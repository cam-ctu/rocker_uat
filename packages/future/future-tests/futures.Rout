
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:46:44.362] plan(): Setting new future strategy stack:
[17:46:44.363] List of future strategies:
[17:46:44.363] 1. sequential:
[17:46:44.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.363]    - tweaked: FALSE
[17:46:44.363]    - call: future::plan("sequential")
[17:46:44.374] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[17:46:44.430] plan(): Setting new future strategy stack:
[17:46:44.430] List of future strategies:
[17:46:44.430] 1. sequential:
[17:46:44.430]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.430]    - tweaked: FALSE
[17:46:44.430]    - call: plan(strategy)
[17:46:44.441] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:46:44.442] getGlobalsAndPackages() ...
[17:46:44.442] Searching for globals...
[17:46:44.445] 
[17:46:44.445] Searching for globals ... DONE
[17:46:44.445] - globals: [0] <none>
[17:46:44.445] getGlobalsAndPackages() ... DONE
[17:46:44.446] run() for ‘Future’ ...
[17:46:44.446] - state: ‘created’
[17:46:44.446] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.447] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.447]   - Field: ‘label’
[17:46:44.447]   - Field: ‘local’
[17:46:44.447]   - Field: ‘owner’
[17:46:44.447]   - Field: ‘envir’
[17:46:44.447]   - Field: ‘packages’
[17:46:44.447]   - Field: ‘gc’
[17:46:44.448]   - Field: ‘conditions’
[17:46:44.448]   - Field: ‘expr’
[17:46:44.448]   - Field: ‘uuid’
[17:46:44.448]   - Field: ‘seed’
[17:46:44.448]   - Field: ‘version’
[17:46:44.448]   - Field: ‘result’
[17:46:44.448]   - Field: ‘asynchronous’
[17:46:44.448]   - Field: ‘calls’
[17:46:44.448]   - Field: ‘globals’
[17:46:44.448]   - Field: ‘stdout’
[17:46:44.448]   - Field: ‘earlySignal’
[17:46:44.449]   - Field: ‘lazy’
[17:46:44.449]   - Field: ‘state’
[17:46:44.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.449] - Launch lazy future ...
[17:46:44.449] Packages needed by the future expression (n = 0): <none>
[17:46:44.450] Packages needed by future strategies (n = 0): <none>
[17:46:44.450] {
[17:46:44.450]     {
[17:46:44.450]         {
[17:46:44.450]             ...future.startTime <- base::Sys.time()
[17:46:44.450]             {
[17:46:44.450]                 {
[17:46:44.450]                   {
[17:46:44.450]                     base::local({
[17:46:44.450]                       has_future <- base::requireNamespace("future", 
[17:46:44.450]                         quietly = TRUE)
[17:46:44.450]                       if (has_future) {
[17:46:44.450]                         ns <- base::getNamespace("future")
[17:46:44.450]                         version <- ns[[".package"]][["version"]]
[17:46:44.450]                         if (is.null(version)) 
[17:46:44.450]                           version <- utils::packageVersion("future")
[17:46:44.450]                       }
[17:46:44.450]                       else {
[17:46:44.450]                         version <- NULL
[17:46:44.450]                       }
[17:46:44.450]                       if (!has_future || version < "1.8.0") {
[17:46:44.450]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.450]                           "", base::R.version$version.string), 
[17:46:44.450]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.450]                             "release", "version")], collapse = " "), 
[17:46:44.450]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.450]                           info)
[17:46:44.450]                         info <- base::paste(info, collapse = "; ")
[17:46:44.450]                         if (!has_future) {
[17:46:44.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.450]                             info)
[17:46:44.450]                         }
[17:46:44.450]                         else {
[17:46:44.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.450]                             info, version)
[17:46:44.450]                         }
[17:46:44.450]                         base::stop(msg)
[17:46:44.450]                       }
[17:46:44.450]                     })
[17:46:44.450]                   }
[17:46:44.450]                   ...future.strategy.old <- future::plan("list")
[17:46:44.450]                   options(future.plan = NULL)
[17:46:44.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.450]                 }
[17:46:44.450]                 ...future.workdir <- getwd()
[17:46:44.450]             }
[17:46:44.450]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.450]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.450]         }
[17:46:44.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.450]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.450]             base::names(...future.oldOptions))
[17:46:44.450]     }
[17:46:44.450]     if (FALSE) {
[17:46:44.450]     }
[17:46:44.450]     else {
[17:46:44.450]         if (TRUE) {
[17:46:44.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.450]                 open = "w")
[17:46:44.450]         }
[17:46:44.450]         else {
[17:46:44.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.450]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.450]         }
[17:46:44.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.450]             base::sink(type = "output", split = FALSE)
[17:46:44.450]             base::close(...future.stdout)
[17:46:44.450]         }, add = TRUE)
[17:46:44.450]     }
[17:46:44.450]     ...future.frame <- base::sys.nframe()
[17:46:44.450]     ...future.conditions <- base::list()
[17:46:44.450]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.450]     if (FALSE) {
[17:46:44.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.450]     }
[17:46:44.450]     ...future.result <- base::tryCatch({
[17:46:44.450]         base::withCallingHandlers({
[17:46:44.450]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.450]             future::FutureResult(value = ...future.value$value, 
[17:46:44.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.450]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.450]                     ...future.globalenv.names))
[17:46:44.450]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.450]         }, condition = base::local({
[17:46:44.450]             c <- base::c
[17:46:44.450]             inherits <- base::inherits
[17:46:44.450]             invokeRestart <- base::invokeRestart
[17:46:44.450]             length <- base::length
[17:46:44.450]             list <- base::list
[17:46:44.450]             seq.int <- base::seq.int
[17:46:44.450]             signalCondition <- base::signalCondition
[17:46:44.450]             sys.calls <- base::sys.calls
[17:46:44.450]             `[[` <- base::`[[`
[17:46:44.450]             `+` <- base::`+`
[17:46:44.450]             `<<-` <- base::`<<-`
[17:46:44.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.450]                   3L)]
[17:46:44.450]             }
[17:46:44.450]             function(cond) {
[17:46:44.450]                 is_error <- inherits(cond, "error")
[17:46:44.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.450]                   NULL)
[17:46:44.450]                 if (is_error) {
[17:46:44.450]                   sessionInformation <- function() {
[17:46:44.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.450]                       search = base::search(), system = base::Sys.info())
[17:46:44.450]                   }
[17:46:44.450]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.450]                     cond$call), session = sessionInformation(), 
[17:46:44.450]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.450]                   signalCondition(cond)
[17:46:44.450]                 }
[17:46:44.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.450]                 "immediateCondition"))) {
[17:46:44.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.450]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.450]                   if (TRUE && !signal) {
[17:46:44.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.450]                     {
[17:46:44.450]                       inherits <- base::inherits
[17:46:44.450]                       invokeRestart <- base::invokeRestart
[17:46:44.450]                       is.null <- base::is.null
[17:46:44.450]                       muffled <- FALSE
[17:46:44.450]                       if (inherits(cond, "message")) {
[17:46:44.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.450]                         if (muffled) 
[17:46:44.450]                           invokeRestart("muffleMessage")
[17:46:44.450]                       }
[17:46:44.450]                       else if (inherits(cond, "warning")) {
[17:46:44.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.450]                         if (muffled) 
[17:46:44.450]                           invokeRestart("muffleWarning")
[17:46:44.450]                       }
[17:46:44.450]                       else if (inherits(cond, "condition")) {
[17:46:44.450]                         if (!is.null(pattern)) {
[17:46:44.450]                           computeRestarts <- base::computeRestarts
[17:46:44.450]                           grepl <- base::grepl
[17:46:44.450]                           restarts <- computeRestarts(cond)
[17:46:44.450]                           for (restart in restarts) {
[17:46:44.450]                             name <- restart$name
[17:46:44.450]                             if (is.null(name)) 
[17:46:44.450]                               next
[17:46:44.450]                             if (!grepl(pattern, name)) 
[17:46:44.450]                               next
[17:46:44.450]                             invokeRestart(restart)
[17:46:44.450]                             muffled <- TRUE
[17:46:44.450]                             break
[17:46:44.450]                           }
[17:46:44.450]                         }
[17:46:44.450]                       }
[17:46:44.450]                       invisible(muffled)
[17:46:44.450]                     }
[17:46:44.450]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.450]                   }
[17:46:44.450]                 }
[17:46:44.450]                 else {
[17:46:44.450]                   if (TRUE) {
[17:46:44.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.450]                     {
[17:46:44.450]                       inherits <- base::inherits
[17:46:44.450]                       invokeRestart <- base::invokeRestart
[17:46:44.450]                       is.null <- base::is.null
[17:46:44.450]                       muffled <- FALSE
[17:46:44.450]                       if (inherits(cond, "message")) {
[17:46:44.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.450]                         if (muffled) 
[17:46:44.450]                           invokeRestart("muffleMessage")
[17:46:44.450]                       }
[17:46:44.450]                       else if (inherits(cond, "warning")) {
[17:46:44.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.450]                         if (muffled) 
[17:46:44.450]                           invokeRestart("muffleWarning")
[17:46:44.450]                       }
[17:46:44.450]                       else if (inherits(cond, "condition")) {
[17:46:44.450]                         if (!is.null(pattern)) {
[17:46:44.450]                           computeRestarts <- base::computeRestarts
[17:46:44.450]                           grepl <- base::grepl
[17:46:44.450]                           restarts <- computeRestarts(cond)
[17:46:44.450]                           for (restart in restarts) {
[17:46:44.450]                             name <- restart$name
[17:46:44.450]                             if (is.null(name)) 
[17:46:44.450]                               next
[17:46:44.450]                             if (!grepl(pattern, name)) 
[17:46:44.450]                               next
[17:46:44.450]                             invokeRestart(restart)
[17:46:44.450]                             muffled <- TRUE
[17:46:44.450]                             break
[17:46:44.450]                           }
[17:46:44.450]                         }
[17:46:44.450]                       }
[17:46:44.450]                       invisible(muffled)
[17:46:44.450]                     }
[17:46:44.450]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.450]                   }
[17:46:44.450]                 }
[17:46:44.450]             }
[17:46:44.450]         }))
[17:46:44.450]     }, error = function(ex) {
[17:46:44.450]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.450]                 ...future.rng), started = ...future.startTime, 
[17:46:44.450]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.450]             version = "1.8"), class = "FutureResult")
[17:46:44.450]     }, finally = {
[17:46:44.450]         if (!identical(...future.workdir, getwd())) 
[17:46:44.450]             setwd(...future.workdir)
[17:46:44.450]         {
[17:46:44.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.450]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.450]             }
[17:46:44.450]             base::options(...future.oldOptions)
[17:46:44.450]             if (.Platform$OS.type == "windows") {
[17:46:44.450]                 old_names <- names(...future.oldEnvVars)
[17:46:44.450]                 envs <- base::Sys.getenv()
[17:46:44.450]                 names <- names(envs)
[17:46:44.450]                 common <- intersect(names, old_names)
[17:46:44.450]                 added <- setdiff(names, old_names)
[17:46:44.450]                 removed <- setdiff(old_names, names)
[17:46:44.450]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.450]                   envs[common]]
[17:46:44.450]                 NAMES <- toupper(changed)
[17:46:44.450]                 args <- list()
[17:46:44.450]                 for (kk in seq_along(NAMES)) {
[17:46:44.450]                   name <- changed[[kk]]
[17:46:44.450]                   NAME <- NAMES[[kk]]
[17:46:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.450]                     next
[17:46:44.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.450]                 }
[17:46:44.450]                 NAMES <- toupper(added)
[17:46:44.450]                 for (kk in seq_along(NAMES)) {
[17:46:44.450]                   name <- added[[kk]]
[17:46:44.450]                   NAME <- NAMES[[kk]]
[17:46:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.450]                     next
[17:46:44.450]                   args[[name]] <- ""
[17:46:44.450]                 }
[17:46:44.450]                 NAMES <- toupper(removed)
[17:46:44.450]                 for (kk in seq_along(NAMES)) {
[17:46:44.450]                   name <- removed[[kk]]
[17:46:44.450]                   NAME <- NAMES[[kk]]
[17:46:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.450]                     next
[17:46:44.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.450]                 }
[17:46:44.450]                 if (length(args) > 0) 
[17:46:44.450]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.450]             }
[17:46:44.450]             else {
[17:46:44.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.450]             }
[17:46:44.450]             {
[17:46:44.450]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.450]                   0L) {
[17:46:44.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.450]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.450]                   base::options(opts)
[17:46:44.450]                 }
[17:46:44.450]                 {
[17:46:44.450]                   {
[17:46:44.450]                     NULL
[17:46:44.450]                     RNGkind("Mersenne-Twister")
[17:46:44.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.450]                       inherits = FALSE)
[17:46:44.450]                   }
[17:46:44.450]                   options(future.plan = NULL)
[17:46:44.450]                   if (is.na(NA_character_)) 
[17:46:44.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.450]                     .init = FALSE)
[17:46:44.450]                 }
[17:46:44.450]             }
[17:46:44.450]         }
[17:46:44.450]     })
[17:46:44.450]     if (TRUE) {
[17:46:44.450]         base::sink(type = "output", split = FALSE)
[17:46:44.450]         if (TRUE) {
[17:46:44.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.450]         }
[17:46:44.450]         else {
[17:46:44.450]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.450]         }
[17:46:44.450]         base::close(...future.stdout)
[17:46:44.450]         ...future.stdout <- NULL
[17:46:44.450]     }
[17:46:44.450]     ...future.result$conditions <- ...future.conditions
[17:46:44.450]     ...future.result$finished <- base::Sys.time()
[17:46:44.450]     ...future.result
[17:46:44.450] }
[17:46:44.452] plan(): Setting new future strategy stack:
[17:46:44.452] List of future strategies:
[17:46:44.452] 1. sequential:
[17:46:44.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.452]    - tweaked: FALSE
[17:46:44.452]    - call: NULL
[17:46:44.453] plan(): nbrOfWorkers() = 1
[17:46:44.454] plan(): Setting new future strategy stack:
[17:46:44.454] List of future strategies:
[17:46:44.454] 1. sequential:
[17:46:44.454]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.454]    - tweaked: FALSE
[17:46:44.454]    - call: plan(strategy)
[17:46:44.454] plan(): nbrOfWorkers() = 1
[17:46:44.454] SequentialFuture started (and completed)
[17:46:44.455] - Launch lazy future ... done
[17:46:44.455] run() for ‘SequentialFuture’ ... done
[17:46:44.455] getGlobalsAndPackages() ...
[17:46:44.455] Searching for globals...
[17:46:44.456] 
[17:46:44.456] Searching for globals ... DONE
[17:46:44.456] - globals: [0] <none>
[17:46:44.456] getGlobalsAndPackages() ... DONE
[17:46:44.456] run() for ‘Future’ ...
[17:46:44.456] - state: ‘created’
[17:46:44.456] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.456] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.457]   - Field: ‘label’
[17:46:44.457]   - Field: ‘local’
[17:46:44.457]   - Field: ‘owner’
[17:46:44.457]   - Field: ‘envir’
[17:46:44.457]   - Field: ‘packages’
[17:46:44.457]   - Field: ‘gc’
[17:46:44.457]   - Field: ‘conditions’
[17:46:44.457]   - Field: ‘expr’
[17:46:44.457]   - Field: ‘uuid’
[17:46:44.457]   - Field: ‘seed’
[17:46:44.458]   - Field: ‘version’
[17:46:44.458]   - Field: ‘result’
[17:46:44.458]   - Field: ‘asynchronous’
[17:46:44.458]   - Field: ‘calls’
[17:46:44.458]   - Field: ‘globals’
[17:46:44.458]   - Field: ‘stdout’
[17:46:44.458]   - Field: ‘earlySignal’
[17:46:44.458]   - Field: ‘lazy’
[17:46:44.458]   - Field: ‘state’
[17:46:44.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.458] - Launch lazy future ...
[17:46:44.459] Packages needed by the future expression (n = 0): <none>
[17:46:44.459] Packages needed by future strategies (n = 0): <none>
[17:46:44.459] {
[17:46:44.459]     {
[17:46:44.459]         {
[17:46:44.459]             ...future.startTime <- base::Sys.time()
[17:46:44.459]             {
[17:46:44.459]                 {
[17:46:44.459]                   {
[17:46:44.459]                     base::local({
[17:46:44.459]                       has_future <- base::requireNamespace("future", 
[17:46:44.459]                         quietly = TRUE)
[17:46:44.459]                       if (has_future) {
[17:46:44.459]                         ns <- base::getNamespace("future")
[17:46:44.459]                         version <- ns[[".package"]][["version"]]
[17:46:44.459]                         if (is.null(version)) 
[17:46:44.459]                           version <- utils::packageVersion("future")
[17:46:44.459]                       }
[17:46:44.459]                       else {
[17:46:44.459]                         version <- NULL
[17:46:44.459]                       }
[17:46:44.459]                       if (!has_future || version < "1.8.0") {
[17:46:44.459]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.459]                           "", base::R.version$version.string), 
[17:46:44.459]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.459]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.459]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.459]                             "release", "version")], collapse = " "), 
[17:46:44.459]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.459]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.459]                           info)
[17:46:44.459]                         info <- base::paste(info, collapse = "; ")
[17:46:44.459]                         if (!has_future) {
[17:46:44.459]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.459]                             info)
[17:46:44.459]                         }
[17:46:44.459]                         else {
[17:46:44.459]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.459]                             info, version)
[17:46:44.459]                         }
[17:46:44.459]                         base::stop(msg)
[17:46:44.459]                       }
[17:46:44.459]                     })
[17:46:44.459]                   }
[17:46:44.459]                   ...future.strategy.old <- future::plan("list")
[17:46:44.459]                   options(future.plan = NULL)
[17:46:44.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.459]                 }
[17:46:44.459]                 ...future.workdir <- getwd()
[17:46:44.459]             }
[17:46:44.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.459]         }
[17:46:44.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.459]             base::names(...future.oldOptions))
[17:46:44.459]     }
[17:46:44.459]     if (FALSE) {
[17:46:44.459]     }
[17:46:44.459]     else {
[17:46:44.459]         if (TRUE) {
[17:46:44.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.459]                 open = "w")
[17:46:44.459]         }
[17:46:44.459]         else {
[17:46:44.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.459]         }
[17:46:44.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.459]             base::sink(type = "output", split = FALSE)
[17:46:44.459]             base::close(...future.stdout)
[17:46:44.459]         }, add = TRUE)
[17:46:44.459]     }
[17:46:44.459]     ...future.frame <- base::sys.nframe()
[17:46:44.459]     ...future.conditions <- base::list()
[17:46:44.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.459]     if (FALSE) {
[17:46:44.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.459]     }
[17:46:44.459]     ...future.result <- base::tryCatch({
[17:46:44.459]         base::withCallingHandlers({
[17:46:44.459]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.459]             future::FutureResult(value = ...future.value$value, 
[17:46:44.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.459]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.459]                     ...future.globalenv.names))
[17:46:44.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.459]         }, condition = base::local({
[17:46:44.459]             c <- base::c
[17:46:44.459]             inherits <- base::inherits
[17:46:44.459]             invokeRestart <- base::invokeRestart
[17:46:44.459]             length <- base::length
[17:46:44.459]             list <- base::list
[17:46:44.459]             seq.int <- base::seq.int
[17:46:44.459]             signalCondition <- base::signalCondition
[17:46:44.459]             sys.calls <- base::sys.calls
[17:46:44.459]             `[[` <- base::`[[`
[17:46:44.459]             `+` <- base::`+`
[17:46:44.459]             `<<-` <- base::`<<-`
[17:46:44.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.459]                   3L)]
[17:46:44.459]             }
[17:46:44.459]             function(cond) {
[17:46:44.459]                 is_error <- inherits(cond, "error")
[17:46:44.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.459]                   NULL)
[17:46:44.459]                 if (is_error) {
[17:46:44.459]                   sessionInformation <- function() {
[17:46:44.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.459]                       search = base::search(), system = base::Sys.info())
[17:46:44.459]                   }
[17:46:44.459]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.459]                     cond$call), session = sessionInformation(), 
[17:46:44.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.459]                   signalCondition(cond)
[17:46:44.459]                 }
[17:46:44.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.459]                 "immediateCondition"))) {
[17:46:44.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.459]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.459]                   if (TRUE && !signal) {
[17:46:44.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.459]                     {
[17:46:44.459]                       inherits <- base::inherits
[17:46:44.459]                       invokeRestart <- base::invokeRestart
[17:46:44.459]                       is.null <- base::is.null
[17:46:44.459]                       muffled <- FALSE
[17:46:44.459]                       if (inherits(cond, "message")) {
[17:46:44.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.459]                         if (muffled) 
[17:46:44.459]                           invokeRestart("muffleMessage")
[17:46:44.459]                       }
[17:46:44.459]                       else if (inherits(cond, "warning")) {
[17:46:44.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.459]                         if (muffled) 
[17:46:44.459]                           invokeRestart("muffleWarning")
[17:46:44.459]                       }
[17:46:44.459]                       else if (inherits(cond, "condition")) {
[17:46:44.459]                         if (!is.null(pattern)) {
[17:46:44.459]                           computeRestarts <- base::computeRestarts
[17:46:44.459]                           grepl <- base::grepl
[17:46:44.459]                           restarts <- computeRestarts(cond)
[17:46:44.459]                           for (restart in restarts) {
[17:46:44.459]                             name <- restart$name
[17:46:44.459]                             if (is.null(name)) 
[17:46:44.459]                               next
[17:46:44.459]                             if (!grepl(pattern, name)) 
[17:46:44.459]                               next
[17:46:44.459]                             invokeRestart(restart)
[17:46:44.459]                             muffled <- TRUE
[17:46:44.459]                             break
[17:46:44.459]                           }
[17:46:44.459]                         }
[17:46:44.459]                       }
[17:46:44.459]                       invisible(muffled)
[17:46:44.459]                     }
[17:46:44.459]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.459]                   }
[17:46:44.459]                 }
[17:46:44.459]                 else {
[17:46:44.459]                   if (TRUE) {
[17:46:44.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.459]                     {
[17:46:44.459]                       inherits <- base::inherits
[17:46:44.459]                       invokeRestart <- base::invokeRestart
[17:46:44.459]                       is.null <- base::is.null
[17:46:44.459]                       muffled <- FALSE
[17:46:44.459]                       if (inherits(cond, "message")) {
[17:46:44.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.459]                         if (muffled) 
[17:46:44.459]                           invokeRestart("muffleMessage")
[17:46:44.459]                       }
[17:46:44.459]                       else if (inherits(cond, "warning")) {
[17:46:44.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.459]                         if (muffled) 
[17:46:44.459]                           invokeRestart("muffleWarning")
[17:46:44.459]                       }
[17:46:44.459]                       else if (inherits(cond, "condition")) {
[17:46:44.459]                         if (!is.null(pattern)) {
[17:46:44.459]                           computeRestarts <- base::computeRestarts
[17:46:44.459]                           grepl <- base::grepl
[17:46:44.459]                           restarts <- computeRestarts(cond)
[17:46:44.459]                           for (restart in restarts) {
[17:46:44.459]                             name <- restart$name
[17:46:44.459]                             if (is.null(name)) 
[17:46:44.459]                               next
[17:46:44.459]                             if (!grepl(pattern, name)) 
[17:46:44.459]                               next
[17:46:44.459]                             invokeRestart(restart)
[17:46:44.459]                             muffled <- TRUE
[17:46:44.459]                             break
[17:46:44.459]                           }
[17:46:44.459]                         }
[17:46:44.459]                       }
[17:46:44.459]                       invisible(muffled)
[17:46:44.459]                     }
[17:46:44.459]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.459]                   }
[17:46:44.459]                 }
[17:46:44.459]             }
[17:46:44.459]         }))
[17:46:44.459]     }, error = function(ex) {
[17:46:44.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.459]                 ...future.rng), started = ...future.startTime, 
[17:46:44.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.459]             version = "1.8"), class = "FutureResult")
[17:46:44.459]     }, finally = {
[17:46:44.459]         if (!identical(...future.workdir, getwd())) 
[17:46:44.459]             setwd(...future.workdir)
[17:46:44.459]         {
[17:46:44.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.459]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.459]             }
[17:46:44.459]             base::options(...future.oldOptions)
[17:46:44.459]             if (.Platform$OS.type == "windows") {
[17:46:44.459]                 old_names <- names(...future.oldEnvVars)
[17:46:44.459]                 envs <- base::Sys.getenv()
[17:46:44.459]                 names <- names(envs)
[17:46:44.459]                 common <- intersect(names, old_names)
[17:46:44.459]                 added <- setdiff(names, old_names)
[17:46:44.459]                 removed <- setdiff(old_names, names)
[17:46:44.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.459]                   envs[common]]
[17:46:44.459]                 NAMES <- toupper(changed)
[17:46:44.459]                 args <- list()
[17:46:44.459]                 for (kk in seq_along(NAMES)) {
[17:46:44.459]                   name <- changed[[kk]]
[17:46:44.459]                   NAME <- NAMES[[kk]]
[17:46:44.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.459]                     next
[17:46:44.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.459]                 }
[17:46:44.459]                 NAMES <- toupper(added)
[17:46:44.459]                 for (kk in seq_along(NAMES)) {
[17:46:44.459]                   name <- added[[kk]]
[17:46:44.459]                   NAME <- NAMES[[kk]]
[17:46:44.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.459]                     next
[17:46:44.459]                   args[[name]] <- ""
[17:46:44.459]                 }
[17:46:44.459]                 NAMES <- toupper(removed)
[17:46:44.459]                 for (kk in seq_along(NAMES)) {
[17:46:44.459]                   name <- removed[[kk]]
[17:46:44.459]                   NAME <- NAMES[[kk]]
[17:46:44.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.459]                     next
[17:46:44.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.459]                 }
[17:46:44.459]                 if (length(args) > 0) 
[17:46:44.459]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.459]             }
[17:46:44.459]             else {
[17:46:44.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.459]             }
[17:46:44.459]             {
[17:46:44.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.459]                   0L) {
[17:46:44.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.459]                   base::options(opts)
[17:46:44.459]                 }
[17:46:44.459]                 {
[17:46:44.459]                   {
[17:46:44.459]                     NULL
[17:46:44.459]                     RNGkind("Mersenne-Twister")
[17:46:44.459]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.459]                       inherits = FALSE)
[17:46:44.459]                   }
[17:46:44.459]                   options(future.plan = NULL)
[17:46:44.459]                   if (is.na(NA_character_)) 
[17:46:44.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.459]                     .init = FALSE)
[17:46:44.459]                 }
[17:46:44.459]             }
[17:46:44.459]         }
[17:46:44.459]     })
[17:46:44.459]     if (TRUE) {
[17:46:44.459]         base::sink(type = "output", split = FALSE)
[17:46:44.459]         if (TRUE) {
[17:46:44.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.459]         }
[17:46:44.459]         else {
[17:46:44.459]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.459]         }
[17:46:44.459]         base::close(...future.stdout)
[17:46:44.459]         ...future.stdout <- NULL
[17:46:44.459]     }
[17:46:44.459]     ...future.result$conditions <- ...future.conditions
[17:46:44.459]     ...future.result$finished <- base::Sys.time()
[17:46:44.459]     ...future.result
[17:46:44.459] }
[17:46:44.461] plan(): Setting new future strategy stack:
[17:46:44.461] List of future strategies:
[17:46:44.461] 1. sequential:
[17:46:44.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.461]    - tweaked: FALSE
[17:46:44.461]    - call: NULL
[17:46:44.461] plan(): nbrOfWorkers() = 1
[17:46:44.462] plan(): Setting new future strategy stack:
[17:46:44.462] List of future strategies:
[17:46:44.462] 1. sequential:
[17:46:44.462]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.462]    - tweaked: FALSE
[17:46:44.462]    - call: plan(strategy)
[17:46:44.463] plan(): nbrOfWorkers() = 1
[17:46:44.463] SequentialFuture started (and completed)
[17:46:44.463] - Launch lazy future ... done
[17:46:44.463] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56178652a850> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5617862e4378> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56178652a850> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5617862e4378> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:46:44.469] resolved() for ‘SequentialFuture’ ...
[17:46:44.469] - state: ‘finished’
[17:46:44.469] - run: TRUE
[17:46:44.469] - result: ‘FutureResult’
[17:46:44.469] resolved() for ‘SequentialFuture’ ... done
[17:46:44.469] resolved() for ‘SequentialFuture’ ...
[17:46:44.469] - state: ‘finished’
[17:46:44.470] - run: TRUE
[17:46:44.470] - result: ‘FutureResult’
[17:46:44.470] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:44.471] resolve() on list ...
[17:46:44.471]  recursive: 0
[17:46:44.471]  length: 6
[17:46:44.471]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:44.471] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.471] - nx: 6
[17:46:44.471] - relay: TRUE
[17:46:44.472] - stdout: TRUE
[17:46:44.472] - signal: TRUE
[17:46:44.472] - resignal: FALSE
[17:46:44.472] - force: TRUE
[17:46:44.472] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.472] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.472]  - until=2
[17:46:44.472]  - relaying element #2
[17:46:44.472] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.472] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.472] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.472]  length: 5 (resolved future 1)
[17:46:44.473] resolved() for ‘SequentialFuture’ ...
[17:46:44.473] - state: ‘finished’
[17:46:44.473] - run: TRUE
[17:46:44.473] - result: ‘FutureResult’
[17:46:44.473] resolved() for ‘SequentialFuture’ ... done
[17:46:44.473] Future #2
[17:46:44.473] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.474] - nx: 6
[17:46:44.474] - relay: TRUE
[17:46:44.474] - stdout: TRUE
[17:46:44.474] - signal: TRUE
[17:46:44.474] - resignal: FALSE
[17:46:44.474] - force: TRUE
[17:46:44.474] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.474] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.474]  - until=2
[17:46:44.474]  - relaying element #2
[17:46:44.474] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.475] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.475] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.475]  length: 4 (resolved future 2)
[17:46:44.475] resolved() for ‘SequentialFuture’ ...
[17:46:44.475] - state: ‘finished’
[17:46:44.475] - run: TRUE
[17:46:44.475] - result: ‘FutureResult’
[17:46:44.475] resolved() for ‘SequentialFuture’ ... done
[17:46:44.475] Future #3
[17:46:44.476] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.476] - nx: 6
[17:46:44.476] - relay: TRUE
[17:46:44.476] - stdout: TRUE
[17:46:44.476] - signal: TRUE
[17:46:44.476] - resignal: FALSE
[17:46:44.476] - force: TRUE
[17:46:44.476] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.476] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.476]  - until=3
[17:46:44.476]  - relaying element #3
[17:46:44.477] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.477] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.477] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.477]  length: 3 (resolved future 3)
[17:46:44.477] signalConditionsASAP(NULL, pos=4) ...
[17:46:44.477] - nx: 6
[17:46:44.477] - relay: TRUE
[17:46:44.477] - stdout: TRUE
[17:46:44.477] - signal: TRUE
[17:46:44.477] - resignal: FALSE
[17:46:44.477] - force: TRUE
[17:46:44.478] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.478] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.478]  - until=5
[17:46:44.478]  - relaying element #5
[17:46:44.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.478] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.478] signalConditionsASAP(NULL, pos=4) ... done
[17:46:44.478]  length: 2 (resolved future 4)
[17:46:44.478] signalConditionsASAP(NULL, pos=5) ...
[17:46:44.478] - nx: 6
[17:46:44.478] - relay: TRUE
[17:46:44.479] - stdout: TRUE
[17:46:44.479] - signal: TRUE
[17:46:44.479] - resignal: FALSE
[17:46:44.479] - force: TRUE
[17:46:44.479] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.479] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.479]  - until=6
[17:46:44.479]  - relaying element #6
[17:46:44.479] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.479] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.479] signalConditionsASAP(NULL, pos=5) ... done
[17:46:44.479]  length: 1 (resolved future 5)
[17:46:44.480] signalConditionsASAP(numeric, pos=6) ...
[17:46:44.480] - nx: 6
[17:46:44.480] - relay: TRUE
[17:46:44.482] - stdout: TRUE
[17:46:44.482] - signal: TRUE
[17:46:44.482] - resignal: FALSE
[17:46:44.482] - force: TRUE
[17:46:44.483] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.483] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.483]  - until=6
[17:46:44.483] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.483] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.483] signalConditionsASAP(numeric, pos=6) ... done
[17:46:44.483]  length: 0 (resolved future 6)
[17:46:44.483] Relaying remaining futures
[17:46:44.483] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.483] - nx: 6
[17:46:44.483] - relay: TRUE
[17:46:44.484] - stdout: TRUE
[17:46:44.484] - signal: TRUE
[17:46:44.484] - resignal: FALSE
[17:46:44.484] - force: TRUE
[17:46:44.484] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:44.484] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.484] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.484] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:46:44.487] getGlobalsAndPackages() ...
[17:46:44.487] Searching for globals...
[17:46:44.487] 
[17:46:44.487] Searching for globals ... DONE
[17:46:44.487] - globals: [0] <none>
[17:46:44.487] getGlobalsAndPackages() ... DONE
[17:46:44.487] run() for ‘Future’ ...
[17:46:44.488] - state: ‘created’
[17:46:44.488] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.488] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.488]   - Field: ‘label’
[17:46:44.488]   - Field: ‘local’
[17:46:44.488]   - Field: ‘owner’
[17:46:44.488]   - Field: ‘envir’
[17:46:44.489]   - Field: ‘packages’
[17:46:44.489]   - Field: ‘gc’
[17:46:44.489]   - Field: ‘conditions’
[17:46:44.489]   - Field: ‘expr’
[17:46:44.489]   - Field: ‘uuid’
[17:46:44.489]   - Field: ‘seed’
[17:46:44.489]   - Field: ‘version’
[17:46:44.489]   - Field: ‘result’
[17:46:44.489]   - Field: ‘asynchronous’
[17:46:44.489]   - Field: ‘calls’
[17:46:44.489]   - Field: ‘globals’
[17:46:44.490]   - Field: ‘stdout’
[17:46:44.490]   - Field: ‘earlySignal’
[17:46:44.490]   - Field: ‘lazy’
[17:46:44.490]   - Field: ‘state’
[17:46:44.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.490] - Launch lazy future ...
[17:46:44.490] Packages needed by the future expression (n = 0): <none>
[17:46:44.490] Packages needed by future strategies (n = 0): <none>
[17:46:44.491] {
[17:46:44.491]     {
[17:46:44.491]         {
[17:46:44.491]             ...future.startTime <- base::Sys.time()
[17:46:44.491]             {
[17:46:44.491]                 {
[17:46:44.491]                   {
[17:46:44.491]                     base::local({
[17:46:44.491]                       has_future <- base::requireNamespace("future", 
[17:46:44.491]                         quietly = TRUE)
[17:46:44.491]                       if (has_future) {
[17:46:44.491]                         ns <- base::getNamespace("future")
[17:46:44.491]                         version <- ns[[".package"]][["version"]]
[17:46:44.491]                         if (is.null(version)) 
[17:46:44.491]                           version <- utils::packageVersion("future")
[17:46:44.491]                       }
[17:46:44.491]                       else {
[17:46:44.491]                         version <- NULL
[17:46:44.491]                       }
[17:46:44.491]                       if (!has_future || version < "1.8.0") {
[17:46:44.491]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.491]                           "", base::R.version$version.string), 
[17:46:44.491]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.491]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.491]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.491]                             "release", "version")], collapse = " "), 
[17:46:44.491]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.491]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.491]                           info)
[17:46:44.491]                         info <- base::paste(info, collapse = "; ")
[17:46:44.491]                         if (!has_future) {
[17:46:44.491]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.491]                             info)
[17:46:44.491]                         }
[17:46:44.491]                         else {
[17:46:44.491]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.491]                             info, version)
[17:46:44.491]                         }
[17:46:44.491]                         base::stop(msg)
[17:46:44.491]                       }
[17:46:44.491]                     })
[17:46:44.491]                   }
[17:46:44.491]                   ...future.strategy.old <- future::plan("list")
[17:46:44.491]                   options(future.plan = NULL)
[17:46:44.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.491]                 }
[17:46:44.491]                 ...future.workdir <- getwd()
[17:46:44.491]             }
[17:46:44.491]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.491]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.491]         }
[17:46:44.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.491]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.491]             base::names(...future.oldOptions))
[17:46:44.491]     }
[17:46:44.491]     if (FALSE) {
[17:46:44.491]     }
[17:46:44.491]     else {
[17:46:44.491]         if (TRUE) {
[17:46:44.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.491]                 open = "w")
[17:46:44.491]         }
[17:46:44.491]         else {
[17:46:44.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.491]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.491]         }
[17:46:44.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.491]             base::sink(type = "output", split = FALSE)
[17:46:44.491]             base::close(...future.stdout)
[17:46:44.491]         }, add = TRUE)
[17:46:44.491]     }
[17:46:44.491]     ...future.frame <- base::sys.nframe()
[17:46:44.491]     ...future.conditions <- base::list()
[17:46:44.491]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.491]     if (FALSE) {
[17:46:44.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.491]     }
[17:46:44.491]     ...future.result <- base::tryCatch({
[17:46:44.491]         base::withCallingHandlers({
[17:46:44.491]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.491]             future::FutureResult(value = ...future.value$value, 
[17:46:44.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.491]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.491]                     ...future.globalenv.names))
[17:46:44.491]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.491]         }, condition = base::local({
[17:46:44.491]             c <- base::c
[17:46:44.491]             inherits <- base::inherits
[17:46:44.491]             invokeRestart <- base::invokeRestart
[17:46:44.491]             length <- base::length
[17:46:44.491]             list <- base::list
[17:46:44.491]             seq.int <- base::seq.int
[17:46:44.491]             signalCondition <- base::signalCondition
[17:46:44.491]             sys.calls <- base::sys.calls
[17:46:44.491]             `[[` <- base::`[[`
[17:46:44.491]             `+` <- base::`+`
[17:46:44.491]             `<<-` <- base::`<<-`
[17:46:44.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.491]                   3L)]
[17:46:44.491]             }
[17:46:44.491]             function(cond) {
[17:46:44.491]                 is_error <- inherits(cond, "error")
[17:46:44.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.491]                   NULL)
[17:46:44.491]                 if (is_error) {
[17:46:44.491]                   sessionInformation <- function() {
[17:46:44.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.491]                       search = base::search(), system = base::Sys.info())
[17:46:44.491]                   }
[17:46:44.491]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.491]                     cond$call), session = sessionInformation(), 
[17:46:44.491]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.491]                   signalCondition(cond)
[17:46:44.491]                 }
[17:46:44.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.491]                 "immediateCondition"))) {
[17:46:44.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.491]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.491]                   if (TRUE && !signal) {
[17:46:44.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.491]                     {
[17:46:44.491]                       inherits <- base::inherits
[17:46:44.491]                       invokeRestart <- base::invokeRestart
[17:46:44.491]                       is.null <- base::is.null
[17:46:44.491]                       muffled <- FALSE
[17:46:44.491]                       if (inherits(cond, "message")) {
[17:46:44.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.491]                         if (muffled) 
[17:46:44.491]                           invokeRestart("muffleMessage")
[17:46:44.491]                       }
[17:46:44.491]                       else if (inherits(cond, "warning")) {
[17:46:44.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.491]                         if (muffled) 
[17:46:44.491]                           invokeRestart("muffleWarning")
[17:46:44.491]                       }
[17:46:44.491]                       else if (inherits(cond, "condition")) {
[17:46:44.491]                         if (!is.null(pattern)) {
[17:46:44.491]                           computeRestarts <- base::computeRestarts
[17:46:44.491]                           grepl <- base::grepl
[17:46:44.491]                           restarts <- computeRestarts(cond)
[17:46:44.491]                           for (restart in restarts) {
[17:46:44.491]                             name <- restart$name
[17:46:44.491]                             if (is.null(name)) 
[17:46:44.491]                               next
[17:46:44.491]                             if (!grepl(pattern, name)) 
[17:46:44.491]                               next
[17:46:44.491]                             invokeRestart(restart)
[17:46:44.491]                             muffled <- TRUE
[17:46:44.491]                             break
[17:46:44.491]                           }
[17:46:44.491]                         }
[17:46:44.491]                       }
[17:46:44.491]                       invisible(muffled)
[17:46:44.491]                     }
[17:46:44.491]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.491]                   }
[17:46:44.491]                 }
[17:46:44.491]                 else {
[17:46:44.491]                   if (TRUE) {
[17:46:44.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.491]                     {
[17:46:44.491]                       inherits <- base::inherits
[17:46:44.491]                       invokeRestart <- base::invokeRestart
[17:46:44.491]                       is.null <- base::is.null
[17:46:44.491]                       muffled <- FALSE
[17:46:44.491]                       if (inherits(cond, "message")) {
[17:46:44.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.491]                         if (muffled) 
[17:46:44.491]                           invokeRestart("muffleMessage")
[17:46:44.491]                       }
[17:46:44.491]                       else if (inherits(cond, "warning")) {
[17:46:44.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.491]                         if (muffled) 
[17:46:44.491]                           invokeRestart("muffleWarning")
[17:46:44.491]                       }
[17:46:44.491]                       else if (inherits(cond, "condition")) {
[17:46:44.491]                         if (!is.null(pattern)) {
[17:46:44.491]                           computeRestarts <- base::computeRestarts
[17:46:44.491]                           grepl <- base::grepl
[17:46:44.491]                           restarts <- computeRestarts(cond)
[17:46:44.491]                           for (restart in restarts) {
[17:46:44.491]                             name <- restart$name
[17:46:44.491]                             if (is.null(name)) 
[17:46:44.491]                               next
[17:46:44.491]                             if (!grepl(pattern, name)) 
[17:46:44.491]                               next
[17:46:44.491]                             invokeRestart(restart)
[17:46:44.491]                             muffled <- TRUE
[17:46:44.491]                             break
[17:46:44.491]                           }
[17:46:44.491]                         }
[17:46:44.491]                       }
[17:46:44.491]                       invisible(muffled)
[17:46:44.491]                     }
[17:46:44.491]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.491]                   }
[17:46:44.491]                 }
[17:46:44.491]             }
[17:46:44.491]         }))
[17:46:44.491]     }, error = function(ex) {
[17:46:44.491]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.491]                 ...future.rng), started = ...future.startTime, 
[17:46:44.491]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.491]             version = "1.8"), class = "FutureResult")
[17:46:44.491]     }, finally = {
[17:46:44.491]         if (!identical(...future.workdir, getwd())) 
[17:46:44.491]             setwd(...future.workdir)
[17:46:44.491]         {
[17:46:44.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.491]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.491]             }
[17:46:44.491]             base::options(...future.oldOptions)
[17:46:44.491]             if (.Platform$OS.type == "windows") {
[17:46:44.491]                 old_names <- names(...future.oldEnvVars)
[17:46:44.491]                 envs <- base::Sys.getenv()
[17:46:44.491]                 names <- names(envs)
[17:46:44.491]                 common <- intersect(names, old_names)
[17:46:44.491]                 added <- setdiff(names, old_names)
[17:46:44.491]                 removed <- setdiff(old_names, names)
[17:46:44.491]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.491]                   envs[common]]
[17:46:44.491]                 NAMES <- toupper(changed)
[17:46:44.491]                 args <- list()
[17:46:44.491]                 for (kk in seq_along(NAMES)) {
[17:46:44.491]                   name <- changed[[kk]]
[17:46:44.491]                   NAME <- NAMES[[kk]]
[17:46:44.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.491]                     next
[17:46:44.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.491]                 }
[17:46:44.491]                 NAMES <- toupper(added)
[17:46:44.491]                 for (kk in seq_along(NAMES)) {
[17:46:44.491]                   name <- added[[kk]]
[17:46:44.491]                   NAME <- NAMES[[kk]]
[17:46:44.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.491]                     next
[17:46:44.491]                   args[[name]] <- ""
[17:46:44.491]                 }
[17:46:44.491]                 NAMES <- toupper(removed)
[17:46:44.491]                 for (kk in seq_along(NAMES)) {
[17:46:44.491]                   name <- removed[[kk]]
[17:46:44.491]                   NAME <- NAMES[[kk]]
[17:46:44.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.491]                     next
[17:46:44.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.491]                 }
[17:46:44.491]                 if (length(args) > 0) 
[17:46:44.491]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.491]             }
[17:46:44.491]             else {
[17:46:44.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.491]             }
[17:46:44.491]             {
[17:46:44.491]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.491]                   0L) {
[17:46:44.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.491]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.491]                   base::options(opts)
[17:46:44.491]                 }
[17:46:44.491]                 {
[17:46:44.491]                   {
[17:46:44.491]                     NULL
[17:46:44.491]                     RNGkind("Mersenne-Twister")
[17:46:44.491]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.491]                       inherits = FALSE)
[17:46:44.491]                   }
[17:46:44.491]                   options(future.plan = NULL)
[17:46:44.491]                   if (is.na(NA_character_)) 
[17:46:44.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.491]                     .init = FALSE)
[17:46:44.491]                 }
[17:46:44.491]             }
[17:46:44.491]         }
[17:46:44.491]     })
[17:46:44.491]     if (TRUE) {
[17:46:44.491]         base::sink(type = "output", split = FALSE)
[17:46:44.491]         if (TRUE) {
[17:46:44.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.491]         }
[17:46:44.491]         else {
[17:46:44.491]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.491]         }
[17:46:44.491]         base::close(...future.stdout)
[17:46:44.491]         ...future.stdout <- NULL
[17:46:44.491]     }
[17:46:44.491]     ...future.result$conditions <- ...future.conditions
[17:46:44.491]     ...future.result$finished <- base::Sys.time()
[17:46:44.491]     ...future.result
[17:46:44.491] }
[17:46:44.492] plan(): Setting new future strategy stack:
[17:46:44.493] List of future strategies:
[17:46:44.493] 1. sequential:
[17:46:44.493]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.493]    - tweaked: FALSE
[17:46:44.493]    - call: NULL
[17:46:44.493] plan(): nbrOfWorkers() = 1
[17:46:44.494] plan(): Setting new future strategy stack:
[17:46:44.494] List of future strategies:
[17:46:44.494] 1. sequential:
[17:46:44.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.494]    - tweaked: FALSE
[17:46:44.494]    - call: plan(strategy)
[17:46:44.494] plan(): nbrOfWorkers() = 1
[17:46:44.494] SequentialFuture started (and completed)
[17:46:44.495] - Launch lazy future ... done
[17:46:44.495] run() for ‘SequentialFuture’ ... done
[17:46:44.495] getGlobalsAndPackages() ...
[17:46:44.495] Searching for globals...
[17:46:44.495] 
[17:46:44.495] Searching for globals ... DONE
[17:46:44.495] - globals: [0] <none>
[17:46:44.495] getGlobalsAndPackages() ... DONE
[17:46:44.496] run() for ‘Future’ ...
[17:46:44.496] - state: ‘created’
[17:46:44.496] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.496] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.496]   - Field: ‘label’
[17:46:44.496]   - Field: ‘local’
[17:46:44.497]   - Field: ‘owner’
[17:46:44.497]   - Field: ‘envir’
[17:46:44.497]   - Field: ‘packages’
[17:46:44.497]   - Field: ‘gc’
[17:46:44.497]   - Field: ‘conditions’
[17:46:44.497]   - Field: ‘expr’
[17:46:44.497]   - Field: ‘uuid’
[17:46:44.497]   - Field: ‘seed’
[17:46:44.497]   - Field: ‘version’
[17:46:44.497]   - Field: ‘result’
[17:46:44.497]   - Field: ‘asynchronous’
[17:46:44.498]   - Field: ‘calls’
[17:46:44.498]   - Field: ‘globals’
[17:46:44.498]   - Field: ‘stdout’
[17:46:44.498]   - Field: ‘earlySignal’
[17:46:44.498]   - Field: ‘lazy’
[17:46:44.498]   - Field: ‘state’
[17:46:44.498] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.498] - Launch lazy future ...
[17:46:44.498] Packages needed by the future expression (n = 0): <none>
[17:46:44.498] Packages needed by future strategies (n = 0): <none>
[17:46:44.499] {
[17:46:44.499]     {
[17:46:44.499]         {
[17:46:44.499]             ...future.startTime <- base::Sys.time()
[17:46:44.499]             {
[17:46:44.499]                 {
[17:46:44.499]                   {
[17:46:44.499]                     base::local({
[17:46:44.499]                       has_future <- base::requireNamespace("future", 
[17:46:44.499]                         quietly = TRUE)
[17:46:44.499]                       if (has_future) {
[17:46:44.499]                         ns <- base::getNamespace("future")
[17:46:44.499]                         version <- ns[[".package"]][["version"]]
[17:46:44.499]                         if (is.null(version)) 
[17:46:44.499]                           version <- utils::packageVersion("future")
[17:46:44.499]                       }
[17:46:44.499]                       else {
[17:46:44.499]                         version <- NULL
[17:46:44.499]                       }
[17:46:44.499]                       if (!has_future || version < "1.8.0") {
[17:46:44.499]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.499]                           "", base::R.version$version.string), 
[17:46:44.499]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.499]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.499]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.499]                             "release", "version")], collapse = " "), 
[17:46:44.499]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.499]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.499]                           info)
[17:46:44.499]                         info <- base::paste(info, collapse = "; ")
[17:46:44.499]                         if (!has_future) {
[17:46:44.499]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.499]                             info)
[17:46:44.499]                         }
[17:46:44.499]                         else {
[17:46:44.499]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.499]                             info, version)
[17:46:44.499]                         }
[17:46:44.499]                         base::stop(msg)
[17:46:44.499]                       }
[17:46:44.499]                     })
[17:46:44.499]                   }
[17:46:44.499]                   ...future.strategy.old <- future::plan("list")
[17:46:44.499]                   options(future.plan = NULL)
[17:46:44.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.499]                 }
[17:46:44.499]                 ...future.workdir <- getwd()
[17:46:44.499]             }
[17:46:44.499]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.499]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.499]         }
[17:46:44.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.499]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.499]             base::names(...future.oldOptions))
[17:46:44.499]     }
[17:46:44.499]     if (FALSE) {
[17:46:44.499]     }
[17:46:44.499]     else {
[17:46:44.499]         if (TRUE) {
[17:46:44.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.499]                 open = "w")
[17:46:44.499]         }
[17:46:44.499]         else {
[17:46:44.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.499]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.499]         }
[17:46:44.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.499]             base::sink(type = "output", split = FALSE)
[17:46:44.499]             base::close(...future.stdout)
[17:46:44.499]         }, add = TRUE)
[17:46:44.499]     }
[17:46:44.499]     ...future.frame <- base::sys.nframe()
[17:46:44.499]     ...future.conditions <- base::list()
[17:46:44.499]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.499]     if (FALSE) {
[17:46:44.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.499]     }
[17:46:44.499]     ...future.result <- base::tryCatch({
[17:46:44.499]         base::withCallingHandlers({
[17:46:44.499]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.499]             future::FutureResult(value = ...future.value$value, 
[17:46:44.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.499]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.499]                     ...future.globalenv.names))
[17:46:44.499]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.499]         }, condition = base::local({
[17:46:44.499]             c <- base::c
[17:46:44.499]             inherits <- base::inherits
[17:46:44.499]             invokeRestart <- base::invokeRestart
[17:46:44.499]             length <- base::length
[17:46:44.499]             list <- base::list
[17:46:44.499]             seq.int <- base::seq.int
[17:46:44.499]             signalCondition <- base::signalCondition
[17:46:44.499]             sys.calls <- base::sys.calls
[17:46:44.499]             `[[` <- base::`[[`
[17:46:44.499]             `+` <- base::`+`
[17:46:44.499]             `<<-` <- base::`<<-`
[17:46:44.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.499]                   3L)]
[17:46:44.499]             }
[17:46:44.499]             function(cond) {
[17:46:44.499]                 is_error <- inherits(cond, "error")
[17:46:44.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.499]                   NULL)
[17:46:44.499]                 if (is_error) {
[17:46:44.499]                   sessionInformation <- function() {
[17:46:44.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.499]                       search = base::search(), system = base::Sys.info())
[17:46:44.499]                   }
[17:46:44.499]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.499]                     cond$call), session = sessionInformation(), 
[17:46:44.499]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.499]                   signalCondition(cond)
[17:46:44.499]                 }
[17:46:44.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.499]                 "immediateCondition"))) {
[17:46:44.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.499]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.499]                   if (TRUE && !signal) {
[17:46:44.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.499]                     {
[17:46:44.499]                       inherits <- base::inherits
[17:46:44.499]                       invokeRestart <- base::invokeRestart
[17:46:44.499]                       is.null <- base::is.null
[17:46:44.499]                       muffled <- FALSE
[17:46:44.499]                       if (inherits(cond, "message")) {
[17:46:44.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.499]                         if (muffled) 
[17:46:44.499]                           invokeRestart("muffleMessage")
[17:46:44.499]                       }
[17:46:44.499]                       else if (inherits(cond, "warning")) {
[17:46:44.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.499]                         if (muffled) 
[17:46:44.499]                           invokeRestart("muffleWarning")
[17:46:44.499]                       }
[17:46:44.499]                       else if (inherits(cond, "condition")) {
[17:46:44.499]                         if (!is.null(pattern)) {
[17:46:44.499]                           computeRestarts <- base::computeRestarts
[17:46:44.499]                           grepl <- base::grepl
[17:46:44.499]                           restarts <- computeRestarts(cond)
[17:46:44.499]                           for (restart in restarts) {
[17:46:44.499]                             name <- restart$name
[17:46:44.499]                             if (is.null(name)) 
[17:46:44.499]                               next
[17:46:44.499]                             if (!grepl(pattern, name)) 
[17:46:44.499]                               next
[17:46:44.499]                             invokeRestart(restart)
[17:46:44.499]                             muffled <- TRUE
[17:46:44.499]                             break
[17:46:44.499]                           }
[17:46:44.499]                         }
[17:46:44.499]                       }
[17:46:44.499]                       invisible(muffled)
[17:46:44.499]                     }
[17:46:44.499]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.499]                   }
[17:46:44.499]                 }
[17:46:44.499]                 else {
[17:46:44.499]                   if (TRUE) {
[17:46:44.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.499]                     {
[17:46:44.499]                       inherits <- base::inherits
[17:46:44.499]                       invokeRestart <- base::invokeRestart
[17:46:44.499]                       is.null <- base::is.null
[17:46:44.499]                       muffled <- FALSE
[17:46:44.499]                       if (inherits(cond, "message")) {
[17:46:44.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.499]                         if (muffled) 
[17:46:44.499]                           invokeRestart("muffleMessage")
[17:46:44.499]                       }
[17:46:44.499]                       else if (inherits(cond, "warning")) {
[17:46:44.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.499]                         if (muffled) 
[17:46:44.499]                           invokeRestart("muffleWarning")
[17:46:44.499]                       }
[17:46:44.499]                       else if (inherits(cond, "condition")) {
[17:46:44.499]                         if (!is.null(pattern)) {
[17:46:44.499]                           computeRestarts <- base::computeRestarts
[17:46:44.499]                           grepl <- base::grepl
[17:46:44.499]                           restarts <- computeRestarts(cond)
[17:46:44.499]                           for (restart in restarts) {
[17:46:44.499]                             name <- restart$name
[17:46:44.499]                             if (is.null(name)) 
[17:46:44.499]                               next
[17:46:44.499]                             if (!grepl(pattern, name)) 
[17:46:44.499]                               next
[17:46:44.499]                             invokeRestart(restart)
[17:46:44.499]                             muffled <- TRUE
[17:46:44.499]                             break
[17:46:44.499]                           }
[17:46:44.499]                         }
[17:46:44.499]                       }
[17:46:44.499]                       invisible(muffled)
[17:46:44.499]                     }
[17:46:44.499]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.499]                   }
[17:46:44.499]                 }
[17:46:44.499]             }
[17:46:44.499]         }))
[17:46:44.499]     }, error = function(ex) {
[17:46:44.499]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.499]                 ...future.rng), started = ...future.startTime, 
[17:46:44.499]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.499]             version = "1.8"), class = "FutureResult")
[17:46:44.499]     }, finally = {
[17:46:44.499]         if (!identical(...future.workdir, getwd())) 
[17:46:44.499]             setwd(...future.workdir)
[17:46:44.499]         {
[17:46:44.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.499]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.499]             }
[17:46:44.499]             base::options(...future.oldOptions)
[17:46:44.499]             if (.Platform$OS.type == "windows") {
[17:46:44.499]                 old_names <- names(...future.oldEnvVars)
[17:46:44.499]                 envs <- base::Sys.getenv()
[17:46:44.499]                 names <- names(envs)
[17:46:44.499]                 common <- intersect(names, old_names)
[17:46:44.499]                 added <- setdiff(names, old_names)
[17:46:44.499]                 removed <- setdiff(old_names, names)
[17:46:44.499]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.499]                   envs[common]]
[17:46:44.499]                 NAMES <- toupper(changed)
[17:46:44.499]                 args <- list()
[17:46:44.499]                 for (kk in seq_along(NAMES)) {
[17:46:44.499]                   name <- changed[[kk]]
[17:46:44.499]                   NAME <- NAMES[[kk]]
[17:46:44.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.499]                     next
[17:46:44.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.499]                 }
[17:46:44.499]                 NAMES <- toupper(added)
[17:46:44.499]                 for (kk in seq_along(NAMES)) {
[17:46:44.499]                   name <- added[[kk]]
[17:46:44.499]                   NAME <- NAMES[[kk]]
[17:46:44.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.499]                     next
[17:46:44.499]                   args[[name]] <- ""
[17:46:44.499]                 }
[17:46:44.499]                 NAMES <- toupper(removed)
[17:46:44.499]                 for (kk in seq_along(NAMES)) {
[17:46:44.499]                   name <- removed[[kk]]
[17:46:44.499]                   NAME <- NAMES[[kk]]
[17:46:44.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.499]                     next
[17:46:44.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.499]                 }
[17:46:44.499]                 if (length(args) > 0) 
[17:46:44.499]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.499]             }
[17:46:44.499]             else {
[17:46:44.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.499]             }
[17:46:44.499]             {
[17:46:44.499]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.499]                   0L) {
[17:46:44.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.499]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.499]                   base::options(opts)
[17:46:44.499]                 }
[17:46:44.499]                 {
[17:46:44.499]                   {
[17:46:44.499]                     NULL
[17:46:44.499]                     RNGkind("Mersenne-Twister")
[17:46:44.499]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.499]                       inherits = FALSE)
[17:46:44.499]                   }
[17:46:44.499]                   options(future.plan = NULL)
[17:46:44.499]                   if (is.na(NA_character_)) 
[17:46:44.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.499]                     .init = FALSE)
[17:46:44.499]                 }
[17:46:44.499]             }
[17:46:44.499]         }
[17:46:44.499]     })
[17:46:44.499]     if (TRUE) {
[17:46:44.499]         base::sink(type = "output", split = FALSE)
[17:46:44.499]         if (TRUE) {
[17:46:44.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.499]         }
[17:46:44.499]         else {
[17:46:44.499]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.499]         }
[17:46:44.499]         base::close(...future.stdout)
[17:46:44.499]         ...future.stdout <- NULL
[17:46:44.499]     }
[17:46:44.499]     ...future.result$conditions <- ...future.conditions
[17:46:44.499]     ...future.result$finished <- base::Sys.time()
[17:46:44.499]     ...future.result
[17:46:44.499] }
[17:46:44.501] plan(): Setting new future strategy stack:
[17:46:44.501] List of future strategies:
[17:46:44.501] 1. sequential:
[17:46:44.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.501]    - tweaked: FALSE
[17:46:44.501]    - call: NULL
[17:46:44.501] plan(): nbrOfWorkers() = 1
[17:46:44.502] plan(): Setting new future strategy stack:
[17:46:44.502] List of future strategies:
[17:46:44.502] 1. sequential:
[17:46:44.502]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.502]    - tweaked: FALSE
[17:46:44.502]    - call: plan(strategy)
[17:46:44.502] plan(): nbrOfWorkers() = 1
[17:46:44.502] SequentialFuture started (and completed)
[17:46:44.503] - Launch lazy future ... done
[17:46:44.503] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561785632388> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5617875cd6c8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561785632388> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5617875cd6c8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:46:44.507] resolved() for ‘SequentialFuture’ ...
[17:46:44.508] - state: ‘finished’
[17:46:44.508] - run: TRUE
[17:46:44.508] - result: ‘FutureResult’
[17:46:44.508] resolved() for ‘SequentialFuture’ ... done
[17:46:44.508] resolved() for ‘SequentialFuture’ ...
[17:46:44.508] - state: ‘finished’
[17:46:44.508] - run: TRUE
[17:46:44.508] - result: ‘FutureResult’
[17:46:44.508] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:44.510] resolve() on list ...
[17:46:44.510]  recursive: 0
[17:46:44.510]  length: 6
[17:46:44.510]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:44.511] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.511] - nx: 6
[17:46:44.511] - relay: TRUE
[17:46:44.511] - stdout: TRUE
[17:46:44.511] - signal: TRUE
[17:46:44.511] - resignal: FALSE
[17:46:44.511] - force: TRUE
[17:46:44.511] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.511] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.511]  - until=2
[17:46:44.511]  - relaying element #2
[17:46:44.511] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.512] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.512] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.512]  length: 5 (resolved future 1)
[17:46:44.512] resolved() for ‘SequentialFuture’ ...
[17:46:44.512] - state: ‘finished’
[17:46:44.512] - run: TRUE
[17:46:44.512] - result: ‘FutureResult’
[17:46:44.512] resolved() for ‘SequentialFuture’ ... done
[17:46:44.512] Future #2
[17:46:44.512] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.513] - nx: 6
[17:46:44.514] - relay: TRUE
[17:46:44.514] - stdout: TRUE
[17:46:44.514] - signal: TRUE
[17:46:44.514] - resignal: FALSE
[17:46:44.515] - force: TRUE
[17:46:44.515] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.515] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.515]  - until=2
[17:46:44.515]  - relaying element #2
[17:46:44.515] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.515] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.515] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.515]  length: 4 (resolved future 2)
[17:46:44.516] resolved() for ‘SequentialFuture’ ...
[17:46:44.516] - state: ‘finished’
[17:46:44.516] - run: TRUE
[17:46:44.516] - result: ‘FutureResult’
[17:46:44.516] resolved() for ‘SequentialFuture’ ... done
[17:46:44.516] Future #3
[17:46:44.516] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.516] - nx: 6
[17:46:44.516] - relay: TRUE
[17:46:44.516] - stdout: TRUE
[17:46:44.516] - signal: TRUE
[17:46:44.517] - resignal: FALSE
[17:46:44.517] - force: TRUE
[17:46:44.517] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.517] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.517]  - until=3
[17:46:44.517]  - relaying element #3
[17:46:44.517] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.517] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.517] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.517]  length: 3 (resolved future 3)
[17:46:44.518] signalConditionsASAP(NULL, pos=4) ...
[17:46:44.518] - nx: 6
[17:46:44.518] - relay: TRUE
[17:46:44.518] - stdout: TRUE
[17:46:44.518] - signal: TRUE
[17:46:44.518] - resignal: FALSE
[17:46:44.518] - force: TRUE
[17:46:44.518] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.518] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.518]  - until=5
[17:46:44.518]  - relaying element #5
[17:46:44.518] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.519] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.519] signalConditionsASAP(NULL, pos=4) ... done
[17:46:44.519]  length: 2 (resolved future 4)
[17:46:44.519] signalConditionsASAP(NULL, pos=5) ...
[17:46:44.519] - nx: 6
[17:46:44.519] - relay: TRUE
[17:46:44.519] - stdout: TRUE
[17:46:44.519] - signal: TRUE
[17:46:44.519] - resignal: FALSE
[17:46:44.519] - force: TRUE
[17:46:44.519] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.519] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.520]  - until=6
[17:46:44.520]  - relaying element #6
[17:46:44.520] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.520] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.520] signalConditionsASAP(NULL, pos=5) ... done
[17:46:44.520]  length: 1 (resolved future 5)
[17:46:44.520] signalConditionsASAP(numeric, pos=6) ...
[17:46:44.520] - nx: 6
[17:46:44.520] - relay: TRUE
[17:46:44.520] - stdout: TRUE
[17:46:44.521] - signal: TRUE
[17:46:44.521] - resignal: FALSE
[17:46:44.521] - force: TRUE
[17:46:44.521] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.521] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.521]  - until=6
[17:46:44.521] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.521] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.521] signalConditionsASAP(numeric, pos=6) ... done
[17:46:44.521]  length: 0 (resolved future 6)
[17:46:44.521] Relaying remaining futures
[17:46:44.521] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.522] - nx: 6
[17:46:44.522] - relay: TRUE
[17:46:44.522] - stdout: TRUE
[17:46:44.522] - signal: TRUE
[17:46:44.522] - resignal: FALSE
[17:46:44.522] - force: TRUE
[17:46:44.522] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:44.522] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.522] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.523] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:46:44.526] getGlobalsAndPackages() ...
[17:46:44.526] Searching for globals...
[17:46:44.526] 
[17:46:44.526] Searching for globals ... DONE
[17:46:44.526] - globals: [0] <none>
[17:46:44.526] getGlobalsAndPackages() ... DONE
[17:46:44.527] run() for ‘Future’ ...
[17:46:44.527] - state: ‘created’
[17:46:44.527] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.527] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.527]   - Field: ‘label’
[17:46:44.527]   - Field: ‘local’
[17:46:44.528]   - Field: ‘owner’
[17:46:44.528]   - Field: ‘envir’
[17:46:44.528]   - Field: ‘packages’
[17:46:44.528]   - Field: ‘gc’
[17:46:44.528]   - Field: ‘conditions’
[17:46:44.528]   - Field: ‘expr’
[17:46:44.528]   - Field: ‘uuid’
[17:46:44.528]   - Field: ‘seed’
[17:46:44.528]   - Field: ‘version’
[17:46:44.528]   - Field: ‘result’
[17:46:44.528]   - Field: ‘asynchronous’
[17:46:44.529]   - Field: ‘calls’
[17:46:44.529]   - Field: ‘globals’
[17:46:44.529]   - Field: ‘stdout’
[17:46:44.529]   - Field: ‘earlySignal’
[17:46:44.529]   - Field: ‘lazy’
[17:46:44.529]   - Field: ‘state’
[17:46:44.529] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.529] - Launch lazy future ...
[17:46:44.529] Packages needed by the future expression (n = 0): <none>
[17:46:44.529] Packages needed by future strategies (n = 0): <none>
[17:46:44.530] {
[17:46:44.530]     {
[17:46:44.530]         {
[17:46:44.530]             ...future.startTime <- base::Sys.time()
[17:46:44.530]             {
[17:46:44.530]                 {
[17:46:44.530]                   {
[17:46:44.530]                     base::local({
[17:46:44.530]                       has_future <- base::requireNamespace("future", 
[17:46:44.530]                         quietly = TRUE)
[17:46:44.530]                       if (has_future) {
[17:46:44.530]                         ns <- base::getNamespace("future")
[17:46:44.530]                         version <- ns[[".package"]][["version"]]
[17:46:44.530]                         if (is.null(version)) 
[17:46:44.530]                           version <- utils::packageVersion("future")
[17:46:44.530]                       }
[17:46:44.530]                       else {
[17:46:44.530]                         version <- NULL
[17:46:44.530]                       }
[17:46:44.530]                       if (!has_future || version < "1.8.0") {
[17:46:44.530]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.530]                           "", base::R.version$version.string), 
[17:46:44.530]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.530]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.530]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.530]                             "release", "version")], collapse = " "), 
[17:46:44.530]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.530]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.530]                           info)
[17:46:44.530]                         info <- base::paste(info, collapse = "; ")
[17:46:44.530]                         if (!has_future) {
[17:46:44.530]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.530]                             info)
[17:46:44.530]                         }
[17:46:44.530]                         else {
[17:46:44.530]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.530]                             info, version)
[17:46:44.530]                         }
[17:46:44.530]                         base::stop(msg)
[17:46:44.530]                       }
[17:46:44.530]                     })
[17:46:44.530]                   }
[17:46:44.530]                   ...future.strategy.old <- future::plan("list")
[17:46:44.530]                   options(future.plan = NULL)
[17:46:44.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.530]                 }
[17:46:44.530]                 ...future.workdir <- getwd()
[17:46:44.530]             }
[17:46:44.530]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.530]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.530]         }
[17:46:44.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.530]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.530]             base::names(...future.oldOptions))
[17:46:44.530]     }
[17:46:44.530]     if (FALSE) {
[17:46:44.530]     }
[17:46:44.530]     else {
[17:46:44.530]         if (TRUE) {
[17:46:44.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.530]                 open = "w")
[17:46:44.530]         }
[17:46:44.530]         else {
[17:46:44.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.530]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.530]         }
[17:46:44.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.530]             base::sink(type = "output", split = FALSE)
[17:46:44.530]             base::close(...future.stdout)
[17:46:44.530]         }, add = TRUE)
[17:46:44.530]     }
[17:46:44.530]     ...future.frame <- base::sys.nframe()
[17:46:44.530]     ...future.conditions <- base::list()
[17:46:44.530]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.530]     if (FALSE) {
[17:46:44.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.530]     }
[17:46:44.530]     ...future.result <- base::tryCatch({
[17:46:44.530]         base::withCallingHandlers({
[17:46:44.530]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.530]             future::FutureResult(value = ...future.value$value, 
[17:46:44.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.530]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.530]                     ...future.globalenv.names))
[17:46:44.530]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.530]         }, condition = base::local({
[17:46:44.530]             c <- base::c
[17:46:44.530]             inherits <- base::inherits
[17:46:44.530]             invokeRestart <- base::invokeRestart
[17:46:44.530]             length <- base::length
[17:46:44.530]             list <- base::list
[17:46:44.530]             seq.int <- base::seq.int
[17:46:44.530]             signalCondition <- base::signalCondition
[17:46:44.530]             sys.calls <- base::sys.calls
[17:46:44.530]             `[[` <- base::`[[`
[17:46:44.530]             `+` <- base::`+`
[17:46:44.530]             `<<-` <- base::`<<-`
[17:46:44.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.530]                   3L)]
[17:46:44.530]             }
[17:46:44.530]             function(cond) {
[17:46:44.530]                 is_error <- inherits(cond, "error")
[17:46:44.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.530]                   NULL)
[17:46:44.530]                 if (is_error) {
[17:46:44.530]                   sessionInformation <- function() {
[17:46:44.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.530]                       search = base::search(), system = base::Sys.info())
[17:46:44.530]                   }
[17:46:44.530]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.530]                     cond$call), session = sessionInformation(), 
[17:46:44.530]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.530]                   signalCondition(cond)
[17:46:44.530]                 }
[17:46:44.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.530]                 "immediateCondition"))) {
[17:46:44.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.530]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.530]                   if (TRUE && !signal) {
[17:46:44.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.530]                     {
[17:46:44.530]                       inherits <- base::inherits
[17:46:44.530]                       invokeRestart <- base::invokeRestart
[17:46:44.530]                       is.null <- base::is.null
[17:46:44.530]                       muffled <- FALSE
[17:46:44.530]                       if (inherits(cond, "message")) {
[17:46:44.530]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.530]                         if (muffled) 
[17:46:44.530]                           invokeRestart("muffleMessage")
[17:46:44.530]                       }
[17:46:44.530]                       else if (inherits(cond, "warning")) {
[17:46:44.530]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.530]                         if (muffled) 
[17:46:44.530]                           invokeRestart("muffleWarning")
[17:46:44.530]                       }
[17:46:44.530]                       else if (inherits(cond, "condition")) {
[17:46:44.530]                         if (!is.null(pattern)) {
[17:46:44.530]                           computeRestarts <- base::computeRestarts
[17:46:44.530]                           grepl <- base::grepl
[17:46:44.530]                           restarts <- computeRestarts(cond)
[17:46:44.530]                           for (restart in restarts) {
[17:46:44.530]                             name <- restart$name
[17:46:44.530]                             if (is.null(name)) 
[17:46:44.530]                               next
[17:46:44.530]                             if (!grepl(pattern, name)) 
[17:46:44.530]                               next
[17:46:44.530]                             invokeRestart(restart)
[17:46:44.530]                             muffled <- TRUE
[17:46:44.530]                             break
[17:46:44.530]                           }
[17:46:44.530]                         }
[17:46:44.530]                       }
[17:46:44.530]                       invisible(muffled)
[17:46:44.530]                     }
[17:46:44.530]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.530]                   }
[17:46:44.530]                 }
[17:46:44.530]                 else {
[17:46:44.530]                   if (TRUE) {
[17:46:44.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.530]                     {
[17:46:44.530]                       inherits <- base::inherits
[17:46:44.530]                       invokeRestart <- base::invokeRestart
[17:46:44.530]                       is.null <- base::is.null
[17:46:44.530]                       muffled <- FALSE
[17:46:44.530]                       if (inherits(cond, "message")) {
[17:46:44.530]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.530]                         if (muffled) 
[17:46:44.530]                           invokeRestart("muffleMessage")
[17:46:44.530]                       }
[17:46:44.530]                       else if (inherits(cond, "warning")) {
[17:46:44.530]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.530]                         if (muffled) 
[17:46:44.530]                           invokeRestart("muffleWarning")
[17:46:44.530]                       }
[17:46:44.530]                       else if (inherits(cond, "condition")) {
[17:46:44.530]                         if (!is.null(pattern)) {
[17:46:44.530]                           computeRestarts <- base::computeRestarts
[17:46:44.530]                           grepl <- base::grepl
[17:46:44.530]                           restarts <- computeRestarts(cond)
[17:46:44.530]                           for (restart in restarts) {
[17:46:44.530]                             name <- restart$name
[17:46:44.530]                             if (is.null(name)) 
[17:46:44.530]                               next
[17:46:44.530]                             if (!grepl(pattern, name)) 
[17:46:44.530]                               next
[17:46:44.530]                             invokeRestart(restart)
[17:46:44.530]                             muffled <- TRUE
[17:46:44.530]                             break
[17:46:44.530]                           }
[17:46:44.530]                         }
[17:46:44.530]                       }
[17:46:44.530]                       invisible(muffled)
[17:46:44.530]                     }
[17:46:44.530]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.530]                   }
[17:46:44.530]                 }
[17:46:44.530]             }
[17:46:44.530]         }))
[17:46:44.530]     }, error = function(ex) {
[17:46:44.530]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.530]                 ...future.rng), started = ...future.startTime, 
[17:46:44.530]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.530]             version = "1.8"), class = "FutureResult")
[17:46:44.530]     }, finally = {
[17:46:44.530]         if (!identical(...future.workdir, getwd())) 
[17:46:44.530]             setwd(...future.workdir)
[17:46:44.530]         {
[17:46:44.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.530]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.530]             }
[17:46:44.530]             base::options(...future.oldOptions)
[17:46:44.530]             if (.Platform$OS.type == "windows") {
[17:46:44.530]                 old_names <- names(...future.oldEnvVars)
[17:46:44.530]                 envs <- base::Sys.getenv()
[17:46:44.530]                 names <- names(envs)
[17:46:44.530]                 common <- intersect(names, old_names)
[17:46:44.530]                 added <- setdiff(names, old_names)
[17:46:44.530]                 removed <- setdiff(old_names, names)
[17:46:44.530]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.530]                   envs[common]]
[17:46:44.530]                 NAMES <- toupper(changed)
[17:46:44.530]                 args <- list()
[17:46:44.530]                 for (kk in seq_along(NAMES)) {
[17:46:44.530]                   name <- changed[[kk]]
[17:46:44.530]                   NAME <- NAMES[[kk]]
[17:46:44.530]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.530]                     next
[17:46:44.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.530]                 }
[17:46:44.530]                 NAMES <- toupper(added)
[17:46:44.530]                 for (kk in seq_along(NAMES)) {
[17:46:44.530]                   name <- added[[kk]]
[17:46:44.530]                   NAME <- NAMES[[kk]]
[17:46:44.530]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.530]                     next
[17:46:44.530]                   args[[name]] <- ""
[17:46:44.530]                 }
[17:46:44.530]                 NAMES <- toupper(removed)
[17:46:44.530]                 for (kk in seq_along(NAMES)) {
[17:46:44.530]                   name <- removed[[kk]]
[17:46:44.530]                   NAME <- NAMES[[kk]]
[17:46:44.530]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.530]                     next
[17:46:44.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.530]                 }
[17:46:44.530]                 if (length(args) > 0) 
[17:46:44.530]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.530]             }
[17:46:44.530]             else {
[17:46:44.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.530]             }
[17:46:44.530]             {
[17:46:44.530]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.530]                   0L) {
[17:46:44.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.530]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.530]                   base::options(opts)
[17:46:44.530]                 }
[17:46:44.530]                 {
[17:46:44.530]                   {
[17:46:44.530]                     NULL
[17:46:44.530]                     RNGkind("Mersenne-Twister")
[17:46:44.530]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.530]                       inherits = FALSE)
[17:46:44.530]                   }
[17:46:44.530]                   options(future.plan = NULL)
[17:46:44.530]                   if (is.na(NA_character_)) 
[17:46:44.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.530]                     .init = FALSE)
[17:46:44.530]                 }
[17:46:44.530]             }
[17:46:44.530]         }
[17:46:44.530]     })
[17:46:44.530]     if (TRUE) {
[17:46:44.530]         base::sink(type = "output", split = FALSE)
[17:46:44.530]         if (TRUE) {
[17:46:44.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.530]         }
[17:46:44.530]         else {
[17:46:44.530]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.530]         }
[17:46:44.530]         base::close(...future.stdout)
[17:46:44.530]         ...future.stdout <- NULL
[17:46:44.530]     }
[17:46:44.530]     ...future.result$conditions <- ...future.conditions
[17:46:44.530]     ...future.result$finished <- base::Sys.time()
[17:46:44.530]     ...future.result
[17:46:44.530] }
[17:46:44.532] plan(): Setting new future strategy stack:
[17:46:44.532] List of future strategies:
[17:46:44.532] 1. sequential:
[17:46:44.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.532]    - tweaked: FALSE
[17:46:44.532]    - call: NULL
[17:46:44.532] plan(): nbrOfWorkers() = 1
[17:46:44.533] plan(): Setting new future strategy stack:
[17:46:44.533] List of future strategies:
[17:46:44.533] 1. sequential:
[17:46:44.533]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.533]    - tweaked: FALSE
[17:46:44.533]    - call: plan(strategy)
[17:46:44.533] plan(): nbrOfWorkers() = 1
[17:46:44.533] SequentialFuture started (and completed)
[17:46:44.534] - Launch lazy future ... done
[17:46:44.534] run() for ‘SequentialFuture’ ... done
[17:46:44.534] getGlobalsAndPackages() ...
[17:46:44.534] Searching for globals...
[17:46:44.534] 
[17:46:44.534] Searching for globals ... DONE
[17:46:44.534] - globals: [0] <none>
[17:46:44.534] getGlobalsAndPackages() ... DONE
[17:46:44.535] run() for ‘Future’ ...
[17:46:44.535] - state: ‘created’
[17:46:44.535] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.535] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.535]   - Field: ‘label’
[17:46:44.535]   - Field: ‘local’
[17:46:44.536]   - Field: ‘owner’
[17:46:44.536]   - Field: ‘envir’
[17:46:44.536]   - Field: ‘packages’
[17:46:44.536]   - Field: ‘gc’
[17:46:44.536]   - Field: ‘conditions’
[17:46:44.536]   - Field: ‘expr’
[17:46:44.536]   - Field: ‘uuid’
[17:46:44.536]   - Field: ‘seed’
[17:46:44.536]   - Field: ‘version’
[17:46:44.536]   - Field: ‘result’
[17:46:44.537]   - Field: ‘asynchronous’
[17:46:44.537]   - Field: ‘calls’
[17:46:44.537]   - Field: ‘globals’
[17:46:44.537]   - Field: ‘stdout’
[17:46:44.537]   - Field: ‘earlySignal’
[17:46:44.537]   - Field: ‘lazy’
[17:46:44.537]   - Field: ‘state’
[17:46:44.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.537] - Launch lazy future ...
[17:46:44.537] Packages needed by the future expression (n = 0): <none>
[17:46:44.537] Packages needed by future strategies (n = 0): <none>
[17:46:44.538] {
[17:46:44.538]     {
[17:46:44.538]         {
[17:46:44.538]             ...future.startTime <- base::Sys.time()
[17:46:44.538]             {
[17:46:44.538]                 {
[17:46:44.538]                   {
[17:46:44.538]                     base::local({
[17:46:44.538]                       has_future <- base::requireNamespace("future", 
[17:46:44.538]                         quietly = TRUE)
[17:46:44.538]                       if (has_future) {
[17:46:44.538]                         ns <- base::getNamespace("future")
[17:46:44.538]                         version <- ns[[".package"]][["version"]]
[17:46:44.538]                         if (is.null(version)) 
[17:46:44.538]                           version <- utils::packageVersion("future")
[17:46:44.538]                       }
[17:46:44.538]                       else {
[17:46:44.538]                         version <- NULL
[17:46:44.538]                       }
[17:46:44.538]                       if (!has_future || version < "1.8.0") {
[17:46:44.538]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.538]                           "", base::R.version$version.string), 
[17:46:44.538]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.538]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.538]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.538]                             "release", "version")], collapse = " "), 
[17:46:44.538]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.538]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.538]                           info)
[17:46:44.538]                         info <- base::paste(info, collapse = "; ")
[17:46:44.538]                         if (!has_future) {
[17:46:44.538]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.538]                             info)
[17:46:44.538]                         }
[17:46:44.538]                         else {
[17:46:44.538]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.538]                             info, version)
[17:46:44.538]                         }
[17:46:44.538]                         base::stop(msg)
[17:46:44.538]                       }
[17:46:44.538]                     })
[17:46:44.538]                   }
[17:46:44.538]                   ...future.strategy.old <- future::plan("list")
[17:46:44.538]                   options(future.plan = NULL)
[17:46:44.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.538]                 }
[17:46:44.538]                 ...future.workdir <- getwd()
[17:46:44.538]             }
[17:46:44.538]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.538]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.538]         }
[17:46:44.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.538]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.538]             base::names(...future.oldOptions))
[17:46:44.538]     }
[17:46:44.538]     if (FALSE) {
[17:46:44.538]     }
[17:46:44.538]     else {
[17:46:44.538]         if (TRUE) {
[17:46:44.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.538]                 open = "w")
[17:46:44.538]         }
[17:46:44.538]         else {
[17:46:44.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.538]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.538]         }
[17:46:44.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.538]             base::sink(type = "output", split = FALSE)
[17:46:44.538]             base::close(...future.stdout)
[17:46:44.538]         }, add = TRUE)
[17:46:44.538]     }
[17:46:44.538]     ...future.frame <- base::sys.nframe()
[17:46:44.538]     ...future.conditions <- base::list()
[17:46:44.538]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.538]     if (FALSE) {
[17:46:44.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.538]     }
[17:46:44.538]     ...future.result <- base::tryCatch({
[17:46:44.538]         base::withCallingHandlers({
[17:46:44.538]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.538]             future::FutureResult(value = ...future.value$value, 
[17:46:44.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.538]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.538]                     ...future.globalenv.names))
[17:46:44.538]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.538]         }, condition = base::local({
[17:46:44.538]             c <- base::c
[17:46:44.538]             inherits <- base::inherits
[17:46:44.538]             invokeRestart <- base::invokeRestart
[17:46:44.538]             length <- base::length
[17:46:44.538]             list <- base::list
[17:46:44.538]             seq.int <- base::seq.int
[17:46:44.538]             signalCondition <- base::signalCondition
[17:46:44.538]             sys.calls <- base::sys.calls
[17:46:44.538]             `[[` <- base::`[[`
[17:46:44.538]             `+` <- base::`+`
[17:46:44.538]             `<<-` <- base::`<<-`
[17:46:44.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.538]                   3L)]
[17:46:44.538]             }
[17:46:44.538]             function(cond) {
[17:46:44.538]                 is_error <- inherits(cond, "error")
[17:46:44.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.538]                   NULL)
[17:46:44.538]                 if (is_error) {
[17:46:44.538]                   sessionInformation <- function() {
[17:46:44.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.538]                       search = base::search(), system = base::Sys.info())
[17:46:44.538]                   }
[17:46:44.538]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.538]                     cond$call), session = sessionInformation(), 
[17:46:44.538]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.538]                   signalCondition(cond)
[17:46:44.538]                 }
[17:46:44.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.538]                 "immediateCondition"))) {
[17:46:44.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.538]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.538]                   if (TRUE && !signal) {
[17:46:44.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.538]                     {
[17:46:44.538]                       inherits <- base::inherits
[17:46:44.538]                       invokeRestart <- base::invokeRestart
[17:46:44.538]                       is.null <- base::is.null
[17:46:44.538]                       muffled <- FALSE
[17:46:44.538]                       if (inherits(cond, "message")) {
[17:46:44.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.538]                         if (muffled) 
[17:46:44.538]                           invokeRestart("muffleMessage")
[17:46:44.538]                       }
[17:46:44.538]                       else if (inherits(cond, "warning")) {
[17:46:44.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.538]                         if (muffled) 
[17:46:44.538]                           invokeRestart("muffleWarning")
[17:46:44.538]                       }
[17:46:44.538]                       else if (inherits(cond, "condition")) {
[17:46:44.538]                         if (!is.null(pattern)) {
[17:46:44.538]                           computeRestarts <- base::computeRestarts
[17:46:44.538]                           grepl <- base::grepl
[17:46:44.538]                           restarts <- computeRestarts(cond)
[17:46:44.538]                           for (restart in restarts) {
[17:46:44.538]                             name <- restart$name
[17:46:44.538]                             if (is.null(name)) 
[17:46:44.538]                               next
[17:46:44.538]                             if (!grepl(pattern, name)) 
[17:46:44.538]                               next
[17:46:44.538]                             invokeRestart(restart)
[17:46:44.538]                             muffled <- TRUE
[17:46:44.538]                             break
[17:46:44.538]                           }
[17:46:44.538]                         }
[17:46:44.538]                       }
[17:46:44.538]                       invisible(muffled)
[17:46:44.538]                     }
[17:46:44.538]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.538]                   }
[17:46:44.538]                 }
[17:46:44.538]                 else {
[17:46:44.538]                   if (TRUE) {
[17:46:44.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.538]                     {
[17:46:44.538]                       inherits <- base::inherits
[17:46:44.538]                       invokeRestart <- base::invokeRestart
[17:46:44.538]                       is.null <- base::is.null
[17:46:44.538]                       muffled <- FALSE
[17:46:44.538]                       if (inherits(cond, "message")) {
[17:46:44.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.538]                         if (muffled) 
[17:46:44.538]                           invokeRestart("muffleMessage")
[17:46:44.538]                       }
[17:46:44.538]                       else if (inherits(cond, "warning")) {
[17:46:44.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.538]                         if (muffled) 
[17:46:44.538]                           invokeRestart("muffleWarning")
[17:46:44.538]                       }
[17:46:44.538]                       else if (inherits(cond, "condition")) {
[17:46:44.538]                         if (!is.null(pattern)) {
[17:46:44.538]                           computeRestarts <- base::computeRestarts
[17:46:44.538]                           grepl <- base::grepl
[17:46:44.538]                           restarts <- computeRestarts(cond)
[17:46:44.538]                           for (restart in restarts) {
[17:46:44.538]                             name <- restart$name
[17:46:44.538]                             if (is.null(name)) 
[17:46:44.538]                               next
[17:46:44.538]                             if (!grepl(pattern, name)) 
[17:46:44.538]                               next
[17:46:44.538]                             invokeRestart(restart)
[17:46:44.538]                             muffled <- TRUE
[17:46:44.538]                             break
[17:46:44.538]                           }
[17:46:44.538]                         }
[17:46:44.538]                       }
[17:46:44.538]                       invisible(muffled)
[17:46:44.538]                     }
[17:46:44.538]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.538]                   }
[17:46:44.538]                 }
[17:46:44.538]             }
[17:46:44.538]         }))
[17:46:44.538]     }, error = function(ex) {
[17:46:44.538]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.538]                 ...future.rng), started = ...future.startTime, 
[17:46:44.538]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.538]             version = "1.8"), class = "FutureResult")
[17:46:44.538]     }, finally = {
[17:46:44.538]         if (!identical(...future.workdir, getwd())) 
[17:46:44.538]             setwd(...future.workdir)
[17:46:44.538]         {
[17:46:44.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.538]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.538]             }
[17:46:44.538]             base::options(...future.oldOptions)
[17:46:44.538]             if (.Platform$OS.type == "windows") {
[17:46:44.538]                 old_names <- names(...future.oldEnvVars)
[17:46:44.538]                 envs <- base::Sys.getenv()
[17:46:44.538]                 names <- names(envs)
[17:46:44.538]                 common <- intersect(names, old_names)
[17:46:44.538]                 added <- setdiff(names, old_names)
[17:46:44.538]                 removed <- setdiff(old_names, names)
[17:46:44.538]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.538]                   envs[common]]
[17:46:44.538]                 NAMES <- toupper(changed)
[17:46:44.538]                 args <- list()
[17:46:44.538]                 for (kk in seq_along(NAMES)) {
[17:46:44.538]                   name <- changed[[kk]]
[17:46:44.538]                   NAME <- NAMES[[kk]]
[17:46:44.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.538]                     next
[17:46:44.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.538]                 }
[17:46:44.538]                 NAMES <- toupper(added)
[17:46:44.538]                 for (kk in seq_along(NAMES)) {
[17:46:44.538]                   name <- added[[kk]]
[17:46:44.538]                   NAME <- NAMES[[kk]]
[17:46:44.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.538]                     next
[17:46:44.538]                   args[[name]] <- ""
[17:46:44.538]                 }
[17:46:44.538]                 NAMES <- toupper(removed)
[17:46:44.538]                 for (kk in seq_along(NAMES)) {
[17:46:44.538]                   name <- removed[[kk]]
[17:46:44.538]                   NAME <- NAMES[[kk]]
[17:46:44.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.538]                     next
[17:46:44.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.538]                 }
[17:46:44.538]                 if (length(args) > 0) 
[17:46:44.538]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.538]             }
[17:46:44.538]             else {
[17:46:44.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.538]             }
[17:46:44.538]             {
[17:46:44.538]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.538]                   0L) {
[17:46:44.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.538]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.538]                   base::options(opts)
[17:46:44.538]                 }
[17:46:44.538]                 {
[17:46:44.538]                   {
[17:46:44.538]                     NULL
[17:46:44.538]                     RNGkind("Mersenne-Twister")
[17:46:44.538]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.538]                       inherits = FALSE)
[17:46:44.538]                   }
[17:46:44.538]                   options(future.plan = NULL)
[17:46:44.538]                   if (is.na(NA_character_)) 
[17:46:44.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.538]                     .init = FALSE)
[17:46:44.538]                 }
[17:46:44.538]             }
[17:46:44.538]         }
[17:46:44.538]     })
[17:46:44.538]     if (TRUE) {
[17:46:44.538]         base::sink(type = "output", split = FALSE)
[17:46:44.538]         if (TRUE) {
[17:46:44.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.538]         }
[17:46:44.538]         else {
[17:46:44.538]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.538]         }
[17:46:44.538]         base::close(...future.stdout)
[17:46:44.538]         ...future.stdout <- NULL
[17:46:44.538]     }
[17:46:44.538]     ...future.result$conditions <- ...future.conditions
[17:46:44.538]     ...future.result$finished <- base::Sys.time()
[17:46:44.538]     ...future.result
[17:46:44.538] }
[17:46:44.540] plan(): Setting new future strategy stack:
[17:46:44.540] List of future strategies:
[17:46:44.540] 1. sequential:
[17:46:44.540]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.540]    - tweaked: FALSE
[17:46:44.540]    - call: NULL
[17:46:44.540] plan(): nbrOfWorkers() = 1
[17:46:44.541] plan(): Setting new future strategy stack:
[17:46:44.541] List of future strategies:
[17:46:44.541] 1. sequential:
[17:46:44.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.541]    - tweaked: FALSE
[17:46:44.541]    - call: plan(strategy)
[17:46:44.541] plan(): nbrOfWorkers() = 1
[17:46:44.541] SequentialFuture started (and completed)
[17:46:44.542] - Launch lazy future ... done
[17:46:44.542] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5617877bc438> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561787c298d0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5617877bc438> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561787c298d0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:46:44.548] resolved() for ‘SequentialFuture’ ...
[17:46:44.548] - state: ‘finished’
[17:46:44.548] - run: TRUE
[17:46:44.549] - result: ‘FutureResult’
[17:46:44.549] resolved() for ‘SequentialFuture’ ... done
[17:46:44.549] resolved() for ‘SequentialFuture’ ...
[17:46:44.549] - state: ‘finished’
[17:46:44.549] - run: TRUE
[17:46:44.549] - result: ‘FutureResult’
[17:46:44.549] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:44.551] resolve() on list ...
[17:46:44.551]  recursive: 0
[17:46:44.551]  length: 6
[17:46:44.551]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:44.551] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.551] - nx: 6
[17:46:44.551] - relay: TRUE
[17:46:44.551] - stdout: TRUE
[17:46:44.551] - signal: TRUE
[17:46:44.551] - resignal: FALSE
[17:46:44.552] - force: TRUE
[17:46:44.552] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.552] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.552]  - until=2
[17:46:44.552]  - relaying element #2
[17:46:44.552] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.552] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.552] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.552]  length: 5 (resolved future 1)
[17:46:44.552] resolved() for ‘SequentialFuture’ ...
[17:46:44.552] - state: ‘finished’
[17:46:44.553] - run: TRUE
[17:46:44.553] - result: ‘FutureResult’
[17:46:44.553] resolved() for ‘SequentialFuture’ ... done
[17:46:44.553] Future #2
[17:46:44.553] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.553] - nx: 6
[17:46:44.553] - relay: TRUE
[17:46:44.553] - stdout: TRUE
[17:46:44.553] - signal: TRUE
[17:46:44.553] - resignal: FALSE
[17:46:44.553] - force: TRUE
[17:46:44.554] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.554] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.554]  - until=2
[17:46:44.554]  - relaying element #2
[17:46:44.554] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.554] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.554] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.554]  length: 4 (resolved future 2)
[17:46:44.554] resolved() for ‘SequentialFuture’ ...
[17:46:44.554] - state: ‘finished’
[17:46:44.555] - run: TRUE
[17:46:44.555] - result: ‘FutureResult’
[17:46:44.555] resolved() for ‘SequentialFuture’ ... done
[17:46:44.555] Future #3
[17:46:44.555] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.555] - nx: 6
[17:46:44.555] - relay: TRUE
[17:46:44.555] - stdout: TRUE
[17:46:44.555] - signal: TRUE
[17:46:44.555] - resignal: FALSE
[17:46:44.555] - force: TRUE
[17:46:44.556] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.556] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.556]  - until=3
[17:46:44.556]  - relaying element #3
[17:46:44.556] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.556] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.556] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.556]  length: 3 (resolved future 3)
[17:46:44.556] signalConditionsASAP(NULL, pos=4) ...
[17:46:44.556] - nx: 6
[17:46:44.556] - relay: TRUE
[17:46:44.557] - stdout: TRUE
[17:46:44.557] - signal: TRUE
[17:46:44.557] - resignal: FALSE
[17:46:44.557] - force: TRUE
[17:46:44.557] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.557] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.557]  - until=5
[17:46:44.557]  - relaying element #5
[17:46:44.557] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.557] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.557] signalConditionsASAP(NULL, pos=4) ... done
[17:46:44.557]  length: 2 (resolved future 4)
[17:46:44.558] signalConditionsASAP(NULL, pos=5) ...
[17:46:44.558] - nx: 6
[17:46:44.558] - relay: TRUE
[17:46:44.558] - stdout: TRUE
[17:46:44.558] - signal: TRUE
[17:46:44.558] - resignal: FALSE
[17:46:44.558] - force: TRUE
[17:46:44.558] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.558] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.558]  - until=6
[17:46:44.558]  - relaying element #6
[17:46:44.558] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.559] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.559] signalConditionsASAP(NULL, pos=5) ... done
[17:46:44.559]  length: 1 (resolved future 5)
[17:46:44.559] signalConditionsASAP(numeric, pos=6) ...
[17:46:44.559] - nx: 6
[17:46:44.559] - relay: TRUE
[17:46:44.559] - stdout: TRUE
[17:46:44.559] - signal: TRUE
[17:46:44.559] - resignal: FALSE
[17:46:44.559] - force: TRUE
[17:46:44.559] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.559] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.560]  - until=6
[17:46:44.560] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.560] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.560] signalConditionsASAP(numeric, pos=6) ... done
[17:46:44.560]  length: 0 (resolved future 6)
[17:46:44.560] Relaying remaining futures
[17:46:44.560] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.560] - nx: 6
[17:46:44.560] - relay: TRUE
[17:46:44.560] - stdout: TRUE
[17:46:44.560] - signal: TRUE
[17:46:44.560] - resignal: FALSE
[17:46:44.561] - force: TRUE
[17:46:44.561] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.561] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:44.561] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.561] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.561] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.561] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:46:44.564] getGlobalsAndPackages() ...
[17:46:44.564] Searching for globals...
[17:46:44.565] 
[17:46:44.565] Searching for globals ... DONE
[17:46:44.565] - globals: [0] <none>
[17:46:44.565] getGlobalsAndPackages() ... DONE
[17:46:44.565] run() for ‘Future’ ...
[17:46:44.565] - state: ‘created’
[17:46:44.565] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.565] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.566] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.566]   - Field: ‘label’
[17:46:44.566]   - Field: ‘local’
[17:46:44.566]   - Field: ‘owner’
[17:46:44.566]   - Field: ‘envir’
[17:46:44.566]   - Field: ‘packages’
[17:46:44.566]   - Field: ‘gc’
[17:46:44.566]   - Field: ‘conditions’
[17:46:44.566]   - Field: ‘expr’
[17:46:44.566]   - Field: ‘uuid’
[17:46:44.567]   - Field: ‘seed’
[17:46:44.567]   - Field: ‘version’
[17:46:44.567]   - Field: ‘result’
[17:46:44.567]   - Field: ‘asynchronous’
[17:46:44.567]   - Field: ‘calls’
[17:46:44.567]   - Field: ‘globals’
[17:46:44.567]   - Field: ‘stdout’
[17:46:44.567]   - Field: ‘earlySignal’
[17:46:44.567]   - Field: ‘lazy’
[17:46:44.567]   - Field: ‘state’
[17:46:44.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.568] - Launch lazy future ...
[17:46:44.568] Packages needed by the future expression (n = 0): <none>
[17:46:44.568] Packages needed by future strategies (n = 0): <none>
[17:46:44.568] {
[17:46:44.568]     {
[17:46:44.568]         {
[17:46:44.568]             ...future.startTime <- base::Sys.time()
[17:46:44.568]             {
[17:46:44.568]                 {
[17:46:44.568]                   {
[17:46:44.568]                     base::local({
[17:46:44.568]                       has_future <- base::requireNamespace("future", 
[17:46:44.568]                         quietly = TRUE)
[17:46:44.568]                       if (has_future) {
[17:46:44.568]                         ns <- base::getNamespace("future")
[17:46:44.568]                         version <- ns[[".package"]][["version"]]
[17:46:44.568]                         if (is.null(version)) 
[17:46:44.568]                           version <- utils::packageVersion("future")
[17:46:44.568]                       }
[17:46:44.568]                       else {
[17:46:44.568]                         version <- NULL
[17:46:44.568]                       }
[17:46:44.568]                       if (!has_future || version < "1.8.0") {
[17:46:44.568]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.568]                           "", base::R.version$version.string), 
[17:46:44.568]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.568]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.568]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.568]                             "release", "version")], collapse = " "), 
[17:46:44.568]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.568]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.568]                           info)
[17:46:44.568]                         info <- base::paste(info, collapse = "; ")
[17:46:44.568]                         if (!has_future) {
[17:46:44.568]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.568]                             info)
[17:46:44.568]                         }
[17:46:44.568]                         else {
[17:46:44.568]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.568]                             info, version)
[17:46:44.568]                         }
[17:46:44.568]                         base::stop(msg)
[17:46:44.568]                       }
[17:46:44.568]                     })
[17:46:44.568]                   }
[17:46:44.568]                   ...future.strategy.old <- future::plan("list")
[17:46:44.568]                   options(future.plan = NULL)
[17:46:44.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.568]                 }
[17:46:44.568]                 ...future.workdir <- getwd()
[17:46:44.568]             }
[17:46:44.568]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.568]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.568]         }
[17:46:44.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.568]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.568]             base::names(...future.oldOptions))
[17:46:44.568]     }
[17:46:44.568]     if (FALSE) {
[17:46:44.568]     }
[17:46:44.568]     else {
[17:46:44.568]         if (TRUE) {
[17:46:44.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.568]                 open = "w")
[17:46:44.568]         }
[17:46:44.568]         else {
[17:46:44.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.568]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.568]         }
[17:46:44.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.568]             base::sink(type = "output", split = FALSE)
[17:46:44.568]             base::close(...future.stdout)
[17:46:44.568]         }, add = TRUE)
[17:46:44.568]     }
[17:46:44.568]     ...future.frame <- base::sys.nframe()
[17:46:44.568]     ...future.conditions <- base::list()
[17:46:44.568]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.568]     if (FALSE) {
[17:46:44.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.568]     }
[17:46:44.568]     ...future.result <- base::tryCatch({
[17:46:44.568]         base::withCallingHandlers({
[17:46:44.568]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.568]             future::FutureResult(value = ...future.value$value, 
[17:46:44.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.568]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.568]                     ...future.globalenv.names))
[17:46:44.568]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.568]         }, condition = base::local({
[17:46:44.568]             c <- base::c
[17:46:44.568]             inherits <- base::inherits
[17:46:44.568]             invokeRestart <- base::invokeRestart
[17:46:44.568]             length <- base::length
[17:46:44.568]             list <- base::list
[17:46:44.568]             seq.int <- base::seq.int
[17:46:44.568]             signalCondition <- base::signalCondition
[17:46:44.568]             sys.calls <- base::sys.calls
[17:46:44.568]             `[[` <- base::`[[`
[17:46:44.568]             `+` <- base::`+`
[17:46:44.568]             `<<-` <- base::`<<-`
[17:46:44.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.568]                   3L)]
[17:46:44.568]             }
[17:46:44.568]             function(cond) {
[17:46:44.568]                 is_error <- inherits(cond, "error")
[17:46:44.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.568]                   NULL)
[17:46:44.568]                 if (is_error) {
[17:46:44.568]                   sessionInformation <- function() {
[17:46:44.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.568]                       search = base::search(), system = base::Sys.info())
[17:46:44.568]                   }
[17:46:44.568]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.568]                     cond$call), session = sessionInformation(), 
[17:46:44.568]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.568]                   signalCondition(cond)
[17:46:44.568]                 }
[17:46:44.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.568]                 "immediateCondition"))) {
[17:46:44.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.568]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.568]                   if (TRUE && !signal) {
[17:46:44.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.568]                     {
[17:46:44.568]                       inherits <- base::inherits
[17:46:44.568]                       invokeRestart <- base::invokeRestart
[17:46:44.568]                       is.null <- base::is.null
[17:46:44.568]                       muffled <- FALSE
[17:46:44.568]                       if (inherits(cond, "message")) {
[17:46:44.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.568]                         if (muffled) 
[17:46:44.568]                           invokeRestart("muffleMessage")
[17:46:44.568]                       }
[17:46:44.568]                       else if (inherits(cond, "warning")) {
[17:46:44.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.568]                         if (muffled) 
[17:46:44.568]                           invokeRestart("muffleWarning")
[17:46:44.568]                       }
[17:46:44.568]                       else if (inherits(cond, "condition")) {
[17:46:44.568]                         if (!is.null(pattern)) {
[17:46:44.568]                           computeRestarts <- base::computeRestarts
[17:46:44.568]                           grepl <- base::grepl
[17:46:44.568]                           restarts <- computeRestarts(cond)
[17:46:44.568]                           for (restart in restarts) {
[17:46:44.568]                             name <- restart$name
[17:46:44.568]                             if (is.null(name)) 
[17:46:44.568]                               next
[17:46:44.568]                             if (!grepl(pattern, name)) 
[17:46:44.568]                               next
[17:46:44.568]                             invokeRestart(restart)
[17:46:44.568]                             muffled <- TRUE
[17:46:44.568]                             break
[17:46:44.568]                           }
[17:46:44.568]                         }
[17:46:44.568]                       }
[17:46:44.568]                       invisible(muffled)
[17:46:44.568]                     }
[17:46:44.568]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.568]                   }
[17:46:44.568]                 }
[17:46:44.568]                 else {
[17:46:44.568]                   if (TRUE) {
[17:46:44.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.568]                     {
[17:46:44.568]                       inherits <- base::inherits
[17:46:44.568]                       invokeRestart <- base::invokeRestart
[17:46:44.568]                       is.null <- base::is.null
[17:46:44.568]                       muffled <- FALSE
[17:46:44.568]                       if (inherits(cond, "message")) {
[17:46:44.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.568]                         if (muffled) 
[17:46:44.568]                           invokeRestart("muffleMessage")
[17:46:44.568]                       }
[17:46:44.568]                       else if (inherits(cond, "warning")) {
[17:46:44.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.568]                         if (muffled) 
[17:46:44.568]                           invokeRestart("muffleWarning")
[17:46:44.568]                       }
[17:46:44.568]                       else if (inherits(cond, "condition")) {
[17:46:44.568]                         if (!is.null(pattern)) {
[17:46:44.568]                           computeRestarts <- base::computeRestarts
[17:46:44.568]                           grepl <- base::grepl
[17:46:44.568]                           restarts <- computeRestarts(cond)
[17:46:44.568]                           for (restart in restarts) {
[17:46:44.568]                             name <- restart$name
[17:46:44.568]                             if (is.null(name)) 
[17:46:44.568]                               next
[17:46:44.568]                             if (!grepl(pattern, name)) 
[17:46:44.568]                               next
[17:46:44.568]                             invokeRestart(restart)
[17:46:44.568]                             muffled <- TRUE
[17:46:44.568]                             break
[17:46:44.568]                           }
[17:46:44.568]                         }
[17:46:44.568]                       }
[17:46:44.568]                       invisible(muffled)
[17:46:44.568]                     }
[17:46:44.568]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.568]                   }
[17:46:44.568]                 }
[17:46:44.568]             }
[17:46:44.568]         }))
[17:46:44.568]     }, error = function(ex) {
[17:46:44.568]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.568]                 ...future.rng), started = ...future.startTime, 
[17:46:44.568]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.568]             version = "1.8"), class = "FutureResult")
[17:46:44.568]     }, finally = {
[17:46:44.568]         if (!identical(...future.workdir, getwd())) 
[17:46:44.568]             setwd(...future.workdir)
[17:46:44.568]         {
[17:46:44.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.568]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.568]             }
[17:46:44.568]             base::options(...future.oldOptions)
[17:46:44.568]             if (.Platform$OS.type == "windows") {
[17:46:44.568]                 old_names <- names(...future.oldEnvVars)
[17:46:44.568]                 envs <- base::Sys.getenv()
[17:46:44.568]                 names <- names(envs)
[17:46:44.568]                 common <- intersect(names, old_names)
[17:46:44.568]                 added <- setdiff(names, old_names)
[17:46:44.568]                 removed <- setdiff(old_names, names)
[17:46:44.568]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.568]                   envs[common]]
[17:46:44.568]                 NAMES <- toupper(changed)
[17:46:44.568]                 args <- list()
[17:46:44.568]                 for (kk in seq_along(NAMES)) {
[17:46:44.568]                   name <- changed[[kk]]
[17:46:44.568]                   NAME <- NAMES[[kk]]
[17:46:44.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.568]                     next
[17:46:44.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.568]                 }
[17:46:44.568]                 NAMES <- toupper(added)
[17:46:44.568]                 for (kk in seq_along(NAMES)) {
[17:46:44.568]                   name <- added[[kk]]
[17:46:44.568]                   NAME <- NAMES[[kk]]
[17:46:44.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.568]                     next
[17:46:44.568]                   args[[name]] <- ""
[17:46:44.568]                 }
[17:46:44.568]                 NAMES <- toupper(removed)
[17:46:44.568]                 for (kk in seq_along(NAMES)) {
[17:46:44.568]                   name <- removed[[kk]]
[17:46:44.568]                   NAME <- NAMES[[kk]]
[17:46:44.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.568]                     next
[17:46:44.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.568]                 }
[17:46:44.568]                 if (length(args) > 0) 
[17:46:44.568]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.568]             }
[17:46:44.568]             else {
[17:46:44.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.568]             }
[17:46:44.568]             {
[17:46:44.568]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.568]                   0L) {
[17:46:44.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.568]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.568]                   base::options(opts)
[17:46:44.568]                 }
[17:46:44.568]                 {
[17:46:44.568]                   {
[17:46:44.568]                     NULL
[17:46:44.568]                     RNGkind("Mersenne-Twister")
[17:46:44.568]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.568]                       inherits = FALSE)
[17:46:44.568]                   }
[17:46:44.568]                   options(future.plan = NULL)
[17:46:44.568]                   if (is.na(NA_character_)) 
[17:46:44.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.568]                     .init = FALSE)
[17:46:44.568]                 }
[17:46:44.568]             }
[17:46:44.568]         }
[17:46:44.568]     })
[17:46:44.568]     if (TRUE) {
[17:46:44.568]         base::sink(type = "output", split = FALSE)
[17:46:44.568]         if (TRUE) {
[17:46:44.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.568]         }
[17:46:44.568]         else {
[17:46:44.568]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.568]         }
[17:46:44.568]         base::close(...future.stdout)
[17:46:44.568]         ...future.stdout <- NULL
[17:46:44.568]     }
[17:46:44.568]     ...future.result$conditions <- ...future.conditions
[17:46:44.568]     ...future.result$finished <- base::Sys.time()
[17:46:44.568]     ...future.result
[17:46:44.568] }
[17:46:44.570] plan(): Setting new future strategy stack:
[17:46:44.570] List of future strategies:
[17:46:44.570] 1. sequential:
[17:46:44.570]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.570]    - tweaked: FALSE
[17:46:44.570]    - call: NULL
[17:46:44.570] plan(): nbrOfWorkers() = 1
[17:46:44.571] plan(): Setting new future strategy stack:
[17:46:44.571] List of future strategies:
[17:46:44.571] 1. sequential:
[17:46:44.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.571]    - tweaked: FALSE
[17:46:44.571]    - call: plan(strategy)
[17:46:44.572] plan(): nbrOfWorkers() = 1
[17:46:44.572] SequentialFuture started (and completed)
[17:46:44.572] - Launch lazy future ... done
[17:46:44.572] run() for ‘SequentialFuture’ ... done
[17:46:44.572] getGlobalsAndPackages() ...
[17:46:44.572] Searching for globals...
[17:46:44.573] 
[17:46:44.573] Searching for globals ... DONE
[17:46:44.573] - globals: [0] <none>
[17:46:44.574] getGlobalsAndPackages() ... DONE
[17:46:44.574] run() for ‘Future’ ...
[17:46:44.575] - state: ‘created’
[17:46:44.575] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.575]   - Field: ‘label’
[17:46:44.575]   - Field: ‘local’
[17:46:44.575]   - Field: ‘owner’
[17:46:44.575]   - Field: ‘envir’
[17:46:44.576]   - Field: ‘packages’
[17:46:44.576]   - Field: ‘gc’
[17:46:44.576]   - Field: ‘conditions’
[17:46:44.576]   - Field: ‘expr’
[17:46:44.576]   - Field: ‘uuid’
[17:46:44.576]   - Field: ‘seed’
[17:46:44.576]   - Field: ‘version’
[17:46:44.576]   - Field: ‘result’
[17:46:44.576]   - Field: ‘asynchronous’
[17:46:44.576]   - Field: ‘calls’
[17:46:44.576]   - Field: ‘globals’
[17:46:44.577]   - Field: ‘stdout’
[17:46:44.577]   - Field: ‘earlySignal’
[17:46:44.577]   - Field: ‘lazy’
[17:46:44.577]   - Field: ‘state’
[17:46:44.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.577] - Launch lazy future ...
[17:46:44.577] Packages needed by the future expression (n = 0): <none>
[17:46:44.577] Packages needed by future strategies (n = 0): <none>
[17:46:44.578] {
[17:46:44.578]     {
[17:46:44.578]         {
[17:46:44.578]             ...future.startTime <- base::Sys.time()
[17:46:44.578]             {
[17:46:44.578]                 {
[17:46:44.578]                   {
[17:46:44.578]                     base::local({
[17:46:44.578]                       has_future <- base::requireNamespace("future", 
[17:46:44.578]                         quietly = TRUE)
[17:46:44.578]                       if (has_future) {
[17:46:44.578]                         ns <- base::getNamespace("future")
[17:46:44.578]                         version <- ns[[".package"]][["version"]]
[17:46:44.578]                         if (is.null(version)) 
[17:46:44.578]                           version <- utils::packageVersion("future")
[17:46:44.578]                       }
[17:46:44.578]                       else {
[17:46:44.578]                         version <- NULL
[17:46:44.578]                       }
[17:46:44.578]                       if (!has_future || version < "1.8.0") {
[17:46:44.578]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.578]                           "", base::R.version$version.string), 
[17:46:44.578]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.578]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.578]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.578]                             "release", "version")], collapse = " "), 
[17:46:44.578]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.578]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.578]                           info)
[17:46:44.578]                         info <- base::paste(info, collapse = "; ")
[17:46:44.578]                         if (!has_future) {
[17:46:44.578]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.578]                             info)
[17:46:44.578]                         }
[17:46:44.578]                         else {
[17:46:44.578]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.578]                             info, version)
[17:46:44.578]                         }
[17:46:44.578]                         base::stop(msg)
[17:46:44.578]                       }
[17:46:44.578]                     })
[17:46:44.578]                   }
[17:46:44.578]                   ...future.strategy.old <- future::plan("list")
[17:46:44.578]                   options(future.plan = NULL)
[17:46:44.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.578]                 }
[17:46:44.578]                 ...future.workdir <- getwd()
[17:46:44.578]             }
[17:46:44.578]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.578]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.578]         }
[17:46:44.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.578]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.578]             base::names(...future.oldOptions))
[17:46:44.578]     }
[17:46:44.578]     if (FALSE) {
[17:46:44.578]     }
[17:46:44.578]     else {
[17:46:44.578]         if (TRUE) {
[17:46:44.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.578]                 open = "w")
[17:46:44.578]         }
[17:46:44.578]         else {
[17:46:44.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.578]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.578]         }
[17:46:44.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.578]             base::sink(type = "output", split = FALSE)
[17:46:44.578]             base::close(...future.stdout)
[17:46:44.578]         }, add = TRUE)
[17:46:44.578]     }
[17:46:44.578]     ...future.frame <- base::sys.nframe()
[17:46:44.578]     ...future.conditions <- base::list()
[17:46:44.578]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.578]     if (FALSE) {
[17:46:44.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.578]     }
[17:46:44.578]     ...future.result <- base::tryCatch({
[17:46:44.578]         base::withCallingHandlers({
[17:46:44.578]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.578]             future::FutureResult(value = ...future.value$value, 
[17:46:44.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.578]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.578]                     ...future.globalenv.names))
[17:46:44.578]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.578]         }, condition = base::local({
[17:46:44.578]             c <- base::c
[17:46:44.578]             inherits <- base::inherits
[17:46:44.578]             invokeRestart <- base::invokeRestart
[17:46:44.578]             length <- base::length
[17:46:44.578]             list <- base::list
[17:46:44.578]             seq.int <- base::seq.int
[17:46:44.578]             signalCondition <- base::signalCondition
[17:46:44.578]             sys.calls <- base::sys.calls
[17:46:44.578]             `[[` <- base::`[[`
[17:46:44.578]             `+` <- base::`+`
[17:46:44.578]             `<<-` <- base::`<<-`
[17:46:44.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.578]                   3L)]
[17:46:44.578]             }
[17:46:44.578]             function(cond) {
[17:46:44.578]                 is_error <- inherits(cond, "error")
[17:46:44.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.578]                   NULL)
[17:46:44.578]                 if (is_error) {
[17:46:44.578]                   sessionInformation <- function() {
[17:46:44.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.578]                       search = base::search(), system = base::Sys.info())
[17:46:44.578]                   }
[17:46:44.578]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.578]                     cond$call), session = sessionInformation(), 
[17:46:44.578]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.578]                   signalCondition(cond)
[17:46:44.578]                 }
[17:46:44.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.578]                 "immediateCondition"))) {
[17:46:44.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.578]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.578]                   if (TRUE && !signal) {
[17:46:44.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.578]                     {
[17:46:44.578]                       inherits <- base::inherits
[17:46:44.578]                       invokeRestart <- base::invokeRestart
[17:46:44.578]                       is.null <- base::is.null
[17:46:44.578]                       muffled <- FALSE
[17:46:44.578]                       if (inherits(cond, "message")) {
[17:46:44.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.578]                         if (muffled) 
[17:46:44.578]                           invokeRestart("muffleMessage")
[17:46:44.578]                       }
[17:46:44.578]                       else if (inherits(cond, "warning")) {
[17:46:44.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.578]                         if (muffled) 
[17:46:44.578]                           invokeRestart("muffleWarning")
[17:46:44.578]                       }
[17:46:44.578]                       else if (inherits(cond, "condition")) {
[17:46:44.578]                         if (!is.null(pattern)) {
[17:46:44.578]                           computeRestarts <- base::computeRestarts
[17:46:44.578]                           grepl <- base::grepl
[17:46:44.578]                           restarts <- computeRestarts(cond)
[17:46:44.578]                           for (restart in restarts) {
[17:46:44.578]                             name <- restart$name
[17:46:44.578]                             if (is.null(name)) 
[17:46:44.578]                               next
[17:46:44.578]                             if (!grepl(pattern, name)) 
[17:46:44.578]                               next
[17:46:44.578]                             invokeRestart(restart)
[17:46:44.578]                             muffled <- TRUE
[17:46:44.578]                             break
[17:46:44.578]                           }
[17:46:44.578]                         }
[17:46:44.578]                       }
[17:46:44.578]                       invisible(muffled)
[17:46:44.578]                     }
[17:46:44.578]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.578]                   }
[17:46:44.578]                 }
[17:46:44.578]                 else {
[17:46:44.578]                   if (TRUE) {
[17:46:44.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.578]                     {
[17:46:44.578]                       inherits <- base::inherits
[17:46:44.578]                       invokeRestart <- base::invokeRestart
[17:46:44.578]                       is.null <- base::is.null
[17:46:44.578]                       muffled <- FALSE
[17:46:44.578]                       if (inherits(cond, "message")) {
[17:46:44.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.578]                         if (muffled) 
[17:46:44.578]                           invokeRestart("muffleMessage")
[17:46:44.578]                       }
[17:46:44.578]                       else if (inherits(cond, "warning")) {
[17:46:44.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.578]                         if (muffled) 
[17:46:44.578]                           invokeRestart("muffleWarning")
[17:46:44.578]                       }
[17:46:44.578]                       else if (inherits(cond, "condition")) {
[17:46:44.578]                         if (!is.null(pattern)) {
[17:46:44.578]                           computeRestarts <- base::computeRestarts
[17:46:44.578]                           grepl <- base::grepl
[17:46:44.578]                           restarts <- computeRestarts(cond)
[17:46:44.578]                           for (restart in restarts) {
[17:46:44.578]                             name <- restart$name
[17:46:44.578]                             if (is.null(name)) 
[17:46:44.578]                               next
[17:46:44.578]                             if (!grepl(pattern, name)) 
[17:46:44.578]                               next
[17:46:44.578]                             invokeRestart(restart)
[17:46:44.578]                             muffled <- TRUE
[17:46:44.578]                             break
[17:46:44.578]                           }
[17:46:44.578]                         }
[17:46:44.578]                       }
[17:46:44.578]                       invisible(muffled)
[17:46:44.578]                     }
[17:46:44.578]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.578]                   }
[17:46:44.578]                 }
[17:46:44.578]             }
[17:46:44.578]         }))
[17:46:44.578]     }, error = function(ex) {
[17:46:44.578]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.578]                 ...future.rng), started = ...future.startTime, 
[17:46:44.578]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.578]             version = "1.8"), class = "FutureResult")
[17:46:44.578]     }, finally = {
[17:46:44.578]         if (!identical(...future.workdir, getwd())) 
[17:46:44.578]             setwd(...future.workdir)
[17:46:44.578]         {
[17:46:44.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.578]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.578]             }
[17:46:44.578]             base::options(...future.oldOptions)
[17:46:44.578]             if (.Platform$OS.type == "windows") {
[17:46:44.578]                 old_names <- names(...future.oldEnvVars)
[17:46:44.578]                 envs <- base::Sys.getenv()
[17:46:44.578]                 names <- names(envs)
[17:46:44.578]                 common <- intersect(names, old_names)
[17:46:44.578]                 added <- setdiff(names, old_names)
[17:46:44.578]                 removed <- setdiff(old_names, names)
[17:46:44.578]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.578]                   envs[common]]
[17:46:44.578]                 NAMES <- toupper(changed)
[17:46:44.578]                 args <- list()
[17:46:44.578]                 for (kk in seq_along(NAMES)) {
[17:46:44.578]                   name <- changed[[kk]]
[17:46:44.578]                   NAME <- NAMES[[kk]]
[17:46:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.578]                     next
[17:46:44.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.578]                 }
[17:46:44.578]                 NAMES <- toupper(added)
[17:46:44.578]                 for (kk in seq_along(NAMES)) {
[17:46:44.578]                   name <- added[[kk]]
[17:46:44.578]                   NAME <- NAMES[[kk]]
[17:46:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.578]                     next
[17:46:44.578]                   args[[name]] <- ""
[17:46:44.578]                 }
[17:46:44.578]                 NAMES <- toupper(removed)
[17:46:44.578]                 for (kk in seq_along(NAMES)) {
[17:46:44.578]                   name <- removed[[kk]]
[17:46:44.578]                   NAME <- NAMES[[kk]]
[17:46:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.578]                     next
[17:46:44.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.578]                 }
[17:46:44.578]                 if (length(args) > 0) 
[17:46:44.578]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.578]             }
[17:46:44.578]             else {
[17:46:44.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.578]             }
[17:46:44.578]             {
[17:46:44.578]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.578]                   0L) {
[17:46:44.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.578]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.578]                   base::options(opts)
[17:46:44.578]                 }
[17:46:44.578]                 {
[17:46:44.578]                   {
[17:46:44.578]                     NULL
[17:46:44.578]                     RNGkind("Mersenne-Twister")
[17:46:44.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.578]                       inherits = FALSE)
[17:46:44.578]                   }
[17:46:44.578]                   options(future.plan = NULL)
[17:46:44.578]                   if (is.na(NA_character_)) 
[17:46:44.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.578]                     .init = FALSE)
[17:46:44.578]                 }
[17:46:44.578]             }
[17:46:44.578]         }
[17:46:44.578]     })
[17:46:44.578]     if (TRUE) {
[17:46:44.578]         base::sink(type = "output", split = FALSE)
[17:46:44.578]         if (TRUE) {
[17:46:44.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.578]         }
[17:46:44.578]         else {
[17:46:44.578]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.578]         }
[17:46:44.578]         base::close(...future.stdout)
[17:46:44.578]         ...future.stdout <- NULL
[17:46:44.578]     }
[17:46:44.578]     ...future.result$conditions <- ...future.conditions
[17:46:44.578]     ...future.result$finished <- base::Sys.time()
[17:46:44.578]     ...future.result
[17:46:44.578] }
[17:46:44.579] plan(): Setting new future strategy stack:
[17:46:44.579] List of future strategies:
[17:46:44.579] 1. sequential:
[17:46:44.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.579]    - tweaked: FALSE
[17:46:44.579]    - call: NULL
[17:46:44.580] plan(): nbrOfWorkers() = 1
[17:46:44.580] plan(): Setting new future strategy stack:
[17:46:44.581] List of future strategies:
[17:46:44.581] 1. sequential:
[17:46:44.581]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.581]    - tweaked: FALSE
[17:46:44.581]    - call: plan(strategy)
[17:46:44.581] plan(): nbrOfWorkers() = 1
[17:46:44.581] SequentialFuture started (and completed)
[17:46:44.581] - Launch lazy future ... done
[17:46:44.581] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561787d0bd30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561786e871d8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561787d0bd30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561786e871d8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:44.586] resolved() for ‘SequentialFuture’ ...
[17:46:44.586] - state: ‘finished’
[17:46:44.587] - run: TRUE
[17:46:44.587] - result: ‘FutureResult’
[17:46:44.587] resolved() for ‘SequentialFuture’ ... done
[17:46:44.587] resolved() for ‘SequentialFuture’ ...
[17:46:44.587] - state: ‘finished’
[17:46:44.587] - run: TRUE
[17:46:44.587] - result: ‘FutureResult’
[17:46:44.587] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:44.589] resolve() on list ...
[17:46:44.589]  recursive: 0
[17:46:44.589]  length: 6
[17:46:44.589]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:44.589] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.589] - nx: 6
[17:46:44.589] - relay: TRUE
[17:46:44.589] - stdout: TRUE
[17:46:44.590] - signal: TRUE
[17:46:44.590] - resignal: FALSE
[17:46:44.590] - force: TRUE
[17:46:44.590] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.590] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.590]  - until=2
[17:46:44.590]  - relaying element #2
[17:46:44.590] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.590] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.590] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.590]  length: 5 (resolved future 1)
[17:46:44.591] resolved() for ‘SequentialFuture’ ...
[17:46:44.591] - state: ‘finished’
[17:46:44.591] - run: TRUE
[17:46:44.591] - result: ‘FutureResult’
[17:46:44.591] resolved() for ‘SequentialFuture’ ... done
[17:46:44.591] Future #2
[17:46:44.591] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.591] - nx: 6
[17:46:44.591] - relay: TRUE
[17:46:44.592] - stdout: TRUE
[17:46:44.592] - signal: TRUE
[17:46:44.592] - resignal: FALSE
[17:46:44.592] - force: TRUE
[17:46:44.592] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.592] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.592]  - until=2
[17:46:44.592]  - relaying element #2
[17:46:44.592] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.592] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.593] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.593]  length: 4 (resolved future 2)
[17:46:44.593] resolved() for ‘SequentialFuture’ ...
[17:46:44.593] - state: ‘finished’
[17:46:44.593] - run: TRUE
[17:46:44.593] - result: ‘FutureResult’
[17:46:44.593] resolved() for ‘SequentialFuture’ ... done
[17:46:44.593] Future #3
[17:46:44.593] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.593] - nx: 6
[17:46:44.594] - relay: TRUE
[17:46:44.594] - stdout: TRUE
[17:46:44.594] - signal: TRUE
[17:46:44.594] - resignal: FALSE
[17:46:44.594] - force: TRUE
[17:46:44.594] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.594] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.594]  - until=3
[17:46:44.594]  - relaying element #3
[17:46:44.594] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.594] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.595] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.595]  length: 3 (resolved future 3)
[17:46:44.595] signalConditionsASAP(NULL, pos=4) ...
[17:46:44.595] - nx: 6
[17:46:44.595] - relay: TRUE
[17:46:44.595] - stdout: TRUE
[17:46:44.595] - signal: TRUE
[17:46:44.595] - resignal: FALSE
[17:46:44.595] - force: TRUE
[17:46:44.595] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.595] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.596]  - until=5
[17:46:44.596]  - relaying element #5
[17:46:44.596] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.596] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.596] signalConditionsASAP(NULL, pos=4) ... done
[17:46:44.596]  length: 2 (resolved future 4)
[17:46:44.596] signalConditionsASAP(NULL, pos=5) ...
[17:46:44.596] - nx: 6
[17:46:44.596] - relay: TRUE
[17:46:44.596] - stdout: TRUE
[17:46:44.596] - signal: TRUE
[17:46:44.596] - resignal: FALSE
[17:46:44.597] - force: TRUE
[17:46:44.597] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.597] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.597]  - until=6
[17:46:44.597]  - relaying element #6
[17:46:44.597] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.597] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.597] signalConditionsASAP(NULL, pos=5) ... done
[17:46:44.597]  length: 1 (resolved future 5)
[17:46:44.597] signalConditionsASAP(numeric, pos=6) ...
[17:46:44.597] - nx: 6
[17:46:44.597] - relay: TRUE
[17:46:44.598] - stdout: TRUE
[17:46:44.598] - signal: TRUE
[17:46:44.598] - resignal: FALSE
[17:46:44.598] - force: TRUE
[17:46:44.598] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.598] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.598]  - until=6
[17:46:44.598] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.598] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.598] signalConditionsASAP(numeric, pos=6) ... done
[17:46:44.598]  length: 0 (resolved future 6)
[17:46:44.598] Relaying remaining futures
[17:46:44.599] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.599] - nx: 6
[17:46:44.599] - relay: TRUE
[17:46:44.599] - stdout: TRUE
[17:46:44.599] - signal: TRUE
[17:46:44.599] - resignal: FALSE
[17:46:44.599] - force: TRUE
[17:46:44.599] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.599] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:44.599] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.599] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.600] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.600] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:46:44.605] getGlobalsAndPackages() ...
[17:46:44.605] Searching for globals...
[17:46:44.605] 
[17:46:44.606] Searching for globals ... DONE
[17:46:44.606] - globals: [0] <none>
[17:46:44.606] getGlobalsAndPackages() ... DONE
[17:46:44.606] run() for ‘Future’ ...
[17:46:44.606] - state: ‘created’
[17:46:44.606] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.607] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.607]   - Field: ‘label’
[17:46:44.607]   - Field: ‘local’
[17:46:44.607]   - Field: ‘owner’
[17:46:44.607]   - Field: ‘envir’
[17:46:44.607]   - Field: ‘packages’
[17:46:44.607]   - Field: ‘gc’
[17:46:44.607]   - Field: ‘conditions’
[17:46:44.607]   - Field: ‘expr’
[17:46:44.608]   - Field: ‘uuid’
[17:46:44.608]   - Field: ‘seed’
[17:46:44.608]   - Field: ‘version’
[17:46:44.608]   - Field: ‘result’
[17:46:44.608]   - Field: ‘asynchronous’
[17:46:44.608]   - Field: ‘calls’
[17:46:44.608]   - Field: ‘globals’
[17:46:44.608]   - Field: ‘stdout’
[17:46:44.608]   - Field: ‘earlySignal’
[17:46:44.608]   - Field: ‘lazy’
[17:46:44.608]   - Field: ‘state’
[17:46:44.608] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.609] - Launch lazy future ...
[17:46:44.609] Packages needed by the future expression (n = 0): <none>
[17:46:44.609] Packages needed by future strategies (n = 0): <none>
[17:46:44.609] {
[17:46:44.609]     {
[17:46:44.609]         {
[17:46:44.609]             ...future.startTime <- base::Sys.time()
[17:46:44.609]             {
[17:46:44.609]                 {
[17:46:44.609]                   {
[17:46:44.609]                     base::local({
[17:46:44.609]                       has_future <- base::requireNamespace("future", 
[17:46:44.609]                         quietly = TRUE)
[17:46:44.609]                       if (has_future) {
[17:46:44.609]                         ns <- base::getNamespace("future")
[17:46:44.609]                         version <- ns[[".package"]][["version"]]
[17:46:44.609]                         if (is.null(version)) 
[17:46:44.609]                           version <- utils::packageVersion("future")
[17:46:44.609]                       }
[17:46:44.609]                       else {
[17:46:44.609]                         version <- NULL
[17:46:44.609]                       }
[17:46:44.609]                       if (!has_future || version < "1.8.0") {
[17:46:44.609]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.609]                           "", base::R.version$version.string), 
[17:46:44.609]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.609]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.609]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.609]                             "release", "version")], collapse = " "), 
[17:46:44.609]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.609]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.609]                           info)
[17:46:44.609]                         info <- base::paste(info, collapse = "; ")
[17:46:44.609]                         if (!has_future) {
[17:46:44.609]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.609]                             info)
[17:46:44.609]                         }
[17:46:44.609]                         else {
[17:46:44.609]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.609]                             info, version)
[17:46:44.609]                         }
[17:46:44.609]                         base::stop(msg)
[17:46:44.609]                       }
[17:46:44.609]                     })
[17:46:44.609]                   }
[17:46:44.609]                   ...future.strategy.old <- future::plan("list")
[17:46:44.609]                   options(future.plan = NULL)
[17:46:44.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.609]                 }
[17:46:44.609]                 ...future.workdir <- getwd()
[17:46:44.609]             }
[17:46:44.609]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.609]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.609]         }
[17:46:44.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.609]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.609]             base::names(...future.oldOptions))
[17:46:44.609]     }
[17:46:44.609]     if (FALSE) {
[17:46:44.609]     }
[17:46:44.609]     else {
[17:46:44.609]         if (TRUE) {
[17:46:44.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.609]                 open = "w")
[17:46:44.609]         }
[17:46:44.609]         else {
[17:46:44.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.609]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.609]         }
[17:46:44.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.609]             base::sink(type = "output", split = FALSE)
[17:46:44.609]             base::close(...future.stdout)
[17:46:44.609]         }, add = TRUE)
[17:46:44.609]     }
[17:46:44.609]     ...future.frame <- base::sys.nframe()
[17:46:44.609]     ...future.conditions <- base::list()
[17:46:44.609]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.609]     if (FALSE) {
[17:46:44.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.609]     }
[17:46:44.609]     ...future.result <- base::tryCatch({
[17:46:44.609]         base::withCallingHandlers({
[17:46:44.609]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.609]             future::FutureResult(value = ...future.value$value, 
[17:46:44.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.609]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.609]                     ...future.globalenv.names))
[17:46:44.609]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.609]         }, condition = base::local({
[17:46:44.609]             c <- base::c
[17:46:44.609]             inherits <- base::inherits
[17:46:44.609]             invokeRestart <- base::invokeRestart
[17:46:44.609]             length <- base::length
[17:46:44.609]             list <- base::list
[17:46:44.609]             seq.int <- base::seq.int
[17:46:44.609]             signalCondition <- base::signalCondition
[17:46:44.609]             sys.calls <- base::sys.calls
[17:46:44.609]             `[[` <- base::`[[`
[17:46:44.609]             `+` <- base::`+`
[17:46:44.609]             `<<-` <- base::`<<-`
[17:46:44.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.609]                   3L)]
[17:46:44.609]             }
[17:46:44.609]             function(cond) {
[17:46:44.609]                 is_error <- inherits(cond, "error")
[17:46:44.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.609]                   NULL)
[17:46:44.609]                 if (is_error) {
[17:46:44.609]                   sessionInformation <- function() {
[17:46:44.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.609]                       search = base::search(), system = base::Sys.info())
[17:46:44.609]                   }
[17:46:44.609]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.609]                     cond$call), session = sessionInformation(), 
[17:46:44.609]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.609]                   signalCondition(cond)
[17:46:44.609]                 }
[17:46:44.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.609]                 "immediateCondition"))) {
[17:46:44.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.609]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.609]                   if (TRUE && !signal) {
[17:46:44.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.609]                     {
[17:46:44.609]                       inherits <- base::inherits
[17:46:44.609]                       invokeRestart <- base::invokeRestart
[17:46:44.609]                       is.null <- base::is.null
[17:46:44.609]                       muffled <- FALSE
[17:46:44.609]                       if (inherits(cond, "message")) {
[17:46:44.609]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.609]                         if (muffled) 
[17:46:44.609]                           invokeRestart("muffleMessage")
[17:46:44.609]                       }
[17:46:44.609]                       else if (inherits(cond, "warning")) {
[17:46:44.609]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.609]                         if (muffled) 
[17:46:44.609]                           invokeRestart("muffleWarning")
[17:46:44.609]                       }
[17:46:44.609]                       else if (inherits(cond, "condition")) {
[17:46:44.609]                         if (!is.null(pattern)) {
[17:46:44.609]                           computeRestarts <- base::computeRestarts
[17:46:44.609]                           grepl <- base::grepl
[17:46:44.609]                           restarts <- computeRestarts(cond)
[17:46:44.609]                           for (restart in restarts) {
[17:46:44.609]                             name <- restart$name
[17:46:44.609]                             if (is.null(name)) 
[17:46:44.609]                               next
[17:46:44.609]                             if (!grepl(pattern, name)) 
[17:46:44.609]                               next
[17:46:44.609]                             invokeRestart(restart)
[17:46:44.609]                             muffled <- TRUE
[17:46:44.609]                             break
[17:46:44.609]                           }
[17:46:44.609]                         }
[17:46:44.609]                       }
[17:46:44.609]                       invisible(muffled)
[17:46:44.609]                     }
[17:46:44.609]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.609]                   }
[17:46:44.609]                 }
[17:46:44.609]                 else {
[17:46:44.609]                   if (TRUE) {
[17:46:44.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.609]                     {
[17:46:44.609]                       inherits <- base::inherits
[17:46:44.609]                       invokeRestart <- base::invokeRestart
[17:46:44.609]                       is.null <- base::is.null
[17:46:44.609]                       muffled <- FALSE
[17:46:44.609]                       if (inherits(cond, "message")) {
[17:46:44.609]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.609]                         if (muffled) 
[17:46:44.609]                           invokeRestart("muffleMessage")
[17:46:44.609]                       }
[17:46:44.609]                       else if (inherits(cond, "warning")) {
[17:46:44.609]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.609]                         if (muffled) 
[17:46:44.609]                           invokeRestart("muffleWarning")
[17:46:44.609]                       }
[17:46:44.609]                       else if (inherits(cond, "condition")) {
[17:46:44.609]                         if (!is.null(pattern)) {
[17:46:44.609]                           computeRestarts <- base::computeRestarts
[17:46:44.609]                           grepl <- base::grepl
[17:46:44.609]                           restarts <- computeRestarts(cond)
[17:46:44.609]                           for (restart in restarts) {
[17:46:44.609]                             name <- restart$name
[17:46:44.609]                             if (is.null(name)) 
[17:46:44.609]                               next
[17:46:44.609]                             if (!grepl(pattern, name)) 
[17:46:44.609]                               next
[17:46:44.609]                             invokeRestart(restart)
[17:46:44.609]                             muffled <- TRUE
[17:46:44.609]                             break
[17:46:44.609]                           }
[17:46:44.609]                         }
[17:46:44.609]                       }
[17:46:44.609]                       invisible(muffled)
[17:46:44.609]                     }
[17:46:44.609]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.609]                   }
[17:46:44.609]                 }
[17:46:44.609]             }
[17:46:44.609]         }))
[17:46:44.609]     }, error = function(ex) {
[17:46:44.609]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.609]                 ...future.rng), started = ...future.startTime, 
[17:46:44.609]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.609]             version = "1.8"), class = "FutureResult")
[17:46:44.609]     }, finally = {
[17:46:44.609]         if (!identical(...future.workdir, getwd())) 
[17:46:44.609]             setwd(...future.workdir)
[17:46:44.609]         {
[17:46:44.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.609]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.609]             }
[17:46:44.609]             base::options(...future.oldOptions)
[17:46:44.609]             if (.Platform$OS.type == "windows") {
[17:46:44.609]                 old_names <- names(...future.oldEnvVars)
[17:46:44.609]                 envs <- base::Sys.getenv()
[17:46:44.609]                 names <- names(envs)
[17:46:44.609]                 common <- intersect(names, old_names)
[17:46:44.609]                 added <- setdiff(names, old_names)
[17:46:44.609]                 removed <- setdiff(old_names, names)
[17:46:44.609]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.609]                   envs[common]]
[17:46:44.609]                 NAMES <- toupper(changed)
[17:46:44.609]                 args <- list()
[17:46:44.609]                 for (kk in seq_along(NAMES)) {
[17:46:44.609]                   name <- changed[[kk]]
[17:46:44.609]                   NAME <- NAMES[[kk]]
[17:46:44.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.609]                     next
[17:46:44.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.609]                 }
[17:46:44.609]                 NAMES <- toupper(added)
[17:46:44.609]                 for (kk in seq_along(NAMES)) {
[17:46:44.609]                   name <- added[[kk]]
[17:46:44.609]                   NAME <- NAMES[[kk]]
[17:46:44.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.609]                     next
[17:46:44.609]                   args[[name]] <- ""
[17:46:44.609]                 }
[17:46:44.609]                 NAMES <- toupper(removed)
[17:46:44.609]                 for (kk in seq_along(NAMES)) {
[17:46:44.609]                   name <- removed[[kk]]
[17:46:44.609]                   NAME <- NAMES[[kk]]
[17:46:44.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.609]                     next
[17:46:44.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.609]                 }
[17:46:44.609]                 if (length(args) > 0) 
[17:46:44.609]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.609]             }
[17:46:44.609]             else {
[17:46:44.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.609]             }
[17:46:44.609]             {
[17:46:44.609]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.609]                   0L) {
[17:46:44.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.609]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.609]                   base::options(opts)
[17:46:44.609]                 }
[17:46:44.609]                 {
[17:46:44.609]                   {
[17:46:44.609]                     NULL
[17:46:44.609]                     RNGkind("Mersenne-Twister")
[17:46:44.609]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.609]                       inherits = FALSE)
[17:46:44.609]                   }
[17:46:44.609]                   options(future.plan = NULL)
[17:46:44.609]                   if (is.na(NA_character_)) 
[17:46:44.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.609]                     .init = FALSE)
[17:46:44.609]                 }
[17:46:44.609]             }
[17:46:44.609]         }
[17:46:44.609]     })
[17:46:44.609]     if (TRUE) {
[17:46:44.609]         base::sink(type = "output", split = FALSE)
[17:46:44.609]         if (TRUE) {
[17:46:44.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.609]         }
[17:46:44.609]         else {
[17:46:44.609]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.609]         }
[17:46:44.609]         base::close(...future.stdout)
[17:46:44.609]         ...future.stdout <- NULL
[17:46:44.609]     }
[17:46:44.609]     ...future.result$conditions <- ...future.conditions
[17:46:44.609]     ...future.result$finished <- base::Sys.time()
[17:46:44.609]     ...future.result
[17:46:44.609] }
[17:46:44.611] plan(): Setting new future strategy stack:
[17:46:44.611] List of future strategies:
[17:46:44.611] 1. sequential:
[17:46:44.611]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.611]    - tweaked: FALSE
[17:46:44.611]    - call: NULL
[17:46:44.612] plan(): nbrOfWorkers() = 1
[17:46:44.612] plan(): Setting new future strategy stack:
[17:46:44.613] List of future strategies:
[17:46:44.613] 1. sequential:
[17:46:44.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.613]    - tweaked: FALSE
[17:46:44.613]    - call: plan(strategy)
[17:46:44.613] plan(): nbrOfWorkers() = 1
[17:46:44.613] SequentialFuture started (and completed)
[17:46:44.613] - Launch lazy future ... done
[17:46:44.613] run() for ‘SequentialFuture’ ... done
[17:46:44.614] getGlobalsAndPackages() ...
[17:46:44.614] Searching for globals...
[17:46:44.614] 
[17:46:44.614] Searching for globals ... DONE
[17:46:44.614] - globals: [0] <none>
[17:46:44.614] getGlobalsAndPackages() ... DONE
[17:46:44.614] run() for ‘Future’ ...
[17:46:44.615] - state: ‘created’
[17:46:44.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.615] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.615]   - Field: ‘label’
[17:46:44.615]   - Field: ‘local’
[17:46:44.615]   - Field: ‘owner’
[17:46:44.615]   - Field: ‘envir’
[17:46:44.616]   - Field: ‘packages’
[17:46:44.616]   - Field: ‘gc’
[17:46:44.616]   - Field: ‘conditions’
[17:46:44.616]   - Field: ‘expr’
[17:46:44.616]   - Field: ‘uuid’
[17:46:44.616]   - Field: ‘seed’
[17:46:44.616]   - Field: ‘version’
[17:46:44.616]   - Field: ‘result’
[17:46:44.616]   - Field: ‘asynchronous’
[17:46:44.616]   - Field: ‘calls’
[17:46:44.616]   - Field: ‘globals’
[17:46:44.617]   - Field: ‘stdout’
[17:46:44.617]   - Field: ‘earlySignal’
[17:46:44.617]   - Field: ‘lazy’
[17:46:44.617]   - Field: ‘state’
[17:46:44.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.617] - Launch lazy future ...
[17:46:44.617] Packages needed by the future expression (n = 0): <none>
[17:46:44.617] Packages needed by future strategies (n = 0): <none>
[17:46:44.618] {
[17:46:44.618]     {
[17:46:44.618]         {
[17:46:44.618]             ...future.startTime <- base::Sys.time()
[17:46:44.618]             {
[17:46:44.618]                 {
[17:46:44.618]                   {
[17:46:44.618]                     base::local({
[17:46:44.618]                       has_future <- base::requireNamespace("future", 
[17:46:44.618]                         quietly = TRUE)
[17:46:44.618]                       if (has_future) {
[17:46:44.618]                         ns <- base::getNamespace("future")
[17:46:44.618]                         version <- ns[[".package"]][["version"]]
[17:46:44.618]                         if (is.null(version)) 
[17:46:44.618]                           version <- utils::packageVersion("future")
[17:46:44.618]                       }
[17:46:44.618]                       else {
[17:46:44.618]                         version <- NULL
[17:46:44.618]                       }
[17:46:44.618]                       if (!has_future || version < "1.8.0") {
[17:46:44.618]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.618]                           "", base::R.version$version.string), 
[17:46:44.618]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.618]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.618]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.618]                             "release", "version")], collapse = " "), 
[17:46:44.618]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.618]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.618]                           info)
[17:46:44.618]                         info <- base::paste(info, collapse = "; ")
[17:46:44.618]                         if (!has_future) {
[17:46:44.618]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.618]                             info)
[17:46:44.618]                         }
[17:46:44.618]                         else {
[17:46:44.618]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.618]                             info, version)
[17:46:44.618]                         }
[17:46:44.618]                         base::stop(msg)
[17:46:44.618]                       }
[17:46:44.618]                     })
[17:46:44.618]                   }
[17:46:44.618]                   ...future.strategy.old <- future::plan("list")
[17:46:44.618]                   options(future.plan = NULL)
[17:46:44.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.618]                 }
[17:46:44.618]                 ...future.workdir <- getwd()
[17:46:44.618]             }
[17:46:44.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.618]         }
[17:46:44.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.618]             base::names(...future.oldOptions))
[17:46:44.618]     }
[17:46:44.618]     if (FALSE) {
[17:46:44.618]     }
[17:46:44.618]     else {
[17:46:44.618]         if (TRUE) {
[17:46:44.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.618]                 open = "w")
[17:46:44.618]         }
[17:46:44.618]         else {
[17:46:44.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.618]         }
[17:46:44.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.618]             base::sink(type = "output", split = FALSE)
[17:46:44.618]             base::close(...future.stdout)
[17:46:44.618]         }, add = TRUE)
[17:46:44.618]     }
[17:46:44.618]     ...future.frame <- base::sys.nframe()
[17:46:44.618]     ...future.conditions <- base::list()
[17:46:44.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.618]     if (FALSE) {
[17:46:44.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.618]     }
[17:46:44.618]     ...future.result <- base::tryCatch({
[17:46:44.618]         base::withCallingHandlers({
[17:46:44.618]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.618]             future::FutureResult(value = ...future.value$value, 
[17:46:44.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.618]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.618]                     ...future.globalenv.names))
[17:46:44.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.618]         }, condition = base::local({
[17:46:44.618]             c <- base::c
[17:46:44.618]             inherits <- base::inherits
[17:46:44.618]             invokeRestart <- base::invokeRestart
[17:46:44.618]             length <- base::length
[17:46:44.618]             list <- base::list
[17:46:44.618]             seq.int <- base::seq.int
[17:46:44.618]             signalCondition <- base::signalCondition
[17:46:44.618]             sys.calls <- base::sys.calls
[17:46:44.618]             `[[` <- base::`[[`
[17:46:44.618]             `+` <- base::`+`
[17:46:44.618]             `<<-` <- base::`<<-`
[17:46:44.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.618]                   3L)]
[17:46:44.618]             }
[17:46:44.618]             function(cond) {
[17:46:44.618]                 is_error <- inherits(cond, "error")
[17:46:44.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.618]                   NULL)
[17:46:44.618]                 if (is_error) {
[17:46:44.618]                   sessionInformation <- function() {
[17:46:44.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.618]                       search = base::search(), system = base::Sys.info())
[17:46:44.618]                   }
[17:46:44.618]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.618]                     cond$call), session = sessionInformation(), 
[17:46:44.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.618]                   signalCondition(cond)
[17:46:44.618]                 }
[17:46:44.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.618]                 "immediateCondition"))) {
[17:46:44.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.618]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.618]                   if (TRUE && !signal) {
[17:46:44.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.618]                     {
[17:46:44.618]                       inherits <- base::inherits
[17:46:44.618]                       invokeRestart <- base::invokeRestart
[17:46:44.618]                       is.null <- base::is.null
[17:46:44.618]                       muffled <- FALSE
[17:46:44.618]                       if (inherits(cond, "message")) {
[17:46:44.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.618]                         if (muffled) 
[17:46:44.618]                           invokeRestart("muffleMessage")
[17:46:44.618]                       }
[17:46:44.618]                       else if (inherits(cond, "warning")) {
[17:46:44.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.618]                         if (muffled) 
[17:46:44.618]                           invokeRestart("muffleWarning")
[17:46:44.618]                       }
[17:46:44.618]                       else if (inherits(cond, "condition")) {
[17:46:44.618]                         if (!is.null(pattern)) {
[17:46:44.618]                           computeRestarts <- base::computeRestarts
[17:46:44.618]                           grepl <- base::grepl
[17:46:44.618]                           restarts <- computeRestarts(cond)
[17:46:44.618]                           for (restart in restarts) {
[17:46:44.618]                             name <- restart$name
[17:46:44.618]                             if (is.null(name)) 
[17:46:44.618]                               next
[17:46:44.618]                             if (!grepl(pattern, name)) 
[17:46:44.618]                               next
[17:46:44.618]                             invokeRestart(restart)
[17:46:44.618]                             muffled <- TRUE
[17:46:44.618]                             break
[17:46:44.618]                           }
[17:46:44.618]                         }
[17:46:44.618]                       }
[17:46:44.618]                       invisible(muffled)
[17:46:44.618]                     }
[17:46:44.618]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.618]                   }
[17:46:44.618]                 }
[17:46:44.618]                 else {
[17:46:44.618]                   if (TRUE) {
[17:46:44.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.618]                     {
[17:46:44.618]                       inherits <- base::inherits
[17:46:44.618]                       invokeRestart <- base::invokeRestart
[17:46:44.618]                       is.null <- base::is.null
[17:46:44.618]                       muffled <- FALSE
[17:46:44.618]                       if (inherits(cond, "message")) {
[17:46:44.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.618]                         if (muffled) 
[17:46:44.618]                           invokeRestart("muffleMessage")
[17:46:44.618]                       }
[17:46:44.618]                       else if (inherits(cond, "warning")) {
[17:46:44.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.618]                         if (muffled) 
[17:46:44.618]                           invokeRestart("muffleWarning")
[17:46:44.618]                       }
[17:46:44.618]                       else if (inherits(cond, "condition")) {
[17:46:44.618]                         if (!is.null(pattern)) {
[17:46:44.618]                           computeRestarts <- base::computeRestarts
[17:46:44.618]                           grepl <- base::grepl
[17:46:44.618]                           restarts <- computeRestarts(cond)
[17:46:44.618]                           for (restart in restarts) {
[17:46:44.618]                             name <- restart$name
[17:46:44.618]                             if (is.null(name)) 
[17:46:44.618]                               next
[17:46:44.618]                             if (!grepl(pattern, name)) 
[17:46:44.618]                               next
[17:46:44.618]                             invokeRestart(restart)
[17:46:44.618]                             muffled <- TRUE
[17:46:44.618]                             break
[17:46:44.618]                           }
[17:46:44.618]                         }
[17:46:44.618]                       }
[17:46:44.618]                       invisible(muffled)
[17:46:44.618]                     }
[17:46:44.618]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.618]                   }
[17:46:44.618]                 }
[17:46:44.618]             }
[17:46:44.618]         }))
[17:46:44.618]     }, error = function(ex) {
[17:46:44.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.618]                 ...future.rng), started = ...future.startTime, 
[17:46:44.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.618]             version = "1.8"), class = "FutureResult")
[17:46:44.618]     }, finally = {
[17:46:44.618]         if (!identical(...future.workdir, getwd())) 
[17:46:44.618]             setwd(...future.workdir)
[17:46:44.618]         {
[17:46:44.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.618]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.618]             }
[17:46:44.618]             base::options(...future.oldOptions)
[17:46:44.618]             if (.Platform$OS.type == "windows") {
[17:46:44.618]                 old_names <- names(...future.oldEnvVars)
[17:46:44.618]                 envs <- base::Sys.getenv()
[17:46:44.618]                 names <- names(envs)
[17:46:44.618]                 common <- intersect(names, old_names)
[17:46:44.618]                 added <- setdiff(names, old_names)
[17:46:44.618]                 removed <- setdiff(old_names, names)
[17:46:44.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.618]                   envs[common]]
[17:46:44.618]                 NAMES <- toupper(changed)
[17:46:44.618]                 args <- list()
[17:46:44.618]                 for (kk in seq_along(NAMES)) {
[17:46:44.618]                   name <- changed[[kk]]
[17:46:44.618]                   NAME <- NAMES[[kk]]
[17:46:44.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.618]                     next
[17:46:44.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.618]                 }
[17:46:44.618]                 NAMES <- toupper(added)
[17:46:44.618]                 for (kk in seq_along(NAMES)) {
[17:46:44.618]                   name <- added[[kk]]
[17:46:44.618]                   NAME <- NAMES[[kk]]
[17:46:44.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.618]                     next
[17:46:44.618]                   args[[name]] <- ""
[17:46:44.618]                 }
[17:46:44.618]                 NAMES <- toupper(removed)
[17:46:44.618]                 for (kk in seq_along(NAMES)) {
[17:46:44.618]                   name <- removed[[kk]]
[17:46:44.618]                   NAME <- NAMES[[kk]]
[17:46:44.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.618]                     next
[17:46:44.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.618]                 }
[17:46:44.618]                 if (length(args) > 0) 
[17:46:44.618]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.618]             }
[17:46:44.618]             else {
[17:46:44.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.618]             }
[17:46:44.618]             {
[17:46:44.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.618]                   0L) {
[17:46:44.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.618]                   base::options(opts)
[17:46:44.618]                 }
[17:46:44.618]                 {
[17:46:44.618]                   {
[17:46:44.618]                     NULL
[17:46:44.618]                     RNGkind("Mersenne-Twister")
[17:46:44.618]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.618]                       inherits = FALSE)
[17:46:44.618]                   }
[17:46:44.618]                   options(future.plan = NULL)
[17:46:44.618]                   if (is.na(NA_character_)) 
[17:46:44.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.618]                     .init = FALSE)
[17:46:44.618]                 }
[17:46:44.618]             }
[17:46:44.618]         }
[17:46:44.618]     })
[17:46:44.618]     if (TRUE) {
[17:46:44.618]         base::sink(type = "output", split = FALSE)
[17:46:44.618]         if (TRUE) {
[17:46:44.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.618]         }
[17:46:44.618]         else {
[17:46:44.618]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.618]         }
[17:46:44.618]         base::close(...future.stdout)
[17:46:44.618]         ...future.stdout <- NULL
[17:46:44.618]     }
[17:46:44.618]     ...future.result$conditions <- ...future.conditions
[17:46:44.618]     ...future.result$finished <- base::Sys.time()
[17:46:44.618]     ...future.result
[17:46:44.618] }
[17:46:44.619] plan(): Setting new future strategy stack:
[17:46:44.620] List of future strategies:
[17:46:44.620] 1. sequential:
[17:46:44.620]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.620]    - tweaked: FALSE
[17:46:44.620]    - call: NULL
[17:46:44.620] plan(): nbrOfWorkers() = 1
[17:46:44.621] plan(): Setting new future strategy stack:
[17:46:44.621] List of future strategies:
[17:46:44.621] 1. sequential:
[17:46:44.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.621]    - tweaked: FALSE
[17:46:44.621]    - call: plan(strategy)
[17:46:44.621] plan(): nbrOfWorkers() = 1
[17:46:44.621] SequentialFuture started (and completed)
[17:46:44.622] - Launch lazy future ... done
[17:46:44.622] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56178601c808> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561787409000> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56178601c808> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x561787409000> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:44.627] resolved() for ‘SequentialFuture’ ...
[17:46:44.627] - state: ‘finished’
[17:46:44.627] - run: TRUE
[17:46:44.627] - result: ‘FutureResult’
[17:46:44.627] resolved() for ‘SequentialFuture’ ... done
[17:46:44.627] resolved() for ‘SequentialFuture’ ...
[17:46:44.628] - state: ‘finished’
[17:46:44.628] - run: TRUE
[17:46:44.628] - result: ‘FutureResult’
[17:46:44.628] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:44.630] resolve() on list ...
[17:46:44.630]  recursive: 0
[17:46:44.630]  length: 6
[17:46:44.630]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:44.630] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.630] - nx: 6
[17:46:44.630] - relay: TRUE
[17:46:44.630] - stdout: TRUE
[17:46:44.630] - signal: TRUE
[17:46:44.631] - resignal: FALSE
[17:46:44.631] - force: TRUE
[17:46:44.631] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.631] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.631]  - until=2
[17:46:44.631]  - relaying element #2
[17:46:44.631] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.631] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.631] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.631]  length: 5 (resolved future 1)
[17:46:44.631] resolved() for ‘SequentialFuture’ ...
[17:46:44.632] - state: ‘finished’
[17:46:44.632] - run: TRUE
[17:46:44.632] - result: ‘FutureResult’
[17:46:44.632] resolved() for ‘SequentialFuture’ ... done
[17:46:44.632] Future #2
[17:46:44.632] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.632] - nx: 6
[17:46:44.632] - relay: TRUE
[17:46:44.632] - stdout: TRUE
[17:46:44.632] - signal: TRUE
[17:46:44.632] - resignal: FALSE
[17:46:44.633] - force: TRUE
[17:46:44.633] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.633] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.633]  - until=2
[17:46:44.633]  - relaying element #2
[17:46:44.633] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.633] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.633] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.633]  length: 4 (resolved future 2)
[17:46:44.635] resolved() for ‘SequentialFuture’ ...
[17:46:44.635] - state: ‘finished’
[17:46:44.636] - run: TRUE
[17:46:44.636] - result: ‘FutureResult’
[17:46:44.636] resolved() for ‘SequentialFuture’ ... done
[17:46:44.636] Future #3
[17:46:44.636] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.636] - nx: 6
[17:46:44.636] - relay: TRUE
[17:46:44.636] - stdout: TRUE
[17:46:44.636] - signal: TRUE
[17:46:44.636] - resignal: FALSE
[17:46:44.636] - force: TRUE
[17:46:44.637] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.637] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.637]  - until=3
[17:46:44.637]  - relaying element #3
[17:46:44.637] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.637] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.637] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.637]  length: 3 (resolved future 3)
[17:46:44.637] signalConditionsASAP(NULL, pos=4) ...
[17:46:44.637] - nx: 6
[17:46:44.638] - relay: TRUE
[17:46:44.638] - stdout: TRUE
[17:46:44.638] - signal: TRUE
[17:46:44.638] - resignal: FALSE
[17:46:44.638] - force: TRUE
[17:46:44.638] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.638] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.638]  - until=5
[17:46:44.638]  - relaying element #5
[17:46:44.638] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.638] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.638] signalConditionsASAP(NULL, pos=4) ... done
[17:46:44.639]  length: 2 (resolved future 4)
[17:46:44.639] signalConditionsASAP(NULL, pos=5) ...
[17:46:44.639] - nx: 6
[17:46:44.639] - relay: TRUE
[17:46:44.639] - stdout: TRUE
[17:46:44.639] - signal: TRUE
[17:46:44.639] - resignal: FALSE
[17:46:44.639] - force: TRUE
[17:46:44.639] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.639] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.639]  - until=6
[17:46:44.639]  - relaying element #6
[17:46:44.640] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.640] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.640] signalConditionsASAP(NULL, pos=5) ... done
[17:46:44.640]  length: 1 (resolved future 5)
[17:46:44.640] signalConditionsASAP(numeric, pos=6) ...
[17:46:44.640] - nx: 6
[17:46:44.640] - relay: TRUE
[17:46:44.640] - stdout: TRUE
[17:46:44.640] - signal: TRUE
[17:46:44.640] - resignal: FALSE
[17:46:44.640] - force: TRUE
[17:46:44.641] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.641] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.641]  - until=6
[17:46:44.641] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.641] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.641] signalConditionsASAP(numeric, pos=6) ... done
[17:46:44.641]  length: 0 (resolved future 6)
[17:46:44.641] Relaying remaining futures
[17:46:44.641] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.641] - nx: 6
[17:46:44.641] - relay: TRUE
[17:46:44.641] - stdout: TRUE
[17:46:44.642] - signal: TRUE
[17:46:44.642] - resignal: FALSE
[17:46:44.642] - force: TRUE
[17:46:44.642] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.642] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:44.642] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.642] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.642] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.642] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[17:46:44.651] plan(): Setting new future strategy stack:
[17:46:44.651] List of future strategies:
[17:46:44.651] 1. sequential:
[17:46:44.651]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.651]    - tweaked: FALSE
[17:46:44.651]    - call: plan(strategy)
[17:46:44.651] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:46:44.652] getGlobalsAndPackages() ...
[17:46:44.652] Searching for globals...
[17:46:44.652] 
[17:46:44.652] Searching for globals ... DONE
[17:46:44.652] - globals: [0] <none>
[17:46:44.652] getGlobalsAndPackages() ... DONE
[17:46:44.653] run() for ‘Future’ ...
[17:46:44.653] - state: ‘created’
[17:46:44.653] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.653] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.653]   - Field: ‘label’
[17:46:44.653]   - Field: ‘local’
[17:46:44.653]   - Field: ‘owner’
[17:46:44.654]   - Field: ‘envir’
[17:46:44.654]   - Field: ‘packages’
[17:46:44.654]   - Field: ‘gc’
[17:46:44.654]   - Field: ‘conditions’
[17:46:44.654]   - Field: ‘expr’
[17:46:44.654]   - Field: ‘uuid’
[17:46:44.654]   - Field: ‘seed’
[17:46:44.654]   - Field: ‘version’
[17:46:44.654]   - Field: ‘result’
[17:46:44.654]   - Field: ‘asynchronous’
[17:46:44.654]   - Field: ‘calls’
[17:46:44.655]   - Field: ‘globals’
[17:46:44.655]   - Field: ‘stdout’
[17:46:44.655]   - Field: ‘earlySignal’
[17:46:44.655]   - Field: ‘lazy’
[17:46:44.655]   - Field: ‘state’
[17:46:44.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.655] - Launch lazy future ...
[17:46:44.655] Packages needed by the future expression (n = 0): <none>
[17:46:44.655] Packages needed by future strategies (n = 0): <none>
[17:46:44.656] {
[17:46:44.656]     {
[17:46:44.656]         {
[17:46:44.656]             ...future.startTime <- base::Sys.time()
[17:46:44.656]             {
[17:46:44.656]                 {
[17:46:44.656]                   {
[17:46:44.656]                     base::local({
[17:46:44.656]                       has_future <- base::requireNamespace("future", 
[17:46:44.656]                         quietly = TRUE)
[17:46:44.656]                       if (has_future) {
[17:46:44.656]                         ns <- base::getNamespace("future")
[17:46:44.656]                         version <- ns[[".package"]][["version"]]
[17:46:44.656]                         if (is.null(version)) 
[17:46:44.656]                           version <- utils::packageVersion("future")
[17:46:44.656]                       }
[17:46:44.656]                       else {
[17:46:44.656]                         version <- NULL
[17:46:44.656]                       }
[17:46:44.656]                       if (!has_future || version < "1.8.0") {
[17:46:44.656]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.656]                           "", base::R.version$version.string), 
[17:46:44.656]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.656]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.656]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.656]                             "release", "version")], collapse = " "), 
[17:46:44.656]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.656]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.656]                           info)
[17:46:44.656]                         info <- base::paste(info, collapse = "; ")
[17:46:44.656]                         if (!has_future) {
[17:46:44.656]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.656]                             info)
[17:46:44.656]                         }
[17:46:44.656]                         else {
[17:46:44.656]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.656]                             info, version)
[17:46:44.656]                         }
[17:46:44.656]                         base::stop(msg)
[17:46:44.656]                       }
[17:46:44.656]                     })
[17:46:44.656]                   }
[17:46:44.656]                   ...future.strategy.old <- future::plan("list")
[17:46:44.656]                   options(future.plan = NULL)
[17:46:44.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.656]                 }
[17:46:44.656]                 ...future.workdir <- getwd()
[17:46:44.656]             }
[17:46:44.656]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.656]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.656]         }
[17:46:44.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.656]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.656]             base::names(...future.oldOptions))
[17:46:44.656]     }
[17:46:44.656]     if (FALSE) {
[17:46:44.656]     }
[17:46:44.656]     else {
[17:46:44.656]         if (TRUE) {
[17:46:44.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.656]                 open = "w")
[17:46:44.656]         }
[17:46:44.656]         else {
[17:46:44.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.656]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.656]         }
[17:46:44.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.656]             base::sink(type = "output", split = FALSE)
[17:46:44.656]             base::close(...future.stdout)
[17:46:44.656]         }, add = TRUE)
[17:46:44.656]     }
[17:46:44.656]     ...future.frame <- base::sys.nframe()
[17:46:44.656]     ...future.conditions <- base::list()
[17:46:44.656]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.656]     if (FALSE) {
[17:46:44.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.656]     }
[17:46:44.656]     ...future.result <- base::tryCatch({
[17:46:44.656]         base::withCallingHandlers({
[17:46:44.656]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.656]             future::FutureResult(value = ...future.value$value, 
[17:46:44.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.656]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.656]                     ...future.globalenv.names))
[17:46:44.656]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.656]         }, condition = base::local({
[17:46:44.656]             c <- base::c
[17:46:44.656]             inherits <- base::inherits
[17:46:44.656]             invokeRestart <- base::invokeRestart
[17:46:44.656]             length <- base::length
[17:46:44.656]             list <- base::list
[17:46:44.656]             seq.int <- base::seq.int
[17:46:44.656]             signalCondition <- base::signalCondition
[17:46:44.656]             sys.calls <- base::sys.calls
[17:46:44.656]             `[[` <- base::`[[`
[17:46:44.656]             `+` <- base::`+`
[17:46:44.656]             `<<-` <- base::`<<-`
[17:46:44.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.656]                   3L)]
[17:46:44.656]             }
[17:46:44.656]             function(cond) {
[17:46:44.656]                 is_error <- inherits(cond, "error")
[17:46:44.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.656]                   NULL)
[17:46:44.656]                 if (is_error) {
[17:46:44.656]                   sessionInformation <- function() {
[17:46:44.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.656]                       search = base::search(), system = base::Sys.info())
[17:46:44.656]                   }
[17:46:44.656]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.656]                     cond$call), session = sessionInformation(), 
[17:46:44.656]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.656]                   signalCondition(cond)
[17:46:44.656]                 }
[17:46:44.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.656]                 "immediateCondition"))) {
[17:46:44.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.656]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.656]                   if (TRUE && !signal) {
[17:46:44.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.656]                     {
[17:46:44.656]                       inherits <- base::inherits
[17:46:44.656]                       invokeRestart <- base::invokeRestart
[17:46:44.656]                       is.null <- base::is.null
[17:46:44.656]                       muffled <- FALSE
[17:46:44.656]                       if (inherits(cond, "message")) {
[17:46:44.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.656]                         if (muffled) 
[17:46:44.656]                           invokeRestart("muffleMessage")
[17:46:44.656]                       }
[17:46:44.656]                       else if (inherits(cond, "warning")) {
[17:46:44.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.656]                         if (muffled) 
[17:46:44.656]                           invokeRestart("muffleWarning")
[17:46:44.656]                       }
[17:46:44.656]                       else if (inherits(cond, "condition")) {
[17:46:44.656]                         if (!is.null(pattern)) {
[17:46:44.656]                           computeRestarts <- base::computeRestarts
[17:46:44.656]                           grepl <- base::grepl
[17:46:44.656]                           restarts <- computeRestarts(cond)
[17:46:44.656]                           for (restart in restarts) {
[17:46:44.656]                             name <- restart$name
[17:46:44.656]                             if (is.null(name)) 
[17:46:44.656]                               next
[17:46:44.656]                             if (!grepl(pattern, name)) 
[17:46:44.656]                               next
[17:46:44.656]                             invokeRestart(restart)
[17:46:44.656]                             muffled <- TRUE
[17:46:44.656]                             break
[17:46:44.656]                           }
[17:46:44.656]                         }
[17:46:44.656]                       }
[17:46:44.656]                       invisible(muffled)
[17:46:44.656]                     }
[17:46:44.656]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.656]                   }
[17:46:44.656]                 }
[17:46:44.656]                 else {
[17:46:44.656]                   if (TRUE) {
[17:46:44.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.656]                     {
[17:46:44.656]                       inherits <- base::inherits
[17:46:44.656]                       invokeRestart <- base::invokeRestart
[17:46:44.656]                       is.null <- base::is.null
[17:46:44.656]                       muffled <- FALSE
[17:46:44.656]                       if (inherits(cond, "message")) {
[17:46:44.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.656]                         if (muffled) 
[17:46:44.656]                           invokeRestart("muffleMessage")
[17:46:44.656]                       }
[17:46:44.656]                       else if (inherits(cond, "warning")) {
[17:46:44.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.656]                         if (muffled) 
[17:46:44.656]                           invokeRestart("muffleWarning")
[17:46:44.656]                       }
[17:46:44.656]                       else if (inherits(cond, "condition")) {
[17:46:44.656]                         if (!is.null(pattern)) {
[17:46:44.656]                           computeRestarts <- base::computeRestarts
[17:46:44.656]                           grepl <- base::grepl
[17:46:44.656]                           restarts <- computeRestarts(cond)
[17:46:44.656]                           for (restart in restarts) {
[17:46:44.656]                             name <- restart$name
[17:46:44.656]                             if (is.null(name)) 
[17:46:44.656]                               next
[17:46:44.656]                             if (!grepl(pattern, name)) 
[17:46:44.656]                               next
[17:46:44.656]                             invokeRestart(restart)
[17:46:44.656]                             muffled <- TRUE
[17:46:44.656]                             break
[17:46:44.656]                           }
[17:46:44.656]                         }
[17:46:44.656]                       }
[17:46:44.656]                       invisible(muffled)
[17:46:44.656]                     }
[17:46:44.656]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.656]                   }
[17:46:44.656]                 }
[17:46:44.656]             }
[17:46:44.656]         }))
[17:46:44.656]     }, error = function(ex) {
[17:46:44.656]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.656]                 ...future.rng), started = ...future.startTime, 
[17:46:44.656]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.656]             version = "1.8"), class = "FutureResult")
[17:46:44.656]     }, finally = {
[17:46:44.656]         if (!identical(...future.workdir, getwd())) 
[17:46:44.656]             setwd(...future.workdir)
[17:46:44.656]         {
[17:46:44.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.656]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.656]             }
[17:46:44.656]             base::options(...future.oldOptions)
[17:46:44.656]             if (.Platform$OS.type == "windows") {
[17:46:44.656]                 old_names <- names(...future.oldEnvVars)
[17:46:44.656]                 envs <- base::Sys.getenv()
[17:46:44.656]                 names <- names(envs)
[17:46:44.656]                 common <- intersect(names, old_names)
[17:46:44.656]                 added <- setdiff(names, old_names)
[17:46:44.656]                 removed <- setdiff(old_names, names)
[17:46:44.656]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.656]                   envs[common]]
[17:46:44.656]                 NAMES <- toupper(changed)
[17:46:44.656]                 args <- list()
[17:46:44.656]                 for (kk in seq_along(NAMES)) {
[17:46:44.656]                   name <- changed[[kk]]
[17:46:44.656]                   NAME <- NAMES[[kk]]
[17:46:44.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.656]                     next
[17:46:44.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.656]                 }
[17:46:44.656]                 NAMES <- toupper(added)
[17:46:44.656]                 for (kk in seq_along(NAMES)) {
[17:46:44.656]                   name <- added[[kk]]
[17:46:44.656]                   NAME <- NAMES[[kk]]
[17:46:44.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.656]                     next
[17:46:44.656]                   args[[name]] <- ""
[17:46:44.656]                 }
[17:46:44.656]                 NAMES <- toupper(removed)
[17:46:44.656]                 for (kk in seq_along(NAMES)) {
[17:46:44.656]                   name <- removed[[kk]]
[17:46:44.656]                   NAME <- NAMES[[kk]]
[17:46:44.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.656]                     next
[17:46:44.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.656]                 }
[17:46:44.656]                 if (length(args) > 0) 
[17:46:44.656]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.656]             }
[17:46:44.656]             else {
[17:46:44.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.656]             }
[17:46:44.656]             {
[17:46:44.656]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.656]                   0L) {
[17:46:44.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.656]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.656]                   base::options(opts)
[17:46:44.656]                 }
[17:46:44.656]                 {
[17:46:44.656]                   {
[17:46:44.656]                     NULL
[17:46:44.656]                     RNGkind("Mersenne-Twister")
[17:46:44.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.656]                       inherits = FALSE)
[17:46:44.656]                   }
[17:46:44.656]                   options(future.plan = NULL)
[17:46:44.656]                   if (is.na(NA_character_)) 
[17:46:44.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.656]                     .init = FALSE)
[17:46:44.656]                 }
[17:46:44.656]             }
[17:46:44.656]         }
[17:46:44.656]     })
[17:46:44.656]     if (TRUE) {
[17:46:44.656]         base::sink(type = "output", split = FALSE)
[17:46:44.656]         if (TRUE) {
[17:46:44.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.656]         }
[17:46:44.656]         else {
[17:46:44.656]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.656]         }
[17:46:44.656]         base::close(...future.stdout)
[17:46:44.656]         ...future.stdout <- NULL
[17:46:44.656]     }
[17:46:44.656]     ...future.result$conditions <- ...future.conditions
[17:46:44.656]     ...future.result$finished <- base::Sys.time()
[17:46:44.656]     ...future.result
[17:46:44.656] }
[17:46:44.658] plan(): Setting new future strategy stack:
[17:46:44.658] List of future strategies:
[17:46:44.658] 1. sequential:
[17:46:44.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.658]    - tweaked: FALSE
[17:46:44.658]    - call: NULL
[17:46:44.658] plan(): nbrOfWorkers() = 1
[17:46:44.659] plan(): Setting new future strategy stack:
[17:46:44.659] List of future strategies:
[17:46:44.659] 1. sequential:
[17:46:44.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.659]    - tweaked: FALSE
[17:46:44.659]    - call: plan(strategy)
[17:46:44.659] plan(): nbrOfWorkers() = 1
[17:46:44.660] SequentialFuture started (and completed)
[17:46:44.660] - Launch lazy future ... done
[17:46:44.660] run() for ‘SequentialFuture’ ... done
[17:46:44.660] getGlobalsAndPackages() ...
[17:46:44.660] Searching for globals...
[17:46:44.660] 
[17:46:44.660] Searching for globals ... DONE
[17:46:44.660] - globals: [0] <none>
[17:46:44.661] getGlobalsAndPackages() ... DONE
[17:46:44.661] run() for ‘Future’ ...
[17:46:44.661] - state: ‘created’
[17:46:44.661] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.661] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.661] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.661]   - Field: ‘label’
[17:46:44.663]   - Field: ‘local’
[17:46:44.663]   - Field: ‘owner’
[17:46:44.663]   - Field: ‘envir’
[17:46:44.664]   - Field: ‘packages’
[17:46:44.664]   - Field: ‘gc’
[17:46:44.664]   - Field: ‘conditions’
[17:46:44.664]   - Field: ‘expr’
[17:46:44.664]   - Field: ‘uuid’
[17:46:44.664]   - Field: ‘seed’
[17:46:44.664]   - Field: ‘version’
[17:46:44.664]   - Field: ‘result’
[17:46:44.664]   - Field: ‘asynchronous’
[17:46:44.664]   - Field: ‘calls’
[17:46:44.664]   - Field: ‘globals’
[17:46:44.665]   - Field: ‘stdout’
[17:46:44.665]   - Field: ‘earlySignal’
[17:46:44.665]   - Field: ‘lazy’
[17:46:44.665]   - Field: ‘state’
[17:46:44.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.665] - Launch lazy future ...
[17:46:44.665] Packages needed by the future expression (n = 0): <none>
[17:46:44.665] Packages needed by future strategies (n = 0): <none>
[17:46:44.666] {
[17:46:44.666]     {
[17:46:44.666]         {
[17:46:44.666]             ...future.startTime <- base::Sys.time()
[17:46:44.666]             {
[17:46:44.666]                 {
[17:46:44.666]                   {
[17:46:44.666]                     base::local({
[17:46:44.666]                       has_future <- base::requireNamespace("future", 
[17:46:44.666]                         quietly = TRUE)
[17:46:44.666]                       if (has_future) {
[17:46:44.666]                         ns <- base::getNamespace("future")
[17:46:44.666]                         version <- ns[[".package"]][["version"]]
[17:46:44.666]                         if (is.null(version)) 
[17:46:44.666]                           version <- utils::packageVersion("future")
[17:46:44.666]                       }
[17:46:44.666]                       else {
[17:46:44.666]                         version <- NULL
[17:46:44.666]                       }
[17:46:44.666]                       if (!has_future || version < "1.8.0") {
[17:46:44.666]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.666]                           "", base::R.version$version.string), 
[17:46:44.666]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.666]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.666]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.666]                             "release", "version")], collapse = " "), 
[17:46:44.666]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.666]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.666]                           info)
[17:46:44.666]                         info <- base::paste(info, collapse = "; ")
[17:46:44.666]                         if (!has_future) {
[17:46:44.666]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.666]                             info)
[17:46:44.666]                         }
[17:46:44.666]                         else {
[17:46:44.666]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.666]                             info, version)
[17:46:44.666]                         }
[17:46:44.666]                         base::stop(msg)
[17:46:44.666]                       }
[17:46:44.666]                     })
[17:46:44.666]                   }
[17:46:44.666]                   ...future.strategy.old <- future::plan("list")
[17:46:44.666]                   options(future.plan = NULL)
[17:46:44.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.666]                 }
[17:46:44.666]                 ...future.workdir <- getwd()
[17:46:44.666]             }
[17:46:44.666]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.666]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.666]         }
[17:46:44.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.666]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.666]             base::names(...future.oldOptions))
[17:46:44.666]     }
[17:46:44.666]     if (FALSE) {
[17:46:44.666]     }
[17:46:44.666]     else {
[17:46:44.666]         if (TRUE) {
[17:46:44.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.666]                 open = "w")
[17:46:44.666]         }
[17:46:44.666]         else {
[17:46:44.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.666]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.666]         }
[17:46:44.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.666]             base::sink(type = "output", split = FALSE)
[17:46:44.666]             base::close(...future.stdout)
[17:46:44.666]         }, add = TRUE)
[17:46:44.666]     }
[17:46:44.666]     ...future.frame <- base::sys.nframe()
[17:46:44.666]     ...future.conditions <- base::list()
[17:46:44.666]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.666]     if (FALSE) {
[17:46:44.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.666]     }
[17:46:44.666]     ...future.result <- base::tryCatch({
[17:46:44.666]         base::withCallingHandlers({
[17:46:44.666]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.666]             future::FutureResult(value = ...future.value$value, 
[17:46:44.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.666]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.666]                     ...future.globalenv.names))
[17:46:44.666]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.666]         }, condition = base::local({
[17:46:44.666]             c <- base::c
[17:46:44.666]             inherits <- base::inherits
[17:46:44.666]             invokeRestart <- base::invokeRestart
[17:46:44.666]             length <- base::length
[17:46:44.666]             list <- base::list
[17:46:44.666]             seq.int <- base::seq.int
[17:46:44.666]             signalCondition <- base::signalCondition
[17:46:44.666]             sys.calls <- base::sys.calls
[17:46:44.666]             `[[` <- base::`[[`
[17:46:44.666]             `+` <- base::`+`
[17:46:44.666]             `<<-` <- base::`<<-`
[17:46:44.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.666]                   3L)]
[17:46:44.666]             }
[17:46:44.666]             function(cond) {
[17:46:44.666]                 is_error <- inherits(cond, "error")
[17:46:44.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.666]                   NULL)
[17:46:44.666]                 if (is_error) {
[17:46:44.666]                   sessionInformation <- function() {
[17:46:44.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.666]                       search = base::search(), system = base::Sys.info())
[17:46:44.666]                   }
[17:46:44.666]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.666]                     cond$call), session = sessionInformation(), 
[17:46:44.666]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.666]                   signalCondition(cond)
[17:46:44.666]                 }
[17:46:44.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.666]                 "immediateCondition"))) {
[17:46:44.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.666]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.666]                   if (TRUE && !signal) {
[17:46:44.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.666]                     {
[17:46:44.666]                       inherits <- base::inherits
[17:46:44.666]                       invokeRestart <- base::invokeRestart
[17:46:44.666]                       is.null <- base::is.null
[17:46:44.666]                       muffled <- FALSE
[17:46:44.666]                       if (inherits(cond, "message")) {
[17:46:44.666]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.666]                         if (muffled) 
[17:46:44.666]                           invokeRestart("muffleMessage")
[17:46:44.666]                       }
[17:46:44.666]                       else if (inherits(cond, "warning")) {
[17:46:44.666]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.666]                         if (muffled) 
[17:46:44.666]                           invokeRestart("muffleWarning")
[17:46:44.666]                       }
[17:46:44.666]                       else if (inherits(cond, "condition")) {
[17:46:44.666]                         if (!is.null(pattern)) {
[17:46:44.666]                           computeRestarts <- base::computeRestarts
[17:46:44.666]                           grepl <- base::grepl
[17:46:44.666]                           restarts <- computeRestarts(cond)
[17:46:44.666]                           for (restart in restarts) {
[17:46:44.666]                             name <- restart$name
[17:46:44.666]                             if (is.null(name)) 
[17:46:44.666]                               next
[17:46:44.666]                             if (!grepl(pattern, name)) 
[17:46:44.666]                               next
[17:46:44.666]                             invokeRestart(restart)
[17:46:44.666]                             muffled <- TRUE
[17:46:44.666]                             break
[17:46:44.666]                           }
[17:46:44.666]                         }
[17:46:44.666]                       }
[17:46:44.666]                       invisible(muffled)
[17:46:44.666]                     }
[17:46:44.666]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.666]                   }
[17:46:44.666]                 }
[17:46:44.666]                 else {
[17:46:44.666]                   if (TRUE) {
[17:46:44.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.666]                     {
[17:46:44.666]                       inherits <- base::inherits
[17:46:44.666]                       invokeRestart <- base::invokeRestart
[17:46:44.666]                       is.null <- base::is.null
[17:46:44.666]                       muffled <- FALSE
[17:46:44.666]                       if (inherits(cond, "message")) {
[17:46:44.666]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.666]                         if (muffled) 
[17:46:44.666]                           invokeRestart("muffleMessage")
[17:46:44.666]                       }
[17:46:44.666]                       else if (inherits(cond, "warning")) {
[17:46:44.666]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.666]                         if (muffled) 
[17:46:44.666]                           invokeRestart("muffleWarning")
[17:46:44.666]                       }
[17:46:44.666]                       else if (inherits(cond, "condition")) {
[17:46:44.666]                         if (!is.null(pattern)) {
[17:46:44.666]                           computeRestarts <- base::computeRestarts
[17:46:44.666]                           grepl <- base::grepl
[17:46:44.666]                           restarts <- computeRestarts(cond)
[17:46:44.666]                           for (restart in restarts) {
[17:46:44.666]                             name <- restart$name
[17:46:44.666]                             if (is.null(name)) 
[17:46:44.666]                               next
[17:46:44.666]                             if (!grepl(pattern, name)) 
[17:46:44.666]                               next
[17:46:44.666]                             invokeRestart(restart)
[17:46:44.666]                             muffled <- TRUE
[17:46:44.666]                             break
[17:46:44.666]                           }
[17:46:44.666]                         }
[17:46:44.666]                       }
[17:46:44.666]                       invisible(muffled)
[17:46:44.666]                     }
[17:46:44.666]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.666]                   }
[17:46:44.666]                 }
[17:46:44.666]             }
[17:46:44.666]         }))
[17:46:44.666]     }, error = function(ex) {
[17:46:44.666]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.666]                 ...future.rng), started = ...future.startTime, 
[17:46:44.666]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.666]             version = "1.8"), class = "FutureResult")
[17:46:44.666]     }, finally = {
[17:46:44.666]         if (!identical(...future.workdir, getwd())) 
[17:46:44.666]             setwd(...future.workdir)
[17:46:44.666]         {
[17:46:44.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.666]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.666]             }
[17:46:44.666]             base::options(...future.oldOptions)
[17:46:44.666]             if (.Platform$OS.type == "windows") {
[17:46:44.666]                 old_names <- names(...future.oldEnvVars)
[17:46:44.666]                 envs <- base::Sys.getenv()
[17:46:44.666]                 names <- names(envs)
[17:46:44.666]                 common <- intersect(names, old_names)
[17:46:44.666]                 added <- setdiff(names, old_names)
[17:46:44.666]                 removed <- setdiff(old_names, names)
[17:46:44.666]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.666]                   envs[common]]
[17:46:44.666]                 NAMES <- toupper(changed)
[17:46:44.666]                 args <- list()
[17:46:44.666]                 for (kk in seq_along(NAMES)) {
[17:46:44.666]                   name <- changed[[kk]]
[17:46:44.666]                   NAME <- NAMES[[kk]]
[17:46:44.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.666]                     next
[17:46:44.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.666]                 }
[17:46:44.666]                 NAMES <- toupper(added)
[17:46:44.666]                 for (kk in seq_along(NAMES)) {
[17:46:44.666]                   name <- added[[kk]]
[17:46:44.666]                   NAME <- NAMES[[kk]]
[17:46:44.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.666]                     next
[17:46:44.666]                   args[[name]] <- ""
[17:46:44.666]                 }
[17:46:44.666]                 NAMES <- toupper(removed)
[17:46:44.666]                 for (kk in seq_along(NAMES)) {
[17:46:44.666]                   name <- removed[[kk]]
[17:46:44.666]                   NAME <- NAMES[[kk]]
[17:46:44.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.666]                     next
[17:46:44.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.666]                 }
[17:46:44.666]                 if (length(args) > 0) 
[17:46:44.666]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.666]             }
[17:46:44.666]             else {
[17:46:44.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.666]             }
[17:46:44.666]             {
[17:46:44.666]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.666]                   0L) {
[17:46:44.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.666]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.666]                   base::options(opts)
[17:46:44.666]                 }
[17:46:44.666]                 {
[17:46:44.666]                   {
[17:46:44.666]                     NULL
[17:46:44.666]                     RNGkind("Mersenne-Twister")
[17:46:44.666]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.666]                       inherits = FALSE)
[17:46:44.666]                   }
[17:46:44.666]                   options(future.plan = NULL)
[17:46:44.666]                   if (is.na(NA_character_)) 
[17:46:44.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.666]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.666]                     .init = FALSE)
[17:46:44.666]                 }
[17:46:44.666]             }
[17:46:44.666]         }
[17:46:44.666]     })
[17:46:44.666]     if (TRUE) {
[17:46:44.666]         base::sink(type = "output", split = FALSE)
[17:46:44.666]         if (TRUE) {
[17:46:44.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.666]         }
[17:46:44.666]         else {
[17:46:44.666]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.666]         }
[17:46:44.666]         base::close(...future.stdout)
[17:46:44.666]         ...future.stdout <- NULL
[17:46:44.666]     }
[17:46:44.666]     ...future.result$conditions <- ...future.conditions
[17:46:44.666]     ...future.result$finished <- base::Sys.time()
[17:46:44.666]     ...future.result
[17:46:44.666] }
[17:46:44.667] plan(): Setting new future strategy stack:
[17:46:44.668] List of future strategies:
[17:46:44.668] 1. sequential:
[17:46:44.668]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.668]    - tweaked: FALSE
[17:46:44.668]    - call: NULL
[17:46:44.668] plan(): nbrOfWorkers() = 1
[17:46:44.669] plan(): Setting new future strategy stack:
[17:46:44.669] List of future strategies:
[17:46:44.669] 1. sequential:
[17:46:44.669]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.669]    - tweaked: FALSE
[17:46:44.669]    - call: plan(strategy)
[17:46:44.669] plan(): nbrOfWorkers() = 1
[17:46:44.669] SequentialFuture started (and completed)
[17:46:44.669] - Launch lazy future ... done
[17:46:44.670] run() for ‘SequentialFuture’ ... done
[17:46:44.671] getGlobalsAndPackages() ...
[17:46:44.671] Searching for globals...
[17:46:44.672] - globals found: [1] ‘{’
[17:46:44.672] Searching for globals ... DONE
[17:46:44.672] Resolving globals: FALSE
[17:46:44.673] 
[17:46:44.673] 
[17:46:44.673] getGlobalsAndPackages() ... DONE
[17:46:44.673] run() for ‘Future’ ...
[17:46:44.673] - state: ‘created’
[17:46:44.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.674] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.674]   - Field: ‘label’
[17:46:44.674]   - Field: ‘local’
[17:46:44.674]   - Field: ‘owner’
[17:46:44.674]   - Field: ‘envir’
[17:46:44.674]   - Field: ‘packages’
[17:46:44.674]   - Field: ‘gc’
[17:46:44.674]   - Field: ‘conditions’
[17:46:44.675]   - Field: ‘expr’
[17:46:44.675]   - Field: ‘uuid’
[17:46:44.675]   - Field: ‘seed’
[17:46:44.675]   - Field: ‘version’
[17:46:44.675]   - Field: ‘result’
[17:46:44.675]   - Field: ‘asynchronous’
[17:46:44.675]   - Field: ‘calls’
[17:46:44.675]   - Field: ‘globals’
[17:46:44.675]   - Field: ‘stdout’
[17:46:44.675]   - Field: ‘earlySignal’
[17:46:44.675]   - Field: ‘lazy’
[17:46:44.676]   - Field: ‘state’
[17:46:44.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.676] - Launch lazy future ...
[17:46:44.676] Packages needed by the future expression (n = 0): <none>
[17:46:44.676] Packages needed by future strategies (n = 0): <none>
[17:46:44.676] {
[17:46:44.676]     {
[17:46:44.676]         {
[17:46:44.676]             ...future.startTime <- base::Sys.time()
[17:46:44.676]             {
[17:46:44.676]                 {
[17:46:44.676]                   {
[17:46:44.676]                     base::local({
[17:46:44.676]                       has_future <- base::requireNamespace("future", 
[17:46:44.676]                         quietly = TRUE)
[17:46:44.676]                       if (has_future) {
[17:46:44.676]                         ns <- base::getNamespace("future")
[17:46:44.676]                         version <- ns[[".package"]][["version"]]
[17:46:44.676]                         if (is.null(version)) 
[17:46:44.676]                           version <- utils::packageVersion("future")
[17:46:44.676]                       }
[17:46:44.676]                       else {
[17:46:44.676]                         version <- NULL
[17:46:44.676]                       }
[17:46:44.676]                       if (!has_future || version < "1.8.0") {
[17:46:44.676]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.676]                           "", base::R.version$version.string), 
[17:46:44.676]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.676]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.676]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.676]                             "release", "version")], collapse = " "), 
[17:46:44.676]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.676]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.676]                           info)
[17:46:44.676]                         info <- base::paste(info, collapse = "; ")
[17:46:44.676]                         if (!has_future) {
[17:46:44.676]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.676]                             info)
[17:46:44.676]                         }
[17:46:44.676]                         else {
[17:46:44.676]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.676]                             info, version)
[17:46:44.676]                         }
[17:46:44.676]                         base::stop(msg)
[17:46:44.676]                       }
[17:46:44.676]                     })
[17:46:44.676]                   }
[17:46:44.676]                   ...future.strategy.old <- future::plan("list")
[17:46:44.676]                   options(future.plan = NULL)
[17:46:44.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.676]                 }
[17:46:44.676]                 ...future.workdir <- getwd()
[17:46:44.676]             }
[17:46:44.676]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.676]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.676]         }
[17:46:44.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.676]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.676]             base::names(...future.oldOptions))
[17:46:44.676]     }
[17:46:44.676]     if (FALSE) {
[17:46:44.676]     }
[17:46:44.676]     else {
[17:46:44.676]         if (TRUE) {
[17:46:44.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.676]                 open = "w")
[17:46:44.676]         }
[17:46:44.676]         else {
[17:46:44.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.676]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.676]         }
[17:46:44.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.676]             base::sink(type = "output", split = FALSE)
[17:46:44.676]             base::close(...future.stdout)
[17:46:44.676]         }, add = TRUE)
[17:46:44.676]     }
[17:46:44.676]     ...future.frame <- base::sys.nframe()
[17:46:44.676]     ...future.conditions <- base::list()
[17:46:44.676]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.676]     if (FALSE) {
[17:46:44.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.676]     }
[17:46:44.676]     ...future.result <- base::tryCatch({
[17:46:44.676]         base::withCallingHandlers({
[17:46:44.676]             ...future.value <- base::withVisible(base::local({
[17:46:44.676]                 4
[17:46:44.676]             }))
[17:46:44.676]             future::FutureResult(value = ...future.value$value, 
[17:46:44.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.676]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.676]                     ...future.globalenv.names))
[17:46:44.676]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.676]         }, condition = base::local({
[17:46:44.676]             c <- base::c
[17:46:44.676]             inherits <- base::inherits
[17:46:44.676]             invokeRestart <- base::invokeRestart
[17:46:44.676]             length <- base::length
[17:46:44.676]             list <- base::list
[17:46:44.676]             seq.int <- base::seq.int
[17:46:44.676]             signalCondition <- base::signalCondition
[17:46:44.676]             sys.calls <- base::sys.calls
[17:46:44.676]             `[[` <- base::`[[`
[17:46:44.676]             `+` <- base::`+`
[17:46:44.676]             `<<-` <- base::`<<-`
[17:46:44.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.676]                   3L)]
[17:46:44.676]             }
[17:46:44.676]             function(cond) {
[17:46:44.676]                 is_error <- inherits(cond, "error")
[17:46:44.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.676]                   NULL)
[17:46:44.676]                 if (is_error) {
[17:46:44.676]                   sessionInformation <- function() {
[17:46:44.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.676]                       search = base::search(), system = base::Sys.info())
[17:46:44.676]                   }
[17:46:44.676]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.676]                     cond$call), session = sessionInformation(), 
[17:46:44.676]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.676]                   signalCondition(cond)
[17:46:44.676]                 }
[17:46:44.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.676]                 "immediateCondition"))) {
[17:46:44.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.676]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.676]                   if (TRUE && !signal) {
[17:46:44.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.676]                     {
[17:46:44.676]                       inherits <- base::inherits
[17:46:44.676]                       invokeRestart <- base::invokeRestart
[17:46:44.676]                       is.null <- base::is.null
[17:46:44.676]                       muffled <- FALSE
[17:46:44.676]                       if (inherits(cond, "message")) {
[17:46:44.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.676]                         if (muffled) 
[17:46:44.676]                           invokeRestart("muffleMessage")
[17:46:44.676]                       }
[17:46:44.676]                       else if (inherits(cond, "warning")) {
[17:46:44.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.676]                         if (muffled) 
[17:46:44.676]                           invokeRestart("muffleWarning")
[17:46:44.676]                       }
[17:46:44.676]                       else if (inherits(cond, "condition")) {
[17:46:44.676]                         if (!is.null(pattern)) {
[17:46:44.676]                           computeRestarts <- base::computeRestarts
[17:46:44.676]                           grepl <- base::grepl
[17:46:44.676]                           restarts <- computeRestarts(cond)
[17:46:44.676]                           for (restart in restarts) {
[17:46:44.676]                             name <- restart$name
[17:46:44.676]                             if (is.null(name)) 
[17:46:44.676]                               next
[17:46:44.676]                             if (!grepl(pattern, name)) 
[17:46:44.676]                               next
[17:46:44.676]                             invokeRestart(restart)
[17:46:44.676]                             muffled <- TRUE
[17:46:44.676]                             break
[17:46:44.676]                           }
[17:46:44.676]                         }
[17:46:44.676]                       }
[17:46:44.676]                       invisible(muffled)
[17:46:44.676]                     }
[17:46:44.676]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.676]                   }
[17:46:44.676]                 }
[17:46:44.676]                 else {
[17:46:44.676]                   if (TRUE) {
[17:46:44.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.676]                     {
[17:46:44.676]                       inherits <- base::inherits
[17:46:44.676]                       invokeRestart <- base::invokeRestart
[17:46:44.676]                       is.null <- base::is.null
[17:46:44.676]                       muffled <- FALSE
[17:46:44.676]                       if (inherits(cond, "message")) {
[17:46:44.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.676]                         if (muffled) 
[17:46:44.676]                           invokeRestart("muffleMessage")
[17:46:44.676]                       }
[17:46:44.676]                       else if (inherits(cond, "warning")) {
[17:46:44.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.676]                         if (muffled) 
[17:46:44.676]                           invokeRestart("muffleWarning")
[17:46:44.676]                       }
[17:46:44.676]                       else if (inherits(cond, "condition")) {
[17:46:44.676]                         if (!is.null(pattern)) {
[17:46:44.676]                           computeRestarts <- base::computeRestarts
[17:46:44.676]                           grepl <- base::grepl
[17:46:44.676]                           restarts <- computeRestarts(cond)
[17:46:44.676]                           for (restart in restarts) {
[17:46:44.676]                             name <- restart$name
[17:46:44.676]                             if (is.null(name)) 
[17:46:44.676]                               next
[17:46:44.676]                             if (!grepl(pattern, name)) 
[17:46:44.676]                               next
[17:46:44.676]                             invokeRestart(restart)
[17:46:44.676]                             muffled <- TRUE
[17:46:44.676]                             break
[17:46:44.676]                           }
[17:46:44.676]                         }
[17:46:44.676]                       }
[17:46:44.676]                       invisible(muffled)
[17:46:44.676]                     }
[17:46:44.676]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.676]                   }
[17:46:44.676]                 }
[17:46:44.676]             }
[17:46:44.676]         }))
[17:46:44.676]     }, error = function(ex) {
[17:46:44.676]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.676]                 ...future.rng), started = ...future.startTime, 
[17:46:44.676]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.676]             version = "1.8"), class = "FutureResult")
[17:46:44.676]     }, finally = {
[17:46:44.676]         if (!identical(...future.workdir, getwd())) 
[17:46:44.676]             setwd(...future.workdir)
[17:46:44.676]         {
[17:46:44.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.676]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.676]             }
[17:46:44.676]             base::options(...future.oldOptions)
[17:46:44.676]             if (.Platform$OS.type == "windows") {
[17:46:44.676]                 old_names <- names(...future.oldEnvVars)
[17:46:44.676]                 envs <- base::Sys.getenv()
[17:46:44.676]                 names <- names(envs)
[17:46:44.676]                 common <- intersect(names, old_names)
[17:46:44.676]                 added <- setdiff(names, old_names)
[17:46:44.676]                 removed <- setdiff(old_names, names)
[17:46:44.676]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.676]                   envs[common]]
[17:46:44.676]                 NAMES <- toupper(changed)
[17:46:44.676]                 args <- list()
[17:46:44.676]                 for (kk in seq_along(NAMES)) {
[17:46:44.676]                   name <- changed[[kk]]
[17:46:44.676]                   NAME <- NAMES[[kk]]
[17:46:44.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.676]                     next
[17:46:44.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.676]                 }
[17:46:44.676]                 NAMES <- toupper(added)
[17:46:44.676]                 for (kk in seq_along(NAMES)) {
[17:46:44.676]                   name <- added[[kk]]
[17:46:44.676]                   NAME <- NAMES[[kk]]
[17:46:44.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.676]                     next
[17:46:44.676]                   args[[name]] <- ""
[17:46:44.676]                 }
[17:46:44.676]                 NAMES <- toupper(removed)
[17:46:44.676]                 for (kk in seq_along(NAMES)) {
[17:46:44.676]                   name <- removed[[kk]]
[17:46:44.676]                   NAME <- NAMES[[kk]]
[17:46:44.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.676]                     next
[17:46:44.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.676]                 }
[17:46:44.676]                 if (length(args) > 0) 
[17:46:44.676]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.676]             }
[17:46:44.676]             else {
[17:46:44.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.676]             }
[17:46:44.676]             {
[17:46:44.676]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.676]                   0L) {
[17:46:44.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.676]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.676]                   base::options(opts)
[17:46:44.676]                 }
[17:46:44.676]                 {
[17:46:44.676]                   {
[17:46:44.676]                     NULL
[17:46:44.676]                     RNGkind("Mersenne-Twister")
[17:46:44.676]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.676]                       inherits = FALSE)
[17:46:44.676]                   }
[17:46:44.676]                   options(future.plan = NULL)
[17:46:44.676]                   if (is.na(NA_character_)) 
[17:46:44.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.676]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.676]                     .init = FALSE)
[17:46:44.676]                 }
[17:46:44.676]             }
[17:46:44.676]         }
[17:46:44.676]     })
[17:46:44.676]     if (TRUE) {
[17:46:44.676]         base::sink(type = "output", split = FALSE)
[17:46:44.676]         if (TRUE) {
[17:46:44.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.676]         }
[17:46:44.676]         else {
[17:46:44.676]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.676]         }
[17:46:44.676]         base::close(...future.stdout)
[17:46:44.676]         ...future.stdout <- NULL
[17:46:44.676]     }
[17:46:44.676]     ...future.result$conditions <- ...future.conditions
[17:46:44.676]     ...future.result$finished <- base::Sys.time()
[17:46:44.676]     ...future.result
[17:46:44.676] }
[17:46:44.678] plan(): Setting new future strategy stack:
[17:46:44.678] List of future strategies:
[17:46:44.678] 1. sequential:
[17:46:44.678]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.678]    - tweaked: FALSE
[17:46:44.678]    - call: NULL
[17:46:44.679] plan(): nbrOfWorkers() = 1
[17:46:44.679] plan(): Setting new future strategy stack:
[17:46:44.680] List of future strategies:
[17:46:44.680] 1. sequential:
[17:46:44.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.680]    - tweaked: FALSE
[17:46:44.680]    - call: plan(strategy)
[17:46:44.680] plan(): nbrOfWorkers() = 1
[17:46:44.680] SequentialFuture started (and completed)
[17:46:44.680] - Launch lazy future ... done
[17:46:44.680] run() for ‘SequentialFuture’ ... done
<environment: 0x561787be9138> 
<environment: 0x5617878c0980> 
[17:46:44.682] resolved() for ‘SequentialFuture’ ...
[17:46:44.682] - state: ‘finished’
[17:46:44.682] - run: TRUE
[17:46:44.682] - result: ‘FutureResult’
[17:46:44.682] resolved() for ‘SequentialFuture’ ... done
[17:46:44.682] resolved() for ‘SequentialFuture’ ...
[17:46:44.682] - state: ‘finished’
[17:46:44.682] - run: TRUE
[17:46:44.683] - result: ‘FutureResult’
[17:46:44.683] resolved() for ‘SequentialFuture’ ... done
[17:46:44.683] resolved() for ‘SequentialFuture’ ...
[17:46:44.683] - state: ‘finished’
[17:46:44.683] - run: TRUE
[17:46:44.683] - result: ‘FutureResult’
[17:46:44.683] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:44.685] resolve() on environment ...
[17:46:44.685]  recursive: 0
[17:46:44.685]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:44.685] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.685] - nx: 4
[17:46:44.685] - relay: TRUE
[17:46:44.686] - stdout: TRUE
[17:46:44.686] - signal: TRUE
[17:46:44.686] - resignal: FALSE
[17:46:44.686] - force: TRUE
[17:46:44.686] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.686] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.686]  - until=2
[17:46:44.686]  - relaying element #2
[17:46:44.686] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.686] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.686] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.686]  length: 3 (resolved future 1)
[17:46:44.687] resolved() for ‘SequentialFuture’ ...
[17:46:44.687] - state: ‘finished’
[17:46:44.687] - run: TRUE
[17:46:44.687] - result: ‘FutureResult’
[17:46:44.687] resolved() for ‘SequentialFuture’ ... done
[17:46:44.687] Future #2
[17:46:44.687] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.687] - nx: 4
[17:46:44.687] - relay: TRUE
[17:46:44.687] - stdout: TRUE
[17:46:44.688] - signal: TRUE
[17:46:44.688] - resignal: FALSE
[17:46:44.688] - force: TRUE
[17:46:44.688] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.688] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.688]  - until=2
[17:46:44.688]  - relaying element #2
[17:46:44.688] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.688] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.688] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.688]  length: 2 (resolved future 2)
[17:46:44.689] resolved() for ‘SequentialFuture’ ...
[17:46:44.689] - state: ‘finished’
[17:46:44.689] - run: TRUE
[17:46:44.689] - result: ‘FutureResult’
[17:46:44.689] resolved() for ‘SequentialFuture’ ... done
[17:46:44.689] Future #3
[17:46:44.689] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.689] - nx: 4
[17:46:44.689] - relay: TRUE
[17:46:44.689] - stdout: TRUE
[17:46:44.690] - signal: TRUE
[17:46:44.690] - resignal: FALSE
[17:46:44.690] - force: TRUE
[17:46:44.690] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.690] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.690]  - until=3
[17:46:44.690]  - relaying element #3
[17:46:44.690] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.690] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.690] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.690]  length: 1 (resolved future 3)
[17:46:44.691] resolved() for ‘SequentialFuture’ ...
[17:46:44.691] - state: ‘finished’
[17:46:44.691] - run: TRUE
[17:46:44.691] - result: ‘FutureResult’
[17:46:44.691] resolved() for ‘SequentialFuture’ ... done
[17:46:44.691] Future #4
[17:46:44.691] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:44.691] - nx: 4
[17:46:44.691] - relay: TRUE
[17:46:44.691] - stdout: TRUE
[17:46:44.691] - signal: TRUE
[17:46:44.692] - resignal: FALSE
[17:46:44.692] - force: TRUE
[17:46:44.692] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.692] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.692]  - until=4
[17:46:44.692]  - relaying element #4
[17:46:44.692] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.692] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.692] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:44.692]  length: 0 (resolved future 4)
[17:46:44.693] Relaying remaining futures
[17:46:44.693] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.693] - nx: 4
[17:46:44.693] - relay: TRUE
[17:46:44.693] - stdout: TRUE
[17:46:44.693] - signal: TRUE
[17:46:44.693] - resignal: FALSE
[17:46:44.693] - force: TRUE
[17:46:44.695] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.695] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:44.695] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.696] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.696] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.696] resolve() on environment ... DONE
<environment: 0x561787ad52e0> 
Dimensions: c(1, 6)
[17:46:44.696] getGlobalsAndPackages() ...
[17:46:44.696] Searching for globals...
[17:46:44.697] 
[17:46:44.697] Searching for globals ... DONE
[17:46:44.697] - globals: [0] <none>
[17:46:44.697] getGlobalsAndPackages() ... DONE
[17:46:44.697] run() for ‘Future’ ...
[17:46:44.697] - state: ‘created’
[17:46:44.697] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.698] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.698]   - Field: ‘label’
[17:46:44.698]   - Field: ‘local’
[17:46:44.698]   - Field: ‘owner’
[17:46:44.698]   - Field: ‘envir’
[17:46:44.698]   - Field: ‘packages’
[17:46:44.698]   - Field: ‘gc’
[17:46:44.698]   - Field: ‘conditions’
[17:46:44.699]   - Field: ‘expr’
[17:46:44.699]   - Field: ‘uuid’
[17:46:44.699]   - Field: ‘seed’
[17:46:44.699]   - Field: ‘version’
[17:46:44.699]   - Field: ‘result’
[17:46:44.699]   - Field: ‘asynchronous’
[17:46:44.699]   - Field: ‘calls’
[17:46:44.699]   - Field: ‘globals’
[17:46:44.699]   - Field: ‘stdout’
[17:46:44.699]   - Field: ‘earlySignal’
[17:46:44.699]   - Field: ‘lazy’
[17:46:44.700]   - Field: ‘state’
[17:46:44.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.700] - Launch lazy future ...
[17:46:44.700] Packages needed by the future expression (n = 0): <none>
[17:46:44.700] Packages needed by future strategies (n = 0): <none>
[17:46:44.700] {
[17:46:44.700]     {
[17:46:44.700]         {
[17:46:44.700]             ...future.startTime <- base::Sys.time()
[17:46:44.700]             {
[17:46:44.700]                 {
[17:46:44.700]                   {
[17:46:44.700]                     base::local({
[17:46:44.700]                       has_future <- base::requireNamespace("future", 
[17:46:44.700]                         quietly = TRUE)
[17:46:44.700]                       if (has_future) {
[17:46:44.700]                         ns <- base::getNamespace("future")
[17:46:44.700]                         version <- ns[[".package"]][["version"]]
[17:46:44.700]                         if (is.null(version)) 
[17:46:44.700]                           version <- utils::packageVersion("future")
[17:46:44.700]                       }
[17:46:44.700]                       else {
[17:46:44.700]                         version <- NULL
[17:46:44.700]                       }
[17:46:44.700]                       if (!has_future || version < "1.8.0") {
[17:46:44.700]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.700]                           "", base::R.version$version.string), 
[17:46:44.700]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.700]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.700]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.700]                             "release", "version")], collapse = " "), 
[17:46:44.700]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.700]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.700]                           info)
[17:46:44.700]                         info <- base::paste(info, collapse = "; ")
[17:46:44.700]                         if (!has_future) {
[17:46:44.700]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.700]                             info)
[17:46:44.700]                         }
[17:46:44.700]                         else {
[17:46:44.700]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.700]                             info, version)
[17:46:44.700]                         }
[17:46:44.700]                         base::stop(msg)
[17:46:44.700]                       }
[17:46:44.700]                     })
[17:46:44.700]                   }
[17:46:44.700]                   ...future.strategy.old <- future::plan("list")
[17:46:44.700]                   options(future.plan = NULL)
[17:46:44.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.700]                 }
[17:46:44.700]                 ...future.workdir <- getwd()
[17:46:44.700]             }
[17:46:44.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.700]         }
[17:46:44.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.700]             base::names(...future.oldOptions))
[17:46:44.700]     }
[17:46:44.700]     if (FALSE) {
[17:46:44.700]     }
[17:46:44.700]     else {
[17:46:44.700]         if (TRUE) {
[17:46:44.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.700]                 open = "w")
[17:46:44.700]         }
[17:46:44.700]         else {
[17:46:44.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.700]         }
[17:46:44.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.700]             base::sink(type = "output", split = FALSE)
[17:46:44.700]             base::close(...future.stdout)
[17:46:44.700]         }, add = TRUE)
[17:46:44.700]     }
[17:46:44.700]     ...future.frame <- base::sys.nframe()
[17:46:44.700]     ...future.conditions <- base::list()
[17:46:44.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.700]     if (FALSE) {
[17:46:44.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.700]     }
[17:46:44.700]     ...future.result <- base::tryCatch({
[17:46:44.700]         base::withCallingHandlers({
[17:46:44.700]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.700]             future::FutureResult(value = ...future.value$value, 
[17:46:44.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.700]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.700]                     ...future.globalenv.names))
[17:46:44.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.700]         }, condition = base::local({
[17:46:44.700]             c <- base::c
[17:46:44.700]             inherits <- base::inherits
[17:46:44.700]             invokeRestart <- base::invokeRestart
[17:46:44.700]             length <- base::length
[17:46:44.700]             list <- base::list
[17:46:44.700]             seq.int <- base::seq.int
[17:46:44.700]             signalCondition <- base::signalCondition
[17:46:44.700]             sys.calls <- base::sys.calls
[17:46:44.700]             `[[` <- base::`[[`
[17:46:44.700]             `+` <- base::`+`
[17:46:44.700]             `<<-` <- base::`<<-`
[17:46:44.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.700]                   3L)]
[17:46:44.700]             }
[17:46:44.700]             function(cond) {
[17:46:44.700]                 is_error <- inherits(cond, "error")
[17:46:44.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.700]                   NULL)
[17:46:44.700]                 if (is_error) {
[17:46:44.700]                   sessionInformation <- function() {
[17:46:44.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.700]                       search = base::search(), system = base::Sys.info())
[17:46:44.700]                   }
[17:46:44.700]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.700]                     cond$call), session = sessionInformation(), 
[17:46:44.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.700]                   signalCondition(cond)
[17:46:44.700]                 }
[17:46:44.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.700]                 "immediateCondition"))) {
[17:46:44.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.700]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.700]                   if (TRUE && !signal) {
[17:46:44.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.700]                     {
[17:46:44.700]                       inherits <- base::inherits
[17:46:44.700]                       invokeRestart <- base::invokeRestart
[17:46:44.700]                       is.null <- base::is.null
[17:46:44.700]                       muffled <- FALSE
[17:46:44.700]                       if (inherits(cond, "message")) {
[17:46:44.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.700]                         if (muffled) 
[17:46:44.700]                           invokeRestart("muffleMessage")
[17:46:44.700]                       }
[17:46:44.700]                       else if (inherits(cond, "warning")) {
[17:46:44.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.700]                         if (muffled) 
[17:46:44.700]                           invokeRestart("muffleWarning")
[17:46:44.700]                       }
[17:46:44.700]                       else if (inherits(cond, "condition")) {
[17:46:44.700]                         if (!is.null(pattern)) {
[17:46:44.700]                           computeRestarts <- base::computeRestarts
[17:46:44.700]                           grepl <- base::grepl
[17:46:44.700]                           restarts <- computeRestarts(cond)
[17:46:44.700]                           for (restart in restarts) {
[17:46:44.700]                             name <- restart$name
[17:46:44.700]                             if (is.null(name)) 
[17:46:44.700]                               next
[17:46:44.700]                             if (!grepl(pattern, name)) 
[17:46:44.700]                               next
[17:46:44.700]                             invokeRestart(restart)
[17:46:44.700]                             muffled <- TRUE
[17:46:44.700]                             break
[17:46:44.700]                           }
[17:46:44.700]                         }
[17:46:44.700]                       }
[17:46:44.700]                       invisible(muffled)
[17:46:44.700]                     }
[17:46:44.700]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.700]                   }
[17:46:44.700]                 }
[17:46:44.700]                 else {
[17:46:44.700]                   if (TRUE) {
[17:46:44.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.700]                     {
[17:46:44.700]                       inherits <- base::inherits
[17:46:44.700]                       invokeRestart <- base::invokeRestart
[17:46:44.700]                       is.null <- base::is.null
[17:46:44.700]                       muffled <- FALSE
[17:46:44.700]                       if (inherits(cond, "message")) {
[17:46:44.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.700]                         if (muffled) 
[17:46:44.700]                           invokeRestart("muffleMessage")
[17:46:44.700]                       }
[17:46:44.700]                       else if (inherits(cond, "warning")) {
[17:46:44.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.700]                         if (muffled) 
[17:46:44.700]                           invokeRestart("muffleWarning")
[17:46:44.700]                       }
[17:46:44.700]                       else if (inherits(cond, "condition")) {
[17:46:44.700]                         if (!is.null(pattern)) {
[17:46:44.700]                           computeRestarts <- base::computeRestarts
[17:46:44.700]                           grepl <- base::grepl
[17:46:44.700]                           restarts <- computeRestarts(cond)
[17:46:44.700]                           for (restart in restarts) {
[17:46:44.700]                             name <- restart$name
[17:46:44.700]                             if (is.null(name)) 
[17:46:44.700]                               next
[17:46:44.700]                             if (!grepl(pattern, name)) 
[17:46:44.700]                               next
[17:46:44.700]                             invokeRestart(restart)
[17:46:44.700]                             muffled <- TRUE
[17:46:44.700]                             break
[17:46:44.700]                           }
[17:46:44.700]                         }
[17:46:44.700]                       }
[17:46:44.700]                       invisible(muffled)
[17:46:44.700]                     }
[17:46:44.700]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.700]                   }
[17:46:44.700]                 }
[17:46:44.700]             }
[17:46:44.700]         }))
[17:46:44.700]     }, error = function(ex) {
[17:46:44.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.700]                 ...future.rng), started = ...future.startTime, 
[17:46:44.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.700]             version = "1.8"), class = "FutureResult")
[17:46:44.700]     }, finally = {
[17:46:44.700]         if (!identical(...future.workdir, getwd())) 
[17:46:44.700]             setwd(...future.workdir)
[17:46:44.700]         {
[17:46:44.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.700]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.700]             }
[17:46:44.700]             base::options(...future.oldOptions)
[17:46:44.700]             if (.Platform$OS.type == "windows") {
[17:46:44.700]                 old_names <- names(...future.oldEnvVars)
[17:46:44.700]                 envs <- base::Sys.getenv()
[17:46:44.700]                 names <- names(envs)
[17:46:44.700]                 common <- intersect(names, old_names)
[17:46:44.700]                 added <- setdiff(names, old_names)
[17:46:44.700]                 removed <- setdiff(old_names, names)
[17:46:44.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.700]                   envs[common]]
[17:46:44.700]                 NAMES <- toupper(changed)
[17:46:44.700]                 args <- list()
[17:46:44.700]                 for (kk in seq_along(NAMES)) {
[17:46:44.700]                   name <- changed[[kk]]
[17:46:44.700]                   NAME <- NAMES[[kk]]
[17:46:44.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.700]                     next
[17:46:44.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.700]                 }
[17:46:44.700]                 NAMES <- toupper(added)
[17:46:44.700]                 for (kk in seq_along(NAMES)) {
[17:46:44.700]                   name <- added[[kk]]
[17:46:44.700]                   NAME <- NAMES[[kk]]
[17:46:44.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.700]                     next
[17:46:44.700]                   args[[name]] <- ""
[17:46:44.700]                 }
[17:46:44.700]                 NAMES <- toupper(removed)
[17:46:44.700]                 for (kk in seq_along(NAMES)) {
[17:46:44.700]                   name <- removed[[kk]]
[17:46:44.700]                   NAME <- NAMES[[kk]]
[17:46:44.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.700]                     next
[17:46:44.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.700]                 }
[17:46:44.700]                 if (length(args) > 0) 
[17:46:44.700]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.700]             }
[17:46:44.700]             else {
[17:46:44.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.700]             }
[17:46:44.700]             {
[17:46:44.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.700]                   0L) {
[17:46:44.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.700]                   base::options(opts)
[17:46:44.700]                 }
[17:46:44.700]                 {
[17:46:44.700]                   {
[17:46:44.700]                     NULL
[17:46:44.700]                     RNGkind("Mersenne-Twister")
[17:46:44.700]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.700]                       inherits = FALSE)
[17:46:44.700]                   }
[17:46:44.700]                   options(future.plan = NULL)
[17:46:44.700]                   if (is.na(NA_character_)) 
[17:46:44.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.700]                     .init = FALSE)
[17:46:44.700]                 }
[17:46:44.700]             }
[17:46:44.700]         }
[17:46:44.700]     })
[17:46:44.700]     if (TRUE) {
[17:46:44.700]         base::sink(type = "output", split = FALSE)
[17:46:44.700]         if (TRUE) {
[17:46:44.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.700]         }
[17:46:44.700]         else {
[17:46:44.700]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.700]         }
[17:46:44.700]         base::close(...future.stdout)
[17:46:44.700]         ...future.stdout <- NULL
[17:46:44.700]     }
[17:46:44.700]     ...future.result$conditions <- ...future.conditions
[17:46:44.700]     ...future.result$finished <- base::Sys.time()
[17:46:44.700]     ...future.result
[17:46:44.700] }
[17:46:44.702] plan(): Setting new future strategy stack:
[17:46:44.702] List of future strategies:
[17:46:44.702] 1. sequential:
[17:46:44.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.702]    - tweaked: FALSE
[17:46:44.702]    - call: NULL
[17:46:44.703] plan(): nbrOfWorkers() = 1
[17:46:44.703] plan(): Setting new future strategy stack:
[17:46:44.704] List of future strategies:
[17:46:44.704] 1. sequential:
[17:46:44.704]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.704]    - tweaked: FALSE
[17:46:44.704]    - call: plan(strategy)
[17:46:44.704] plan(): nbrOfWorkers() = 1
[17:46:44.704] SequentialFuture started (and completed)
[17:46:44.704] - Launch lazy future ... done
[17:46:44.704] run() for ‘SequentialFuture’ ... done
[17:46:44.704] getGlobalsAndPackages() ...
[17:46:44.705] Searching for globals...
[17:46:44.705] 
[17:46:44.705] Searching for globals ... DONE
[17:46:44.705] - globals: [0] <none>
[17:46:44.705] getGlobalsAndPackages() ... DONE
[17:46:44.705] run() for ‘Future’ ...
[17:46:44.705] - state: ‘created’
[17:46:44.706] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.706] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.706] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.706]   - Field: ‘label’
[17:46:44.706]   - Field: ‘local’
[17:46:44.706]   - Field: ‘owner’
[17:46:44.706]   - Field: ‘envir’
[17:46:44.706]   - Field: ‘packages’
[17:46:44.706]   - Field: ‘gc’
[17:46:44.707]   - Field: ‘conditions’
[17:46:44.707]   - Field: ‘expr’
[17:46:44.707]   - Field: ‘uuid’
[17:46:44.707]   - Field: ‘seed’
[17:46:44.707]   - Field: ‘version’
[17:46:44.707]   - Field: ‘result’
[17:46:44.707]   - Field: ‘asynchronous’
[17:46:44.707]   - Field: ‘calls’
[17:46:44.707]   - Field: ‘globals’
[17:46:44.707]   - Field: ‘stdout’
[17:46:44.707]   - Field: ‘earlySignal’
[17:46:44.708]   - Field: ‘lazy’
[17:46:44.708]   - Field: ‘state’
[17:46:44.708] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.708] - Launch lazy future ...
[17:46:44.708] Packages needed by the future expression (n = 0): <none>
[17:46:44.708] Packages needed by future strategies (n = 0): <none>
[17:46:44.709] {
[17:46:44.709]     {
[17:46:44.709]         {
[17:46:44.709]             ...future.startTime <- base::Sys.time()
[17:46:44.709]             {
[17:46:44.709]                 {
[17:46:44.709]                   {
[17:46:44.709]                     base::local({
[17:46:44.709]                       has_future <- base::requireNamespace("future", 
[17:46:44.709]                         quietly = TRUE)
[17:46:44.709]                       if (has_future) {
[17:46:44.709]                         ns <- base::getNamespace("future")
[17:46:44.709]                         version <- ns[[".package"]][["version"]]
[17:46:44.709]                         if (is.null(version)) 
[17:46:44.709]                           version <- utils::packageVersion("future")
[17:46:44.709]                       }
[17:46:44.709]                       else {
[17:46:44.709]                         version <- NULL
[17:46:44.709]                       }
[17:46:44.709]                       if (!has_future || version < "1.8.0") {
[17:46:44.709]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.709]                           "", base::R.version$version.string), 
[17:46:44.709]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.709]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.709]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.709]                             "release", "version")], collapse = " "), 
[17:46:44.709]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.709]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.709]                           info)
[17:46:44.709]                         info <- base::paste(info, collapse = "; ")
[17:46:44.709]                         if (!has_future) {
[17:46:44.709]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.709]                             info)
[17:46:44.709]                         }
[17:46:44.709]                         else {
[17:46:44.709]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.709]                             info, version)
[17:46:44.709]                         }
[17:46:44.709]                         base::stop(msg)
[17:46:44.709]                       }
[17:46:44.709]                     })
[17:46:44.709]                   }
[17:46:44.709]                   ...future.strategy.old <- future::plan("list")
[17:46:44.709]                   options(future.plan = NULL)
[17:46:44.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.709]                 }
[17:46:44.709]                 ...future.workdir <- getwd()
[17:46:44.709]             }
[17:46:44.709]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.709]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.709]         }
[17:46:44.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.709]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.709]             base::names(...future.oldOptions))
[17:46:44.709]     }
[17:46:44.709]     if (FALSE) {
[17:46:44.709]     }
[17:46:44.709]     else {
[17:46:44.709]         if (TRUE) {
[17:46:44.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.709]                 open = "w")
[17:46:44.709]         }
[17:46:44.709]         else {
[17:46:44.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.709]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.709]         }
[17:46:44.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.709]             base::sink(type = "output", split = FALSE)
[17:46:44.709]             base::close(...future.stdout)
[17:46:44.709]         }, add = TRUE)
[17:46:44.709]     }
[17:46:44.709]     ...future.frame <- base::sys.nframe()
[17:46:44.709]     ...future.conditions <- base::list()
[17:46:44.709]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.709]     if (FALSE) {
[17:46:44.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.709]     }
[17:46:44.709]     ...future.result <- base::tryCatch({
[17:46:44.709]         base::withCallingHandlers({
[17:46:44.709]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.709]             future::FutureResult(value = ...future.value$value, 
[17:46:44.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.709]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.709]                     ...future.globalenv.names))
[17:46:44.709]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.709]         }, condition = base::local({
[17:46:44.709]             c <- base::c
[17:46:44.709]             inherits <- base::inherits
[17:46:44.709]             invokeRestart <- base::invokeRestart
[17:46:44.709]             length <- base::length
[17:46:44.709]             list <- base::list
[17:46:44.709]             seq.int <- base::seq.int
[17:46:44.709]             signalCondition <- base::signalCondition
[17:46:44.709]             sys.calls <- base::sys.calls
[17:46:44.709]             `[[` <- base::`[[`
[17:46:44.709]             `+` <- base::`+`
[17:46:44.709]             `<<-` <- base::`<<-`
[17:46:44.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.709]                   3L)]
[17:46:44.709]             }
[17:46:44.709]             function(cond) {
[17:46:44.709]                 is_error <- inherits(cond, "error")
[17:46:44.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.709]                   NULL)
[17:46:44.709]                 if (is_error) {
[17:46:44.709]                   sessionInformation <- function() {
[17:46:44.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.709]                       search = base::search(), system = base::Sys.info())
[17:46:44.709]                   }
[17:46:44.709]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.709]                     cond$call), session = sessionInformation(), 
[17:46:44.709]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.709]                   signalCondition(cond)
[17:46:44.709]                 }
[17:46:44.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.709]                 "immediateCondition"))) {
[17:46:44.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.709]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.709]                   if (TRUE && !signal) {
[17:46:44.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.709]                     {
[17:46:44.709]                       inherits <- base::inherits
[17:46:44.709]                       invokeRestart <- base::invokeRestart
[17:46:44.709]                       is.null <- base::is.null
[17:46:44.709]                       muffled <- FALSE
[17:46:44.709]                       if (inherits(cond, "message")) {
[17:46:44.709]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.709]                         if (muffled) 
[17:46:44.709]                           invokeRestart("muffleMessage")
[17:46:44.709]                       }
[17:46:44.709]                       else if (inherits(cond, "warning")) {
[17:46:44.709]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.709]                         if (muffled) 
[17:46:44.709]                           invokeRestart("muffleWarning")
[17:46:44.709]                       }
[17:46:44.709]                       else if (inherits(cond, "condition")) {
[17:46:44.709]                         if (!is.null(pattern)) {
[17:46:44.709]                           computeRestarts <- base::computeRestarts
[17:46:44.709]                           grepl <- base::grepl
[17:46:44.709]                           restarts <- computeRestarts(cond)
[17:46:44.709]                           for (restart in restarts) {
[17:46:44.709]                             name <- restart$name
[17:46:44.709]                             if (is.null(name)) 
[17:46:44.709]                               next
[17:46:44.709]                             if (!grepl(pattern, name)) 
[17:46:44.709]                               next
[17:46:44.709]                             invokeRestart(restart)
[17:46:44.709]                             muffled <- TRUE
[17:46:44.709]                             break
[17:46:44.709]                           }
[17:46:44.709]                         }
[17:46:44.709]                       }
[17:46:44.709]                       invisible(muffled)
[17:46:44.709]                     }
[17:46:44.709]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.709]                   }
[17:46:44.709]                 }
[17:46:44.709]                 else {
[17:46:44.709]                   if (TRUE) {
[17:46:44.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.709]                     {
[17:46:44.709]                       inherits <- base::inherits
[17:46:44.709]                       invokeRestart <- base::invokeRestart
[17:46:44.709]                       is.null <- base::is.null
[17:46:44.709]                       muffled <- FALSE
[17:46:44.709]                       if (inherits(cond, "message")) {
[17:46:44.709]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.709]                         if (muffled) 
[17:46:44.709]                           invokeRestart("muffleMessage")
[17:46:44.709]                       }
[17:46:44.709]                       else if (inherits(cond, "warning")) {
[17:46:44.709]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.709]                         if (muffled) 
[17:46:44.709]                           invokeRestart("muffleWarning")
[17:46:44.709]                       }
[17:46:44.709]                       else if (inherits(cond, "condition")) {
[17:46:44.709]                         if (!is.null(pattern)) {
[17:46:44.709]                           computeRestarts <- base::computeRestarts
[17:46:44.709]                           grepl <- base::grepl
[17:46:44.709]                           restarts <- computeRestarts(cond)
[17:46:44.709]                           for (restart in restarts) {
[17:46:44.709]                             name <- restart$name
[17:46:44.709]                             if (is.null(name)) 
[17:46:44.709]                               next
[17:46:44.709]                             if (!grepl(pattern, name)) 
[17:46:44.709]                               next
[17:46:44.709]                             invokeRestart(restart)
[17:46:44.709]                             muffled <- TRUE
[17:46:44.709]                             break
[17:46:44.709]                           }
[17:46:44.709]                         }
[17:46:44.709]                       }
[17:46:44.709]                       invisible(muffled)
[17:46:44.709]                     }
[17:46:44.709]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.709]                   }
[17:46:44.709]                 }
[17:46:44.709]             }
[17:46:44.709]         }))
[17:46:44.709]     }, error = function(ex) {
[17:46:44.709]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.709]                 ...future.rng), started = ...future.startTime, 
[17:46:44.709]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.709]             version = "1.8"), class = "FutureResult")
[17:46:44.709]     }, finally = {
[17:46:44.709]         if (!identical(...future.workdir, getwd())) 
[17:46:44.709]             setwd(...future.workdir)
[17:46:44.709]         {
[17:46:44.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.709]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.709]             }
[17:46:44.709]             base::options(...future.oldOptions)
[17:46:44.709]             if (.Platform$OS.type == "windows") {
[17:46:44.709]                 old_names <- names(...future.oldEnvVars)
[17:46:44.709]                 envs <- base::Sys.getenv()
[17:46:44.709]                 names <- names(envs)
[17:46:44.709]                 common <- intersect(names, old_names)
[17:46:44.709]                 added <- setdiff(names, old_names)
[17:46:44.709]                 removed <- setdiff(old_names, names)
[17:46:44.709]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.709]                   envs[common]]
[17:46:44.709]                 NAMES <- toupper(changed)
[17:46:44.709]                 args <- list()
[17:46:44.709]                 for (kk in seq_along(NAMES)) {
[17:46:44.709]                   name <- changed[[kk]]
[17:46:44.709]                   NAME <- NAMES[[kk]]
[17:46:44.709]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.709]                     next
[17:46:44.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.709]                 }
[17:46:44.709]                 NAMES <- toupper(added)
[17:46:44.709]                 for (kk in seq_along(NAMES)) {
[17:46:44.709]                   name <- added[[kk]]
[17:46:44.709]                   NAME <- NAMES[[kk]]
[17:46:44.709]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.709]                     next
[17:46:44.709]                   args[[name]] <- ""
[17:46:44.709]                 }
[17:46:44.709]                 NAMES <- toupper(removed)
[17:46:44.709]                 for (kk in seq_along(NAMES)) {
[17:46:44.709]                   name <- removed[[kk]]
[17:46:44.709]                   NAME <- NAMES[[kk]]
[17:46:44.709]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.709]                     next
[17:46:44.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.709]                 }
[17:46:44.709]                 if (length(args) > 0) 
[17:46:44.709]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.709]             }
[17:46:44.709]             else {
[17:46:44.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.709]             }
[17:46:44.709]             {
[17:46:44.709]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.709]                   0L) {
[17:46:44.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.709]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.709]                   base::options(opts)
[17:46:44.709]                 }
[17:46:44.709]                 {
[17:46:44.709]                   {
[17:46:44.709]                     NULL
[17:46:44.709]                     RNGkind("Mersenne-Twister")
[17:46:44.709]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.709]                       inherits = FALSE)
[17:46:44.709]                   }
[17:46:44.709]                   options(future.plan = NULL)
[17:46:44.709]                   if (is.na(NA_character_)) 
[17:46:44.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.709]                     .init = FALSE)
[17:46:44.709]                 }
[17:46:44.709]             }
[17:46:44.709]         }
[17:46:44.709]     })
[17:46:44.709]     if (TRUE) {
[17:46:44.709]         base::sink(type = "output", split = FALSE)
[17:46:44.709]         if (TRUE) {
[17:46:44.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.709]         }
[17:46:44.709]         else {
[17:46:44.709]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.709]         }
[17:46:44.709]         base::close(...future.stdout)
[17:46:44.709]         ...future.stdout <- NULL
[17:46:44.709]     }
[17:46:44.709]     ...future.result$conditions <- ...future.conditions
[17:46:44.709]     ...future.result$finished <- base::Sys.time()
[17:46:44.709]     ...future.result
[17:46:44.709] }
[17:46:44.710] plan(): Setting new future strategy stack:
[17:46:44.710] List of future strategies:
[17:46:44.710] 1. sequential:
[17:46:44.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.710]    - tweaked: FALSE
[17:46:44.710]    - call: NULL
[17:46:44.711] plan(): nbrOfWorkers() = 1
[17:46:44.711] plan(): Setting new future strategy stack:
[17:46:44.712] List of future strategies:
[17:46:44.712] 1. sequential:
[17:46:44.712]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.712]    - tweaked: FALSE
[17:46:44.712]    - call: plan(strategy)
[17:46:44.712] plan(): nbrOfWorkers() = 1
[17:46:44.712] SequentialFuture started (and completed)
[17:46:44.712] - Launch lazy future ... done
[17:46:44.712] run() for ‘SequentialFuture’ ... done
[17:46:44.713] getGlobalsAndPackages() ...
[17:46:44.713] Searching for globals...
[17:46:44.713] - globals found: [1] ‘{’
[17:46:44.713] Searching for globals ... DONE
[17:46:44.714] Resolving globals: FALSE
[17:46:44.714] 
[17:46:44.714] 
[17:46:44.714] getGlobalsAndPackages() ... DONE
[17:46:44.714] run() for ‘Future’ ...
[17:46:44.714] - state: ‘created’
[17:46:44.714] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.715] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.715]   - Field: ‘label’
[17:46:44.715]   - Field: ‘local’
[17:46:44.715]   - Field: ‘owner’
[17:46:44.715]   - Field: ‘envir’
[17:46:44.715]   - Field: ‘packages’
[17:46:44.715]   - Field: ‘gc’
[17:46:44.715]   - Field: ‘conditions’
[17:46:44.716]   - Field: ‘expr’
[17:46:44.716]   - Field: ‘uuid’
[17:46:44.716]   - Field: ‘seed’
[17:46:44.716]   - Field: ‘version’
[17:46:44.716]   - Field: ‘result’
[17:46:44.716]   - Field: ‘asynchronous’
[17:46:44.716]   - Field: ‘calls’
[17:46:44.716]   - Field: ‘globals’
[17:46:44.716]   - Field: ‘stdout’
[17:46:44.716]   - Field: ‘earlySignal’
[17:46:44.716]   - Field: ‘lazy’
[17:46:44.716]   - Field: ‘state’
[17:46:44.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.717] - Launch lazy future ...
[17:46:44.717] Packages needed by the future expression (n = 0): <none>
[17:46:44.717] Packages needed by future strategies (n = 0): <none>
[17:46:44.717] {
[17:46:44.717]     {
[17:46:44.717]         {
[17:46:44.717]             ...future.startTime <- base::Sys.time()
[17:46:44.717]             {
[17:46:44.717]                 {
[17:46:44.717]                   {
[17:46:44.717]                     base::local({
[17:46:44.717]                       has_future <- base::requireNamespace("future", 
[17:46:44.717]                         quietly = TRUE)
[17:46:44.717]                       if (has_future) {
[17:46:44.717]                         ns <- base::getNamespace("future")
[17:46:44.717]                         version <- ns[[".package"]][["version"]]
[17:46:44.717]                         if (is.null(version)) 
[17:46:44.717]                           version <- utils::packageVersion("future")
[17:46:44.717]                       }
[17:46:44.717]                       else {
[17:46:44.717]                         version <- NULL
[17:46:44.717]                       }
[17:46:44.717]                       if (!has_future || version < "1.8.0") {
[17:46:44.717]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.717]                           "", base::R.version$version.string), 
[17:46:44.717]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.717]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.717]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.717]                             "release", "version")], collapse = " "), 
[17:46:44.717]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.717]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.717]                           info)
[17:46:44.717]                         info <- base::paste(info, collapse = "; ")
[17:46:44.717]                         if (!has_future) {
[17:46:44.717]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.717]                             info)
[17:46:44.717]                         }
[17:46:44.717]                         else {
[17:46:44.717]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.717]                             info, version)
[17:46:44.717]                         }
[17:46:44.717]                         base::stop(msg)
[17:46:44.717]                       }
[17:46:44.717]                     })
[17:46:44.717]                   }
[17:46:44.717]                   ...future.strategy.old <- future::plan("list")
[17:46:44.717]                   options(future.plan = NULL)
[17:46:44.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.717]                 }
[17:46:44.717]                 ...future.workdir <- getwd()
[17:46:44.717]             }
[17:46:44.717]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.717]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.717]         }
[17:46:44.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.717]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.717]             base::names(...future.oldOptions))
[17:46:44.717]     }
[17:46:44.717]     if (FALSE) {
[17:46:44.717]     }
[17:46:44.717]     else {
[17:46:44.717]         if (TRUE) {
[17:46:44.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.717]                 open = "w")
[17:46:44.717]         }
[17:46:44.717]         else {
[17:46:44.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.717]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.717]         }
[17:46:44.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.717]             base::sink(type = "output", split = FALSE)
[17:46:44.717]             base::close(...future.stdout)
[17:46:44.717]         }, add = TRUE)
[17:46:44.717]     }
[17:46:44.717]     ...future.frame <- base::sys.nframe()
[17:46:44.717]     ...future.conditions <- base::list()
[17:46:44.717]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.717]     if (FALSE) {
[17:46:44.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.717]     }
[17:46:44.717]     ...future.result <- base::tryCatch({
[17:46:44.717]         base::withCallingHandlers({
[17:46:44.717]             ...future.value <- base::withVisible(base::local({
[17:46:44.717]                 4
[17:46:44.717]             }))
[17:46:44.717]             future::FutureResult(value = ...future.value$value, 
[17:46:44.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.717]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.717]                     ...future.globalenv.names))
[17:46:44.717]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.717]         }, condition = base::local({
[17:46:44.717]             c <- base::c
[17:46:44.717]             inherits <- base::inherits
[17:46:44.717]             invokeRestart <- base::invokeRestart
[17:46:44.717]             length <- base::length
[17:46:44.717]             list <- base::list
[17:46:44.717]             seq.int <- base::seq.int
[17:46:44.717]             signalCondition <- base::signalCondition
[17:46:44.717]             sys.calls <- base::sys.calls
[17:46:44.717]             `[[` <- base::`[[`
[17:46:44.717]             `+` <- base::`+`
[17:46:44.717]             `<<-` <- base::`<<-`
[17:46:44.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.717]                   3L)]
[17:46:44.717]             }
[17:46:44.717]             function(cond) {
[17:46:44.717]                 is_error <- inherits(cond, "error")
[17:46:44.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.717]                   NULL)
[17:46:44.717]                 if (is_error) {
[17:46:44.717]                   sessionInformation <- function() {
[17:46:44.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.717]                       search = base::search(), system = base::Sys.info())
[17:46:44.717]                   }
[17:46:44.717]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.717]                     cond$call), session = sessionInformation(), 
[17:46:44.717]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.717]                   signalCondition(cond)
[17:46:44.717]                 }
[17:46:44.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.717]                 "immediateCondition"))) {
[17:46:44.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.717]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.717]                   if (TRUE && !signal) {
[17:46:44.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.717]                     {
[17:46:44.717]                       inherits <- base::inherits
[17:46:44.717]                       invokeRestart <- base::invokeRestart
[17:46:44.717]                       is.null <- base::is.null
[17:46:44.717]                       muffled <- FALSE
[17:46:44.717]                       if (inherits(cond, "message")) {
[17:46:44.717]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.717]                         if (muffled) 
[17:46:44.717]                           invokeRestart("muffleMessage")
[17:46:44.717]                       }
[17:46:44.717]                       else if (inherits(cond, "warning")) {
[17:46:44.717]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.717]                         if (muffled) 
[17:46:44.717]                           invokeRestart("muffleWarning")
[17:46:44.717]                       }
[17:46:44.717]                       else if (inherits(cond, "condition")) {
[17:46:44.717]                         if (!is.null(pattern)) {
[17:46:44.717]                           computeRestarts <- base::computeRestarts
[17:46:44.717]                           grepl <- base::grepl
[17:46:44.717]                           restarts <- computeRestarts(cond)
[17:46:44.717]                           for (restart in restarts) {
[17:46:44.717]                             name <- restart$name
[17:46:44.717]                             if (is.null(name)) 
[17:46:44.717]                               next
[17:46:44.717]                             if (!grepl(pattern, name)) 
[17:46:44.717]                               next
[17:46:44.717]                             invokeRestart(restart)
[17:46:44.717]                             muffled <- TRUE
[17:46:44.717]                             break
[17:46:44.717]                           }
[17:46:44.717]                         }
[17:46:44.717]                       }
[17:46:44.717]                       invisible(muffled)
[17:46:44.717]                     }
[17:46:44.717]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.717]                   }
[17:46:44.717]                 }
[17:46:44.717]                 else {
[17:46:44.717]                   if (TRUE) {
[17:46:44.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.717]                     {
[17:46:44.717]                       inherits <- base::inherits
[17:46:44.717]                       invokeRestart <- base::invokeRestart
[17:46:44.717]                       is.null <- base::is.null
[17:46:44.717]                       muffled <- FALSE
[17:46:44.717]                       if (inherits(cond, "message")) {
[17:46:44.717]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.717]                         if (muffled) 
[17:46:44.717]                           invokeRestart("muffleMessage")
[17:46:44.717]                       }
[17:46:44.717]                       else if (inherits(cond, "warning")) {
[17:46:44.717]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.717]                         if (muffled) 
[17:46:44.717]                           invokeRestart("muffleWarning")
[17:46:44.717]                       }
[17:46:44.717]                       else if (inherits(cond, "condition")) {
[17:46:44.717]                         if (!is.null(pattern)) {
[17:46:44.717]                           computeRestarts <- base::computeRestarts
[17:46:44.717]                           grepl <- base::grepl
[17:46:44.717]                           restarts <- computeRestarts(cond)
[17:46:44.717]                           for (restart in restarts) {
[17:46:44.717]                             name <- restart$name
[17:46:44.717]                             if (is.null(name)) 
[17:46:44.717]                               next
[17:46:44.717]                             if (!grepl(pattern, name)) 
[17:46:44.717]                               next
[17:46:44.717]                             invokeRestart(restart)
[17:46:44.717]                             muffled <- TRUE
[17:46:44.717]                             break
[17:46:44.717]                           }
[17:46:44.717]                         }
[17:46:44.717]                       }
[17:46:44.717]                       invisible(muffled)
[17:46:44.717]                     }
[17:46:44.717]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.717]                   }
[17:46:44.717]                 }
[17:46:44.717]             }
[17:46:44.717]         }))
[17:46:44.717]     }, error = function(ex) {
[17:46:44.717]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.717]                 ...future.rng), started = ...future.startTime, 
[17:46:44.717]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.717]             version = "1.8"), class = "FutureResult")
[17:46:44.717]     }, finally = {
[17:46:44.717]         if (!identical(...future.workdir, getwd())) 
[17:46:44.717]             setwd(...future.workdir)
[17:46:44.717]         {
[17:46:44.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.717]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.717]             }
[17:46:44.717]             base::options(...future.oldOptions)
[17:46:44.717]             if (.Platform$OS.type == "windows") {
[17:46:44.717]                 old_names <- names(...future.oldEnvVars)
[17:46:44.717]                 envs <- base::Sys.getenv()
[17:46:44.717]                 names <- names(envs)
[17:46:44.717]                 common <- intersect(names, old_names)
[17:46:44.717]                 added <- setdiff(names, old_names)
[17:46:44.717]                 removed <- setdiff(old_names, names)
[17:46:44.717]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.717]                   envs[common]]
[17:46:44.717]                 NAMES <- toupper(changed)
[17:46:44.717]                 args <- list()
[17:46:44.717]                 for (kk in seq_along(NAMES)) {
[17:46:44.717]                   name <- changed[[kk]]
[17:46:44.717]                   NAME <- NAMES[[kk]]
[17:46:44.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.717]                     next
[17:46:44.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.717]                 }
[17:46:44.717]                 NAMES <- toupper(added)
[17:46:44.717]                 for (kk in seq_along(NAMES)) {
[17:46:44.717]                   name <- added[[kk]]
[17:46:44.717]                   NAME <- NAMES[[kk]]
[17:46:44.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.717]                     next
[17:46:44.717]                   args[[name]] <- ""
[17:46:44.717]                 }
[17:46:44.717]                 NAMES <- toupper(removed)
[17:46:44.717]                 for (kk in seq_along(NAMES)) {
[17:46:44.717]                   name <- removed[[kk]]
[17:46:44.717]                   NAME <- NAMES[[kk]]
[17:46:44.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.717]                     next
[17:46:44.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.717]                 }
[17:46:44.717]                 if (length(args) > 0) 
[17:46:44.717]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.717]             }
[17:46:44.717]             else {
[17:46:44.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.717]             }
[17:46:44.717]             {
[17:46:44.717]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.717]                   0L) {
[17:46:44.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.717]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.717]                   base::options(opts)
[17:46:44.717]                 }
[17:46:44.717]                 {
[17:46:44.717]                   {
[17:46:44.717]                     NULL
[17:46:44.717]                     RNGkind("Mersenne-Twister")
[17:46:44.717]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.717]                       inherits = FALSE)
[17:46:44.717]                   }
[17:46:44.717]                   options(future.plan = NULL)
[17:46:44.717]                   if (is.na(NA_character_)) 
[17:46:44.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.717]                     .init = FALSE)
[17:46:44.717]                 }
[17:46:44.717]             }
[17:46:44.717]         }
[17:46:44.717]     })
[17:46:44.717]     if (TRUE) {
[17:46:44.717]         base::sink(type = "output", split = FALSE)
[17:46:44.717]         if (TRUE) {
[17:46:44.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.717]         }
[17:46:44.717]         else {
[17:46:44.717]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.717]         }
[17:46:44.717]         base::close(...future.stdout)
[17:46:44.717]         ...future.stdout <- NULL
[17:46:44.717]     }
[17:46:44.717]     ...future.result$conditions <- ...future.conditions
[17:46:44.717]     ...future.result$finished <- base::Sys.time()
[17:46:44.717]     ...future.result
[17:46:44.717] }
[17:46:44.719] plan(): Setting new future strategy stack:
[17:46:44.719] List of future strategies:
[17:46:44.719] 1. sequential:
[17:46:44.719]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.719]    - tweaked: FALSE
[17:46:44.719]    - call: NULL
[17:46:44.720] plan(): nbrOfWorkers() = 1
[17:46:44.720] plan(): Setting new future strategy stack:
[17:46:44.720] List of future strategies:
[17:46:44.720] 1. sequential:
[17:46:44.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.720]    - tweaked: FALSE
[17:46:44.720]    - call: plan(strategy)
[17:46:44.721] plan(): nbrOfWorkers() = 1
[17:46:44.721] SequentialFuture started (and completed)
[17:46:44.721] - Launch lazy future ... done
[17:46:44.721] run() for ‘SequentialFuture’ ... done
<environment: 0x561786355bc8> 
<environment: 0x561787e83c10> 
[17:46:44.722] resolved() for ‘SequentialFuture’ ...
[17:46:44.722] - state: ‘finished’
[17:46:44.723] - run: TRUE
[17:46:44.723] - result: ‘FutureResult’
[17:46:44.723] resolved() for ‘SequentialFuture’ ... done
[17:46:44.723] resolved() for ‘SequentialFuture’ ...
[17:46:44.723] - state: ‘finished’
[17:46:44.723] - run: TRUE
[17:46:44.723] - result: ‘FutureResult’
[17:46:44.723] resolved() for ‘SequentialFuture’ ... done
[17:46:44.723] resolved() for ‘SequentialFuture’ ...
[17:46:44.723] - state: ‘finished’
[17:46:44.724] - run: TRUE
[17:46:44.724] - result: ‘FutureResult’
[17:46:44.724] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:44.727] resolve() on environment ...
[17:46:44.727]  recursive: 0
[17:46:44.727]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:44.727] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.727] - nx: 4
[17:46:44.728] - relay: TRUE
[17:46:44.728] - stdout: TRUE
[17:46:44.728] - signal: TRUE
[17:46:44.728] - resignal: FALSE
[17:46:44.728] - force: TRUE
[17:46:44.728] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.728] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.728]  - until=2
[17:46:44.728]  - relaying element #2
[17:46:44.728] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.728] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.728] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.729]  length: 3 (resolved future 1)
[17:46:44.729] resolved() for ‘SequentialFuture’ ...
[17:46:44.729] - state: ‘finished’
[17:46:44.729] - run: TRUE
[17:46:44.729] - result: ‘FutureResult’
[17:46:44.729] resolved() for ‘SequentialFuture’ ... done
[17:46:44.729] Future #2
[17:46:44.729] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.729] - nx: 4
[17:46:44.729] - relay: TRUE
[17:46:44.730] - stdout: TRUE
[17:46:44.730] - signal: TRUE
[17:46:44.730] - resignal: FALSE
[17:46:44.730] - force: TRUE
[17:46:44.730] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.730] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.730]  - until=2
[17:46:44.730]  - relaying element #2
[17:46:44.730] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.730] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.730] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.731]  length: 2 (resolved future 2)
[17:46:44.731] resolved() for ‘SequentialFuture’ ...
[17:46:44.731] - state: ‘finished’
[17:46:44.731] - run: TRUE
[17:46:44.731] - result: ‘FutureResult’
[17:46:44.731] resolved() for ‘SequentialFuture’ ... done
[17:46:44.731] Future #3
[17:46:44.731] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.731] - nx: 4
[17:46:44.731] - relay: TRUE
[17:46:44.732] - stdout: TRUE
[17:46:44.732] - signal: TRUE
[17:46:44.732] - resignal: FALSE
[17:46:44.732] - force: TRUE
[17:46:44.732] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.732] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.732]  - until=3
[17:46:44.732]  - relaying element #3
[17:46:44.732] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.732] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.732] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.733]  length: 1 (resolved future 3)
[17:46:44.733] resolved() for ‘SequentialFuture’ ...
[17:46:44.733] - state: ‘finished’
[17:46:44.733] - run: TRUE
[17:46:44.733] - result: ‘FutureResult’
[17:46:44.733] resolved() for ‘SequentialFuture’ ... done
[17:46:44.733] Future #4
[17:46:44.733] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:44.733] - nx: 4
[17:46:44.733] - relay: TRUE
[17:46:44.734] - stdout: TRUE
[17:46:44.734] - signal: TRUE
[17:46:44.734] - resignal: FALSE
[17:46:44.734] - force: TRUE
[17:46:44.734] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.734] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.734]  - until=4
[17:46:44.734]  - relaying element #4
[17:46:44.734] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.734] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.734] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:44.735]  length: 0 (resolved future 4)
[17:46:44.735] Relaying remaining futures
[17:46:44.735] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.735] - nx: 4
[17:46:44.735] - relay: TRUE
[17:46:44.735] - stdout: TRUE
[17:46:44.735] - signal: TRUE
[17:46:44.735] - resignal: FALSE
[17:46:44.735] - force: TRUE
[17:46:44.735] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.735] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:44.736] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.736] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.736] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.736] resolve() on environment ... DONE
<environment: 0x561786f492f8> 
Dimensions: c(2, 3)
[17:46:44.736] getGlobalsAndPackages() ...
[17:46:44.736] Searching for globals...
[17:46:44.737] 
[17:46:44.737] Searching for globals ... DONE
[17:46:44.737] - globals: [0] <none>
[17:46:44.737] getGlobalsAndPackages() ... DONE
[17:46:44.737] run() for ‘Future’ ...
[17:46:44.737] - state: ‘created’
[17:46:44.737] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.738] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.738]   - Field: ‘label’
[17:46:44.738]   - Field: ‘local’
[17:46:44.738]   - Field: ‘owner’
[17:46:44.738]   - Field: ‘envir’
[17:46:44.738]   - Field: ‘packages’
[17:46:44.738]   - Field: ‘gc’
[17:46:44.738]   - Field: ‘conditions’
[17:46:44.738]   - Field: ‘expr’
[17:46:44.739]   - Field: ‘uuid’
[17:46:44.739]   - Field: ‘seed’
[17:46:44.739]   - Field: ‘version’
[17:46:44.739]   - Field: ‘result’
[17:46:44.739]   - Field: ‘asynchronous’
[17:46:44.739]   - Field: ‘calls’
[17:46:44.739]   - Field: ‘globals’
[17:46:44.739]   - Field: ‘stdout’
[17:46:44.739]   - Field: ‘earlySignal’
[17:46:44.739]   - Field: ‘lazy’
[17:46:44.739]   - Field: ‘state’
[17:46:44.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.740] - Launch lazy future ...
[17:46:44.740] Packages needed by the future expression (n = 0): <none>
[17:46:44.740] Packages needed by future strategies (n = 0): <none>
[17:46:44.740] {
[17:46:44.740]     {
[17:46:44.740]         {
[17:46:44.740]             ...future.startTime <- base::Sys.time()
[17:46:44.740]             {
[17:46:44.740]                 {
[17:46:44.740]                   {
[17:46:44.740]                     base::local({
[17:46:44.740]                       has_future <- base::requireNamespace("future", 
[17:46:44.740]                         quietly = TRUE)
[17:46:44.740]                       if (has_future) {
[17:46:44.740]                         ns <- base::getNamespace("future")
[17:46:44.740]                         version <- ns[[".package"]][["version"]]
[17:46:44.740]                         if (is.null(version)) 
[17:46:44.740]                           version <- utils::packageVersion("future")
[17:46:44.740]                       }
[17:46:44.740]                       else {
[17:46:44.740]                         version <- NULL
[17:46:44.740]                       }
[17:46:44.740]                       if (!has_future || version < "1.8.0") {
[17:46:44.740]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.740]                           "", base::R.version$version.string), 
[17:46:44.740]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.740]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.740]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.740]                             "release", "version")], collapse = " "), 
[17:46:44.740]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.740]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.740]                           info)
[17:46:44.740]                         info <- base::paste(info, collapse = "; ")
[17:46:44.740]                         if (!has_future) {
[17:46:44.740]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.740]                             info)
[17:46:44.740]                         }
[17:46:44.740]                         else {
[17:46:44.740]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.740]                             info, version)
[17:46:44.740]                         }
[17:46:44.740]                         base::stop(msg)
[17:46:44.740]                       }
[17:46:44.740]                     })
[17:46:44.740]                   }
[17:46:44.740]                   ...future.strategy.old <- future::plan("list")
[17:46:44.740]                   options(future.plan = NULL)
[17:46:44.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.740]                 }
[17:46:44.740]                 ...future.workdir <- getwd()
[17:46:44.740]             }
[17:46:44.740]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.740]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.740]         }
[17:46:44.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.740]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.740]             base::names(...future.oldOptions))
[17:46:44.740]     }
[17:46:44.740]     if (FALSE) {
[17:46:44.740]     }
[17:46:44.740]     else {
[17:46:44.740]         if (TRUE) {
[17:46:44.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.740]                 open = "w")
[17:46:44.740]         }
[17:46:44.740]         else {
[17:46:44.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.740]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.740]         }
[17:46:44.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.740]             base::sink(type = "output", split = FALSE)
[17:46:44.740]             base::close(...future.stdout)
[17:46:44.740]         }, add = TRUE)
[17:46:44.740]     }
[17:46:44.740]     ...future.frame <- base::sys.nframe()
[17:46:44.740]     ...future.conditions <- base::list()
[17:46:44.740]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.740]     if (FALSE) {
[17:46:44.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.740]     }
[17:46:44.740]     ...future.result <- base::tryCatch({
[17:46:44.740]         base::withCallingHandlers({
[17:46:44.740]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.740]             future::FutureResult(value = ...future.value$value, 
[17:46:44.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.740]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.740]                     ...future.globalenv.names))
[17:46:44.740]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.740]         }, condition = base::local({
[17:46:44.740]             c <- base::c
[17:46:44.740]             inherits <- base::inherits
[17:46:44.740]             invokeRestart <- base::invokeRestart
[17:46:44.740]             length <- base::length
[17:46:44.740]             list <- base::list
[17:46:44.740]             seq.int <- base::seq.int
[17:46:44.740]             signalCondition <- base::signalCondition
[17:46:44.740]             sys.calls <- base::sys.calls
[17:46:44.740]             `[[` <- base::`[[`
[17:46:44.740]             `+` <- base::`+`
[17:46:44.740]             `<<-` <- base::`<<-`
[17:46:44.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.740]                   3L)]
[17:46:44.740]             }
[17:46:44.740]             function(cond) {
[17:46:44.740]                 is_error <- inherits(cond, "error")
[17:46:44.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.740]                   NULL)
[17:46:44.740]                 if (is_error) {
[17:46:44.740]                   sessionInformation <- function() {
[17:46:44.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.740]                       search = base::search(), system = base::Sys.info())
[17:46:44.740]                   }
[17:46:44.740]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.740]                     cond$call), session = sessionInformation(), 
[17:46:44.740]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.740]                   signalCondition(cond)
[17:46:44.740]                 }
[17:46:44.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.740]                 "immediateCondition"))) {
[17:46:44.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.740]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.740]                   if (TRUE && !signal) {
[17:46:44.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.740]                     {
[17:46:44.740]                       inherits <- base::inherits
[17:46:44.740]                       invokeRestart <- base::invokeRestart
[17:46:44.740]                       is.null <- base::is.null
[17:46:44.740]                       muffled <- FALSE
[17:46:44.740]                       if (inherits(cond, "message")) {
[17:46:44.740]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.740]                         if (muffled) 
[17:46:44.740]                           invokeRestart("muffleMessage")
[17:46:44.740]                       }
[17:46:44.740]                       else if (inherits(cond, "warning")) {
[17:46:44.740]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.740]                         if (muffled) 
[17:46:44.740]                           invokeRestart("muffleWarning")
[17:46:44.740]                       }
[17:46:44.740]                       else if (inherits(cond, "condition")) {
[17:46:44.740]                         if (!is.null(pattern)) {
[17:46:44.740]                           computeRestarts <- base::computeRestarts
[17:46:44.740]                           grepl <- base::grepl
[17:46:44.740]                           restarts <- computeRestarts(cond)
[17:46:44.740]                           for (restart in restarts) {
[17:46:44.740]                             name <- restart$name
[17:46:44.740]                             if (is.null(name)) 
[17:46:44.740]                               next
[17:46:44.740]                             if (!grepl(pattern, name)) 
[17:46:44.740]                               next
[17:46:44.740]                             invokeRestart(restart)
[17:46:44.740]                             muffled <- TRUE
[17:46:44.740]                             break
[17:46:44.740]                           }
[17:46:44.740]                         }
[17:46:44.740]                       }
[17:46:44.740]                       invisible(muffled)
[17:46:44.740]                     }
[17:46:44.740]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.740]                   }
[17:46:44.740]                 }
[17:46:44.740]                 else {
[17:46:44.740]                   if (TRUE) {
[17:46:44.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.740]                     {
[17:46:44.740]                       inherits <- base::inherits
[17:46:44.740]                       invokeRestart <- base::invokeRestart
[17:46:44.740]                       is.null <- base::is.null
[17:46:44.740]                       muffled <- FALSE
[17:46:44.740]                       if (inherits(cond, "message")) {
[17:46:44.740]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.740]                         if (muffled) 
[17:46:44.740]                           invokeRestart("muffleMessage")
[17:46:44.740]                       }
[17:46:44.740]                       else if (inherits(cond, "warning")) {
[17:46:44.740]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.740]                         if (muffled) 
[17:46:44.740]                           invokeRestart("muffleWarning")
[17:46:44.740]                       }
[17:46:44.740]                       else if (inherits(cond, "condition")) {
[17:46:44.740]                         if (!is.null(pattern)) {
[17:46:44.740]                           computeRestarts <- base::computeRestarts
[17:46:44.740]                           grepl <- base::grepl
[17:46:44.740]                           restarts <- computeRestarts(cond)
[17:46:44.740]                           for (restart in restarts) {
[17:46:44.740]                             name <- restart$name
[17:46:44.740]                             if (is.null(name)) 
[17:46:44.740]                               next
[17:46:44.740]                             if (!grepl(pattern, name)) 
[17:46:44.740]                               next
[17:46:44.740]                             invokeRestart(restart)
[17:46:44.740]                             muffled <- TRUE
[17:46:44.740]                             break
[17:46:44.740]                           }
[17:46:44.740]                         }
[17:46:44.740]                       }
[17:46:44.740]                       invisible(muffled)
[17:46:44.740]                     }
[17:46:44.740]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.740]                   }
[17:46:44.740]                 }
[17:46:44.740]             }
[17:46:44.740]         }))
[17:46:44.740]     }, error = function(ex) {
[17:46:44.740]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.740]                 ...future.rng), started = ...future.startTime, 
[17:46:44.740]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.740]             version = "1.8"), class = "FutureResult")
[17:46:44.740]     }, finally = {
[17:46:44.740]         if (!identical(...future.workdir, getwd())) 
[17:46:44.740]             setwd(...future.workdir)
[17:46:44.740]         {
[17:46:44.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.740]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.740]             }
[17:46:44.740]             base::options(...future.oldOptions)
[17:46:44.740]             if (.Platform$OS.type == "windows") {
[17:46:44.740]                 old_names <- names(...future.oldEnvVars)
[17:46:44.740]                 envs <- base::Sys.getenv()
[17:46:44.740]                 names <- names(envs)
[17:46:44.740]                 common <- intersect(names, old_names)
[17:46:44.740]                 added <- setdiff(names, old_names)
[17:46:44.740]                 removed <- setdiff(old_names, names)
[17:46:44.740]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.740]                   envs[common]]
[17:46:44.740]                 NAMES <- toupper(changed)
[17:46:44.740]                 args <- list()
[17:46:44.740]                 for (kk in seq_along(NAMES)) {
[17:46:44.740]                   name <- changed[[kk]]
[17:46:44.740]                   NAME <- NAMES[[kk]]
[17:46:44.740]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.740]                     next
[17:46:44.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.740]                 }
[17:46:44.740]                 NAMES <- toupper(added)
[17:46:44.740]                 for (kk in seq_along(NAMES)) {
[17:46:44.740]                   name <- added[[kk]]
[17:46:44.740]                   NAME <- NAMES[[kk]]
[17:46:44.740]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.740]                     next
[17:46:44.740]                   args[[name]] <- ""
[17:46:44.740]                 }
[17:46:44.740]                 NAMES <- toupper(removed)
[17:46:44.740]                 for (kk in seq_along(NAMES)) {
[17:46:44.740]                   name <- removed[[kk]]
[17:46:44.740]                   NAME <- NAMES[[kk]]
[17:46:44.740]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.740]                     next
[17:46:44.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.740]                 }
[17:46:44.740]                 if (length(args) > 0) 
[17:46:44.740]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.740]             }
[17:46:44.740]             else {
[17:46:44.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.740]             }
[17:46:44.740]             {
[17:46:44.740]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.740]                   0L) {
[17:46:44.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.740]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.740]                   base::options(opts)
[17:46:44.740]                 }
[17:46:44.740]                 {
[17:46:44.740]                   {
[17:46:44.740]                     NULL
[17:46:44.740]                     RNGkind("Mersenne-Twister")
[17:46:44.740]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.740]                       inherits = FALSE)
[17:46:44.740]                   }
[17:46:44.740]                   options(future.plan = NULL)
[17:46:44.740]                   if (is.na(NA_character_)) 
[17:46:44.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.740]                     .init = FALSE)
[17:46:44.740]                 }
[17:46:44.740]             }
[17:46:44.740]         }
[17:46:44.740]     })
[17:46:44.740]     if (TRUE) {
[17:46:44.740]         base::sink(type = "output", split = FALSE)
[17:46:44.740]         if (TRUE) {
[17:46:44.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.740]         }
[17:46:44.740]         else {
[17:46:44.740]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.740]         }
[17:46:44.740]         base::close(...future.stdout)
[17:46:44.740]         ...future.stdout <- NULL
[17:46:44.740]     }
[17:46:44.740]     ...future.result$conditions <- ...future.conditions
[17:46:44.740]     ...future.result$finished <- base::Sys.time()
[17:46:44.740]     ...future.result
[17:46:44.740] }
[17:46:44.742] plan(): Setting new future strategy stack:
[17:46:44.742] List of future strategies:
[17:46:44.742] 1. sequential:
[17:46:44.742]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.742]    - tweaked: FALSE
[17:46:44.742]    - call: NULL
[17:46:44.743] plan(): nbrOfWorkers() = 1
[17:46:44.743] plan(): Setting new future strategy stack:
[17:46:44.743] List of future strategies:
[17:46:44.743] 1. sequential:
[17:46:44.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.743]    - tweaked: FALSE
[17:46:44.743]    - call: plan(strategy)
[17:46:44.744] plan(): nbrOfWorkers() = 1
[17:46:44.744] SequentialFuture started (and completed)
[17:46:44.744] - Launch lazy future ... done
[17:46:44.744] run() for ‘SequentialFuture’ ... done
[17:46:44.744] getGlobalsAndPackages() ...
[17:46:44.744] Searching for globals...
[17:46:44.745] 
[17:46:44.745] Searching for globals ... DONE
[17:46:44.745] - globals: [0] <none>
[17:46:44.745] getGlobalsAndPackages() ... DONE
[17:46:44.745] run() for ‘Future’ ...
[17:46:44.745] - state: ‘created’
[17:46:44.745] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.746] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.746] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.746]   - Field: ‘label’
[17:46:44.746]   - Field: ‘local’
[17:46:44.746]   - Field: ‘owner’
[17:46:44.746]   - Field: ‘envir’
[17:46:44.746]   - Field: ‘packages’
[17:46:44.746]   - Field: ‘gc’
[17:46:44.746]   - Field: ‘conditions’
[17:46:44.746]   - Field: ‘expr’
[17:46:44.746]   - Field: ‘uuid’
[17:46:44.747]   - Field: ‘seed’
[17:46:44.747]   - Field: ‘version’
[17:46:44.747]   - Field: ‘result’
[17:46:44.747]   - Field: ‘asynchronous’
[17:46:44.747]   - Field: ‘calls’
[17:46:44.747]   - Field: ‘globals’
[17:46:44.747]   - Field: ‘stdout’
[17:46:44.747]   - Field: ‘earlySignal’
[17:46:44.747]   - Field: ‘lazy’
[17:46:44.747]   - Field: ‘state’
[17:46:44.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.748] - Launch lazy future ...
[17:46:44.748] Packages needed by the future expression (n = 0): <none>
[17:46:44.748] Packages needed by future strategies (n = 0): <none>
[17:46:44.748] {
[17:46:44.748]     {
[17:46:44.748]         {
[17:46:44.748]             ...future.startTime <- base::Sys.time()
[17:46:44.748]             {
[17:46:44.748]                 {
[17:46:44.748]                   {
[17:46:44.748]                     base::local({
[17:46:44.748]                       has_future <- base::requireNamespace("future", 
[17:46:44.748]                         quietly = TRUE)
[17:46:44.748]                       if (has_future) {
[17:46:44.748]                         ns <- base::getNamespace("future")
[17:46:44.748]                         version <- ns[[".package"]][["version"]]
[17:46:44.748]                         if (is.null(version)) 
[17:46:44.748]                           version <- utils::packageVersion("future")
[17:46:44.748]                       }
[17:46:44.748]                       else {
[17:46:44.748]                         version <- NULL
[17:46:44.748]                       }
[17:46:44.748]                       if (!has_future || version < "1.8.0") {
[17:46:44.748]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.748]                           "", base::R.version$version.string), 
[17:46:44.748]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.748]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.748]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.748]                             "release", "version")], collapse = " "), 
[17:46:44.748]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.748]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.748]                           info)
[17:46:44.748]                         info <- base::paste(info, collapse = "; ")
[17:46:44.748]                         if (!has_future) {
[17:46:44.748]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.748]                             info)
[17:46:44.748]                         }
[17:46:44.748]                         else {
[17:46:44.748]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.748]                             info, version)
[17:46:44.748]                         }
[17:46:44.748]                         base::stop(msg)
[17:46:44.748]                       }
[17:46:44.748]                     })
[17:46:44.748]                   }
[17:46:44.748]                   ...future.strategy.old <- future::plan("list")
[17:46:44.748]                   options(future.plan = NULL)
[17:46:44.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.748]                 }
[17:46:44.748]                 ...future.workdir <- getwd()
[17:46:44.748]             }
[17:46:44.748]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.748]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.748]         }
[17:46:44.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.748]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.748]             base::names(...future.oldOptions))
[17:46:44.748]     }
[17:46:44.748]     if (FALSE) {
[17:46:44.748]     }
[17:46:44.748]     else {
[17:46:44.748]         if (TRUE) {
[17:46:44.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.748]                 open = "w")
[17:46:44.748]         }
[17:46:44.748]         else {
[17:46:44.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.748]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.748]         }
[17:46:44.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.748]             base::sink(type = "output", split = FALSE)
[17:46:44.748]             base::close(...future.stdout)
[17:46:44.748]         }, add = TRUE)
[17:46:44.748]     }
[17:46:44.748]     ...future.frame <- base::sys.nframe()
[17:46:44.748]     ...future.conditions <- base::list()
[17:46:44.748]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.748]     if (FALSE) {
[17:46:44.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.748]     }
[17:46:44.748]     ...future.result <- base::tryCatch({
[17:46:44.748]         base::withCallingHandlers({
[17:46:44.748]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.748]             future::FutureResult(value = ...future.value$value, 
[17:46:44.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.748]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.748]                     ...future.globalenv.names))
[17:46:44.748]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.748]         }, condition = base::local({
[17:46:44.748]             c <- base::c
[17:46:44.748]             inherits <- base::inherits
[17:46:44.748]             invokeRestart <- base::invokeRestart
[17:46:44.748]             length <- base::length
[17:46:44.748]             list <- base::list
[17:46:44.748]             seq.int <- base::seq.int
[17:46:44.748]             signalCondition <- base::signalCondition
[17:46:44.748]             sys.calls <- base::sys.calls
[17:46:44.748]             `[[` <- base::`[[`
[17:46:44.748]             `+` <- base::`+`
[17:46:44.748]             `<<-` <- base::`<<-`
[17:46:44.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.748]                   3L)]
[17:46:44.748]             }
[17:46:44.748]             function(cond) {
[17:46:44.748]                 is_error <- inherits(cond, "error")
[17:46:44.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.748]                   NULL)
[17:46:44.748]                 if (is_error) {
[17:46:44.748]                   sessionInformation <- function() {
[17:46:44.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.748]                       search = base::search(), system = base::Sys.info())
[17:46:44.748]                   }
[17:46:44.748]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.748]                     cond$call), session = sessionInformation(), 
[17:46:44.748]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.748]                   signalCondition(cond)
[17:46:44.748]                 }
[17:46:44.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.748]                 "immediateCondition"))) {
[17:46:44.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.748]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.748]                   if (TRUE && !signal) {
[17:46:44.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.748]                     {
[17:46:44.748]                       inherits <- base::inherits
[17:46:44.748]                       invokeRestart <- base::invokeRestart
[17:46:44.748]                       is.null <- base::is.null
[17:46:44.748]                       muffled <- FALSE
[17:46:44.748]                       if (inherits(cond, "message")) {
[17:46:44.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.748]                         if (muffled) 
[17:46:44.748]                           invokeRestart("muffleMessage")
[17:46:44.748]                       }
[17:46:44.748]                       else if (inherits(cond, "warning")) {
[17:46:44.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.748]                         if (muffled) 
[17:46:44.748]                           invokeRestart("muffleWarning")
[17:46:44.748]                       }
[17:46:44.748]                       else if (inherits(cond, "condition")) {
[17:46:44.748]                         if (!is.null(pattern)) {
[17:46:44.748]                           computeRestarts <- base::computeRestarts
[17:46:44.748]                           grepl <- base::grepl
[17:46:44.748]                           restarts <- computeRestarts(cond)
[17:46:44.748]                           for (restart in restarts) {
[17:46:44.748]                             name <- restart$name
[17:46:44.748]                             if (is.null(name)) 
[17:46:44.748]                               next
[17:46:44.748]                             if (!grepl(pattern, name)) 
[17:46:44.748]                               next
[17:46:44.748]                             invokeRestart(restart)
[17:46:44.748]                             muffled <- TRUE
[17:46:44.748]                             break
[17:46:44.748]                           }
[17:46:44.748]                         }
[17:46:44.748]                       }
[17:46:44.748]                       invisible(muffled)
[17:46:44.748]                     }
[17:46:44.748]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.748]                   }
[17:46:44.748]                 }
[17:46:44.748]                 else {
[17:46:44.748]                   if (TRUE) {
[17:46:44.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.748]                     {
[17:46:44.748]                       inherits <- base::inherits
[17:46:44.748]                       invokeRestart <- base::invokeRestart
[17:46:44.748]                       is.null <- base::is.null
[17:46:44.748]                       muffled <- FALSE
[17:46:44.748]                       if (inherits(cond, "message")) {
[17:46:44.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.748]                         if (muffled) 
[17:46:44.748]                           invokeRestart("muffleMessage")
[17:46:44.748]                       }
[17:46:44.748]                       else if (inherits(cond, "warning")) {
[17:46:44.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.748]                         if (muffled) 
[17:46:44.748]                           invokeRestart("muffleWarning")
[17:46:44.748]                       }
[17:46:44.748]                       else if (inherits(cond, "condition")) {
[17:46:44.748]                         if (!is.null(pattern)) {
[17:46:44.748]                           computeRestarts <- base::computeRestarts
[17:46:44.748]                           grepl <- base::grepl
[17:46:44.748]                           restarts <- computeRestarts(cond)
[17:46:44.748]                           for (restart in restarts) {
[17:46:44.748]                             name <- restart$name
[17:46:44.748]                             if (is.null(name)) 
[17:46:44.748]                               next
[17:46:44.748]                             if (!grepl(pattern, name)) 
[17:46:44.748]                               next
[17:46:44.748]                             invokeRestart(restart)
[17:46:44.748]                             muffled <- TRUE
[17:46:44.748]                             break
[17:46:44.748]                           }
[17:46:44.748]                         }
[17:46:44.748]                       }
[17:46:44.748]                       invisible(muffled)
[17:46:44.748]                     }
[17:46:44.748]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.748]                   }
[17:46:44.748]                 }
[17:46:44.748]             }
[17:46:44.748]         }))
[17:46:44.748]     }, error = function(ex) {
[17:46:44.748]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.748]                 ...future.rng), started = ...future.startTime, 
[17:46:44.748]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.748]             version = "1.8"), class = "FutureResult")
[17:46:44.748]     }, finally = {
[17:46:44.748]         if (!identical(...future.workdir, getwd())) 
[17:46:44.748]             setwd(...future.workdir)
[17:46:44.748]         {
[17:46:44.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.748]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.748]             }
[17:46:44.748]             base::options(...future.oldOptions)
[17:46:44.748]             if (.Platform$OS.type == "windows") {
[17:46:44.748]                 old_names <- names(...future.oldEnvVars)
[17:46:44.748]                 envs <- base::Sys.getenv()
[17:46:44.748]                 names <- names(envs)
[17:46:44.748]                 common <- intersect(names, old_names)
[17:46:44.748]                 added <- setdiff(names, old_names)
[17:46:44.748]                 removed <- setdiff(old_names, names)
[17:46:44.748]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.748]                   envs[common]]
[17:46:44.748]                 NAMES <- toupper(changed)
[17:46:44.748]                 args <- list()
[17:46:44.748]                 for (kk in seq_along(NAMES)) {
[17:46:44.748]                   name <- changed[[kk]]
[17:46:44.748]                   NAME <- NAMES[[kk]]
[17:46:44.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.748]                     next
[17:46:44.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.748]                 }
[17:46:44.748]                 NAMES <- toupper(added)
[17:46:44.748]                 for (kk in seq_along(NAMES)) {
[17:46:44.748]                   name <- added[[kk]]
[17:46:44.748]                   NAME <- NAMES[[kk]]
[17:46:44.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.748]                     next
[17:46:44.748]                   args[[name]] <- ""
[17:46:44.748]                 }
[17:46:44.748]                 NAMES <- toupper(removed)
[17:46:44.748]                 for (kk in seq_along(NAMES)) {
[17:46:44.748]                   name <- removed[[kk]]
[17:46:44.748]                   NAME <- NAMES[[kk]]
[17:46:44.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.748]                     next
[17:46:44.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.748]                 }
[17:46:44.748]                 if (length(args) > 0) 
[17:46:44.748]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.748]             }
[17:46:44.748]             else {
[17:46:44.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.748]             }
[17:46:44.748]             {
[17:46:44.748]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.748]                   0L) {
[17:46:44.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.748]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.748]                   base::options(opts)
[17:46:44.748]                 }
[17:46:44.748]                 {
[17:46:44.748]                   {
[17:46:44.748]                     NULL
[17:46:44.748]                     RNGkind("Mersenne-Twister")
[17:46:44.748]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.748]                       inherits = FALSE)
[17:46:44.748]                   }
[17:46:44.748]                   options(future.plan = NULL)
[17:46:44.748]                   if (is.na(NA_character_)) 
[17:46:44.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.748]                     .init = FALSE)
[17:46:44.748]                 }
[17:46:44.748]             }
[17:46:44.748]         }
[17:46:44.748]     })
[17:46:44.748]     if (TRUE) {
[17:46:44.748]         base::sink(type = "output", split = FALSE)
[17:46:44.748]         if (TRUE) {
[17:46:44.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.748]         }
[17:46:44.748]         else {
[17:46:44.748]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.748]         }
[17:46:44.748]         base::close(...future.stdout)
[17:46:44.748]         ...future.stdout <- NULL
[17:46:44.748]     }
[17:46:44.748]     ...future.result$conditions <- ...future.conditions
[17:46:44.748]     ...future.result$finished <- base::Sys.time()
[17:46:44.748]     ...future.result
[17:46:44.748] }
[17:46:44.750] plan(): Setting new future strategy stack:
[17:46:44.750] List of future strategies:
[17:46:44.750] 1. sequential:
[17:46:44.750]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.750]    - tweaked: FALSE
[17:46:44.750]    - call: NULL
[17:46:44.750] plan(): nbrOfWorkers() = 1
[17:46:44.751] plan(): Setting new future strategy stack:
[17:46:44.751] List of future strategies:
[17:46:44.751] 1. sequential:
[17:46:44.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.751]    - tweaked: FALSE
[17:46:44.751]    - call: plan(strategy)
[17:46:44.752] plan(): nbrOfWorkers() = 1
[17:46:44.752] SequentialFuture started (and completed)
[17:46:44.752] - Launch lazy future ... done
[17:46:44.752] run() for ‘SequentialFuture’ ... done
[17:46:44.752] getGlobalsAndPackages() ...
[17:46:44.752] Searching for globals...
[17:46:44.753] - globals found: [1] ‘{’
[17:46:44.753] Searching for globals ... DONE
[17:46:44.753] Resolving globals: FALSE
[17:46:44.753] 
[17:46:44.753] 
[17:46:44.755] getGlobalsAndPackages() ... DONE
[17:46:44.755] run() for ‘Future’ ...
[17:46:44.756] - state: ‘created’
[17:46:44.756] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.756] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.756] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.756]   - Field: ‘label’
[17:46:44.756]   - Field: ‘local’
[17:46:44.756]   - Field: ‘owner’
[17:46:44.756]   - Field: ‘envir’
[17:46:44.756]   - Field: ‘packages’
[17:46:44.757]   - Field: ‘gc’
[17:46:44.757]   - Field: ‘conditions’
[17:46:44.757]   - Field: ‘expr’
[17:46:44.757]   - Field: ‘uuid’
[17:46:44.757]   - Field: ‘seed’
[17:46:44.757]   - Field: ‘version’
[17:46:44.757]   - Field: ‘result’
[17:46:44.757]   - Field: ‘asynchronous’
[17:46:44.757]   - Field: ‘calls’
[17:46:44.757]   - Field: ‘globals’
[17:46:44.757]   - Field: ‘stdout’
[17:46:44.758]   - Field: ‘earlySignal’
[17:46:44.758]   - Field: ‘lazy’
[17:46:44.758]   - Field: ‘state’
[17:46:44.758] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.758] - Launch lazy future ...
[17:46:44.758] Packages needed by the future expression (n = 0): <none>
[17:46:44.758] Packages needed by future strategies (n = 0): <none>
[17:46:44.759] {
[17:46:44.759]     {
[17:46:44.759]         {
[17:46:44.759]             ...future.startTime <- base::Sys.time()
[17:46:44.759]             {
[17:46:44.759]                 {
[17:46:44.759]                   {
[17:46:44.759]                     base::local({
[17:46:44.759]                       has_future <- base::requireNamespace("future", 
[17:46:44.759]                         quietly = TRUE)
[17:46:44.759]                       if (has_future) {
[17:46:44.759]                         ns <- base::getNamespace("future")
[17:46:44.759]                         version <- ns[[".package"]][["version"]]
[17:46:44.759]                         if (is.null(version)) 
[17:46:44.759]                           version <- utils::packageVersion("future")
[17:46:44.759]                       }
[17:46:44.759]                       else {
[17:46:44.759]                         version <- NULL
[17:46:44.759]                       }
[17:46:44.759]                       if (!has_future || version < "1.8.0") {
[17:46:44.759]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.759]                           "", base::R.version$version.string), 
[17:46:44.759]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.759]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.759]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.759]                             "release", "version")], collapse = " "), 
[17:46:44.759]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.759]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.759]                           info)
[17:46:44.759]                         info <- base::paste(info, collapse = "; ")
[17:46:44.759]                         if (!has_future) {
[17:46:44.759]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.759]                             info)
[17:46:44.759]                         }
[17:46:44.759]                         else {
[17:46:44.759]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.759]                             info, version)
[17:46:44.759]                         }
[17:46:44.759]                         base::stop(msg)
[17:46:44.759]                       }
[17:46:44.759]                     })
[17:46:44.759]                   }
[17:46:44.759]                   ...future.strategy.old <- future::plan("list")
[17:46:44.759]                   options(future.plan = NULL)
[17:46:44.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.759]                 }
[17:46:44.759]                 ...future.workdir <- getwd()
[17:46:44.759]             }
[17:46:44.759]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.759]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.759]         }
[17:46:44.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.759]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.759]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.759]             base::names(...future.oldOptions))
[17:46:44.759]     }
[17:46:44.759]     if (FALSE) {
[17:46:44.759]     }
[17:46:44.759]     else {
[17:46:44.759]         if (TRUE) {
[17:46:44.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.759]                 open = "w")
[17:46:44.759]         }
[17:46:44.759]         else {
[17:46:44.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.759]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.759]         }
[17:46:44.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.759]             base::sink(type = "output", split = FALSE)
[17:46:44.759]             base::close(...future.stdout)
[17:46:44.759]         }, add = TRUE)
[17:46:44.759]     }
[17:46:44.759]     ...future.frame <- base::sys.nframe()
[17:46:44.759]     ...future.conditions <- base::list()
[17:46:44.759]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.759]     if (FALSE) {
[17:46:44.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.759]     }
[17:46:44.759]     ...future.result <- base::tryCatch({
[17:46:44.759]         base::withCallingHandlers({
[17:46:44.759]             ...future.value <- base::withVisible(base::local({
[17:46:44.759]                 4
[17:46:44.759]             }))
[17:46:44.759]             future::FutureResult(value = ...future.value$value, 
[17:46:44.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.759]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.759]                     ...future.globalenv.names))
[17:46:44.759]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.759]         }, condition = base::local({
[17:46:44.759]             c <- base::c
[17:46:44.759]             inherits <- base::inherits
[17:46:44.759]             invokeRestart <- base::invokeRestart
[17:46:44.759]             length <- base::length
[17:46:44.759]             list <- base::list
[17:46:44.759]             seq.int <- base::seq.int
[17:46:44.759]             signalCondition <- base::signalCondition
[17:46:44.759]             sys.calls <- base::sys.calls
[17:46:44.759]             `[[` <- base::`[[`
[17:46:44.759]             `+` <- base::`+`
[17:46:44.759]             `<<-` <- base::`<<-`
[17:46:44.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.759]                   3L)]
[17:46:44.759]             }
[17:46:44.759]             function(cond) {
[17:46:44.759]                 is_error <- inherits(cond, "error")
[17:46:44.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.759]                   NULL)
[17:46:44.759]                 if (is_error) {
[17:46:44.759]                   sessionInformation <- function() {
[17:46:44.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.759]                       search = base::search(), system = base::Sys.info())
[17:46:44.759]                   }
[17:46:44.759]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.759]                     cond$call), session = sessionInformation(), 
[17:46:44.759]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.759]                   signalCondition(cond)
[17:46:44.759]                 }
[17:46:44.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.759]                 "immediateCondition"))) {
[17:46:44.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.759]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.759]                   if (TRUE && !signal) {
[17:46:44.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.759]                     {
[17:46:44.759]                       inherits <- base::inherits
[17:46:44.759]                       invokeRestart <- base::invokeRestart
[17:46:44.759]                       is.null <- base::is.null
[17:46:44.759]                       muffled <- FALSE
[17:46:44.759]                       if (inherits(cond, "message")) {
[17:46:44.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.759]                         if (muffled) 
[17:46:44.759]                           invokeRestart("muffleMessage")
[17:46:44.759]                       }
[17:46:44.759]                       else if (inherits(cond, "warning")) {
[17:46:44.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.759]                         if (muffled) 
[17:46:44.759]                           invokeRestart("muffleWarning")
[17:46:44.759]                       }
[17:46:44.759]                       else if (inherits(cond, "condition")) {
[17:46:44.759]                         if (!is.null(pattern)) {
[17:46:44.759]                           computeRestarts <- base::computeRestarts
[17:46:44.759]                           grepl <- base::grepl
[17:46:44.759]                           restarts <- computeRestarts(cond)
[17:46:44.759]                           for (restart in restarts) {
[17:46:44.759]                             name <- restart$name
[17:46:44.759]                             if (is.null(name)) 
[17:46:44.759]                               next
[17:46:44.759]                             if (!grepl(pattern, name)) 
[17:46:44.759]                               next
[17:46:44.759]                             invokeRestart(restart)
[17:46:44.759]                             muffled <- TRUE
[17:46:44.759]                             break
[17:46:44.759]                           }
[17:46:44.759]                         }
[17:46:44.759]                       }
[17:46:44.759]                       invisible(muffled)
[17:46:44.759]                     }
[17:46:44.759]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.759]                   }
[17:46:44.759]                 }
[17:46:44.759]                 else {
[17:46:44.759]                   if (TRUE) {
[17:46:44.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.759]                     {
[17:46:44.759]                       inherits <- base::inherits
[17:46:44.759]                       invokeRestart <- base::invokeRestart
[17:46:44.759]                       is.null <- base::is.null
[17:46:44.759]                       muffled <- FALSE
[17:46:44.759]                       if (inherits(cond, "message")) {
[17:46:44.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.759]                         if (muffled) 
[17:46:44.759]                           invokeRestart("muffleMessage")
[17:46:44.759]                       }
[17:46:44.759]                       else if (inherits(cond, "warning")) {
[17:46:44.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.759]                         if (muffled) 
[17:46:44.759]                           invokeRestart("muffleWarning")
[17:46:44.759]                       }
[17:46:44.759]                       else if (inherits(cond, "condition")) {
[17:46:44.759]                         if (!is.null(pattern)) {
[17:46:44.759]                           computeRestarts <- base::computeRestarts
[17:46:44.759]                           grepl <- base::grepl
[17:46:44.759]                           restarts <- computeRestarts(cond)
[17:46:44.759]                           for (restart in restarts) {
[17:46:44.759]                             name <- restart$name
[17:46:44.759]                             if (is.null(name)) 
[17:46:44.759]                               next
[17:46:44.759]                             if (!grepl(pattern, name)) 
[17:46:44.759]                               next
[17:46:44.759]                             invokeRestart(restart)
[17:46:44.759]                             muffled <- TRUE
[17:46:44.759]                             break
[17:46:44.759]                           }
[17:46:44.759]                         }
[17:46:44.759]                       }
[17:46:44.759]                       invisible(muffled)
[17:46:44.759]                     }
[17:46:44.759]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.759]                   }
[17:46:44.759]                 }
[17:46:44.759]             }
[17:46:44.759]         }))
[17:46:44.759]     }, error = function(ex) {
[17:46:44.759]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.759]                 ...future.rng), started = ...future.startTime, 
[17:46:44.759]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.759]             version = "1.8"), class = "FutureResult")
[17:46:44.759]     }, finally = {
[17:46:44.759]         if (!identical(...future.workdir, getwd())) 
[17:46:44.759]             setwd(...future.workdir)
[17:46:44.759]         {
[17:46:44.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.759]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.759]             }
[17:46:44.759]             base::options(...future.oldOptions)
[17:46:44.759]             if (.Platform$OS.type == "windows") {
[17:46:44.759]                 old_names <- names(...future.oldEnvVars)
[17:46:44.759]                 envs <- base::Sys.getenv()
[17:46:44.759]                 names <- names(envs)
[17:46:44.759]                 common <- intersect(names, old_names)
[17:46:44.759]                 added <- setdiff(names, old_names)
[17:46:44.759]                 removed <- setdiff(old_names, names)
[17:46:44.759]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.759]                   envs[common]]
[17:46:44.759]                 NAMES <- toupper(changed)
[17:46:44.759]                 args <- list()
[17:46:44.759]                 for (kk in seq_along(NAMES)) {
[17:46:44.759]                   name <- changed[[kk]]
[17:46:44.759]                   NAME <- NAMES[[kk]]
[17:46:44.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.759]                     next
[17:46:44.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.759]                 }
[17:46:44.759]                 NAMES <- toupper(added)
[17:46:44.759]                 for (kk in seq_along(NAMES)) {
[17:46:44.759]                   name <- added[[kk]]
[17:46:44.759]                   NAME <- NAMES[[kk]]
[17:46:44.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.759]                     next
[17:46:44.759]                   args[[name]] <- ""
[17:46:44.759]                 }
[17:46:44.759]                 NAMES <- toupper(removed)
[17:46:44.759]                 for (kk in seq_along(NAMES)) {
[17:46:44.759]                   name <- removed[[kk]]
[17:46:44.759]                   NAME <- NAMES[[kk]]
[17:46:44.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.759]                     next
[17:46:44.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.759]                 }
[17:46:44.759]                 if (length(args) > 0) 
[17:46:44.759]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.759]             }
[17:46:44.759]             else {
[17:46:44.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.759]             }
[17:46:44.759]             {
[17:46:44.759]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.759]                   0L) {
[17:46:44.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.759]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.759]                   base::options(opts)
[17:46:44.759]                 }
[17:46:44.759]                 {
[17:46:44.759]                   {
[17:46:44.759]                     NULL
[17:46:44.759]                     RNGkind("Mersenne-Twister")
[17:46:44.759]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.759]                       inherits = FALSE)
[17:46:44.759]                   }
[17:46:44.759]                   options(future.plan = NULL)
[17:46:44.759]                   if (is.na(NA_character_)) 
[17:46:44.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.759]                     .init = FALSE)
[17:46:44.759]                 }
[17:46:44.759]             }
[17:46:44.759]         }
[17:46:44.759]     })
[17:46:44.759]     if (TRUE) {
[17:46:44.759]         base::sink(type = "output", split = FALSE)
[17:46:44.759]         if (TRUE) {
[17:46:44.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.759]         }
[17:46:44.759]         else {
[17:46:44.759]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.759]         }
[17:46:44.759]         base::close(...future.stdout)
[17:46:44.759]         ...future.stdout <- NULL
[17:46:44.759]     }
[17:46:44.759]     ...future.result$conditions <- ...future.conditions
[17:46:44.759]     ...future.result$finished <- base::Sys.time()
[17:46:44.759]     ...future.result
[17:46:44.759] }
[17:46:44.760] plan(): Setting new future strategy stack:
[17:46:44.760] List of future strategies:
[17:46:44.760] 1. sequential:
[17:46:44.760]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.760]    - tweaked: FALSE
[17:46:44.760]    - call: NULL
[17:46:44.761] plan(): nbrOfWorkers() = 1
[17:46:44.761] plan(): Setting new future strategy stack:
[17:46:44.762] List of future strategies:
[17:46:44.762] 1. sequential:
[17:46:44.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.762]    - tweaked: FALSE
[17:46:44.762]    - call: plan(strategy)
[17:46:44.762] plan(): nbrOfWorkers() = 1
[17:46:44.762] SequentialFuture started (and completed)
[17:46:44.762] - Launch lazy future ... done
[17:46:44.762] run() for ‘SequentialFuture’ ... done
<environment: 0x561787589008> 
<environment: 0x561785bcf508> 
[17:46:44.764] resolved() for ‘SequentialFuture’ ...
[17:46:44.764] - state: ‘finished’
[17:46:44.764] - run: TRUE
[17:46:44.764] - result: ‘FutureResult’
[17:46:44.764] resolved() for ‘SequentialFuture’ ... done
[17:46:44.764] resolved() for ‘SequentialFuture’ ...
[17:46:44.764] - state: ‘finished’
[17:46:44.764] - run: TRUE
[17:46:44.764] - result: ‘FutureResult’
[17:46:44.764] resolved() for ‘SequentialFuture’ ... done
[17:46:44.765] resolved() for ‘SequentialFuture’ ...
[17:46:44.765] - state: ‘finished’
[17:46:44.765] - run: TRUE
[17:46:44.765] - result: ‘FutureResult’
[17:46:44.765] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:44.766] resolve() on environment ...
[17:46:44.766]  recursive: 0
[17:46:44.767]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:44.767] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.767] - nx: 4
[17:46:44.767] - relay: TRUE
[17:46:44.767] - stdout: TRUE
[17:46:44.767] - signal: TRUE
[17:46:44.767] - resignal: FALSE
[17:46:44.767] - force: TRUE
[17:46:44.767] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.767] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.767]  - until=2
[17:46:44.768]  - relaying element #2
[17:46:44.768] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.768] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.768] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.768]  length: 3 (resolved future 1)
[17:46:44.768] resolved() for ‘SequentialFuture’ ...
[17:46:44.768] - state: ‘finished’
[17:46:44.768] - run: TRUE
[17:46:44.768] - result: ‘FutureResult’
[17:46:44.768] resolved() for ‘SequentialFuture’ ... done
[17:46:44.768] Future #2
[17:46:44.769] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.769] - nx: 4
[17:46:44.769] - relay: TRUE
[17:46:44.769] - stdout: TRUE
[17:46:44.769] - signal: TRUE
[17:46:44.769] - resignal: FALSE
[17:46:44.769] - force: TRUE
[17:46:44.769] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.769] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.769]  - until=2
[17:46:44.769]  - relaying element #2
[17:46:44.770] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.770] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.770] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.770]  length: 2 (resolved future 2)
[17:46:44.770] resolved() for ‘SequentialFuture’ ...
[17:46:44.770] - state: ‘finished’
[17:46:44.770] - run: TRUE
[17:46:44.770] - result: ‘FutureResult’
[17:46:44.770] resolved() for ‘SequentialFuture’ ... done
[17:46:44.770] Future #3
[17:46:44.771] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.771] - nx: 4
[17:46:44.771] - relay: TRUE
[17:46:44.771] - stdout: TRUE
[17:46:44.771] - signal: TRUE
[17:46:44.771] - resignal: FALSE
[17:46:44.771] - force: TRUE
[17:46:44.771] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.771] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.771]  - until=3
[17:46:44.771]  - relaying element #3
[17:46:44.772] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.772] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.772] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.772]  length: 1 (resolved future 3)
[17:46:44.772] resolved() for ‘SequentialFuture’ ...
[17:46:44.772] - state: ‘finished’
[17:46:44.772] - run: TRUE
[17:46:44.772] - result: ‘FutureResult’
[17:46:44.772] resolved() for ‘SequentialFuture’ ... done
[17:46:44.772] Future #4
[17:46:44.773] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:44.773] - nx: 4
[17:46:44.773] - relay: TRUE
[17:46:44.773] - stdout: TRUE
[17:46:44.773] - signal: TRUE
[17:46:44.773] - resignal: FALSE
[17:46:44.773] - force: TRUE
[17:46:44.773] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.773] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.773]  - until=4
[17:46:44.773]  - relaying element #4
[17:46:44.774] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.774] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.774] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:44.774]  length: 0 (resolved future 4)
[17:46:44.774] Relaying remaining futures
[17:46:44.774] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.774] - nx: 4
[17:46:44.774] - relay: TRUE
[17:46:44.774] - stdout: TRUE
[17:46:44.774] - signal: TRUE
[17:46:44.774] - resignal: FALSE
[17:46:44.775] - force: TRUE
[17:46:44.775] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.775] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:44.775] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.775] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.775] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.775] resolve() on environment ... DONE
<environment: 0x56178750e6a0> 
Dimensions: c(2, 3, 1)
[17:46:44.776] getGlobalsAndPackages() ...
[17:46:44.776] Searching for globals...
[17:46:44.776] 
[17:46:44.776] Searching for globals ... DONE
[17:46:44.776] - globals: [0] <none>
[17:46:44.776] getGlobalsAndPackages() ... DONE
[17:46:44.777] run() for ‘Future’ ...
[17:46:44.777] - state: ‘created’
[17:46:44.777] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.777] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.777]   - Field: ‘label’
[17:46:44.777]   - Field: ‘local’
[17:46:44.777]   - Field: ‘owner’
[17:46:44.777]   - Field: ‘envir’
[17:46:44.778]   - Field: ‘packages’
[17:46:44.778]   - Field: ‘gc’
[17:46:44.778]   - Field: ‘conditions’
[17:46:44.778]   - Field: ‘expr’
[17:46:44.778]   - Field: ‘uuid’
[17:46:44.778]   - Field: ‘seed’
[17:46:44.778]   - Field: ‘version’
[17:46:44.778]   - Field: ‘result’
[17:46:44.778]   - Field: ‘asynchronous’
[17:46:44.778]   - Field: ‘calls’
[17:46:44.778]   - Field: ‘globals’
[17:46:44.779]   - Field: ‘stdout’
[17:46:44.779]   - Field: ‘earlySignal’
[17:46:44.779]   - Field: ‘lazy’
[17:46:44.779]   - Field: ‘state’
[17:46:44.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.779] - Launch lazy future ...
[17:46:44.779] Packages needed by the future expression (n = 0): <none>
[17:46:44.779] Packages needed by future strategies (n = 0): <none>
[17:46:44.780] {
[17:46:44.780]     {
[17:46:44.780]         {
[17:46:44.780]             ...future.startTime <- base::Sys.time()
[17:46:44.780]             {
[17:46:44.780]                 {
[17:46:44.780]                   {
[17:46:44.780]                     base::local({
[17:46:44.780]                       has_future <- base::requireNamespace("future", 
[17:46:44.780]                         quietly = TRUE)
[17:46:44.780]                       if (has_future) {
[17:46:44.780]                         ns <- base::getNamespace("future")
[17:46:44.780]                         version <- ns[[".package"]][["version"]]
[17:46:44.780]                         if (is.null(version)) 
[17:46:44.780]                           version <- utils::packageVersion("future")
[17:46:44.780]                       }
[17:46:44.780]                       else {
[17:46:44.780]                         version <- NULL
[17:46:44.780]                       }
[17:46:44.780]                       if (!has_future || version < "1.8.0") {
[17:46:44.780]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.780]                           "", base::R.version$version.string), 
[17:46:44.780]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.780]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.780]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.780]                             "release", "version")], collapse = " "), 
[17:46:44.780]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.780]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.780]                           info)
[17:46:44.780]                         info <- base::paste(info, collapse = "; ")
[17:46:44.780]                         if (!has_future) {
[17:46:44.780]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.780]                             info)
[17:46:44.780]                         }
[17:46:44.780]                         else {
[17:46:44.780]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.780]                             info, version)
[17:46:44.780]                         }
[17:46:44.780]                         base::stop(msg)
[17:46:44.780]                       }
[17:46:44.780]                     })
[17:46:44.780]                   }
[17:46:44.780]                   ...future.strategy.old <- future::plan("list")
[17:46:44.780]                   options(future.plan = NULL)
[17:46:44.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.780]                 }
[17:46:44.780]                 ...future.workdir <- getwd()
[17:46:44.780]             }
[17:46:44.780]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.780]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.780]         }
[17:46:44.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.780]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.780]             base::names(...future.oldOptions))
[17:46:44.780]     }
[17:46:44.780]     if (FALSE) {
[17:46:44.780]     }
[17:46:44.780]     else {
[17:46:44.780]         if (TRUE) {
[17:46:44.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.780]                 open = "w")
[17:46:44.780]         }
[17:46:44.780]         else {
[17:46:44.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.780]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.780]         }
[17:46:44.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.780]             base::sink(type = "output", split = FALSE)
[17:46:44.780]             base::close(...future.stdout)
[17:46:44.780]         }, add = TRUE)
[17:46:44.780]     }
[17:46:44.780]     ...future.frame <- base::sys.nframe()
[17:46:44.780]     ...future.conditions <- base::list()
[17:46:44.780]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.780]     if (FALSE) {
[17:46:44.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.780]     }
[17:46:44.780]     ...future.result <- base::tryCatch({
[17:46:44.780]         base::withCallingHandlers({
[17:46:44.780]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.780]             future::FutureResult(value = ...future.value$value, 
[17:46:44.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.780]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.780]                     ...future.globalenv.names))
[17:46:44.780]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.780]         }, condition = base::local({
[17:46:44.780]             c <- base::c
[17:46:44.780]             inherits <- base::inherits
[17:46:44.780]             invokeRestart <- base::invokeRestart
[17:46:44.780]             length <- base::length
[17:46:44.780]             list <- base::list
[17:46:44.780]             seq.int <- base::seq.int
[17:46:44.780]             signalCondition <- base::signalCondition
[17:46:44.780]             sys.calls <- base::sys.calls
[17:46:44.780]             `[[` <- base::`[[`
[17:46:44.780]             `+` <- base::`+`
[17:46:44.780]             `<<-` <- base::`<<-`
[17:46:44.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.780]                   3L)]
[17:46:44.780]             }
[17:46:44.780]             function(cond) {
[17:46:44.780]                 is_error <- inherits(cond, "error")
[17:46:44.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.780]                   NULL)
[17:46:44.780]                 if (is_error) {
[17:46:44.780]                   sessionInformation <- function() {
[17:46:44.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.780]                       search = base::search(), system = base::Sys.info())
[17:46:44.780]                   }
[17:46:44.780]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.780]                     cond$call), session = sessionInformation(), 
[17:46:44.780]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.780]                   signalCondition(cond)
[17:46:44.780]                 }
[17:46:44.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.780]                 "immediateCondition"))) {
[17:46:44.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.780]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.780]                   if (TRUE && !signal) {
[17:46:44.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.780]                     {
[17:46:44.780]                       inherits <- base::inherits
[17:46:44.780]                       invokeRestart <- base::invokeRestart
[17:46:44.780]                       is.null <- base::is.null
[17:46:44.780]                       muffled <- FALSE
[17:46:44.780]                       if (inherits(cond, "message")) {
[17:46:44.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.780]                         if (muffled) 
[17:46:44.780]                           invokeRestart("muffleMessage")
[17:46:44.780]                       }
[17:46:44.780]                       else if (inherits(cond, "warning")) {
[17:46:44.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.780]                         if (muffled) 
[17:46:44.780]                           invokeRestart("muffleWarning")
[17:46:44.780]                       }
[17:46:44.780]                       else if (inherits(cond, "condition")) {
[17:46:44.780]                         if (!is.null(pattern)) {
[17:46:44.780]                           computeRestarts <- base::computeRestarts
[17:46:44.780]                           grepl <- base::grepl
[17:46:44.780]                           restarts <- computeRestarts(cond)
[17:46:44.780]                           for (restart in restarts) {
[17:46:44.780]                             name <- restart$name
[17:46:44.780]                             if (is.null(name)) 
[17:46:44.780]                               next
[17:46:44.780]                             if (!grepl(pattern, name)) 
[17:46:44.780]                               next
[17:46:44.780]                             invokeRestart(restart)
[17:46:44.780]                             muffled <- TRUE
[17:46:44.780]                             break
[17:46:44.780]                           }
[17:46:44.780]                         }
[17:46:44.780]                       }
[17:46:44.780]                       invisible(muffled)
[17:46:44.780]                     }
[17:46:44.780]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.780]                   }
[17:46:44.780]                 }
[17:46:44.780]                 else {
[17:46:44.780]                   if (TRUE) {
[17:46:44.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.780]                     {
[17:46:44.780]                       inherits <- base::inherits
[17:46:44.780]                       invokeRestart <- base::invokeRestart
[17:46:44.780]                       is.null <- base::is.null
[17:46:44.780]                       muffled <- FALSE
[17:46:44.780]                       if (inherits(cond, "message")) {
[17:46:44.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.780]                         if (muffled) 
[17:46:44.780]                           invokeRestart("muffleMessage")
[17:46:44.780]                       }
[17:46:44.780]                       else if (inherits(cond, "warning")) {
[17:46:44.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.780]                         if (muffled) 
[17:46:44.780]                           invokeRestart("muffleWarning")
[17:46:44.780]                       }
[17:46:44.780]                       else if (inherits(cond, "condition")) {
[17:46:44.780]                         if (!is.null(pattern)) {
[17:46:44.780]                           computeRestarts <- base::computeRestarts
[17:46:44.780]                           grepl <- base::grepl
[17:46:44.780]                           restarts <- computeRestarts(cond)
[17:46:44.780]                           for (restart in restarts) {
[17:46:44.780]                             name <- restart$name
[17:46:44.780]                             if (is.null(name)) 
[17:46:44.780]                               next
[17:46:44.780]                             if (!grepl(pattern, name)) 
[17:46:44.780]                               next
[17:46:44.780]                             invokeRestart(restart)
[17:46:44.780]                             muffled <- TRUE
[17:46:44.780]                             break
[17:46:44.780]                           }
[17:46:44.780]                         }
[17:46:44.780]                       }
[17:46:44.780]                       invisible(muffled)
[17:46:44.780]                     }
[17:46:44.780]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.780]                   }
[17:46:44.780]                 }
[17:46:44.780]             }
[17:46:44.780]         }))
[17:46:44.780]     }, error = function(ex) {
[17:46:44.780]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.780]                 ...future.rng), started = ...future.startTime, 
[17:46:44.780]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.780]             version = "1.8"), class = "FutureResult")
[17:46:44.780]     }, finally = {
[17:46:44.780]         if (!identical(...future.workdir, getwd())) 
[17:46:44.780]             setwd(...future.workdir)
[17:46:44.780]         {
[17:46:44.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.780]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.780]             }
[17:46:44.780]             base::options(...future.oldOptions)
[17:46:44.780]             if (.Platform$OS.type == "windows") {
[17:46:44.780]                 old_names <- names(...future.oldEnvVars)
[17:46:44.780]                 envs <- base::Sys.getenv()
[17:46:44.780]                 names <- names(envs)
[17:46:44.780]                 common <- intersect(names, old_names)
[17:46:44.780]                 added <- setdiff(names, old_names)
[17:46:44.780]                 removed <- setdiff(old_names, names)
[17:46:44.780]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.780]                   envs[common]]
[17:46:44.780]                 NAMES <- toupper(changed)
[17:46:44.780]                 args <- list()
[17:46:44.780]                 for (kk in seq_along(NAMES)) {
[17:46:44.780]                   name <- changed[[kk]]
[17:46:44.780]                   NAME <- NAMES[[kk]]
[17:46:44.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.780]                     next
[17:46:44.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.780]                 }
[17:46:44.780]                 NAMES <- toupper(added)
[17:46:44.780]                 for (kk in seq_along(NAMES)) {
[17:46:44.780]                   name <- added[[kk]]
[17:46:44.780]                   NAME <- NAMES[[kk]]
[17:46:44.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.780]                     next
[17:46:44.780]                   args[[name]] <- ""
[17:46:44.780]                 }
[17:46:44.780]                 NAMES <- toupper(removed)
[17:46:44.780]                 for (kk in seq_along(NAMES)) {
[17:46:44.780]                   name <- removed[[kk]]
[17:46:44.780]                   NAME <- NAMES[[kk]]
[17:46:44.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.780]                     next
[17:46:44.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.780]                 }
[17:46:44.780]                 if (length(args) > 0) 
[17:46:44.780]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.780]             }
[17:46:44.780]             else {
[17:46:44.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.780]             }
[17:46:44.780]             {
[17:46:44.780]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.780]                   0L) {
[17:46:44.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.780]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.780]                   base::options(opts)
[17:46:44.780]                 }
[17:46:44.780]                 {
[17:46:44.780]                   {
[17:46:44.780]                     NULL
[17:46:44.780]                     RNGkind("Mersenne-Twister")
[17:46:44.780]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.780]                       inherits = FALSE)
[17:46:44.780]                   }
[17:46:44.780]                   options(future.plan = NULL)
[17:46:44.780]                   if (is.na(NA_character_)) 
[17:46:44.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.780]                     .init = FALSE)
[17:46:44.780]                 }
[17:46:44.780]             }
[17:46:44.780]         }
[17:46:44.780]     })
[17:46:44.780]     if (TRUE) {
[17:46:44.780]         base::sink(type = "output", split = FALSE)
[17:46:44.780]         if (TRUE) {
[17:46:44.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.780]         }
[17:46:44.780]         else {
[17:46:44.780]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.780]         }
[17:46:44.780]         base::close(...future.stdout)
[17:46:44.780]         ...future.stdout <- NULL
[17:46:44.780]     }
[17:46:44.780]     ...future.result$conditions <- ...future.conditions
[17:46:44.780]     ...future.result$finished <- base::Sys.time()
[17:46:44.780]     ...future.result
[17:46:44.780] }
[17:46:44.781] plan(): Setting new future strategy stack:
[17:46:44.782] List of future strategies:
[17:46:44.782] 1. sequential:
[17:46:44.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.782]    - tweaked: FALSE
[17:46:44.782]    - call: NULL
[17:46:44.784] plan(): nbrOfWorkers() = 1
[17:46:44.785] plan(): Setting new future strategy stack:
[17:46:44.785] List of future strategies:
[17:46:44.785] 1. sequential:
[17:46:44.785]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.785]    - tweaked: FALSE
[17:46:44.785]    - call: plan(strategy)
[17:46:44.785] plan(): nbrOfWorkers() = 1
[17:46:44.785] SequentialFuture started (and completed)
[17:46:44.786] - Launch lazy future ... done
[17:46:44.786] run() for ‘SequentialFuture’ ... done
[17:46:44.786] getGlobalsAndPackages() ...
[17:46:44.786] Searching for globals...
[17:46:44.786] 
[17:46:44.786] Searching for globals ... DONE
[17:46:44.786] - globals: [0] <none>
[17:46:44.786] getGlobalsAndPackages() ... DONE
[17:46:44.787] run() for ‘Future’ ...
[17:46:44.787] - state: ‘created’
[17:46:44.787] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.787] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.787]   - Field: ‘label’
[17:46:44.788]   - Field: ‘local’
[17:46:44.788]   - Field: ‘owner’
[17:46:44.788]   - Field: ‘envir’
[17:46:44.788]   - Field: ‘packages’
[17:46:44.788]   - Field: ‘gc’
[17:46:44.788]   - Field: ‘conditions’
[17:46:44.788]   - Field: ‘expr’
[17:46:44.788]   - Field: ‘uuid’
[17:46:44.788]   - Field: ‘seed’
[17:46:44.788]   - Field: ‘version’
[17:46:44.788]   - Field: ‘result’
[17:46:44.788]   - Field: ‘asynchronous’
[17:46:44.789]   - Field: ‘calls’
[17:46:44.789]   - Field: ‘globals’
[17:46:44.789]   - Field: ‘stdout’
[17:46:44.789]   - Field: ‘earlySignal’
[17:46:44.789]   - Field: ‘lazy’
[17:46:44.789]   - Field: ‘state’
[17:46:44.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.789] - Launch lazy future ...
[17:46:44.789] Packages needed by the future expression (n = 0): <none>
[17:46:44.789] Packages needed by future strategies (n = 0): <none>
[17:46:44.790] {
[17:46:44.790]     {
[17:46:44.790]         {
[17:46:44.790]             ...future.startTime <- base::Sys.time()
[17:46:44.790]             {
[17:46:44.790]                 {
[17:46:44.790]                   {
[17:46:44.790]                     base::local({
[17:46:44.790]                       has_future <- base::requireNamespace("future", 
[17:46:44.790]                         quietly = TRUE)
[17:46:44.790]                       if (has_future) {
[17:46:44.790]                         ns <- base::getNamespace("future")
[17:46:44.790]                         version <- ns[[".package"]][["version"]]
[17:46:44.790]                         if (is.null(version)) 
[17:46:44.790]                           version <- utils::packageVersion("future")
[17:46:44.790]                       }
[17:46:44.790]                       else {
[17:46:44.790]                         version <- NULL
[17:46:44.790]                       }
[17:46:44.790]                       if (!has_future || version < "1.8.0") {
[17:46:44.790]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.790]                           "", base::R.version$version.string), 
[17:46:44.790]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.790]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.790]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.790]                             "release", "version")], collapse = " "), 
[17:46:44.790]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.790]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.790]                           info)
[17:46:44.790]                         info <- base::paste(info, collapse = "; ")
[17:46:44.790]                         if (!has_future) {
[17:46:44.790]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.790]                             info)
[17:46:44.790]                         }
[17:46:44.790]                         else {
[17:46:44.790]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.790]                             info, version)
[17:46:44.790]                         }
[17:46:44.790]                         base::stop(msg)
[17:46:44.790]                       }
[17:46:44.790]                     })
[17:46:44.790]                   }
[17:46:44.790]                   ...future.strategy.old <- future::plan("list")
[17:46:44.790]                   options(future.plan = NULL)
[17:46:44.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.790]                 }
[17:46:44.790]                 ...future.workdir <- getwd()
[17:46:44.790]             }
[17:46:44.790]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.790]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.790]         }
[17:46:44.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.790]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.790]             base::names(...future.oldOptions))
[17:46:44.790]     }
[17:46:44.790]     if (FALSE) {
[17:46:44.790]     }
[17:46:44.790]     else {
[17:46:44.790]         if (TRUE) {
[17:46:44.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.790]                 open = "w")
[17:46:44.790]         }
[17:46:44.790]         else {
[17:46:44.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.790]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.790]         }
[17:46:44.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.790]             base::sink(type = "output", split = FALSE)
[17:46:44.790]             base::close(...future.stdout)
[17:46:44.790]         }, add = TRUE)
[17:46:44.790]     }
[17:46:44.790]     ...future.frame <- base::sys.nframe()
[17:46:44.790]     ...future.conditions <- base::list()
[17:46:44.790]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.790]     if (FALSE) {
[17:46:44.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.790]     }
[17:46:44.790]     ...future.result <- base::tryCatch({
[17:46:44.790]         base::withCallingHandlers({
[17:46:44.790]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.790]             future::FutureResult(value = ...future.value$value, 
[17:46:44.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.790]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.790]                     ...future.globalenv.names))
[17:46:44.790]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.790]         }, condition = base::local({
[17:46:44.790]             c <- base::c
[17:46:44.790]             inherits <- base::inherits
[17:46:44.790]             invokeRestart <- base::invokeRestart
[17:46:44.790]             length <- base::length
[17:46:44.790]             list <- base::list
[17:46:44.790]             seq.int <- base::seq.int
[17:46:44.790]             signalCondition <- base::signalCondition
[17:46:44.790]             sys.calls <- base::sys.calls
[17:46:44.790]             `[[` <- base::`[[`
[17:46:44.790]             `+` <- base::`+`
[17:46:44.790]             `<<-` <- base::`<<-`
[17:46:44.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.790]                   3L)]
[17:46:44.790]             }
[17:46:44.790]             function(cond) {
[17:46:44.790]                 is_error <- inherits(cond, "error")
[17:46:44.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.790]                   NULL)
[17:46:44.790]                 if (is_error) {
[17:46:44.790]                   sessionInformation <- function() {
[17:46:44.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.790]                       search = base::search(), system = base::Sys.info())
[17:46:44.790]                   }
[17:46:44.790]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.790]                     cond$call), session = sessionInformation(), 
[17:46:44.790]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.790]                   signalCondition(cond)
[17:46:44.790]                 }
[17:46:44.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.790]                 "immediateCondition"))) {
[17:46:44.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.790]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.790]                   if (TRUE && !signal) {
[17:46:44.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.790]                     {
[17:46:44.790]                       inherits <- base::inherits
[17:46:44.790]                       invokeRestart <- base::invokeRestart
[17:46:44.790]                       is.null <- base::is.null
[17:46:44.790]                       muffled <- FALSE
[17:46:44.790]                       if (inherits(cond, "message")) {
[17:46:44.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.790]                         if (muffled) 
[17:46:44.790]                           invokeRestart("muffleMessage")
[17:46:44.790]                       }
[17:46:44.790]                       else if (inherits(cond, "warning")) {
[17:46:44.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.790]                         if (muffled) 
[17:46:44.790]                           invokeRestart("muffleWarning")
[17:46:44.790]                       }
[17:46:44.790]                       else if (inherits(cond, "condition")) {
[17:46:44.790]                         if (!is.null(pattern)) {
[17:46:44.790]                           computeRestarts <- base::computeRestarts
[17:46:44.790]                           grepl <- base::grepl
[17:46:44.790]                           restarts <- computeRestarts(cond)
[17:46:44.790]                           for (restart in restarts) {
[17:46:44.790]                             name <- restart$name
[17:46:44.790]                             if (is.null(name)) 
[17:46:44.790]                               next
[17:46:44.790]                             if (!grepl(pattern, name)) 
[17:46:44.790]                               next
[17:46:44.790]                             invokeRestart(restart)
[17:46:44.790]                             muffled <- TRUE
[17:46:44.790]                             break
[17:46:44.790]                           }
[17:46:44.790]                         }
[17:46:44.790]                       }
[17:46:44.790]                       invisible(muffled)
[17:46:44.790]                     }
[17:46:44.790]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.790]                   }
[17:46:44.790]                 }
[17:46:44.790]                 else {
[17:46:44.790]                   if (TRUE) {
[17:46:44.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.790]                     {
[17:46:44.790]                       inherits <- base::inherits
[17:46:44.790]                       invokeRestart <- base::invokeRestart
[17:46:44.790]                       is.null <- base::is.null
[17:46:44.790]                       muffled <- FALSE
[17:46:44.790]                       if (inherits(cond, "message")) {
[17:46:44.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.790]                         if (muffled) 
[17:46:44.790]                           invokeRestart("muffleMessage")
[17:46:44.790]                       }
[17:46:44.790]                       else if (inherits(cond, "warning")) {
[17:46:44.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.790]                         if (muffled) 
[17:46:44.790]                           invokeRestart("muffleWarning")
[17:46:44.790]                       }
[17:46:44.790]                       else if (inherits(cond, "condition")) {
[17:46:44.790]                         if (!is.null(pattern)) {
[17:46:44.790]                           computeRestarts <- base::computeRestarts
[17:46:44.790]                           grepl <- base::grepl
[17:46:44.790]                           restarts <- computeRestarts(cond)
[17:46:44.790]                           for (restart in restarts) {
[17:46:44.790]                             name <- restart$name
[17:46:44.790]                             if (is.null(name)) 
[17:46:44.790]                               next
[17:46:44.790]                             if (!grepl(pattern, name)) 
[17:46:44.790]                               next
[17:46:44.790]                             invokeRestart(restart)
[17:46:44.790]                             muffled <- TRUE
[17:46:44.790]                             break
[17:46:44.790]                           }
[17:46:44.790]                         }
[17:46:44.790]                       }
[17:46:44.790]                       invisible(muffled)
[17:46:44.790]                     }
[17:46:44.790]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.790]                   }
[17:46:44.790]                 }
[17:46:44.790]             }
[17:46:44.790]         }))
[17:46:44.790]     }, error = function(ex) {
[17:46:44.790]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.790]                 ...future.rng), started = ...future.startTime, 
[17:46:44.790]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.790]             version = "1.8"), class = "FutureResult")
[17:46:44.790]     }, finally = {
[17:46:44.790]         if (!identical(...future.workdir, getwd())) 
[17:46:44.790]             setwd(...future.workdir)
[17:46:44.790]         {
[17:46:44.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.790]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.790]             }
[17:46:44.790]             base::options(...future.oldOptions)
[17:46:44.790]             if (.Platform$OS.type == "windows") {
[17:46:44.790]                 old_names <- names(...future.oldEnvVars)
[17:46:44.790]                 envs <- base::Sys.getenv()
[17:46:44.790]                 names <- names(envs)
[17:46:44.790]                 common <- intersect(names, old_names)
[17:46:44.790]                 added <- setdiff(names, old_names)
[17:46:44.790]                 removed <- setdiff(old_names, names)
[17:46:44.790]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.790]                   envs[common]]
[17:46:44.790]                 NAMES <- toupper(changed)
[17:46:44.790]                 args <- list()
[17:46:44.790]                 for (kk in seq_along(NAMES)) {
[17:46:44.790]                   name <- changed[[kk]]
[17:46:44.790]                   NAME <- NAMES[[kk]]
[17:46:44.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.790]                     next
[17:46:44.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.790]                 }
[17:46:44.790]                 NAMES <- toupper(added)
[17:46:44.790]                 for (kk in seq_along(NAMES)) {
[17:46:44.790]                   name <- added[[kk]]
[17:46:44.790]                   NAME <- NAMES[[kk]]
[17:46:44.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.790]                     next
[17:46:44.790]                   args[[name]] <- ""
[17:46:44.790]                 }
[17:46:44.790]                 NAMES <- toupper(removed)
[17:46:44.790]                 for (kk in seq_along(NAMES)) {
[17:46:44.790]                   name <- removed[[kk]]
[17:46:44.790]                   NAME <- NAMES[[kk]]
[17:46:44.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.790]                     next
[17:46:44.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.790]                 }
[17:46:44.790]                 if (length(args) > 0) 
[17:46:44.790]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.790]             }
[17:46:44.790]             else {
[17:46:44.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.790]             }
[17:46:44.790]             {
[17:46:44.790]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.790]                   0L) {
[17:46:44.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.790]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.790]                   base::options(opts)
[17:46:44.790]                 }
[17:46:44.790]                 {
[17:46:44.790]                   {
[17:46:44.790]                     NULL
[17:46:44.790]                     RNGkind("Mersenne-Twister")
[17:46:44.790]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.790]                       inherits = FALSE)
[17:46:44.790]                   }
[17:46:44.790]                   options(future.plan = NULL)
[17:46:44.790]                   if (is.na(NA_character_)) 
[17:46:44.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.790]                     .init = FALSE)
[17:46:44.790]                 }
[17:46:44.790]             }
[17:46:44.790]         }
[17:46:44.790]     })
[17:46:44.790]     if (TRUE) {
[17:46:44.790]         base::sink(type = "output", split = FALSE)
[17:46:44.790]         if (TRUE) {
[17:46:44.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.790]         }
[17:46:44.790]         else {
[17:46:44.790]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.790]         }
[17:46:44.790]         base::close(...future.stdout)
[17:46:44.790]         ...future.stdout <- NULL
[17:46:44.790]     }
[17:46:44.790]     ...future.result$conditions <- ...future.conditions
[17:46:44.790]     ...future.result$finished <- base::Sys.time()
[17:46:44.790]     ...future.result
[17:46:44.790] }
[17:46:44.792] plan(): Setting new future strategy stack:
[17:46:44.792] List of future strategies:
[17:46:44.792] 1. sequential:
[17:46:44.792]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.792]    - tweaked: FALSE
[17:46:44.792]    - call: NULL
[17:46:44.792] plan(): nbrOfWorkers() = 1
[17:46:44.793] plan(): Setting new future strategy stack:
[17:46:44.793] List of future strategies:
[17:46:44.793] 1. sequential:
[17:46:44.793]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.793]    - tweaked: FALSE
[17:46:44.793]    - call: plan(strategy)
[17:46:44.794] plan(): nbrOfWorkers() = 1
[17:46:44.794] SequentialFuture started (and completed)
[17:46:44.794] - Launch lazy future ... done
[17:46:44.794] run() for ‘SequentialFuture’ ... done
[17:46:44.794] getGlobalsAndPackages() ...
[17:46:44.794] Searching for globals...
[17:46:44.795] - globals found: [1] ‘{’
[17:46:44.795] Searching for globals ... DONE
[17:46:44.795] Resolving globals: FALSE
[17:46:44.795] 
[17:46:44.795] 
[17:46:44.796] getGlobalsAndPackages() ... DONE
[17:46:44.796] run() for ‘Future’ ...
[17:46:44.796] - state: ‘created’
[17:46:44.796] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.796] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.796]   - Field: ‘label’
[17:46:44.797]   - Field: ‘local’
[17:46:44.797]   - Field: ‘owner’
[17:46:44.797]   - Field: ‘envir’
[17:46:44.797]   - Field: ‘packages’
[17:46:44.797]   - Field: ‘gc’
[17:46:44.797]   - Field: ‘conditions’
[17:46:44.797]   - Field: ‘expr’
[17:46:44.797]   - Field: ‘uuid’
[17:46:44.797]   - Field: ‘seed’
[17:46:44.797]   - Field: ‘version’
[17:46:44.797]   - Field: ‘result’
[17:46:44.798]   - Field: ‘asynchronous’
[17:46:44.798]   - Field: ‘calls’
[17:46:44.798]   - Field: ‘globals’
[17:46:44.798]   - Field: ‘stdout’
[17:46:44.798]   - Field: ‘earlySignal’
[17:46:44.798]   - Field: ‘lazy’
[17:46:44.798]   - Field: ‘state’
[17:46:44.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.798] - Launch lazy future ...
[17:46:44.798] Packages needed by the future expression (n = 0): <none>
[17:46:44.799] Packages needed by future strategies (n = 0): <none>
[17:46:44.799] {
[17:46:44.799]     {
[17:46:44.799]         {
[17:46:44.799]             ...future.startTime <- base::Sys.time()
[17:46:44.799]             {
[17:46:44.799]                 {
[17:46:44.799]                   {
[17:46:44.799]                     base::local({
[17:46:44.799]                       has_future <- base::requireNamespace("future", 
[17:46:44.799]                         quietly = TRUE)
[17:46:44.799]                       if (has_future) {
[17:46:44.799]                         ns <- base::getNamespace("future")
[17:46:44.799]                         version <- ns[[".package"]][["version"]]
[17:46:44.799]                         if (is.null(version)) 
[17:46:44.799]                           version <- utils::packageVersion("future")
[17:46:44.799]                       }
[17:46:44.799]                       else {
[17:46:44.799]                         version <- NULL
[17:46:44.799]                       }
[17:46:44.799]                       if (!has_future || version < "1.8.0") {
[17:46:44.799]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.799]                           "", base::R.version$version.string), 
[17:46:44.799]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.799]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.799]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.799]                             "release", "version")], collapse = " "), 
[17:46:44.799]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.799]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.799]                           info)
[17:46:44.799]                         info <- base::paste(info, collapse = "; ")
[17:46:44.799]                         if (!has_future) {
[17:46:44.799]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.799]                             info)
[17:46:44.799]                         }
[17:46:44.799]                         else {
[17:46:44.799]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.799]                             info, version)
[17:46:44.799]                         }
[17:46:44.799]                         base::stop(msg)
[17:46:44.799]                       }
[17:46:44.799]                     })
[17:46:44.799]                   }
[17:46:44.799]                   ...future.strategy.old <- future::plan("list")
[17:46:44.799]                   options(future.plan = NULL)
[17:46:44.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.799]                 }
[17:46:44.799]                 ...future.workdir <- getwd()
[17:46:44.799]             }
[17:46:44.799]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.799]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.799]         }
[17:46:44.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.799]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.799]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.799]             base::names(...future.oldOptions))
[17:46:44.799]     }
[17:46:44.799]     if (FALSE) {
[17:46:44.799]     }
[17:46:44.799]     else {
[17:46:44.799]         if (TRUE) {
[17:46:44.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.799]                 open = "w")
[17:46:44.799]         }
[17:46:44.799]         else {
[17:46:44.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.799]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.799]         }
[17:46:44.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.799]             base::sink(type = "output", split = FALSE)
[17:46:44.799]             base::close(...future.stdout)
[17:46:44.799]         }, add = TRUE)
[17:46:44.799]     }
[17:46:44.799]     ...future.frame <- base::sys.nframe()
[17:46:44.799]     ...future.conditions <- base::list()
[17:46:44.799]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.799]     if (FALSE) {
[17:46:44.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.799]     }
[17:46:44.799]     ...future.result <- base::tryCatch({
[17:46:44.799]         base::withCallingHandlers({
[17:46:44.799]             ...future.value <- base::withVisible(base::local({
[17:46:44.799]                 4
[17:46:44.799]             }))
[17:46:44.799]             future::FutureResult(value = ...future.value$value, 
[17:46:44.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.799]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.799]                     ...future.globalenv.names))
[17:46:44.799]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.799]         }, condition = base::local({
[17:46:44.799]             c <- base::c
[17:46:44.799]             inherits <- base::inherits
[17:46:44.799]             invokeRestart <- base::invokeRestart
[17:46:44.799]             length <- base::length
[17:46:44.799]             list <- base::list
[17:46:44.799]             seq.int <- base::seq.int
[17:46:44.799]             signalCondition <- base::signalCondition
[17:46:44.799]             sys.calls <- base::sys.calls
[17:46:44.799]             `[[` <- base::`[[`
[17:46:44.799]             `+` <- base::`+`
[17:46:44.799]             `<<-` <- base::`<<-`
[17:46:44.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.799]                   3L)]
[17:46:44.799]             }
[17:46:44.799]             function(cond) {
[17:46:44.799]                 is_error <- inherits(cond, "error")
[17:46:44.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.799]                   NULL)
[17:46:44.799]                 if (is_error) {
[17:46:44.799]                   sessionInformation <- function() {
[17:46:44.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.799]                       search = base::search(), system = base::Sys.info())
[17:46:44.799]                   }
[17:46:44.799]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.799]                     cond$call), session = sessionInformation(), 
[17:46:44.799]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.799]                   signalCondition(cond)
[17:46:44.799]                 }
[17:46:44.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.799]                 "immediateCondition"))) {
[17:46:44.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.799]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.799]                   if (TRUE && !signal) {
[17:46:44.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.799]                     {
[17:46:44.799]                       inherits <- base::inherits
[17:46:44.799]                       invokeRestart <- base::invokeRestart
[17:46:44.799]                       is.null <- base::is.null
[17:46:44.799]                       muffled <- FALSE
[17:46:44.799]                       if (inherits(cond, "message")) {
[17:46:44.799]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.799]                         if (muffled) 
[17:46:44.799]                           invokeRestart("muffleMessage")
[17:46:44.799]                       }
[17:46:44.799]                       else if (inherits(cond, "warning")) {
[17:46:44.799]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.799]                         if (muffled) 
[17:46:44.799]                           invokeRestart("muffleWarning")
[17:46:44.799]                       }
[17:46:44.799]                       else if (inherits(cond, "condition")) {
[17:46:44.799]                         if (!is.null(pattern)) {
[17:46:44.799]                           computeRestarts <- base::computeRestarts
[17:46:44.799]                           grepl <- base::grepl
[17:46:44.799]                           restarts <- computeRestarts(cond)
[17:46:44.799]                           for (restart in restarts) {
[17:46:44.799]                             name <- restart$name
[17:46:44.799]                             if (is.null(name)) 
[17:46:44.799]                               next
[17:46:44.799]                             if (!grepl(pattern, name)) 
[17:46:44.799]                               next
[17:46:44.799]                             invokeRestart(restart)
[17:46:44.799]                             muffled <- TRUE
[17:46:44.799]                             break
[17:46:44.799]                           }
[17:46:44.799]                         }
[17:46:44.799]                       }
[17:46:44.799]                       invisible(muffled)
[17:46:44.799]                     }
[17:46:44.799]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.799]                   }
[17:46:44.799]                 }
[17:46:44.799]                 else {
[17:46:44.799]                   if (TRUE) {
[17:46:44.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.799]                     {
[17:46:44.799]                       inherits <- base::inherits
[17:46:44.799]                       invokeRestart <- base::invokeRestart
[17:46:44.799]                       is.null <- base::is.null
[17:46:44.799]                       muffled <- FALSE
[17:46:44.799]                       if (inherits(cond, "message")) {
[17:46:44.799]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.799]                         if (muffled) 
[17:46:44.799]                           invokeRestart("muffleMessage")
[17:46:44.799]                       }
[17:46:44.799]                       else if (inherits(cond, "warning")) {
[17:46:44.799]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.799]                         if (muffled) 
[17:46:44.799]                           invokeRestart("muffleWarning")
[17:46:44.799]                       }
[17:46:44.799]                       else if (inherits(cond, "condition")) {
[17:46:44.799]                         if (!is.null(pattern)) {
[17:46:44.799]                           computeRestarts <- base::computeRestarts
[17:46:44.799]                           grepl <- base::grepl
[17:46:44.799]                           restarts <- computeRestarts(cond)
[17:46:44.799]                           for (restart in restarts) {
[17:46:44.799]                             name <- restart$name
[17:46:44.799]                             if (is.null(name)) 
[17:46:44.799]                               next
[17:46:44.799]                             if (!grepl(pattern, name)) 
[17:46:44.799]                               next
[17:46:44.799]                             invokeRestart(restart)
[17:46:44.799]                             muffled <- TRUE
[17:46:44.799]                             break
[17:46:44.799]                           }
[17:46:44.799]                         }
[17:46:44.799]                       }
[17:46:44.799]                       invisible(muffled)
[17:46:44.799]                     }
[17:46:44.799]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.799]                   }
[17:46:44.799]                 }
[17:46:44.799]             }
[17:46:44.799]         }))
[17:46:44.799]     }, error = function(ex) {
[17:46:44.799]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.799]                 ...future.rng), started = ...future.startTime, 
[17:46:44.799]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.799]             version = "1.8"), class = "FutureResult")
[17:46:44.799]     }, finally = {
[17:46:44.799]         if (!identical(...future.workdir, getwd())) 
[17:46:44.799]             setwd(...future.workdir)
[17:46:44.799]         {
[17:46:44.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.799]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.799]             }
[17:46:44.799]             base::options(...future.oldOptions)
[17:46:44.799]             if (.Platform$OS.type == "windows") {
[17:46:44.799]                 old_names <- names(...future.oldEnvVars)
[17:46:44.799]                 envs <- base::Sys.getenv()
[17:46:44.799]                 names <- names(envs)
[17:46:44.799]                 common <- intersect(names, old_names)
[17:46:44.799]                 added <- setdiff(names, old_names)
[17:46:44.799]                 removed <- setdiff(old_names, names)
[17:46:44.799]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.799]                   envs[common]]
[17:46:44.799]                 NAMES <- toupper(changed)
[17:46:44.799]                 args <- list()
[17:46:44.799]                 for (kk in seq_along(NAMES)) {
[17:46:44.799]                   name <- changed[[kk]]
[17:46:44.799]                   NAME <- NAMES[[kk]]
[17:46:44.799]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.799]                     next
[17:46:44.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.799]                 }
[17:46:44.799]                 NAMES <- toupper(added)
[17:46:44.799]                 for (kk in seq_along(NAMES)) {
[17:46:44.799]                   name <- added[[kk]]
[17:46:44.799]                   NAME <- NAMES[[kk]]
[17:46:44.799]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.799]                     next
[17:46:44.799]                   args[[name]] <- ""
[17:46:44.799]                 }
[17:46:44.799]                 NAMES <- toupper(removed)
[17:46:44.799]                 for (kk in seq_along(NAMES)) {
[17:46:44.799]                   name <- removed[[kk]]
[17:46:44.799]                   NAME <- NAMES[[kk]]
[17:46:44.799]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.799]                     next
[17:46:44.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.799]                 }
[17:46:44.799]                 if (length(args) > 0) 
[17:46:44.799]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.799]             }
[17:46:44.799]             else {
[17:46:44.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.799]             }
[17:46:44.799]             {
[17:46:44.799]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.799]                   0L) {
[17:46:44.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.799]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.799]                   base::options(opts)
[17:46:44.799]                 }
[17:46:44.799]                 {
[17:46:44.799]                   {
[17:46:44.799]                     NULL
[17:46:44.799]                     RNGkind("Mersenne-Twister")
[17:46:44.799]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.799]                       inherits = FALSE)
[17:46:44.799]                   }
[17:46:44.799]                   options(future.plan = NULL)
[17:46:44.799]                   if (is.na(NA_character_)) 
[17:46:44.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.799]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.799]                     .init = FALSE)
[17:46:44.799]                 }
[17:46:44.799]             }
[17:46:44.799]         }
[17:46:44.799]     })
[17:46:44.799]     if (TRUE) {
[17:46:44.799]         base::sink(type = "output", split = FALSE)
[17:46:44.799]         if (TRUE) {
[17:46:44.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.799]         }
[17:46:44.799]         else {
[17:46:44.799]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.799]         }
[17:46:44.799]         base::close(...future.stdout)
[17:46:44.799]         ...future.stdout <- NULL
[17:46:44.799]     }
[17:46:44.799]     ...future.result$conditions <- ...future.conditions
[17:46:44.799]     ...future.result$finished <- base::Sys.time()
[17:46:44.799]     ...future.result
[17:46:44.799] }
[17:46:44.801] plan(): Setting new future strategy stack:
[17:46:44.801] List of future strategies:
[17:46:44.801] 1. sequential:
[17:46:44.801]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.801]    - tweaked: FALSE
[17:46:44.801]    - call: NULL
[17:46:44.801] plan(): nbrOfWorkers() = 1
[17:46:44.802] plan(): Setting new future strategy stack:
[17:46:44.802] List of future strategies:
[17:46:44.802] 1. sequential:
[17:46:44.802]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.802]    - tweaked: FALSE
[17:46:44.802]    - call: plan(strategy)
[17:46:44.802] plan(): nbrOfWorkers() = 1
[17:46:44.803] SequentialFuture started (and completed)
[17:46:44.803] - Launch lazy future ... done
[17:46:44.803] run() for ‘SequentialFuture’ ... done
<environment: 0x561787d0af58> 
<environment: 0x561787afd558> 
[17:46:44.804] resolved() for ‘SequentialFuture’ ...
[17:46:44.804] - state: ‘finished’
[17:46:44.804] - run: TRUE
[17:46:44.804] - result: ‘FutureResult’
[17:46:44.805] resolved() for ‘SequentialFuture’ ... done
[17:46:44.805] resolved() for ‘SequentialFuture’ ...
[17:46:44.805] - state: ‘finished’
[17:46:44.805] - run: TRUE
[17:46:44.805] - result: ‘FutureResult’
[17:46:44.805] resolved() for ‘SequentialFuture’ ... done
[17:46:44.805] resolved() for ‘SequentialFuture’ ...
[17:46:44.805] - state: ‘finished’
[17:46:44.805] - run: TRUE
[17:46:44.805] - result: ‘FutureResult’
[17:46:44.805] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:44.807] resolve() on environment ...
[17:46:44.807]  recursive: 0
[17:46:44.807]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:44.808] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.808] - nx: 4
[17:46:44.808] - relay: TRUE
[17:46:44.808] - stdout: TRUE
[17:46:44.808] - signal: TRUE
[17:46:44.808] - resignal: FALSE
[17:46:44.808] - force: TRUE
[17:46:44.808] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.808] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.809]  - until=2
[17:46:44.809]  - relaying element #2
[17:46:44.809] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.809] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.809] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.809]  length: 3 (resolved future 1)
[17:46:44.809] resolved() for ‘SequentialFuture’ ...
[17:46:44.809] - state: ‘finished’
[17:46:44.809] - run: TRUE
[17:46:44.810] - result: ‘FutureResult’
[17:46:44.810] resolved() for ‘SequentialFuture’ ... done
[17:46:44.810] Future #2
[17:46:44.810] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.810] - nx: 4
[17:46:44.810] - relay: TRUE
[17:46:44.810] - stdout: TRUE
[17:46:44.810] - signal: TRUE
[17:46:44.810] - resignal: FALSE
[17:46:44.810] - force: TRUE
[17:46:44.810] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.811] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.811]  - until=2
[17:46:44.811]  - relaying element #2
[17:46:44.811] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.811] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.811] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.811]  length: 2 (resolved future 2)
[17:46:44.811] resolved() for ‘SequentialFuture’ ...
[17:46:44.811] - state: ‘finished’
[17:46:44.812] - run: TRUE
[17:46:44.812] - result: ‘FutureResult’
[17:46:44.812] resolved() for ‘SequentialFuture’ ... done
[17:46:44.812] Future #3
[17:46:44.812] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.812] - nx: 4
[17:46:44.812] - relay: TRUE
[17:46:44.812] - stdout: TRUE
[17:46:44.812] - signal: TRUE
[17:46:44.812] - resignal: FALSE
[17:46:44.812] - force: TRUE
[17:46:44.814] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.815] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.815]  - until=3
[17:46:44.815]  - relaying element #3
[17:46:44.815] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.815] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.815] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.815]  length: 1 (resolved future 3)
[17:46:44.815] resolved() for ‘SequentialFuture’ ...
[17:46:44.815] - state: ‘finished’
[17:46:44.816] - run: TRUE
[17:46:44.816] - result: ‘FutureResult’
[17:46:44.816] resolved() for ‘SequentialFuture’ ... done
[17:46:44.816] Future #4
[17:46:44.816] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:44.816] - nx: 4
[17:46:44.816] - relay: TRUE
[17:46:44.816] - stdout: TRUE
[17:46:44.816] - signal: TRUE
[17:46:44.816] - resignal: FALSE
[17:46:44.816] - force: TRUE
[17:46:44.817] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.817] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.817]  - until=4
[17:46:44.817]  - relaying element #4
[17:46:44.817] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.817] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.817] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:44.817]  length: 0 (resolved future 4)
[17:46:44.817] Relaying remaining futures
[17:46:44.817] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.818] - nx: 4
[17:46:44.818] - relay: TRUE
[17:46:44.818] - stdout: TRUE
[17:46:44.818] - signal: TRUE
[17:46:44.818] - resignal: FALSE
[17:46:44.818] - force: TRUE
[17:46:44.818] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.818] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:44.818] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.818] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.818] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.818] resolve() on environment ... DONE
<environment: 0x561787c9a6f0> 
Dimensions: c(2, 1, 3, 1)
[17:46:44.819] getGlobalsAndPackages() ...
[17:46:44.819] Searching for globals...
[17:46:44.820] 
[17:46:44.820] Searching for globals ... DONE
[17:46:44.820] - globals: [0] <none>
[17:46:44.820] getGlobalsAndPackages() ... DONE
[17:46:44.820] run() for ‘Future’ ...
[17:46:44.820] - state: ‘created’
[17:46:44.820] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.821]   - Field: ‘label’
[17:46:44.821]   - Field: ‘local’
[17:46:44.821]   - Field: ‘owner’
[17:46:44.821]   - Field: ‘envir’
[17:46:44.821]   - Field: ‘packages’
[17:46:44.821]   - Field: ‘gc’
[17:46:44.821]   - Field: ‘conditions’
[17:46:44.821]   - Field: ‘expr’
[17:46:44.821]   - Field: ‘uuid’
[17:46:44.822]   - Field: ‘seed’
[17:46:44.822]   - Field: ‘version’
[17:46:44.822]   - Field: ‘result’
[17:46:44.822]   - Field: ‘asynchronous’
[17:46:44.822]   - Field: ‘calls’
[17:46:44.822]   - Field: ‘globals’
[17:46:44.822]   - Field: ‘stdout’
[17:46:44.822]   - Field: ‘earlySignal’
[17:46:44.822]   - Field: ‘lazy’
[17:46:44.822]   - Field: ‘state’
[17:46:44.822] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.823] - Launch lazy future ...
[17:46:44.823] Packages needed by the future expression (n = 0): <none>
[17:46:44.823] Packages needed by future strategies (n = 0): <none>
[17:46:44.823] {
[17:46:44.823]     {
[17:46:44.823]         {
[17:46:44.823]             ...future.startTime <- base::Sys.time()
[17:46:44.823]             {
[17:46:44.823]                 {
[17:46:44.823]                   {
[17:46:44.823]                     base::local({
[17:46:44.823]                       has_future <- base::requireNamespace("future", 
[17:46:44.823]                         quietly = TRUE)
[17:46:44.823]                       if (has_future) {
[17:46:44.823]                         ns <- base::getNamespace("future")
[17:46:44.823]                         version <- ns[[".package"]][["version"]]
[17:46:44.823]                         if (is.null(version)) 
[17:46:44.823]                           version <- utils::packageVersion("future")
[17:46:44.823]                       }
[17:46:44.823]                       else {
[17:46:44.823]                         version <- NULL
[17:46:44.823]                       }
[17:46:44.823]                       if (!has_future || version < "1.8.0") {
[17:46:44.823]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.823]                           "", base::R.version$version.string), 
[17:46:44.823]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.823]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.823]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.823]                             "release", "version")], collapse = " "), 
[17:46:44.823]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.823]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.823]                           info)
[17:46:44.823]                         info <- base::paste(info, collapse = "; ")
[17:46:44.823]                         if (!has_future) {
[17:46:44.823]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.823]                             info)
[17:46:44.823]                         }
[17:46:44.823]                         else {
[17:46:44.823]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.823]                             info, version)
[17:46:44.823]                         }
[17:46:44.823]                         base::stop(msg)
[17:46:44.823]                       }
[17:46:44.823]                     })
[17:46:44.823]                   }
[17:46:44.823]                   ...future.strategy.old <- future::plan("list")
[17:46:44.823]                   options(future.plan = NULL)
[17:46:44.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.823]                 }
[17:46:44.823]                 ...future.workdir <- getwd()
[17:46:44.823]             }
[17:46:44.823]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.823]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.823]         }
[17:46:44.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.823]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.823]             base::names(...future.oldOptions))
[17:46:44.823]     }
[17:46:44.823]     if (FALSE) {
[17:46:44.823]     }
[17:46:44.823]     else {
[17:46:44.823]         if (TRUE) {
[17:46:44.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.823]                 open = "w")
[17:46:44.823]         }
[17:46:44.823]         else {
[17:46:44.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.823]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.823]         }
[17:46:44.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.823]             base::sink(type = "output", split = FALSE)
[17:46:44.823]             base::close(...future.stdout)
[17:46:44.823]         }, add = TRUE)
[17:46:44.823]     }
[17:46:44.823]     ...future.frame <- base::sys.nframe()
[17:46:44.823]     ...future.conditions <- base::list()
[17:46:44.823]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.823]     if (FALSE) {
[17:46:44.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.823]     }
[17:46:44.823]     ...future.result <- base::tryCatch({
[17:46:44.823]         base::withCallingHandlers({
[17:46:44.823]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.823]             future::FutureResult(value = ...future.value$value, 
[17:46:44.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.823]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.823]                     ...future.globalenv.names))
[17:46:44.823]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.823]         }, condition = base::local({
[17:46:44.823]             c <- base::c
[17:46:44.823]             inherits <- base::inherits
[17:46:44.823]             invokeRestart <- base::invokeRestart
[17:46:44.823]             length <- base::length
[17:46:44.823]             list <- base::list
[17:46:44.823]             seq.int <- base::seq.int
[17:46:44.823]             signalCondition <- base::signalCondition
[17:46:44.823]             sys.calls <- base::sys.calls
[17:46:44.823]             `[[` <- base::`[[`
[17:46:44.823]             `+` <- base::`+`
[17:46:44.823]             `<<-` <- base::`<<-`
[17:46:44.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.823]                   3L)]
[17:46:44.823]             }
[17:46:44.823]             function(cond) {
[17:46:44.823]                 is_error <- inherits(cond, "error")
[17:46:44.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.823]                   NULL)
[17:46:44.823]                 if (is_error) {
[17:46:44.823]                   sessionInformation <- function() {
[17:46:44.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.823]                       search = base::search(), system = base::Sys.info())
[17:46:44.823]                   }
[17:46:44.823]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.823]                     cond$call), session = sessionInformation(), 
[17:46:44.823]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.823]                   signalCondition(cond)
[17:46:44.823]                 }
[17:46:44.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.823]                 "immediateCondition"))) {
[17:46:44.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.823]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.823]                   if (TRUE && !signal) {
[17:46:44.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.823]                     {
[17:46:44.823]                       inherits <- base::inherits
[17:46:44.823]                       invokeRestart <- base::invokeRestart
[17:46:44.823]                       is.null <- base::is.null
[17:46:44.823]                       muffled <- FALSE
[17:46:44.823]                       if (inherits(cond, "message")) {
[17:46:44.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.823]                         if (muffled) 
[17:46:44.823]                           invokeRestart("muffleMessage")
[17:46:44.823]                       }
[17:46:44.823]                       else if (inherits(cond, "warning")) {
[17:46:44.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.823]                         if (muffled) 
[17:46:44.823]                           invokeRestart("muffleWarning")
[17:46:44.823]                       }
[17:46:44.823]                       else if (inherits(cond, "condition")) {
[17:46:44.823]                         if (!is.null(pattern)) {
[17:46:44.823]                           computeRestarts <- base::computeRestarts
[17:46:44.823]                           grepl <- base::grepl
[17:46:44.823]                           restarts <- computeRestarts(cond)
[17:46:44.823]                           for (restart in restarts) {
[17:46:44.823]                             name <- restart$name
[17:46:44.823]                             if (is.null(name)) 
[17:46:44.823]                               next
[17:46:44.823]                             if (!grepl(pattern, name)) 
[17:46:44.823]                               next
[17:46:44.823]                             invokeRestart(restart)
[17:46:44.823]                             muffled <- TRUE
[17:46:44.823]                             break
[17:46:44.823]                           }
[17:46:44.823]                         }
[17:46:44.823]                       }
[17:46:44.823]                       invisible(muffled)
[17:46:44.823]                     }
[17:46:44.823]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.823]                   }
[17:46:44.823]                 }
[17:46:44.823]                 else {
[17:46:44.823]                   if (TRUE) {
[17:46:44.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.823]                     {
[17:46:44.823]                       inherits <- base::inherits
[17:46:44.823]                       invokeRestart <- base::invokeRestart
[17:46:44.823]                       is.null <- base::is.null
[17:46:44.823]                       muffled <- FALSE
[17:46:44.823]                       if (inherits(cond, "message")) {
[17:46:44.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.823]                         if (muffled) 
[17:46:44.823]                           invokeRestart("muffleMessage")
[17:46:44.823]                       }
[17:46:44.823]                       else if (inherits(cond, "warning")) {
[17:46:44.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.823]                         if (muffled) 
[17:46:44.823]                           invokeRestart("muffleWarning")
[17:46:44.823]                       }
[17:46:44.823]                       else if (inherits(cond, "condition")) {
[17:46:44.823]                         if (!is.null(pattern)) {
[17:46:44.823]                           computeRestarts <- base::computeRestarts
[17:46:44.823]                           grepl <- base::grepl
[17:46:44.823]                           restarts <- computeRestarts(cond)
[17:46:44.823]                           for (restart in restarts) {
[17:46:44.823]                             name <- restart$name
[17:46:44.823]                             if (is.null(name)) 
[17:46:44.823]                               next
[17:46:44.823]                             if (!grepl(pattern, name)) 
[17:46:44.823]                               next
[17:46:44.823]                             invokeRestart(restart)
[17:46:44.823]                             muffled <- TRUE
[17:46:44.823]                             break
[17:46:44.823]                           }
[17:46:44.823]                         }
[17:46:44.823]                       }
[17:46:44.823]                       invisible(muffled)
[17:46:44.823]                     }
[17:46:44.823]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.823]                   }
[17:46:44.823]                 }
[17:46:44.823]             }
[17:46:44.823]         }))
[17:46:44.823]     }, error = function(ex) {
[17:46:44.823]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.823]                 ...future.rng), started = ...future.startTime, 
[17:46:44.823]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.823]             version = "1.8"), class = "FutureResult")
[17:46:44.823]     }, finally = {
[17:46:44.823]         if (!identical(...future.workdir, getwd())) 
[17:46:44.823]             setwd(...future.workdir)
[17:46:44.823]         {
[17:46:44.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.823]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.823]             }
[17:46:44.823]             base::options(...future.oldOptions)
[17:46:44.823]             if (.Platform$OS.type == "windows") {
[17:46:44.823]                 old_names <- names(...future.oldEnvVars)
[17:46:44.823]                 envs <- base::Sys.getenv()
[17:46:44.823]                 names <- names(envs)
[17:46:44.823]                 common <- intersect(names, old_names)
[17:46:44.823]                 added <- setdiff(names, old_names)
[17:46:44.823]                 removed <- setdiff(old_names, names)
[17:46:44.823]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.823]                   envs[common]]
[17:46:44.823]                 NAMES <- toupper(changed)
[17:46:44.823]                 args <- list()
[17:46:44.823]                 for (kk in seq_along(NAMES)) {
[17:46:44.823]                   name <- changed[[kk]]
[17:46:44.823]                   NAME <- NAMES[[kk]]
[17:46:44.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.823]                     next
[17:46:44.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.823]                 }
[17:46:44.823]                 NAMES <- toupper(added)
[17:46:44.823]                 for (kk in seq_along(NAMES)) {
[17:46:44.823]                   name <- added[[kk]]
[17:46:44.823]                   NAME <- NAMES[[kk]]
[17:46:44.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.823]                     next
[17:46:44.823]                   args[[name]] <- ""
[17:46:44.823]                 }
[17:46:44.823]                 NAMES <- toupper(removed)
[17:46:44.823]                 for (kk in seq_along(NAMES)) {
[17:46:44.823]                   name <- removed[[kk]]
[17:46:44.823]                   NAME <- NAMES[[kk]]
[17:46:44.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.823]                     next
[17:46:44.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.823]                 }
[17:46:44.823]                 if (length(args) > 0) 
[17:46:44.823]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.823]             }
[17:46:44.823]             else {
[17:46:44.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.823]             }
[17:46:44.823]             {
[17:46:44.823]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.823]                   0L) {
[17:46:44.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.823]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.823]                   base::options(opts)
[17:46:44.823]                 }
[17:46:44.823]                 {
[17:46:44.823]                   {
[17:46:44.823]                     NULL
[17:46:44.823]                     RNGkind("Mersenne-Twister")
[17:46:44.823]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.823]                       inherits = FALSE)
[17:46:44.823]                   }
[17:46:44.823]                   options(future.plan = NULL)
[17:46:44.823]                   if (is.na(NA_character_)) 
[17:46:44.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.823]                     .init = FALSE)
[17:46:44.823]                 }
[17:46:44.823]             }
[17:46:44.823]         }
[17:46:44.823]     })
[17:46:44.823]     if (TRUE) {
[17:46:44.823]         base::sink(type = "output", split = FALSE)
[17:46:44.823]         if (TRUE) {
[17:46:44.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.823]         }
[17:46:44.823]         else {
[17:46:44.823]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.823]         }
[17:46:44.823]         base::close(...future.stdout)
[17:46:44.823]         ...future.stdout <- NULL
[17:46:44.823]     }
[17:46:44.823]     ...future.result$conditions <- ...future.conditions
[17:46:44.823]     ...future.result$finished <- base::Sys.time()
[17:46:44.823]     ...future.result
[17:46:44.823] }
[17:46:44.825] plan(): Setting new future strategy stack:
[17:46:44.825] List of future strategies:
[17:46:44.825] 1. sequential:
[17:46:44.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.825]    - tweaked: FALSE
[17:46:44.825]    - call: NULL
[17:46:44.826] plan(): nbrOfWorkers() = 1
[17:46:44.826] plan(): Setting new future strategy stack:
[17:46:44.826] List of future strategies:
[17:46:44.826] 1. sequential:
[17:46:44.826]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.826]    - tweaked: FALSE
[17:46:44.826]    - call: plan(strategy)
[17:46:44.827] plan(): nbrOfWorkers() = 1
[17:46:44.827] SequentialFuture started (and completed)
[17:46:44.827] - Launch lazy future ... done
[17:46:44.827] run() for ‘SequentialFuture’ ... done
[17:46:44.827] getGlobalsAndPackages() ...
[17:46:44.827] Searching for globals...
[17:46:44.828] 
[17:46:44.828] Searching for globals ... DONE
[17:46:44.828] - globals: [0] <none>
[17:46:44.828] getGlobalsAndPackages() ... DONE
[17:46:44.828] run() for ‘Future’ ...
[17:46:44.828] - state: ‘created’
[17:46:44.828] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.829] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.829] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.829]   - Field: ‘label’
[17:46:44.829]   - Field: ‘local’
[17:46:44.829]   - Field: ‘owner’
[17:46:44.829]   - Field: ‘envir’
[17:46:44.829]   - Field: ‘packages’
[17:46:44.829]   - Field: ‘gc’
[17:46:44.829]   - Field: ‘conditions’
[17:46:44.830]   - Field: ‘expr’
[17:46:44.830]   - Field: ‘uuid’
[17:46:44.830]   - Field: ‘seed’
[17:46:44.830]   - Field: ‘version’
[17:46:44.830]   - Field: ‘result’
[17:46:44.830]   - Field: ‘asynchronous’
[17:46:44.830]   - Field: ‘calls’
[17:46:44.830]   - Field: ‘globals’
[17:46:44.830]   - Field: ‘stdout’
[17:46:44.830]   - Field: ‘earlySignal’
[17:46:44.830]   - Field: ‘lazy’
[17:46:44.831]   - Field: ‘state’
[17:46:44.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.831] - Launch lazy future ...
[17:46:44.831] Packages needed by the future expression (n = 0): <none>
[17:46:44.831] Packages needed by future strategies (n = 0): <none>
[17:46:44.831] {
[17:46:44.831]     {
[17:46:44.831]         {
[17:46:44.831]             ...future.startTime <- base::Sys.time()
[17:46:44.831]             {
[17:46:44.831]                 {
[17:46:44.831]                   {
[17:46:44.831]                     base::local({
[17:46:44.831]                       has_future <- base::requireNamespace("future", 
[17:46:44.831]                         quietly = TRUE)
[17:46:44.831]                       if (has_future) {
[17:46:44.831]                         ns <- base::getNamespace("future")
[17:46:44.831]                         version <- ns[[".package"]][["version"]]
[17:46:44.831]                         if (is.null(version)) 
[17:46:44.831]                           version <- utils::packageVersion("future")
[17:46:44.831]                       }
[17:46:44.831]                       else {
[17:46:44.831]                         version <- NULL
[17:46:44.831]                       }
[17:46:44.831]                       if (!has_future || version < "1.8.0") {
[17:46:44.831]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.831]                           "", base::R.version$version.string), 
[17:46:44.831]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.831]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.831]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.831]                             "release", "version")], collapse = " "), 
[17:46:44.831]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.831]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.831]                           info)
[17:46:44.831]                         info <- base::paste(info, collapse = "; ")
[17:46:44.831]                         if (!has_future) {
[17:46:44.831]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.831]                             info)
[17:46:44.831]                         }
[17:46:44.831]                         else {
[17:46:44.831]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.831]                             info, version)
[17:46:44.831]                         }
[17:46:44.831]                         base::stop(msg)
[17:46:44.831]                       }
[17:46:44.831]                     })
[17:46:44.831]                   }
[17:46:44.831]                   ...future.strategy.old <- future::plan("list")
[17:46:44.831]                   options(future.plan = NULL)
[17:46:44.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.831]                 }
[17:46:44.831]                 ...future.workdir <- getwd()
[17:46:44.831]             }
[17:46:44.831]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.831]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.831]         }
[17:46:44.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.831]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.831]             base::names(...future.oldOptions))
[17:46:44.831]     }
[17:46:44.831]     if (FALSE) {
[17:46:44.831]     }
[17:46:44.831]     else {
[17:46:44.831]         if (TRUE) {
[17:46:44.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.831]                 open = "w")
[17:46:44.831]         }
[17:46:44.831]         else {
[17:46:44.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.831]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.831]         }
[17:46:44.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.831]             base::sink(type = "output", split = FALSE)
[17:46:44.831]             base::close(...future.stdout)
[17:46:44.831]         }, add = TRUE)
[17:46:44.831]     }
[17:46:44.831]     ...future.frame <- base::sys.nframe()
[17:46:44.831]     ...future.conditions <- base::list()
[17:46:44.831]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.831]     if (FALSE) {
[17:46:44.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.831]     }
[17:46:44.831]     ...future.result <- base::tryCatch({
[17:46:44.831]         base::withCallingHandlers({
[17:46:44.831]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.831]             future::FutureResult(value = ...future.value$value, 
[17:46:44.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.831]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.831]                     ...future.globalenv.names))
[17:46:44.831]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.831]         }, condition = base::local({
[17:46:44.831]             c <- base::c
[17:46:44.831]             inherits <- base::inherits
[17:46:44.831]             invokeRestart <- base::invokeRestart
[17:46:44.831]             length <- base::length
[17:46:44.831]             list <- base::list
[17:46:44.831]             seq.int <- base::seq.int
[17:46:44.831]             signalCondition <- base::signalCondition
[17:46:44.831]             sys.calls <- base::sys.calls
[17:46:44.831]             `[[` <- base::`[[`
[17:46:44.831]             `+` <- base::`+`
[17:46:44.831]             `<<-` <- base::`<<-`
[17:46:44.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.831]                   3L)]
[17:46:44.831]             }
[17:46:44.831]             function(cond) {
[17:46:44.831]                 is_error <- inherits(cond, "error")
[17:46:44.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.831]                   NULL)
[17:46:44.831]                 if (is_error) {
[17:46:44.831]                   sessionInformation <- function() {
[17:46:44.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.831]                       search = base::search(), system = base::Sys.info())
[17:46:44.831]                   }
[17:46:44.831]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.831]                     cond$call), session = sessionInformation(), 
[17:46:44.831]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.831]                   signalCondition(cond)
[17:46:44.831]                 }
[17:46:44.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.831]                 "immediateCondition"))) {
[17:46:44.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.831]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.831]                   if (TRUE && !signal) {
[17:46:44.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.831]                     {
[17:46:44.831]                       inherits <- base::inherits
[17:46:44.831]                       invokeRestart <- base::invokeRestart
[17:46:44.831]                       is.null <- base::is.null
[17:46:44.831]                       muffled <- FALSE
[17:46:44.831]                       if (inherits(cond, "message")) {
[17:46:44.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.831]                         if (muffled) 
[17:46:44.831]                           invokeRestart("muffleMessage")
[17:46:44.831]                       }
[17:46:44.831]                       else if (inherits(cond, "warning")) {
[17:46:44.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.831]                         if (muffled) 
[17:46:44.831]                           invokeRestart("muffleWarning")
[17:46:44.831]                       }
[17:46:44.831]                       else if (inherits(cond, "condition")) {
[17:46:44.831]                         if (!is.null(pattern)) {
[17:46:44.831]                           computeRestarts <- base::computeRestarts
[17:46:44.831]                           grepl <- base::grepl
[17:46:44.831]                           restarts <- computeRestarts(cond)
[17:46:44.831]                           for (restart in restarts) {
[17:46:44.831]                             name <- restart$name
[17:46:44.831]                             if (is.null(name)) 
[17:46:44.831]                               next
[17:46:44.831]                             if (!grepl(pattern, name)) 
[17:46:44.831]                               next
[17:46:44.831]                             invokeRestart(restart)
[17:46:44.831]                             muffled <- TRUE
[17:46:44.831]                             break
[17:46:44.831]                           }
[17:46:44.831]                         }
[17:46:44.831]                       }
[17:46:44.831]                       invisible(muffled)
[17:46:44.831]                     }
[17:46:44.831]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.831]                   }
[17:46:44.831]                 }
[17:46:44.831]                 else {
[17:46:44.831]                   if (TRUE) {
[17:46:44.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.831]                     {
[17:46:44.831]                       inherits <- base::inherits
[17:46:44.831]                       invokeRestart <- base::invokeRestart
[17:46:44.831]                       is.null <- base::is.null
[17:46:44.831]                       muffled <- FALSE
[17:46:44.831]                       if (inherits(cond, "message")) {
[17:46:44.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.831]                         if (muffled) 
[17:46:44.831]                           invokeRestart("muffleMessage")
[17:46:44.831]                       }
[17:46:44.831]                       else if (inherits(cond, "warning")) {
[17:46:44.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.831]                         if (muffled) 
[17:46:44.831]                           invokeRestart("muffleWarning")
[17:46:44.831]                       }
[17:46:44.831]                       else if (inherits(cond, "condition")) {
[17:46:44.831]                         if (!is.null(pattern)) {
[17:46:44.831]                           computeRestarts <- base::computeRestarts
[17:46:44.831]                           grepl <- base::grepl
[17:46:44.831]                           restarts <- computeRestarts(cond)
[17:46:44.831]                           for (restart in restarts) {
[17:46:44.831]                             name <- restart$name
[17:46:44.831]                             if (is.null(name)) 
[17:46:44.831]                               next
[17:46:44.831]                             if (!grepl(pattern, name)) 
[17:46:44.831]                               next
[17:46:44.831]                             invokeRestart(restart)
[17:46:44.831]                             muffled <- TRUE
[17:46:44.831]                             break
[17:46:44.831]                           }
[17:46:44.831]                         }
[17:46:44.831]                       }
[17:46:44.831]                       invisible(muffled)
[17:46:44.831]                     }
[17:46:44.831]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.831]                   }
[17:46:44.831]                 }
[17:46:44.831]             }
[17:46:44.831]         }))
[17:46:44.831]     }, error = function(ex) {
[17:46:44.831]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.831]                 ...future.rng), started = ...future.startTime, 
[17:46:44.831]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.831]             version = "1.8"), class = "FutureResult")
[17:46:44.831]     }, finally = {
[17:46:44.831]         if (!identical(...future.workdir, getwd())) 
[17:46:44.831]             setwd(...future.workdir)
[17:46:44.831]         {
[17:46:44.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.831]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.831]             }
[17:46:44.831]             base::options(...future.oldOptions)
[17:46:44.831]             if (.Platform$OS.type == "windows") {
[17:46:44.831]                 old_names <- names(...future.oldEnvVars)
[17:46:44.831]                 envs <- base::Sys.getenv()
[17:46:44.831]                 names <- names(envs)
[17:46:44.831]                 common <- intersect(names, old_names)
[17:46:44.831]                 added <- setdiff(names, old_names)
[17:46:44.831]                 removed <- setdiff(old_names, names)
[17:46:44.831]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.831]                   envs[common]]
[17:46:44.831]                 NAMES <- toupper(changed)
[17:46:44.831]                 args <- list()
[17:46:44.831]                 for (kk in seq_along(NAMES)) {
[17:46:44.831]                   name <- changed[[kk]]
[17:46:44.831]                   NAME <- NAMES[[kk]]
[17:46:44.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.831]                     next
[17:46:44.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.831]                 }
[17:46:44.831]                 NAMES <- toupper(added)
[17:46:44.831]                 for (kk in seq_along(NAMES)) {
[17:46:44.831]                   name <- added[[kk]]
[17:46:44.831]                   NAME <- NAMES[[kk]]
[17:46:44.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.831]                     next
[17:46:44.831]                   args[[name]] <- ""
[17:46:44.831]                 }
[17:46:44.831]                 NAMES <- toupper(removed)
[17:46:44.831]                 for (kk in seq_along(NAMES)) {
[17:46:44.831]                   name <- removed[[kk]]
[17:46:44.831]                   NAME <- NAMES[[kk]]
[17:46:44.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.831]                     next
[17:46:44.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.831]                 }
[17:46:44.831]                 if (length(args) > 0) 
[17:46:44.831]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.831]             }
[17:46:44.831]             else {
[17:46:44.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.831]             }
[17:46:44.831]             {
[17:46:44.831]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.831]                   0L) {
[17:46:44.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.831]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.831]                   base::options(opts)
[17:46:44.831]                 }
[17:46:44.831]                 {
[17:46:44.831]                   {
[17:46:44.831]                     NULL
[17:46:44.831]                     RNGkind("Mersenne-Twister")
[17:46:44.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.831]                       inherits = FALSE)
[17:46:44.831]                   }
[17:46:44.831]                   options(future.plan = NULL)
[17:46:44.831]                   if (is.na(NA_character_)) 
[17:46:44.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.831]                     .init = FALSE)
[17:46:44.831]                 }
[17:46:44.831]             }
[17:46:44.831]         }
[17:46:44.831]     })
[17:46:44.831]     if (TRUE) {
[17:46:44.831]         base::sink(type = "output", split = FALSE)
[17:46:44.831]         if (TRUE) {
[17:46:44.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.831]         }
[17:46:44.831]         else {
[17:46:44.831]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.831]         }
[17:46:44.831]         base::close(...future.stdout)
[17:46:44.831]         ...future.stdout <- NULL
[17:46:44.831]     }
[17:46:44.831]     ...future.result$conditions <- ...future.conditions
[17:46:44.831]     ...future.result$finished <- base::Sys.time()
[17:46:44.831]     ...future.result
[17:46:44.831] }
[17:46:44.833] plan(): Setting new future strategy stack:
[17:46:44.833] List of future strategies:
[17:46:44.833] 1. sequential:
[17:46:44.833]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.833]    - tweaked: FALSE
[17:46:44.833]    - call: NULL
[17:46:44.834] plan(): nbrOfWorkers() = 1
[17:46:44.834] plan(): Setting new future strategy stack:
[17:46:44.835] List of future strategies:
[17:46:44.835] 1. sequential:
[17:46:44.835]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.835]    - tweaked: FALSE
[17:46:44.835]    - call: plan(strategy)
[17:46:44.835] plan(): nbrOfWorkers() = 1
[17:46:44.835] SequentialFuture started (and completed)
[17:46:44.835] - Launch lazy future ... done
[17:46:44.835] run() for ‘SequentialFuture’ ... done
[17:46:44.836] getGlobalsAndPackages() ...
[17:46:44.836] Searching for globals...
[17:46:44.836] - globals found: [1] ‘{’
[17:46:44.836] Searching for globals ... DONE
[17:46:44.837] Resolving globals: FALSE
[17:46:44.837] 
[17:46:44.837] 
[17:46:44.837] getGlobalsAndPackages() ... DONE
[17:46:44.837] run() for ‘Future’ ...
[17:46:44.837] - state: ‘created’
[17:46:44.837] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.838] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.838]   - Field: ‘label’
[17:46:44.838]   - Field: ‘local’
[17:46:44.838]   - Field: ‘owner’
[17:46:44.838]   - Field: ‘envir’
[17:46:44.838]   - Field: ‘packages’
[17:46:44.838]   - Field: ‘gc’
[17:46:44.838]   - Field: ‘conditions’
[17:46:44.839]   - Field: ‘expr’
[17:46:44.839]   - Field: ‘uuid’
[17:46:44.839]   - Field: ‘seed’
[17:46:44.839]   - Field: ‘version’
[17:46:44.839]   - Field: ‘result’
[17:46:44.839]   - Field: ‘asynchronous’
[17:46:44.839]   - Field: ‘calls’
[17:46:44.839]   - Field: ‘globals’
[17:46:44.839]   - Field: ‘stdout’
[17:46:44.839]   - Field: ‘earlySignal’
[17:46:44.839]   - Field: ‘lazy’
[17:46:44.840]   - Field: ‘state’
[17:46:44.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.840] - Launch lazy future ...
[17:46:44.840] Packages needed by the future expression (n = 0): <none>
[17:46:44.840] Packages needed by future strategies (n = 0): <none>
[17:46:44.840] {
[17:46:44.840]     {
[17:46:44.840]         {
[17:46:44.840]             ...future.startTime <- base::Sys.time()
[17:46:44.840]             {
[17:46:44.840]                 {
[17:46:44.840]                   {
[17:46:44.840]                     base::local({
[17:46:44.840]                       has_future <- base::requireNamespace("future", 
[17:46:44.840]                         quietly = TRUE)
[17:46:44.840]                       if (has_future) {
[17:46:44.840]                         ns <- base::getNamespace("future")
[17:46:44.840]                         version <- ns[[".package"]][["version"]]
[17:46:44.840]                         if (is.null(version)) 
[17:46:44.840]                           version <- utils::packageVersion("future")
[17:46:44.840]                       }
[17:46:44.840]                       else {
[17:46:44.840]                         version <- NULL
[17:46:44.840]                       }
[17:46:44.840]                       if (!has_future || version < "1.8.0") {
[17:46:44.840]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.840]                           "", base::R.version$version.string), 
[17:46:44.840]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.840]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.840]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.840]                             "release", "version")], collapse = " "), 
[17:46:44.840]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.840]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.840]                           info)
[17:46:44.840]                         info <- base::paste(info, collapse = "; ")
[17:46:44.840]                         if (!has_future) {
[17:46:44.840]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.840]                             info)
[17:46:44.840]                         }
[17:46:44.840]                         else {
[17:46:44.840]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.840]                             info, version)
[17:46:44.840]                         }
[17:46:44.840]                         base::stop(msg)
[17:46:44.840]                       }
[17:46:44.840]                     })
[17:46:44.840]                   }
[17:46:44.840]                   ...future.strategy.old <- future::plan("list")
[17:46:44.840]                   options(future.plan = NULL)
[17:46:44.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.840]                 }
[17:46:44.840]                 ...future.workdir <- getwd()
[17:46:44.840]             }
[17:46:44.840]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.840]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.840]         }
[17:46:44.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.840]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.840]             base::names(...future.oldOptions))
[17:46:44.840]     }
[17:46:44.840]     if (FALSE) {
[17:46:44.840]     }
[17:46:44.840]     else {
[17:46:44.840]         if (TRUE) {
[17:46:44.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.840]                 open = "w")
[17:46:44.840]         }
[17:46:44.840]         else {
[17:46:44.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.840]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.840]         }
[17:46:44.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.840]             base::sink(type = "output", split = FALSE)
[17:46:44.840]             base::close(...future.stdout)
[17:46:44.840]         }, add = TRUE)
[17:46:44.840]     }
[17:46:44.840]     ...future.frame <- base::sys.nframe()
[17:46:44.840]     ...future.conditions <- base::list()
[17:46:44.840]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.840]     if (FALSE) {
[17:46:44.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.840]     }
[17:46:44.840]     ...future.result <- base::tryCatch({
[17:46:44.840]         base::withCallingHandlers({
[17:46:44.840]             ...future.value <- base::withVisible(base::local({
[17:46:44.840]                 4
[17:46:44.840]             }))
[17:46:44.840]             future::FutureResult(value = ...future.value$value, 
[17:46:44.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.840]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.840]                     ...future.globalenv.names))
[17:46:44.840]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.840]         }, condition = base::local({
[17:46:44.840]             c <- base::c
[17:46:44.840]             inherits <- base::inherits
[17:46:44.840]             invokeRestart <- base::invokeRestart
[17:46:44.840]             length <- base::length
[17:46:44.840]             list <- base::list
[17:46:44.840]             seq.int <- base::seq.int
[17:46:44.840]             signalCondition <- base::signalCondition
[17:46:44.840]             sys.calls <- base::sys.calls
[17:46:44.840]             `[[` <- base::`[[`
[17:46:44.840]             `+` <- base::`+`
[17:46:44.840]             `<<-` <- base::`<<-`
[17:46:44.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.840]                   3L)]
[17:46:44.840]             }
[17:46:44.840]             function(cond) {
[17:46:44.840]                 is_error <- inherits(cond, "error")
[17:46:44.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.840]                   NULL)
[17:46:44.840]                 if (is_error) {
[17:46:44.840]                   sessionInformation <- function() {
[17:46:44.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.840]                       search = base::search(), system = base::Sys.info())
[17:46:44.840]                   }
[17:46:44.840]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.840]                     cond$call), session = sessionInformation(), 
[17:46:44.840]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.840]                   signalCondition(cond)
[17:46:44.840]                 }
[17:46:44.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.840]                 "immediateCondition"))) {
[17:46:44.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.840]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.840]                   if (TRUE && !signal) {
[17:46:44.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.840]                     {
[17:46:44.840]                       inherits <- base::inherits
[17:46:44.840]                       invokeRestart <- base::invokeRestart
[17:46:44.840]                       is.null <- base::is.null
[17:46:44.840]                       muffled <- FALSE
[17:46:44.840]                       if (inherits(cond, "message")) {
[17:46:44.840]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.840]                         if (muffled) 
[17:46:44.840]                           invokeRestart("muffleMessage")
[17:46:44.840]                       }
[17:46:44.840]                       else if (inherits(cond, "warning")) {
[17:46:44.840]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.840]                         if (muffled) 
[17:46:44.840]                           invokeRestart("muffleWarning")
[17:46:44.840]                       }
[17:46:44.840]                       else if (inherits(cond, "condition")) {
[17:46:44.840]                         if (!is.null(pattern)) {
[17:46:44.840]                           computeRestarts <- base::computeRestarts
[17:46:44.840]                           grepl <- base::grepl
[17:46:44.840]                           restarts <- computeRestarts(cond)
[17:46:44.840]                           for (restart in restarts) {
[17:46:44.840]                             name <- restart$name
[17:46:44.840]                             if (is.null(name)) 
[17:46:44.840]                               next
[17:46:44.840]                             if (!grepl(pattern, name)) 
[17:46:44.840]                               next
[17:46:44.840]                             invokeRestart(restart)
[17:46:44.840]                             muffled <- TRUE
[17:46:44.840]                             break
[17:46:44.840]                           }
[17:46:44.840]                         }
[17:46:44.840]                       }
[17:46:44.840]                       invisible(muffled)
[17:46:44.840]                     }
[17:46:44.840]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.840]                   }
[17:46:44.840]                 }
[17:46:44.840]                 else {
[17:46:44.840]                   if (TRUE) {
[17:46:44.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.840]                     {
[17:46:44.840]                       inherits <- base::inherits
[17:46:44.840]                       invokeRestart <- base::invokeRestart
[17:46:44.840]                       is.null <- base::is.null
[17:46:44.840]                       muffled <- FALSE
[17:46:44.840]                       if (inherits(cond, "message")) {
[17:46:44.840]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.840]                         if (muffled) 
[17:46:44.840]                           invokeRestart("muffleMessage")
[17:46:44.840]                       }
[17:46:44.840]                       else if (inherits(cond, "warning")) {
[17:46:44.840]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.840]                         if (muffled) 
[17:46:44.840]                           invokeRestart("muffleWarning")
[17:46:44.840]                       }
[17:46:44.840]                       else if (inherits(cond, "condition")) {
[17:46:44.840]                         if (!is.null(pattern)) {
[17:46:44.840]                           computeRestarts <- base::computeRestarts
[17:46:44.840]                           grepl <- base::grepl
[17:46:44.840]                           restarts <- computeRestarts(cond)
[17:46:44.840]                           for (restart in restarts) {
[17:46:44.840]                             name <- restart$name
[17:46:44.840]                             if (is.null(name)) 
[17:46:44.840]                               next
[17:46:44.840]                             if (!grepl(pattern, name)) 
[17:46:44.840]                               next
[17:46:44.840]                             invokeRestart(restart)
[17:46:44.840]                             muffled <- TRUE
[17:46:44.840]                             break
[17:46:44.840]                           }
[17:46:44.840]                         }
[17:46:44.840]                       }
[17:46:44.840]                       invisible(muffled)
[17:46:44.840]                     }
[17:46:44.840]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.840]                   }
[17:46:44.840]                 }
[17:46:44.840]             }
[17:46:44.840]         }))
[17:46:44.840]     }, error = function(ex) {
[17:46:44.840]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.840]                 ...future.rng), started = ...future.startTime, 
[17:46:44.840]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.840]             version = "1.8"), class = "FutureResult")
[17:46:44.840]     }, finally = {
[17:46:44.840]         if (!identical(...future.workdir, getwd())) 
[17:46:44.840]             setwd(...future.workdir)
[17:46:44.840]         {
[17:46:44.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.840]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.840]             }
[17:46:44.840]             base::options(...future.oldOptions)
[17:46:44.840]             if (.Platform$OS.type == "windows") {
[17:46:44.840]                 old_names <- names(...future.oldEnvVars)
[17:46:44.840]                 envs <- base::Sys.getenv()
[17:46:44.840]                 names <- names(envs)
[17:46:44.840]                 common <- intersect(names, old_names)
[17:46:44.840]                 added <- setdiff(names, old_names)
[17:46:44.840]                 removed <- setdiff(old_names, names)
[17:46:44.840]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.840]                   envs[common]]
[17:46:44.840]                 NAMES <- toupper(changed)
[17:46:44.840]                 args <- list()
[17:46:44.840]                 for (kk in seq_along(NAMES)) {
[17:46:44.840]                   name <- changed[[kk]]
[17:46:44.840]                   NAME <- NAMES[[kk]]
[17:46:44.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.840]                     next
[17:46:44.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.840]                 }
[17:46:44.840]                 NAMES <- toupper(added)
[17:46:44.840]                 for (kk in seq_along(NAMES)) {
[17:46:44.840]                   name <- added[[kk]]
[17:46:44.840]                   NAME <- NAMES[[kk]]
[17:46:44.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.840]                     next
[17:46:44.840]                   args[[name]] <- ""
[17:46:44.840]                 }
[17:46:44.840]                 NAMES <- toupper(removed)
[17:46:44.840]                 for (kk in seq_along(NAMES)) {
[17:46:44.840]                   name <- removed[[kk]]
[17:46:44.840]                   NAME <- NAMES[[kk]]
[17:46:44.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.840]                     next
[17:46:44.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.840]                 }
[17:46:44.840]                 if (length(args) > 0) 
[17:46:44.840]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.840]             }
[17:46:44.840]             else {
[17:46:44.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.840]             }
[17:46:44.840]             {
[17:46:44.840]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.840]                   0L) {
[17:46:44.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.840]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.840]                   base::options(opts)
[17:46:44.840]                 }
[17:46:44.840]                 {
[17:46:44.840]                   {
[17:46:44.840]                     NULL
[17:46:44.840]                     RNGkind("Mersenne-Twister")
[17:46:44.840]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.840]                       inherits = FALSE)
[17:46:44.840]                   }
[17:46:44.840]                   options(future.plan = NULL)
[17:46:44.840]                   if (is.na(NA_character_)) 
[17:46:44.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.840]                     .init = FALSE)
[17:46:44.840]                 }
[17:46:44.840]             }
[17:46:44.840]         }
[17:46:44.840]     })
[17:46:44.840]     if (TRUE) {
[17:46:44.840]         base::sink(type = "output", split = FALSE)
[17:46:44.840]         if (TRUE) {
[17:46:44.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.840]         }
[17:46:44.840]         else {
[17:46:44.840]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.840]         }
[17:46:44.840]         base::close(...future.stdout)
[17:46:44.840]         ...future.stdout <- NULL
[17:46:44.840]     }
[17:46:44.840]     ...future.result$conditions <- ...future.conditions
[17:46:44.840]     ...future.result$finished <- base::Sys.time()
[17:46:44.840]     ...future.result
[17:46:44.840] }
[17:46:44.842] plan(): Setting new future strategy stack:
[17:46:44.842] List of future strategies:
[17:46:44.842] 1. sequential:
[17:46:44.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.842]    - tweaked: FALSE
[17:46:44.842]    - call: NULL
[17:46:44.843] plan(): nbrOfWorkers() = 1
[17:46:44.845] plan(): Setting new future strategy stack:
[17:46:44.846] List of future strategies:
[17:46:44.846] 1. sequential:
[17:46:44.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.846]    - tweaked: FALSE
[17:46:44.846]    - call: plan(strategy)
[17:46:44.846] plan(): nbrOfWorkers() = 1
[17:46:44.846] SequentialFuture started (and completed)
[17:46:44.846] - Launch lazy future ... done
[17:46:44.846] run() for ‘SequentialFuture’ ... done
<environment: 0x5617856e0168> 
<environment: 0x561786247290> 
[17:46:44.848] resolved() for ‘SequentialFuture’ ...
[17:46:44.848] - state: ‘finished’
[17:46:44.848] - run: TRUE
[17:46:44.848] - result: ‘FutureResult’
[17:46:44.848] resolved() for ‘SequentialFuture’ ... done
[17:46:44.848] resolved() for ‘SequentialFuture’ ...
[17:46:44.848] - state: ‘finished’
[17:46:44.849] - run: TRUE
[17:46:44.849] - result: ‘FutureResult’
[17:46:44.849] resolved() for ‘SequentialFuture’ ... done
[17:46:44.849] resolved() for ‘SequentialFuture’ ...
[17:46:44.849] - state: ‘finished’
[17:46:44.849] - run: TRUE
[17:46:44.849] - result: ‘FutureResult’
[17:46:44.849] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:44.850] resolve() on environment ...
[17:46:44.850]  recursive: 0
[17:46:44.851]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:44.851] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.851] - nx: 4
[17:46:44.851] - relay: TRUE
[17:46:44.851] - stdout: TRUE
[17:46:44.851] - signal: TRUE
[17:46:44.852] - resignal: FALSE
[17:46:44.852] - force: TRUE
[17:46:44.852] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.852] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.852]  - until=2
[17:46:44.852]  - relaying element #2
[17:46:44.852] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.852] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.852] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.852]  length: 3 (resolved future 1)
[17:46:44.852] resolved() for ‘SequentialFuture’ ...
[17:46:44.852] - state: ‘finished’
[17:46:44.853] - run: TRUE
[17:46:44.853] - result: ‘FutureResult’
[17:46:44.853] resolved() for ‘SequentialFuture’ ... done
[17:46:44.853] Future #2
[17:46:44.853] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.853] - nx: 4
[17:46:44.853] - relay: TRUE
[17:46:44.853] - stdout: TRUE
[17:46:44.853] - signal: TRUE
[17:46:44.853] - resignal: FALSE
[17:46:44.853] - force: TRUE
[17:46:44.854] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:44.854] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:44.854]  - until=2
[17:46:44.854]  - relaying element #2
[17:46:44.854] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.854] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.854] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.854]  length: 2 (resolved future 2)
[17:46:44.854] resolved() for ‘SequentialFuture’ ...
[17:46:44.855] - state: ‘finished’
[17:46:44.855] - run: TRUE
[17:46:44.855] - result: ‘FutureResult’
[17:46:44.855] resolved() for ‘SequentialFuture’ ... done
[17:46:44.855] Future #3
[17:46:44.855] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.855] - nx: 4
[17:46:44.855] - relay: TRUE
[17:46:44.855] - stdout: TRUE
[17:46:44.855] - signal: TRUE
[17:46:44.855] - resignal: FALSE
[17:46:44.856] - force: TRUE
[17:46:44.856] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:44.856] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:44.856]  - until=3
[17:46:44.856]  - relaying element #3
[17:46:44.856] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.856] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.856] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.856]  length: 1 (resolved future 3)
[17:46:44.856] resolved() for ‘SequentialFuture’ ...
[17:46:44.857] - state: ‘finished’
[17:46:44.857] - run: TRUE
[17:46:44.857] - result: ‘FutureResult’
[17:46:44.857] resolved() for ‘SequentialFuture’ ... done
[17:46:44.857] Future #4
[17:46:44.857] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:44.857] - nx: 4
[17:46:44.857] - relay: TRUE
[17:46:44.857] - stdout: TRUE
[17:46:44.857] - signal: TRUE
[17:46:44.857] - resignal: FALSE
[17:46:44.857] - force: TRUE
[17:46:44.858] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:44.858] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:44.858]  - until=4
[17:46:44.858]  - relaying element #4
[17:46:44.858] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.858] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.858] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:44.858]  length: 0 (resolved future 4)
[17:46:44.858] Relaying remaining futures
[17:46:44.858] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.859] - nx: 4
[17:46:44.859] - relay: TRUE
[17:46:44.859] - stdout: TRUE
[17:46:44.859] - signal: TRUE
[17:46:44.859] - resignal: FALSE
[17:46:44.859] - force: TRUE
[17:46:44.859] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.859] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:44.859] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:44.859] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:44.859] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.860] resolve() on environment ... DONE
<environment: 0x561785746eb8> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[17:46:44.860] plan(): Setting new future strategy stack:
[17:46:44.860] List of future strategies:
[17:46:44.860] 1. sequential:
[17:46:44.860]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.860]    - tweaked: FALSE
[17:46:44.860]    - call: plan(strategy)
[17:46:44.861] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:46:44.861] getGlobalsAndPackages() ...
[17:46:44.861] Searching for globals...
[17:46:44.862] 
[17:46:44.862] Searching for globals ... DONE
[17:46:44.862] - globals: [0] <none>
[17:46:44.862] getGlobalsAndPackages() ... DONE
[17:46:44.862] run() for ‘Future’ ...
[17:46:44.862] - state: ‘created’
[17:46:44.862] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.863] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.863] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.863]   - Field: ‘label’
[17:46:44.863]   - Field: ‘local’
[17:46:44.863]   - Field: ‘owner’
[17:46:44.863]   - Field: ‘envir’
[17:46:44.863]   - Field: ‘packages’
[17:46:44.863]   - Field: ‘gc’
[17:46:44.863]   - Field: ‘conditions’
[17:46:44.863]   - Field: ‘expr’
[17:46:44.864]   - Field: ‘uuid’
[17:46:44.864]   - Field: ‘seed’
[17:46:44.864]   - Field: ‘version’
[17:46:44.864]   - Field: ‘result’
[17:46:44.864]   - Field: ‘asynchronous’
[17:46:44.864]   - Field: ‘calls’
[17:46:44.864]   - Field: ‘globals’
[17:46:44.864]   - Field: ‘stdout’
[17:46:44.864]   - Field: ‘earlySignal’
[17:46:44.864]   - Field: ‘lazy’
[17:46:44.864]   - Field: ‘state’
[17:46:44.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.865] - Launch lazy future ...
[17:46:44.865] Packages needed by the future expression (n = 0): <none>
[17:46:44.865] Packages needed by future strategies (n = 0): <none>
[17:46:44.865] {
[17:46:44.865]     {
[17:46:44.865]         {
[17:46:44.865]             ...future.startTime <- base::Sys.time()
[17:46:44.865]             {
[17:46:44.865]                 {
[17:46:44.865]                   {
[17:46:44.865]                     base::local({
[17:46:44.865]                       has_future <- base::requireNamespace("future", 
[17:46:44.865]                         quietly = TRUE)
[17:46:44.865]                       if (has_future) {
[17:46:44.865]                         ns <- base::getNamespace("future")
[17:46:44.865]                         version <- ns[[".package"]][["version"]]
[17:46:44.865]                         if (is.null(version)) 
[17:46:44.865]                           version <- utils::packageVersion("future")
[17:46:44.865]                       }
[17:46:44.865]                       else {
[17:46:44.865]                         version <- NULL
[17:46:44.865]                       }
[17:46:44.865]                       if (!has_future || version < "1.8.0") {
[17:46:44.865]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.865]                           "", base::R.version$version.string), 
[17:46:44.865]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.865]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.865]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.865]                             "release", "version")], collapse = " "), 
[17:46:44.865]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.865]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.865]                           info)
[17:46:44.865]                         info <- base::paste(info, collapse = "; ")
[17:46:44.865]                         if (!has_future) {
[17:46:44.865]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.865]                             info)
[17:46:44.865]                         }
[17:46:44.865]                         else {
[17:46:44.865]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.865]                             info, version)
[17:46:44.865]                         }
[17:46:44.865]                         base::stop(msg)
[17:46:44.865]                       }
[17:46:44.865]                     })
[17:46:44.865]                   }
[17:46:44.865]                   ...future.strategy.old <- future::plan("list")
[17:46:44.865]                   options(future.plan = NULL)
[17:46:44.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.865]                 }
[17:46:44.865]                 ...future.workdir <- getwd()
[17:46:44.865]             }
[17:46:44.865]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.865]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.865]         }
[17:46:44.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.865]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.865]             base::names(...future.oldOptions))
[17:46:44.865]     }
[17:46:44.865]     if (FALSE) {
[17:46:44.865]     }
[17:46:44.865]     else {
[17:46:44.865]         if (TRUE) {
[17:46:44.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.865]                 open = "w")
[17:46:44.865]         }
[17:46:44.865]         else {
[17:46:44.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.865]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.865]         }
[17:46:44.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.865]             base::sink(type = "output", split = FALSE)
[17:46:44.865]             base::close(...future.stdout)
[17:46:44.865]         }, add = TRUE)
[17:46:44.865]     }
[17:46:44.865]     ...future.frame <- base::sys.nframe()
[17:46:44.865]     ...future.conditions <- base::list()
[17:46:44.865]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.865]     if (FALSE) {
[17:46:44.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.865]     }
[17:46:44.865]     ...future.result <- base::tryCatch({
[17:46:44.865]         base::withCallingHandlers({
[17:46:44.865]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.865]             future::FutureResult(value = ...future.value$value, 
[17:46:44.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.865]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.865]                     ...future.globalenv.names))
[17:46:44.865]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.865]         }, condition = base::local({
[17:46:44.865]             c <- base::c
[17:46:44.865]             inherits <- base::inherits
[17:46:44.865]             invokeRestart <- base::invokeRestart
[17:46:44.865]             length <- base::length
[17:46:44.865]             list <- base::list
[17:46:44.865]             seq.int <- base::seq.int
[17:46:44.865]             signalCondition <- base::signalCondition
[17:46:44.865]             sys.calls <- base::sys.calls
[17:46:44.865]             `[[` <- base::`[[`
[17:46:44.865]             `+` <- base::`+`
[17:46:44.865]             `<<-` <- base::`<<-`
[17:46:44.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.865]                   3L)]
[17:46:44.865]             }
[17:46:44.865]             function(cond) {
[17:46:44.865]                 is_error <- inherits(cond, "error")
[17:46:44.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.865]                   NULL)
[17:46:44.865]                 if (is_error) {
[17:46:44.865]                   sessionInformation <- function() {
[17:46:44.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.865]                       search = base::search(), system = base::Sys.info())
[17:46:44.865]                   }
[17:46:44.865]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.865]                     cond$call), session = sessionInformation(), 
[17:46:44.865]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.865]                   signalCondition(cond)
[17:46:44.865]                 }
[17:46:44.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.865]                 "immediateCondition"))) {
[17:46:44.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.865]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.865]                   if (TRUE && !signal) {
[17:46:44.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.865]                     {
[17:46:44.865]                       inherits <- base::inherits
[17:46:44.865]                       invokeRestart <- base::invokeRestart
[17:46:44.865]                       is.null <- base::is.null
[17:46:44.865]                       muffled <- FALSE
[17:46:44.865]                       if (inherits(cond, "message")) {
[17:46:44.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.865]                         if (muffled) 
[17:46:44.865]                           invokeRestart("muffleMessage")
[17:46:44.865]                       }
[17:46:44.865]                       else if (inherits(cond, "warning")) {
[17:46:44.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.865]                         if (muffled) 
[17:46:44.865]                           invokeRestart("muffleWarning")
[17:46:44.865]                       }
[17:46:44.865]                       else if (inherits(cond, "condition")) {
[17:46:44.865]                         if (!is.null(pattern)) {
[17:46:44.865]                           computeRestarts <- base::computeRestarts
[17:46:44.865]                           grepl <- base::grepl
[17:46:44.865]                           restarts <- computeRestarts(cond)
[17:46:44.865]                           for (restart in restarts) {
[17:46:44.865]                             name <- restart$name
[17:46:44.865]                             if (is.null(name)) 
[17:46:44.865]                               next
[17:46:44.865]                             if (!grepl(pattern, name)) 
[17:46:44.865]                               next
[17:46:44.865]                             invokeRestart(restart)
[17:46:44.865]                             muffled <- TRUE
[17:46:44.865]                             break
[17:46:44.865]                           }
[17:46:44.865]                         }
[17:46:44.865]                       }
[17:46:44.865]                       invisible(muffled)
[17:46:44.865]                     }
[17:46:44.865]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.865]                   }
[17:46:44.865]                 }
[17:46:44.865]                 else {
[17:46:44.865]                   if (TRUE) {
[17:46:44.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.865]                     {
[17:46:44.865]                       inherits <- base::inherits
[17:46:44.865]                       invokeRestart <- base::invokeRestart
[17:46:44.865]                       is.null <- base::is.null
[17:46:44.865]                       muffled <- FALSE
[17:46:44.865]                       if (inherits(cond, "message")) {
[17:46:44.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.865]                         if (muffled) 
[17:46:44.865]                           invokeRestart("muffleMessage")
[17:46:44.865]                       }
[17:46:44.865]                       else if (inherits(cond, "warning")) {
[17:46:44.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.865]                         if (muffled) 
[17:46:44.865]                           invokeRestart("muffleWarning")
[17:46:44.865]                       }
[17:46:44.865]                       else if (inherits(cond, "condition")) {
[17:46:44.865]                         if (!is.null(pattern)) {
[17:46:44.865]                           computeRestarts <- base::computeRestarts
[17:46:44.865]                           grepl <- base::grepl
[17:46:44.865]                           restarts <- computeRestarts(cond)
[17:46:44.865]                           for (restart in restarts) {
[17:46:44.865]                             name <- restart$name
[17:46:44.865]                             if (is.null(name)) 
[17:46:44.865]                               next
[17:46:44.865]                             if (!grepl(pattern, name)) 
[17:46:44.865]                               next
[17:46:44.865]                             invokeRestart(restart)
[17:46:44.865]                             muffled <- TRUE
[17:46:44.865]                             break
[17:46:44.865]                           }
[17:46:44.865]                         }
[17:46:44.865]                       }
[17:46:44.865]                       invisible(muffled)
[17:46:44.865]                     }
[17:46:44.865]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.865]                   }
[17:46:44.865]                 }
[17:46:44.865]             }
[17:46:44.865]         }))
[17:46:44.865]     }, error = function(ex) {
[17:46:44.865]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.865]                 ...future.rng), started = ...future.startTime, 
[17:46:44.865]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.865]             version = "1.8"), class = "FutureResult")
[17:46:44.865]     }, finally = {
[17:46:44.865]         if (!identical(...future.workdir, getwd())) 
[17:46:44.865]             setwd(...future.workdir)
[17:46:44.865]         {
[17:46:44.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.865]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.865]             }
[17:46:44.865]             base::options(...future.oldOptions)
[17:46:44.865]             if (.Platform$OS.type == "windows") {
[17:46:44.865]                 old_names <- names(...future.oldEnvVars)
[17:46:44.865]                 envs <- base::Sys.getenv()
[17:46:44.865]                 names <- names(envs)
[17:46:44.865]                 common <- intersect(names, old_names)
[17:46:44.865]                 added <- setdiff(names, old_names)
[17:46:44.865]                 removed <- setdiff(old_names, names)
[17:46:44.865]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.865]                   envs[common]]
[17:46:44.865]                 NAMES <- toupper(changed)
[17:46:44.865]                 args <- list()
[17:46:44.865]                 for (kk in seq_along(NAMES)) {
[17:46:44.865]                   name <- changed[[kk]]
[17:46:44.865]                   NAME <- NAMES[[kk]]
[17:46:44.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.865]                     next
[17:46:44.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.865]                 }
[17:46:44.865]                 NAMES <- toupper(added)
[17:46:44.865]                 for (kk in seq_along(NAMES)) {
[17:46:44.865]                   name <- added[[kk]]
[17:46:44.865]                   NAME <- NAMES[[kk]]
[17:46:44.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.865]                     next
[17:46:44.865]                   args[[name]] <- ""
[17:46:44.865]                 }
[17:46:44.865]                 NAMES <- toupper(removed)
[17:46:44.865]                 for (kk in seq_along(NAMES)) {
[17:46:44.865]                   name <- removed[[kk]]
[17:46:44.865]                   NAME <- NAMES[[kk]]
[17:46:44.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.865]                     next
[17:46:44.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.865]                 }
[17:46:44.865]                 if (length(args) > 0) 
[17:46:44.865]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.865]             }
[17:46:44.865]             else {
[17:46:44.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.865]             }
[17:46:44.865]             {
[17:46:44.865]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.865]                   0L) {
[17:46:44.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.865]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.865]                   base::options(opts)
[17:46:44.865]                 }
[17:46:44.865]                 {
[17:46:44.865]                   {
[17:46:44.865]                     NULL
[17:46:44.865]                     RNGkind("Mersenne-Twister")
[17:46:44.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.865]                       inherits = FALSE)
[17:46:44.865]                   }
[17:46:44.865]                   options(future.plan = NULL)
[17:46:44.865]                   if (is.na(NA_character_)) 
[17:46:44.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.865]                     .init = FALSE)
[17:46:44.865]                 }
[17:46:44.865]             }
[17:46:44.865]         }
[17:46:44.865]     })
[17:46:44.865]     if (TRUE) {
[17:46:44.865]         base::sink(type = "output", split = FALSE)
[17:46:44.865]         if (TRUE) {
[17:46:44.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.865]         }
[17:46:44.865]         else {
[17:46:44.865]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.865]         }
[17:46:44.865]         base::close(...future.stdout)
[17:46:44.865]         ...future.stdout <- NULL
[17:46:44.865]     }
[17:46:44.865]     ...future.result$conditions <- ...future.conditions
[17:46:44.865]     ...future.result$finished <- base::Sys.time()
[17:46:44.865]     ...future.result
[17:46:44.865] }
[17:46:44.867] plan(): Setting new future strategy stack:
[17:46:44.867] List of future strategies:
[17:46:44.867] 1. sequential:
[17:46:44.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.867]    - tweaked: FALSE
[17:46:44.867]    - call: NULL
[17:46:44.868] plan(): nbrOfWorkers() = 1
[17:46:44.868] plan(): Setting new future strategy stack:
[17:46:44.868] List of future strategies:
[17:46:44.868] 1. sequential:
[17:46:44.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.868]    - tweaked: FALSE
[17:46:44.868]    - call: plan(strategy)
[17:46:44.869] plan(): nbrOfWorkers() = 1
[17:46:44.869] SequentialFuture started (and completed)
[17:46:44.869] - Launch lazy future ... done
[17:46:44.869] run() for ‘SequentialFuture’ ... done
[17:46:44.869] getGlobalsAndPackages() ...
[17:46:44.869] Searching for globals...
[17:46:44.870] 
[17:46:44.870] Searching for globals ... DONE
[17:46:44.870] - globals: [0] <none>
[17:46:44.870] getGlobalsAndPackages() ... DONE
[17:46:44.870] run() for ‘Future’ ...
[17:46:44.870] - state: ‘created’
[17:46:44.870] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.871] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.871]   - Field: ‘label’
[17:46:44.871]   - Field: ‘local’
[17:46:44.873]   - Field: ‘owner’
[17:46:44.873]   - Field: ‘envir’
[17:46:44.873]   - Field: ‘packages’
[17:46:44.873]   - Field: ‘gc’
[17:46:44.873]   - Field: ‘conditions’
[17:46:44.874]   - Field: ‘expr’
[17:46:44.874]   - Field: ‘uuid’
[17:46:44.874]   - Field: ‘seed’
[17:46:44.874]   - Field: ‘version’
[17:46:44.874]   - Field: ‘result’
[17:46:44.874]   - Field: ‘asynchronous’
[17:46:44.874]   - Field: ‘calls’
[17:46:44.874]   - Field: ‘globals’
[17:46:44.874]   - Field: ‘stdout’
[17:46:44.874]   - Field: ‘earlySignal’
[17:46:44.874]   - Field: ‘lazy’
[17:46:44.875]   - Field: ‘state’
[17:46:44.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.875] - Launch lazy future ...
[17:46:44.875] Packages needed by the future expression (n = 0): <none>
[17:46:44.875] Packages needed by future strategies (n = 0): <none>
[17:46:44.875] {
[17:46:44.875]     {
[17:46:44.875]         {
[17:46:44.875]             ...future.startTime <- base::Sys.time()
[17:46:44.875]             {
[17:46:44.875]                 {
[17:46:44.875]                   {
[17:46:44.875]                     base::local({
[17:46:44.875]                       has_future <- base::requireNamespace("future", 
[17:46:44.875]                         quietly = TRUE)
[17:46:44.875]                       if (has_future) {
[17:46:44.875]                         ns <- base::getNamespace("future")
[17:46:44.875]                         version <- ns[[".package"]][["version"]]
[17:46:44.875]                         if (is.null(version)) 
[17:46:44.875]                           version <- utils::packageVersion("future")
[17:46:44.875]                       }
[17:46:44.875]                       else {
[17:46:44.875]                         version <- NULL
[17:46:44.875]                       }
[17:46:44.875]                       if (!has_future || version < "1.8.0") {
[17:46:44.875]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.875]                           "", base::R.version$version.string), 
[17:46:44.875]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.875]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.875]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.875]                             "release", "version")], collapse = " "), 
[17:46:44.875]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.875]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.875]                           info)
[17:46:44.875]                         info <- base::paste(info, collapse = "; ")
[17:46:44.875]                         if (!has_future) {
[17:46:44.875]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.875]                             info)
[17:46:44.875]                         }
[17:46:44.875]                         else {
[17:46:44.875]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.875]                             info, version)
[17:46:44.875]                         }
[17:46:44.875]                         base::stop(msg)
[17:46:44.875]                       }
[17:46:44.875]                     })
[17:46:44.875]                   }
[17:46:44.875]                   ...future.strategy.old <- future::plan("list")
[17:46:44.875]                   options(future.plan = NULL)
[17:46:44.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.875]                 }
[17:46:44.875]                 ...future.workdir <- getwd()
[17:46:44.875]             }
[17:46:44.875]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.875]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.875]         }
[17:46:44.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.875]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.875]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.875]             base::names(...future.oldOptions))
[17:46:44.875]     }
[17:46:44.875]     if (FALSE) {
[17:46:44.875]     }
[17:46:44.875]     else {
[17:46:44.875]         if (TRUE) {
[17:46:44.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.875]                 open = "w")
[17:46:44.875]         }
[17:46:44.875]         else {
[17:46:44.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.875]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.875]         }
[17:46:44.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.875]             base::sink(type = "output", split = FALSE)
[17:46:44.875]             base::close(...future.stdout)
[17:46:44.875]         }, add = TRUE)
[17:46:44.875]     }
[17:46:44.875]     ...future.frame <- base::sys.nframe()
[17:46:44.875]     ...future.conditions <- base::list()
[17:46:44.875]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.875]     if (FALSE) {
[17:46:44.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.875]     }
[17:46:44.875]     ...future.result <- base::tryCatch({
[17:46:44.875]         base::withCallingHandlers({
[17:46:44.875]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.875]             future::FutureResult(value = ...future.value$value, 
[17:46:44.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.875]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.875]                     ...future.globalenv.names))
[17:46:44.875]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.875]         }, condition = base::local({
[17:46:44.875]             c <- base::c
[17:46:44.875]             inherits <- base::inherits
[17:46:44.875]             invokeRestart <- base::invokeRestart
[17:46:44.875]             length <- base::length
[17:46:44.875]             list <- base::list
[17:46:44.875]             seq.int <- base::seq.int
[17:46:44.875]             signalCondition <- base::signalCondition
[17:46:44.875]             sys.calls <- base::sys.calls
[17:46:44.875]             `[[` <- base::`[[`
[17:46:44.875]             `+` <- base::`+`
[17:46:44.875]             `<<-` <- base::`<<-`
[17:46:44.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.875]                   3L)]
[17:46:44.875]             }
[17:46:44.875]             function(cond) {
[17:46:44.875]                 is_error <- inherits(cond, "error")
[17:46:44.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.875]                   NULL)
[17:46:44.875]                 if (is_error) {
[17:46:44.875]                   sessionInformation <- function() {
[17:46:44.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.875]                       search = base::search(), system = base::Sys.info())
[17:46:44.875]                   }
[17:46:44.875]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.875]                     cond$call), session = sessionInformation(), 
[17:46:44.875]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.875]                   signalCondition(cond)
[17:46:44.875]                 }
[17:46:44.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.875]                 "immediateCondition"))) {
[17:46:44.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.875]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.875]                   if (TRUE && !signal) {
[17:46:44.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.875]                     {
[17:46:44.875]                       inherits <- base::inherits
[17:46:44.875]                       invokeRestart <- base::invokeRestart
[17:46:44.875]                       is.null <- base::is.null
[17:46:44.875]                       muffled <- FALSE
[17:46:44.875]                       if (inherits(cond, "message")) {
[17:46:44.875]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.875]                         if (muffled) 
[17:46:44.875]                           invokeRestart("muffleMessage")
[17:46:44.875]                       }
[17:46:44.875]                       else if (inherits(cond, "warning")) {
[17:46:44.875]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.875]                         if (muffled) 
[17:46:44.875]                           invokeRestart("muffleWarning")
[17:46:44.875]                       }
[17:46:44.875]                       else if (inherits(cond, "condition")) {
[17:46:44.875]                         if (!is.null(pattern)) {
[17:46:44.875]                           computeRestarts <- base::computeRestarts
[17:46:44.875]                           grepl <- base::grepl
[17:46:44.875]                           restarts <- computeRestarts(cond)
[17:46:44.875]                           for (restart in restarts) {
[17:46:44.875]                             name <- restart$name
[17:46:44.875]                             if (is.null(name)) 
[17:46:44.875]                               next
[17:46:44.875]                             if (!grepl(pattern, name)) 
[17:46:44.875]                               next
[17:46:44.875]                             invokeRestart(restart)
[17:46:44.875]                             muffled <- TRUE
[17:46:44.875]                             break
[17:46:44.875]                           }
[17:46:44.875]                         }
[17:46:44.875]                       }
[17:46:44.875]                       invisible(muffled)
[17:46:44.875]                     }
[17:46:44.875]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.875]                   }
[17:46:44.875]                 }
[17:46:44.875]                 else {
[17:46:44.875]                   if (TRUE) {
[17:46:44.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.875]                     {
[17:46:44.875]                       inherits <- base::inherits
[17:46:44.875]                       invokeRestart <- base::invokeRestart
[17:46:44.875]                       is.null <- base::is.null
[17:46:44.875]                       muffled <- FALSE
[17:46:44.875]                       if (inherits(cond, "message")) {
[17:46:44.875]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.875]                         if (muffled) 
[17:46:44.875]                           invokeRestart("muffleMessage")
[17:46:44.875]                       }
[17:46:44.875]                       else if (inherits(cond, "warning")) {
[17:46:44.875]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.875]                         if (muffled) 
[17:46:44.875]                           invokeRestart("muffleWarning")
[17:46:44.875]                       }
[17:46:44.875]                       else if (inherits(cond, "condition")) {
[17:46:44.875]                         if (!is.null(pattern)) {
[17:46:44.875]                           computeRestarts <- base::computeRestarts
[17:46:44.875]                           grepl <- base::grepl
[17:46:44.875]                           restarts <- computeRestarts(cond)
[17:46:44.875]                           for (restart in restarts) {
[17:46:44.875]                             name <- restart$name
[17:46:44.875]                             if (is.null(name)) 
[17:46:44.875]                               next
[17:46:44.875]                             if (!grepl(pattern, name)) 
[17:46:44.875]                               next
[17:46:44.875]                             invokeRestart(restart)
[17:46:44.875]                             muffled <- TRUE
[17:46:44.875]                             break
[17:46:44.875]                           }
[17:46:44.875]                         }
[17:46:44.875]                       }
[17:46:44.875]                       invisible(muffled)
[17:46:44.875]                     }
[17:46:44.875]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.875]                   }
[17:46:44.875]                 }
[17:46:44.875]             }
[17:46:44.875]         }))
[17:46:44.875]     }, error = function(ex) {
[17:46:44.875]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.875]                 ...future.rng), started = ...future.startTime, 
[17:46:44.875]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.875]             version = "1.8"), class = "FutureResult")
[17:46:44.875]     }, finally = {
[17:46:44.875]         if (!identical(...future.workdir, getwd())) 
[17:46:44.875]             setwd(...future.workdir)
[17:46:44.875]         {
[17:46:44.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.875]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.875]             }
[17:46:44.875]             base::options(...future.oldOptions)
[17:46:44.875]             if (.Platform$OS.type == "windows") {
[17:46:44.875]                 old_names <- names(...future.oldEnvVars)
[17:46:44.875]                 envs <- base::Sys.getenv()
[17:46:44.875]                 names <- names(envs)
[17:46:44.875]                 common <- intersect(names, old_names)
[17:46:44.875]                 added <- setdiff(names, old_names)
[17:46:44.875]                 removed <- setdiff(old_names, names)
[17:46:44.875]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.875]                   envs[common]]
[17:46:44.875]                 NAMES <- toupper(changed)
[17:46:44.875]                 args <- list()
[17:46:44.875]                 for (kk in seq_along(NAMES)) {
[17:46:44.875]                   name <- changed[[kk]]
[17:46:44.875]                   NAME <- NAMES[[kk]]
[17:46:44.875]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.875]                     next
[17:46:44.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.875]                 }
[17:46:44.875]                 NAMES <- toupper(added)
[17:46:44.875]                 for (kk in seq_along(NAMES)) {
[17:46:44.875]                   name <- added[[kk]]
[17:46:44.875]                   NAME <- NAMES[[kk]]
[17:46:44.875]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.875]                     next
[17:46:44.875]                   args[[name]] <- ""
[17:46:44.875]                 }
[17:46:44.875]                 NAMES <- toupper(removed)
[17:46:44.875]                 for (kk in seq_along(NAMES)) {
[17:46:44.875]                   name <- removed[[kk]]
[17:46:44.875]                   NAME <- NAMES[[kk]]
[17:46:44.875]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.875]                     next
[17:46:44.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.875]                 }
[17:46:44.875]                 if (length(args) > 0) 
[17:46:44.875]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.875]             }
[17:46:44.875]             else {
[17:46:44.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.875]             }
[17:46:44.875]             {
[17:46:44.875]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.875]                   0L) {
[17:46:44.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.875]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.875]                   base::options(opts)
[17:46:44.875]                 }
[17:46:44.875]                 {
[17:46:44.875]                   {
[17:46:44.875]                     NULL
[17:46:44.875]                     RNGkind("Mersenne-Twister")
[17:46:44.875]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.875]                       inherits = FALSE)
[17:46:44.875]                   }
[17:46:44.875]                   options(future.plan = NULL)
[17:46:44.875]                   if (is.na(NA_character_)) 
[17:46:44.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.875]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.875]                     .init = FALSE)
[17:46:44.875]                 }
[17:46:44.875]             }
[17:46:44.875]         }
[17:46:44.875]     })
[17:46:44.875]     if (TRUE) {
[17:46:44.875]         base::sink(type = "output", split = FALSE)
[17:46:44.875]         if (TRUE) {
[17:46:44.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.875]         }
[17:46:44.875]         else {
[17:46:44.875]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.875]         }
[17:46:44.875]         base::close(...future.stdout)
[17:46:44.875]         ...future.stdout <- NULL
[17:46:44.875]     }
[17:46:44.875]     ...future.result$conditions <- ...future.conditions
[17:46:44.875]     ...future.result$finished <- base::Sys.time()
[17:46:44.875]     ...future.result
[17:46:44.875] }
[17:46:44.877] plan(): Setting new future strategy stack:
[17:46:44.877] List of future strategies:
[17:46:44.877] 1. sequential:
[17:46:44.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.877]    - tweaked: FALSE
[17:46:44.877]    - call: NULL
[17:46:44.878] plan(): nbrOfWorkers() = 1
[17:46:44.878] plan(): Setting new future strategy stack:
[17:46:44.878] List of future strategies:
[17:46:44.878] 1. sequential:
[17:46:44.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.878]    - tweaked: FALSE
[17:46:44.878]    - call: plan(strategy)
[17:46:44.879] plan(): nbrOfWorkers() = 1
[17:46:44.879] SequentialFuture started (and completed)
[17:46:44.879] - Launch lazy future ... done
[17:46:44.879] run() for ‘SequentialFuture’ ... done
[17:46:44.880] getGlobalsAndPackages() ...
[17:46:44.880] Searching for globals...
[17:46:44.881] - globals found: [1] ‘{’
[17:46:44.881] Searching for globals ... DONE
[17:46:44.881] Resolving globals: FALSE
[17:46:44.881] 
[17:46:44.881] 
[17:46:44.881] getGlobalsAndPackages() ... DONE
[17:46:44.881] run() for ‘Future’ ...
[17:46:44.882] - state: ‘created’
[17:46:44.882] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.882] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.882]   - Field: ‘label’
[17:46:44.882]   - Field: ‘local’
[17:46:44.882]   - Field: ‘owner’
[17:46:44.882]   - Field: ‘envir’
[17:46:44.883]   - Field: ‘packages’
[17:46:44.883]   - Field: ‘gc’
[17:46:44.883]   - Field: ‘conditions’
[17:46:44.883]   - Field: ‘expr’
[17:46:44.883]   - Field: ‘uuid’
[17:46:44.883]   - Field: ‘seed’
[17:46:44.883]   - Field: ‘version’
[17:46:44.883]   - Field: ‘result’
[17:46:44.883]   - Field: ‘asynchronous’
[17:46:44.883]   - Field: ‘calls’
[17:46:44.883]   - Field: ‘globals’
[17:46:44.884]   - Field: ‘stdout’
[17:46:44.884]   - Field: ‘earlySignal’
[17:46:44.884]   - Field: ‘lazy’
[17:46:44.884]   - Field: ‘state’
[17:46:44.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.884] - Launch lazy future ...
[17:46:44.884] Packages needed by the future expression (n = 0): <none>
[17:46:44.884] Packages needed by future strategies (n = 0): <none>
[17:46:44.885] {
[17:46:44.885]     {
[17:46:44.885]         {
[17:46:44.885]             ...future.startTime <- base::Sys.time()
[17:46:44.885]             {
[17:46:44.885]                 {
[17:46:44.885]                   {
[17:46:44.885]                     base::local({
[17:46:44.885]                       has_future <- base::requireNamespace("future", 
[17:46:44.885]                         quietly = TRUE)
[17:46:44.885]                       if (has_future) {
[17:46:44.885]                         ns <- base::getNamespace("future")
[17:46:44.885]                         version <- ns[[".package"]][["version"]]
[17:46:44.885]                         if (is.null(version)) 
[17:46:44.885]                           version <- utils::packageVersion("future")
[17:46:44.885]                       }
[17:46:44.885]                       else {
[17:46:44.885]                         version <- NULL
[17:46:44.885]                       }
[17:46:44.885]                       if (!has_future || version < "1.8.0") {
[17:46:44.885]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.885]                           "", base::R.version$version.string), 
[17:46:44.885]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.885]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.885]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.885]                             "release", "version")], collapse = " "), 
[17:46:44.885]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.885]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.885]                           info)
[17:46:44.885]                         info <- base::paste(info, collapse = "; ")
[17:46:44.885]                         if (!has_future) {
[17:46:44.885]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.885]                             info)
[17:46:44.885]                         }
[17:46:44.885]                         else {
[17:46:44.885]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.885]                             info, version)
[17:46:44.885]                         }
[17:46:44.885]                         base::stop(msg)
[17:46:44.885]                       }
[17:46:44.885]                     })
[17:46:44.885]                   }
[17:46:44.885]                   ...future.strategy.old <- future::plan("list")
[17:46:44.885]                   options(future.plan = NULL)
[17:46:44.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.885]                 }
[17:46:44.885]                 ...future.workdir <- getwd()
[17:46:44.885]             }
[17:46:44.885]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.885]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.885]         }
[17:46:44.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.885]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.885]             base::names(...future.oldOptions))
[17:46:44.885]     }
[17:46:44.885]     if (FALSE) {
[17:46:44.885]     }
[17:46:44.885]     else {
[17:46:44.885]         if (TRUE) {
[17:46:44.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.885]                 open = "w")
[17:46:44.885]         }
[17:46:44.885]         else {
[17:46:44.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.885]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.885]         }
[17:46:44.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.885]             base::sink(type = "output", split = FALSE)
[17:46:44.885]             base::close(...future.stdout)
[17:46:44.885]         }, add = TRUE)
[17:46:44.885]     }
[17:46:44.885]     ...future.frame <- base::sys.nframe()
[17:46:44.885]     ...future.conditions <- base::list()
[17:46:44.885]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.885]     if (FALSE) {
[17:46:44.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.885]     }
[17:46:44.885]     ...future.result <- base::tryCatch({
[17:46:44.885]         base::withCallingHandlers({
[17:46:44.885]             ...future.value <- base::withVisible(base::local({
[17:46:44.885]                 4
[17:46:44.885]             }))
[17:46:44.885]             future::FutureResult(value = ...future.value$value, 
[17:46:44.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.885]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.885]                     ...future.globalenv.names))
[17:46:44.885]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.885]         }, condition = base::local({
[17:46:44.885]             c <- base::c
[17:46:44.885]             inherits <- base::inherits
[17:46:44.885]             invokeRestart <- base::invokeRestart
[17:46:44.885]             length <- base::length
[17:46:44.885]             list <- base::list
[17:46:44.885]             seq.int <- base::seq.int
[17:46:44.885]             signalCondition <- base::signalCondition
[17:46:44.885]             sys.calls <- base::sys.calls
[17:46:44.885]             `[[` <- base::`[[`
[17:46:44.885]             `+` <- base::`+`
[17:46:44.885]             `<<-` <- base::`<<-`
[17:46:44.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.885]                   3L)]
[17:46:44.885]             }
[17:46:44.885]             function(cond) {
[17:46:44.885]                 is_error <- inherits(cond, "error")
[17:46:44.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.885]                   NULL)
[17:46:44.885]                 if (is_error) {
[17:46:44.885]                   sessionInformation <- function() {
[17:46:44.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.885]                       search = base::search(), system = base::Sys.info())
[17:46:44.885]                   }
[17:46:44.885]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.885]                     cond$call), session = sessionInformation(), 
[17:46:44.885]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.885]                   signalCondition(cond)
[17:46:44.885]                 }
[17:46:44.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.885]                 "immediateCondition"))) {
[17:46:44.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.885]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.885]                   if (TRUE && !signal) {
[17:46:44.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.885]                     {
[17:46:44.885]                       inherits <- base::inherits
[17:46:44.885]                       invokeRestart <- base::invokeRestart
[17:46:44.885]                       is.null <- base::is.null
[17:46:44.885]                       muffled <- FALSE
[17:46:44.885]                       if (inherits(cond, "message")) {
[17:46:44.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.885]                         if (muffled) 
[17:46:44.885]                           invokeRestart("muffleMessage")
[17:46:44.885]                       }
[17:46:44.885]                       else if (inherits(cond, "warning")) {
[17:46:44.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.885]                         if (muffled) 
[17:46:44.885]                           invokeRestart("muffleWarning")
[17:46:44.885]                       }
[17:46:44.885]                       else if (inherits(cond, "condition")) {
[17:46:44.885]                         if (!is.null(pattern)) {
[17:46:44.885]                           computeRestarts <- base::computeRestarts
[17:46:44.885]                           grepl <- base::grepl
[17:46:44.885]                           restarts <- computeRestarts(cond)
[17:46:44.885]                           for (restart in restarts) {
[17:46:44.885]                             name <- restart$name
[17:46:44.885]                             if (is.null(name)) 
[17:46:44.885]                               next
[17:46:44.885]                             if (!grepl(pattern, name)) 
[17:46:44.885]                               next
[17:46:44.885]                             invokeRestart(restart)
[17:46:44.885]                             muffled <- TRUE
[17:46:44.885]                             break
[17:46:44.885]                           }
[17:46:44.885]                         }
[17:46:44.885]                       }
[17:46:44.885]                       invisible(muffled)
[17:46:44.885]                     }
[17:46:44.885]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.885]                   }
[17:46:44.885]                 }
[17:46:44.885]                 else {
[17:46:44.885]                   if (TRUE) {
[17:46:44.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.885]                     {
[17:46:44.885]                       inherits <- base::inherits
[17:46:44.885]                       invokeRestart <- base::invokeRestart
[17:46:44.885]                       is.null <- base::is.null
[17:46:44.885]                       muffled <- FALSE
[17:46:44.885]                       if (inherits(cond, "message")) {
[17:46:44.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.885]                         if (muffled) 
[17:46:44.885]                           invokeRestart("muffleMessage")
[17:46:44.885]                       }
[17:46:44.885]                       else if (inherits(cond, "warning")) {
[17:46:44.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.885]                         if (muffled) 
[17:46:44.885]                           invokeRestart("muffleWarning")
[17:46:44.885]                       }
[17:46:44.885]                       else if (inherits(cond, "condition")) {
[17:46:44.885]                         if (!is.null(pattern)) {
[17:46:44.885]                           computeRestarts <- base::computeRestarts
[17:46:44.885]                           grepl <- base::grepl
[17:46:44.885]                           restarts <- computeRestarts(cond)
[17:46:44.885]                           for (restart in restarts) {
[17:46:44.885]                             name <- restart$name
[17:46:44.885]                             if (is.null(name)) 
[17:46:44.885]                               next
[17:46:44.885]                             if (!grepl(pattern, name)) 
[17:46:44.885]                               next
[17:46:44.885]                             invokeRestart(restart)
[17:46:44.885]                             muffled <- TRUE
[17:46:44.885]                             break
[17:46:44.885]                           }
[17:46:44.885]                         }
[17:46:44.885]                       }
[17:46:44.885]                       invisible(muffled)
[17:46:44.885]                     }
[17:46:44.885]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.885]                   }
[17:46:44.885]                 }
[17:46:44.885]             }
[17:46:44.885]         }))
[17:46:44.885]     }, error = function(ex) {
[17:46:44.885]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.885]                 ...future.rng), started = ...future.startTime, 
[17:46:44.885]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.885]             version = "1.8"), class = "FutureResult")
[17:46:44.885]     }, finally = {
[17:46:44.885]         if (!identical(...future.workdir, getwd())) 
[17:46:44.885]             setwd(...future.workdir)
[17:46:44.885]         {
[17:46:44.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.885]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.885]             }
[17:46:44.885]             base::options(...future.oldOptions)
[17:46:44.885]             if (.Platform$OS.type == "windows") {
[17:46:44.885]                 old_names <- names(...future.oldEnvVars)
[17:46:44.885]                 envs <- base::Sys.getenv()
[17:46:44.885]                 names <- names(envs)
[17:46:44.885]                 common <- intersect(names, old_names)
[17:46:44.885]                 added <- setdiff(names, old_names)
[17:46:44.885]                 removed <- setdiff(old_names, names)
[17:46:44.885]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.885]                   envs[common]]
[17:46:44.885]                 NAMES <- toupper(changed)
[17:46:44.885]                 args <- list()
[17:46:44.885]                 for (kk in seq_along(NAMES)) {
[17:46:44.885]                   name <- changed[[kk]]
[17:46:44.885]                   NAME <- NAMES[[kk]]
[17:46:44.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.885]                     next
[17:46:44.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.885]                 }
[17:46:44.885]                 NAMES <- toupper(added)
[17:46:44.885]                 for (kk in seq_along(NAMES)) {
[17:46:44.885]                   name <- added[[kk]]
[17:46:44.885]                   NAME <- NAMES[[kk]]
[17:46:44.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.885]                     next
[17:46:44.885]                   args[[name]] <- ""
[17:46:44.885]                 }
[17:46:44.885]                 NAMES <- toupper(removed)
[17:46:44.885]                 for (kk in seq_along(NAMES)) {
[17:46:44.885]                   name <- removed[[kk]]
[17:46:44.885]                   NAME <- NAMES[[kk]]
[17:46:44.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.885]                     next
[17:46:44.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.885]                 }
[17:46:44.885]                 if (length(args) > 0) 
[17:46:44.885]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.885]             }
[17:46:44.885]             else {
[17:46:44.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.885]             }
[17:46:44.885]             {
[17:46:44.885]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.885]                   0L) {
[17:46:44.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.885]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.885]                   base::options(opts)
[17:46:44.885]                 }
[17:46:44.885]                 {
[17:46:44.885]                   {
[17:46:44.885]                     NULL
[17:46:44.885]                     RNGkind("Mersenne-Twister")
[17:46:44.885]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.885]                       inherits = FALSE)
[17:46:44.885]                   }
[17:46:44.885]                   options(future.plan = NULL)
[17:46:44.885]                   if (is.na(NA_character_)) 
[17:46:44.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.885]                     .init = FALSE)
[17:46:44.885]                 }
[17:46:44.885]             }
[17:46:44.885]         }
[17:46:44.885]     })
[17:46:44.885]     if (TRUE) {
[17:46:44.885]         base::sink(type = "output", split = FALSE)
[17:46:44.885]         if (TRUE) {
[17:46:44.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.885]         }
[17:46:44.885]         else {
[17:46:44.885]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.885]         }
[17:46:44.885]         base::close(...future.stdout)
[17:46:44.885]         ...future.stdout <- NULL
[17:46:44.885]     }
[17:46:44.885]     ...future.result$conditions <- ...future.conditions
[17:46:44.885]     ...future.result$finished <- base::Sys.time()
[17:46:44.885]     ...future.result
[17:46:44.885] }
[17:46:44.886] plan(): Setting new future strategy stack:
[17:46:44.886] List of future strategies:
[17:46:44.886] 1. sequential:
[17:46:44.886]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.886]    - tweaked: FALSE
[17:46:44.886]    - call: NULL
[17:46:44.887] plan(): nbrOfWorkers() = 1
[17:46:44.888] plan(): Setting new future strategy stack:
[17:46:44.888] List of future strategies:
[17:46:44.888] 1. sequential:
[17:46:44.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.888]    - tweaked: FALSE
[17:46:44.888]    - call: plan(strategy)
[17:46:44.888] plan(): nbrOfWorkers() = 1
[17:46:44.888] SequentialFuture started (and completed)
[17:46:44.888] - Launch lazy future ... done
[17:46:44.888] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x561787ad56d0> 
Classes 'listenv', 'environment' <environment: 0x561787929478> 
[17:46:44.891] resolved() for ‘SequentialFuture’ ...
[17:46:44.892] - state: ‘finished’
[17:46:44.892] - run: TRUE
[17:46:44.892] - result: ‘FutureResult’
[17:46:44.892] resolved() for ‘SequentialFuture’ ... done
[17:46:44.892] resolved() for ‘SequentialFuture’ ...
[17:46:44.892] - state: ‘finished’
[17:46:44.892] - run: TRUE
[17:46:44.892] - result: ‘FutureResult’
[17:46:44.892] resolved() for ‘SequentialFuture’ ... done
[17:46:44.892] resolved() for ‘SequentialFuture’ ...
[17:46:44.892] - state: ‘finished’
[17:46:44.893] - run: TRUE
[17:46:44.893] - result: ‘FutureResult’
[17:46:44.893] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:44.894] resolve() on list environment ...
[17:46:44.895]  recursive: 0
[17:46:44.895]  length: 6
[17:46:44.896]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:44.896] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.896] - nx: 6
[17:46:44.896] - relay: TRUE
[17:46:44.896] - stdout: TRUE
[17:46:44.896] - signal: TRUE
[17:46:44.896] - resignal: FALSE
[17:46:44.896] - force: TRUE
[17:46:44.896] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.896] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.896]  - until=2
[17:46:44.897]  - relaying element #2
[17:46:44.897] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.897] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.897] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.897]  length: 5 (resolved future 1)
[17:46:44.897] resolved() for ‘SequentialFuture’ ...
[17:46:44.897] - state: ‘finished’
[17:46:44.897] - run: TRUE
[17:46:44.897] - result: ‘FutureResult’
[17:46:44.897] resolved() for ‘SequentialFuture’ ... done
[17:46:44.897] Future #2
[17:46:44.898] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.898] - nx: 6
[17:46:44.898] - relay: TRUE
[17:46:44.898] - stdout: TRUE
[17:46:44.898] - signal: TRUE
[17:46:44.898] - resignal: FALSE
[17:46:44.898] - force: TRUE
[17:46:44.898] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.898] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.898]  - until=2
[17:46:44.898]  - relaying element #2
[17:46:44.899] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.899] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.899] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.899]  length: 4 (resolved future 2)
[17:46:44.899] resolved() for ‘SequentialFuture’ ...
[17:46:44.899] - state: ‘finished’
[17:46:44.899] - run: TRUE
[17:46:44.899] - result: ‘FutureResult’
[17:46:44.899] resolved() for ‘SequentialFuture’ ... done
[17:46:44.901] Future #3
[17:46:44.902] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.902] - nx: 6
[17:46:44.902] - relay: TRUE
[17:46:44.902] - stdout: TRUE
[17:46:44.902] - signal: TRUE
[17:46:44.902] - resignal: FALSE
[17:46:44.902] - force: TRUE
[17:46:44.902] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.902] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.902]  - until=3
[17:46:44.902]  - relaying element #3
[17:46:44.903] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.903] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.903]  length: 3 (resolved future 3)
[17:46:44.903] resolved() for ‘SequentialFuture’ ...
[17:46:44.903] - state: ‘finished’
[17:46:44.903] - run: TRUE
[17:46:44.903] - result: ‘FutureResult’
[17:46:44.903] resolved() for ‘SequentialFuture’ ... done
[17:46:44.904] Future #4
[17:46:44.904] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:44.904] - nx: 6
[17:46:44.904] - relay: TRUE
[17:46:44.904] - stdout: TRUE
[17:46:44.904] - signal: TRUE
[17:46:44.904] - resignal: FALSE
[17:46:44.904] - force: TRUE
[17:46:44.904] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.904]  - until=4
[17:46:44.904]  - relaying element #4
[17:46:44.905] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.905] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.905] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:44.905]  length: 2 (resolved future 4)
[17:46:44.905] signalConditionsASAP(NULL, pos=5) ...
[17:46:44.905] - nx: 6
[17:46:44.905] - relay: TRUE
[17:46:44.905] - stdout: TRUE
[17:46:44.905] - signal: TRUE
[17:46:44.905] - resignal: FALSE
[17:46:44.905] - force: TRUE
[17:46:44.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.906] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.906]  - until=6
[17:46:44.906]  - relaying element #6
[17:46:44.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.906] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.906] signalConditionsASAP(NULL, pos=5) ... done
[17:46:44.906]  length: 1 (resolved future 5)
[17:46:44.906] signalConditionsASAP(numeric, pos=6) ...
[17:46:44.906] - nx: 6
[17:46:44.906] - relay: TRUE
[17:46:44.907] - stdout: TRUE
[17:46:44.907] - signal: TRUE
[17:46:44.907] - resignal: FALSE
[17:46:44.907] - force: TRUE
[17:46:44.907] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.907] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.907]  - until=6
[17:46:44.907] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.907] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.907] signalConditionsASAP(numeric, pos=6) ... done
[17:46:44.907]  length: 0 (resolved future 6)
[17:46:44.907] Relaying remaining futures
[17:46:44.908] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.908] - nx: 6
[17:46:44.908] - relay: TRUE
[17:46:44.908] - stdout: TRUE
[17:46:44.908] - signal: TRUE
[17:46:44.908] - resignal: FALSE
[17:46:44.908] - force: TRUE
[17:46:44.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.908] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:44.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.908] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.908] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.909] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x561787c0a800> 
Dimensions: c(1, 6)
[17:46:44.909] getGlobalsAndPackages() ...
[17:46:44.909] Searching for globals...
[17:46:44.910] 
[17:46:44.910] Searching for globals ... DONE
[17:46:44.910] - globals: [0] <none>
[17:46:44.910] getGlobalsAndPackages() ... DONE
[17:46:44.910] run() for ‘Future’ ...
[17:46:44.910] - state: ‘created’
[17:46:44.910] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.911] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.911]   - Field: ‘label’
[17:46:44.911]   - Field: ‘local’
[17:46:44.911]   - Field: ‘owner’
[17:46:44.911]   - Field: ‘envir’
[17:46:44.911]   - Field: ‘packages’
[17:46:44.911]   - Field: ‘gc’
[17:46:44.911]   - Field: ‘conditions’
[17:46:44.912]   - Field: ‘expr’
[17:46:44.912]   - Field: ‘uuid’
[17:46:44.912]   - Field: ‘seed’
[17:46:44.912]   - Field: ‘version’
[17:46:44.912]   - Field: ‘result’
[17:46:44.912]   - Field: ‘asynchronous’
[17:46:44.912]   - Field: ‘calls’
[17:46:44.912]   - Field: ‘globals’
[17:46:44.912]   - Field: ‘stdout’
[17:46:44.912]   - Field: ‘earlySignal’
[17:46:44.912]   - Field: ‘lazy’
[17:46:44.912]   - Field: ‘state’
[17:46:44.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.913] - Launch lazy future ...
[17:46:44.913] Packages needed by the future expression (n = 0): <none>
[17:46:44.913] Packages needed by future strategies (n = 0): <none>
[17:46:44.913] {
[17:46:44.913]     {
[17:46:44.913]         {
[17:46:44.913]             ...future.startTime <- base::Sys.time()
[17:46:44.913]             {
[17:46:44.913]                 {
[17:46:44.913]                   {
[17:46:44.913]                     base::local({
[17:46:44.913]                       has_future <- base::requireNamespace("future", 
[17:46:44.913]                         quietly = TRUE)
[17:46:44.913]                       if (has_future) {
[17:46:44.913]                         ns <- base::getNamespace("future")
[17:46:44.913]                         version <- ns[[".package"]][["version"]]
[17:46:44.913]                         if (is.null(version)) 
[17:46:44.913]                           version <- utils::packageVersion("future")
[17:46:44.913]                       }
[17:46:44.913]                       else {
[17:46:44.913]                         version <- NULL
[17:46:44.913]                       }
[17:46:44.913]                       if (!has_future || version < "1.8.0") {
[17:46:44.913]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.913]                           "", base::R.version$version.string), 
[17:46:44.913]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.913]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.913]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.913]                             "release", "version")], collapse = " "), 
[17:46:44.913]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.913]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.913]                           info)
[17:46:44.913]                         info <- base::paste(info, collapse = "; ")
[17:46:44.913]                         if (!has_future) {
[17:46:44.913]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.913]                             info)
[17:46:44.913]                         }
[17:46:44.913]                         else {
[17:46:44.913]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.913]                             info, version)
[17:46:44.913]                         }
[17:46:44.913]                         base::stop(msg)
[17:46:44.913]                       }
[17:46:44.913]                     })
[17:46:44.913]                   }
[17:46:44.913]                   ...future.strategy.old <- future::plan("list")
[17:46:44.913]                   options(future.plan = NULL)
[17:46:44.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.913]                 }
[17:46:44.913]                 ...future.workdir <- getwd()
[17:46:44.913]             }
[17:46:44.913]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.913]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.913]         }
[17:46:44.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.913]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.913]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.913]             base::names(...future.oldOptions))
[17:46:44.913]     }
[17:46:44.913]     if (FALSE) {
[17:46:44.913]     }
[17:46:44.913]     else {
[17:46:44.913]         if (TRUE) {
[17:46:44.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.913]                 open = "w")
[17:46:44.913]         }
[17:46:44.913]         else {
[17:46:44.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.913]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.913]         }
[17:46:44.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.913]             base::sink(type = "output", split = FALSE)
[17:46:44.913]             base::close(...future.stdout)
[17:46:44.913]         }, add = TRUE)
[17:46:44.913]     }
[17:46:44.913]     ...future.frame <- base::sys.nframe()
[17:46:44.913]     ...future.conditions <- base::list()
[17:46:44.913]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.913]     if (FALSE) {
[17:46:44.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.913]     }
[17:46:44.913]     ...future.result <- base::tryCatch({
[17:46:44.913]         base::withCallingHandlers({
[17:46:44.913]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.913]             future::FutureResult(value = ...future.value$value, 
[17:46:44.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.913]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.913]                     ...future.globalenv.names))
[17:46:44.913]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.913]         }, condition = base::local({
[17:46:44.913]             c <- base::c
[17:46:44.913]             inherits <- base::inherits
[17:46:44.913]             invokeRestart <- base::invokeRestart
[17:46:44.913]             length <- base::length
[17:46:44.913]             list <- base::list
[17:46:44.913]             seq.int <- base::seq.int
[17:46:44.913]             signalCondition <- base::signalCondition
[17:46:44.913]             sys.calls <- base::sys.calls
[17:46:44.913]             `[[` <- base::`[[`
[17:46:44.913]             `+` <- base::`+`
[17:46:44.913]             `<<-` <- base::`<<-`
[17:46:44.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.913]                   3L)]
[17:46:44.913]             }
[17:46:44.913]             function(cond) {
[17:46:44.913]                 is_error <- inherits(cond, "error")
[17:46:44.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.913]                   NULL)
[17:46:44.913]                 if (is_error) {
[17:46:44.913]                   sessionInformation <- function() {
[17:46:44.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.913]                       search = base::search(), system = base::Sys.info())
[17:46:44.913]                   }
[17:46:44.913]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.913]                     cond$call), session = sessionInformation(), 
[17:46:44.913]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.913]                   signalCondition(cond)
[17:46:44.913]                 }
[17:46:44.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.913]                 "immediateCondition"))) {
[17:46:44.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.913]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.913]                   if (TRUE && !signal) {
[17:46:44.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.913]                     {
[17:46:44.913]                       inherits <- base::inherits
[17:46:44.913]                       invokeRestart <- base::invokeRestart
[17:46:44.913]                       is.null <- base::is.null
[17:46:44.913]                       muffled <- FALSE
[17:46:44.913]                       if (inherits(cond, "message")) {
[17:46:44.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.913]                         if (muffled) 
[17:46:44.913]                           invokeRestart("muffleMessage")
[17:46:44.913]                       }
[17:46:44.913]                       else if (inherits(cond, "warning")) {
[17:46:44.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.913]                         if (muffled) 
[17:46:44.913]                           invokeRestart("muffleWarning")
[17:46:44.913]                       }
[17:46:44.913]                       else if (inherits(cond, "condition")) {
[17:46:44.913]                         if (!is.null(pattern)) {
[17:46:44.913]                           computeRestarts <- base::computeRestarts
[17:46:44.913]                           grepl <- base::grepl
[17:46:44.913]                           restarts <- computeRestarts(cond)
[17:46:44.913]                           for (restart in restarts) {
[17:46:44.913]                             name <- restart$name
[17:46:44.913]                             if (is.null(name)) 
[17:46:44.913]                               next
[17:46:44.913]                             if (!grepl(pattern, name)) 
[17:46:44.913]                               next
[17:46:44.913]                             invokeRestart(restart)
[17:46:44.913]                             muffled <- TRUE
[17:46:44.913]                             break
[17:46:44.913]                           }
[17:46:44.913]                         }
[17:46:44.913]                       }
[17:46:44.913]                       invisible(muffled)
[17:46:44.913]                     }
[17:46:44.913]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.913]                   }
[17:46:44.913]                 }
[17:46:44.913]                 else {
[17:46:44.913]                   if (TRUE) {
[17:46:44.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.913]                     {
[17:46:44.913]                       inherits <- base::inherits
[17:46:44.913]                       invokeRestart <- base::invokeRestart
[17:46:44.913]                       is.null <- base::is.null
[17:46:44.913]                       muffled <- FALSE
[17:46:44.913]                       if (inherits(cond, "message")) {
[17:46:44.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.913]                         if (muffled) 
[17:46:44.913]                           invokeRestart("muffleMessage")
[17:46:44.913]                       }
[17:46:44.913]                       else if (inherits(cond, "warning")) {
[17:46:44.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.913]                         if (muffled) 
[17:46:44.913]                           invokeRestart("muffleWarning")
[17:46:44.913]                       }
[17:46:44.913]                       else if (inherits(cond, "condition")) {
[17:46:44.913]                         if (!is.null(pattern)) {
[17:46:44.913]                           computeRestarts <- base::computeRestarts
[17:46:44.913]                           grepl <- base::grepl
[17:46:44.913]                           restarts <- computeRestarts(cond)
[17:46:44.913]                           for (restart in restarts) {
[17:46:44.913]                             name <- restart$name
[17:46:44.913]                             if (is.null(name)) 
[17:46:44.913]                               next
[17:46:44.913]                             if (!grepl(pattern, name)) 
[17:46:44.913]                               next
[17:46:44.913]                             invokeRestart(restart)
[17:46:44.913]                             muffled <- TRUE
[17:46:44.913]                             break
[17:46:44.913]                           }
[17:46:44.913]                         }
[17:46:44.913]                       }
[17:46:44.913]                       invisible(muffled)
[17:46:44.913]                     }
[17:46:44.913]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.913]                   }
[17:46:44.913]                 }
[17:46:44.913]             }
[17:46:44.913]         }))
[17:46:44.913]     }, error = function(ex) {
[17:46:44.913]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.913]                 ...future.rng), started = ...future.startTime, 
[17:46:44.913]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.913]             version = "1.8"), class = "FutureResult")
[17:46:44.913]     }, finally = {
[17:46:44.913]         if (!identical(...future.workdir, getwd())) 
[17:46:44.913]             setwd(...future.workdir)
[17:46:44.913]         {
[17:46:44.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.913]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.913]             }
[17:46:44.913]             base::options(...future.oldOptions)
[17:46:44.913]             if (.Platform$OS.type == "windows") {
[17:46:44.913]                 old_names <- names(...future.oldEnvVars)
[17:46:44.913]                 envs <- base::Sys.getenv()
[17:46:44.913]                 names <- names(envs)
[17:46:44.913]                 common <- intersect(names, old_names)
[17:46:44.913]                 added <- setdiff(names, old_names)
[17:46:44.913]                 removed <- setdiff(old_names, names)
[17:46:44.913]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.913]                   envs[common]]
[17:46:44.913]                 NAMES <- toupper(changed)
[17:46:44.913]                 args <- list()
[17:46:44.913]                 for (kk in seq_along(NAMES)) {
[17:46:44.913]                   name <- changed[[kk]]
[17:46:44.913]                   NAME <- NAMES[[kk]]
[17:46:44.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.913]                     next
[17:46:44.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.913]                 }
[17:46:44.913]                 NAMES <- toupper(added)
[17:46:44.913]                 for (kk in seq_along(NAMES)) {
[17:46:44.913]                   name <- added[[kk]]
[17:46:44.913]                   NAME <- NAMES[[kk]]
[17:46:44.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.913]                     next
[17:46:44.913]                   args[[name]] <- ""
[17:46:44.913]                 }
[17:46:44.913]                 NAMES <- toupper(removed)
[17:46:44.913]                 for (kk in seq_along(NAMES)) {
[17:46:44.913]                   name <- removed[[kk]]
[17:46:44.913]                   NAME <- NAMES[[kk]]
[17:46:44.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.913]                     next
[17:46:44.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.913]                 }
[17:46:44.913]                 if (length(args) > 0) 
[17:46:44.913]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.913]             }
[17:46:44.913]             else {
[17:46:44.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.913]             }
[17:46:44.913]             {
[17:46:44.913]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.913]                   0L) {
[17:46:44.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.913]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.913]                   base::options(opts)
[17:46:44.913]                 }
[17:46:44.913]                 {
[17:46:44.913]                   {
[17:46:44.913]                     NULL
[17:46:44.913]                     RNGkind("Mersenne-Twister")
[17:46:44.913]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.913]                       inherits = FALSE)
[17:46:44.913]                   }
[17:46:44.913]                   options(future.plan = NULL)
[17:46:44.913]                   if (is.na(NA_character_)) 
[17:46:44.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.913]                     .init = FALSE)
[17:46:44.913]                 }
[17:46:44.913]             }
[17:46:44.913]         }
[17:46:44.913]     })
[17:46:44.913]     if (TRUE) {
[17:46:44.913]         base::sink(type = "output", split = FALSE)
[17:46:44.913]         if (TRUE) {
[17:46:44.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.913]         }
[17:46:44.913]         else {
[17:46:44.913]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.913]         }
[17:46:44.913]         base::close(...future.stdout)
[17:46:44.913]         ...future.stdout <- NULL
[17:46:44.913]     }
[17:46:44.913]     ...future.result$conditions <- ...future.conditions
[17:46:44.913]     ...future.result$finished <- base::Sys.time()
[17:46:44.913]     ...future.result
[17:46:44.913] }
[17:46:44.915] plan(): Setting new future strategy stack:
[17:46:44.915] List of future strategies:
[17:46:44.915] 1. sequential:
[17:46:44.915]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.915]    - tweaked: FALSE
[17:46:44.915]    - call: NULL
[17:46:44.916] plan(): nbrOfWorkers() = 1
[17:46:44.916] plan(): Setting new future strategy stack:
[17:46:44.916] List of future strategies:
[17:46:44.916] 1. sequential:
[17:46:44.916]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.916]    - tweaked: FALSE
[17:46:44.916]    - call: plan(strategy)
[17:46:44.917] plan(): nbrOfWorkers() = 1
[17:46:44.917] SequentialFuture started (and completed)
[17:46:44.917] - Launch lazy future ... done
[17:46:44.917] run() for ‘SequentialFuture’ ... done
[17:46:44.917] getGlobalsAndPackages() ...
[17:46:44.917] Searching for globals...
[17:46:44.918] 
[17:46:44.918] Searching for globals ... DONE
[17:46:44.918] - globals: [0] <none>
[17:46:44.918] getGlobalsAndPackages() ... DONE
[17:46:44.918] run() for ‘Future’ ...
[17:46:44.918] - state: ‘created’
[17:46:44.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.919] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.919]   - Field: ‘label’
[17:46:44.919]   - Field: ‘local’
[17:46:44.919]   - Field: ‘owner’
[17:46:44.919]   - Field: ‘envir’
[17:46:44.919]   - Field: ‘packages’
[17:46:44.919]   - Field: ‘gc’
[17:46:44.919]   - Field: ‘conditions’
[17:46:44.919]   - Field: ‘expr’
[17:46:44.920]   - Field: ‘uuid’
[17:46:44.920]   - Field: ‘seed’
[17:46:44.920]   - Field: ‘version’
[17:46:44.920]   - Field: ‘result’
[17:46:44.920]   - Field: ‘asynchronous’
[17:46:44.920]   - Field: ‘calls’
[17:46:44.920]   - Field: ‘globals’
[17:46:44.920]   - Field: ‘stdout’
[17:46:44.920]   - Field: ‘earlySignal’
[17:46:44.920]   - Field: ‘lazy’
[17:46:44.920]   - Field: ‘state’
[17:46:44.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.921] - Launch lazy future ...
[17:46:44.921] Packages needed by the future expression (n = 0): <none>
[17:46:44.921] Packages needed by future strategies (n = 0): <none>
[17:46:44.921] {
[17:46:44.921]     {
[17:46:44.921]         {
[17:46:44.921]             ...future.startTime <- base::Sys.time()
[17:46:44.921]             {
[17:46:44.921]                 {
[17:46:44.921]                   {
[17:46:44.921]                     base::local({
[17:46:44.921]                       has_future <- base::requireNamespace("future", 
[17:46:44.921]                         quietly = TRUE)
[17:46:44.921]                       if (has_future) {
[17:46:44.921]                         ns <- base::getNamespace("future")
[17:46:44.921]                         version <- ns[[".package"]][["version"]]
[17:46:44.921]                         if (is.null(version)) 
[17:46:44.921]                           version <- utils::packageVersion("future")
[17:46:44.921]                       }
[17:46:44.921]                       else {
[17:46:44.921]                         version <- NULL
[17:46:44.921]                       }
[17:46:44.921]                       if (!has_future || version < "1.8.0") {
[17:46:44.921]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.921]                           "", base::R.version$version.string), 
[17:46:44.921]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.921]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.921]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.921]                             "release", "version")], collapse = " "), 
[17:46:44.921]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.921]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.921]                           info)
[17:46:44.921]                         info <- base::paste(info, collapse = "; ")
[17:46:44.921]                         if (!has_future) {
[17:46:44.921]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.921]                             info)
[17:46:44.921]                         }
[17:46:44.921]                         else {
[17:46:44.921]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.921]                             info, version)
[17:46:44.921]                         }
[17:46:44.921]                         base::stop(msg)
[17:46:44.921]                       }
[17:46:44.921]                     })
[17:46:44.921]                   }
[17:46:44.921]                   ...future.strategy.old <- future::plan("list")
[17:46:44.921]                   options(future.plan = NULL)
[17:46:44.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.921]                 }
[17:46:44.921]                 ...future.workdir <- getwd()
[17:46:44.921]             }
[17:46:44.921]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.921]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.921]         }
[17:46:44.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.921]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.921]             base::names(...future.oldOptions))
[17:46:44.921]     }
[17:46:44.921]     if (FALSE) {
[17:46:44.921]     }
[17:46:44.921]     else {
[17:46:44.921]         if (TRUE) {
[17:46:44.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.921]                 open = "w")
[17:46:44.921]         }
[17:46:44.921]         else {
[17:46:44.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.921]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.921]         }
[17:46:44.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.921]             base::sink(type = "output", split = FALSE)
[17:46:44.921]             base::close(...future.stdout)
[17:46:44.921]         }, add = TRUE)
[17:46:44.921]     }
[17:46:44.921]     ...future.frame <- base::sys.nframe()
[17:46:44.921]     ...future.conditions <- base::list()
[17:46:44.921]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.921]     if (FALSE) {
[17:46:44.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.921]     }
[17:46:44.921]     ...future.result <- base::tryCatch({
[17:46:44.921]         base::withCallingHandlers({
[17:46:44.921]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.921]             future::FutureResult(value = ...future.value$value, 
[17:46:44.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.921]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.921]                     ...future.globalenv.names))
[17:46:44.921]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.921]         }, condition = base::local({
[17:46:44.921]             c <- base::c
[17:46:44.921]             inherits <- base::inherits
[17:46:44.921]             invokeRestart <- base::invokeRestart
[17:46:44.921]             length <- base::length
[17:46:44.921]             list <- base::list
[17:46:44.921]             seq.int <- base::seq.int
[17:46:44.921]             signalCondition <- base::signalCondition
[17:46:44.921]             sys.calls <- base::sys.calls
[17:46:44.921]             `[[` <- base::`[[`
[17:46:44.921]             `+` <- base::`+`
[17:46:44.921]             `<<-` <- base::`<<-`
[17:46:44.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.921]                   3L)]
[17:46:44.921]             }
[17:46:44.921]             function(cond) {
[17:46:44.921]                 is_error <- inherits(cond, "error")
[17:46:44.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.921]                   NULL)
[17:46:44.921]                 if (is_error) {
[17:46:44.921]                   sessionInformation <- function() {
[17:46:44.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.921]                       search = base::search(), system = base::Sys.info())
[17:46:44.921]                   }
[17:46:44.921]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.921]                     cond$call), session = sessionInformation(), 
[17:46:44.921]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.921]                   signalCondition(cond)
[17:46:44.921]                 }
[17:46:44.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.921]                 "immediateCondition"))) {
[17:46:44.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.921]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.921]                   if (TRUE && !signal) {
[17:46:44.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.921]                     {
[17:46:44.921]                       inherits <- base::inherits
[17:46:44.921]                       invokeRestart <- base::invokeRestart
[17:46:44.921]                       is.null <- base::is.null
[17:46:44.921]                       muffled <- FALSE
[17:46:44.921]                       if (inherits(cond, "message")) {
[17:46:44.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.921]                         if (muffled) 
[17:46:44.921]                           invokeRestart("muffleMessage")
[17:46:44.921]                       }
[17:46:44.921]                       else if (inherits(cond, "warning")) {
[17:46:44.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.921]                         if (muffled) 
[17:46:44.921]                           invokeRestart("muffleWarning")
[17:46:44.921]                       }
[17:46:44.921]                       else if (inherits(cond, "condition")) {
[17:46:44.921]                         if (!is.null(pattern)) {
[17:46:44.921]                           computeRestarts <- base::computeRestarts
[17:46:44.921]                           grepl <- base::grepl
[17:46:44.921]                           restarts <- computeRestarts(cond)
[17:46:44.921]                           for (restart in restarts) {
[17:46:44.921]                             name <- restart$name
[17:46:44.921]                             if (is.null(name)) 
[17:46:44.921]                               next
[17:46:44.921]                             if (!grepl(pattern, name)) 
[17:46:44.921]                               next
[17:46:44.921]                             invokeRestart(restart)
[17:46:44.921]                             muffled <- TRUE
[17:46:44.921]                             break
[17:46:44.921]                           }
[17:46:44.921]                         }
[17:46:44.921]                       }
[17:46:44.921]                       invisible(muffled)
[17:46:44.921]                     }
[17:46:44.921]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.921]                   }
[17:46:44.921]                 }
[17:46:44.921]                 else {
[17:46:44.921]                   if (TRUE) {
[17:46:44.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.921]                     {
[17:46:44.921]                       inherits <- base::inherits
[17:46:44.921]                       invokeRestart <- base::invokeRestart
[17:46:44.921]                       is.null <- base::is.null
[17:46:44.921]                       muffled <- FALSE
[17:46:44.921]                       if (inherits(cond, "message")) {
[17:46:44.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.921]                         if (muffled) 
[17:46:44.921]                           invokeRestart("muffleMessage")
[17:46:44.921]                       }
[17:46:44.921]                       else if (inherits(cond, "warning")) {
[17:46:44.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.921]                         if (muffled) 
[17:46:44.921]                           invokeRestart("muffleWarning")
[17:46:44.921]                       }
[17:46:44.921]                       else if (inherits(cond, "condition")) {
[17:46:44.921]                         if (!is.null(pattern)) {
[17:46:44.921]                           computeRestarts <- base::computeRestarts
[17:46:44.921]                           grepl <- base::grepl
[17:46:44.921]                           restarts <- computeRestarts(cond)
[17:46:44.921]                           for (restart in restarts) {
[17:46:44.921]                             name <- restart$name
[17:46:44.921]                             if (is.null(name)) 
[17:46:44.921]                               next
[17:46:44.921]                             if (!grepl(pattern, name)) 
[17:46:44.921]                               next
[17:46:44.921]                             invokeRestart(restart)
[17:46:44.921]                             muffled <- TRUE
[17:46:44.921]                             break
[17:46:44.921]                           }
[17:46:44.921]                         }
[17:46:44.921]                       }
[17:46:44.921]                       invisible(muffled)
[17:46:44.921]                     }
[17:46:44.921]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.921]                   }
[17:46:44.921]                 }
[17:46:44.921]             }
[17:46:44.921]         }))
[17:46:44.921]     }, error = function(ex) {
[17:46:44.921]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.921]                 ...future.rng), started = ...future.startTime, 
[17:46:44.921]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.921]             version = "1.8"), class = "FutureResult")
[17:46:44.921]     }, finally = {
[17:46:44.921]         if (!identical(...future.workdir, getwd())) 
[17:46:44.921]             setwd(...future.workdir)
[17:46:44.921]         {
[17:46:44.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.921]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.921]             }
[17:46:44.921]             base::options(...future.oldOptions)
[17:46:44.921]             if (.Platform$OS.type == "windows") {
[17:46:44.921]                 old_names <- names(...future.oldEnvVars)
[17:46:44.921]                 envs <- base::Sys.getenv()
[17:46:44.921]                 names <- names(envs)
[17:46:44.921]                 common <- intersect(names, old_names)
[17:46:44.921]                 added <- setdiff(names, old_names)
[17:46:44.921]                 removed <- setdiff(old_names, names)
[17:46:44.921]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.921]                   envs[common]]
[17:46:44.921]                 NAMES <- toupper(changed)
[17:46:44.921]                 args <- list()
[17:46:44.921]                 for (kk in seq_along(NAMES)) {
[17:46:44.921]                   name <- changed[[kk]]
[17:46:44.921]                   NAME <- NAMES[[kk]]
[17:46:44.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.921]                     next
[17:46:44.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.921]                 }
[17:46:44.921]                 NAMES <- toupper(added)
[17:46:44.921]                 for (kk in seq_along(NAMES)) {
[17:46:44.921]                   name <- added[[kk]]
[17:46:44.921]                   NAME <- NAMES[[kk]]
[17:46:44.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.921]                     next
[17:46:44.921]                   args[[name]] <- ""
[17:46:44.921]                 }
[17:46:44.921]                 NAMES <- toupper(removed)
[17:46:44.921]                 for (kk in seq_along(NAMES)) {
[17:46:44.921]                   name <- removed[[kk]]
[17:46:44.921]                   NAME <- NAMES[[kk]]
[17:46:44.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.921]                     next
[17:46:44.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.921]                 }
[17:46:44.921]                 if (length(args) > 0) 
[17:46:44.921]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.921]             }
[17:46:44.921]             else {
[17:46:44.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.921]             }
[17:46:44.921]             {
[17:46:44.921]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.921]                   0L) {
[17:46:44.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.921]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.921]                   base::options(opts)
[17:46:44.921]                 }
[17:46:44.921]                 {
[17:46:44.921]                   {
[17:46:44.921]                     NULL
[17:46:44.921]                     RNGkind("Mersenne-Twister")
[17:46:44.921]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.921]                       inherits = FALSE)
[17:46:44.921]                   }
[17:46:44.921]                   options(future.plan = NULL)
[17:46:44.921]                   if (is.na(NA_character_)) 
[17:46:44.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.921]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.921]                     .init = FALSE)
[17:46:44.921]                 }
[17:46:44.921]             }
[17:46:44.921]         }
[17:46:44.921]     })
[17:46:44.921]     if (TRUE) {
[17:46:44.921]         base::sink(type = "output", split = FALSE)
[17:46:44.921]         if (TRUE) {
[17:46:44.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.921]         }
[17:46:44.921]         else {
[17:46:44.921]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.921]         }
[17:46:44.921]         base::close(...future.stdout)
[17:46:44.921]         ...future.stdout <- NULL
[17:46:44.921]     }
[17:46:44.921]     ...future.result$conditions <- ...future.conditions
[17:46:44.921]     ...future.result$finished <- base::Sys.time()
[17:46:44.921]     ...future.result
[17:46:44.921] }
[17:46:44.923] plan(): Setting new future strategy stack:
[17:46:44.923] List of future strategies:
[17:46:44.923] 1. sequential:
[17:46:44.923]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.923]    - tweaked: FALSE
[17:46:44.923]    - call: NULL
[17:46:44.923] plan(): nbrOfWorkers() = 1
[17:46:44.924] plan(): Setting new future strategy stack:
[17:46:44.924] List of future strategies:
[17:46:44.924] 1. sequential:
[17:46:44.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.924]    - tweaked: FALSE
[17:46:44.924]    - call: plan(strategy)
[17:46:44.925] plan(): nbrOfWorkers() = 1
[17:46:44.925] SequentialFuture started (and completed)
[17:46:44.925] - Launch lazy future ... done
[17:46:44.925] run() for ‘SequentialFuture’ ... done
[17:46:44.925] getGlobalsAndPackages() ...
[17:46:44.925] Searching for globals...
[17:46:44.926] - globals found: [1] ‘{’
[17:46:44.926] Searching for globals ... DONE
[17:46:44.926] Resolving globals: FALSE
[17:46:44.926] 
[17:46:44.927] 
[17:46:44.928] getGlobalsAndPackages() ... DONE
[17:46:44.929] run() for ‘Future’ ...
[17:46:44.929] - state: ‘created’
[17:46:44.929] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.929] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.929] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.929]   - Field: ‘label’
[17:46:44.929]   - Field: ‘local’
[17:46:44.929]   - Field: ‘owner’
[17:46:44.930]   - Field: ‘envir’
[17:46:44.930]   - Field: ‘packages’
[17:46:44.930]   - Field: ‘gc’
[17:46:44.930]   - Field: ‘conditions’
[17:46:44.930]   - Field: ‘expr’
[17:46:44.930]   - Field: ‘uuid’
[17:46:44.930]   - Field: ‘seed’
[17:46:44.930]   - Field: ‘version’
[17:46:44.930]   - Field: ‘result’
[17:46:44.930]   - Field: ‘asynchronous’
[17:46:44.930]   - Field: ‘calls’
[17:46:44.931]   - Field: ‘globals’
[17:46:44.931]   - Field: ‘stdout’
[17:46:44.931]   - Field: ‘earlySignal’
[17:46:44.931]   - Field: ‘lazy’
[17:46:44.931]   - Field: ‘state’
[17:46:44.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.931] - Launch lazy future ...
[17:46:44.931] Packages needed by the future expression (n = 0): <none>
[17:46:44.931] Packages needed by future strategies (n = 0): <none>
[17:46:44.932] {
[17:46:44.932]     {
[17:46:44.932]         {
[17:46:44.932]             ...future.startTime <- base::Sys.time()
[17:46:44.932]             {
[17:46:44.932]                 {
[17:46:44.932]                   {
[17:46:44.932]                     base::local({
[17:46:44.932]                       has_future <- base::requireNamespace("future", 
[17:46:44.932]                         quietly = TRUE)
[17:46:44.932]                       if (has_future) {
[17:46:44.932]                         ns <- base::getNamespace("future")
[17:46:44.932]                         version <- ns[[".package"]][["version"]]
[17:46:44.932]                         if (is.null(version)) 
[17:46:44.932]                           version <- utils::packageVersion("future")
[17:46:44.932]                       }
[17:46:44.932]                       else {
[17:46:44.932]                         version <- NULL
[17:46:44.932]                       }
[17:46:44.932]                       if (!has_future || version < "1.8.0") {
[17:46:44.932]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.932]                           "", base::R.version$version.string), 
[17:46:44.932]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.932]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.932]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.932]                             "release", "version")], collapse = " "), 
[17:46:44.932]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.932]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.932]                           info)
[17:46:44.932]                         info <- base::paste(info, collapse = "; ")
[17:46:44.932]                         if (!has_future) {
[17:46:44.932]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.932]                             info)
[17:46:44.932]                         }
[17:46:44.932]                         else {
[17:46:44.932]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.932]                             info, version)
[17:46:44.932]                         }
[17:46:44.932]                         base::stop(msg)
[17:46:44.932]                       }
[17:46:44.932]                     })
[17:46:44.932]                   }
[17:46:44.932]                   ...future.strategy.old <- future::plan("list")
[17:46:44.932]                   options(future.plan = NULL)
[17:46:44.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.932]                 }
[17:46:44.932]                 ...future.workdir <- getwd()
[17:46:44.932]             }
[17:46:44.932]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.932]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.932]         }
[17:46:44.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.932]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.932]             base::names(...future.oldOptions))
[17:46:44.932]     }
[17:46:44.932]     if (FALSE) {
[17:46:44.932]     }
[17:46:44.932]     else {
[17:46:44.932]         if (TRUE) {
[17:46:44.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.932]                 open = "w")
[17:46:44.932]         }
[17:46:44.932]         else {
[17:46:44.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.932]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.932]         }
[17:46:44.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.932]             base::sink(type = "output", split = FALSE)
[17:46:44.932]             base::close(...future.stdout)
[17:46:44.932]         }, add = TRUE)
[17:46:44.932]     }
[17:46:44.932]     ...future.frame <- base::sys.nframe()
[17:46:44.932]     ...future.conditions <- base::list()
[17:46:44.932]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.932]     if (FALSE) {
[17:46:44.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.932]     }
[17:46:44.932]     ...future.result <- base::tryCatch({
[17:46:44.932]         base::withCallingHandlers({
[17:46:44.932]             ...future.value <- base::withVisible(base::local({
[17:46:44.932]                 4
[17:46:44.932]             }))
[17:46:44.932]             future::FutureResult(value = ...future.value$value, 
[17:46:44.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.932]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.932]                     ...future.globalenv.names))
[17:46:44.932]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.932]         }, condition = base::local({
[17:46:44.932]             c <- base::c
[17:46:44.932]             inherits <- base::inherits
[17:46:44.932]             invokeRestart <- base::invokeRestart
[17:46:44.932]             length <- base::length
[17:46:44.932]             list <- base::list
[17:46:44.932]             seq.int <- base::seq.int
[17:46:44.932]             signalCondition <- base::signalCondition
[17:46:44.932]             sys.calls <- base::sys.calls
[17:46:44.932]             `[[` <- base::`[[`
[17:46:44.932]             `+` <- base::`+`
[17:46:44.932]             `<<-` <- base::`<<-`
[17:46:44.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.932]                   3L)]
[17:46:44.932]             }
[17:46:44.932]             function(cond) {
[17:46:44.932]                 is_error <- inherits(cond, "error")
[17:46:44.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.932]                   NULL)
[17:46:44.932]                 if (is_error) {
[17:46:44.932]                   sessionInformation <- function() {
[17:46:44.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.932]                       search = base::search(), system = base::Sys.info())
[17:46:44.932]                   }
[17:46:44.932]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.932]                     cond$call), session = sessionInformation(), 
[17:46:44.932]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.932]                   signalCondition(cond)
[17:46:44.932]                 }
[17:46:44.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.932]                 "immediateCondition"))) {
[17:46:44.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.932]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.932]                   if (TRUE && !signal) {
[17:46:44.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.932]                     {
[17:46:44.932]                       inherits <- base::inherits
[17:46:44.932]                       invokeRestart <- base::invokeRestart
[17:46:44.932]                       is.null <- base::is.null
[17:46:44.932]                       muffled <- FALSE
[17:46:44.932]                       if (inherits(cond, "message")) {
[17:46:44.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.932]                         if (muffled) 
[17:46:44.932]                           invokeRestart("muffleMessage")
[17:46:44.932]                       }
[17:46:44.932]                       else if (inherits(cond, "warning")) {
[17:46:44.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.932]                         if (muffled) 
[17:46:44.932]                           invokeRestart("muffleWarning")
[17:46:44.932]                       }
[17:46:44.932]                       else if (inherits(cond, "condition")) {
[17:46:44.932]                         if (!is.null(pattern)) {
[17:46:44.932]                           computeRestarts <- base::computeRestarts
[17:46:44.932]                           grepl <- base::grepl
[17:46:44.932]                           restarts <- computeRestarts(cond)
[17:46:44.932]                           for (restart in restarts) {
[17:46:44.932]                             name <- restart$name
[17:46:44.932]                             if (is.null(name)) 
[17:46:44.932]                               next
[17:46:44.932]                             if (!grepl(pattern, name)) 
[17:46:44.932]                               next
[17:46:44.932]                             invokeRestart(restart)
[17:46:44.932]                             muffled <- TRUE
[17:46:44.932]                             break
[17:46:44.932]                           }
[17:46:44.932]                         }
[17:46:44.932]                       }
[17:46:44.932]                       invisible(muffled)
[17:46:44.932]                     }
[17:46:44.932]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.932]                   }
[17:46:44.932]                 }
[17:46:44.932]                 else {
[17:46:44.932]                   if (TRUE) {
[17:46:44.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.932]                     {
[17:46:44.932]                       inherits <- base::inherits
[17:46:44.932]                       invokeRestart <- base::invokeRestart
[17:46:44.932]                       is.null <- base::is.null
[17:46:44.932]                       muffled <- FALSE
[17:46:44.932]                       if (inherits(cond, "message")) {
[17:46:44.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.932]                         if (muffled) 
[17:46:44.932]                           invokeRestart("muffleMessage")
[17:46:44.932]                       }
[17:46:44.932]                       else if (inherits(cond, "warning")) {
[17:46:44.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.932]                         if (muffled) 
[17:46:44.932]                           invokeRestart("muffleWarning")
[17:46:44.932]                       }
[17:46:44.932]                       else if (inherits(cond, "condition")) {
[17:46:44.932]                         if (!is.null(pattern)) {
[17:46:44.932]                           computeRestarts <- base::computeRestarts
[17:46:44.932]                           grepl <- base::grepl
[17:46:44.932]                           restarts <- computeRestarts(cond)
[17:46:44.932]                           for (restart in restarts) {
[17:46:44.932]                             name <- restart$name
[17:46:44.932]                             if (is.null(name)) 
[17:46:44.932]                               next
[17:46:44.932]                             if (!grepl(pattern, name)) 
[17:46:44.932]                               next
[17:46:44.932]                             invokeRestart(restart)
[17:46:44.932]                             muffled <- TRUE
[17:46:44.932]                             break
[17:46:44.932]                           }
[17:46:44.932]                         }
[17:46:44.932]                       }
[17:46:44.932]                       invisible(muffled)
[17:46:44.932]                     }
[17:46:44.932]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.932]                   }
[17:46:44.932]                 }
[17:46:44.932]             }
[17:46:44.932]         }))
[17:46:44.932]     }, error = function(ex) {
[17:46:44.932]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.932]                 ...future.rng), started = ...future.startTime, 
[17:46:44.932]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.932]             version = "1.8"), class = "FutureResult")
[17:46:44.932]     }, finally = {
[17:46:44.932]         if (!identical(...future.workdir, getwd())) 
[17:46:44.932]             setwd(...future.workdir)
[17:46:44.932]         {
[17:46:44.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.932]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.932]             }
[17:46:44.932]             base::options(...future.oldOptions)
[17:46:44.932]             if (.Platform$OS.type == "windows") {
[17:46:44.932]                 old_names <- names(...future.oldEnvVars)
[17:46:44.932]                 envs <- base::Sys.getenv()
[17:46:44.932]                 names <- names(envs)
[17:46:44.932]                 common <- intersect(names, old_names)
[17:46:44.932]                 added <- setdiff(names, old_names)
[17:46:44.932]                 removed <- setdiff(old_names, names)
[17:46:44.932]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.932]                   envs[common]]
[17:46:44.932]                 NAMES <- toupper(changed)
[17:46:44.932]                 args <- list()
[17:46:44.932]                 for (kk in seq_along(NAMES)) {
[17:46:44.932]                   name <- changed[[kk]]
[17:46:44.932]                   NAME <- NAMES[[kk]]
[17:46:44.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.932]                     next
[17:46:44.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.932]                 }
[17:46:44.932]                 NAMES <- toupper(added)
[17:46:44.932]                 for (kk in seq_along(NAMES)) {
[17:46:44.932]                   name <- added[[kk]]
[17:46:44.932]                   NAME <- NAMES[[kk]]
[17:46:44.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.932]                     next
[17:46:44.932]                   args[[name]] <- ""
[17:46:44.932]                 }
[17:46:44.932]                 NAMES <- toupper(removed)
[17:46:44.932]                 for (kk in seq_along(NAMES)) {
[17:46:44.932]                   name <- removed[[kk]]
[17:46:44.932]                   NAME <- NAMES[[kk]]
[17:46:44.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.932]                     next
[17:46:44.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.932]                 }
[17:46:44.932]                 if (length(args) > 0) 
[17:46:44.932]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.932]             }
[17:46:44.932]             else {
[17:46:44.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.932]             }
[17:46:44.932]             {
[17:46:44.932]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.932]                   0L) {
[17:46:44.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.932]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.932]                   base::options(opts)
[17:46:44.932]                 }
[17:46:44.932]                 {
[17:46:44.932]                   {
[17:46:44.932]                     NULL
[17:46:44.932]                     RNGkind("Mersenne-Twister")
[17:46:44.932]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.932]                       inherits = FALSE)
[17:46:44.932]                   }
[17:46:44.932]                   options(future.plan = NULL)
[17:46:44.932]                   if (is.na(NA_character_)) 
[17:46:44.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.932]                     .init = FALSE)
[17:46:44.932]                 }
[17:46:44.932]             }
[17:46:44.932]         }
[17:46:44.932]     })
[17:46:44.932]     if (TRUE) {
[17:46:44.932]         base::sink(type = "output", split = FALSE)
[17:46:44.932]         if (TRUE) {
[17:46:44.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.932]         }
[17:46:44.932]         else {
[17:46:44.932]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.932]         }
[17:46:44.932]         base::close(...future.stdout)
[17:46:44.932]         ...future.stdout <- NULL
[17:46:44.932]     }
[17:46:44.932]     ...future.result$conditions <- ...future.conditions
[17:46:44.932]     ...future.result$finished <- base::Sys.time()
[17:46:44.932]     ...future.result
[17:46:44.932] }
[17:46:44.933] plan(): Setting new future strategy stack:
[17:46:44.934] List of future strategies:
[17:46:44.934] 1. sequential:
[17:46:44.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.934]    - tweaked: FALSE
[17:46:44.934]    - call: NULL
[17:46:44.934] plan(): nbrOfWorkers() = 1
[17:46:44.935] plan(): Setting new future strategy stack:
[17:46:44.935] List of future strategies:
[17:46:44.935] 1. sequential:
[17:46:44.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.935]    - tweaked: FALSE
[17:46:44.935]    - call: plan(strategy)
[17:46:44.935] plan(): nbrOfWorkers() = 1
[17:46:44.935] SequentialFuture started (and completed)
[17:46:44.935] - Launch lazy future ... done
[17:46:44.936] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5617874b3c70> 
Classes 'listenv', 'environment' <environment: 0x561786295ed0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:46:44.939] resolved() for ‘SequentialFuture’ ...
[17:46:44.939] - state: ‘finished’
[17:46:44.939] - run: TRUE
[17:46:44.939] - result: ‘FutureResult’
[17:46:44.939] resolved() for ‘SequentialFuture’ ... done
[17:46:44.939] resolved() for ‘SequentialFuture’ ...
[17:46:44.940] - state: ‘finished’
[17:46:44.940] - run: TRUE
[17:46:44.940] - result: ‘FutureResult’
[17:46:44.940] resolved() for ‘SequentialFuture’ ... done
[17:46:44.940] resolved() for ‘SequentialFuture’ ...
[17:46:44.940] - state: ‘finished’
[17:46:44.940] - run: TRUE
[17:46:44.940] - result: ‘FutureResult’
[17:46:44.940] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:44.942] resolve() on list environment ...
[17:46:44.942]  recursive: 0
[17:46:44.943]  length: 6
[17:46:44.944]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:44.944] signalConditionsASAP(numeric, pos=1) ...
[17:46:44.944] - nx: 6
[17:46:44.944] - relay: TRUE
[17:46:44.944] - stdout: TRUE
[17:46:44.944] - signal: TRUE
[17:46:44.944] - resignal: FALSE
[17:46:44.944] - force: TRUE
[17:46:44.944] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.944] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.944]  - until=2
[17:46:44.944]  - relaying element #2
[17:46:44.945] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.945] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.945] signalConditionsASAP(NULL, pos=1) ... done
[17:46:44.945]  length: 5 (resolved future 1)
[17:46:44.945] resolved() for ‘SequentialFuture’ ...
[17:46:44.945] - state: ‘finished’
[17:46:44.945] - run: TRUE
[17:46:44.945] - result: ‘FutureResult’
[17:46:44.945] resolved() for ‘SequentialFuture’ ... done
[17:46:44.945] Future #2
[17:46:44.946] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:44.946] - nx: 6
[17:46:44.946] - relay: TRUE
[17:46:44.946] - stdout: TRUE
[17:46:44.946] - signal: TRUE
[17:46:44.946] - resignal: FALSE
[17:46:44.946] - force: TRUE
[17:46:44.946] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.946] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:44.946]  - until=2
[17:46:44.946]  - relaying element #2
[17:46:44.947] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.947] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.947] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:44.947]  length: 4 (resolved future 2)
[17:46:44.947] resolved() for ‘SequentialFuture’ ...
[17:46:44.947] - state: ‘finished’
[17:46:44.947] - run: TRUE
[17:46:44.947] - result: ‘FutureResult’
[17:46:44.947] resolved() for ‘SequentialFuture’ ... done
[17:46:44.947] Future #3
[17:46:44.948] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:44.948] - nx: 6
[17:46:44.948] - relay: TRUE
[17:46:44.948] - stdout: TRUE
[17:46:44.948] - signal: TRUE
[17:46:44.948] - resignal: FALSE
[17:46:44.948] - force: TRUE
[17:46:44.948] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.948] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:44.948]  - until=3
[17:46:44.948]  - relaying element #3
[17:46:44.948] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.949] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.949] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:44.949]  length: 3 (resolved future 3)
[17:46:44.949] resolved() for ‘SequentialFuture’ ...
[17:46:44.949] - state: ‘finished’
[17:46:44.949] - run: TRUE
[17:46:44.949] - result: ‘FutureResult’
[17:46:44.949] resolved() for ‘SequentialFuture’ ... done
[17:46:44.949] Future #4
[17:46:44.949] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:44.949] - nx: 6
[17:46:44.950] - relay: TRUE
[17:46:44.950] - stdout: TRUE
[17:46:44.950] - signal: TRUE
[17:46:44.950] - resignal: FALSE
[17:46:44.950] - force: TRUE
[17:46:44.950] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.950] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:44.950]  - until=4
[17:46:44.950]  - relaying element #4
[17:46:44.950] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.950] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.951] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:44.951]  length: 2 (resolved future 4)
[17:46:44.951] signalConditionsASAP(NULL, pos=5) ...
[17:46:44.951] - nx: 6
[17:46:44.976] - relay: TRUE
[17:46:44.976] - stdout: TRUE
[17:46:44.977] - signal: TRUE
[17:46:44.977] - resignal: FALSE
[17:46:44.977] - force: TRUE
[17:46:44.977] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.977] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.977]  - until=6
[17:46:44.977]  - relaying element #6
[17:46:44.977] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.977] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.977] signalConditionsASAP(NULL, pos=5) ... done
[17:46:44.978]  length: 1 (resolved future 5)
[17:46:44.978] signalConditionsASAP(numeric, pos=6) ...
[17:46:44.978] - nx: 6
[17:46:44.978] - relay: TRUE
[17:46:44.978] - stdout: TRUE
[17:46:44.978] - signal: TRUE
[17:46:44.978] - resignal: FALSE
[17:46:44.978] - force: TRUE
[17:46:44.978] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:44.978] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.978]  - until=6
[17:46:44.979] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.979] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.979] signalConditionsASAP(numeric, pos=6) ... done
[17:46:44.979]  length: 0 (resolved future 6)
[17:46:44.979] Relaying remaining futures
[17:46:44.979] signalConditionsASAP(NULL, pos=0) ...
[17:46:44.979] - nx: 6
[17:46:44.979] - relay: TRUE
[17:46:44.979] - stdout: TRUE
[17:46:44.979] - signal: TRUE
[17:46:44.979] - resignal: FALSE
[17:46:44.979] - force: TRUE
[17:46:44.980] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.980] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:44.980] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:44.980] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:44.980] signalConditionsASAP(NULL, pos=0) ... done
[17:46:44.980] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x56178795ac30> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:46:44.982] getGlobalsAndPackages() ...
[17:46:44.982] Searching for globals...
[17:46:44.982] 
[17:46:44.983] Searching for globals ... DONE
[17:46:44.983] - globals: [0] <none>
[17:46:44.983] getGlobalsAndPackages() ... DONE
[17:46:44.983] run() for ‘Future’ ...
[17:46:44.983] - state: ‘created’
[17:46:44.983] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.983] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.984]   - Field: ‘label’
[17:46:44.984]   - Field: ‘local’
[17:46:44.984]   - Field: ‘owner’
[17:46:44.984]   - Field: ‘envir’
[17:46:44.984]   - Field: ‘packages’
[17:46:44.984]   - Field: ‘gc’
[17:46:44.984]   - Field: ‘conditions’
[17:46:44.984]   - Field: ‘expr’
[17:46:44.984]   - Field: ‘uuid’
[17:46:44.984]   - Field: ‘seed’
[17:46:44.985]   - Field: ‘version’
[17:46:44.985]   - Field: ‘result’
[17:46:44.985]   - Field: ‘asynchronous’
[17:46:44.985]   - Field: ‘calls’
[17:46:44.985]   - Field: ‘globals’
[17:46:44.985]   - Field: ‘stdout’
[17:46:44.985]   - Field: ‘earlySignal’
[17:46:44.985]   - Field: ‘lazy’
[17:46:44.985]   - Field: ‘state’
[17:46:44.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.985] - Launch lazy future ...
[17:46:44.986] Packages needed by the future expression (n = 0): <none>
[17:46:44.986] Packages needed by future strategies (n = 0): <none>
[17:46:44.986] {
[17:46:44.986]     {
[17:46:44.986]         {
[17:46:44.986]             ...future.startTime <- base::Sys.time()
[17:46:44.986]             {
[17:46:44.986]                 {
[17:46:44.986]                   {
[17:46:44.986]                     base::local({
[17:46:44.986]                       has_future <- base::requireNamespace("future", 
[17:46:44.986]                         quietly = TRUE)
[17:46:44.986]                       if (has_future) {
[17:46:44.986]                         ns <- base::getNamespace("future")
[17:46:44.986]                         version <- ns[[".package"]][["version"]]
[17:46:44.986]                         if (is.null(version)) 
[17:46:44.986]                           version <- utils::packageVersion("future")
[17:46:44.986]                       }
[17:46:44.986]                       else {
[17:46:44.986]                         version <- NULL
[17:46:44.986]                       }
[17:46:44.986]                       if (!has_future || version < "1.8.0") {
[17:46:44.986]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.986]                           "", base::R.version$version.string), 
[17:46:44.986]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.986]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.986]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.986]                             "release", "version")], collapse = " "), 
[17:46:44.986]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.986]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.986]                           info)
[17:46:44.986]                         info <- base::paste(info, collapse = "; ")
[17:46:44.986]                         if (!has_future) {
[17:46:44.986]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.986]                             info)
[17:46:44.986]                         }
[17:46:44.986]                         else {
[17:46:44.986]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.986]                             info, version)
[17:46:44.986]                         }
[17:46:44.986]                         base::stop(msg)
[17:46:44.986]                       }
[17:46:44.986]                     })
[17:46:44.986]                   }
[17:46:44.986]                   ...future.strategy.old <- future::plan("list")
[17:46:44.986]                   options(future.plan = NULL)
[17:46:44.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.986]                 }
[17:46:44.986]                 ...future.workdir <- getwd()
[17:46:44.986]             }
[17:46:44.986]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.986]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.986]         }
[17:46:44.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.986]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.986]             base::names(...future.oldOptions))
[17:46:44.986]     }
[17:46:44.986]     if (FALSE) {
[17:46:44.986]     }
[17:46:44.986]     else {
[17:46:44.986]         if (TRUE) {
[17:46:44.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.986]                 open = "w")
[17:46:44.986]         }
[17:46:44.986]         else {
[17:46:44.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.986]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.986]         }
[17:46:44.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.986]             base::sink(type = "output", split = FALSE)
[17:46:44.986]             base::close(...future.stdout)
[17:46:44.986]         }, add = TRUE)
[17:46:44.986]     }
[17:46:44.986]     ...future.frame <- base::sys.nframe()
[17:46:44.986]     ...future.conditions <- base::list()
[17:46:44.986]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.986]     if (FALSE) {
[17:46:44.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.986]     }
[17:46:44.986]     ...future.result <- base::tryCatch({
[17:46:44.986]         base::withCallingHandlers({
[17:46:44.986]             ...future.value <- base::withVisible(base::local(2))
[17:46:44.986]             future::FutureResult(value = ...future.value$value, 
[17:46:44.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.986]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.986]                     ...future.globalenv.names))
[17:46:44.986]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.986]         }, condition = base::local({
[17:46:44.986]             c <- base::c
[17:46:44.986]             inherits <- base::inherits
[17:46:44.986]             invokeRestart <- base::invokeRestart
[17:46:44.986]             length <- base::length
[17:46:44.986]             list <- base::list
[17:46:44.986]             seq.int <- base::seq.int
[17:46:44.986]             signalCondition <- base::signalCondition
[17:46:44.986]             sys.calls <- base::sys.calls
[17:46:44.986]             `[[` <- base::`[[`
[17:46:44.986]             `+` <- base::`+`
[17:46:44.986]             `<<-` <- base::`<<-`
[17:46:44.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.986]                   3L)]
[17:46:44.986]             }
[17:46:44.986]             function(cond) {
[17:46:44.986]                 is_error <- inherits(cond, "error")
[17:46:44.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.986]                   NULL)
[17:46:44.986]                 if (is_error) {
[17:46:44.986]                   sessionInformation <- function() {
[17:46:44.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.986]                       search = base::search(), system = base::Sys.info())
[17:46:44.986]                   }
[17:46:44.986]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.986]                     cond$call), session = sessionInformation(), 
[17:46:44.986]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.986]                   signalCondition(cond)
[17:46:44.986]                 }
[17:46:44.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.986]                 "immediateCondition"))) {
[17:46:44.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.986]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.986]                   if (TRUE && !signal) {
[17:46:44.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.986]                     {
[17:46:44.986]                       inherits <- base::inherits
[17:46:44.986]                       invokeRestart <- base::invokeRestart
[17:46:44.986]                       is.null <- base::is.null
[17:46:44.986]                       muffled <- FALSE
[17:46:44.986]                       if (inherits(cond, "message")) {
[17:46:44.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.986]                         if (muffled) 
[17:46:44.986]                           invokeRestart("muffleMessage")
[17:46:44.986]                       }
[17:46:44.986]                       else if (inherits(cond, "warning")) {
[17:46:44.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.986]                         if (muffled) 
[17:46:44.986]                           invokeRestart("muffleWarning")
[17:46:44.986]                       }
[17:46:44.986]                       else if (inherits(cond, "condition")) {
[17:46:44.986]                         if (!is.null(pattern)) {
[17:46:44.986]                           computeRestarts <- base::computeRestarts
[17:46:44.986]                           grepl <- base::grepl
[17:46:44.986]                           restarts <- computeRestarts(cond)
[17:46:44.986]                           for (restart in restarts) {
[17:46:44.986]                             name <- restart$name
[17:46:44.986]                             if (is.null(name)) 
[17:46:44.986]                               next
[17:46:44.986]                             if (!grepl(pattern, name)) 
[17:46:44.986]                               next
[17:46:44.986]                             invokeRestart(restart)
[17:46:44.986]                             muffled <- TRUE
[17:46:44.986]                             break
[17:46:44.986]                           }
[17:46:44.986]                         }
[17:46:44.986]                       }
[17:46:44.986]                       invisible(muffled)
[17:46:44.986]                     }
[17:46:44.986]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.986]                   }
[17:46:44.986]                 }
[17:46:44.986]                 else {
[17:46:44.986]                   if (TRUE) {
[17:46:44.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.986]                     {
[17:46:44.986]                       inherits <- base::inherits
[17:46:44.986]                       invokeRestart <- base::invokeRestart
[17:46:44.986]                       is.null <- base::is.null
[17:46:44.986]                       muffled <- FALSE
[17:46:44.986]                       if (inherits(cond, "message")) {
[17:46:44.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.986]                         if (muffled) 
[17:46:44.986]                           invokeRestart("muffleMessage")
[17:46:44.986]                       }
[17:46:44.986]                       else if (inherits(cond, "warning")) {
[17:46:44.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.986]                         if (muffled) 
[17:46:44.986]                           invokeRestart("muffleWarning")
[17:46:44.986]                       }
[17:46:44.986]                       else if (inherits(cond, "condition")) {
[17:46:44.986]                         if (!is.null(pattern)) {
[17:46:44.986]                           computeRestarts <- base::computeRestarts
[17:46:44.986]                           grepl <- base::grepl
[17:46:44.986]                           restarts <- computeRestarts(cond)
[17:46:44.986]                           for (restart in restarts) {
[17:46:44.986]                             name <- restart$name
[17:46:44.986]                             if (is.null(name)) 
[17:46:44.986]                               next
[17:46:44.986]                             if (!grepl(pattern, name)) 
[17:46:44.986]                               next
[17:46:44.986]                             invokeRestart(restart)
[17:46:44.986]                             muffled <- TRUE
[17:46:44.986]                             break
[17:46:44.986]                           }
[17:46:44.986]                         }
[17:46:44.986]                       }
[17:46:44.986]                       invisible(muffled)
[17:46:44.986]                     }
[17:46:44.986]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.986]                   }
[17:46:44.986]                 }
[17:46:44.986]             }
[17:46:44.986]         }))
[17:46:44.986]     }, error = function(ex) {
[17:46:44.986]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.986]                 ...future.rng), started = ...future.startTime, 
[17:46:44.986]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.986]             version = "1.8"), class = "FutureResult")
[17:46:44.986]     }, finally = {
[17:46:44.986]         if (!identical(...future.workdir, getwd())) 
[17:46:44.986]             setwd(...future.workdir)
[17:46:44.986]         {
[17:46:44.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.986]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.986]             }
[17:46:44.986]             base::options(...future.oldOptions)
[17:46:44.986]             if (.Platform$OS.type == "windows") {
[17:46:44.986]                 old_names <- names(...future.oldEnvVars)
[17:46:44.986]                 envs <- base::Sys.getenv()
[17:46:44.986]                 names <- names(envs)
[17:46:44.986]                 common <- intersect(names, old_names)
[17:46:44.986]                 added <- setdiff(names, old_names)
[17:46:44.986]                 removed <- setdiff(old_names, names)
[17:46:44.986]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.986]                   envs[common]]
[17:46:44.986]                 NAMES <- toupper(changed)
[17:46:44.986]                 args <- list()
[17:46:44.986]                 for (kk in seq_along(NAMES)) {
[17:46:44.986]                   name <- changed[[kk]]
[17:46:44.986]                   NAME <- NAMES[[kk]]
[17:46:44.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.986]                     next
[17:46:44.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.986]                 }
[17:46:44.986]                 NAMES <- toupper(added)
[17:46:44.986]                 for (kk in seq_along(NAMES)) {
[17:46:44.986]                   name <- added[[kk]]
[17:46:44.986]                   NAME <- NAMES[[kk]]
[17:46:44.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.986]                     next
[17:46:44.986]                   args[[name]] <- ""
[17:46:44.986]                 }
[17:46:44.986]                 NAMES <- toupper(removed)
[17:46:44.986]                 for (kk in seq_along(NAMES)) {
[17:46:44.986]                   name <- removed[[kk]]
[17:46:44.986]                   NAME <- NAMES[[kk]]
[17:46:44.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.986]                     next
[17:46:44.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.986]                 }
[17:46:44.986]                 if (length(args) > 0) 
[17:46:44.986]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.986]             }
[17:46:44.986]             else {
[17:46:44.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.986]             }
[17:46:44.986]             {
[17:46:44.986]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.986]                   0L) {
[17:46:44.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.986]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.986]                   base::options(opts)
[17:46:44.986]                 }
[17:46:44.986]                 {
[17:46:44.986]                   {
[17:46:44.986]                     NULL
[17:46:44.986]                     RNGkind("Mersenne-Twister")
[17:46:44.986]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.986]                       inherits = FALSE)
[17:46:44.986]                   }
[17:46:44.986]                   options(future.plan = NULL)
[17:46:44.986]                   if (is.na(NA_character_)) 
[17:46:44.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.986]                     .init = FALSE)
[17:46:44.986]                 }
[17:46:44.986]             }
[17:46:44.986]         }
[17:46:44.986]     })
[17:46:44.986]     if (TRUE) {
[17:46:44.986]         base::sink(type = "output", split = FALSE)
[17:46:44.986]         if (TRUE) {
[17:46:44.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.986]         }
[17:46:44.986]         else {
[17:46:44.986]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.986]         }
[17:46:44.986]         base::close(...future.stdout)
[17:46:44.986]         ...future.stdout <- NULL
[17:46:44.986]     }
[17:46:44.986]     ...future.result$conditions <- ...future.conditions
[17:46:44.986]     ...future.result$finished <- base::Sys.time()
[17:46:44.986]     ...future.result
[17:46:44.986] }
[17:46:44.988] plan(): Setting new future strategy stack:
[17:46:44.988] List of future strategies:
[17:46:44.988] 1. sequential:
[17:46:44.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.988]    - tweaked: FALSE
[17:46:44.988]    - call: NULL
[17:46:44.988] plan(): nbrOfWorkers() = 1
[17:46:44.989] plan(): Setting new future strategy stack:
[17:46:44.989] List of future strategies:
[17:46:44.989] 1. sequential:
[17:46:44.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.989]    - tweaked: FALSE
[17:46:44.989]    - call: plan(strategy)
[17:46:44.990] plan(): nbrOfWorkers() = 1
[17:46:44.990] SequentialFuture started (and completed)
[17:46:44.990] - Launch lazy future ... done
[17:46:44.990] run() for ‘SequentialFuture’ ... done
[17:46:44.990] getGlobalsAndPackages() ...
[17:46:44.990] Searching for globals...
[17:46:44.991] 
[17:46:44.991] Searching for globals ... DONE
[17:46:44.991] - globals: [0] <none>
[17:46:44.991] getGlobalsAndPackages() ... DONE
[17:46:44.991] run() for ‘Future’ ...
[17:46:44.991] - state: ‘created’
[17:46:44.991] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:44.991] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:44.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:44.992]   - Field: ‘label’
[17:46:44.992]   - Field: ‘local’
[17:46:44.992]   - Field: ‘owner’
[17:46:44.992]   - Field: ‘envir’
[17:46:44.992]   - Field: ‘packages’
[17:46:44.992]   - Field: ‘gc’
[17:46:44.992]   - Field: ‘conditions’
[17:46:44.993]   - Field: ‘expr’
[17:46:44.993]   - Field: ‘uuid’
[17:46:44.993]   - Field: ‘seed’
[17:46:44.993]   - Field: ‘version’
[17:46:44.993]   - Field: ‘result’
[17:46:44.993]   - Field: ‘asynchronous’
[17:46:44.993]   - Field: ‘calls’
[17:46:44.993]   - Field: ‘globals’
[17:46:44.993]   - Field: ‘stdout’
[17:46:44.993]   - Field: ‘earlySignal’
[17:46:44.994]   - Field: ‘lazy’
[17:46:44.994]   - Field: ‘state’
[17:46:44.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:44.994] - Launch lazy future ...
[17:46:44.994] Packages needed by the future expression (n = 0): <none>
[17:46:44.994] Packages needed by future strategies (n = 0): <none>
[17:46:44.995] {
[17:46:44.995]     {
[17:46:44.995]         {
[17:46:44.995]             ...future.startTime <- base::Sys.time()
[17:46:44.995]             {
[17:46:44.995]                 {
[17:46:44.995]                   {
[17:46:44.995]                     base::local({
[17:46:44.995]                       has_future <- base::requireNamespace("future", 
[17:46:44.995]                         quietly = TRUE)
[17:46:44.995]                       if (has_future) {
[17:46:44.995]                         ns <- base::getNamespace("future")
[17:46:44.995]                         version <- ns[[".package"]][["version"]]
[17:46:44.995]                         if (is.null(version)) 
[17:46:44.995]                           version <- utils::packageVersion("future")
[17:46:44.995]                       }
[17:46:44.995]                       else {
[17:46:44.995]                         version <- NULL
[17:46:44.995]                       }
[17:46:44.995]                       if (!has_future || version < "1.8.0") {
[17:46:44.995]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:44.995]                           "", base::R.version$version.string), 
[17:46:44.995]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:44.995]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:44.995]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:44.995]                             "release", "version")], collapse = " "), 
[17:46:44.995]                           hostname = base::Sys.info()[["nodename"]])
[17:46:44.995]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:44.995]                           info)
[17:46:44.995]                         info <- base::paste(info, collapse = "; ")
[17:46:44.995]                         if (!has_future) {
[17:46:44.995]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:44.995]                             info)
[17:46:44.995]                         }
[17:46:44.995]                         else {
[17:46:44.995]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:44.995]                             info, version)
[17:46:44.995]                         }
[17:46:44.995]                         base::stop(msg)
[17:46:44.995]                       }
[17:46:44.995]                     })
[17:46:44.995]                   }
[17:46:44.995]                   ...future.strategy.old <- future::plan("list")
[17:46:44.995]                   options(future.plan = NULL)
[17:46:44.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:44.995]                 }
[17:46:44.995]                 ...future.workdir <- getwd()
[17:46:44.995]             }
[17:46:44.995]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:44.995]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:44.995]         }
[17:46:44.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:44.995]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:44.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:44.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:44.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:44.995]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:44.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:44.995]             base::names(...future.oldOptions))
[17:46:44.995]     }
[17:46:44.995]     if (FALSE) {
[17:46:44.995]     }
[17:46:44.995]     else {
[17:46:44.995]         if (TRUE) {
[17:46:44.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:44.995]                 open = "w")
[17:46:44.995]         }
[17:46:44.995]         else {
[17:46:44.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:44.995]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:44.995]         }
[17:46:44.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:44.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:44.995]             base::sink(type = "output", split = FALSE)
[17:46:44.995]             base::close(...future.stdout)
[17:46:44.995]         }, add = TRUE)
[17:46:44.995]     }
[17:46:44.995]     ...future.frame <- base::sys.nframe()
[17:46:44.995]     ...future.conditions <- base::list()
[17:46:44.995]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:44.995]     if (FALSE) {
[17:46:44.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:44.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:44.995]     }
[17:46:44.995]     ...future.result <- base::tryCatch({
[17:46:44.995]         base::withCallingHandlers({
[17:46:44.995]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:44.995]             future::FutureResult(value = ...future.value$value, 
[17:46:44.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.995]                   ...future.rng), globalenv = if (FALSE) 
[17:46:44.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:44.995]                     ...future.globalenv.names))
[17:46:44.995]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:44.995]         }, condition = base::local({
[17:46:44.995]             c <- base::c
[17:46:44.995]             inherits <- base::inherits
[17:46:44.995]             invokeRestart <- base::invokeRestart
[17:46:44.995]             length <- base::length
[17:46:44.995]             list <- base::list
[17:46:44.995]             seq.int <- base::seq.int
[17:46:44.995]             signalCondition <- base::signalCondition
[17:46:44.995]             sys.calls <- base::sys.calls
[17:46:44.995]             `[[` <- base::`[[`
[17:46:44.995]             `+` <- base::`+`
[17:46:44.995]             `<<-` <- base::`<<-`
[17:46:44.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:44.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:44.995]                   3L)]
[17:46:44.995]             }
[17:46:44.995]             function(cond) {
[17:46:44.995]                 is_error <- inherits(cond, "error")
[17:46:44.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:44.995]                   NULL)
[17:46:44.995]                 if (is_error) {
[17:46:44.995]                   sessionInformation <- function() {
[17:46:44.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:44.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:44.995]                       search = base::search(), system = base::Sys.info())
[17:46:44.995]                   }
[17:46:44.995]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:44.995]                     cond$call), session = sessionInformation(), 
[17:46:44.995]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:44.995]                   signalCondition(cond)
[17:46:44.995]                 }
[17:46:44.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:44.995]                 "immediateCondition"))) {
[17:46:44.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:44.995]                   ...future.conditions[[length(...future.conditions) + 
[17:46:44.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:44.995]                   if (TRUE && !signal) {
[17:46:44.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.995]                     {
[17:46:44.995]                       inherits <- base::inherits
[17:46:44.995]                       invokeRestart <- base::invokeRestart
[17:46:44.995]                       is.null <- base::is.null
[17:46:44.995]                       muffled <- FALSE
[17:46:44.995]                       if (inherits(cond, "message")) {
[17:46:44.995]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.995]                         if (muffled) 
[17:46:44.995]                           invokeRestart("muffleMessage")
[17:46:44.995]                       }
[17:46:44.995]                       else if (inherits(cond, "warning")) {
[17:46:44.995]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.995]                         if (muffled) 
[17:46:44.995]                           invokeRestart("muffleWarning")
[17:46:44.995]                       }
[17:46:44.995]                       else if (inherits(cond, "condition")) {
[17:46:44.995]                         if (!is.null(pattern)) {
[17:46:44.995]                           computeRestarts <- base::computeRestarts
[17:46:44.995]                           grepl <- base::grepl
[17:46:44.995]                           restarts <- computeRestarts(cond)
[17:46:44.995]                           for (restart in restarts) {
[17:46:44.995]                             name <- restart$name
[17:46:44.995]                             if (is.null(name)) 
[17:46:44.995]                               next
[17:46:44.995]                             if (!grepl(pattern, name)) 
[17:46:44.995]                               next
[17:46:44.995]                             invokeRestart(restart)
[17:46:44.995]                             muffled <- TRUE
[17:46:44.995]                             break
[17:46:44.995]                           }
[17:46:44.995]                         }
[17:46:44.995]                       }
[17:46:44.995]                       invisible(muffled)
[17:46:44.995]                     }
[17:46:44.995]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.995]                   }
[17:46:44.995]                 }
[17:46:44.995]                 else {
[17:46:44.995]                   if (TRUE) {
[17:46:44.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:44.995]                     {
[17:46:44.995]                       inherits <- base::inherits
[17:46:44.995]                       invokeRestart <- base::invokeRestart
[17:46:44.995]                       is.null <- base::is.null
[17:46:44.995]                       muffled <- FALSE
[17:46:44.995]                       if (inherits(cond, "message")) {
[17:46:44.995]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:44.995]                         if (muffled) 
[17:46:44.995]                           invokeRestart("muffleMessage")
[17:46:44.995]                       }
[17:46:44.995]                       else if (inherits(cond, "warning")) {
[17:46:44.995]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:44.995]                         if (muffled) 
[17:46:44.995]                           invokeRestart("muffleWarning")
[17:46:44.995]                       }
[17:46:44.995]                       else if (inherits(cond, "condition")) {
[17:46:44.995]                         if (!is.null(pattern)) {
[17:46:44.995]                           computeRestarts <- base::computeRestarts
[17:46:44.995]                           grepl <- base::grepl
[17:46:44.995]                           restarts <- computeRestarts(cond)
[17:46:44.995]                           for (restart in restarts) {
[17:46:44.995]                             name <- restart$name
[17:46:44.995]                             if (is.null(name)) 
[17:46:44.995]                               next
[17:46:44.995]                             if (!grepl(pattern, name)) 
[17:46:44.995]                               next
[17:46:44.995]                             invokeRestart(restart)
[17:46:44.995]                             muffled <- TRUE
[17:46:44.995]                             break
[17:46:44.995]                           }
[17:46:44.995]                         }
[17:46:44.995]                       }
[17:46:44.995]                       invisible(muffled)
[17:46:44.995]                     }
[17:46:44.995]                     muffleCondition(cond, pattern = "^muffle")
[17:46:44.995]                   }
[17:46:44.995]                 }
[17:46:44.995]             }
[17:46:44.995]         }))
[17:46:44.995]     }, error = function(ex) {
[17:46:44.995]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:44.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:44.995]                 ...future.rng), started = ...future.startTime, 
[17:46:44.995]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:44.995]             version = "1.8"), class = "FutureResult")
[17:46:44.995]     }, finally = {
[17:46:44.995]         if (!identical(...future.workdir, getwd())) 
[17:46:44.995]             setwd(...future.workdir)
[17:46:44.995]         {
[17:46:44.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:44.995]                 ...future.oldOptions$nwarnings <- NULL
[17:46:44.995]             }
[17:46:44.995]             base::options(...future.oldOptions)
[17:46:44.995]             if (.Platform$OS.type == "windows") {
[17:46:44.995]                 old_names <- names(...future.oldEnvVars)
[17:46:44.995]                 envs <- base::Sys.getenv()
[17:46:44.995]                 names <- names(envs)
[17:46:44.995]                 common <- intersect(names, old_names)
[17:46:44.995]                 added <- setdiff(names, old_names)
[17:46:44.995]                 removed <- setdiff(old_names, names)
[17:46:44.995]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:44.995]                   envs[common]]
[17:46:44.995]                 NAMES <- toupper(changed)
[17:46:44.995]                 args <- list()
[17:46:44.995]                 for (kk in seq_along(NAMES)) {
[17:46:44.995]                   name <- changed[[kk]]
[17:46:44.995]                   NAME <- NAMES[[kk]]
[17:46:44.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.995]                     next
[17:46:44.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.995]                 }
[17:46:44.995]                 NAMES <- toupper(added)
[17:46:44.995]                 for (kk in seq_along(NAMES)) {
[17:46:44.995]                   name <- added[[kk]]
[17:46:44.995]                   NAME <- NAMES[[kk]]
[17:46:44.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.995]                     next
[17:46:44.995]                   args[[name]] <- ""
[17:46:44.995]                 }
[17:46:44.995]                 NAMES <- toupper(removed)
[17:46:44.995]                 for (kk in seq_along(NAMES)) {
[17:46:44.995]                   name <- removed[[kk]]
[17:46:44.995]                   NAME <- NAMES[[kk]]
[17:46:44.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:44.995]                     next
[17:46:44.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:44.995]                 }
[17:46:44.995]                 if (length(args) > 0) 
[17:46:44.995]                   base::do.call(base::Sys.setenv, args = args)
[17:46:44.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:44.995]             }
[17:46:44.995]             else {
[17:46:44.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:44.995]             }
[17:46:44.995]             {
[17:46:44.995]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:44.995]                   0L) {
[17:46:44.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:44.995]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:44.995]                   base::options(opts)
[17:46:44.995]                 }
[17:46:44.995]                 {
[17:46:44.995]                   {
[17:46:44.995]                     NULL
[17:46:44.995]                     RNGkind("Mersenne-Twister")
[17:46:44.995]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:44.995]                       inherits = FALSE)
[17:46:44.995]                   }
[17:46:44.995]                   options(future.plan = NULL)
[17:46:44.995]                   if (is.na(NA_character_)) 
[17:46:44.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:44.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:44.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:44.995]                     .init = FALSE)
[17:46:44.995]                 }
[17:46:44.995]             }
[17:46:44.995]         }
[17:46:44.995]     })
[17:46:44.995]     if (TRUE) {
[17:46:44.995]         base::sink(type = "output", split = FALSE)
[17:46:44.995]         if (TRUE) {
[17:46:44.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:44.995]         }
[17:46:44.995]         else {
[17:46:44.995]             ...future.result["stdout"] <- base::list(NULL)
[17:46:44.995]         }
[17:46:44.995]         base::close(...future.stdout)
[17:46:44.995]         ...future.stdout <- NULL
[17:46:44.995]     }
[17:46:44.995]     ...future.result$conditions <- ...future.conditions
[17:46:44.995]     ...future.result$finished <- base::Sys.time()
[17:46:44.995]     ...future.result
[17:46:44.995] }
[17:46:44.996] plan(): Setting new future strategy stack:
[17:46:44.996] List of future strategies:
[17:46:44.996] 1. sequential:
[17:46:44.996]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.996]    - tweaked: FALSE
[17:46:44.996]    - call: NULL
[17:46:44.997] plan(): nbrOfWorkers() = 1
[17:46:44.997] plan(): Setting new future strategy stack:
[17:46:44.997] List of future strategies:
[17:46:44.997] 1. sequential:
[17:46:44.997]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:44.997]    - tweaked: FALSE
[17:46:44.997]    - call: plan(strategy)
[17:46:44.998] plan(): nbrOfWorkers() = 1
[17:46:44.998] SequentialFuture started (and completed)
[17:46:44.998] - Launch lazy future ... done
[17:46:44.998] run() for ‘SequentialFuture’ ... done
[17:46:44.999] getGlobalsAndPackages() ...
[17:46:44.999] Searching for globals...
[17:46:44.999] - globals found: [1] ‘{’
[17:46:44.999] Searching for globals ... DONE
[17:46:44.999] Resolving globals: FALSE
[17:46:45.000] 
[17:46:45.000] 
[17:46:45.000] getGlobalsAndPackages() ... DONE
[17:46:45.000] run() for ‘Future’ ...
[17:46:45.000] - state: ‘created’
[17:46:45.000] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:45.001] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:45.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:45.001]   - Field: ‘label’
[17:46:45.001]   - Field: ‘local’
[17:46:45.001]   - Field: ‘owner’
[17:46:45.001]   - Field: ‘envir’
[17:46:45.001]   - Field: ‘packages’
[17:46:45.001]   - Field: ‘gc’
[17:46:45.001]   - Field: ‘conditions’
[17:46:45.001]   - Field: ‘expr’
[17:46:45.002]   - Field: ‘uuid’
[17:46:45.002]   - Field: ‘seed’
[17:46:45.002]   - Field: ‘version’
[17:46:45.002]   - Field: ‘result’
[17:46:45.002]   - Field: ‘asynchronous’
[17:46:45.002]   - Field: ‘calls’
[17:46:45.002]   - Field: ‘globals’
[17:46:45.002]   - Field: ‘stdout’
[17:46:45.002]   - Field: ‘earlySignal’
[17:46:45.002]   - Field: ‘lazy’
[17:46:45.002]   - Field: ‘state’
[17:46:45.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:45.003] - Launch lazy future ...
[17:46:45.003] Packages needed by the future expression (n = 0): <none>
[17:46:45.003] Packages needed by future strategies (n = 0): <none>
[17:46:45.003] {
[17:46:45.003]     {
[17:46:45.003]         {
[17:46:45.003]             ...future.startTime <- base::Sys.time()
[17:46:45.003]             {
[17:46:45.003]                 {
[17:46:45.003]                   {
[17:46:45.003]                     base::local({
[17:46:45.003]                       has_future <- base::requireNamespace("future", 
[17:46:45.003]                         quietly = TRUE)
[17:46:45.003]                       if (has_future) {
[17:46:45.003]                         ns <- base::getNamespace("future")
[17:46:45.003]                         version <- ns[[".package"]][["version"]]
[17:46:45.003]                         if (is.null(version)) 
[17:46:45.003]                           version <- utils::packageVersion("future")
[17:46:45.003]                       }
[17:46:45.003]                       else {
[17:46:45.003]                         version <- NULL
[17:46:45.003]                       }
[17:46:45.003]                       if (!has_future || version < "1.8.0") {
[17:46:45.003]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.003]                           "", base::R.version$version.string), 
[17:46:45.003]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:45.003]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.003]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.003]                             "release", "version")], collapse = " "), 
[17:46:45.003]                           hostname = base::Sys.info()[["nodename"]])
[17:46:45.003]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.003]                           info)
[17:46:45.003]                         info <- base::paste(info, collapse = "; ")
[17:46:45.003]                         if (!has_future) {
[17:46:45.003]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.003]                             info)
[17:46:45.003]                         }
[17:46:45.003]                         else {
[17:46:45.003]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.003]                             info, version)
[17:46:45.003]                         }
[17:46:45.003]                         base::stop(msg)
[17:46:45.003]                       }
[17:46:45.003]                     })
[17:46:45.003]                   }
[17:46:45.003]                   ...future.strategy.old <- future::plan("list")
[17:46:45.003]                   options(future.plan = NULL)
[17:46:45.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.003]                 }
[17:46:45.003]                 ...future.workdir <- getwd()
[17:46:45.003]             }
[17:46:45.003]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.003]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.003]         }
[17:46:45.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.003]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.003]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.003]             base::names(...future.oldOptions))
[17:46:45.003]     }
[17:46:45.003]     if (FALSE) {
[17:46:45.003]     }
[17:46:45.003]     else {
[17:46:45.003]         if (TRUE) {
[17:46:45.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.003]                 open = "w")
[17:46:45.003]         }
[17:46:45.003]         else {
[17:46:45.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.003]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.003]         }
[17:46:45.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.003]             base::sink(type = "output", split = FALSE)
[17:46:45.003]             base::close(...future.stdout)
[17:46:45.003]         }, add = TRUE)
[17:46:45.003]     }
[17:46:45.003]     ...future.frame <- base::sys.nframe()
[17:46:45.003]     ...future.conditions <- base::list()
[17:46:45.003]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.003]     if (FALSE) {
[17:46:45.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.003]     }
[17:46:45.003]     ...future.result <- base::tryCatch({
[17:46:45.003]         base::withCallingHandlers({
[17:46:45.003]             ...future.value <- base::withVisible(base::local({
[17:46:45.003]                 4
[17:46:45.003]             }))
[17:46:45.003]             future::FutureResult(value = ...future.value$value, 
[17:46:45.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.003]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.003]                     ...future.globalenv.names))
[17:46:45.003]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.003]         }, condition = base::local({
[17:46:45.003]             c <- base::c
[17:46:45.003]             inherits <- base::inherits
[17:46:45.003]             invokeRestart <- base::invokeRestart
[17:46:45.003]             length <- base::length
[17:46:45.003]             list <- base::list
[17:46:45.003]             seq.int <- base::seq.int
[17:46:45.003]             signalCondition <- base::signalCondition
[17:46:45.003]             sys.calls <- base::sys.calls
[17:46:45.003]             `[[` <- base::`[[`
[17:46:45.003]             `+` <- base::`+`
[17:46:45.003]             `<<-` <- base::`<<-`
[17:46:45.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.003]                   3L)]
[17:46:45.003]             }
[17:46:45.003]             function(cond) {
[17:46:45.003]                 is_error <- inherits(cond, "error")
[17:46:45.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.003]                   NULL)
[17:46:45.003]                 if (is_error) {
[17:46:45.003]                   sessionInformation <- function() {
[17:46:45.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.003]                       search = base::search(), system = base::Sys.info())
[17:46:45.003]                   }
[17:46:45.003]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.003]                     cond$call), session = sessionInformation(), 
[17:46:45.003]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.003]                   signalCondition(cond)
[17:46:45.003]                 }
[17:46:45.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.003]                 "immediateCondition"))) {
[17:46:45.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.003]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.003]                   if (TRUE && !signal) {
[17:46:45.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.003]                     {
[17:46:45.003]                       inherits <- base::inherits
[17:46:45.003]                       invokeRestart <- base::invokeRestart
[17:46:45.003]                       is.null <- base::is.null
[17:46:45.003]                       muffled <- FALSE
[17:46:45.003]                       if (inherits(cond, "message")) {
[17:46:45.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.003]                         if (muffled) 
[17:46:45.003]                           invokeRestart("muffleMessage")
[17:46:45.003]                       }
[17:46:45.003]                       else if (inherits(cond, "warning")) {
[17:46:45.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.003]                         if (muffled) 
[17:46:45.003]                           invokeRestart("muffleWarning")
[17:46:45.003]                       }
[17:46:45.003]                       else if (inherits(cond, "condition")) {
[17:46:45.003]                         if (!is.null(pattern)) {
[17:46:45.003]                           computeRestarts <- base::computeRestarts
[17:46:45.003]                           grepl <- base::grepl
[17:46:45.003]                           restarts <- computeRestarts(cond)
[17:46:45.003]                           for (restart in restarts) {
[17:46:45.003]                             name <- restart$name
[17:46:45.003]                             if (is.null(name)) 
[17:46:45.003]                               next
[17:46:45.003]                             if (!grepl(pattern, name)) 
[17:46:45.003]                               next
[17:46:45.003]                             invokeRestart(restart)
[17:46:45.003]                             muffled <- TRUE
[17:46:45.003]                             break
[17:46:45.003]                           }
[17:46:45.003]                         }
[17:46:45.003]                       }
[17:46:45.003]                       invisible(muffled)
[17:46:45.003]                     }
[17:46:45.003]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.003]                   }
[17:46:45.003]                 }
[17:46:45.003]                 else {
[17:46:45.003]                   if (TRUE) {
[17:46:45.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.003]                     {
[17:46:45.003]                       inherits <- base::inherits
[17:46:45.003]                       invokeRestart <- base::invokeRestart
[17:46:45.003]                       is.null <- base::is.null
[17:46:45.003]                       muffled <- FALSE
[17:46:45.003]                       if (inherits(cond, "message")) {
[17:46:45.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.003]                         if (muffled) 
[17:46:45.003]                           invokeRestart("muffleMessage")
[17:46:45.003]                       }
[17:46:45.003]                       else if (inherits(cond, "warning")) {
[17:46:45.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.003]                         if (muffled) 
[17:46:45.003]                           invokeRestart("muffleWarning")
[17:46:45.003]                       }
[17:46:45.003]                       else if (inherits(cond, "condition")) {
[17:46:45.003]                         if (!is.null(pattern)) {
[17:46:45.003]                           computeRestarts <- base::computeRestarts
[17:46:45.003]                           grepl <- base::grepl
[17:46:45.003]                           restarts <- computeRestarts(cond)
[17:46:45.003]                           for (restart in restarts) {
[17:46:45.003]                             name <- restart$name
[17:46:45.003]                             if (is.null(name)) 
[17:46:45.003]                               next
[17:46:45.003]                             if (!grepl(pattern, name)) 
[17:46:45.003]                               next
[17:46:45.003]                             invokeRestart(restart)
[17:46:45.003]                             muffled <- TRUE
[17:46:45.003]                             break
[17:46:45.003]                           }
[17:46:45.003]                         }
[17:46:45.003]                       }
[17:46:45.003]                       invisible(muffled)
[17:46:45.003]                     }
[17:46:45.003]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.003]                   }
[17:46:45.003]                 }
[17:46:45.003]             }
[17:46:45.003]         }))
[17:46:45.003]     }, error = function(ex) {
[17:46:45.003]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.003]                 ...future.rng), started = ...future.startTime, 
[17:46:45.003]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.003]             version = "1.8"), class = "FutureResult")
[17:46:45.003]     }, finally = {
[17:46:45.003]         if (!identical(...future.workdir, getwd())) 
[17:46:45.003]             setwd(...future.workdir)
[17:46:45.003]         {
[17:46:45.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.003]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.003]             }
[17:46:45.003]             base::options(...future.oldOptions)
[17:46:45.003]             if (.Platform$OS.type == "windows") {
[17:46:45.003]                 old_names <- names(...future.oldEnvVars)
[17:46:45.003]                 envs <- base::Sys.getenv()
[17:46:45.003]                 names <- names(envs)
[17:46:45.003]                 common <- intersect(names, old_names)
[17:46:45.003]                 added <- setdiff(names, old_names)
[17:46:45.003]                 removed <- setdiff(old_names, names)
[17:46:45.003]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.003]                   envs[common]]
[17:46:45.003]                 NAMES <- toupper(changed)
[17:46:45.003]                 args <- list()
[17:46:45.003]                 for (kk in seq_along(NAMES)) {
[17:46:45.003]                   name <- changed[[kk]]
[17:46:45.003]                   NAME <- NAMES[[kk]]
[17:46:45.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.003]                     next
[17:46:45.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.003]                 }
[17:46:45.003]                 NAMES <- toupper(added)
[17:46:45.003]                 for (kk in seq_along(NAMES)) {
[17:46:45.003]                   name <- added[[kk]]
[17:46:45.003]                   NAME <- NAMES[[kk]]
[17:46:45.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.003]                     next
[17:46:45.003]                   args[[name]] <- ""
[17:46:45.003]                 }
[17:46:45.003]                 NAMES <- toupper(removed)
[17:46:45.003]                 for (kk in seq_along(NAMES)) {
[17:46:45.003]                   name <- removed[[kk]]
[17:46:45.003]                   NAME <- NAMES[[kk]]
[17:46:45.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.003]                     next
[17:46:45.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.003]                 }
[17:46:45.003]                 if (length(args) > 0) 
[17:46:45.003]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.003]             }
[17:46:45.003]             else {
[17:46:45.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.003]             }
[17:46:45.003]             {
[17:46:45.003]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.003]                   0L) {
[17:46:45.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.003]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.003]                   base::options(opts)
[17:46:45.003]                 }
[17:46:45.003]                 {
[17:46:45.003]                   {
[17:46:45.003]                     NULL
[17:46:45.003]                     RNGkind("Mersenne-Twister")
[17:46:45.003]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:45.003]                       inherits = FALSE)
[17:46:45.003]                   }
[17:46:45.003]                   options(future.plan = NULL)
[17:46:45.003]                   if (is.na(NA_character_)) 
[17:46:45.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.003]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.003]                     .init = FALSE)
[17:46:45.003]                 }
[17:46:45.003]             }
[17:46:45.003]         }
[17:46:45.003]     })
[17:46:45.003]     if (TRUE) {
[17:46:45.003]         base::sink(type = "output", split = FALSE)
[17:46:45.003]         if (TRUE) {
[17:46:45.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.003]         }
[17:46:45.003]         else {
[17:46:45.003]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.003]         }
[17:46:45.003]         base::close(...future.stdout)
[17:46:45.003]         ...future.stdout <- NULL
[17:46:45.003]     }
[17:46:45.003]     ...future.result$conditions <- ...future.conditions
[17:46:45.003]     ...future.result$finished <- base::Sys.time()
[17:46:45.003]     ...future.result
[17:46:45.003] }
[17:46:45.005] plan(): Setting new future strategy stack:
[17:46:45.005] List of future strategies:
[17:46:45.005] 1. sequential:
[17:46:45.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.005]    - tweaked: FALSE
[17:46:45.005]    - call: NULL
[17:46:45.006] plan(): nbrOfWorkers() = 1
[17:46:45.006] plan(): Setting new future strategy stack:
[17:46:45.006] List of future strategies:
[17:46:45.006] 1. sequential:
[17:46:45.006]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.006]    - tweaked: FALSE
[17:46:45.006]    - call: plan(strategy)
[17:46:45.007] plan(): nbrOfWorkers() = 1
[17:46:45.007] SequentialFuture started (and completed)
[17:46:45.007] - Launch lazy future ... done
[17:46:45.008] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x561785758eb8> 
Classes 'listenv', 'environment' <environment: 0x56178601f3a8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:46:45.012] resolved() for ‘SequentialFuture’ ...
[17:46:45.012] - state: ‘finished’
[17:46:45.012] - run: TRUE
[17:46:45.012] - result: ‘FutureResult’
[17:46:45.012] resolved() for ‘SequentialFuture’ ... done
[17:46:45.012] resolved() for ‘SequentialFuture’ ...
[17:46:45.012] - state: ‘finished’
[17:46:45.012] - run: TRUE
[17:46:45.012] - result: ‘FutureResult’
[17:46:45.012] resolved() for ‘SequentialFuture’ ... done
[17:46:45.013] resolved() for ‘SequentialFuture’ ...
[17:46:45.013] - state: ‘finished’
[17:46:45.013] - run: TRUE
[17:46:45.013] - result: ‘FutureResult’
[17:46:45.013] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:45.015] resolve() on list environment ...
[17:46:45.015]  recursive: 0
[17:46:45.016]  length: 6
[17:46:45.016]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:45.016] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.016] - nx: 6
[17:46:45.016] - relay: TRUE
[17:46:45.017] - stdout: TRUE
[17:46:45.017] - signal: TRUE
[17:46:45.017] - resignal: FALSE
[17:46:45.017] - force: TRUE
[17:46:45.017] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.017] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.017]  - until=2
[17:46:45.017]  - relaying element #2
[17:46:45.017] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.017] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.017] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.017]  length: 5 (resolved future 1)
[17:46:45.018] resolved() for ‘SequentialFuture’ ...
[17:46:45.018] - state: ‘finished’
[17:46:45.018] - run: TRUE
[17:46:45.018] - result: ‘FutureResult’
[17:46:45.018] resolved() for ‘SequentialFuture’ ... done
[17:46:45.018] Future #2
[17:46:45.018] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:45.018] - nx: 6
[17:46:45.018] - relay: TRUE
[17:46:45.018] - stdout: TRUE
[17:46:45.018] - signal: TRUE
[17:46:45.019] - resignal: FALSE
[17:46:45.019] - force: TRUE
[17:46:45.019] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.019] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.019]  - until=2
[17:46:45.019]  - relaying element #2
[17:46:45.019] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.019] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.019] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:45.019]  length: 4 (resolved future 2)
[17:46:45.020] resolved() for ‘SequentialFuture’ ...
[17:46:45.020] - state: ‘finished’
[17:46:45.020] - run: TRUE
[17:46:45.020] - result: ‘FutureResult’
[17:46:45.020] resolved() for ‘SequentialFuture’ ... done
[17:46:45.020] Future #3
[17:46:45.020] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:45.020] - nx: 6
[17:46:45.020] - relay: TRUE
[17:46:45.020] - stdout: TRUE
[17:46:45.020] - signal: TRUE
[17:46:45.021] - resignal: FALSE
[17:46:45.021] - force: TRUE
[17:46:45.021] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.021] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.021]  - until=3
[17:46:45.021]  - relaying element #3
[17:46:45.021] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.021] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.021] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:45.021]  length: 3 (resolved future 3)
[17:46:45.022] resolved() for ‘SequentialFuture’ ...
[17:46:45.022] - state: ‘finished’
[17:46:45.022] - run: TRUE
[17:46:45.022] - result: ‘FutureResult’
[17:46:45.022] resolved() for ‘SequentialFuture’ ... done
[17:46:45.022] Future #4
[17:46:45.022] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:45.022] - nx: 6
[17:46:45.022] - relay: TRUE
[17:46:45.022] - stdout: TRUE
[17:46:45.022] - signal: TRUE
[17:46:45.022] - resignal: FALSE
[17:46:45.023] - force: TRUE
[17:46:45.023] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.023] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.023]  - until=4
[17:46:45.023]  - relaying element #4
[17:46:45.023] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.023] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.023] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:45.023]  length: 2 (resolved future 4)
[17:46:45.023] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.024] - nx: 6
[17:46:45.024] - relay: TRUE
[17:46:45.024] - stdout: TRUE
[17:46:45.024] - signal: TRUE
[17:46:45.024] - resignal: FALSE
[17:46:45.024] - force: TRUE
[17:46:45.024] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.024] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.024]  - until=6
[17:46:45.024]  - relaying element #6
[17:46:45.024] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.024] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.025] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.025]  length: 1 (resolved future 5)
[17:46:45.025] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.025] - nx: 6
[17:46:45.025] - relay: TRUE
[17:46:45.025] - stdout: TRUE
[17:46:45.025] - signal: TRUE
[17:46:45.025] - resignal: FALSE
[17:46:45.025] - force: TRUE
[17:46:45.025] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.025] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.025]  - until=6
[17:46:45.026] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.026] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.026] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.026]  length: 0 (resolved future 6)
[17:46:45.026] Relaying remaining futures
[17:46:45.026] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.026] - nx: 6
[17:46:45.026] - relay: TRUE
[17:46:45.026] - stdout: TRUE
[17:46:45.026] - signal: TRUE
[17:46:45.026] - resignal: FALSE
[17:46:45.026] - force: TRUE
[17:46:45.027] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.027] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:45.027] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.027] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.027] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.027] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x561785bb5498> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:46:45.029] getGlobalsAndPackages() ...
[17:46:45.029] Searching for globals...
[17:46:45.029] 
[17:46:45.029] Searching for globals ... DONE
[17:46:45.029] - globals: [0] <none>
[17:46:45.030] getGlobalsAndPackages() ... DONE
[17:46:45.030] run() for ‘Future’ ...
[17:46:45.030] - state: ‘created’
[17:46:45.030] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:45.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:45.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:45.030]   - Field: ‘label’
[17:46:45.031]   - Field: ‘local’
[17:46:45.031]   - Field: ‘owner’
[17:46:45.031]   - Field: ‘envir’
[17:46:45.031]   - Field: ‘packages’
[17:46:45.031]   - Field: ‘gc’
[17:46:45.031]   - Field: ‘conditions’
[17:46:45.031]   - Field: ‘expr’
[17:46:45.031]   - Field: ‘uuid’
[17:46:45.031]   - Field: ‘seed’
[17:46:45.031]   - Field: ‘version’
[17:46:45.031]   - Field: ‘result’
[17:46:45.032]   - Field: ‘asynchronous’
[17:46:45.032]   - Field: ‘calls’
[17:46:45.032]   - Field: ‘globals’
[17:46:45.032]   - Field: ‘stdout’
[17:46:45.033]   - Field: ‘earlySignal’
[17:46:45.033]   - Field: ‘lazy’
[17:46:45.033]   - Field: ‘state’
[17:46:45.033] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:45.033] - Launch lazy future ...
[17:46:45.034] Packages needed by the future expression (n = 0): <none>
[17:46:45.034] Packages needed by future strategies (n = 0): <none>
[17:46:45.034] {
[17:46:45.034]     {
[17:46:45.034]         {
[17:46:45.034]             ...future.startTime <- base::Sys.time()
[17:46:45.034]             {
[17:46:45.034]                 {
[17:46:45.034]                   {
[17:46:45.034]                     base::local({
[17:46:45.034]                       has_future <- base::requireNamespace("future", 
[17:46:45.034]                         quietly = TRUE)
[17:46:45.034]                       if (has_future) {
[17:46:45.034]                         ns <- base::getNamespace("future")
[17:46:45.034]                         version <- ns[[".package"]][["version"]]
[17:46:45.034]                         if (is.null(version)) 
[17:46:45.034]                           version <- utils::packageVersion("future")
[17:46:45.034]                       }
[17:46:45.034]                       else {
[17:46:45.034]                         version <- NULL
[17:46:45.034]                       }
[17:46:45.034]                       if (!has_future || version < "1.8.0") {
[17:46:45.034]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.034]                           "", base::R.version$version.string), 
[17:46:45.034]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:45.034]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.034]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.034]                             "release", "version")], collapse = " "), 
[17:46:45.034]                           hostname = base::Sys.info()[["nodename"]])
[17:46:45.034]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.034]                           info)
[17:46:45.034]                         info <- base::paste(info, collapse = "; ")
[17:46:45.034]                         if (!has_future) {
[17:46:45.034]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.034]                             info)
[17:46:45.034]                         }
[17:46:45.034]                         else {
[17:46:45.034]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.034]                             info, version)
[17:46:45.034]                         }
[17:46:45.034]                         base::stop(msg)
[17:46:45.034]                       }
[17:46:45.034]                     })
[17:46:45.034]                   }
[17:46:45.034]                   ...future.strategy.old <- future::plan("list")
[17:46:45.034]                   options(future.plan = NULL)
[17:46:45.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.034]                 }
[17:46:45.034]                 ...future.workdir <- getwd()
[17:46:45.034]             }
[17:46:45.034]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.034]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.034]         }
[17:46:45.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.034]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.034]             base::names(...future.oldOptions))
[17:46:45.034]     }
[17:46:45.034]     if (FALSE) {
[17:46:45.034]     }
[17:46:45.034]     else {
[17:46:45.034]         if (TRUE) {
[17:46:45.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.034]                 open = "w")
[17:46:45.034]         }
[17:46:45.034]         else {
[17:46:45.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.034]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.034]         }
[17:46:45.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.034]             base::sink(type = "output", split = FALSE)
[17:46:45.034]             base::close(...future.stdout)
[17:46:45.034]         }, add = TRUE)
[17:46:45.034]     }
[17:46:45.034]     ...future.frame <- base::sys.nframe()
[17:46:45.034]     ...future.conditions <- base::list()
[17:46:45.034]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.034]     if (FALSE) {
[17:46:45.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.034]     }
[17:46:45.034]     ...future.result <- base::tryCatch({
[17:46:45.034]         base::withCallingHandlers({
[17:46:45.034]             ...future.value <- base::withVisible(base::local(2))
[17:46:45.034]             future::FutureResult(value = ...future.value$value, 
[17:46:45.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.034]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.034]                     ...future.globalenv.names))
[17:46:45.034]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.034]         }, condition = base::local({
[17:46:45.034]             c <- base::c
[17:46:45.034]             inherits <- base::inherits
[17:46:45.034]             invokeRestart <- base::invokeRestart
[17:46:45.034]             length <- base::length
[17:46:45.034]             list <- base::list
[17:46:45.034]             seq.int <- base::seq.int
[17:46:45.034]             signalCondition <- base::signalCondition
[17:46:45.034]             sys.calls <- base::sys.calls
[17:46:45.034]             `[[` <- base::`[[`
[17:46:45.034]             `+` <- base::`+`
[17:46:45.034]             `<<-` <- base::`<<-`
[17:46:45.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.034]                   3L)]
[17:46:45.034]             }
[17:46:45.034]             function(cond) {
[17:46:45.034]                 is_error <- inherits(cond, "error")
[17:46:45.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.034]                   NULL)
[17:46:45.034]                 if (is_error) {
[17:46:45.034]                   sessionInformation <- function() {
[17:46:45.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.034]                       search = base::search(), system = base::Sys.info())
[17:46:45.034]                   }
[17:46:45.034]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.034]                     cond$call), session = sessionInformation(), 
[17:46:45.034]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.034]                   signalCondition(cond)
[17:46:45.034]                 }
[17:46:45.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.034]                 "immediateCondition"))) {
[17:46:45.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.034]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.034]                   if (TRUE && !signal) {
[17:46:45.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.034]                     {
[17:46:45.034]                       inherits <- base::inherits
[17:46:45.034]                       invokeRestart <- base::invokeRestart
[17:46:45.034]                       is.null <- base::is.null
[17:46:45.034]                       muffled <- FALSE
[17:46:45.034]                       if (inherits(cond, "message")) {
[17:46:45.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.034]                         if (muffled) 
[17:46:45.034]                           invokeRestart("muffleMessage")
[17:46:45.034]                       }
[17:46:45.034]                       else if (inherits(cond, "warning")) {
[17:46:45.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.034]                         if (muffled) 
[17:46:45.034]                           invokeRestart("muffleWarning")
[17:46:45.034]                       }
[17:46:45.034]                       else if (inherits(cond, "condition")) {
[17:46:45.034]                         if (!is.null(pattern)) {
[17:46:45.034]                           computeRestarts <- base::computeRestarts
[17:46:45.034]                           grepl <- base::grepl
[17:46:45.034]                           restarts <- computeRestarts(cond)
[17:46:45.034]                           for (restart in restarts) {
[17:46:45.034]                             name <- restart$name
[17:46:45.034]                             if (is.null(name)) 
[17:46:45.034]                               next
[17:46:45.034]                             if (!grepl(pattern, name)) 
[17:46:45.034]                               next
[17:46:45.034]                             invokeRestart(restart)
[17:46:45.034]                             muffled <- TRUE
[17:46:45.034]                             break
[17:46:45.034]                           }
[17:46:45.034]                         }
[17:46:45.034]                       }
[17:46:45.034]                       invisible(muffled)
[17:46:45.034]                     }
[17:46:45.034]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.034]                   }
[17:46:45.034]                 }
[17:46:45.034]                 else {
[17:46:45.034]                   if (TRUE) {
[17:46:45.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.034]                     {
[17:46:45.034]                       inherits <- base::inherits
[17:46:45.034]                       invokeRestart <- base::invokeRestart
[17:46:45.034]                       is.null <- base::is.null
[17:46:45.034]                       muffled <- FALSE
[17:46:45.034]                       if (inherits(cond, "message")) {
[17:46:45.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.034]                         if (muffled) 
[17:46:45.034]                           invokeRestart("muffleMessage")
[17:46:45.034]                       }
[17:46:45.034]                       else if (inherits(cond, "warning")) {
[17:46:45.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.034]                         if (muffled) 
[17:46:45.034]                           invokeRestart("muffleWarning")
[17:46:45.034]                       }
[17:46:45.034]                       else if (inherits(cond, "condition")) {
[17:46:45.034]                         if (!is.null(pattern)) {
[17:46:45.034]                           computeRestarts <- base::computeRestarts
[17:46:45.034]                           grepl <- base::grepl
[17:46:45.034]                           restarts <- computeRestarts(cond)
[17:46:45.034]                           for (restart in restarts) {
[17:46:45.034]                             name <- restart$name
[17:46:45.034]                             if (is.null(name)) 
[17:46:45.034]                               next
[17:46:45.034]                             if (!grepl(pattern, name)) 
[17:46:45.034]                               next
[17:46:45.034]                             invokeRestart(restart)
[17:46:45.034]                             muffled <- TRUE
[17:46:45.034]                             break
[17:46:45.034]                           }
[17:46:45.034]                         }
[17:46:45.034]                       }
[17:46:45.034]                       invisible(muffled)
[17:46:45.034]                     }
[17:46:45.034]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.034]                   }
[17:46:45.034]                 }
[17:46:45.034]             }
[17:46:45.034]         }))
[17:46:45.034]     }, error = function(ex) {
[17:46:45.034]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.034]                 ...future.rng), started = ...future.startTime, 
[17:46:45.034]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.034]             version = "1.8"), class = "FutureResult")
[17:46:45.034]     }, finally = {
[17:46:45.034]         if (!identical(...future.workdir, getwd())) 
[17:46:45.034]             setwd(...future.workdir)
[17:46:45.034]         {
[17:46:45.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.034]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.034]             }
[17:46:45.034]             base::options(...future.oldOptions)
[17:46:45.034]             if (.Platform$OS.type == "windows") {
[17:46:45.034]                 old_names <- names(...future.oldEnvVars)
[17:46:45.034]                 envs <- base::Sys.getenv()
[17:46:45.034]                 names <- names(envs)
[17:46:45.034]                 common <- intersect(names, old_names)
[17:46:45.034]                 added <- setdiff(names, old_names)
[17:46:45.034]                 removed <- setdiff(old_names, names)
[17:46:45.034]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.034]                   envs[common]]
[17:46:45.034]                 NAMES <- toupper(changed)
[17:46:45.034]                 args <- list()
[17:46:45.034]                 for (kk in seq_along(NAMES)) {
[17:46:45.034]                   name <- changed[[kk]]
[17:46:45.034]                   NAME <- NAMES[[kk]]
[17:46:45.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.034]                     next
[17:46:45.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.034]                 }
[17:46:45.034]                 NAMES <- toupper(added)
[17:46:45.034]                 for (kk in seq_along(NAMES)) {
[17:46:45.034]                   name <- added[[kk]]
[17:46:45.034]                   NAME <- NAMES[[kk]]
[17:46:45.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.034]                     next
[17:46:45.034]                   args[[name]] <- ""
[17:46:45.034]                 }
[17:46:45.034]                 NAMES <- toupper(removed)
[17:46:45.034]                 for (kk in seq_along(NAMES)) {
[17:46:45.034]                   name <- removed[[kk]]
[17:46:45.034]                   NAME <- NAMES[[kk]]
[17:46:45.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.034]                     next
[17:46:45.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.034]                 }
[17:46:45.034]                 if (length(args) > 0) 
[17:46:45.034]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.034]             }
[17:46:45.034]             else {
[17:46:45.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.034]             }
[17:46:45.034]             {
[17:46:45.034]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.034]                   0L) {
[17:46:45.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.034]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.034]                   base::options(opts)
[17:46:45.034]                 }
[17:46:45.034]                 {
[17:46:45.034]                   {
[17:46:45.034]                     NULL
[17:46:45.034]                     RNGkind("Mersenne-Twister")
[17:46:45.034]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:45.034]                       inherits = FALSE)
[17:46:45.034]                   }
[17:46:45.034]                   options(future.plan = NULL)
[17:46:45.034]                   if (is.na(NA_character_)) 
[17:46:45.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.034]                     .init = FALSE)
[17:46:45.034]                 }
[17:46:45.034]             }
[17:46:45.034]         }
[17:46:45.034]     })
[17:46:45.034]     if (TRUE) {
[17:46:45.034]         base::sink(type = "output", split = FALSE)
[17:46:45.034]         if (TRUE) {
[17:46:45.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.034]         }
[17:46:45.034]         else {
[17:46:45.034]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.034]         }
[17:46:45.034]         base::close(...future.stdout)
[17:46:45.034]         ...future.stdout <- NULL
[17:46:45.034]     }
[17:46:45.034]     ...future.result$conditions <- ...future.conditions
[17:46:45.034]     ...future.result$finished <- base::Sys.time()
[17:46:45.034]     ...future.result
[17:46:45.034] }
[17:46:45.036] plan(): Setting new future strategy stack:
[17:46:45.036] List of future strategies:
[17:46:45.036] 1. sequential:
[17:46:45.036]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.036]    - tweaked: FALSE
[17:46:45.036]    - call: NULL
[17:46:45.036] plan(): nbrOfWorkers() = 1
[17:46:45.037] plan(): Setting new future strategy stack:
[17:46:45.037] List of future strategies:
[17:46:45.037] 1. sequential:
[17:46:45.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.037]    - tweaked: FALSE
[17:46:45.037]    - call: plan(strategy)
[17:46:45.038] plan(): nbrOfWorkers() = 1
[17:46:45.038] SequentialFuture started (and completed)
[17:46:45.038] - Launch lazy future ... done
[17:46:45.038] run() for ‘SequentialFuture’ ... done
[17:46:45.038] getGlobalsAndPackages() ...
[17:46:45.038] Searching for globals...
[17:46:45.039] 
[17:46:45.039] Searching for globals ... DONE
[17:46:45.039] - globals: [0] <none>
[17:46:45.039] getGlobalsAndPackages() ... DONE
[17:46:45.039] run() for ‘Future’ ...
[17:46:45.039] - state: ‘created’
[17:46:45.039] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:45.040] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:45.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:45.040]   - Field: ‘label’
[17:46:45.040]   - Field: ‘local’
[17:46:45.040]   - Field: ‘owner’
[17:46:45.040]   - Field: ‘envir’
[17:46:45.040]   - Field: ‘packages’
[17:46:45.040]   - Field: ‘gc’
[17:46:45.040]   - Field: ‘conditions’
[17:46:45.040]   - Field: ‘expr’
[17:46:45.041]   - Field: ‘uuid’
[17:46:45.041]   - Field: ‘seed’
[17:46:45.041]   - Field: ‘version’
[17:46:45.041]   - Field: ‘result’
[17:46:45.041]   - Field: ‘asynchronous’
[17:46:45.041]   - Field: ‘calls’
[17:46:45.041]   - Field: ‘globals’
[17:46:45.041]   - Field: ‘stdout’
[17:46:45.041]   - Field: ‘earlySignal’
[17:46:45.041]   - Field: ‘lazy’
[17:46:45.041]   - Field: ‘state’
[17:46:45.041] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:45.042] - Launch lazy future ...
[17:46:45.042] Packages needed by the future expression (n = 0): <none>
[17:46:45.042] Packages needed by future strategies (n = 0): <none>
[17:46:45.042] {
[17:46:45.042]     {
[17:46:45.042]         {
[17:46:45.042]             ...future.startTime <- base::Sys.time()
[17:46:45.042]             {
[17:46:45.042]                 {
[17:46:45.042]                   {
[17:46:45.042]                     base::local({
[17:46:45.042]                       has_future <- base::requireNamespace("future", 
[17:46:45.042]                         quietly = TRUE)
[17:46:45.042]                       if (has_future) {
[17:46:45.042]                         ns <- base::getNamespace("future")
[17:46:45.042]                         version <- ns[[".package"]][["version"]]
[17:46:45.042]                         if (is.null(version)) 
[17:46:45.042]                           version <- utils::packageVersion("future")
[17:46:45.042]                       }
[17:46:45.042]                       else {
[17:46:45.042]                         version <- NULL
[17:46:45.042]                       }
[17:46:45.042]                       if (!has_future || version < "1.8.0") {
[17:46:45.042]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.042]                           "", base::R.version$version.string), 
[17:46:45.042]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:45.042]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.042]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.042]                             "release", "version")], collapse = " "), 
[17:46:45.042]                           hostname = base::Sys.info()[["nodename"]])
[17:46:45.042]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.042]                           info)
[17:46:45.042]                         info <- base::paste(info, collapse = "; ")
[17:46:45.042]                         if (!has_future) {
[17:46:45.042]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.042]                             info)
[17:46:45.042]                         }
[17:46:45.042]                         else {
[17:46:45.042]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.042]                             info, version)
[17:46:45.042]                         }
[17:46:45.042]                         base::stop(msg)
[17:46:45.042]                       }
[17:46:45.042]                     })
[17:46:45.042]                   }
[17:46:45.042]                   ...future.strategy.old <- future::plan("list")
[17:46:45.042]                   options(future.plan = NULL)
[17:46:45.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.042]                 }
[17:46:45.042]                 ...future.workdir <- getwd()
[17:46:45.042]             }
[17:46:45.042]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.042]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.042]         }
[17:46:45.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.042]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.042]             base::names(...future.oldOptions))
[17:46:45.042]     }
[17:46:45.042]     if (FALSE) {
[17:46:45.042]     }
[17:46:45.042]     else {
[17:46:45.042]         if (TRUE) {
[17:46:45.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.042]                 open = "w")
[17:46:45.042]         }
[17:46:45.042]         else {
[17:46:45.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.042]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.042]         }
[17:46:45.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.042]             base::sink(type = "output", split = FALSE)
[17:46:45.042]             base::close(...future.stdout)
[17:46:45.042]         }, add = TRUE)
[17:46:45.042]     }
[17:46:45.042]     ...future.frame <- base::sys.nframe()
[17:46:45.042]     ...future.conditions <- base::list()
[17:46:45.042]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.042]     if (FALSE) {
[17:46:45.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.042]     }
[17:46:45.042]     ...future.result <- base::tryCatch({
[17:46:45.042]         base::withCallingHandlers({
[17:46:45.042]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:45.042]             future::FutureResult(value = ...future.value$value, 
[17:46:45.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.042]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.042]                     ...future.globalenv.names))
[17:46:45.042]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.042]         }, condition = base::local({
[17:46:45.042]             c <- base::c
[17:46:45.042]             inherits <- base::inherits
[17:46:45.042]             invokeRestart <- base::invokeRestart
[17:46:45.042]             length <- base::length
[17:46:45.042]             list <- base::list
[17:46:45.042]             seq.int <- base::seq.int
[17:46:45.042]             signalCondition <- base::signalCondition
[17:46:45.042]             sys.calls <- base::sys.calls
[17:46:45.042]             `[[` <- base::`[[`
[17:46:45.042]             `+` <- base::`+`
[17:46:45.042]             `<<-` <- base::`<<-`
[17:46:45.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.042]                   3L)]
[17:46:45.042]             }
[17:46:45.042]             function(cond) {
[17:46:45.042]                 is_error <- inherits(cond, "error")
[17:46:45.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.042]                   NULL)
[17:46:45.042]                 if (is_error) {
[17:46:45.042]                   sessionInformation <- function() {
[17:46:45.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.042]                       search = base::search(), system = base::Sys.info())
[17:46:45.042]                   }
[17:46:45.042]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.042]                     cond$call), session = sessionInformation(), 
[17:46:45.042]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.042]                   signalCondition(cond)
[17:46:45.042]                 }
[17:46:45.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.042]                 "immediateCondition"))) {
[17:46:45.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.042]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.042]                   if (TRUE && !signal) {
[17:46:45.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.042]                     {
[17:46:45.042]                       inherits <- base::inherits
[17:46:45.042]                       invokeRestart <- base::invokeRestart
[17:46:45.042]                       is.null <- base::is.null
[17:46:45.042]                       muffled <- FALSE
[17:46:45.042]                       if (inherits(cond, "message")) {
[17:46:45.042]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.042]                         if (muffled) 
[17:46:45.042]                           invokeRestart("muffleMessage")
[17:46:45.042]                       }
[17:46:45.042]                       else if (inherits(cond, "warning")) {
[17:46:45.042]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.042]                         if (muffled) 
[17:46:45.042]                           invokeRestart("muffleWarning")
[17:46:45.042]                       }
[17:46:45.042]                       else if (inherits(cond, "condition")) {
[17:46:45.042]                         if (!is.null(pattern)) {
[17:46:45.042]                           computeRestarts <- base::computeRestarts
[17:46:45.042]                           grepl <- base::grepl
[17:46:45.042]                           restarts <- computeRestarts(cond)
[17:46:45.042]                           for (restart in restarts) {
[17:46:45.042]                             name <- restart$name
[17:46:45.042]                             if (is.null(name)) 
[17:46:45.042]                               next
[17:46:45.042]                             if (!grepl(pattern, name)) 
[17:46:45.042]                               next
[17:46:45.042]                             invokeRestart(restart)
[17:46:45.042]                             muffled <- TRUE
[17:46:45.042]                             break
[17:46:45.042]                           }
[17:46:45.042]                         }
[17:46:45.042]                       }
[17:46:45.042]                       invisible(muffled)
[17:46:45.042]                     }
[17:46:45.042]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.042]                   }
[17:46:45.042]                 }
[17:46:45.042]                 else {
[17:46:45.042]                   if (TRUE) {
[17:46:45.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.042]                     {
[17:46:45.042]                       inherits <- base::inherits
[17:46:45.042]                       invokeRestart <- base::invokeRestart
[17:46:45.042]                       is.null <- base::is.null
[17:46:45.042]                       muffled <- FALSE
[17:46:45.042]                       if (inherits(cond, "message")) {
[17:46:45.042]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.042]                         if (muffled) 
[17:46:45.042]                           invokeRestart("muffleMessage")
[17:46:45.042]                       }
[17:46:45.042]                       else if (inherits(cond, "warning")) {
[17:46:45.042]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.042]                         if (muffled) 
[17:46:45.042]                           invokeRestart("muffleWarning")
[17:46:45.042]                       }
[17:46:45.042]                       else if (inherits(cond, "condition")) {
[17:46:45.042]                         if (!is.null(pattern)) {
[17:46:45.042]                           computeRestarts <- base::computeRestarts
[17:46:45.042]                           grepl <- base::grepl
[17:46:45.042]                           restarts <- computeRestarts(cond)
[17:46:45.042]                           for (restart in restarts) {
[17:46:45.042]                             name <- restart$name
[17:46:45.042]                             if (is.null(name)) 
[17:46:45.042]                               next
[17:46:45.042]                             if (!grepl(pattern, name)) 
[17:46:45.042]                               next
[17:46:45.042]                             invokeRestart(restart)
[17:46:45.042]                             muffled <- TRUE
[17:46:45.042]                             break
[17:46:45.042]                           }
[17:46:45.042]                         }
[17:46:45.042]                       }
[17:46:45.042]                       invisible(muffled)
[17:46:45.042]                     }
[17:46:45.042]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.042]                   }
[17:46:45.042]                 }
[17:46:45.042]             }
[17:46:45.042]         }))
[17:46:45.042]     }, error = function(ex) {
[17:46:45.042]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.042]                 ...future.rng), started = ...future.startTime, 
[17:46:45.042]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.042]             version = "1.8"), class = "FutureResult")
[17:46:45.042]     }, finally = {
[17:46:45.042]         if (!identical(...future.workdir, getwd())) 
[17:46:45.042]             setwd(...future.workdir)
[17:46:45.042]         {
[17:46:45.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.042]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.042]             }
[17:46:45.042]             base::options(...future.oldOptions)
[17:46:45.042]             if (.Platform$OS.type == "windows") {
[17:46:45.042]                 old_names <- names(...future.oldEnvVars)
[17:46:45.042]                 envs <- base::Sys.getenv()
[17:46:45.042]                 names <- names(envs)
[17:46:45.042]                 common <- intersect(names, old_names)
[17:46:45.042]                 added <- setdiff(names, old_names)
[17:46:45.042]                 removed <- setdiff(old_names, names)
[17:46:45.042]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.042]                   envs[common]]
[17:46:45.042]                 NAMES <- toupper(changed)
[17:46:45.042]                 args <- list()
[17:46:45.042]                 for (kk in seq_along(NAMES)) {
[17:46:45.042]                   name <- changed[[kk]]
[17:46:45.042]                   NAME <- NAMES[[kk]]
[17:46:45.042]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.042]                     next
[17:46:45.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.042]                 }
[17:46:45.042]                 NAMES <- toupper(added)
[17:46:45.042]                 for (kk in seq_along(NAMES)) {
[17:46:45.042]                   name <- added[[kk]]
[17:46:45.042]                   NAME <- NAMES[[kk]]
[17:46:45.042]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.042]                     next
[17:46:45.042]                   args[[name]] <- ""
[17:46:45.042]                 }
[17:46:45.042]                 NAMES <- toupper(removed)
[17:46:45.042]                 for (kk in seq_along(NAMES)) {
[17:46:45.042]                   name <- removed[[kk]]
[17:46:45.042]                   NAME <- NAMES[[kk]]
[17:46:45.042]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.042]                     next
[17:46:45.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.042]                 }
[17:46:45.042]                 if (length(args) > 0) 
[17:46:45.042]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.042]             }
[17:46:45.042]             else {
[17:46:45.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.042]             }
[17:46:45.042]             {
[17:46:45.042]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.042]                   0L) {
[17:46:45.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.042]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.042]                   base::options(opts)
[17:46:45.042]                 }
[17:46:45.042]                 {
[17:46:45.042]                   {
[17:46:45.042]                     NULL
[17:46:45.042]                     RNGkind("Mersenne-Twister")
[17:46:45.042]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:45.042]                       inherits = FALSE)
[17:46:45.042]                   }
[17:46:45.042]                   options(future.plan = NULL)
[17:46:45.042]                   if (is.na(NA_character_)) 
[17:46:45.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.042]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.042]                     .init = FALSE)
[17:46:45.042]                 }
[17:46:45.042]             }
[17:46:45.042]         }
[17:46:45.042]     })
[17:46:45.042]     if (TRUE) {
[17:46:45.042]         base::sink(type = "output", split = FALSE)
[17:46:45.042]         if (TRUE) {
[17:46:45.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.042]         }
[17:46:45.042]         else {
[17:46:45.042]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.042]         }
[17:46:45.042]         base::close(...future.stdout)
[17:46:45.042]         ...future.stdout <- NULL
[17:46:45.042]     }
[17:46:45.042]     ...future.result$conditions <- ...future.conditions
[17:46:45.042]     ...future.result$finished <- base::Sys.time()
[17:46:45.042]     ...future.result
[17:46:45.042] }
[17:46:45.044] plan(): Setting new future strategy stack:
[17:46:45.044] List of future strategies:
[17:46:45.044] 1. sequential:
[17:46:45.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.044]    - tweaked: FALSE
[17:46:45.044]    - call: NULL
[17:46:45.044] plan(): nbrOfWorkers() = 1
[17:46:45.045] plan(): Setting new future strategy stack:
[17:46:45.045] List of future strategies:
[17:46:45.045] 1. sequential:
[17:46:45.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.045]    - tweaked: FALSE
[17:46:45.045]    - call: plan(strategy)
[17:46:45.046] plan(): nbrOfWorkers() = 1
[17:46:45.046] SequentialFuture started (and completed)
[17:46:45.046] - Launch lazy future ... done
[17:46:45.046] run() for ‘SequentialFuture’ ... done
[17:46:45.046] getGlobalsAndPackages() ...
[17:46:45.046] Searching for globals...
[17:46:45.047] - globals found: [1] ‘{’
[17:46:45.047] Searching for globals ... DONE
[17:46:45.047] Resolving globals: FALSE
[17:46:45.048] 
[17:46:45.048] 
[17:46:45.048] getGlobalsAndPackages() ... DONE
[17:46:45.048] run() for ‘Future’ ...
[17:46:45.048] - state: ‘created’
[17:46:45.048] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:45.048] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:45.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:45.049]   - Field: ‘label’
[17:46:45.049]   - Field: ‘local’
[17:46:45.049]   - Field: ‘owner’
[17:46:45.049]   - Field: ‘envir’
[17:46:45.049]   - Field: ‘packages’
[17:46:45.049]   - Field: ‘gc’
[17:46:45.049]   - Field: ‘conditions’
[17:46:45.049]   - Field: ‘expr’
[17:46:45.049]   - Field: ‘uuid’
[17:46:45.049]   - Field: ‘seed’
[17:46:45.050]   - Field: ‘version’
[17:46:45.050]   - Field: ‘result’
[17:46:45.050]   - Field: ‘asynchronous’
[17:46:45.050]   - Field: ‘calls’
[17:46:45.050]   - Field: ‘globals’
[17:46:45.050]   - Field: ‘stdout’
[17:46:45.050]   - Field: ‘earlySignal’
[17:46:45.050]   - Field: ‘lazy’
[17:46:45.050]   - Field: ‘state’
[17:46:45.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:45.050] - Launch lazy future ...
[17:46:45.051] Packages needed by the future expression (n = 0): <none>
[17:46:45.051] Packages needed by future strategies (n = 0): <none>
[17:46:45.051] {
[17:46:45.051]     {
[17:46:45.051]         {
[17:46:45.051]             ...future.startTime <- base::Sys.time()
[17:46:45.051]             {
[17:46:45.051]                 {
[17:46:45.051]                   {
[17:46:45.051]                     base::local({
[17:46:45.051]                       has_future <- base::requireNamespace("future", 
[17:46:45.051]                         quietly = TRUE)
[17:46:45.051]                       if (has_future) {
[17:46:45.051]                         ns <- base::getNamespace("future")
[17:46:45.051]                         version <- ns[[".package"]][["version"]]
[17:46:45.051]                         if (is.null(version)) 
[17:46:45.051]                           version <- utils::packageVersion("future")
[17:46:45.051]                       }
[17:46:45.051]                       else {
[17:46:45.051]                         version <- NULL
[17:46:45.051]                       }
[17:46:45.051]                       if (!has_future || version < "1.8.0") {
[17:46:45.051]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.051]                           "", base::R.version$version.string), 
[17:46:45.051]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:45.051]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.051]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.051]                             "release", "version")], collapse = " "), 
[17:46:45.051]                           hostname = base::Sys.info()[["nodename"]])
[17:46:45.051]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.051]                           info)
[17:46:45.051]                         info <- base::paste(info, collapse = "; ")
[17:46:45.051]                         if (!has_future) {
[17:46:45.051]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.051]                             info)
[17:46:45.051]                         }
[17:46:45.051]                         else {
[17:46:45.051]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.051]                             info, version)
[17:46:45.051]                         }
[17:46:45.051]                         base::stop(msg)
[17:46:45.051]                       }
[17:46:45.051]                     })
[17:46:45.051]                   }
[17:46:45.051]                   ...future.strategy.old <- future::plan("list")
[17:46:45.051]                   options(future.plan = NULL)
[17:46:45.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.051]                 }
[17:46:45.051]                 ...future.workdir <- getwd()
[17:46:45.051]             }
[17:46:45.051]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.051]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.051]         }
[17:46:45.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.051]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.051]             base::names(...future.oldOptions))
[17:46:45.051]     }
[17:46:45.051]     if (FALSE) {
[17:46:45.051]     }
[17:46:45.051]     else {
[17:46:45.051]         if (TRUE) {
[17:46:45.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.051]                 open = "w")
[17:46:45.051]         }
[17:46:45.051]         else {
[17:46:45.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.051]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.051]         }
[17:46:45.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.051]             base::sink(type = "output", split = FALSE)
[17:46:45.051]             base::close(...future.stdout)
[17:46:45.051]         }, add = TRUE)
[17:46:45.051]     }
[17:46:45.051]     ...future.frame <- base::sys.nframe()
[17:46:45.051]     ...future.conditions <- base::list()
[17:46:45.051]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.051]     if (FALSE) {
[17:46:45.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.051]     }
[17:46:45.051]     ...future.result <- base::tryCatch({
[17:46:45.051]         base::withCallingHandlers({
[17:46:45.051]             ...future.value <- base::withVisible(base::local({
[17:46:45.051]                 4
[17:46:45.051]             }))
[17:46:45.051]             future::FutureResult(value = ...future.value$value, 
[17:46:45.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.051]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.051]                     ...future.globalenv.names))
[17:46:45.051]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.051]         }, condition = base::local({
[17:46:45.051]             c <- base::c
[17:46:45.051]             inherits <- base::inherits
[17:46:45.051]             invokeRestart <- base::invokeRestart
[17:46:45.051]             length <- base::length
[17:46:45.051]             list <- base::list
[17:46:45.051]             seq.int <- base::seq.int
[17:46:45.051]             signalCondition <- base::signalCondition
[17:46:45.051]             sys.calls <- base::sys.calls
[17:46:45.051]             `[[` <- base::`[[`
[17:46:45.051]             `+` <- base::`+`
[17:46:45.051]             `<<-` <- base::`<<-`
[17:46:45.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.051]                   3L)]
[17:46:45.051]             }
[17:46:45.051]             function(cond) {
[17:46:45.051]                 is_error <- inherits(cond, "error")
[17:46:45.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.051]                   NULL)
[17:46:45.051]                 if (is_error) {
[17:46:45.051]                   sessionInformation <- function() {
[17:46:45.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.051]                       search = base::search(), system = base::Sys.info())
[17:46:45.051]                   }
[17:46:45.051]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.051]                     cond$call), session = sessionInformation(), 
[17:46:45.051]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.051]                   signalCondition(cond)
[17:46:45.051]                 }
[17:46:45.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.051]                 "immediateCondition"))) {
[17:46:45.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.051]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.051]                   if (TRUE && !signal) {
[17:46:45.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.051]                     {
[17:46:45.051]                       inherits <- base::inherits
[17:46:45.051]                       invokeRestart <- base::invokeRestart
[17:46:45.051]                       is.null <- base::is.null
[17:46:45.051]                       muffled <- FALSE
[17:46:45.051]                       if (inherits(cond, "message")) {
[17:46:45.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.051]                         if (muffled) 
[17:46:45.051]                           invokeRestart("muffleMessage")
[17:46:45.051]                       }
[17:46:45.051]                       else if (inherits(cond, "warning")) {
[17:46:45.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.051]                         if (muffled) 
[17:46:45.051]                           invokeRestart("muffleWarning")
[17:46:45.051]                       }
[17:46:45.051]                       else if (inherits(cond, "condition")) {
[17:46:45.051]                         if (!is.null(pattern)) {
[17:46:45.051]                           computeRestarts <- base::computeRestarts
[17:46:45.051]                           grepl <- base::grepl
[17:46:45.051]                           restarts <- computeRestarts(cond)
[17:46:45.051]                           for (restart in restarts) {
[17:46:45.051]                             name <- restart$name
[17:46:45.051]                             if (is.null(name)) 
[17:46:45.051]                               next
[17:46:45.051]                             if (!grepl(pattern, name)) 
[17:46:45.051]                               next
[17:46:45.051]                             invokeRestart(restart)
[17:46:45.051]                             muffled <- TRUE
[17:46:45.051]                             break
[17:46:45.051]                           }
[17:46:45.051]                         }
[17:46:45.051]                       }
[17:46:45.051]                       invisible(muffled)
[17:46:45.051]                     }
[17:46:45.051]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.051]                   }
[17:46:45.051]                 }
[17:46:45.051]                 else {
[17:46:45.051]                   if (TRUE) {
[17:46:45.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.051]                     {
[17:46:45.051]                       inherits <- base::inherits
[17:46:45.051]                       invokeRestart <- base::invokeRestart
[17:46:45.051]                       is.null <- base::is.null
[17:46:45.051]                       muffled <- FALSE
[17:46:45.051]                       if (inherits(cond, "message")) {
[17:46:45.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.051]                         if (muffled) 
[17:46:45.051]                           invokeRestart("muffleMessage")
[17:46:45.051]                       }
[17:46:45.051]                       else if (inherits(cond, "warning")) {
[17:46:45.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.051]                         if (muffled) 
[17:46:45.051]                           invokeRestart("muffleWarning")
[17:46:45.051]                       }
[17:46:45.051]                       else if (inherits(cond, "condition")) {
[17:46:45.051]                         if (!is.null(pattern)) {
[17:46:45.051]                           computeRestarts <- base::computeRestarts
[17:46:45.051]                           grepl <- base::grepl
[17:46:45.051]                           restarts <- computeRestarts(cond)
[17:46:45.051]                           for (restart in restarts) {
[17:46:45.051]                             name <- restart$name
[17:46:45.051]                             if (is.null(name)) 
[17:46:45.051]                               next
[17:46:45.051]                             if (!grepl(pattern, name)) 
[17:46:45.051]                               next
[17:46:45.051]                             invokeRestart(restart)
[17:46:45.051]                             muffled <- TRUE
[17:46:45.051]                             break
[17:46:45.051]                           }
[17:46:45.051]                         }
[17:46:45.051]                       }
[17:46:45.051]                       invisible(muffled)
[17:46:45.051]                     }
[17:46:45.051]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.051]                   }
[17:46:45.051]                 }
[17:46:45.051]             }
[17:46:45.051]         }))
[17:46:45.051]     }, error = function(ex) {
[17:46:45.051]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.051]                 ...future.rng), started = ...future.startTime, 
[17:46:45.051]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.051]             version = "1.8"), class = "FutureResult")
[17:46:45.051]     }, finally = {
[17:46:45.051]         if (!identical(...future.workdir, getwd())) 
[17:46:45.051]             setwd(...future.workdir)
[17:46:45.051]         {
[17:46:45.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.051]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.051]             }
[17:46:45.051]             base::options(...future.oldOptions)
[17:46:45.051]             if (.Platform$OS.type == "windows") {
[17:46:45.051]                 old_names <- names(...future.oldEnvVars)
[17:46:45.051]                 envs <- base::Sys.getenv()
[17:46:45.051]                 names <- names(envs)
[17:46:45.051]                 common <- intersect(names, old_names)
[17:46:45.051]                 added <- setdiff(names, old_names)
[17:46:45.051]                 removed <- setdiff(old_names, names)
[17:46:45.051]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.051]                   envs[common]]
[17:46:45.051]                 NAMES <- toupper(changed)
[17:46:45.051]                 args <- list()
[17:46:45.051]                 for (kk in seq_along(NAMES)) {
[17:46:45.051]                   name <- changed[[kk]]
[17:46:45.051]                   NAME <- NAMES[[kk]]
[17:46:45.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.051]                     next
[17:46:45.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.051]                 }
[17:46:45.051]                 NAMES <- toupper(added)
[17:46:45.051]                 for (kk in seq_along(NAMES)) {
[17:46:45.051]                   name <- added[[kk]]
[17:46:45.051]                   NAME <- NAMES[[kk]]
[17:46:45.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.051]                     next
[17:46:45.051]                   args[[name]] <- ""
[17:46:45.051]                 }
[17:46:45.051]                 NAMES <- toupper(removed)
[17:46:45.051]                 for (kk in seq_along(NAMES)) {
[17:46:45.051]                   name <- removed[[kk]]
[17:46:45.051]                   NAME <- NAMES[[kk]]
[17:46:45.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.051]                     next
[17:46:45.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.051]                 }
[17:46:45.051]                 if (length(args) > 0) 
[17:46:45.051]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.051]             }
[17:46:45.051]             else {
[17:46:45.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.051]             }
[17:46:45.051]             {
[17:46:45.051]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.051]                   0L) {
[17:46:45.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.051]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.051]                   base::options(opts)
[17:46:45.051]                 }
[17:46:45.051]                 {
[17:46:45.051]                   {
[17:46:45.051]                     NULL
[17:46:45.051]                     RNGkind("Mersenne-Twister")
[17:46:45.051]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:45.051]                       inherits = FALSE)
[17:46:45.051]                   }
[17:46:45.051]                   options(future.plan = NULL)
[17:46:45.051]                   if (is.na(NA_character_)) 
[17:46:45.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.051]                     .init = FALSE)
[17:46:45.051]                 }
[17:46:45.051]             }
[17:46:45.051]         }
[17:46:45.051]     })
[17:46:45.051]     if (TRUE) {
[17:46:45.051]         base::sink(type = "output", split = FALSE)
[17:46:45.051]         if (TRUE) {
[17:46:45.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.051]         }
[17:46:45.051]         else {
[17:46:45.051]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.051]         }
[17:46:45.051]         base::close(...future.stdout)
[17:46:45.051]         ...future.stdout <- NULL
[17:46:45.051]     }
[17:46:45.051]     ...future.result$conditions <- ...future.conditions
[17:46:45.051]     ...future.result$finished <- base::Sys.time()
[17:46:45.051]     ...future.result
[17:46:45.051] }
[17:46:45.053] plan(): Setting new future strategy stack:
[17:46:45.053] List of future strategies:
[17:46:45.053] 1. sequential:
[17:46:45.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.053]    - tweaked: FALSE
[17:46:45.053]    - call: NULL
[17:46:45.053] plan(): nbrOfWorkers() = 1
[17:46:45.054] plan(): Setting new future strategy stack:
[17:46:45.054] List of future strategies:
[17:46:45.054] 1. sequential:
[17:46:45.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.054]    - tweaked: FALSE
[17:46:45.054]    - call: plan(strategy)
[17:46:45.055] plan(): nbrOfWorkers() = 1
[17:46:45.055] SequentialFuture started (and completed)
[17:46:45.055] - Launch lazy future ... done
[17:46:45.055] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x561787ee4620> 
Classes 'listenv', 'environment' <environment: 0x561787bd85f0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:45.059] resolved() for ‘SequentialFuture’ ...
[17:46:45.059] - state: ‘finished’
[17:46:45.059] - run: TRUE
[17:46:45.059] - result: ‘FutureResult’
[17:46:45.059] resolved() for ‘SequentialFuture’ ... done
[17:46:45.059] resolved() for ‘SequentialFuture’ ...
[17:46:45.059] - state: ‘finished’
[17:46:45.059] - run: TRUE
[17:46:45.059] - result: ‘FutureResult’
[17:46:45.060] resolved() for ‘SequentialFuture’ ... done
[17:46:45.060] resolved() for ‘SequentialFuture’ ...
[17:46:45.060] - state: ‘finished’
[17:46:45.060] - run: TRUE
[17:46:45.060] - result: ‘FutureResult’
[17:46:45.060] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:45.063] resolve() on list environment ...
[17:46:45.063]  recursive: 0
[17:46:45.065]  length: 6
[17:46:45.065]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:45.066] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.066] - nx: 6
[17:46:45.066] - relay: TRUE
[17:46:45.066] - stdout: TRUE
[17:46:45.066] - signal: TRUE
[17:46:45.066] - resignal: FALSE
[17:46:45.066] - force: TRUE
[17:46:45.066] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.066] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.066]  - until=2
[17:46:45.066]  - relaying element #2
[17:46:45.067] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.067] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.067] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.067]  length: 5 (resolved future 1)
[17:46:45.067] resolved() for ‘SequentialFuture’ ...
[17:46:45.067] - state: ‘finished’
[17:46:45.067] - run: TRUE
[17:46:45.067] - result: ‘FutureResult’
[17:46:45.067] resolved() for ‘SequentialFuture’ ... done
[17:46:45.067] Future #2
[17:46:45.068] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:45.068] - nx: 6
[17:46:45.068] - relay: TRUE
[17:46:45.068] - stdout: TRUE
[17:46:45.068] - signal: TRUE
[17:46:45.068] - resignal: FALSE
[17:46:45.068] - force: TRUE
[17:46:45.068] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.068] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.068]  - until=2
[17:46:45.068]  - relaying element #2
[17:46:45.069] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.069] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.069] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:45.069]  length: 4 (resolved future 2)
[17:46:45.069] resolved() for ‘SequentialFuture’ ...
[17:46:45.069] - state: ‘finished’
[17:46:45.069] - run: TRUE
[17:46:45.069] - result: ‘FutureResult’
[17:46:45.069] resolved() for ‘SequentialFuture’ ... done
[17:46:45.069] Future #3
[17:46:45.070] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:45.070] - nx: 6
[17:46:45.070] - relay: TRUE
[17:46:45.070] - stdout: TRUE
[17:46:45.070] - signal: TRUE
[17:46:45.070] - resignal: FALSE
[17:46:45.070] - force: TRUE
[17:46:45.070] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.070] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.070]  - until=3
[17:46:45.070]  - relaying element #3
[17:46:45.071] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.071] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.071] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:45.071]  length: 3 (resolved future 3)
[17:46:45.071] resolved() for ‘SequentialFuture’ ...
[17:46:45.071] - state: ‘finished’
[17:46:45.071] - run: TRUE
[17:46:45.071] - result: ‘FutureResult’
[17:46:45.071] resolved() for ‘SequentialFuture’ ... done
[17:46:45.072] Future #4
[17:46:45.072] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:45.072] - nx: 6
[17:46:45.072] - relay: TRUE
[17:46:45.072] - stdout: TRUE
[17:46:45.072] - signal: TRUE
[17:46:45.072] - resignal: FALSE
[17:46:45.072] - force: TRUE
[17:46:45.072] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.072] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.072]  - until=4
[17:46:45.073]  - relaying element #4
[17:46:45.073] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.073] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.073] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:45.073]  length: 2 (resolved future 4)
[17:46:45.073] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.073] - nx: 6
[17:46:45.073] - relay: TRUE
[17:46:45.073] - stdout: TRUE
[17:46:45.073] - signal: TRUE
[17:46:45.073] - resignal: FALSE
[17:46:45.074] - force: TRUE
[17:46:45.074] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.074] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.074]  - until=6
[17:46:45.074]  - relaying element #6
[17:46:45.074] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.074] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.074] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.074]  length: 1 (resolved future 5)
[17:46:45.074] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.074] - nx: 6
[17:46:45.075] - relay: TRUE
[17:46:45.075] - stdout: TRUE
[17:46:45.075] - signal: TRUE
[17:46:45.075] - resignal: FALSE
[17:46:45.075] - force: TRUE
[17:46:45.075] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.075] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.075]  - until=6
[17:46:45.075] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.075] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.075] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.075]  length: 0 (resolved future 6)
[17:46:45.076] Relaying remaining futures
[17:46:45.076] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.076] - nx: 6
[17:46:45.076] - relay: TRUE
[17:46:45.076] - stdout: TRUE
[17:46:45.076] - signal: TRUE
[17:46:45.076] - resignal: FALSE
[17:46:45.076] - force: TRUE
[17:46:45.076] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.076] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:45.076] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.076] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.077] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.077] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5617882b36a8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:46:45.079] getGlobalsAndPackages() ...
[17:46:45.079] Searching for globals...
[17:46:45.079] 
[17:46:45.079] Searching for globals ... DONE
[17:46:45.079] - globals: [0] <none>
[17:46:45.080] getGlobalsAndPackages() ... DONE
[17:46:45.080] run() for ‘Future’ ...
[17:46:45.080] - state: ‘created’
[17:46:45.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:45.080] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:45.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:45.080]   - Field: ‘label’
[17:46:45.081]   - Field: ‘local’
[17:46:45.081]   - Field: ‘owner’
[17:46:45.081]   - Field: ‘envir’
[17:46:45.081]   - Field: ‘packages’
[17:46:45.081]   - Field: ‘gc’
[17:46:45.081]   - Field: ‘conditions’
[17:46:45.081]   - Field: ‘expr’
[17:46:45.081]   - Field: ‘uuid’
[17:46:45.081]   - Field: ‘seed’
[17:46:45.081]   - Field: ‘version’
[17:46:45.081]   - Field: ‘result’
[17:46:45.082]   - Field: ‘asynchronous’
[17:46:45.082]   - Field: ‘calls’
[17:46:45.082]   - Field: ‘globals’
[17:46:45.082]   - Field: ‘stdout’
[17:46:45.082]   - Field: ‘earlySignal’
[17:46:45.082]   - Field: ‘lazy’
[17:46:45.082]   - Field: ‘state’
[17:46:45.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:45.082] - Launch lazy future ...
[17:46:45.082] Packages needed by the future expression (n = 0): <none>
[17:46:45.083] Packages needed by future strategies (n = 0): <none>
[17:46:45.083] {
[17:46:45.083]     {
[17:46:45.083]         {
[17:46:45.083]             ...future.startTime <- base::Sys.time()
[17:46:45.083]             {
[17:46:45.083]                 {
[17:46:45.083]                   {
[17:46:45.083]                     base::local({
[17:46:45.083]                       has_future <- base::requireNamespace("future", 
[17:46:45.083]                         quietly = TRUE)
[17:46:45.083]                       if (has_future) {
[17:46:45.083]                         ns <- base::getNamespace("future")
[17:46:45.083]                         version <- ns[[".package"]][["version"]]
[17:46:45.083]                         if (is.null(version)) 
[17:46:45.083]                           version <- utils::packageVersion("future")
[17:46:45.083]                       }
[17:46:45.083]                       else {
[17:46:45.083]                         version <- NULL
[17:46:45.083]                       }
[17:46:45.083]                       if (!has_future || version < "1.8.0") {
[17:46:45.083]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.083]                           "", base::R.version$version.string), 
[17:46:45.083]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:45.083]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.083]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.083]                             "release", "version")], collapse = " "), 
[17:46:45.083]                           hostname = base::Sys.info()[["nodename"]])
[17:46:45.083]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.083]                           info)
[17:46:45.083]                         info <- base::paste(info, collapse = "; ")
[17:46:45.083]                         if (!has_future) {
[17:46:45.083]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.083]                             info)
[17:46:45.083]                         }
[17:46:45.083]                         else {
[17:46:45.083]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.083]                             info, version)
[17:46:45.083]                         }
[17:46:45.083]                         base::stop(msg)
[17:46:45.083]                       }
[17:46:45.083]                     })
[17:46:45.083]                   }
[17:46:45.083]                   ...future.strategy.old <- future::plan("list")
[17:46:45.083]                   options(future.plan = NULL)
[17:46:45.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.083]                 }
[17:46:45.083]                 ...future.workdir <- getwd()
[17:46:45.083]             }
[17:46:45.083]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.083]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.083]         }
[17:46:45.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.083]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.083]             base::names(...future.oldOptions))
[17:46:45.083]     }
[17:46:45.083]     if (FALSE) {
[17:46:45.083]     }
[17:46:45.083]     else {
[17:46:45.083]         if (TRUE) {
[17:46:45.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.083]                 open = "w")
[17:46:45.083]         }
[17:46:45.083]         else {
[17:46:45.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.083]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.083]         }
[17:46:45.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.083]             base::sink(type = "output", split = FALSE)
[17:46:45.083]             base::close(...future.stdout)
[17:46:45.083]         }, add = TRUE)
[17:46:45.083]     }
[17:46:45.083]     ...future.frame <- base::sys.nframe()
[17:46:45.083]     ...future.conditions <- base::list()
[17:46:45.083]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.083]     if (FALSE) {
[17:46:45.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.083]     }
[17:46:45.083]     ...future.result <- base::tryCatch({
[17:46:45.083]         base::withCallingHandlers({
[17:46:45.083]             ...future.value <- base::withVisible(base::local(2))
[17:46:45.083]             future::FutureResult(value = ...future.value$value, 
[17:46:45.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.083]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.083]                     ...future.globalenv.names))
[17:46:45.083]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.083]         }, condition = base::local({
[17:46:45.083]             c <- base::c
[17:46:45.083]             inherits <- base::inherits
[17:46:45.083]             invokeRestart <- base::invokeRestart
[17:46:45.083]             length <- base::length
[17:46:45.083]             list <- base::list
[17:46:45.083]             seq.int <- base::seq.int
[17:46:45.083]             signalCondition <- base::signalCondition
[17:46:45.083]             sys.calls <- base::sys.calls
[17:46:45.083]             `[[` <- base::`[[`
[17:46:45.083]             `+` <- base::`+`
[17:46:45.083]             `<<-` <- base::`<<-`
[17:46:45.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.083]                   3L)]
[17:46:45.083]             }
[17:46:45.083]             function(cond) {
[17:46:45.083]                 is_error <- inherits(cond, "error")
[17:46:45.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.083]                   NULL)
[17:46:45.083]                 if (is_error) {
[17:46:45.083]                   sessionInformation <- function() {
[17:46:45.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.083]                       search = base::search(), system = base::Sys.info())
[17:46:45.083]                   }
[17:46:45.083]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.083]                     cond$call), session = sessionInformation(), 
[17:46:45.083]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.083]                   signalCondition(cond)
[17:46:45.083]                 }
[17:46:45.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.083]                 "immediateCondition"))) {
[17:46:45.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.083]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.083]                   if (TRUE && !signal) {
[17:46:45.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.083]                     {
[17:46:45.083]                       inherits <- base::inherits
[17:46:45.083]                       invokeRestart <- base::invokeRestart
[17:46:45.083]                       is.null <- base::is.null
[17:46:45.083]                       muffled <- FALSE
[17:46:45.083]                       if (inherits(cond, "message")) {
[17:46:45.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.083]                         if (muffled) 
[17:46:45.083]                           invokeRestart("muffleMessage")
[17:46:45.083]                       }
[17:46:45.083]                       else if (inherits(cond, "warning")) {
[17:46:45.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.083]                         if (muffled) 
[17:46:45.083]                           invokeRestart("muffleWarning")
[17:46:45.083]                       }
[17:46:45.083]                       else if (inherits(cond, "condition")) {
[17:46:45.083]                         if (!is.null(pattern)) {
[17:46:45.083]                           computeRestarts <- base::computeRestarts
[17:46:45.083]                           grepl <- base::grepl
[17:46:45.083]                           restarts <- computeRestarts(cond)
[17:46:45.083]                           for (restart in restarts) {
[17:46:45.083]                             name <- restart$name
[17:46:45.083]                             if (is.null(name)) 
[17:46:45.083]                               next
[17:46:45.083]                             if (!grepl(pattern, name)) 
[17:46:45.083]                               next
[17:46:45.083]                             invokeRestart(restart)
[17:46:45.083]                             muffled <- TRUE
[17:46:45.083]                             break
[17:46:45.083]                           }
[17:46:45.083]                         }
[17:46:45.083]                       }
[17:46:45.083]                       invisible(muffled)
[17:46:45.083]                     }
[17:46:45.083]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.083]                   }
[17:46:45.083]                 }
[17:46:45.083]                 else {
[17:46:45.083]                   if (TRUE) {
[17:46:45.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.083]                     {
[17:46:45.083]                       inherits <- base::inherits
[17:46:45.083]                       invokeRestart <- base::invokeRestart
[17:46:45.083]                       is.null <- base::is.null
[17:46:45.083]                       muffled <- FALSE
[17:46:45.083]                       if (inherits(cond, "message")) {
[17:46:45.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.083]                         if (muffled) 
[17:46:45.083]                           invokeRestart("muffleMessage")
[17:46:45.083]                       }
[17:46:45.083]                       else if (inherits(cond, "warning")) {
[17:46:45.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.083]                         if (muffled) 
[17:46:45.083]                           invokeRestart("muffleWarning")
[17:46:45.083]                       }
[17:46:45.083]                       else if (inherits(cond, "condition")) {
[17:46:45.083]                         if (!is.null(pattern)) {
[17:46:45.083]                           computeRestarts <- base::computeRestarts
[17:46:45.083]                           grepl <- base::grepl
[17:46:45.083]                           restarts <- computeRestarts(cond)
[17:46:45.083]                           for (restart in restarts) {
[17:46:45.083]                             name <- restart$name
[17:46:45.083]                             if (is.null(name)) 
[17:46:45.083]                               next
[17:46:45.083]                             if (!grepl(pattern, name)) 
[17:46:45.083]                               next
[17:46:45.083]                             invokeRestart(restart)
[17:46:45.083]                             muffled <- TRUE
[17:46:45.083]                             break
[17:46:45.083]                           }
[17:46:45.083]                         }
[17:46:45.083]                       }
[17:46:45.083]                       invisible(muffled)
[17:46:45.083]                     }
[17:46:45.083]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.083]                   }
[17:46:45.083]                 }
[17:46:45.083]             }
[17:46:45.083]         }))
[17:46:45.083]     }, error = function(ex) {
[17:46:45.083]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.083]                 ...future.rng), started = ...future.startTime, 
[17:46:45.083]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.083]             version = "1.8"), class = "FutureResult")
[17:46:45.083]     }, finally = {
[17:46:45.083]         if (!identical(...future.workdir, getwd())) 
[17:46:45.083]             setwd(...future.workdir)
[17:46:45.083]         {
[17:46:45.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.083]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.083]             }
[17:46:45.083]             base::options(...future.oldOptions)
[17:46:45.083]             if (.Platform$OS.type == "windows") {
[17:46:45.083]                 old_names <- names(...future.oldEnvVars)
[17:46:45.083]                 envs <- base::Sys.getenv()
[17:46:45.083]                 names <- names(envs)
[17:46:45.083]                 common <- intersect(names, old_names)
[17:46:45.083]                 added <- setdiff(names, old_names)
[17:46:45.083]                 removed <- setdiff(old_names, names)
[17:46:45.083]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.083]                   envs[common]]
[17:46:45.083]                 NAMES <- toupper(changed)
[17:46:45.083]                 args <- list()
[17:46:45.083]                 for (kk in seq_along(NAMES)) {
[17:46:45.083]                   name <- changed[[kk]]
[17:46:45.083]                   NAME <- NAMES[[kk]]
[17:46:45.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.083]                     next
[17:46:45.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.083]                 }
[17:46:45.083]                 NAMES <- toupper(added)
[17:46:45.083]                 for (kk in seq_along(NAMES)) {
[17:46:45.083]                   name <- added[[kk]]
[17:46:45.083]                   NAME <- NAMES[[kk]]
[17:46:45.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.083]                     next
[17:46:45.083]                   args[[name]] <- ""
[17:46:45.083]                 }
[17:46:45.083]                 NAMES <- toupper(removed)
[17:46:45.083]                 for (kk in seq_along(NAMES)) {
[17:46:45.083]                   name <- removed[[kk]]
[17:46:45.083]                   NAME <- NAMES[[kk]]
[17:46:45.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.083]                     next
[17:46:45.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.083]                 }
[17:46:45.083]                 if (length(args) > 0) 
[17:46:45.083]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.083]             }
[17:46:45.083]             else {
[17:46:45.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.083]             }
[17:46:45.083]             {
[17:46:45.083]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.083]                   0L) {
[17:46:45.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.083]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.083]                   base::options(opts)
[17:46:45.083]                 }
[17:46:45.083]                 {
[17:46:45.083]                   {
[17:46:45.083]                     NULL
[17:46:45.083]                     RNGkind("Mersenne-Twister")
[17:46:45.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:45.083]                       inherits = FALSE)
[17:46:45.083]                   }
[17:46:45.083]                   options(future.plan = NULL)
[17:46:45.083]                   if (is.na(NA_character_)) 
[17:46:45.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.083]                     .init = FALSE)
[17:46:45.083]                 }
[17:46:45.083]             }
[17:46:45.083]         }
[17:46:45.083]     })
[17:46:45.083]     if (TRUE) {
[17:46:45.083]         base::sink(type = "output", split = FALSE)
[17:46:45.083]         if (TRUE) {
[17:46:45.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.083]         }
[17:46:45.083]         else {
[17:46:45.083]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.083]         }
[17:46:45.083]         base::close(...future.stdout)
[17:46:45.083]         ...future.stdout <- NULL
[17:46:45.083]     }
[17:46:45.083]     ...future.result$conditions <- ...future.conditions
[17:46:45.083]     ...future.result$finished <- base::Sys.time()
[17:46:45.083]     ...future.result
[17:46:45.083] }
[17:46:45.085] plan(): Setting new future strategy stack:
[17:46:45.085] List of future strategies:
[17:46:45.085] 1. sequential:
[17:46:45.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.085]    - tweaked: FALSE
[17:46:45.085]    - call: NULL
[17:46:45.085] plan(): nbrOfWorkers() = 1
[17:46:45.086] plan(): Setting new future strategy stack:
[17:46:45.086] List of future strategies:
[17:46:45.086] 1. sequential:
[17:46:45.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.086]    - tweaked: FALSE
[17:46:45.086]    - call: plan(strategy)
[17:46:45.086] plan(): nbrOfWorkers() = 1
[17:46:45.087] SequentialFuture started (and completed)
[17:46:45.087] - Launch lazy future ... done
[17:46:45.087] run() for ‘SequentialFuture’ ... done
[17:46:45.087] getGlobalsAndPackages() ...
[17:46:45.087] Searching for globals...
[17:46:45.087] 
[17:46:45.087] Searching for globals ... DONE
[17:46:45.088] - globals: [0] <none>
[17:46:45.088] getGlobalsAndPackages() ... DONE
[17:46:45.088] run() for ‘Future’ ...
[17:46:45.088] - state: ‘created’
[17:46:45.088] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:45.088] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:45.088] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:45.089]   - Field: ‘label’
[17:46:45.089]   - Field: ‘local’
[17:46:45.089]   - Field: ‘owner’
[17:46:45.089]   - Field: ‘envir’
[17:46:45.089]   - Field: ‘packages’
[17:46:45.089]   - Field: ‘gc’
[17:46:45.089]   - Field: ‘conditions’
[17:46:45.089]   - Field: ‘expr’
[17:46:45.089]   - Field: ‘uuid’
[17:46:45.089]   - Field: ‘seed’
[17:46:45.089]   - Field: ‘version’
[17:46:45.090]   - Field: ‘result’
[17:46:45.090]   - Field: ‘asynchronous’
[17:46:45.090]   - Field: ‘calls’
[17:46:45.090]   - Field: ‘globals’
[17:46:45.090]   - Field: ‘stdout’
[17:46:45.090]   - Field: ‘earlySignal’
[17:46:45.090]   - Field: ‘lazy’
[17:46:45.090]   - Field: ‘state’
[17:46:45.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:45.090] - Launch lazy future ...
[17:46:45.090] Packages needed by the future expression (n = 0): <none>
[17:46:45.091] Packages needed by future strategies (n = 0): <none>
[17:46:45.092] {
[17:46:45.092]     {
[17:46:45.092]         {
[17:46:45.092]             ...future.startTime <- base::Sys.time()
[17:46:45.092]             {
[17:46:45.092]                 {
[17:46:45.092]                   {
[17:46:45.092]                     base::local({
[17:46:45.092]                       has_future <- base::requireNamespace("future", 
[17:46:45.092]                         quietly = TRUE)
[17:46:45.092]                       if (has_future) {
[17:46:45.092]                         ns <- base::getNamespace("future")
[17:46:45.092]                         version <- ns[[".package"]][["version"]]
[17:46:45.092]                         if (is.null(version)) 
[17:46:45.092]                           version <- utils::packageVersion("future")
[17:46:45.092]                       }
[17:46:45.092]                       else {
[17:46:45.092]                         version <- NULL
[17:46:45.092]                       }
[17:46:45.092]                       if (!has_future || version < "1.8.0") {
[17:46:45.092]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.092]                           "", base::R.version$version.string), 
[17:46:45.092]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:45.092]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.092]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.092]                             "release", "version")], collapse = " "), 
[17:46:45.092]                           hostname = base::Sys.info()[["nodename"]])
[17:46:45.092]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.092]                           info)
[17:46:45.092]                         info <- base::paste(info, collapse = "; ")
[17:46:45.092]                         if (!has_future) {
[17:46:45.092]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.092]                             info)
[17:46:45.092]                         }
[17:46:45.092]                         else {
[17:46:45.092]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.092]                             info, version)
[17:46:45.092]                         }
[17:46:45.092]                         base::stop(msg)
[17:46:45.092]                       }
[17:46:45.092]                     })
[17:46:45.092]                   }
[17:46:45.092]                   ...future.strategy.old <- future::plan("list")
[17:46:45.092]                   options(future.plan = NULL)
[17:46:45.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.092]                 }
[17:46:45.092]                 ...future.workdir <- getwd()
[17:46:45.092]             }
[17:46:45.092]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.092]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.092]         }
[17:46:45.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.092]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.092]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.092]             base::names(...future.oldOptions))
[17:46:45.092]     }
[17:46:45.092]     if (FALSE) {
[17:46:45.092]     }
[17:46:45.092]     else {
[17:46:45.092]         if (TRUE) {
[17:46:45.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.092]                 open = "w")
[17:46:45.092]         }
[17:46:45.092]         else {
[17:46:45.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.092]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.092]         }
[17:46:45.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.092]             base::sink(type = "output", split = FALSE)
[17:46:45.092]             base::close(...future.stdout)
[17:46:45.092]         }, add = TRUE)
[17:46:45.092]     }
[17:46:45.092]     ...future.frame <- base::sys.nframe()
[17:46:45.092]     ...future.conditions <- base::list()
[17:46:45.092]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.092]     if (FALSE) {
[17:46:45.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.092]     }
[17:46:45.092]     ...future.result <- base::tryCatch({
[17:46:45.092]         base::withCallingHandlers({
[17:46:45.092]             ...future.value <- base::withVisible(base::local(NULL))
[17:46:45.092]             future::FutureResult(value = ...future.value$value, 
[17:46:45.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.092]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.092]                     ...future.globalenv.names))
[17:46:45.092]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.092]         }, condition = base::local({
[17:46:45.092]             c <- base::c
[17:46:45.092]             inherits <- base::inherits
[17:46:45.092]             invokeRestart <- base::invokeRestart
[17:46:45.092]             length <- base::length
[17:46:45.092]             list <- base::list
[17:46:45.092]             seq.int <- base::seq.int
[17:46:45.092]             signalCondition <- base::signalCondition
[17:46:45.092]             sys.calls <- base::sys.calls
[17:46:45.092]             `[[` <- base::`[[`
[17:46:45.092]             `+` <- base::`+`
[17:46:45.092]             `<<-` <- base::`<<-`
[17:46:45.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.092]                   3L)]
[17:46:45.092]             }
[17:46:45.092]             function(cond) {
[17:46:45.092]                 is_error <- inherits(cond, "error")
[17:46:45.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.092]                   NULL)
[17:46:45.092]                 if (is_error) {
[17:46:45.092]                   sessionInformation <- function() {
[17:46:45.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.092]                       search = base::search(), system = base::Sys.info())
[17:46:45.092]                   }
[17:46:45.092]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.092]                     cond$call), session = sessionInformation(), 
[17:46:45.092]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.092]                   signalCondition(cond)
[17:46:45.092]                 }
[17:46:45.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.092]                 "immediateCondition"))) {
[17:46:45.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.092]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.092]                   if (TRUE && !signal) {
[17:46:45.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.092]                     {
[17:46:45.092]                       inherits <- base::inherits
[17:46:45.092]                       invokeRestart <- base::invokeRestart
[17:46:45.092]                       is.null <- base::is.null
[17:46:45.092]                       muffled <- FALSE
[17:46:45.092]                       if (inherits(cond, "message")) {
[17:46:45.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.092]                         if (muffled) 
[17:46:45.092]                           invokeRestart("muffleMessage")
[17:46:45.092]                       }
[17:46:45.092]                       else if (inherits(cond, "warning")) {
[17:46:45.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.092]                         if (muffled) 
[17:46:45.092]                           invokeRestart("muffleWarning")
[17:46:45.092]                       }
[17:46:45.092]                       else if (inherits(cond, "condition")) {
[17:46:45.092]                         if (!is.null(pattern)) {
[17:46:45.092]                           computeRestarts <- base::computeRestarts
[17:46:45.092]                           grepl <- base::grepl
[17:46:45.092]                           restarts <- computeRestarts(cond)
[17:46:45.092]                           for (restart in restarts) {
[17:46:45.092]                             name <- restart$name
[17:46:45.092]                             if (is.null(name)) 
[17:46:45.092]                               next
[17:46:45.092]                             if (!grepl(pattern, name)) 
[17:46:45.092]                               next
[17:46:45.092]                             invokeRestart(restart)
[17:46:45.092]                             muffled <- TRUE
[17:46:45.092]                             break
[17:46:45.092]                           }
[17:46:45.092]                         }
[17:46:45.092]                       }
[17:46:45.092]                       invisible(muffled)
[17:46:45.092]                     }
[17:46:45.092]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.092]                   }
[17:46:45.092]                 }
[17:46:45.092]                 else {
[17:46:45.092]                   if (TRUE) {
[17:46:45.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.092]                     {
[17:46:45.092]                       inherits <- base::inherits
[17:46:45.092]                       invokeRestart <- base::invokeRestart
[17:46:45.092]                       is.null <- base::is.null
[17:46:45.092]                       muffled <- FALSE
[17:46:45.092]                       if (inherits(cond, "message")) {
[17:46:45.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.092]                         if (muffled) 
[17:46:45.092]                           invokeRestart("muffleMessage")
[17:46:45.092]                       }
[17:46:45.092]                       else if (inherits(cond, "warning")) {
[17:46:45.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.092]                         if (muffled) 
[17:46:45.092]                           invokeRestart("muffleWarning")
[17:46:45.092]                       }
[17:46:45.092]                       else if (inherits(cond, "condition")) {
[17:46:45.092]                         if (!is.null(pattern)) {
[17:46:45.092]                           computeRestarts <- base::computeRestarts
[17:46:45.092]                           grepl <- base::grepl
[17:46:45.092]                           restarts <- computeRestarts(cond)
[17:46:45.092]                           for (restart in restarts) {
[17:46:45.092]                             name <- restart$name
[17:46:45.092]                             if (is.null(name)) 
[17:46:45.092]                               next
[17:46:45.092]                             if (!grepl(pattern, name)) 
[17:46:45.092]                               next
[17:46:45.092]                             invokeRestart(restart)
[17:46:45.092]                             muffled <- TRUE
[17:46:45.092]                             break
[17:46:45.092]                           }
[17:46:45.092]                         }
[17:46:45.092]                       }
[17:46:45.092]                       invisible(muffled)
[17:46:45.092]                     }
[17:46:45.092]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.092]                   }
[17:46:45.092]                 }
[17:46:45.092]             }
[17:46:45.092]         }))
[17:46:45.092]     }, error = function(ex) {
[17:46:45.092]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.092]                 ...future.rng), started = ...future.startTime, 
[17:46:45.092]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.092]             version = "1.8"), class = "FutureResult")
[17:46:45.092]     }, finally = {
[17:46:45.092]         if (!identical(...future.workdir, getwd())) 
[17:46:45.092]             setwd(...future.workdir)
[17:46:45.092]         {
[17:46:45.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.092]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.092]             }
[17:46:45.092]             base::options(...future.oldOptions)
[17:46:45.092]             if (.Platform$OS.type == "windows") {
[17:46:45.092]                 old_names <- names(...future.oldEnvVars)
[17:46:45.092]                 envs <- base::Sys.getenv()
[17:46:45.092]                 names <- names(envs)
[17:46:45.092]                 common <- intersect(names, old_names)
[17:46:45.092]                 added <- setdiff(names, old_names)
[17:46:45.092]                 removed <- setdiff(old_names, names)
[17:46:45.092]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.092]                   envs[common]]
[17:46:45.092]                 NAMES <- toupper(changed)
[17:46:45.092]                 args <- list()
[17:46:45.092]                 for (kk in seq_along(NAMES)) {
[17:46:45.092]                   name <- changed[[kk]]
[17:46:45.092]                   NAME <- NAMES[[kk]]
[17:46:45.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.092]                     next
[17:46:45.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.092]                 }
[17:46:45.092]                 NAMES <- toupper(added)
[17:46:45.092]                 for (kk in seq_along(NAMES)) {
[17:46:45.092]                   name <- added[[kk]]
[17:46:45.092]                   NAME <- NAMES[[kk]]
[17:46:45.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.092]                     next
[17:46:45.092]                   args[[name]] <- ""
[17:46:45.092]                 }
[17:46:45.092]                 NAMES <- toupper(removed)
[17:46:45.092]                 for (kk in seq_along(NAMES)) {
[17:46:45.092]                   name <- removed[[kk]]
[17:46:45.092]                   NAME <- NAMES[[kk]]
[17:46:45.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.092]                     next
[17:46:45.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.092]                 }
[17:46:45.092]                 if (length(args) > 0) 
[17:46:45.092]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.092]             }
[17:46:45.092]             else {
[17:46:45.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.092]             }
[17:46:45.092]             {
[17:46:45.092]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.092]                   0L) {
[17:46:45.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.092]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.092]                   base::options(opts)
[17:46:45.092]                 }
[17:46:45.092]                 {
[17:46:45.092]                   {
[17:46:45.092]                     NULL
[17:46:45.092]                     RNGkind("Mersenne-Twister")
[17:46:45.092]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:45.092]                       inherits = FALSE)
[17:46:45.092]                   }
[17:46:45.092]                   options(future.plan = NULL)
[17:46:45.092]                   if (is.na(NA_character_)) 
[17:46:45.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.092]                     .init = FALSE)
[17:46:45.092]                 }
[17:46:45.092]             }
[17:46:45.092]         }
[17:46:45.092]     })
[17:46:45.092]     if (TRUE) {
[17:46:45.092]         base::sink(type = "output", split = FALSE)
[17:46:45.092]         if (TRUE) {
[17:46:45.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.092]         }
[17:46:45.092]         else {
[17:46:45.092]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.092]         }
[17:46:45.092]         base::close(...future.stdout)
[17:46:45.092]         ...future.stdout <- NULL
[17:46:45.092]     }
[17:46:45.092]     ...future.result$conditions <- ...future.conditions
[17:46:45.092]     ...future.result$finished <- base::Sys.time()
[17:46:45.092]     ...future.result
[17:46:45.092] }
[17:46:45.094] plan(): Setting new future strategy stack:
[17:46:45.094] List of future strategies:
[17:46:45.094] 1. sequential:
[17:46:45.094]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.094]    - tweaked: FALSE
[17:46:45.094]    - call: NULL
[17:46:45.095] plan(): nbrOfWorkers() = 1
[17:46:45.095] plan(): Setting new future strategy stack:
[17:46:45.095] List of future strategies:
[17:46:45.095] 1. sequential:
[17:46:45.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.095]    - tweaked: FALSE
[17:46:45.095]    - call: plan(strategy)
[17:46:45.096] plan(): nbrOfWorkers() = 1
[17:46:45.096] SequentialFuture started (and completed)
[17:46:45.096] - Launch lazy future ... done
[17:46:45.096] run() for ‘SequentialFuture’ ... done
[17:46:45.097] getGlobalsAndPackages() ...
[17:46:45.097] Searching for globals...
[17:46:45.097] - globals found: [1] ‘{’
[17:46:45.097] Searching for globals ... DONE
[17:46:45.097] Resolving globals: FALSE
[17:46:45.098] 
[17:46:45.098] 
[17:46:45.098] getGlobalsAndPackages() ... DONE
[17:46:45.098] run() for ‘Future’ ...
[17:46:45.098] - state: ‘created’
[17:46:45.098] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:45.099] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:45.099] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:45.099]   - Field: ‘label’
[17:46:45.099]   - Field: ‘local’
[17:46:45.099]   - Field: ‘owner’
[17:46:45.099]   - Field: ‘envir’
[17:46:45.099]   - Field: ‘packages’
[17:46:45.099]   - Field: ‘gc’
[17:46:45.099]   - Field: ‘conditions’
[17:46:45.100]   - Field: ‘expr’
[17:46:45.100]   - Field: ‘uuid’
[17:46:45.100]   - Field: ‘seed’
[17:46:45.100]   - Field: ‘version’
[17:46:45.100]   - Field: ‘result’
[17:46:45.100]   - Field: ‘asynchronous’
[17:46:45.100]   - Field: ‘calls’
[17:46:45.100]   - Field: ‘globals’
[17:46:45.100]   - Field: ‘stdout’
[17:46:45.100]   - Field: ‘earlySignal’
[17:46:45.100]   - Field: ‘lazy’
[17:46:45.100]   - Field: ‘state’
[17:46:45.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:45.101] - Launch lazy future ...
[17:46:45.101] Packages needed by the future expression (n = 0): <none>
[17:46:45.101] Packages needed by future strategies (n = 0): <none>
[17:46:45.101] {
[17:46:45.101]     {
[17:46:45.101]         {
[17:46:45.101]             ...future.startTime <- base::Sys.time()
[17:46:45.101]             {
[17:46:45.101]                 {
[17:46:45.101]                   {
[17:46:45.101]                     base::local({
[17:46:45.101]                       has_future <- base::requireNamespace("future", 
[17:46:45.101]                         quietly = TRUE)
[17:46:45.101]                       if (has_future) {
[17:46:45.101]                         ns <- base::getNamespace("future")
[17:46:45.101]                         version <- ns[[".package"]][["version"]]
[17:46:45.101]                         if (is.null(version)) 
[17:46:45.101]                           version <- utils::packageVersion("future")
[17:46:45.101]                       }
[17:46:45.101]                       else {
[17:46:45.101]                         version <- NULL
[17:46:45.101]                       }
[17:46:45.101]                       if (!has_future || version < "1.8.0") {
[17:46:45.101]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.101]                           "", base::R.version$version.string), 
[17:46:45.101]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:45.101]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.101]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.101]                             "release", "version")], collapse = " "), 
[17:46:45.101]                           hostname = base::Sys.info()[["nodename"]])
[17:46:45.101]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.101]                           info)
[17:46:45.101]                         info <- base::paste(info, collapse = "; ")
[17:46:45.101]                         if (!has_future) {
[17:46:45.101]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.101]                             info)
[17:46:45.101]                         }
[17:46:45.101]                         else {
[17:46:45.101]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.101]                             info, version)
[17:46:45.101]                         }
[17:46:45.101]                         base::stop(msg)
[17:46:45.101]                       }
[17:46:45.101]                     })
[17:46:45.101]                   }
[17:46:45.101]                   ...future.strategy.old <- future::plan("list")
[17:46:45.101]                   options(future.plan = NULL)
[17:46:45.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.101]                 }
[17:46:45.101]                 ...future.workdir <- getwd()
[17:46:45.101]             }
[17:46:45.101]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.101]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.101]         }
[17:46:45.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.101]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.101]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.101]             base::names(...future.oldOptions))
[17:46:45.101]     }
[17:46:45.101]     if (FALSE) {
[17:46:45.101]     }
[17:46:45.101]     else {
[17:46:45.101]         if (TRUE) {
[17:46:45.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.101]                 open = "w")
[17:46:45.101]         }
[17:46:45.101]         else {
[17:46:45.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.101]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.101]         }
[17:46:45.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.101]             base::sink(type = "output", split = FALSE)
[17:46:45.101]             base::close(...future.stdout)
[17:46:45.101]         }, add = TRUE)
[17:46:45.101]     }
[17:46:45.101]     ...future.frame <- base::sys.nframe()
[17:46:45.101]     ...future.conditions <- base::list()
[17:46:45.101]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.101]     if (FALSE) {
[17:46:45.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.101]     }
[17:46:45.101]     ...future.result <- base::tryCatch({
[17:46:45.101]         base::withCallingHandlers({
[17:46:45.101]             ...future.value <- base::withVisible(base::local({
[17:46:45.101]                 4
[17:46:45.101]             }))
[17:46:45.101]             future::FutureResult(value = ...future.value$value, 
[17:46:45.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.101]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.101]                     ...future.globalenv.names))
[17:46:45.101]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.101]         }, condition = base::local({
[17:46:45.101]             c <- base::c
[17:46:45.101]             inherits <- base::inherits
[17:46:45.101]             invokeRestart <- base::invokeRestart
[17:46:45.101]             length <- base::length
[17:46:45.101]             list <- base::list
[17:46:45.101]             seq.int <- base::seq.int
[17:46:45.101]             signalCondition <- base::signalCondition
[17:46:45.101]             sys.calls <- base::sys.calls
[17:46:45.101]             `[[` <- base::`[[`
[17:46:45.101]             `+` <- base::`+`
[17:46:45.101]             `<<-` <- base::`<<-`
[17:46:45.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.101]                   3L)]
[17:46:45.101]             }
[17:46:45.101]             function(cond) {
[17:46:45.101]                 is_error <- inherits(cond, "error")
[17:46:45.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.101]                   NULL)
[17:46:45.101]                 if (is_error) {
[17:46:45.101]                   sessionInformation <- function() {
[17:46:45.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.101]                       search = base::search(), system = base::Sys.info())
[17:46:45.101]                   }
[17:46:45.101]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.101]                     cond$call), session = sessionInformation(), 
[17:46:45.101]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.101]                   signalCondition(cond)
[17:46:45.101]                 }
[17:46:45.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.101]                 "immediateCondition"))) {
[17:46:45.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.101]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.101]                   if (TRUE && !signal) {
[17:46:45.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.101]                     {
[17:46:45.101]                       inherits <- base::inherits
[17:46:45.101]                       invokeRestart <- base::invokeRestart
[17:46:45.101]                       is.null <- base::is.null
[17:46:45.101]                       muffled <- FALSE
[17:46:45.101]                       if (inherits(cond, "message")) {
[17:46:45.101]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.101]                         if (muffled) 
[17:46:45.101]                           invokeRestart("muffleMessage")
[17:46:45.101]                       }
[17:46:45.101]                       else if (inherits(cond, "warning")) {
[17:46:45.101]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.101]                         if (muffled) 
[17:46:45.101]                           invokeRestart("muffleWarning")
[17:46:45.101]                       }
[17:46:45.101]                       else if (inherits(cond, "condition")) {
[17:46:45.101]                         if (!is.null(pattern)) {
[17:46:45.101]                           computeRestarts <- base::computeRestarts
[17:46:45.101]                           grepl <- base::grepl
[17:46:45.101]                           restarts <- computeRestarts(cond)
[17:46:45.101]                           for (restart in restarts) {
[17:46:45.101]                             name <- restart$name
[17:46:45.101]                             if (is.null(name)) 
[17:46:45.101]                               next
[17:46:45.101]                             if (!grepl(pattern, name)) 
[17:46:45.101]                               next
[17:46:45.101]                             invokeRestart(restart)
[17:46:45.101]                             muffled <- TRUE
[17:46:45.101]                             break
[17:46:45.101]                           }
[17:46:45.101]                         }
[17:46:45.101]                       }
[17:46:45.101]                       invisible(muffled)
[17:46:45.101]                     }
[17:46:45.101]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.101]                   }
[17:46:45.101]                 }
[17:46:45.101]                 else {
[17:46:45.101]                   if (TRUE) {
[17:46:45.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.101]                     {
[17:46:45.101]                       inherits <- base::inherits
[17:46:45.101]                       invokeRestart <- base::invokeRestart
[17:46:45.101]                       is.null <- base::is.null
[17:46:45.101]                       muffled <- FALSE
[17:46:45.101]                       if (inherits(cond, "message")) {
[17:46:45.101]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.101]                         if (muffled) 
[17:46:45.101]                           invokeRestart("muffleMessage")
[17:46:45.101]                       }
[17:46:45.101]                       else if (inherits(cond, "warning")) {
[17:46:45.101]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.101]                         if (muffled) 
[17:46:45.101]                           invokeRestart("muffleWarning")
[17:46:45.101]                       }
[17:46:45.101]                       else if (inherits(cond, "condition")) {
[17:46:45.101]                         if (!is.null(pattern)) {
[17:46:45.101]                           computeRestarts <- base::computeRestarts
[17:46:45.101]                           grepl <- base::grepl
[17:46:45.101]                           restarts <- computeRestarts(cond)
[17:46:45.101]                           for (restart in restarts) {
[17:46:45.101]                             name <- restart$name
[17:46:45.101]                             if (is.null(name)) 
[17:46:45.101]                               next
[17:46:45.101]                             if (!grepl(pattern, name)) 
[17:46:45.101]                               next
[17:46:45.101]                             invokeRestart(restart)
[17:46:45.101]                             muffled <- TRUE
[17:46:45.101]                             break
[17:46:45.101]                           }
[17:46:45.101]                         }
[17:46:45.101]                       }
[17:46:45.101]                       invisible(muffled)
[17:46:45.101]                     }
[17:46:45.101]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.101]                   }
[17:46:45.101]                 }
[17:46:45.101]             }
[17:46:45.101]         }))
[17:46:45.101]     }, error = function(ex) {
[17:46:45.101]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.101]                 ...future.rng), started = ...future.startTime, 
[17:46:45.101]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.101]             version = "1.8"), class = "FutureResult")
[17:46:45.101]     }, finally = {
[17:46:45.101]         if (!identical(...future.workdir, getwd())) 
[17:46:45.101]             setwd(...future.workdir)
[17:46:45.101]         {
[17:46:45.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.101]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.101]             }
[17:46:45.101]             base::options(...future.oldOptions)
[17:46:45.101]             if (.Platform$OS.type == "windows") {
[17:46:45.101]                 old_names <- names(...future.oldEnvVars)
[17:46:45.101]                 envs <- base::Sys.getenv()
[17:46:45.101]                 names <- names(envs)
[17:46:45.101]                 common <- intersect(names, old_names)
[17:46:45.101]                 added <- setdiff(names, old_names)
[17:46:45.101]                 removed <- setdiff(old_names, names)
[17:46:45.101]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.101]                   envs[common]]
[17:46:45.101]                 NAMES <- toupper(changed)
[17:46:45.101]                 args <- list()
[17:46:45.101]                 for (kk in seq_along(NAMES)) {
[17:46:45.101]                   name <- changed[[kk]]
[17:46:45.101]                   NAME <- NAMES[[kk]]
[17:46:45.101]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.101]                     next
[17:46:45.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.101]                 }
[17:46:45.101]                 NAMES <- toupper(added)
[17:46:45.101]                 for (kk in seq_along(NAMES)) {
[17:46:45.101]                   name <- added[[kk]]
[17:46:45.101]                   NAME <- NAMES[[kk]]
[17:46:45.101]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.101]                     next
[17:46:45.101]                   args[[name]] <- ""
[17:46:45.101]                 }
[17:46:45.101]                 NAMES <- toupper(removed)
[17:46:45.101]                 for (kk in seq_along(NAMES)) {
[17:46:45.101]                   name <- removed[[kk]]
[17:46:45.101]                   NAME <- NAMES[[kk]]
[17:46:45.101]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.101]                     next
[17:46:45.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.101]                 }
[17:46:45.101]                 if (length(args) > 0) 
[17:46:45.101]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.101]             }
[17:46:45.101]             else {
[17:46:45.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.101]             }
[17:46:45.101]             {
[17:46:45.101]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.101]                   0L) {
[17:46:45.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.101]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.101]                   base::options(opts)
[17:46:45.101]                 }
[17:46:45.101]                 {
[17:46:45.101]                   {
[17:46:45.101]                     NULL
[17:46:45.101]                     RNGkind("Mersenne-Twister")
[17:46:45.101]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:45.101]                       inherits = FALSE)
[17:46:45.101]                   }
[17:46:45.101]                   options(future.plan = NULL)
[17:46:45.101]                   if (is.na(NA_character_)) 
[17:46:45.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.101]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.101]                     .init = FALSE)
[17:46:45.101]                 }
[17:46:45.101]             }
[17:46:45.101]         }
[17:46:45.101]     })
[17:46:45.101]     if (TRUE) {
[17:46:45.101]         base::sink(type = "output", split = FALSE)
[17:46:45.101]         if (TRUE) {
[17:46:45.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.101]         }
[17:46:45.101]         else {
[17:46:45.101]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.101]         }
[17:46:45.101]         base::close(...future.stdout)
[17:46:45.101]         ...future.stdout <- NULL
[17:46:45.101]     }
[17:46:45.101]     ...future.result$conditions <- ...future.conditions
[17:46:45.101]     ...future.result$finished <- base::Sys.time()
[17:46:45.101]     ...future.result
[17:46:45.101] }
[17:46:45.103] plan(): Setting new future strategy stack:
[17:46:45.103] List of future strategies:
[17:46:45.103] 1. sequential:
[17:46:45.103]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.103]    - tweaked: FALSE
[17:46:45.103]    - call: NULL
[17:46:45.104] plan(): nbrOfWorkers() = 1
[17:46:45.104] plan(): Setting new future strategy stack:
[17:46:45.104] List of future strategies:
[17:46:45.104] 1. sequential:
[17:46:45.104]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.104]    - tweaked: FALSE
[17:46:45.104]    - call: plan(strategy)
[17:46:45.105] plan(): nbrOfWorkers() = 1
[17:46:45.105] SequentialFuture started (and completed)
[17:46:45.105] - Launch lazy future ... done
[17:46:45.105] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5617879c1798> 
Classes 'listenv', 'environment' <environment: 0x56178753f088> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:45.109] resolved() for ‘SequentialFuture’ ...
[17:46:45.109] - state: ‘finished’
[17:46:45.109] - run: TRUE
[17:46:45.109] - result: ‘FutureResult’
[17:46:45.109] resolved() for ‘SequentialFuture’ ... done
[17:46:45.110] resolved() for ‘SequentialFuture’ ...
[17:46:45.110] - state: ‘finished’
[17:46:45.110] - run: TRUE
[17:46:45.110] - result: ‘FutureResult’
[17:46:45.110] resolved() for ‘SequentialFuture’ ... done
[17:46:45.110] resolved() for ‘SequentialFuture’ ...
[17:46:45.110] - state: ‘finished’
[17:46:45.110] - run: TRUE
[17:46:45.110] - result: ‘FutureResult’
[17:46:45.110] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:45.113] resolve() on list environment ...
[17:46:45.113]  recursive: 0
[17:46:45.114]  length: 6
[17:46:45.114]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:45.114] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.114] - nx: 6
[17:46:45.114] - relay: TRUE
[17:46:45.114] - stdout: TRUE
[17:46:45.115] - signal: TRUE
[17:46:45.115] - resignal: FALSE
[17:46:45.115] - force: TRUE
[17:46:45.115] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.115] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.115]  - until=2
[17:46:45.115]  - relaying element #2
[17:46:45.115] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.115] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.115] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.115]  length: 5 (resolved future 1)
[17:46:45.116] resolved() for ‘SequentialFuture’ ...
[17:46:45.116] - state: ‘finished’
[17:46:45.116] - run: TRUE
[17:46:45.116] - result: ‘FutureResult’
[17:46:45.116] resolved() for ‘SequentialFuture’ ... done
[17:46:45.116] Future #2
[17:46:45.116] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:46:45.116] - nx: 6
[17:46:45.116] - relay: TRUE
[17:46:45.116] - stdout: TRUE
[17:46:45.117] - signal: TRUE
[17:46:45.117] - resignal: FALSE
[17:46:45.117] - force: TRUE
[17:46:45.117] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.117] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.117]  - until=2
[17:46:45.117]  - relaying element #2
[17:46:45.117] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.117] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.117] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:46:45.117]  length: 4 (resolved future 2)
[17:46:45.118] resolved() for ‘SequentialFuture’ ...
[17:46:45.118] - state: ‘finished’
[17:46:45.118] - run: TRUE
[17:46:45.118] - result: ‘FutureResult’
[17:46:45.118] resolved() for ‘SequentialFuture’ ... done
[17:46:45.118] Future #3
[17:46:45.118] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:46:45.118] - nx: 6
[17:46:45.118] - relay: TRUE
[17:46:45.118] - stdout: TRUE
[17:46:45.119] - signal: TRUE
[17:46:45.119] - resignal: FALSE
[17:46:45.119] - force: TRUE
[17:46:45.119] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.119] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.119]  - until=3
[17:46:45.119]  - relaying element #3
[17:46:45.121] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.121] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.121] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:46:45.121]  length: 3 (resolved future 3)
[17:46:45.121] resolved() for ‘SequentialFuture’ ...
[17:46:45.121] - state: ‘finished’
[17:46:45.121] - run: TRUE
[17:46:45.121] - result: ‘FutureResult’
[17:46:45.121] resolved() for ‘SequentialFuture’ ... done
[17:46:45.121] Future #4
[17:46:45.122] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:46:45.122] - nx: 6
[17:46:45.122] - relay: TRUE
[17:46:45.122] - stdout: TRUE
[17:46:45.122] - signal: TRUE
[17:46:45.122] - resignal: FALSE
[17:46:45.122] - force: TRUE
[17:46:45.122] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.122] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.122]  - until=4
[17:46:45.122]  - relaying element #4
[17:46:45.123] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.123] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.123] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:46:45.123]  length: 2 (resolved future 4)
[17:46:45.123] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.123] - nx: 6
[17:46:45.123] - relay: TRUE
[17:46:45.123] - stdout: TRUE
[17:46:45.123] - signal: TRUE
[17:46:45.123] - resignal: FALSE
[17:46:45.124] - force: TRUE
[17:46:45.124] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.124] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.124]  - until=6
[17:46:45.124]  - relaying element #6
[17:46:45.124] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.124] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.124] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.124]  length: 1 (resolved future 5)
[17:46:45.124] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.124] - nx: 6
[17:46:45.125] - relay: TRUE
[17:46:45.125] - stdout: TRUE
[17:46:45.125] - signal: TRUE
[17:46:45.125] - resignal: FALSE
[17:46:45.125] - force: TRUE
[17:46:45.125] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.125] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.125]  - until=6
[17:46:45.125] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.125] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.125] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.125]  length: 0 (resolved future 6)
[17:46:45.126] Relaying remaining futures
[17:46:45.126] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.126] - nx: 6
[17:46:45.126] - relay: TRUE
[17:46:45.126] - stdout: TRUE
[17:46:45.126] - signal: TRUE
[17:46:45.126] - resignal: FALSE
[17:46:45.126] - force: TRUE
[17:46:45.126] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.126] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:45.126] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.126] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.127] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.127] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x561787bf5e48> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[17:46:45.129] plan(): Setting new future strategy stack:
[17:46:45.130] List of future strategies:
[17:46:45.130] 1. multicore:
[17:46:45.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.130]    - tweaked: FALSE
[17:46:45.130]    - call: plan(strategy)
[17:46:45.134] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:46:45.134] getGlobalsAndPackages() ...
[17:46:45.134] Searching for globals...
[17:46:45.134] 
[17:46:45.135] Searching for globals ... DONE
[17:46:45.135] - globals: [0] <none>
[17:46:45.135] getGlobalsAndPackages() ... DONE
[17:46:45.135] run() for ‘Future’ ...
[17:46:45.135] - state: ‘created’
[17:46:45.135] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.139] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.139]   - Field: ‘label’
[17:46:45.139]   - Field: ‘local’
[17:46:45.139]   - Field: ‘owner’
[17:46:45.139]   - Field: ‘envir’
[17:46:45.139]   - Field: ‘workers’
[17:46:45.140]   - Field: ‘packages’
[17:46:45.140]   - Field: ‘gc’
[17:46:45.140]   - Field: ‘job’
[17:46:45.140]   - Field: ‘conditions’
[17:46:45.140]   - Field: ‘expr’
[17:46:45.140]   - Field: ‘uuid’
[17:46:45.140]   - Field: ‘seed’
[17:46:45.140]   - Field: ‘version’
[17:46:45.140]   - Field: ‘result’
[17:46:45.140]   - Field: ‘asynchronous’
[17:46:45.140]   - Field: ‘calls’
[17:46:45.140]   - Field: ‘globals’
[17:46:45.141]   - Field: ‘stdout’
[17:46:45.141]   - Field: ‘earlySignal’
[17:46:45.141]   - Field: ‘lazy’
[17:46:45.141]   - Field: ‘state’
[17:46:45.141] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.141] - Launch lazy future ...
[17:46:45.142] Packages needed by the future expression (n = 0): <none>
[17:46:45.142] Packages needed by future strategies (n = 0): <none>
[17:46:45.142] {
[17:46:45.142]     {
[17:46:45.142]         {
[17:46:45.142]             ...future.startTime <- base::Sys.time()
[17:46:45.142]             {
[17:46:45.142]                 {
[17:46:45.142]                   {
[17:46:45.142]                     {
[17:46:45.142]                       base::local({
[17:46:45.142]                         has_future <- base::requireNamespace("future", 
[17:46:45.142]                           quietly = TRUE)
[17:46:45.142]                         if (has_future) {
[17:46:45.142]                           ns <- base::getNamespace("future")
[17:46:45.142]                           version <- ns[[".package"]][["version"]]
[17:46:45.142]                           if (is.null(version)) 
[17:46:45.142]                             version <- utils::packageVersion("future")
[17:46:45.142]                         }
[17:46:45.142]                         else {
[17:46:45.142]                           version <- NULL
[17:46:45.142]                         }
[17:46:45.142]                         if (!has_future || version < "1.8.0") {
[17:46:45.142]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.142]                             "", base::R.version$version.string), 
[17:46:45.142]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.142]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.142]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.142]                               "release", "version")], collapse = " "), 
[17:46:45.142]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.142]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.142]                             info)
[17:46:45.142]                           info <- base::paste(info, collapse = "; ")
[17:46:45.142]                           if (!has_future) {
[17:46:45.142]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.142]                               info)
[17:46:45.142]                           }
[17:46:45.142]                           else {
[17:46:45.142]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.142]                               info, version)
[17:46:45.142]                           }
[17:46:45.142]                           base::stop(msg)
[17:46:45.142]                         }
[17:46:45.142]                       })
[17:46:45.142]                     }
[17:46:45.142]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.142]                     base::options(mc.cores = 1L)
[17:46:45.142]                   }
[17:46:45.142]                   ...future.strategy.old <- future::plan("list")
[17:46:45.142]                   options(future.plan = NULL)
[17:46:45.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.142]                 }
[17:46:45.142]                 ...future.workdir <- getwd()
[17:46:45.142]             }
[17:46:45.142]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.142]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.142]         }
[17:46:45.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.142]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.142]             base::names(...future.oldOptions))
[17:46:45.142]     }
[17:46:45.142]     if (FALSE) {
[17:46:45.142]     }
[17:46:45.142]     else {
[17:46:45.142]         if (TRUE) {
[17:46:45.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.142]                 open = "w")
[17:46:45.142]         }
[17:46:45.142]         else {
[17:46:45.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.142]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.142]         }
[17:46:45.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.142]             base::sink(type = "output", split = FALSE)
[17:46:45.142]             base::close(...future.stdout)
[17:46:45.142]         }, add = TRUE)
[17:46:45.142]     }
[17:46:45.142]     ...future.frame <- base::sys.nframe()
[17:46:45.142]     ...future.conditions <- base::list()
[17:46:45.142]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.142]     if (FALSE) {
[17:46:45.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.142]     }
[17:46:45.142]     ...future.result <- base::tryCatch({
[17:46:45.142]         base::withCallingHandlers({
[17:46:45.142]             ...future.value <- base::withVisible(base::local({
[17:46:45.142]                 withCallingHandlers({
[17:46:45.142]                   2
[17:46:45.142]                 }, immediateCondition = function(cond) {
[17:46:45.142]                   save_rds <- function (object, pathname, ...) 
[17:46:45.142]                   {
[17:46:45.142]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.142]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.142]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.142]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.142]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.142]                         fi_tmp[["mtime"]])
[17:46:45.142]                     }
[17:46:45.142]                     tryCatch({
[17:46:45.142]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.142]                     }, error = function(ex) {
[17:46:45.142]                       msg <- conditionMessage(ex)
[17:46:45.142]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.142]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.142]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.142]                         fi_tmp[["mtime"]], msg)
[17:46:45.142]                       ex$message <- msg
[17:46:45.142]                       stop(ex)
[17:46:45.142]                     })
[17:46:45.142]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.142]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.142]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.142]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.142]                       fi <- file.info(pathname)
[17:46:45.142]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.142]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.142]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.142]                         fi[["size"]], fi[["mtime"]])
[17:46:45.142]                       stop(msg)
[17:46:45.142]                     }
[17:46:45.142]                     invisible(pathname)
[17:46:45.142]                   }
[17:46:45.142]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.142]                     rootPath = tempdir()) 
[17:46:45.142]                   {
[17:46:45.142]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.142]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.142]                       tmpdir = path, fileext = ".rds")
[17:46:45.142]                     save_rds(obj, file)
[17:46:45.142]                   }
[17:46:45.142]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.142]                   {
[17:46:45.142]                     inherits <- base::inherits
[17:46:45.142]                     invokeRestart <- base::invokeRestart
[17:46:45.142]                     is.null <- base::is.null
[17:46:45.142]                     muffled <- FALSE
[17:46:45.142]                     if (inherits(cond, "message")) {
[17:46:45.142]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.142]                       if (muffled) 
[17:46:45.142]                         invokeRestart("muffleMessage")
[17:46:45.142]                     }
[17:46:45.142]                     else if (inherits(cond, "warning")) {
[17:46:45.142]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.142]                       if (muffled) 
[17:46:45.142]                         invokeRestart("muffleWarning")
[17:46:45.142]                     }
[17:46:45.142]                     else if (inherits(cond, "condition")) {
[17:46:45.142]                       if (!is.null(pattern)) {
[17:46:45.142]                         computeRestarts <- base::computeRestarts
[17:46:45.142]                         grepl <- base::grepl
[17:46:45.142]                         restarts <- computeRestarts(cond)
[17:46:45.142]                         for (restart in restarts) {
[17:46:45.142]                           name <- restart$name
[17:46:45.142]                           if (is.null(name)) 
[17:46:45.142]                             next
[17:46:45.142]                           if (!grepl(pattern, name)) 
[17:46:45.142]                             next
[17:46:45.142]                           invokeRestart(restart)
[17:46:45.142]                           muffled <- TRUE
[17:46:45.142]                           break
[17:46:45.142]                         }
[17:46:45.142]                       }
[17:46:45.142]                     }
[17:46:45.142]                     invisible(muffled)
[17:46:45.142]                   }
[17:46:45.142]                   muffleCondition(cond)
[17:46:45.142]                 })
[17:46:45.142]             }))
[17:46:45.142]             future::FutureResult(value = ...future.value$value, 
[17:46:45.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.142]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.142]                     ...future.globalenv.names))
[17:46:45.142]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.142]         }, condition = base::local({
[17:46:45.142]             c <- base::c
[17:46:45.142]             inherits <- base::inherits
[17:46:45.142]             invokeRestart <- base::invokeRestart
[17:46:45.142]             length <- base::length
[17:46:45.142]             list <- base::list
[17:46:45.142]             seq.int <- base::seq.int
[17:46:45.142]             signalCondition <- base::signalCondition
[17:46:45.142]             sys.calls <- base::sys.calls
[17:46:45.142]             `[[` <- base::`[[`
[17:46:45.142]             `+` <- base::`+`
[17:46:45.142]             `<<-` <- base::`<<-`
[17:46:45.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.142]                   3L)]
[17:46:45.142]             }
[17:46:45.142]             function(cond) {
[17:46:45.142]                 is_error <- inherits(cond, "error")
[17:46:45.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.142]                   NULL)
[17:46:45.142]                 if (is_error) {
[17:46:45.142]                   sessionInformation <- function() {
[17:46:45.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.142]                       search = base::search(), system = base::Sys.info())
[17:46:45.142]                   }
[17:46:45.142]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.142]                     cond$call), session = sessionInformation(), 
[17:46:45.142]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.142]                   signalCondition(cond)
[17:46:45.142]                 }
[17:46:45.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.142]                 "immediateCondition"))) {
[17:46:45.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.142]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.142]                   if (TRUE && !signal) {
[17:46:45.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.142]                     {
[17:46:45.142]                       inherits <- base::inherits
[17:46:45.142]                       invokeRestart <- base::invokeRestart
[17:46:45.142]                       is.null <- base::is.null
[17:46:45.142]                       muffled <- FALSE
[17:46:45.142]                       if (inherits(cond, "message")) {
[17:46:45.142]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.142]                         if (muffled) 
[17:46:45.142]                           invokeRestart("muffleMessage")
[17:46:45.142]                       }
[17:46:45.142]                       else if (inherits(cond, "warning")) {
[17:46:45.142]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.142]                         if (muffled) 
[17:46:45.142]                           invokeRestart("muffleWarning")
[17:46:45.142]                       }
[17:46:45.142]                       else if (inherits(cond, "condition")) {
[17:46:45.142]                         if (!is.null(pattern)) {
[17:46:45.142]                           computeRestarts <- base::computeRestarts
[17:46:45.142]                           grepl <- base::grepl
[17:46:45.142]                           restarts <- computeRestarts(cond)
[17:46:45.142]                           for (restart in restarts) {
[17:46:45.142]                             name <- restart$name
[17:46:45.142]                             if (is.null(name)) 
[17:46:45.142]                               next
[17:46:45.142]                             if (!grepl(pattern, name)) 
[17:46:45.142]                               next
[17:46:45.142]                             invokeRestart(restart)
[17:46:45.142]                             muffled <- TRUE
[17:46:45.142]                             break
[17:46:45.142]                           }
[17:46:45.142]                         }
[17:46:45.142]                       }
[17:46:45.142]                       invisible(muffled)
[17:46:45.142]                     }
[17:46:45.142]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.142]                   }
[17:46:45.142]                 }
[17:46:45.142]                 else {
[17:46:45.142]                   if (TRUE) {
[17:46:45.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.142]                     {
[17:46:45.142]                       inherits <- base::inherits
[17:46:45.142]                       invokeRestart <- base::invokeRestart
[17:46:45.142]                       is.null <- base::is.null
[17:46:45.142]                       muffled <- FALSE
[17:46:45.142]                       if (inherits(cond, "message")) {
[17:46:45.142]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.142]                         if (muffled) 
[17:46:45.142]                           invokeRestart("muffleMessage")
[17:46:45.142]                       }
[17:46:45.142]                       else if (inherits(cond, "warning")) {
[17:46:45.142]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.142]                         if (muffled) 
[17:46:45.142]                           invokeRestart("muffleWarning")
[17:46:45.142]                       }
[17:46:45.142]                       else if (inherits(cond, "condition")) {
[17:46:45.142]                         if (!is.null(pattern)) {
[17:46:45.142]                           computeRestarts <- base::computeRestarts
[17:46:45.142]                           grepl <- base::grepl
[17:46:45.142]                           restarts <- computeRestarts(cond)
[17:46:45.142]                           for (restart in restarts) {
[17:46:45.142]                             name <- restart$name
[17:46:45.142]                             if (is.null(name)) 
[17:46:45.142]                               next
[17:46:45.142]                             if (!grepl(pattern, name)) 
[17:46:45.142]                               next
[17:46:45.142]                             invokeRestart(restart)
[17:46:45.142]                             muffled <- TRUE
[17:46:45.142]                             break
[17:46:45.142]                           }
[17:46:45.142]                         }
[17:46:45.142]                       }
[17:46:45.142]                       invisible(muffled)
[17:46:45.142]                     }
[17:46:45.142]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.142]                   }
[17:46:45.142]                 }
[17:46:45.142]             }
[17:46:45.142]         }))
[17:46:45.142]     }, error = function(ex) {
[17:46:45.142]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.142]                 ...future.rng), started = ...future.startTime, 
[17:46:45.142]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.142]             version = "1.8"), class = "FutureResult")
[17:46:45.142]     }, finally = {
[17:46:45.142]         if (!identical(...future.workdir, getwd())) 
[17:46:45.142]             setwd(...future.workdir)
[17:46:45.142]         {
[17:46:45.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.142]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.142]             }
[17:46:45.142]             base::options(...future.oldOptions)
[17:46:45.142]             if (.Platform$OS.type == "windows") {
[17:46:45.142]                 old_names <- names(...future.oldEnvVars)
[17:46:45.142]                 envs <- base::Sys.getenv()
[17:46:45.142]                 names <- names(envs)
[17:46:45.142]                 common <- intersect(names, old_names)
[17:46:45.142]                 added <- setdiff(names, old_names)
[17:46:45.142]                 removed <- setdiff(old_names, names)
[17:46:45.142]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.142]                   envs[common]]
[17:46:45.142]                 NAMES <- toupper(changed)
[17:46:45.142]                 args <- list()
[17:46:45.142]                 for (kk in seq_along(NAMES)) {
[17:46:45.142]                   name <- changed[[kk]]
[17:46:45.142]                   NAME <- NAMES[[kk]]
[17:46:45.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.142]                     next
[17:46:45.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.142]                 }
[17:46:45.142]                 NAMES <- toupper(added)
[17:46:45.142]                 for (kk in seq_along(NAMES)) {
[17:46:45.142]                   name <- added[[kk]]
[17:46:45.142]                   NAME <- NAMES[[kk]]
[17:46:45.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.142]                     next
[17:46:45.142]                   args[[name]] <- ""
[17:46:45.142]                 }
[17:46:45.142]                 NAMES <- toupper(removed)
[17:46:45.142]                 for (kk in seq_along(NAMES)) {
[17:46:45.142]                   name <- removed[[kk]]
[17:46:45.142]                   NAME <- NAMES[[kk]]
[17:46:45.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.142]                     next
[17:46:45.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.142]                 }
[17:46:45.142]                 if (length(args) > 0) 
[17:46:45.142]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.142]             }
[17:46:45.142]             else {
[17:46:45.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.142]             }
[17:46:45.142]             {
[17:46:45.142]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.142]                   0L) {
[17:46:45.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.142]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.142]                   base::options(opts)
[17:46:45.142]                 }
[17:46:45.142]                 {
[17:46:45.142]                   {
[17:46:45.142]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.142]                     NULL
[17:46:45.142]                   }
[17:46:45.142]                   options(future.plan = NULL)
[17:46:45.142]                   if (is.na(NA_character_)) 
[17:46:45.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.142]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.142]                     .init = FALSE)
[17:46:45.142]                 }
[17:46:45.142]             }
[17:46:45.142]         }
[17:46:45.142]     })
[17:46:45.142]     if (TRUE) {
[17:46:45.142]         base::sink(type = "output", split = FALSE)
[17:46:45.142]         if (TRUE) {
[17:46:45.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.142]         }
[17:46:45.142]         else {
[17:46:45.142]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.142]         }
[17:46:45.142]         base::close(...future.stdout)
[17:46:45.142]         ...future.stdout <- NULL
[17:46:45.142]     }
[17:46:45.142]     ...future.result$conditions <- ...future.conditions
[17:46:45.142]     ...future.result$finished <- base::Sys.time()
[17:46:45.142]     ...future.result
[17:46:45.142] }
[17:46:45.145] requestCore(): workers = 2
[17:46:45.148] MulticoreFuture started
[17:46:45.148] - Launch lazy future ... done
[17:46:45.148] run() for ‘MulticoreFuture’ ... done
[17:46:45.148] plan(): Setting new future strategy stack:
[17:46:45.149] getGlobalsAndPackages() ...
[17:46:45.149] Searching for globals...
[17:46:45.149] List of future strategies:
[17:46:45.149] 1. sequential:
[17:46:45.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.149]    - tweaked: FALSE
[17:46:45.149]    - call: NULL
[17:46:45.150] plan(): nbrOfWorkers() = 1
[17:46:45.150] 
[17:46:45.150] Searching for globals ... DONE
[17:46:45.151] - globals: [0] <none>
[17:46:45.151] getGlobalsAndPackages() ... DONE
[17:46:45.151] run() for ‘Future’ ...
[17:46:45.152] plan(): Setting new future strategy stack:
[17:46:45.152] - state: ‘created’
[17:46:45.152] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.152] List of future strategies:
[17:46:45.152] 1. multicore:
[17:46:45.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.152]    - tweaked: FALSE
[17:46:45.152]    - call: plan(strategy)
[17:46:45.157] plan(): nbrOfWorkers() = 2
[17:46:45.157] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.158]   - Field: ‘label’
[17:46:45.158]   - Field: ‘local’
[17:46:45.158]   - Field: ‘owner’
[17:46:45.158]   - Field: ‘envir’
[17:46:45.158]   - Field: ‘workers’
[17:46:45.158]   - Field: ‘packages’
[17:46:45.159]   - Field: ‘gc’
[17:46:45.159]   - Field: ‘job’
[17:46:45.159]   - Field: ‘conditions’
[17:46:45.159]   - Field: ‘expr’
[17:46:45.159]   - Field: ‘uuid’
[17:46:45.159]   - Field: ‘seed’
[17:46:45.159]   - Field: ‘version’
[17:46:45.160]   - Field: ‘result’
[17:46:45.160]   - Field: ‘asynchronous’
[17:46:45.160]   - Field: ‘calls’
[17:46:45.160]   - Field: ‘globals’
[17:46:45.160]   - Field: ‘stdout’
[17:46:45.160]   - Field: ‘earlySignal’
[17:46:45.160]   - Field: ‘lazy’
[17:46:45.161]   - Field: ‘state’
[17:46:45.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.161] - Launch lazy future ...
[17:46:45.161] Packages needed by the future expression (n = 0): <none>
[17:46:45.161] Packages needed by future strategies (n = 0): <none>
[17:46:45.162] {
[17:46:45.162]     {
[17:46:45.162]         {
[17:46:45.162]             ...future.startTime <- base::Sys.time()
[17:46:45.162]             {
[17:46:45.162]                 {
[17:46:45.162]                   {
[17:46:45.162]                     {
[17:46:45.162]                       base::local({
[17:46:45.162]                         has_future <- base::requireNamespace("future", 
[17:46:45.162]                           quietly = TRUE)
[17:46:45.162]                         if (has_future) {
[17:46:45.162]                           ns <- base::getNamespace("future")
[17:46:45.162]                           version <- ns[[".package"]][["version"]]
[17:46:45.162]                           if (is.null(version)) 
[17:46:45.162]                             version <- utils::packageVersion("future")
[17:46:45.162]                         }
[17:46:45.162]                         else {
[17:46:45.162]                           version <- NULL
[17:46:45.162]                         }
[17:46:45.162]                         if (!has_future || version < "1.8.0") {
[17:46:45.162]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.162]                             "", base::R.version$version.string), 
[17:46:45.162]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.162]                               "release", "version")], collapse = " "), 
[17:46:45.162]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.162]                             info)
[17:46:45.162]                           info <- base::paste(info, collapse = "; ")
[17:46:45.162]                           if (!has_future) {
[17:46:45.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.162]                               info)
[17:46:45.162]                           }
[17:46:45.162]                           else {
[17:46:45.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.162]                               info, version)
[17:46:45.162]                           }
[17:46:45.162]                           base::stop(msg)
[17:46:45.162]                         }
[17:46:45.162]                       })
[17:46:45.162]                     }
[17:46:45.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.162]                     base::options(mc.cores = 1L)
[17:46:45.162]                   }
[17:46:45.162]                   ...future.strategy.old <- future::plan("list")
[17:46:45.162]                   options(future.plan = NULL)
[17:46:45.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.162]                 }
[17:46:45.162]                 ...future.workdir <- getwd()
[17:46:45.162]             }
[17:46:45.162]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.162]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.162]         }
[17:46:45.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.162]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.162]             base::names(...future.oldOptions))
[17:46:45.162]     }
[17:46:45.162]     if (FALSE) {
[17:46:45.162]     }
[17:46:45.162]     else {
[17:46:45.162]         if (TRUE) {
[17:46:45.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.162]                 open = "w")
[17:46:45.162]         }
[17:46:45.162]         else {
[17:46:45.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.162]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.162]         }
[17:46:45.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.162]             base::sink(type = "output", split = FALSE)
[17:46:45.162]             base::close(...future.stdout)
[17:46:45.162]         }, add = TRUE)
[17:46:45.162]     }
[17:46:45.162]     ...future.frame <- base::sys.nframe()
[17:46:45.162]     ...future.conditions <- base::list()
[17:46:45.162]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.162]     if (FALSE) {
[17:46:45.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.162]     }
[17:46:45.162]     ...future.result <- base::tryCatch({
[17:46:45.162]         base::withCallingHandlers({
[17:46:45.162]             ...future.value <- base::withVisible(base::local({
[17:46:45.162]                 withCallingHandlers({
[17:46:45.162]                   NULL
[17:46:45.162]                 }, immediateCondition = function(cond) {
[17:46:45.162]                   save_rds <- function (object, pathname, ...) 
[17:46:45.162]                   {
[17:46:45.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.162]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.162]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.162]                         fi_tmp[["mtime"]])
[17:46:45.162]                     }
[17:46:45.162]                     tryCatch({
[17:46:45.162]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.162]                     }, error = function(ex) {
[17:46:45.162]                       msg <- conditionMessage(ex)
[17:46:45.162]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.162]                         fi_tmp[["mtime"]], msg)
[17:46:45.162]                       ex$message <- msg
[17:46:45.162]                       stop(ex)
[17:46:45.162]                     })
[17:46:45.162]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.162]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.162]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.162]                       fi <- file.info(pathname)
[17:46:45.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.162]                         fi[["size"]], fi[["mtime"]])
[17:46:45.162]                       stop(msg)
[17:46:45.162]                     }
[17:46:45.162]                     invisible(pathname)
[17:46:45.162]                   }
[17:46:45.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.162]                     rootPath = tempdir()) 
[17:46:45.162]                   {
[17:46:45.162]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.162]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.162]                       tmpdir = path, fileext = ".rds")
[17:46:45.162]                     save_rds(obj, file)
[17:46:45.162]                   }
[17:46:45.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.162]                   {
[17:46:45.162]                     inherits <- base::inherits
[17:46:45.162]                     invokeRestart <- base::invokeRestart
[17:46:45.162]                     is.null <- base::is.null
[17:46:45.162]                     muffled <- FALSE
[17:46:45.162]                     if (inherits(cond, "message")) {
[17:46:45.162]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.162]                       if (muffled) 
[17:46:45.162]                         invokeRestart("muffleMessage")
[17:46:45.162]                     }
[17:46:45.162]                     else if (inherits(cond, "warning")) {
[17:46:45.162]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.162]                       if (muffled) 
[17:46:45.162]                         invokeRestart("muffleWarning")
[17:46:45.162]                     }
[17:46:45.162]                     else if (inherits(cond, "condition")) {
[17:46:45.162]                       if (!is.null(pattern)) {
[17:46:45.162]                         computeRestarts <- base::computeRestarts
[17:46:45.162]                         grepl <- base::grepl
[17:46:45.162]                         restarts <- computeRestarts(cond)
[17:46:45.162]                         for (restart in restarts) {
[17:46:45.162]                           name <- restart$name
[17:46:45.162]                           if (is.null(name)) 
[17:46:45.162]                             next
[17:46:45.162]                           if (!grepl(pattern, name)) 
[17:46:45.162]                             next
[17:46:45.162]                           invokeRestart(restart)
[17:46:45.162]                           muffled <- TRUE
[17:46:45.162]                           break
[17:46:45.162]                         }
[17:46:45.162]                       }
[17:46:45.162]                     }
[17:46:45.162]                     invisible(muffled)
[17:46:45.162]                   }
[17:46:45.162]                   muffleCondition(cond)
[17:46:45.162]                 })
[17:46:45.162]             }))
[17:46:45.162]             future::FutureResult(value = ...future.value$value, 
[17:46:45.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.162]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.162]                     ...future.globalenv.names))
[17:46:45.162]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.162]         }, condition = base::local({
[17:46:45.162]             c <- base::c
[17:46:45.162]             inherits <- base::inherits
[17:46:45.162]             invokeRestart <- base::invokeRestart
[17:46:45.162]             length <- base::length
[17:46:45.162]             list <- base::list
[17:46:45.162]             seq.int <- base::seq.int
[17:46:45.162]             signalCondition <- base::signalCondition
[17:46:45.162]             sys.calls <- base::sys.calls
[17:46:45.162]             `[[` <- base::`[[`
[17:46:45.162]             `+` <- base::`+`
[17:46:45.162]             `<<-` <- base::`<<-`
[17:46:45.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.162]                   3L)]
[17:46:45.162]             }
[17:46:45.162]             function(cond) {
[17:46:45.162]                 is_error <- inherits(cond, "error")
[17:46:45.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.162]                   NULL)
[17:46:45.162]                 if (is_error) {
[17:46:45.162]                   sessionInformation <- function() {
[17:46:45.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.162]                       search = base::search(), system = base::Sys.info())
[17:46:45.162]                   }
[17:46:45.162]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.162]                     cond$call), session = sessionInformation(), 
[17:46:45.162]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.162]                   signalCondition(cond)
[17:46:45.162]                 }
[17:46:45.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.162]                 "immediateCondition"))) {
[17:46:45.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.162]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.162]                   if (TRUE && !signal) {
[17:46:45.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.162]                     {
[17:46:45.162]                       inherits <- base::inherits
[17:46:45.162]                       invokeRestart <- base::invokeRestart
[17:46:45.162]                       is.null <- base::is.null
[17:46:45.162]                       muffled <- FALSE
[17:46:45.162]                       if (inherits(cond, "message")) {
[17:46:45.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.162]                         if (muffled) 
[17:46:45.162]                           invokeRestart("muffleMessage")
[17:46:45.162]                       }
[17:46:45.162]                       else if (inherits(cond, "warning")) {
[17:46:45.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.162]                         if (muffled) 
[17:46:45.162]                           invokeRestart("muffleWarning")
[17:46:45.162]                       }
[17:46:45.162]                       else if (inherits(cond, "condition")) {
[17:46:45.162]                         if (!is.null(pattern)) {
[17:46:45.162]                           computeRestarts <- base::computeRestarts
[17:46:45.162]                           grepl <- base::grepl
[17:46:45.162]                           restarts <- computeRestarts(cond)
[17:46:45.162]                           for (restart in restarts) {
[17:46:45.162]                             name <- restart$name
[17:46:45.162]                             if (is.null(name)) 
[17:46:45.162]                               next
[17:46:45.162]                             if (!grepl(pattern, name)) 
[17:46:45.162]                               next
[17:46:45.162]                             invokeRestart(restart)
[17:46:45.162]                             muffled <- TRUE
[17:46:45.162]                             break
[17:46:45.162]                           }
[17:46:45.162]                         }
[17:46:45.162]                       }
[17:46:45.162]                       invisible(muffled)
[17:46:45.162]                     }
[17:46:45.162]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.162]                   }
[17:46:45.162]                 }
[17:46:45.162]                 else {
[17:46:45.162]                   if (TRUE) {
[17:46:45.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.162]                     {
[17:46:45.162]                       inherits <- base::inherits
[17:46:45.162]                       invokeRestart <- base::invokeRestart
[17:46:45.162]                       is.null <- base::is.null
[17:46:45.162]                       muffled <- FALSE
[17:46:45.162]                       if (inherits(cond, "message")) {
[17:46:45.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.162]                         if (muffled) 
[17:46:45.162]                           invokeRestart("muffleMessage")
[17:46:45.162]                       }
[17:46:45.162]                       else if (inherits(cond, "warning")) {
[17:46:45.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.162]                         if (muffled) 
[17:46:45.162]                           invokeRestart("muffleWarning")
[17:46:45.162]                       }
[17:46:45.162]                       else if (inherits(cond, "condition")) {
[17:46:45.162]                         if (!is.null(pattern)) {
[17:46:45.162]                           computeRestarts <- base::computeRestarts
[17:46:45.162]                           grepl <- base::grepl
[17:46:45.162]                           restarts <- computeRestarts(cond)
[17:46:45.162]                           for (restart in restarts) {
[17:46:45.162]                             name <- restart$name
[17:46:45.162]                             if (is.null(name)) 
[17:46:45.162]                               next
[17:46:45.162]                             if (!grepl(pattern, name)) 
[17:46:45.162]                               next
[17:46:45.162]                             invokeRestart(restart)
[17:46:45.162]                             muffled <- TRUE
[17:46:45.162]                             break
[17:46:45.162]                           }
[17:46:45.162]                         }
[17:46:45.162]                       }
[17:46:45.162]                       invisible(muffled)
[17:46:45.162]                     }
[17:46:45.162]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.162]                   }
[17:46:45.162]                 }
[17:46:45.162]             }
[17:46:45.162]         }))
[17:46:45.162]     }, error = function(ex) {
[17:46:45.162]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.162]                 ...future.rng), started = ...future.startTime, 
[17:46:45.162]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.162]             version = "1.8"), class = "FutureResult")
[17:46:45.162]     }, finally = {
[17:46:45.162]         if (!identical(...future.workdir, getwd())) 
[17:46:45.162]             setwd(...future.workdir)
[17:46:45.162]         {
[17:46:45.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.162]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.162]             }
[17:46:45.162]             base::options(...future.oldOptions)
[17:46:45.162]             if (.Platform$OS.type == "windows") {
[17:46:45.162]                 old_names <- names(...future.oldEnvVars)
[17:46:45.162]                 envs <- base::Sys.getenv()
[17:46:45.162]                 names <- names(envs)
[17:46:45.162]                 common <- intersect(names, old_names)
[17:46:45.162]                 added <- setdiff(names, old_names)
[17:46:45.162]                 removed <- setdiff(old_names, names)
[17:46:45.162]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.162]                   envs[common]]
[17:46:45.162]                 NAMES <- toupper(changed)
[17:46:45.162]                 args <- list()
[17:46:45.162]                 for (kk in seq_along(NAMES)) {
[17:46:45.162]                   name <- changed[[kk]]
[17:46:45.162]                   NAME <- NAMES[[kk]]
[17:46:45.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.162]                     next
[17:46:45.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.162]                 }
[17:46:45.162]                 NAMES <- toupper(added)
[17:46:45.162]                 for (kk in seq_along(NAMES)) {
[17:46:45.162]                   name <- added[[kk]]
[17:46:45.162]                   NAME <- NAMES[[kk]]
[17:46:45.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.162]                     next
[17:46:45.162]                   args[[name]] <- ""
[17:46:45.162]                 }
[17:46:45.162]                 NAMES <- toupper(removed)
[17:46:45.162]                 for (kk in seq_along(NAMES)) {
[17:46:45.162]                   name <- removed[[kk]]
[17:46:45.162]                   NAME <- NAMES[[kk]]
[17:46:45.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.162]                     next
[17:46:45.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.162]                 }
[17:46:45.162]                 if (length(args) > 0) 
[17:46:45.162]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.162]             }
[17:46:45.162]             else {
[17:46:45.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.162]             }
[17:46:45.162]             {
[17:46:45.162]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.162]                   0L) {
[17:46:45.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.162]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.162]                   base::options(opts)
[17:46:45.162]                 }
[17:46:45.162]                 {
[17:46:45.162]                   {
[17:46:45.162]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.162]                     NULL
[17:46:45.162]                   }
[17:46:45.162]                   options(future.plan = NULL)
[17:46:45.162]                   if (is.na(NA_character_)) 
[17:46:45.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.162]                     .init = FALSE)
[17:46:45.162]                 }
[17:46:45.162]             }
[17:46:45.162]         }
[17:46:45.162]     })
[17:46:45.162]     if (TRUE) {
[17:46:45.162]         base::sink(type = "output", split = FALSE)
[17:46:45.162]         if (TRUE) {
[17:46:45.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.162]         }
[17:46:45.162]         else {
[17:46:45.162]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.162]         }
[17:46:45.162]         base::close(...future.stdout)
[17:46:45.162]         ...future.stdout <- NULL
[17:46:45.162]     }
[17:46:45.162]     ...future.result$conditions <- ...future.conditions
[17:46:45.162]     ...future.result$finished <- base::Sys.time()
[17:46:45.162]     ...future.result
[17:46:45.162] }
[17:46:45.166] requestCore(): workers = 2
[17:46:45.176] MulticoreFuture started
[17:46:45.177] - Launch lazy future ... done
[17:46:45.177] run() for ‘MulticoreFuture’ ... done
[17:46:45.177] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:46:45.178] List of future strategies:
[17:46:45.178] 1. sequential:
[17:46:45.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.178]    - tweaked: FALSE
[17:46:45.178]    - call: NULL
 num [17:46:45.179] plan(): nbrOfWorkers() = 1
1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617875bdbe8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787bf7898> 
 $  : NULL
 $  : NULL
[17:46:45.182] plan(): Setting new future strategy stack:
 $  :[17:46:45.182] List of future strategies:
[17:46:45.182] 1. multicore:
[17:46:45.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.182]    - tweaked: FALSE
[17:46:45.182]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617875bdbe8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787bf7898> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:46:45.187] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:45.189] resolve() on list ...
[17:46:45.189]  recursive: 0
[17:46:45.190]  length: 6
[17:46:45.190]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:45.190] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.190] - nx: 6
[17:46:45.190] - relay: TRUE
[17:46:45.190] - stdout: TRUE
[17:46:45.191] - signal: TRUE
[17:46:45.191] - resignal: FALSE
[17:46:45.191] - force: TRUE
[17:46:45.191] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.191] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.191]  - until=2
[17:46:45.191]  - relaying element #2
[17:46:45.192] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.192] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.192] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.192]  length: 5 (resolved future 1)
[17:46:45.192] Future #2
[17:46:45.193] result() for MulticoreFuture ...
[17:46:45.195] result() for MulticoreFuture ...
[17:46:45.195] result() for MulticoreFuture ... done
[17:46:45.195] result() for MulticoreFuture ... done
[17:46:45.195] result() for MulticoreFuture ...
[17:46:45.195] result() for MulticoreFuture ... done
[17:46:45.196] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:45.196] - nx: 6
[17:46:45.196] - relay: TRUE
[17:46:45.196] - stdout: TRUE
[17:46:45.196] - signal: TRUE
[17:46:45.196] - resignal: FALSE
[17:46:45.197] - force: TRUE
[17:46:45.197] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.197] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.197]  - until=2
[17:46:45.197]  - relaying element #2
[17:46:45.197] result() for MulticoreFuture ...
[17:46:45.198] result() for MulticoreFuture ... done
[17:46:45.198] result() for MulticoreFuture ...
[17:46:45.198] result() for MulticoreFuture ... done
[17:46:45.198] result() for MulticoreFuture ...
[17:46:45.198] result() for MulticoreFuture ... done
[17:46:45.198] result() for MulticoreFuture ...
[17:46:45.199] result() for MulticoreFuture ... done
[17:46:45.199] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.199] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.199] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:45.199]  length: 4 (resolved future 2)
[17:46:45.200] Future #3
[17:46:45.200] result() for MulticoreFuture ...
[17:46:45.200] result() for MulticoreFuture ...
[17:46:45.201] result() for MulticoreFuture ... done
[17:46:45.201] result() for MulticoreFuture ... done
[17:46:45.201] result() for MulticoreFuture ...
[17:46:45.201] result() for MulticoreFuture ... done
[17:46:45.201] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:45.201] - nx: 6
[17:46:45.201] - relay: TRUE
[17:46:45.201] - stdout: TRUE
[17:46:45.201] - signal: TRUE
[17:46:45.202] - resignal: FALSE
[17:46:45.202] - force: TRUE
[17:46:45.202] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.202] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.202]  - until=3
[17:46:45.202]  - relaying element #3
[17:46:45.202] result() for MulticoreFuture ...
[17:46:45.202] result() for MulticoreFuture ... done
[17:46:45.202] result() for MulticoreFuture ...
[17:46:45.203] result() for MulticoreFuture ... done
[17:46:45.203] result() for MulticoreFuture ...
[17:46:45.203] result() for MulticoreFuture ... done
[17:46:45.203] result() for MulticoreFuture ...
[17:46:45.203] result() for MulticoreFuture ... done
[17:46:45.203] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.203] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.203] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:45.204]  length: 3 (resolved future 3)
[17:46:45.204] signalConditionsASAP(NULL, pos=4) ...
[17:46:45.204] - nx: 6
[17:46:45.204] - relay: TRUE
[17:46:45.204] - stdout: TRUE
[17:46:45.204] - signal: TRUE
[17:46:45.204] - resignal: FALSE
[17:46:45.204] - force: TRUE
[17:46:45.204] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.204] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.204]  - until=5
[17:46:45.205]  - relaying element #5
[17:46:45.205] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.205] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.205] signalConditionsASAP(NULL, pos=4) ... done
[17:46:45.205]  length: 2 (resolved future 4)
[17:46:45.205] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.205] - nx: 6
[17:46:45.205] - relay: TRUE
[17:46:45.205] - stdout: TRUE
[17:46:45.205] - signal: TRUE
[17:46:45.206] - resignal: FALSE
[17:46:45.206] - force: TRUE
[17:46:45.206] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.206] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.206]  - until=6
[17:46:45.206]  - relaying element #6
[17:46:45.206] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.206] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.206] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.206]  length: 1 (resolved future 5)
[17:46:45.207] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.207] - nx: 6
[17:46:45.207] - relay: TRUE
[17:46:45.207] - stdout: TRUE
[17:46:45.207] - signal: TRUE
[17:46:45.207] - resignal: FALSE
[17:46:45.207] - force: TRUE
[17:46:45.207] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.207] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.207]  - until=6
[17:46:45.208] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.208] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.208] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.208]  length: 0 (resolved future 6)
[17:46:45.208] Relaying remaining futures
[17:46:45.208] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.208] - nx: 6
[17:46:45.208] - relay: TRUE
[17:46:45.208] - stdout: TRUE
[17:46:45.208] - signal: TRUE
[17:46:45.209] - resignal: FALSE
[17:46:45.209] - force: TRUE
[17:46:45.209] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:45.209] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.209] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.209] resolve() on list ... DONE
[17:46:45.209] result() for MulticoreFuture ...
[17:46:45.209] result() for MulticoreFuture ... done
[17:46:45.210] result() for MulticoreFuture ...
[17:46:45.210] result() for MulticoreFuture ... done
[17:46:45.210] result() for MulticoreFuture ...
[17:46:45.210] result() for MulticoreFuture ... done
[17:46:45.210] result() for MulticoreFuture ...
[17:46:45.210] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:46:45.212] getGlobalsAndPackages() ...
[17:46:45.213] Searching for globals...
[17:46:45.213] 
[17:46:45.213] Searching for globals ... DONE
[17:46:45.213] - globals: [0] <none>
[17:46:45.213] getGlobalsAndPackages() ... DONE
[17:46:45.214] run() for ‘Future’ ...
[17:46:45.214] - state: ‘created’
[17:46:45.214] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.219] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.219] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.220]   - Field: ‘label’
[17:46:45.220]   - Field: ‘local’
[17:46:45.220]   - Field: ‘owner’
[17:46:45.220]   - Field: ‘envir’
[17:46:45.220]   - Field: ‘workers’
[17:46:45.220]   - Field: ‘packages’
[17:46:45.220]   - Field: ‘gc’
[17:46:45.220]   - Field: ‘job’
[17:46:45.221]   - Field: ‘conditions’
[17:46:45.221]   - Field: ‘expr’
[17:46:45.221]   - Field: ‘uuid’
[17:46:45.221]   - Field: ‘seed’
[17:46:45.221]   - Field: ‘version’
[17:46:45.221]   - Field: ‘result’
[17:46:45.221]   - Field: ‘asynchronous’
[17:46:45.221]   - Field: ‘calls’
[17:46:45.221]   - Field: ‘globals’
[17:46:45.221]   - Field: ‘stdout’
[17:46:45.221]   - Field: ‘earlySignal’
[17:46:45.222]   - Field: ‘lazy’
[17:46:45.222]   - Field: ‘state’
[17:46:45.222] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.222] - Launch lazy future ...
[17:46:45.222] Packages needed by the future expression (n = 0): <none>
[17:46:45.222] Packages needed by future strategies (n = 0): <none>
[17:46:45.223] {
[17:46:45.223]     {
[17:46:45.223]         {
[17:46:45.223]             ...future.startTime <- base::Sys.time()
[17:46:45.223]             {
[17:46:45.223]                 {
[17:46:45.223]                   {
[17:46:45.223]                     {
[17:46:45.223]                       base::local({
[17:46:45.223]                         has_future <- base::requireNamespace("future", 
[17:46:45.223]                           quietly = TRUE)
[17:46:45.223]                         if (has_future) {
[17:46:45.223]                           ns <- base::getNamespace("future")
[17:46:45.223]                           version <- ns[[".package"]][["version"]]
[17:46:45.223]                           if (is.null(version)) 
[17:46:45.223]                             version <- utils::packageVersion("future")
[17:46:45.223]                         }
[17:46:45.223]                         else {
[17:46:45.223]                           version <- NULL
[17:46:45.223]                         }
[17:46:45.223]                         if (!has_future || version < "1.8.0") {
[17:46:45.223]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.223]                             "", base::R.version$version.string), 
[17:46:45.223]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.223]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.223]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.223]                               "release", "version")], collapse = " "), 
[17:46:45.223]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.223]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.223]                             info)
[17:46:45.223]                           info <- base::paste(info, collapse = "; ")
[17:46:45.223]                           if (!has_future) {
[17:46:45.223]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.223]                               info)
[17:46:45.223]                           }
[17:46:45.223]                           else {
[17:46:45.223]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.223]                               info, version)
[17:46:45.223]                           }
[17:46:45.223]                           base::stop(msg)
[17:46:45.223]                         }
[17:46:45.223]                       })
[17:46:45.223]                     }
[17:46:45.223]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.223]                     base::options(mc.cores = 1L)
[17:46:45.223]                   }
[17:46:45.223]                   ...future.strategy.old <- future::plan("list")
[17:46:45.223]                   options(future.plan = NULL)
[17:46:45.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.223]                 }
[17:46:45.223]                 ...future.workdir <- getwd()
[17:46:45.223]             }
[17:46:45.223]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.223]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.223]         }
[17:46:45.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.223]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.223]             base::names(...future.oldOptions))
[17:46:45.223]     }
[17:46:45.223]     if (FALSE) {
[17:46:45.223]     }
[17:46:45.223]     else {
[17:46:45.223]         if (TRUE) {
[17:46:45.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.223]                 open = "w")
[17:46:45.223]         }
[17:46:45.223]         else {
[17:46:45.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.223]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.223]         }
[17:46:45.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.223]             base::sink(type = "output", split = FALSE)
[17:46:45.223]             base::close(...future.stdout)
[17:46:45.223]         }, add = TRUE)
[17:46:45.223]     }
[17:46:45.223]     ...future.frame <- base::sys.nframe()
[17:46:45.223]     ...future.conditions <- base::list()
[17:46:45.223]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.223]     if (FALSE) {
[17:46:45.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.223]     }
[17:46:45.223]     ...future.result <- base::tryCatch({
[17:46:45.223]         base::withCallingHandlers({
[17:46:45.223]             ...future.value <- base::withVisible(base::local({
[17:46:45.223]                 withCallingHandlers({
[17:46:45.223]                   2
[17:46:45.223]                 }, immediateCondition = function(cond) {
[17:46:45.223]                   save_rds <- function (object, pathname, ...) 
[17:46:45.223]                   {
[17:46:45.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.223]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.223]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.223]                         fi_tmp[["mtime"]])
[17:46:45.223]                     }
[17:46:45.223]                     tryCatch({
[17:46:45.223]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.223]                     }, error = function(ex) {
[17:46:45.223]                       msg <- conditionMessage(ex)
[17:46:45.223]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.223]                         fi_tmp[["mtime"]], msg)
[17:46:45.223]                       ex$message <- msg
[17:46:45.223]                       stop(ex)
[17:46:45.223]                     })
[17:46:45.223]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.223]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.223]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.223]                       fi <- file.info(pathname)
[17:46:45.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.223]                         fi[["size"]], fi[["mtime"]])
[17:46:45.223]                       stop(msg)
[17:46:45.223]                     }
[17:46:45.223]                     invisible(pathname)
[17:46:45.223]                   }
[17:46:45.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.223]                     rootPath = tempdir()) 
[17:46:45.223]                   {
[17:46:45.223]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.223]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.223]                       tmpdir = path, fileext = ".rds")
[17:46:45.223]                     save_rds(obj, file)
[17:46:45.223]                   }
[17:46:45.223]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.223]                   {
[17:46:45.223]                     inherits <- base::inherits
[17:46:45.223]                     invokeRestart <- base::invokeRestart
[17:46:45.223]                     is.null <- base::is.null
[17:46:45.223]                     muffled <- FALSE
[17:46:45.223]                     if (inherits(cond, "message")) {
[17:46:45.223]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.223]                       if (muffled) 
[17:46:45.223]                         invokeRestart("muffleMessage")
[17:46:45.223]                     }
[17:46:45.223]                     else if (inherits(cond, "warning")) {
[17:46:45.223]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.223]                       if (muffled) 
[17:46:45.223]                         invokeRestart("muffleWarning")
[17:46:45.223]                     }
[17:46:45.223]                     else if (inherits(cond, "condition")) {
[17:46:45.223]                       if (!is.null(pattern)) {
[17:46:45.223]                         computeRestarts <- base::computeRestarts
[17:46:45.223]                         grepl <- base::grepl
[17:46:45.223]                         restarts <- computeRestarts(cond)
[17:46:45.223]                         for (restart in restarts) {
[17:46:45.223]                           name <- restart$name
[17:46:45.223]                           if (is.null(name)) 
[17:46:45.223]                             next
[17:46:45.223]                           if (!grepl(pattern, name)) 
[17:46:45.223]                             next
[17:46:45.223]                           invokeRestart(restart)
[17:46:45.223]                           muffled <- TRUE
[17:46:45.223]                           break
[17:46:45.223]                         }
[17:46:45.223]                       }
[17:46:45.223]                     }
[17:46:45.223]                     invisible(muffled)
[17:46:45.223]                   }
[17:46:45.223]                   muffleCondition(cond)
[17:46:45.223]                 })
[17:46:45.223]             }))
[17:46:45.223]             future::FutureResult(value = ...future.value$value, 
[17:46:45.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.223]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.223]                     ...future.globalenv.names))
[17:46:45.223]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.223]         }, condition = base::local({
[17:46:45.223]             c <- base::c
[17:46:45.223]             inherits <- base::inherits
[17:46:45.223]             invokeRestart <- base::invokeRestart
[17:46:45.223]             length <- base::length
[17:46:45.223]             list <- base::list
[17:46:45.223]             seq.int <- base::seq.int
[17:46:45.223]             signalCondition <- base::signalCondition
[17:46:45.223]             sys.calls <- base::sys.calls
[17:46:45.223]             `[[` <- base::`[[`
[17:46:45.223]             `+` <- base::`+`
[17:46:45.223]             `<<-` <- base::`<<-`
[17:46:45.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.223]                   3L)]
[17:46:45.223]             }
[17:46:45.223]             function(cond) {
[17:46:45.223]                 is_error <- inherits(cond, "error")
[17:46:45.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.223]                   NULL)
[17:46:45.223]                 if (is_error) {
[17:46:45.223]                   sessionInformation <- function() {
[17:46:45.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.223]                       search = base::search(), system = base::Sys.info())
[17:46:45.223]                   }
[17:46:45.223]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.223]                     cond$call), session = sessionInformation(), 
[17:46:45.223]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.223]                   signalCondition(cond)
[17:46:45.223]                 }
[17:46:45.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.223]                 "immediateCondition"))) {
[17:46:45.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.223]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.223]                   if (TRUE && !signal) {
[17:46:45.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.223]                     {
[17:46:45.223]                       inherits <- base::inherits
[17:46:45.223]                       invokeRestart <- base::invokeRestart
[17:46:45.223]                       is.null <- base::is.null
[17:46:45.223]                       muffled <- FALSE
[17:46:45.223]                       if (inherits(cond, "message")) {
[17:46:45.223]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.223]                         if (muffled) 
[17:46:45.223]                           invokeRestart("muffleMessage")
[17:46:45.223]                       }
[17:46:45.223]                       else if (inherits(cond, "warning")) {
[17:46:45.223]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.223]                         if (muffled) 
[17:46:45.223]                           invokeRestart("muffleWarning")
[17:46:45.223]                       }
[17:46:45.223]                       else if (inherits(cond, "condition")) {
[17:46:45.223]                         if (!is.null(pattern)) {
[17:46:45.223]                           computeRestarts <- base::computeRestarts
[17:46:45.223]                           grepl <- base::grepl
[17:46:45.223]                           restarts <- computeRestarts(cond)
[17:46:45.223]                           for (restart in restarts) {
[17:46:45.223]                             name <- restart$name
[17:46:45.223]                             if (is.null(name)) 
[17:46:45.223]                               next
[17:46:45.223]                             if (!grepl(pattern, name)) 
[17:46:45.223]                               next
[17:46:45.223]                             invokeRestart(restart)
[17:46:45.223]                             muffled <- TRUE
[17:46:45.223]                             break
[17:46:45.223]                           }
[17:46:45.223]                         }
[17:46:45.223]                       }
[17:46:45.223]                       invisible(muffled)
[17:46:45.223]                     }
[17:46:45.223]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.223]                   }
[17:46:45.223]                 }
[17:46:45.223]                 else {
[17:46:45.223]                   if (TRUE) {
[17:46:45.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.223]                     {
[17:46:45.223]                       inherits <- base::inherits
[17:46:45.223]                       invokeRestart <- base::invokeRestart
[17:46:45.223]                       is.null <- base::is.null
[17:46:45.223]                       muffled <- FALSE
[17:46:45.223]                       if (inherits(cond, "message")) {
[17:46:45.223]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.223]                         if (muffled) 
[17:46:45.223]                           invokeRestart("muffleMessage")
[17:46:45.223]                       }
[17:46:45.223]                       else if (inherits(cond, "warning")) {
[17:46:45.223]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.223]                         if (muffled) 
[17:46:45.223]                           invokeRestart("muffleWarning")
[17:46:45.223]                       }
[17:46:45.223]                       else if (inherits(cond, "condition")) {
[17:46:45.223]                         if (!is.null(pattern)) {
[17:46:45.223]                           computeRestarts <- base::computeRestarts
[17:46:45.223]                           grepl <- base::grepl
[17:46:45.223]                           restarts <- computeRestarts(cond)
[17:46:45.223]                           for (restart in restarts) {
[17:46:45.223]                             name <- restart$name
[17:46:45.223]                             if (is.null(name)) 
[17:46:45.223]                               next
[17:46:45.223]                             if (!grepl(pattern, name)) 
[17:46:45.223]                               next
[17:46:45.223]                             invokeRestart(restart)
[17:46:45.223]                             muffled <- TRUE
[17:46:45.223]                             break
[17:46:45.223]                           }
[17:46:45.223]                         }
[17:46:45.223]                       }
[17:46:45.223]                       invisible(muffled)
[17:46:45.223]                     }
[17:46:45.223]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.223]                   }
[17:46:45.223]                 }
[17:46:45.223]             }
[17:46:45.223]         }))
[17:46:45.223]     }, error = function(ex) {
[17:46:45.223]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.223]                 ...future.rng), started = ...future.startTime, 
[17:46:45.223]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.223]             version = "1.8"), class = "FutureResult")
[17:46:45.223]     }, finally = {
[17:46:45.223]         if (!identical(...future.workdir, getwd())) 
[17:46:45.223]             setwd(...future.workdir)
[17:46:45.223]         {
[17:46:45.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.223]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.223]             }
[17:46:45.223]             base::options(...future.oldOptions)
[17:46:45.223]             if (.Platform$OS.type == "windows") {
[17:46:45.223]                 old_names <- names(...future.oldEnvVars)
[17:46:45.223]                 envs <- base::Sys.getenv()
[17:46:45.223]                 names <- names(envs)
[17:46:45.223]                 common <- intersect(names, old_names)
[17:46:45.223]                 added <- setdiff(names, old_names)
[17:46:45.223]                 removed <- setdiff(old_names, names)
[17:46:45.223]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.223]                   envs[common]]
[17:46:45.223]                 NAMES <- toupper(changed)
[17:46:45.223]                 args <- list()
[17:46:45.223]                 for (kk in seq_along(NAMES)) {
[17:46:45.223]                   name <- changed[[kk]]
[17:46:45.223]                   NAME <- NAMES[[kk]]
[17:46:45.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.223]                     next
[17:46:45.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.223]                 }
[17:46:45.223]                 NAMES <- toupper(added)
[17:46:45.223]                 for (kk in seq_along(NAMES)) {
[17:46:45.223]                   name <- added[[kk]]
[17:46:45.223]                   NAME <- NAMES[[kk]]
[17:46:45.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.223]                     next
[17:46:45.223]                   args[[name]] <- ""
[17:46:45.223]                 }
[17:46:45.223]                 NAMES <- toupper(removed)
[17:46:45.223]                 for (kk in seq_along(NAMES)) {
[17:46:45.223]                   name <- removed[[kk]]
[17:46:45.223]                   NAME <- NAMES[[kk]]
[17:46:45.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.223]                     next
[17:46:45.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.223]                 }
[17:46:45.223]                 if (length(args) > 0) 
[17:46:45.223]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.223]             }
[17:46:45.223]             else {
[17:46:45.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.223]             }
[17:46:45.223]             {
[17:46:45.223]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.223]                   0L) {
[17:46:45.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.223]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.223]                   base::options(opts)
[17:46:45.223]                 }
[17:46:45.223]                 {
[17:46:45.223]                   {
[17:46:45.223]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.223]                     NULL
[17:46:45.223]                   }
[17:46:45.223]                   options(future.plan = NULL)
[17:46:45.223]                   if (is.na(NA_character_)) 
[17:46:45.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.223]                     .init = FALSE)
[17:46:45.223]                 }
[17:46:45.223]             }
[17:46:45.223]         }
[17:46:45.223]     })
[17:46:45.223]     if (TRUE) {
[17:46:45.223]         base::sink(type = "output", split = FALSE)
[17:46:45.223]         if (TRUE) {
[17:46:45.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.223]         }
[17:46:45.223]         else {
[17:46:45.223]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.223]         }
[17:46:45.223]         base::close(...future.stdout)
[17:46:45.223]         ...future.stdout <- NULL
[17:46:45.223]     }
[17:46:45.223]     ...future.result$conditions <- ...future.conditions
[17:46:45.223]     ...future.result$finished <- base::Sys.time()
[17:46:45.223]     ...future.result
[17:46:45.223] }
[17:46:45.225] requestCore(): workers = 2
[17:46:45.227] MulticoreFuture started
[17:46:45.227] - Launch lazy future ... done
[17:46:45.227] run() for ‘MulticoreFuture’ ... done
[17:46:45.228] getGlobalsAndPackages() ...
[17:46:45.228] plan(): Setting new future strategy stack:
[17:46:45.228] Searching for globals...
[17:46:45.228] List of future strategies:
[17:46:45.228] 1. sequential:
[17:46:45.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.228]    - tweaked: FALSE
[17:46:45.228]    - call: NULL
[17:46:45.229] 
[17:46:45.229] Searching for globals ... DONE
[17:46:45.229] plan(): nbrOfWorkers() = 1
[17:46:45.229] - globals: [0] <none>
[17:46:45.230] getGlobalsAndPackages() ... DONE
[17:46:45.230] run() for ‘Future’ ...
[17:46:45.230] - state: ‘created’
[17:46:45.231] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.231] plan(): Setting new future strategy stack:
[17:46:45.231] List of future strategies:
[17:46:45.231] 1. multicore:
[17:46:45.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.231]    - tweaked: FALSE
[17:46:45.231]    - call: plan(strategy)
[17:46:45.236] plan(): nbrOfWorkers() = 2
[17:46:45.236] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.236]   - Field: ‘label’
[17:46:45.237]   - Field: ‘local’
[17:46:45.237]   - Field: ‘owner’
[17:46:45.237]   - Field: ‘envir’
[17:46:45.237]   - Field: ‘workers’
[17:46:45.237]   - Field: ‘packages’
[17:46:45.237]   - Field: ‘gc’
[17:46:45.238]   - Field: ‘job’
[17:46:45.238]   - Field: ‘conditions’
[17:46:45.238]   - Field: ‘expr’
[17:46:45.238]   - Field: ‘uuid’
[17:46:45.238]   - Field: ‘seed’
[17:46:45.238]   - Field: ‘version’
[17:46:45.239]   - Field: ‘result’
[17:46:45.239]   - Field: ‘asynchronous’
[17:46:45.239]   - Field: ‘calls’
[17:46:45.239]   - Field: ‘globals’
[17:46:45.239]   - Field: ‘stdout’
[17:46:45.239]   - Field: ‘earlySignal’
[17:46:45.239]   - Field: ‘lazy’
[17:46:45.240]   - Field: ‘state’
[17:46:45.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.240] - Launch lazy future ...
[17:46:45.240] Packages needed by the future expression (n = 0): <none>
[17:46:45.241] Packages needed by future strategies (n = 0): <none>
[17:46:45.241] {
[17:46:45.241]     {
[17:46:45.241]         {
[17:46:45.241]             ...future.startTime <- base::Sys.time()
[17:46:45.241]             {
[17:46:45.241]                 {
[17:46:45.241]                   {
[17:46:45.241]                     {
[17:46:45.241]                       base::local({
[17:46:45.241]                         has_future <- base::requireNamespace("future", 
[17:46:45.241]                           quietly = TRUE)
[17:46:45.241]                         if (has_future) {
[17:46:45.241]                           ns <- base::getNamespace("future")
[17:46:45.241]                           version <- ns[[".package"]][["version"]]
[17:46:45.241]                           if (is.null(version)) 
[17:46:45.241]                             version <- utils::packageVersion("future")
[17:46:45.241]                         }
[17:46:45.241]                         else {
[17:46:45.241]                           version <- NULL
[17:46:45.241]                         }
[17:46:45.241]                         if (!has_future || version < "1.8.0") {
[17:46:45.241]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.241]                             "", base::R.version$version.string), 
[17:46:45.241]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.241]                               "release", "version")], collapse = " "), 
[17:46:45.241]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.241]                             info)
[17:46:45.241]                           info <- base::paste(info, collapse = "; ")
[17:46:45.241]                           if (!has_future) {
[17:46:45.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.241]                               info)
[17:46:45.241]                           }
[17:46:45.241]                           else {
[17:46:45.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.241]                               info, version)
[17:46:45.241]                           }
[17:46:45.241]                           base::stop(msg)
[17:46:45.241]                         }
[17:46:45.241]                       })
[17:46:45.241]                     }
[17:46:45.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.241]                     base::options(mc.cores = 1L)
[17:46:45.241]                   }
[17:46:45.241]                   ...future.strategy.old <- future::plan("list")
[17:46:45.241]                   options(future.plan = NULL)
[17:46:45.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.241]                 }
[17:46:45.241]                 ...future.workdir <- getwd()
[17:46:45.241]             }
[17:46:45.241]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.241]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.241]         }
[17:46:45.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.241]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.241]             base::names(...future.oldOptions))
[17:46:45.241]     }
[17:46:45.241]     if (FALSE) {
[17:46:45.241]     }
[17:46:45.241]     else {
[17:46:45.241]         if (TRUE) {
[17:46:45.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.241]                 open = "w")
[17:46:45.241]         }
[17:46:45.241]         else {
[17:46:45.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.241]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.241]         }
[17:46:45.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.241]             base::sink(type = "output", split = FALSE)
[17:46:45.241]             base::close(...future.stdout)
[17:46:45.241]         }, add = TRUE)
[17:46:45.241]     }
[17:46:45.241]     ...future.frame <- base::sys.nframe()
[17:46:45.241]     ...future.conditions <- base::list()
[17:46:45.241]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.241]     if (FALSE) {
[17:46:45.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.241]     }
[17:46:45.241]     ...future.result <- base::tryCatch({
[17:46:45.241]         base::withCallingHandlers({
[17:46:45.241]             ...future.value <- base::withVisible(base::local({
[17:46:45.241]                 withCallingHandlers({
[17:46:45.241]                   NULL
[17:46:45.241]                 }, immediateCondition = function(cond) {
[17:46:45.241]                   save_rds <- function (object, pathname, ...) 
[17:46:45.241]                   {
[17:46:45.241]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.241]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.241]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.241]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.241]                         fi_tmp[["mtime"]])
[17:46:45.241]                     }
[17:46:45.241]                     tryCatch({
[17:46:45.241]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.241]                     }, error = function(ex) {
[17:46:45.241]                       msg <- conditionMessage(ex)
[17:46:45.241]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.241]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.241]                         fi_tmp[["mtime"]], msg)
[17:46:45.241]                       ex$message <- msg
[17:46:45.241]                       stop(ex)
[17:46:45.241]                     })
[17:46:45.241]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.241]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.241]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.241]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.241]                       fi <- file.info(pathname)
[17:46:45.241]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.241]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.241]                         fi[["size"]], fi[["mtime"]])
[17:46:45.241]                       stop(msg)
[17:46:45.241]                     }
[17:46:45.241]                     invisible(pathname)
[17:46:45.241]                   }
[17:46:45.241]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.241]                     rootPath = tempdir()) 
[17:46:45.241]                   {
[17:46:45.241]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.241]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.241]                       tmpdir = path, fileext = ".rds")
[17:46:45.241]                     save_rds(obj, file)
[17:46:45.241]                   }
[17:46:45.241]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.241]                   {
[17:46:45.241]                     inherits <- base::inherits
[17:46:45.241]                     invokeRestart <- base::invokeRestart
[17:46:45.241]                     is.null <- base::is.null
[17:46:45.241]                     muffled <- FALSE
[17:46:45.241]                     if (inherits(cond, "message")) {
[17:46:45.241]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.241]                       if (muffled) 
[17:46:45.241]                         invokeRestart("muffleMessage")
[17:46:45.241]                     }
[17:46:45.241]                     else if (inherits(cond, "warning")) {
[17:46:45.241]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.241]                       if (muffled) 
[17:46:45.241]                         invokeRestart("muffleWarning")
[17:46:45.241]                     }
[17:46:45.241]                     else if (inherits(cond, "condition")) {
[17:46:45.241]                       if (!is.null(pattern)) {
[17:46:45.241]                         computeRestarts <- base::computeRestarts
[17:46:45.241]                         grepl <- base::grepl
[17:46:45.241]                         restarts <- computeRestarts(cond)
[17:46:45.241]                         for (restart in restarts) {
[17:46:45.241]                           name <- restart$name
[17:46:45.241]                           if (is.null(name)) 
[17:46:45.241]                             next
[17:46:45.241]                           if (!grepl(pattern, name)) 
[17:46:45.241]                             next
[17:46:45.241]                           invokeRestart(restart)
[17:46:45.241]                           muffled <- TRUE
[17:46:45.241]                           break
[17:46:45.241]                         }
[17:46:45.241]                       }
[17:46:45.241]                     }
[17:46:45.241]                     invisible(muffled)
[17:46:45.241]                   }
[17:46:45.241]                   muffleCondition(cond)
[17:46:45.241]                 })
[17:46:45.241]             }))
[17:46:45.241]             future::FutureResult(value = ...future.value$value, 
[17:46:45.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.241]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.241]                     ...future.globalenv.names))
[17:46:45.241]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.241]         }, condition = base::local({
[17:46:45.241]             c <- base::c
[17:46:45.241]             inherits <- base::inherits
[17:46:45.241]             invokeRestart <- base::invokeRestart
[17:46:45.241]             length <- base::length
[17:46:45.241]             list <- base::list
[17:46:45.241]             seq.int <- base::seq.int
[17:46:45.241]             signalCondition <- base::signalCondition
[17:46:45.241]             sys.calls <- base::sys.calls
[17:46:45.241]             `[[` <- base::`[[`
[17:46:45.241]             `+` <- base::`+`
[17:46:45.241]             `<<-` <- base::`<<-`
[17:46:45.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.241]                   3L)]
[17:46:45.241]             }
[17:46:45.241]             function(cond) {
[17:46:45.241]                 is_error <- inherits(cond, "error")
[17:46:45.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.241]                   NULL)
[17:46:45.241]                 if (is_error) {
[17:46:45.241]                   sessionInformation <- function() {
[17:46:45.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.241]                       search = base::search(), system = base::Sys.info())
[17:46:45.241]                   }
[17:46:45.241]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.241]                     cond$call), session = sessionInformation(), 
[17:46:45.241]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.241]                   signalCondition(cond)
[17:46:45.241]                 }
[17:46:45.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.241]                 "immediateCondition"))) {
[17:46:45.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.241]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.241]                   if (TRUE && !signal) {
[17:46:45.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.241]                     {
[17:46:45.241]                       inherits <- base::inherits
[17:46:45.241]                       invokeRestart <- base::invokeRestart
[17:46:45.241]                       is.null <- base::is.null
[17:46:45.241]                       muffled <- FALSE
[17:46:45.241]                       if (inherits(cond, "message")) {
[17:46:45.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.241]                         if (muffled) 
[17:46:45.241]                           invokeRestart("muffleMessage")
[17:46:45.241]                       }
[17:46:45.241]                       else if (inherits(cond, "warning")) {
[17:46:45.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.241]                         if (muffled) 
[17:46:45.241]                           invokeRestart("muffleWarning")
[17:46:45.241]                       }
[17:46:45.241]                       else if (inherits(cond, "condition")) {
[17:46:45.241]                         if (!is.null(pattern)) {
[17:46:45.241]                           computeRestarts <- base::computeRestarts
[17:46:45.241]                           grepl <- base::grepl
[17:46:45.241]                           restarts <- computeRestarts(cond)
[17:46:45.241]                           for (restart in restarts) {
[17:46:45.241]                             name <- restart$name
[17:46:45.241]                             if (is.null(name)) 
[17:46:45.241]                               next
[17:46:45.241]                             if (!grepl(pattern, name)) 
[17:46:45.241]                               next
[17:46:45.241]                             invokeRestart(restart)
[17:46:45.241]                             muffled <- TRUE
[17:46:45.241]                             break
[17:46:45.241]                           }
[17:46:45.241]                         }
[17:46:45.241]                       }
[17:46:45.241]                       invisible(muffled)
[17:46:45.241]                     }
[17:46:45.241]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.241]                   }
[17:46:45.241]                 }
[17:46:45.241]                 else {
[17:46:45.241]                   if (TRUE) {
[17:46:45.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.241]                     {
[17:46:45.241]                       inherits <- base::inherits
[17:46:45.241]                       invokeRestart <- base::invokeRestart
[17:46:45.241]                       is.null <- base::is.null
[17:46:45.241]                       muffled <- FALSE
[17:46:45.241]                       if (inherits(cond, "message")) {
[17:46:45.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.241]                         if (muffled) 
[17:46:45.241]                           invokeRestart("muffleMessage")
[17:46:45.241]                       }
[17:46:45.241]                       else if (inherits(cond, "warning")) {
[17:46:45.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.241]                         if (muffled) 
[17:46:45.241]                           invokeRestart("muffleWarning")
[17:46:45.241]                       }
[17:46:45.241]                       else if (inherits(cond, "condition")) {
[17:46:45.241]                         if (!is.null(pattern)) {
[17:46:45.241]                           computeRestarts <- base::computeRestarts
[17:46:45.241]                           grepl <- base::grepl
[17:46:45.241]                           restarts <- computeRestarts(cond)
[17:46:45.241]                           for (restart in restarts) {
[17:46:45.241]                             name <- restart$name
[17:46:45.241]                             if (is.null(name)) 
[17:46:45.241]                               next
[17:46:45.241]                             if (!grepl(pattern, name)) 
[17:46:45.241]                               next
[17:46:45.241]                             invokeRestart(restart)
[17:46:45.241]                             muffled <- TRUE
[17:46:45.241]                             break
[17:46:45.241]                           }
[17:46:45.241]                         }
[17:46:45.241]                       }
[17:46:45.241]                       invisible(muffled)
[17:46:45.241]                     }
[17:46:45.241]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.241]                   }
[17:46:45.241]                 }
[17:46:45.241]             }
[17:46:45.241]         }))
[17:46:45.241]     }, error = function(ex) {
[17:46:45.241]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.241]                 ...future.rng), started = ...future.startTime, 
[17:46:45.241]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.241]             version = "1.8"), class = "FutureResult")
[17:46:45.241]     }, finally = {
[17:46:45.241]         if (!identical(...future.workdir, getwd())) 
[17:46:45.241]             setwd(...future.workdir)
[17:46:45.241]         {
[17:46:45.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.241]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.241]             }
[17:46:45.241]             base::options(...future.oldOptions)
[17:46:45.241]             if (.Platform$OS.type == "windows") {
[17:46:45.241]                 old_names <- names(...future.oldEnvVars)
[17:46:45.241]                 envs <- base::Sys.getenv()
[17:46:45.241]                 names <- names(envs)
[17:46:45.241]                 common <- intersect(names, old_names)
[17:46:45.241]                 added <- setdiff(names, old_names)
[17:46:45.241]                 removed <- setdiff(old_names, names)
[17:46:45.241]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.241]                   envs[common]]
[17:46:45.241]                 NAMES <- toupper(changed)
[17:46:45.241]                 args <- list()
[17:46:45.241]                 for (kk in seq_along(NAMES)) {
[17:46:45.241]                   name <- changed[[kk]]
[17:46:45.241]                   NAME <- NAMES[[kk]]
[17:46:45.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.241]                     next
[17:46:45.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.241]                 }
[17:46:45.241]                 NAMES <- toupper(added)
[17:46:45.241]                 for (kk in seq_along(NAMES)) {
[17:46:45.241]                   name <- added[[kk]]
[17:46:45.241]                   NAME <- NAMES[[kk]]
[17:46:45.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.241]                     next
[17:46:45.241]                   args[[name]] <- ""
[17:46:45.241]                 }
[17:46:45.241]                 NAMES <- toupper(removed)
[17:46:45.241]                 for (kk in seq_along(NAMES)) {
[17:46:45.241]                   name <- removed[[kk]]
[17:46:45.241]                   NAME <- NAMES[[kk]]
[17:46:45.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.241]                     next
[17:46:45.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.241]                 }
[17:46:45.241]                 if (length(args) > 0) 
[17:46:45.241]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.241]             }
[17:46:45.241]             else {
[17:46:45.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.241]             }
[17:46:45.241]             {
[17:46:45.241]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.241]                   0L) {
[17:46:45.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.241]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.241]                   base::options(opts)
[17:46:45.241]                 }
[17:46:45.241]                 {
[17:46:45.241]                   {
[17:46:45.241]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.241]                     NULL
[17:46:45.241]                   }
[17:46:45.241]                   options(future.plan = NULL)
[17:46:45.241]                   if (is.na(NA_character_)) 
[17:46:45.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.241]                     .init = FALSE)
[17:46:45.241]                 }
[17:46:45.241]             }
[17:46:45.241]         }
[17:46:45.241]     })
[17:46:45.241]     if (TRUE) {
[17:46:45.241]         base::sink(type = "output", split = FALSE)
[17:46:45.241]         if (TRUE) {
[17:46:45.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.241]         }
[17:46:45.241]         else {
[17:46:45.241]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.241]         }
[17:46:45.241]         base::close(...future.stdout)
[17:46:45.241]         ...future.stdout <- NULL
[17:46:45.241]     }
[17:46:45.241]     ...future.result$conditions <- ...future.conditions
[17:46:45.241]     ...future.result$finished <- base::Sys.time()
[17:46:45.241]     ...future.result
[17:46:45.241] }
[17:46:45.245] requestCore(): workers = 2
[17:46:45.247] MulticoreFuture started
[17:46:45.247] - Launch lazy future ... done
[17:46:45.247] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[17:46:45.248] plan(): Setting new future strategy stack:
 num 1
 $ b:[17:46:45.248] List of future strategies:
[17:46:45.248] 1. sequential:
[17:46:45.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.248]    - tweaked: FALSE
[17:46:45.248]    - call: NULL
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561788213a40> 
 $ c:[17:46:45.249] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561785c3f760> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[17:46:45.251] plan(): Setting new future strategy stack:
 num 1
 $ b:[17:46:45.251] List of future strategies:
[17:46:45.251] 1. multicore:
[17:46:45.251]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.251]    - tweaked: FALSE
[17:46:45.251]    - call: plan(strategy)
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561788213a40> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561785c3f760> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:46:45.256] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:45.259] resolve() on list ...
[17:46:45.259]  recursive: 0
[17:46:45.259]  length: 6
[17:46:45.259]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:45.260] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.260] - nx: 6
[17:46:45.260] - relay: TRUE
[17:46:45.260] - stdout: TRUE
[17:46:45.260] - signal: TRUE
[17:46:45.260] - resignal: FALSE
[17:46:45.260] - force: TRUE
[17:46:45.260] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.261] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.261]  - until=2
[17:46:45.261]  - relaying element #2
[17:46:45.261] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.261] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.261] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.262]  length: 5 (resolved future 1)
[17:46:45.262] Future #2
[17:46:45.262] result() for MulticoreFuture ...
[17:46:45.263] result() for MulticoreFuture ...
[17:46:45.263] result() for MulticoreFuture ... done
[17:46:45.263] result() for MulticoreFuture ... done
[17:46:45.263] result() for MulticoreFuture ...
[17:46:45.264] result() for MulticoreFuture ... done
[17:46:45.264] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:45.264] - nx: 6
[17:46:45.264] - relay: TRUE
[17:46:45.264] - stdout: TRUE
[17:46:45.264] - signal: TRUE
[17:46:45.264] - resignal: FALSE
[17:46:45.264] - force: TRUE
[17:46:45.265] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.265] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.265]  - until=2
[17:46:45.265]  - relaying element #2
[17:46:45.265] result() for MulticoreFuture ...
[17:46:45.265] result() for MulticoreFuture ... done
[17:46:45.265] result() for MulticoreFuture ...
[17:46:45.266] result() for MulticoreFuture ... done
[17:46:45.266] result() for MulticoreFuture ...
[17:46:45.266] result() for MulticoreFuture ... done
[17:46:45.266] result() for MulticoreFuture ...
[17:46:45.266] result() for MulticoreFuture ... done
[17:46:45.266] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.266] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.266] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:45.267]  length: 4 (resolved future 2)
[17:46:45.267] Future #3
[17:46:45.267] result() for MulticoreFuture ...
[17:46:45.268] result() for MulticoreFuture ...
[17:46:45.268] result() for MulticoreFuture ... done
[17:46:45.268] result() for MulticoreFuture ... done
[17:46:45.268] result() for MulticoreFuture ...
[17:46:45.268] result() for MulticoreFuture ... done
[17:46:45.268] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:45.269] - nx: 6
[17:46:45.269] - relay: TRUE
[17:46:45.269] - stdout: TRUE
[17:46:45.269] - signal: TRUE
[17:46:45.269] - resignal: FALSE
[17:46:45.269] - force: TRUE
[17:46:45.269] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.269] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.270]  - until=3
[17:46:45.270]  - relaying element #3
[17:46:45.270] result() for MulticoreFuture ...
[17:46:45.270] result() for MulticoreFuture ... done
[17:46:45.270] result() for MulticoreFuture ...
[17:46:45.270] result() for MulticoreFuture ... done
[17:46:45.270] result() for MulticoreFuture ...
[17:46:45.270] result() for MulticoreFuture ... done
[17:46:45.273] result() for MulticoreFuture ...
[17:46:45.273] result() for MulticoreFuture ... done
[17:46:45.273] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.273] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.274] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:45.274]  length: 3 (resolved future 3)
[17:46:45.274] signalConditionsASAP(NULL, pos=4) ...
[17:46:45.274] - nx: 6
[17:46:45.274] - relay: TRUE
[17:46:45.274] - stdout: TRUE
[17:46:45.275] - signal: TRUE
[17:46:45.275] - resignal: FALSE
[17:46:45.275] - force: TRUE
[17:46:45.275] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.275] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.275]  - until=5
[17:46:45.275]  - relaying element #5
[17:46:45.276] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.276] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.276] signalConditionsASAP(NULL, pos=4) ... done
[17:46:45.276]  length: 2 (resolved future 4)
[17:46:45.276] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.276] - nx: 6
[17:46:45.276] - relay: TRUE
[17:46:45.276] - stdout: TRUE
[17:46:45.276] - signal: TRUE
[17:46:45.277] - resignal: FALSE
[17:46:45.277] - force: TRUE
[17:46:45.277] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.277] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.277]  - until=6
[17:46:45.277]  - relaying element #6
[17:46:45.277] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.277] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.277] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.278]  length: 1 (resolved future 5)
[17:46:45.278] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.278] - nx: 6
[17:46:45.278] - relay: TRUE
[17:46:45.278] - stdout: TRUE
[17:46:45.278] - signal: TRUE
[17:46:45.278] - resignal: FALSE
[17:46:45.278] - force: TRUE
[17:46:45.278] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.278] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.279]  - until=6
[17:46:45.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.279] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.279] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.279]  length: 0 (resolved future 6)
[17:46:45.279] Relaying remaining futures
[17:46:45.279] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.279] - nx: 6
[17:46:45.279] - relay: TRUE
[17:46:45.280] - stdout: TRUE
[17:46:45.280] - signal: TRUE
[17:46:45.280] - resignal: FALSE
[17:46:45.280] - force: TRUE
[17:46:45.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.280] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:45.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.280] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.281] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.281] resolve() on list ... DONE
[17:46:45.281] result() for MulticoreFuture ...
[17:46:45.281] result() for MulticoreFuture ... done
[17:46:45.281] result() for MulticoreFuture ...
[17:46:45.281] result() for MulticoreFuture ... done
[17:46:45.281] result() for MulticoreFuture ...
[17:46:45.281] result() for MulticoreFuture ... done
[17:46:45.281] result() for MulticoreFuture ...
[17:46:45.281] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:46:45.285] getGlobalsAndPackages() ...
[17:46:45.285] Searching for globals...
[17:46:45.285] 
[17:46:45.286] Searching for globals ... DONE
[17:46:45.286] - globals: [0] <none>
[17:46:45.286] getGlobalsAndPackages() ... DONE
[17:46:45.286] run() for ‘Future’ ...
[17:46:45.286] - state: ‘created’
[17:46:45.286] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.290]   - Field: ‘label’
[17:46:45.291]   - Field: ‘local’
[17:46:45.291]   - Field: ‘owner’
[17:46:45.291]   - Field: ‘envir’
[17:46:45.291]   - Field: ‘workers’
[17:46:45.291]   - Field: ‘packages’
[17:46:45.291]   - Field: ‘gc’
[17:46:45.291]   - Field: ‘job’
[17:46:45.291]   - Field: ‘conditions’
[17:46:45.291]   - Field: ‘expr’
[17:46:45.291]   - Field: ‘uuid’
[17:46:45.292]   - Field: ‘seed’
[17:46:45.292]   - Field: ‘version’
[17:46:45.292]   - Field: ‘result’
[17:46:45.292]   - Field: ‘asynchronous’
[17:46:45.292]   - Field: ‘calls’
[17:46:45.292]   - Field: ‘globals’
[17:46:45.292]   - Field: ‘stdout’
[17:46:45.292]   - Field: ‘earlySignal’
[17:46:45.292]   - Field: ‘lazy’
[17:46:45.292]   - Field: ‘state’
[17:46:45.292] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.293] - Launch lazy future ...
[17:46:45.293] Packages needed by the future expression (n = 0): <none>
[17:46:45.293] Packages needed by future strategies (n = 0): <none>
[17:46:45.293] {
[17:46:45.293]     {
[17:46:45.293]         {
[17:46:45.293]             ...future.startTime <- base::Sys.time()
[17:46:45.293]             {
[17:46:45.293]                 {
[17:46:45.293]                   {
[17:46:45.293]                     {
[17:46:45.293]                       base::local({
[17:46:45.293]                         has_future <- base::requireNamespace("future", 
[17:46:45.293]                           quietly = TRUE)
[17:46:45.293]                         if (has_future) {
[17:46:45.293]                           ns <- base::getNamespace("future")
[17:46:45.293]                           version <- ns[[".package"]][["version"]]
[17:46:45.293]                           if (is.null(version)) 
[17:46:45.293]                             version <- utils::packageVersion("future")
[17:46:45.293]                         }
[17:46:45.293]                         else {
[17:46:45.293]                           version <- NULL
[17:46:45.293]                         }
[17:46:45.293]                         if (!has_future || version < "1.8.0") {
[17:46:45.293]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.293]                             "", base::R.version$version.string), 
[17:46:45.293]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.293]                               "release", "version")], collapse = " "), 
[17:46:45.293]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.293]                             info)
[17:46:45.293]                           info <- base::paste(info, collapse = "; ")
[17:46:45.293]                           if (!has_future) {
[17:46:45.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.293]                               info)
[17:46:45.293]                           }
[17:46:45.293]                           else {
[17:46:45.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.293]                               info, version)
[17:46:45.293]                           }
[17:46:45.293]                           base::stop(msg)
[17:46:45.293]                         }
[17:46:45.293]                       })
[17:46:45.293]                     }
[17:46:45.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.293]                     base::options(mc.cores = 1L)
[17:46:45.293]                   }
[17:46:45.293]                   ...future.strategy.old <- future::plan("list")
[17:46:45.293]                   options(future.plan = NULL)
[17:46:45.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.293]                 }
[17:46:45.293]                 ...future.workdir <- getwd()
[17:46:45.293]             }
[17:46:45.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.293]         }
[17:46:45.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.293]             base::names(...future.oldOptions))
[17:46:45.293]     }
[17:46:45.293]     if (FALSE) {
[17:46:45.293]     }
[17:46:45.293]     else {
[17:46:45.293]         if (TRUE) {
[17:46:45.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.293]                 open = "w")
[17:46:45.293]         }
[17:46:45.293]         else {
[17:46:45.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.293]         }
[17:46:45.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.293]             base::sink(type = "output", split = FALSE)
[17:46:45.293]             base::close(...future.stdout)
[17:46:45.293]         }, add = TRUE)
[17:46:45.293]     }
[17:46:45.293]     ...future.frame <- base::sys.nframe()
[17:46:45.293]     ...future.conditions <- base::list()
[17:46:45.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.293]     if (FALSE) {
[17:46:45.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.293]     }
[17:46:45.293]     ...future.result <- base::tryCatch({
[17:46:45.293]         base::withCallingHandlers({
[17:46:45.293]             ...future.value <- base::withVisible(base::local({
[17:46:45.293]                 withCallingHandlers({
[17:46:45.293]                   2
[17:46:45.293]                 }, immediateCondition = function(cond) {
[17:46:45.293]                   save_rds <- function (object, pathname, ...) 
[17:46:45.293]                   {
[17:46:45.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.293]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.293]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.293]                         fi_tmp[["mtime"]])
[17:46:45.293]                     }
[17:46:45.293]                     tryCatch({
[17:46:45.293]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.293]                     }, error = function(ex) {
[17:46:45.293]                       msg <- conditionMessage(ex)
[17:46:45.293]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.293]                         fi_tmp[["mtime"]], msg)
[17:46:45.293]                       ex$message <- msg
[17:46:45.293]                       stop(ex)
[17:46:45.293]                     })
[17:46:45.293]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.293]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.293]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.293]                       fi <- file.info(pathname)
[17:46:45.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.293]                         fi[["size"]], fi[["mtime"]])
[17:46:45.293]                       stop(msg)
[17:46:45.293]                     }
[17:46:45.293]                     invisible(pathname)
[17:46:45.293]                   }
[17:46:45.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.293]                     rootPath = tempdir()) 
[17:46:45.293]                   {
[17:46:45.293]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.293]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.293]                       tmpdir = path, fileext = ".rds")
[17:46:45.293]                     save_rds(obj, file)
[17:46:45.293]                   }
[17:46:45.293]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.293]                   {
[17:46:45.293]                     inherits <- base::inherits
[17:46:45.293]                     invokeRestart <- base::invokeRestart
[17:46:45.293]                     is.null <- base::is.null
[17:46:45.293]                     muffled <- FALSE
[17:46:45.293]                     if (inherits(cond, "message")) {
[17:46:45.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.293]                       if (muffled) 
[17:46:45.293]                         invokeRestart("muffleMessage")
[17:46:45.293]                     }
[17:46:45.293]                     else if (inherits(cond, "warning")) {
[17:46:45.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.293]                       if (muffled) 
[17:46:45.293]                         invokeRestart("muffleWarning")
[17:46:45.293]                     }
[17:46:45.293]                     else if (inherits(cond, "condition")) {
[17:46:45.293]                       if (!is.null(pattern)) {
[17:46:45.293]                         computeRestarts <- base::computeRestarts
[17:46:45.293]                         grepl <- base::grepl
[17:46:45.293]                         restarts <- computeRestarts(cond)
[17:46:45.293]                         for (restart in restarts) {
[17:46:45.293]                           name <- restart$name
[17:46:45.293]                           if (is.null(name)) 
[17:46:45.293]                             next
[17:46:45.293]                           if (!grepl(pattern, name)) 
[17:46:45.293]                             next
[17:46:45.293]                           invokeRestart(restart)
[17:46:45.293]                           muffled <- TRUE
[17:46:45.293]                           break
[17:46:45.293]                         }
[17:46:45.293]                       }
[17:46:45.293]                     }
[17:46:45.293]                     invisible(muffled)
[17:46:45.293]                   }
[17:46:45.293]                   muffleCondition(cond)
[17:46:45.293]                 })
[17:46:45.293]             }))
[17:46:45.293]             future::FutureResult(value = ...future.value$value, 
[17:46:45.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.293]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.293]                     ...future.globalenv.names))
[17:46:45.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.293]         }, condition = base::local({
[17:46:45.293]             c <- base::c
[17:46:45.293]             inherits <- base::inherits
[17:46:45.293]             invokeRestart <- base::invokeRestart
[17:46:45.293]             length <- base::length
[17:46:45.293]             list <- base::list
[17:46:45.293]             seq.int <- base::seq.int
[17:46:45.293]             signalCondition <- base::signalCondition
[17:46:45.293]             sys.calls <- base::sys.calls
[17:46:45.293]             `[[` <- base::`[[`
[17:46:45.293]             `+` <- base::`+`
[17:46:45.293]             `<<-` <- base::`<<-`
[17:46:45.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.293]                   3L)]
[17:46:45.293]             }
[17:46:45.293]             function(cond) {
[17:46:45.293]                 is_error <- inherits(cond, "error")
[17:46:45.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.293]                   NULL)
[17:46:45.293]                 if (is_error) {
[17:46:45.293]                   sessionInformation <- function() {
[17:46:45.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.293]                       search = base::search(), system = base::Sys.info())
[17:46:45.293]                   }
[17:46:45.293]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.293]                     cond$call), session = sessionInformation(), 
[17:46:45.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.293]                   signalCondition(cond)
[17:46:45.293]                 }
[17:46:45.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.293]                 "immediateCondition"))) {
[17:46:45.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.293]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.293]                   if (TRUE && !signal) {
[17:46:45.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.293]                     {
[17:46:45.293]                       inherits <- base::inherits
[17:46:45.293]                       invokeRestart <- base::invokeRestart
[17:46:45.293]                       is.null <- base::is.null
[17:46:45.293]                       muffled <- FALSE
[17:46:45.293]                       if (inherits(cond, "message")) {
[17:46:45.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.293]                         if (muffled) 
[17:46:45.293]                           invokeRestart("muffleMessage")
[17:46:45.293]                       }
[17:46:45.293]                       else if (inherits(cond, "warning")) {
[17:46:45.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.293]                         if (muffled) 
[17:46:45.293]                           invokeRestart("muffleWarning")
[17:46:45.293]                       }
[17:46:45.293]                       else if (inherits(cond, "condition")) {
[17:46:45.293]                         if (!is.null(pattern)) {
[17:46:45.293]                           computeRestarts <- base::computeRestarts
[17:46:45.293]                           grepl <- base::grepl
[17:46:45.293]                           restarts <- computeRestarts(cond)
[17:46:45.293]                           for (restart in restarts) {
[17:46:45.293]                             name <- restart$name
[17:46:45.293]                             if (is.null(name)) 
[17:46:45.293]                               next
[17:46:45.293]                             if (!grepl(pattern, name)) 
[17:46:45.293]                               next
[17:46:45.293]                             invokeRestart(restart)
[17:46:45.293]                             muffled <- TRUE
[17:46:45.293]                             break
[17:46:45.293]                           }
[17:46:45.293]                         }
[17:46:45.293]                       }
[17:46:45.293]                       invisible(muffled)
[17:46:45.293]                     }
[17:46:45.293]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.293]                   }
[17:46:45.293]                 }
[17:46:45.293]                 else {
[17:46:45.293]                   if (TRUE) {
[17:46:45.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.293]                     {
[17:46:45.293]                       inherits <- base::inherits
[17:46:45.293]                       invokeRestart <- base::invokeRestart
[17:46:45.293]                       is.null <- base::is.null
[17:46:45.293]                       muffled <- FALSE
[17:46:45.293]                       if (inherits(cond, "message")) {
[17:46:45.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.293]                         if (muffled) 
[17:46:45.293]                           invokeRestart("muffleMessage")
[17:46:45.293]                       }
[17:46:45.293]                       else if (inherits(cond, "warning")) {
[17:46:45.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.293]                         if (muffled) 
[17:46:45.293]                           invokeRestart("muffleWarning")
[17:46:45.293]                       }
[17:46:45.293]                       else if (inherits(cond, "condition")) {
[17:46:45.293]                         if (!is.null(pattern)) {
[17:46:45.293]                           computeRestarts <- base::computeRestarts
[17:46:45.293]                           grepl <- base::grepl
[17:46:45.293]                           restarts <- computeRestarts(cond)
[17:46:45.293]                           for (restart in restarts) {
[17:46:45.293]                             name <- restart$name
[17:46:45.293]                             if (is.null(name)) 
[17:46:45.293]                               next
[17:46:45.293]                             if (!grepl(pattern, name)) 
[17:46:45.293]                               next
[17:46:45.293]                             invokeRestart(restart)
[17:46:45.293]                             muffled <- TRUE
[17:46:45.293]                             break
[17:46:45.293]                           }
[17:46:45.293]                         }
[17:46:45.293]                       }
[17:46:45.293]                       invisible(muffled)
[17:46:45.293]                     }
[17:46:45.293]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.293]                   }
[17:46:45.293]                 }
[17:46:45.293]             }
[17:46:45.293]         }))
[17:46:45.293]     }, error = function(ex) {
[17:46:45.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.293]                 ...future.rng), started = ...future.startTime, 
[17:46:45.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.293]             version = "1.8"), class = "FutureResult")
[17:46:45.293]     }, finally = {
[17:46:45.293]         if (!identical(...future.workdir, getwd())) 
[17:46:45.293]             setwd(...future.workdir)
[17:46:45.293]         {
[17:46:45.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.293]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.293]             }
[17:46:45.293]             base::options(...future.oldOptions)
[17:46:45.293]             if (.Platform$OS.type == "windows") {
[17:46:45.293]                 old_names <- names(...future.oldEnvVars)
[17:46:45.293]                 envs <- base::Sys.getenv()
[17:46:45.293]                 names <- names(envs)
[17:46:45.293]                 common <- intersect(names, old_names)
[17:46:45.293]                 added <- setdiff(names, old_names)
[17:46:45.293]                 removed <- setdiff(old_names, names)
[17:46:45.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.293]                   envs[common]]
[17:46:45.293]                 NAMES <- toupper(changed)
[17:46:45.293]                 args <- list()
[17:46:45.293]                 for (kk in seq_along(NAMES)) {
[17:46:45.293]                   name <- changed[[kk]]
[17:46:45.293]                   NAME <- NAMES[[kk]]
[17:46:45.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.293]                     next
[17:46:45.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.293]                 }
[17:46:45.293]                 NAMES <- toupper(added)
[17:46:45.293]                 for (kk in seq_along(NAMES)) {
[17:46:45.293]                   name <- added[[kk]]
[17:46:45.293]                   NAME <- NAMES[[kk]]
[17:46:45.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.293]                     next
[17:46:45.293]                   args[[name]] <- ""
[17:46:45.293]                 }
[17:46:45.293]                 NAMES <- toupper(removed)
[17:46:45.293]                 for (kk in seq_along(NAMES)) {
[17:46:45.293]                   name <- removed[[kk]]
[17:46:45.293]                   NAME <- NAMES[[kk]]
[17:46:45.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.293]                     next
[17:46:45.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.293]                 }
[17:46:45.293]                 if (length(args) > 0) 
[17:46:45.293]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.293]             }
[17:46:45.293]             else {
[17:46:45.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.293]             }
[17:46:45.293]             {
[17:46:45.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.293]                   0L) {
[17:46:45.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.293]                   base::options(opts)
[17:46:45.293]                 }
[17:46:45.293]                 {
[17:46:45.293]                   {
[17:46:45.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.293]                     NULL
[17:46:45.293]                   }
[17:46:45.293]                   options(future.plan = NULL)
[17:46:45.293]                   if (is.na(NA_character_)) 
[17:46:45.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.293]                     .init = FALSE)
[17:46:45.293]                 }
[17:46:45.293]             }
[17:46:45.293]         }
[17:46:45.293]     })
[17:46:45.293]     if (TRUE) {
[17:46:45.293]         base::sink(type = "output", split = FALSE)
[17:46:45.293]         if (TRUE) {
[17:46:45.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.293]         }
[17:46:45.293]         else {
[17:46:45.293]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.293]         }
[17:46:45.293]         base::close(...future.stdout)
[17:46:45.293]         ...future.stdout <- NULL
[17:46:45.293]     }
[17:46:45.293]     ...future.result$conditions <- ...future.conditions
[17:46:45.293]     ...future.result$finished <- base::Sys.time()
[17:46:45.293]     ...future.result
[17:46:45.293] }
[17:46:45.296] requestCore(): workers = 2
[17:46:45.297] MulticoreFuture started
[17:46:45.298] - Launch lazy future ... done
[17:46:45.298] run() for ‘MulticoreFuture’ ... done
[17:46:45.298] getGlobalsAndPackages() ...
[17:46:45.298] plan(): Setting new future strategy stack:
[17:46:45.298] Searching for globals...
[17:46:45.299] 
[17:46:45.299] List of future strategies:
[17:46:45.299] 1. sequential:
[17:46:45.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.299]    - tweaked: FALSE
[17:46:45.299]    - call: NULL
[17:46:45.299] Searching for globals ... DONE
[17:46:45.300] plan(): nbrOfWorkers() = 1
[17:46:45.300] - globals: [0] <none>
[17:46:45.300] getGlobalsAndPackages() ... DONE
[17:46:45.300] run() for ‘Future’ ...
[17:46:45.301] - state: ‘created’
[17:46:45.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.302] plan(): Setting new future strategy stack:
[17:46:45.302] List of future strategies:
[17:46:45.302] 1. multicore:
[17:46:45.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.302]    - tweaked: FALSE
[17:46:45.302]    - call: plan(strategy)
[17:46:45.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.306]   - Field: ‘label’
[17:46:45.306]   - Field: ‘local’
[17:46:45.306] plan(): nbrOfWorkers() = 2
[17:46:45.306]   - Field: ‘owner’
[17:46:45.307]   - Field: ‘envir’
[17:46:45.307]   - Field: ‘workers’
[17:46:45.307]   - Field: ‘packages’
[17:46:45.307]   - Field: ‘gc’
[17:46:45.307]   - Field: ‘job’
[17:46:45.307]   - Field: ‘conditions’
[17:46:45.308]   - Field: ‘expr’
[17:46:45.308]   - Field: ‘uuid’
[17:46:45.308]   - Field: ‘seed’
[17:46:45.308]   - Field: ‘version’
[17:46:45.308]   - Field: ‘result’
[17:46:45.308]   - Field: ‘asynchronous’
[17:46:45.308]   - Field: ‘calls’
[17:46:45.309]   - Field: ‘globals’
[17:46:45.309]   - Field: ‘stdout’
[17:46:45.309]   - Field: ‘earlySignal’
[17:46:45.309]   - Field: ‘lazy’
[17:46:45.309]   - Field: ‘state’
[17:46:45.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.309] - Launch lazy future ...
[17:46:45.310] Packages needed by the future expression (n = 0): <none>
[17:46:45.310] Packages needed by future strategies (n = 0): <none>
[17:46:45.311] {
[17:46:45.311]     {
[17:46:45.311]         {
[17:46:45.311]             ...future.startTime <- base::Sys.time()
[17:46:45.311]             {
[17:46:45.311]                 {
[17:46:45.311]                   {
[17:46:45.311]                     {
[17:46:45.311]                       base::local({
[17:46:45.311]                         has_future <- base::requireNamespace("future", 
[17:46:45.311]                           quietly = TRUE)
[17:46:45.311]                         if (has_future) {
[17:46:45.311]                           ns <- base::getNamespace("future")
[17:46:45.311]                           version <- ns[[".package"]][["version"]]
[17:46:45.311]                           if (is.null(version)) 
[17:46:45.311]                             version <- utils::packageVersion("future")
[17:46:45.311]                         }
[17:46:45.311]                         else {
[17:46:45.311]                           version <- NULL
[17:46:45.311]                         }
[17:46:45.311]                         if (!has_future || version < "1.8.0") {
[17:46:45.311]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.311]                             "", base::R.version$version.string), 
[17:46:45.311]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.311]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.311]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.311]                               "release", "version")], collapse = " "), 
[17:46:45.311]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.311]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.311]                             info)
[17:46:45.311]                           info <- base::paste(info, collapse = "; ")
[17:46:45.311]                           if (!has_future) {
[17:46:45.311]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.311]                               info)
[17:46:45.311]                           }
[17:46:45.311]                           else {
[17:46:45.311]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.311]                               info, version)
[17:46:45.311]                           }
[17:46:45.311]                           base::stop(msg)
[17:46:45.311]                         }
[17:46:45.311]                       })
[17:46:45.311]                     }
[17:46:45.311]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.311]                     base::options(mc.cores = 1L)
[17:46:45.311]                   }
[17:46:45.311]                   ...future.strategy.old <- future::plan("list")
[17:46:45.311]                   options(future.plan = NULL)
[17:46:45.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.311]                 }
[17:46:45.311]                 ...future.workdir <- getwd()
[17:46:45.311]             }
[17:46:45.311]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.311]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.311]         }
[17:46:45.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.311]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.311]             base::names(...future.oldOptions))
[17:46:45.311]     }
[17:46:45.311]     if (FALSE) {
[17:46:45.311]     }
[17:46:45.311]     else {
[17:46:45.311]         if (TRUE) {
[17:46:45.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.311]                 open = "w")
[17:46:45.311]         }
[17:46:45.311]         else {
[17:46:45.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.311]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.311]         }
[17:46:45.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.311]             base::sink(type = "output", split = FALSE)
[17:46:45.311]             base::close(...future.stdout)
[17:46:45.311]         }, add = TRUE)
[17:46:45.311]     }
[17:46:45.311]     ...future.frame <- base::sys.nframe()
[17:46:45.311]     ...future.conditions <- base::list()
[17:46:45.311]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.311]     if (FALSE) {
[17:46:45.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.311]     }
[17:46:45.311]     ...future.result <- base::tryCatch({
[17:46:45.311]         base::withCallingHandlers({
[17:46:45.311]             ...future.value <- base::withVisible(base::local({
[17:46:45.311]                 withCallingHandlers({
[17:46:45.311]                   NULL
[17:46:45.311]                 }, immediateCondition = function(cond) {
[17:46:45.311]                   save_rds <- function (object, pathname, ...) 
[17:46:45.311]                   {
[17:46:45.311]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.311]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.311]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.311]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.311]                         fi_tmp[["mtime"]])
[17:46:45.311]                     }
[17:46:45.311]                     tryCatch({
[17:46:45.311]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.311]                     }, error = function(ex) {
[17:46:45.311]                       msg <- conditionMessage(ex)
[17:46:45.311]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.311]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.311]                         fi_tmp[["mtime"]], msg)
[17:46:45.311]                       ex$message <- msg
[17:46:45.311]                       stop(ex)
[17:46:45.311]                     })
[17:46:45.311]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.311]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.311]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.311]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.311]                       fi <- file.info(pathname)
[17:46:45.311]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.311]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.311]                         fi[["size"]], fi[["mtime"]])
[17:46:45.311]                       stop(msg)
[17:46:45.311]                     }
[17:46:45.311]                     invisible(pathname)
[17:46:45.311]                   }
[17:46:45.311]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.311]                     rootPath = tempdir()) 
[17:46:45.311]                   {
[17:46:45.311]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.311]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.311]                       tmpdir = path, fileext = ".rds")
[17:46:45.311]                     save_rds(obj, file)
[17:46:45.311]                   }
[17:46:45.311]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.311]                   {
[17:46:45.311]                     inherits <- base::inherits
[17:46:45.311]                     invokeRestart <- base::invokeRestart
[17:46:45.311]                     is.null <- base::is.null
[17:46:45.311]                     muffled <- FALSE
[17:46:45.311]                     if (inherits(cond, "message")) {
[17:46:45.311]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.311]                       if (muffled) 
[17:46:45.311]                         invokeRestart("muffleMessage")
[17:46:45.311]                     }
[17:46:45.311]                     else if (inherits(cond, "warning")) {
[17:46:45.311]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.311]                       if (muffled) 
[17:46:45.311]                         invokeRestart("muffleWarning")
[17:46:45.311]                     }
[17:46:45.311]                     else if (inherits(cond, "condition")) {
[17:46:45.311]                       if (!is.null(pattern)) {
[17:46:45.311]                         computeRestarts <- base::computeRestarts
[17:46:45.311]                         grepl <- base::grepl
[17:46:45.311]                         restarts <- computeRestarts(cond)
[17:46:45.311]                         for (restart in restarts) {
[17:46:45.311]                           name <- restart$name
[17:46:45.311]                           if (is.null(name)) 
[17:46:45.311]                             next
[17:46:45.311]                           if (!grepl(pattern, name)) 
[17:46:45.311]                             next
[17:46:45.311]                           invokeRestart(restart)
[17:46:45.311]                           muffled <- TRUE
[17:46:45.311]                           break
[17:46:45.311]                         }
[17:46:45.311]                       }
[17:46:45.311]                     }
[17:46:45.311]                     invisible(muffled)
[17:46:45.311]                   }
[17:46:45.311]                   muffleCondition(cond)
[17:46:45.311]                 })
[17:46:45.311]             }))
[17:46:45.311]             future::FutureResult(value = ...future.value$value, 
[17:46:45.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.311]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.311]                     ...future.globalenv.names))
[17:46:45.311]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.311]         }, condition = base::local({
[17:46:45.311]             c <- base::c
[17:46:45.311]             inherits <- base::inherits
[17:46:45.311]             invokeRestart <- base::invokeRestart
[17:46:45.311]             length <- base::length
[17:46:45.311]             list <- base::list
[17:46:45.311]             seq.int <- base::seq.int
[17:46:45.311]             signalCondition <- base::signalCondition
[17:46:45.311]             sys.calls <- base::sys.calls
[17:46:45.311]             `[[` <- base::`[[`
[17:46:45.311]             `+` <- base::`+`
[17:46:45.311]             `<<-` <- base::`<<-`
[17:46:45.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.311]                   3L)]
[17:46:45.311]             }
[17:46:45.311]             function(cond) {
[17:46:45.311]                 is_error <- inherits(cond, "error")
[17:46:45.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.311]                   NULL)
[17:46:45.311]                 if (is_error) {
[17:46:45.311]                   sessionInformation <- function() {
[17:46:45.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.311]                       search = base::search(), system = base::Sys.info())
[17:46:45.311]                   }
[17:46:45.311]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.311]                     cond$call), session = sessionInformation(), 
[17:46:45.311]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.311]                   signalCondition(cond)
[17:46:45.311]                 }
[17:46:45.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.311]                 "immediateCondition"))) {
[17:46:45.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.311]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.311]                   if (TRUE && !signal) {
[17:46:45.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.311]                     {
[17:46:45.311]                       inherits <- base::inherits
[17:46:45.311]                       invokeRestart <- base::invokeRestart
[17:46:45.311]                       is.null <- base::is.null
[17:46:45.311]                       muffled <- FALSE
[17:46:45.311]                       if (inherits(cond, "message")) {
[17:46:45.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.311]                         if (muffled) 
[17:46:45.311]                           invokeRestart("muffleMessage")
[17:46:45.311]                       }
[17:46:45.311]                       else if (inherits(cond, "warning")) {
[17:46:45.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.311]                         if (muffled) 
[17:46:45.311]                           invokeRestart("muffleWarning")
[17:46:45.311]                       }
[17:46:45.311]                       else if (inherits(cond, "condition")) {
[17:46:45.311]                         if (!is.null(pattern)) {
[17:46:45.311]                           computeRestarts <- base::computeRestarts
[17:46:45.311]                           grepl <- base::grepl
[17:46:45.311]                           restarts <- computeRestarts(cond)
[17:46:45.311]                           for (restart in restarts) {
[17:46:45.311]                             name <- restart$name
[17:46:45.311]                             if (is.null(name)) 
[17:46:45.311]                               next
[17:46:45.311]                             if (!grepl(pattern, name)) 
[17:46:45.311]                               next
[17:46:45.311]                             invokeRestart(restart)
[17:46:45.311]                             muffled <- TRUE
[17:46:45.311]                             break
[17:46:45.311]                           }
[17:46:45.311]                         }
[17:46:45.311]                       }
[17:46:45.311]                       invisible(muffled)
[17:46:45.311]                     }
[17:46:45.311]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.311]                   }
[17:46:45.311]                 }
[17:46:45.311]                 else {
[17:46:45.311]                   if (TRUE) {
[17:46:45.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.311]                     {
[17:46:45.311]                       inherits <- base::inherits
[17:46:45.311]                       invokeRestart <- base::invokeRestart
[17:46:45.311]                       is.null <- base::is.null
[17:46:45.311]                       muffled <- FALSE
[17:46:45.311]                       if (inherits(cond, "message")) {
[17:46:45.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.311]                         if (muffled) 
[17:46:45.311]                           invokeRestart("muffleMessage")
[17:46:45.311]                       }
[17:46:45.311]                       else if (inherits(cond, "warning")) {
[17:46:45.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.311]                         if (muffled) 
[17:46:45.311]                           invokeRestart("muffleWarning")
[17:46:45.311]                       }
[17:46:45.311]                       else if (inherits(cond, "condition")) {
[17:46:45.311]                         if (!is.null(pattern)) {
[17:46:45.311]                           computeRestarts <- base::computeRestarts
[17:46:45.311]                           grepl <- base::grepl
[17:46:45.311]                           restarts <- computeRestarts(cond)
[17:46:45.311]                           for (restart in restarts) {
[17:46:45.311]                             name <- restart$name
[17:46:45.311]                             if (is.null(name)) 
[17:46:45.311]                               next
[17:46:45.311]                             if (!grepl(pattern, name)) 
[17:46:45.311]                               next
[17:46:45.311]                             invokeRestart(restart)
[17:46:45.311]                             muffled <- TRUE
[17:46:45.311]                             break
[17:46:45.311]                           }
[17:46:45.311]                         }
[17:46:45.311]                       }
[17:46:45.311]                       invisible(muffled)
[17:46:45.311]                     }
[17:46:45.311]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.311]                   }
[17:46:45.311]                 }
[17:46:45.311]             }
[17:46:45.311]         }))
[17:46:45.311]     }, error = function(ex) {
[17:46:45.311]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.311]                 ...future.rng), started = ...future.startTime, 
[17:46:45.311]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.311]             version = "1.8"), class = "FutureResult")
[17:46:45.311]     }, finally = {
[17:46:45.311]         if (!identical(...future.workdir, getwd())) 
[17:46:45.311]             setwd(...future.workdir)
[17:46:45.311]         {
[17:46:45.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.311]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.311]             }
[17:46:45.311]             base::options(...future.oldOptions)
[17:46:45.311]             if (.Platform$OS.type == "windows") {
[17:46:45.311]                 old_names <- names(...future.oldEnvVars)
[17:46:45.311]                 envs <- base::Sys.getenv()
[17:46:45.311]                 names <- names(envs)
[17:46:45.311]                 common <- intersect(names, old_names)
[17:46:45.311]                 added <- setdiff(names, old_names)
[17:46:45.311]                 removed <- setdiff(old_names, names)
[17:46:45.311]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.311]                   envs[common]]
[17:46:45.311]                 NAMES <- toupper(changed)
[17:46:45.311]                 args <- list()
[17:46:45.311]                 for (kk in seq_along(NAMES)) {
[17:46:45.311]                   name <- changed[[kk]]
[17:46:45.311]                   NAME <- NAMES[[kk]]
[17:46:45.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.311]                     next
[17:46:45.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.311]                 }
[17:46:45.311]                 NAMES <- toupper(added)
[17:46:45.311]                 for (kk in seq_along(NAMES)) {
[17:46:45.311]                   name <- added[[kk]]
[17:46:45.311]                   NAME <- NAMES[[kk]]
[17:46:45.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.311]                     next
[17:46:45.311]                   args[[name]] <- ""
[17:46:45.311]                 }
[17:46:45.311]                 NAMES <- toupper(removed)
[17:46:45.311]                 for (kk in seq_along(NAMES)) {
[17:46:45.311]                   name <- removed[[kk]]
[17:46:45.311]                   NAME <- NAMES[[kk]]
[17:46:45.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.311]                     next
[17:46:45.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.311]                 }
[17:46:45.311]                 if (length(args) > 0) 
[17:46:45.311]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.311]             }
[17:46:45.311]             else {
[17:46:45.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.311]             }
[17:46:45.311]             {
[17:46:45.311]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.311]                   0L) {
[17:46:45.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.311]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.311]                   base::options(opts)
[17:46:45.311]                 }
[17:46:45.311]                 {
[17:46:45.311]                   {
[17:46:45.311]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.311]                     NULL
[17:46:45.311]                   }
[17:46:45.311]                   options(future.plan = NULL)
[17:46:45.311]                   if (is.na(NA_character_)) 
[17:46:45.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.311]                     .init = FALSE)
[17:46:45.311]                 }
[17:46:45.311]             }
[17:46:45.311]         }
[17:46:45.311]     })
[17:46:45.311]     if (TRUE) {
[17:46:45.311]         base::sink(type = "output", split = FALSE)
[17:46:45.311]         if (TRUE) {
[17:46:45.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.311]         }
[17:46:45.311]         else {
[17:46:45.311]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.311]         }
[17:46:45.311]         base::close(...future.stdout)
[17:46:45.311]         ...future.stdout <- NULL
[17:46:45.311]     }
[17:46:45.311]     ...future.result$conditions <- ...future.conditions
[17:46:45.311]     ...future.result$finished <- base::Sys.time()
[17:46:45.311]     ...future.result
[17:46:45.311] }
[17:46:45.314] requestCore(): workers = 2
[17:46:45.316] MulticoreFuture started
[17:46:45.317] - Launch lazy future ... done
[17:46:45.317] run() for ‘MulticoreFuture’ ... done
List of 6
[17:46:45.317] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[17:46:45.318] List of future strategies:
[17:46:45.318] 1. sequential:
[17:46:45.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.318]    - tweaked: FALSE
[17:46:45.318]    - call: NULL
[17:46:45.319] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787572a48> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787b84820> 
 $  : NULL
 $  : NULL
 $  :[17:46:45.321] plan(): Setting new future strategy stack:
[17:46:45.321] List of future strategies:
[17:46:45.321] 1. multicore:
[17:46:45.321]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.321]    - tweaked: FALSE
[17:46:45.321]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787572a48> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787b84820> 
 $  : NULL
 $  : NULL
 $  :[17:46:45.330] plan(): nbrOfWorkers() = 2
 num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:45.336] resolve() on list ...
[17:46:45.336]  recursive: 0
[17:46:45.336]  length: 6
[17:46:45.336]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:45.337] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.337] - nx: 6
[17:46:45.337] - relay: TRUE
[17:46:45.337] - stdout: TRUE
[17:46:45.337] - signal: TRUE
[17:46:45.337] - resignal: FALSE
[17:46:45.337] - force: TRUE
[17:46:45.337] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.338] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.338]  - until=2
[17:46:45.338]  - relaying element #2
[17:46:45.338] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.338] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.338] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.338]  length: 5 (resolved future 1)
[17:46:45.339] Future #2
[17:46:45.339] result() for MulticoreFuture ...
[17:46:45.340] result() for MulticoreFuture ...
[17:46:45.340] result() for MulticoreFuture ... done
[17:46:45.340] result() for MulticoreFuture ... done
[17:46:45.340] result() for MulticoreFuture ...
[17:46:45.340] result() for MulticoreFuture ... done
[17:46:45.340] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:45.341] - nx: 6
[17:46:45.341] - relay: TRUE
[17:46:45.341] - stdout: TRUE
[17:46:45.341] - signal: TRUE
[17:46:45.341] - resignal: FALSE
[17:46:45.341] - force: TRUE
[17:46:45.341] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.341] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.342]  - until=2
[17:46:45.342]  - relaying element #2
[17:46:45.342] result() for MulticoreFuture ...
[17:46:45.342] result() for MulticoreFuture ... done
[17:46:45.342] result() for MulticoreFuture ...
[17:46:45.342] result() for MulticoreFuture ... done
[17:46:45.342] result() for MulticoreFuture ...
[17:46:45.343] result() for MulticoreFuture ... done
[17:46:45.343] result() for MulticoreFuture ...
[17:46:45.343] result() for MulticoreFuture ... done
[17:46:45.343] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.343] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.343] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:45.343]  length: 4 (resolved future 2)
[17:46:45.344] Future #3
[17:46:45.344] result() for MulticoreFuture ...
[17:46:45.344] result() for MulticoreFuture ...
[17:46:45.344] result() for MulticoreFuture ... done
[17:46:45.345] result() for MulticoreFuture ... done
[17:46:45.345] result() for MulticoreFuture ...
[17:46:45.345] result() for MulticoreFuture ... done
[17:46:45.345] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:45.345] - nx: 6
[17:46:45.345] - relay: TRUE
[17:46:45.345] - stdout: TRUE
[17:46:45.345] - signal: TRUE
[17:46:45.346] - resignal: FALSE
[17:46:45.346] - force: TRUE
[17:46:45.346] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.346] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.346]  - until=3
[17:46:45.346]  - relaying element #3
[17:46:45.346] result() for MulticoreFuture ...
[17:46:45.346] result() for MulticoreFuture ... done
[17:46:45.346] result() for MulticoreFuture ...
[17:46:45.346] result() for MulticoreFuture ... done
[17:46:45.347] result() for MulticoreFuture ...
[17:46:45.347] result() for MulticoreFuture ... done
[17:46:45.347] result() for MulticoreFuture ...
[17:46:45.347] result() for MulticoreFuture ... done
[17:46:45.347] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.347] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.347] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:45.347]  length: 3 (resolved future 3)
[17:46:45.347] signalConditionsASAP(NULL, pos=4) ...
[17:46:45.348] - nx: 6
[17:46:45.348] - relay: TRUE
[17:46:45.348] - stdout: TRUE
[17:46:45.348] - signal: TRUE
[17:46:45.348] - resignal: FALSE
[17:46:45.348] - force: TRUE
[17:46:45.348] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.348] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.348]  - until=5
[17:46:45.348]  - relaying element #5
[17:46:45.349] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.349] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.349] signalConditionsASAP(NULL, pos=4) ... done
[17:46:45.349]  length: 2 (resolved future 4)
[17:46:45.349] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.349] - nx: 6
[17:46:45.349] - relay: TRUE
[17:46:45.349] - stdout: TRUE
[17:46:45.349] - signal: TRUE
[17:46:45.349] - resignal: FALSE
[17:46:45.350] - force: TRUE
[17:46:45.350] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.350] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.350]  - until=6
[17:46:45.350]  - relaying element #6
[17:46:45.350] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.350] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.350] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.350]  length: 1 (resolved future 5)
[17:46:45.350] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.350] - nx: 6
[17:46:45.351] - relay: TRUE
[17:46:45.351] - stdout: TRUE
[17:46:45.351] - signal: TRUE
[17:46:45.351] - resignal: FALSE
[17:46:45.351] - force: TRUE
[17:46:45.351] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.351] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.351]  - until=6
[17:46:45.351] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.351] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.352] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.352]  length: 0 (resolved future 6)
[17:46:45.352] Relaying remaining futures
[17:46:45.352] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.352] - nx: 6
[17:46:45.352] - relay: TRUE
[17:46:45.352] - stdout: TRUE
[17:46:45.352] - signal: TRUE
[17:46:45.352] - resignal: FALSE
[17:46:45.352] - force: TRUE
[17:46:45.352] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.353] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:45.353] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.353] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.353] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.353] resolve() on list ... DONE
[17:46:45.353] result() for MulticoreFuture ...
[17:46:45.353] result() for MulticoreFuture ... done
[17:46:45.353] result() for MulticoreFuture ...
[17:46:45.353] result() for MulticoreFuture ... done
[17:46:45.354] result() for MulticoreFuture ...
[17:46:45.354] result() for MulticoreFuture ... done
[17:46:45.354] result() for MulticoreFuture ...
[17:46:45.354] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:46:45.357] getGlobalsAndPackages() ...
[17:46:45.357] Searching for globals...
[17:46:45.358] 
[17:46:45.358] Searching for globals ... DONE
[17:46:45.358] - globals: [0] <none>
[17:46:45.358] getGlobalsAndPackages() ... DONE
[17:46:45.358] run() for ‘Future’ ...
[17:46:45.358] - state: ‘created’
[17:46:45.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.364] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.364]   - Field: ‘label’
[17:46:45.364]   - Field: ‘local’
[17:46:45.365]   - Field: ‘owner’
[17:46:45.365]   - Field: ‘envir’
[17:46:45.365]   - Field: ‘workers’
[17:46:45.365]   - Field: ‘packages’
[17:46:45.365]   - Field: ‘gc’
[17:46:45.365]   - Field: ‘job’
[17:46:45.365]   - Field: ‘conditions’
[17:46:45.365]   - Field: ‘expr’
[17:46:45.365]   - Field: ‘uuid’
[17:46:45.365]   - Field: ‘seed’
[17:46:45.366]   - Field: ‘version’
[17:46:45.366]   - Field: ‘result’
[17:46:45.366]   - Field: ‘asynchronous’
[17:46:45.366]   - Field: ‘calls’
[17:46:45.366]   - Field: ‘globals’
[17:46:45.366]   - Field: ‘stdout’
[17:46:45.366]   - Field: ‘earlySignal’
[17:46:45.366]   - Field: ‘lazy’
[17:46:45.366]   - Field: ‘state’
[17:46:45.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.366] - Launch lazy future ...
[17:46:45.367] Packages needed by the future expression (n = 0): <none>
[17:46:45.367] Packages needed by future strategies (n = 0): <none>
[17:46:45.367] {
[17:46:45.367]     {
[17:46:45.367]         {
[17:46:45.367]             ...future.startTime <- base::Sys.time()
[17:46:45.367]             {
[17:46:45.367]                 {
[17:46:45.367]                   {
[17:46:45.367]                     {
[17:46:45.367]                       base::local({
[17:46:45.367]                         has_future <- base::requireNamespace("future", 
[17:46:45.367]                           quietly = TRUE)
[17:46:45.367]                         if (has_future) {
[17:46:45.367]                           ns <- base::getNamespace("future")
[17:46:45.367]                           version <- ns[[".package"]][["version"]]
[17:46:45.367]                           if (is.null(version)) 
[17:46:45.367]                             version <- utils::packageVersion("future")
[17:46:45.367]                         }
[17:46:45.367]                         else {
[17:46:45.367]                           version <- NULL
[17:46:45.367]                         }
[17:46:45.367]                         if (!has_future || version < "1.8.0") {
[17:46:45.367]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.367]                             "", base::R.version$version.string), 
[17:46:45.367]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.367]                               "release", "version")], collapse = " "), 
[17:46:45.367]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.367]                             info)
[17:46:45.367]                           info <- base::paste(info, collapse = "; ")
[17:46:45.367]                           if (!has_future) {
[17:46:45.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.367]                               info)
[17:46:45.367]                           }
[17:46:45.367]                           else {
[17:46:45.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.367]                               info, version)
[17:46:45.367]                           }
[17:46:45.367]                           base::stop(msg)
[17:46:45.367]                         }
[17:46:45.367]                       })
[17:46:45.367]                     }
[17:46:45.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.367]                     base::options(mc.cores = 1L)
[17:46:45.367]                   }
[17:46:45.367]                   ...future.strategy.old <- future::plan("list")
[17:46:45.367]                   options(future.plan = NULL)
[17:46:45.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.367]                 }
[17:46:45.367]                 ...future.workdir <- getwd()
[17:46:45.367]             }
[17:46:45.367]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.367]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.367]         }
[17:46:45.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.367]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.367]             base::names(...future.oldOptions))
[17:46:45.367]     }
[17:46:45.367]     if (FALSE) {
[17:46:45.367]     }
[17:46:45.367]     else {
[17:46:45.367]         if (TRUE) {
[17:46:45.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.367]                 open = "w")
[17:46:45.367]         }
[17:46:45.367]         else {
[17:46:45.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.367]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.367]         }
[17:46:45.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.367]             base::sink(type = "output", split = FALSE)
[17:46:45.367]             base::close(...future.stdout)
[17:46:45.367]         }, add = TRUE)
[17:46:45.367]     }
[17:46:45.367]     ...future.frame <- base::sys.nframe()
[17:46:45.367]     ...future.conditions <- base::list()
[17:46:45.367]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.367]     if (FALSE) {
[17:46:45.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.367]     }
[17:46:45.367]     ...future.result <- base::tryCatch({
[17:46:45.367]         base::withCallingHandlers({
[17:46:45.367]             ...future.value <- base::withVisible(base::local({
[17:46:45.367]                 withCallingHandlers({
[17:46:45.367]                   2
[17:46:45.367]                 }, immediateCondition = function(cond) {
[17:46:45.367]                   save_rds <- function (object, pathname, ...) 
[17:46:45.367]                   {
[17:46:45.367]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.367]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.367]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.367]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.367]                         fi_tmp[["mtime"]])
[17:46:45.367]                     }
[17:46:45.367]                     tryCatch({
[17:46:45.367]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.367]                     }, error = function(ex) {
[17:46:45.367]                       msg <- conditionMessage(ex)
[17:46:45.367]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.367]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.367]                         fi_tmp[["mtime"]], msg)
[17:46:45.367]                       ex$message <- msg
[17:46:45.367]                       stop(ex)
[17:46:45.367]                     })
[17:46:45.367]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.367]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.367]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.367]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.367]                       fi <- file.info(pathname)
[17:46:45.367]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.367]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.367]                         fi[["size"]], fi[["mtime"]])
[17:46:45.367]                       stop(msg)
[17:46:45.367]                     }
[17:46:45.367]                     invisible(pathname)
[17:46:45.367]                   }
[17:46:45.367]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.367]                     rootPath = tempdir()) 
[17:46:45.367]                   {
[17:46:45.367]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.367]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.367]                       tmpdir = path, fileext = ".rds")
[17:46:45.367]                     save_rds(obj, file)
[17:46:45.367]                   }
[17:46:45.367]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.367]                   {
[17:46:45.367]                     inherits <- base::inherits
[17:46:45.367]                     invokeRestart <- base::invokeRestart
[17:46:45.367]                     is.null <- base::is.null
[17:46:45.367]                     muffled <- FALSE
[17:46:45.367]                     if (inherits(cond, "message")) {
[17:46:45.367]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.367]                       if (muffled) 
[17:46:45.367]                         invokeRestart("muffleMessage")
[17:46:45.367]                     }
[17:46:45.367]                     else if (inherits(cond, "warning")) {
[17:46:45.367]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.367]                       if (muffled) 
[17:46:45.367]                         invokeRestart("muffleWarning")
[17:46:45.367]                     }
[17:46:45.367]                     else if (inherits(cond, "condition")) {
[17:46:45.367]                       if (!is.null(pattern)) {
[17:46:45.367]                         computeRestarts <- base::computeRestarts
[17:46:45.367]                         grepl <- base::grepl
[17:46:45.367]                         restarts <- computeRestarts(cond)
[17:46:45.367]                         for (restart in restarts) {
[17:46:45.367]                           name <- restart$name
[17:46:45.367]                           if (is.null(name)) 
[17:46:45.367]                             next
[17:46:45.367]                           if (!grepl(pattern, name)) 
[17:46:45.367]                             next
[17:46:45.367]                           invokeRestart(restart)
[17:46:45.367]                           muffled <- TRUE
[17:46:45.367]                           break
[17:46:45.367]                         }
[17:46:45.367]                       }
[17:46:45.367]                     }
[17:46:45.367]                     invisible(muffled)
[17:46:45.367]                   }
[17:46:45.367]                   muffleCondition(cond)
[17:46:45.367]                 })
[17:46:45.367]             }))
[17:46:45.367]             future::FutureResult(value = ...future.value$value, 
[17:46:45.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.367]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.367]                     ...future.globalenv.names))
[17:46:45.367]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.367]         }, condition = base::local({
[17:46:45.367]             c <- base::c
[17:46:45.367]             inherits <- base::inherits
[17:46:45.367]             invokeRestart <- base::invokeRestart
[17:46:45.367]             length <- base::length
[17:46:45.367]             list <- base::list
[17:46:45.367]             seq.int <- base::seq.int
[17:46:45.367]             signalCondition <- base::signalCondition
[17:46:45.367]             sys.calls <- base::sys.calls
[17:46:45.367]             `[[` <- base::`[[`
[17:46:45.367]             `+` <- base::`+`
[17:46:45.367]             `<<-` <- base::`<<-`
[17:46:45.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.367]                   3L)]
[17:46:45.367]             }
[17:46:45.367]             function(cond) {
[17:46:45.367]                 is_error <- inherits(cond, "error")
[17:46:45.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.367]                   NULL)
[17:46:45.367]                 if (is_error) {
[17:46:45.367]                   sessionInformation <- function() {
[17:46:45.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.367]                       search = base::search(), system = base::Sys.info())
[17:46:45.367]                   }
[17:46:45.367]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.367]                     cond$call), session = sessionInformation(), 
[17:46:45.367]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.367]                   signalCondition(cond)
[17:46:45.367]                 }
[17:46:45.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.367]                 "immediateCondition"))) {
[17:46:45.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.367]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.367]                   if (TRUE && !signal) {
[17:46:45.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.367]                     {
[17:46:45.367]                       inherits <- base::inherits
[17:46:45.367]                       invokeRestart <- base::invokeRestart
[17:46:45.367]                       is.null <- base::is.null
[17:46:45.367]                       muffled <- FALSE
[17:46:45.367]                       if (inherits(cond, "message")) {
[17:46:45.367]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.367]                         if (muffled) 
[17:46:45.367]                           invokeRestart("muffleMessage")
[17:46:45.367]                       }
[17:46:45.367]                       else if (inherits(cond, "warning")) {
[17:46:45.367]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.367]                         if (muffled) 
[17:46:45.367]                           invokeRestart("muffleWarning")
[17:46:45.367]                       }
[17:46:45.367]                       else if (inherits(cond, "condition")) {
[17:46:45.367]                         if (!is.null(pattern)) {
[17:46:45.367]                           computeRestarts <- base::computeRestarts
[17:46:45.367]                           grepl <- base::grepl
[17:46:45.367]                           restarts <- computeRestarts(cond)
[17:46:45.367]                           for (restart in restarts) {
[17:46:45.367]                             name <- restart$name
[17:46:45.367]                             if (is.null(name)) 
[17:46:45.367]                               next
[17:46:45.367]                             if (!grepl(pattern, name)) 
[17:46:45.367]                               next
[17:46:45.367]                             invokeRestart(restart)
[17:46:45.367]                             muffled <- TRUE
[17:46:45.367]                             break
[17:46:45.367]                           }
[17:46:45.367]                         }
[17:46:45.367]                       }
[17:46:45.367]                       invisible(muffled)
[17:46:45.367]                     }
[17:46:45.367]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.367]                   }
[17:46:45.367]                 }
[17:46:45.367]                 else {
[17:46:45.367]                   if (TRUE) {
[17:46:45.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.367]                     {
[17:46:45.367]                       inherits <- base::inherits
[17:46:45.367]                       invokeRestart <- base::invokeRestart
[17:46:45.367]                       is.null <- base::is.null
[17:46:45.367]                       muffled <- FALSE
[17:46:45.367]                       if (inherits(cond, "message")) {
[17:46:45.367]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.367]                         if (muffled) 
[17:46:45.367]                           invokeRestart("muffleMessage")
[17:46:45.367]                       }
[17:46:45.367]                       else if (inherits(cond, "warning")) {
[17:46:45.367]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.367]                         if (muffled) 
[17:46:45.367]                           invokeRestart("muffleWarning")
[17:46:45.367]                       }
[17:46:45.367]                       else if (inherits(cond, "condition")) {
[17:46:45.367]                         if (!is.null(pattern)) {
[17:46:45.367]                           computeRestarts <- base::computeRestarts
[17:46:45.367]                           grepl <- base::grepl
[17:46:45.367]                           restarts <- computeRestarts(cond)
[17:46:45.367]                           for (restart in restarts) {
[17:46:45.367]                             name <- restart$name
[17:46:45.367]                             if (is.null(name)) 
[17:46:45.367]                               next
[17:46:45.367]                             if (!grepl(pattern, name)) 
[17:46:45.367]                               next
[17:46:45.367]                             invokeRestart(restart)
[17:46:45.367]                             muffled <- TRUE
[17:46:45.367]                             break
[17:46:45.367]                           }
[17:46:45.367]                         }
[17:46:45.367]                       }
[17:46:45.367]                       invisible(muffled)
[17:46:45.367]                     }
[17:46:45.367]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.367]                   }
[17:46:45.367]                 }
[17:46:45.367]             }
[17:46:45.367]         }))
[17:46:45.367]     }, error = function(ex) {
[17:46:45.367]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.367]                 ...future.rng), started = ...future.startTime, 
[17:46:45.367]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.367]             version = "1.8"), class = "FutureResult")
[17:46:45.367]     }, finally = {
[17:46:45.367]         if (!identical(...future.workdir, getwd())) 
[17:46:45.367]             setwd(...future.workdir)
[17:46:45.367]         {
[17:46:45.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.367]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.367]             }
[17:46:45.367]             base::options(...future.oldOptions)
[17:46:45.367]             if (.Platform$OS.type == "windows") {
[17:46:45.367]                 old_names <- names(...future.oldEnvVars)
[17:46:45.367]                 envs <- base::Sys.getenv()
[17:46:45.367]                 names <- names(envs)
[17:46:45.367]                 common <- intersect(names, old_names)
[17:46:45.367]                 added <- setdiff(names, old_names)
[17:46:45.367]                 removed <- setdiff(old_names, names)
[17:46:45.367]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.367]                   envs[common]]
[17:46:45.367]                 NAMES <- toupper(changed)
[17:46:45.367]                 args <- list()
[17:46:45.367]                 for (kk in seq_along(NAMES)) {
[17:46:45.367]                   name <- changed[[kk]]
[17:46:45.367]                   NAME <- NAMES[[kk]]
[17:46:45.367]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.367]                     next
[17:46:45.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.367]                 }
[17:46:45.367]                 NAMES <- toupper(added)
[17:46:45.367]                 for (kk in seq_along(NAMES)) {
[17:46:45.367]                   name <- added[[kk]]
[17:46:45.367]                   NAME <- NAMES[[kk]]
[17:46:45.367]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.367]                     next
[17:46:45.367]                   args[[name]] <- ""
[17:46:45.367]                 }
[17:46:45.367]                 NAMES <- toupper(removed)
[17:46:45.367]                 for (kk in seq_along(NAMES)) {
[17:46:45.367]                   name <- removed[[kk]]
[17:46:45.367]                   NAME <- NAMES[[kk]]
[17:46:45.367]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.367]                     next
[17:46:45.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.367]                 }
[17:46:45.367]                 if (length(args) > 0) 
[17:46:45.367]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.367]             }
[17:46:45.367]             else {
[17:46:45.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.367]             }
[17:46:45.367]             {
[17:46:45.367]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.367]                   0L) {
[17:46:45.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.367]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.367]                   base::options(opts)
[17:46:45.367]                 }
[17:46:45.367]                 {
[17:46:45.367]                   {
[17:46:45.367]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.367]                     NULL
[17:46:45.367]                   }
[17:46:45.367]                   options(future.plan = NULL)
[17:46:45.367]                   if (is.na(NA_character_)) 
[17:46:45.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.367]                     .init = FALSE)
[17:46:45.367]                 }
[17:46:45.367]             }
[17:46:45.367]         }
[17:46:45.367]     })
[17:46:45.367]     if (TRUE) {
[17:46:45.367]         base::sink(type = "output", split = FALSE)
[17:46:45.367]         if (TRUE) {
[17:46:45.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.367]         }
[17:46:45.367]         else {
[17:46:45.367]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.367]         }
[17:46:45.367]         base::close(...future.stdout)
[17:46:45.367]         ...future.stdout <- NULL
[17:46:45.367]     }
[17:46:45.367]     ...future.result$conditions <- ...future.conditions
[17:46:45.367]     ...future.result$finished <- base::Sys.time()
[17:46:45.367]     ...future.result
[17:46:45.367] }
[17:46:45.370] requestCore(): workers = 2
[17:46:45.371] MulticoreFuture started
[17:46:45.372] - Launch lazy future ... done
[17:46:45.372] run() for ‘MulticoreFuture’ ... done
[17:46:45.372] plan(): Setting new future strategy stack:
[17:46:45.373] getGlobalsAndPackages() ...
[17:46:45.373] Searching for globals...
[17:46:45.373] List of future strategies:
[17:46:45.373] 1. sequential:
[17:46:45.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.373]    - tweaked: FALSE
[17:46:45.373]    - call: NULL
[17:46:45.374] 
[17:46:45.374] plan(): nbrOfWorkers() = 1
[17:46:45.374] Searching for globals ... DONE
[17:46:45.374] - globals: [0] <none>
[17:46:45.374] getGlobalsAndPackages() ... DONE
[17:46:45.375] run() for ‘Future’ ...
[17:46:45.375] - state: ‘created’
[17:46:45.375] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.376] plan(): Setting new future strategy stack:
[17:46:45.376] List of future strategies:
[17:46:45.376] 1. multicore:
[17:46:45.376]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.376]    - tweaked: FALSE
[17:46:45.376]    - call: plan(strategy)
[17:46:45.380] plan(): nbrOfWorkers() = 2
[17:46:45.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.381]   - Field: ‘label’
[17:46:45.381]   - Field: ‘local’
[17:46:45.381]   - Field: ‘owner’
[17:46:45.381]   - Field: ‘envir’
[17:46:45.381]   - Field: ‘workers’
[17:46:45.382]   - Field: ‘packages’
[17:46:45.382]   - Field: ‘gc’
[17:46:45.382]   - Field: ‘job’
[17:46:45.382]   - Field: ‘conditions’
[17:46:45.382]   - Field: ‘expr’
[17:46:45.382]   - Field: ‘uuid’
[17:46:45.383]   - Field: ‘seed’
[17:46:45.383]   - Field: ‘version’
[17:46:45.383]   - Field: ‘result’
[17:46:45.383]   - Field: ‘asynchronous’
[17:46:45.383]   - Field: ‘calls’
[17:46:45.383]   - Field: ‘globals’
[17:46:45.383]   - Field: ‘stdout’
[17:46:45.384]   - Field: ‘earlySignal’
[17:46:45.384]   - Field: ‘lazy’
[17:46:45.384]   - Field: ‘state’
[17:46:45.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.384] - Launch lazy future ...
[17:46:45.385] Packages needed by the future expression (n = 0): <none>
[17:46:45.385] Packages needed by future strategies (n = 0): <none>
[17:46:45.386] {
[17:46:45.386]     {
[17:46:45.386]         {
[17:46:45.386]             ...future.startTime <- base::Sys.time()
[17:46:45.386]             {
[17:46:45.386]                 {
[17:46:45.386]                   {
[17:46:45.386]                     {
[17:46:45.386]                       base::local({
[17:46:45.386]                         has_future <- base::requireNamespace("future", 
[17:46:45.386]                           quietly = TRUE)
[17:46:45.386]                         if (has_future) {
[17:46:45.386]                           ns <- base::getNamespace("future")
[17:46:45.386]                           version <- ns[[".package"]][["version"]]
[17:46:45.386]                           if (is.null(version)) 
[17:46:45.386]                             version <- utils::packageVersion("future")
[17:46:45.386]                         }
[17:46:45.386]                         else {
[17:46:45.386]                           version <- NULL
[17:46:45.386]                         }
[17:46:45.386]                         if (!has_future || version < "1.8.0") {
[17:46:45.386]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.386]                             "", base::R.version$version.string), 
[17:46:45.386]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.386]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.386]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.386]                               "release", "version")], collapse = " "), 
[17:46:45.386]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.386]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.386]                             info)
[17:46:45.386]                           info <- base::paste(info, collapse = "; ")
[17:46:45.386]                           if (!has_future) {
[17:46:45.386]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.386]                               info)
[17:46:45.386]                           }
[17:46:45.386]                           else {
[17:46:45.386]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.386]                               info, version)
[17:46:45.386]                           }
[17:46:45.386]                           base::stop(msg)
[17:46:45.386]                         }
[17:46:45.386]                       })
[17:46:45.386]                     }
[17:46:45.386]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.386]                     base::options(mc.cores = 1L)
[17:46:45.386]                   }
[17:46:45.386]                   ...future.strategy.old <- future::plan("list")
[17:46:45.386]                   options(future.plan = NULL)
[17:46:45.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.386]                 }
[17:46:45.386]                 ...future.workdir <- getwd()
[17:46:45.386]             }
[17:46:45.386]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.386]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.386]         }
[17:46:45.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.386]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.386]             base::names(...future.oldOptions))
[17:46:45.386]     }
[17:46:45.386]     if (FALSE) {
[17:46:45.386]     }
[17:46:45.386]     else {
[17:46:45.386]         if (TRUE) {
[17:46:45.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.386]                 open = "w")
[17:46:45.386]         }
[17:46:45.386]         else {
[17:46:45.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.386]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.386]         }
[17:46:45.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.386]             base::sink(type = "output", split = FALSE)
[17:46:45.386]             base::close(...future.stdout)
[17:46:45.386]         }, add = TRUE)
[17:46:45.386]     }
[17:46:45.386]     ...future.frame <- base::sys.nframe()
[17:46:45.386]     ...future.conditions <- base::list()
[17:46:45.386]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.386]     if (FALSE) {
[17:46:45.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.386]     }
[17:46:45.386]     ...future.result <- base::tryCatch({
[17:46:45.386]         base::withCallingHandlers({
[17:46:45.386]             ...future.value <- base::withVisible(base::local({
[17:46:45.386]                 withCallingHandlers({
[17:46:45.386]                   NULL
[17:46:45.386]                 }, immediateCondition = function(cond) {
[17:46:45.386]                   save_rds <- function (object, pathname, ...) 
[17:46:45.386]                   {
[17:46:45.386]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.386]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.386]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.386]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.386]                         fi_tmp[["mtime"]])
[17:46:45.386]                     }
[17:46:45.386]                     tryCatch({
[17:46:45.386]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.386]                     }, error = function(ex) {
[17:46:45.386]                       msg <- conditionMessage(ex)
[17:46:45.386]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.386]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.386]                         fi_tmp[["mtime"]], msg)
[17:46:45.386]                       ex$message <- msg
[17:46:45.386]                       stop(ex)
[17:46:45.386]                     })
[17:46:45.386]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.386]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.386]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.386]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.386]                       fi <- file.info(pathname)
[17:46:45.386]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.386]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.386]                         fi[["size"]], fi[["mtime"]])
[17:46:45.386]                       stop(msg)
[17:46:45.386]                     }
[17:46:45.386]                     invisible(pathname)
[17:46:45.386]                   }
[17:46:45.386]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.386]                     rootPath = tempdir()) 
[17:46:45.386]                   {
[17:46:45.386]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.386]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.386]                       tmpdir = path, fileext = ".rds")
[17:46:45.386]                     save_rds(obj, file)
[17:46:45.386]                   }
[17:46:45.386]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.386]                   {
[17:46:45.386]                     inherits <- base::inherits
[17:46:45.386]                     invokeRestart <- base::invokeRestart
[17:46:45.386]                     is.null <- base::is.null
[17:46:45.386]                     muffled <- FALSE
[17:46:45.386]                     if (inherits(cond, "message")) {
[17:46:45.386]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.386]                       if (muffled) 
[17:46:45.386]                         invokeRestart("muffleMessage")
[17:46:45.386]                     }
[17:46:45.386]                     else if (inherits(cond, "warning")) {
[17:46:45.386]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.386]                       if (muffled) 
[17:46:45.386]                         invokeRestart("muffleWarning")
[17:46:45.386]                     }
[17:46:45.386]                     else if (inherits(cond, "condition")) {
[17:46:45.386]                       if (!is.null(pattern)) {
[17:46:45.386]                         computeRestarts <- base::computeRestarts
[17:46:45.386]                         grepl <- base::grepl
[17:46:45.386]                         restarts <- computeRestarts(cond)
[17:46:45.386]                         for (restart in restarts) {
[17:46:45.386]                           name <- restart$name
[17:46:45.386]                           if (is.null(name)) 
[17:46:45.386]                             next
[17:46:45.386]                           if (!grepl(pattern, name)) 
[17:46:45.386]                             next
[17:46:45.386]                           invokeRestart(restart)
[17:46:45.386]                           muffled <- TRUE
[17:46:45.386]                           break
[17:46:45.386]                         }
[17:46:45.386]                       }
[17:46:45.386]                     }
[17:46:45.386]                     invisible(muffled)
[17:46:45.386]                   }
[17:46:45.386]                   muffleCondition(cond)
[17:46:45.386]                 })
[17:46:45.386]             }))
[17:46:45.386]             future::FutureResult(value = ...future.value$value, 
[17:46:45.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.386]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.386]                     ...future.globalenv.names))
[17:46:45.386]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.386]         }, condition = base::local({
[17:46:45.386]             c <- base::c
[17:46:45.386]             inherits <- base::inherits
[17:46:45.386]             invokeRestart <- base::invokeRestart
[17:46:45.386]             length <- base::length
[17:46:45.386]             list <- base::list
[17:46:45.386]             seq.int <- base::seq.int
[17:46:45.386]             signalCondition <- base::signalCondition
[17:46:45.386]             sys.calls <- base::sys.calls
[17:46:45.386]             `[[` <- base::`[[`
[17:46:45.386]             `+` <- base::`+`
[17:46:45.386]             `<<-` <- base::`<<-`
[17:46:45.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.386]                   3L)]
[17:46:45.386]             }
[17:46:45.386]             function(cond) {
[17:46:45.386]                 is_error <- inherits(cond, "error")
[17:46:45.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.386]                   NULL)
[17:46:45.386]                 if (is_error) {
[17:46:45.386]                   sessionInformation <- function() {
[17:46:45.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.386]                       search = base::search(), system = base::Sys.info())
[17:46:45.386]                   }
[17:46:45.386]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.386]                     cond$call), session = sessionInformation(), 
[17:46:45.386]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.386]                   signalCondition(cond)
[17:46:45.386]                 }
[17:46:45.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.386]                 "immediateCondition"))) {
[17:46:45.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.386]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.386]                   if (TRUE && !signal) {
[17:46:45.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.386]                     {
[17:46:45.386]                       inherits <- base::inherits
[17:46:45.386]                       invokeRestart <- base::invokeRestart
[17:46:45.386]                       is.null <- base::is.null
[17:46:45.386]                       muffled <- FALSE
[17:46:45.386]                       if (inherits(cond, "message")) {
[17:46:45.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.386]                         if (muffled) 
[17:46:45.386]                           invokeRestart("muffleMessage")
[17:46:45.386]                       }
[17:46:45.386]                       else if (inherits(cond, "warning")) {
[17:46:45.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.386]                         if (muffled) 
[17:46:45.386]                           invokeRestart("muffleWarning")
[17:46:45.386]                       }
[17:46:45.386]                       else if (inherits(cond, "condition")) {
[17:46:45.386]                         if (!is.null(pattern)) {
[17:46:45.386]                           computeRestarts <- base::computeRestarts
[17:46:45.386]                           grepl <- base::grepl
[17:46:45.386]                           restarts <- computeRestarts(cond)
[17:46:45.386]                           for (restart in restarts) {
[17:46:45.386]                             name <- restart$name
[17:46:45.386]                             if (is.null(name)) 
[17:46:45.386]                               next
[17:46:45.386]                             if (!grepl(pattern, name)) 
[17:46:45.386]                               next
[17:46:45.386]                             invokeRestart(restart)
[17:46:45.386]                             muffled <- TRUE
[17:46:45.386]                             break
[17:46:45.386]                           }
[17:46:45.386]                         }
[17:46:45.386]                       }
[17:46:45.386]                       invisible(muffled)
[17:46:45.386]                     }
[17:46:45.386]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.386]                   }
[17:46:45.386]                 }
[17:46:45.386]                 else {
[17:46:45.386]                   if (TRUE) {
[17:46:45.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.386]                     {
[17:46:45.386]                       inherits <- base::inherits
[17:46:45.386]                       invokeRestart <- base::invokeRestart
[17:46:45.386]                       is.null <- base::is.null
[17:46:45.386]                       muffled <- FALSE
[17:46:45.386]                       if (inherits(cond, "message")) {
[17:46:45.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.386]                         if (muffled) 
[17:46:45.386]                           invokeRestart("muffleMessage")
[17:46:45.386]                       }
[17:46:45.386]                       else if (inherits(cond, "warning")) {
[17:46:45.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.386]                         if (muffled) 
[17:46:45.386]                           invokeRestart("muffleWarning")
[17:46:45.386]                       }
[17:46:45.386]                       else if (inherits(cond, "condition")) {
[17:46:45.386]                         if (!is.null(pattern)) {
[17:46:45.386]                           computeRestarts <- base::computeRestarts
[17:46:45.386]                           grepl <- base::grepl
[17:46:45.386]                           restarts <- computeRestarts(cond)
[17:46:45.386]                           for (restart in restarts) {
[17:46:45.386]                             name <- restart$name
[17:46:45.386]                             if (is.null(name)) 
[17:46:45.386]                               next
[17:46:45.386]                             if (!grepl(pattern, name)) 
[17:46:45.386]                               next
[17:46:45.386]                             invokeRestart(restart)
[17:46:45.386]                             muffled <- TRUE
[17:46:45.386]                             break
[17:46:45.386]                           }
[17:46:45.386]                         }
[17:46:45.386]                       }
[17:46:45.386]                       invisible(muffled)
[17:46:45.386]                     }
[17:46:45.386]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.386]                   }
[17:46:45.386]                 }
[17:46:45.386]             }
[17:46:45.386]         }))
[17:46:45.386]     }, error = function(ex) {
[17:46:45.386]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.386]                 ...future.rng), started = ...future.startTime, 
[17:46:45.386]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.386]             version = "1.8"), class = "FutureResult")
[17:46:45.386]     }, finally = {
[17:46:45.386]         if (!identical(...future.workdir, getwd())) 
[17:46:45.386]             setwd(...future.workdir)
[17:46:45.386]         {
[17:46:45.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.386]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.386]             }
[17:46:45.386]             base::options(...future.oldOptions)
[17:46:45.386]             if (.Platform$OS.type == "windows") {
[17:46:45.386]                 old_names <- names(...future.oldEnvVars)
[17:46:45.386]                 envs <- base::Sys.getenv()
[17:46:45.386]                 names <- names(envs)
[17:46:45.386]                 common <- intersect(names, old_names)
[17:46:45.386]                 added <- setdiff(names, old_names)
[17:46:45.386]                 removed <- setdiff(old_names, names)
[17:46:45.386]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.386]                   envs[common]]
[17:46:45.386]                 NAMES <- toupper(changed)
[17:46:45.386]                 args <- list()
[17:46:45.386]                 for (kk in seq_along(NAMES)) {
[17:46:45.386]                   name <- changed[[kk]]
[17:46:45.386]                   NAME <- NAMES[[kk]]
[17:46:45.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.386]                     next
[17:46:45.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.386]                 }
[17:46:45.386]                 NAMES <- toupper(added)
[17:46:45.386]                 for (kk in seq_along(NAMES)) {
[17:46:45.386]                   name <- added[[kk]]
[17:46:45.386]                   NAME <- NAMES[[kk]]
[17:46:45.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.386]                     next
[17:46:45.386]                   args[[name]] <- ""
[17:46:45.386]                 }
[17:46:45.386]                 NAMES <- toupper(removed)
[17:46:45.386]                 for (kk in seq_along(NAMES)) {
[17:46:45.386]                   name <- removed[[kk]]
[17:46:45.386]                   NAME <- NAMES[[kk]]
[17:46:45.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.386]                     next
[17:46:45.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.386]                 }
[17:46:45.386]                 if (length(args) > 0) 
[17:46:45.386]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.386]             }
[17:46:45.386]             else {
[17:46:45.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.386]             }
[17:46:45.386]             {
[17:46:45.386]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.386]                   0L) {
[17:46:45.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.386]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.386]                   base::options(opts)
[17:46:45.386]                 }
[17:46:45.386]                 {
[17:46:45.386]                   {
[17:46:45.386]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.386]                     NULL
[17:46:45.386]                   }
[17:46:45.386]                   options(future.plan = NULL)
[17:46:45.386]                   if (is.na(NA_character_)) 
[17:46:45.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.386]                     .init = FALSE)
[17:46:45.386]                 }
[17:46:45.386]             }
[17:46:45.386]         }
[17:46:45.386]     })
[17:46:45.386]     if (TRUE) {
[17:46:45.386]         base::sink(type = "output", split = FALSE)
[17:46:45.386]         if (TRUE) {
[17:46:45.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.386]         }
[17:46:45.386]         else {
[17:46:45.386]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.386]         }
[17:46:45.386]         base::close(...future.stdout)
[17:46:45.386]         ...future.stdout <- NULL
[17:46:45.386]     }
[17:46:45.386]     ...future.result$conditions <- ...future.conditions
[17:46:45.386]     ...future.result$finished <- base::Sys.time()
[17:46:45.386]     ...future.result
[17:46:45.386] }
[17:46:45.389] requestCore(): workers = 2
[17:46:45.391] MulticoreFuture started
[17:46:45.391] - Launch lazy future ... done
[17:46:45.391] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[17:46:45.392] plan(): Setting new future strategy stack:
 num 1
 $ b:[17:46:45.392] List of future strategies:
[17:46:45.392] 1. sequential:
[17:46:45.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.392]    - tweaked: FALSE
[17:46:45.392]    - call: NULL
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56178821b458> 
 $ c:[17:46:45.394] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56178583e518> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[17:46:45.396] plan(): Setting new future strategy stack:
 num 1
 $ b:[17:46:45.396] List of future strategies:
[17:46:45.396] 1. multicore:
[17:46:45.396]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.396]    - tweaked: FALSE
[17:46:45.396]    - call: plan(strategy)
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56178821b458> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56178583e518> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:45.401] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:45.404] resolve() on list ...
[17:46:45.404]  recursive: 0
[17:46:45.404]  length: 6
[17:46:45.404]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:45.404] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.404] - nx: 6
[17:46:45.405] - relay: TRUE
[17:46:45.405] - stdout: TRUE
[17:46:45.405] - signal: TRUE
[17:46:45.405] - resignal: FALSE
[17:46:45.405] - force: TRUE
[17:46:45.405] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.405] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.406]  - until=2
[17:46:45.406]  - relaying element #2
[17:46:45.406] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.406] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.406] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.406]  length: 5 (resolved future 1)
[17:46:45.407] Future #2
[17:46:45.407] result() for MulticoreFuture ...
[17:46:45.408] result() for MulticoreFuture ...
[17:46:45.408] result() for MulticoreFuture ... done
[17:46:45.408] result() for MulticoreFuture ... done
[17:46:45.408] result() for MulticoreFuture ...
[17:46:45.408] result() for MulticoreFuture ... done
[17:46:45.408] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:45.409] - nx: 6
[17:46:45.409] - relay: TRUE
[17:46:45.409] - stdout: TRUE
[17:46:45.409] - signal: TRUE
[17:46:45.409] - resignal: FALSE
[17:46:45.409] - force: TRUE
[17:46:45.409] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.409] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.410]  - until=2
[17:46:45.410]  - relaying element #2
[17:46:45.410] result() for MulticoreFuture ...
[17:46:45.410] result() for MulticoreFuture ... done
[17:46:45.410] result() for MulticoreFuture ...
[17:46:45.410] result() for MulticoreFuture ... done
[17:46:45.410] result() for MulticoreFuture ...
[17:46:45.411] result() for MulticoreFuture ... done
[17:46:45.411] result() for MulticoreFuture ...
[17:46:45.411] result() for MulticoreFuture ... done
[17:46:45.411] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.411] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.411] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:45.411]  length: 4 (resolved future 2)
[17:46:45.412] Future #3
[17:46:45.412] result() for MulticoreFuture ...
[17:46:45.413] result() for MulticoreFuture ...
[17:46:45.413] result() for MulticoreFuture ... done
[17:46:45.413] result() for MulticoreFuture ... done
[17:46:45.413] result() for MulticoreFuture ...
[17:46:45.413] result() for MulticoreFuture ... done
[17:46:45.413] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:45.413] - nx: 6
[17:46:45.413] - relay: TRUE
[17:46:45.414] - stdout: TRUE
[17:46:45.416] - signal: TRUE
[17:46:45.417] - resignal: FALSE
[17:46:45.417] - force: TRUE
[17:46:45.417] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.417] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.417]  - until=3
[17:46:45.418]  - relaying element #3
[17:46:45.418] result() for MulticoreFuture ...
[17:46:45.418] result() for MulticoreFuture ... done
[17:46:45.418] result() for MulticoreFuture ...
[17:46:45.418] result() for MulticoreFuture ... done
[17:46:45.418] result() for MulticoreFuture ...
[17:46:45.418] result() for MulticoreFuture ... done
[17:46:45.419] result() for MulticoreFuture ...
[17:46:45.419] result() for MulticoreFuture ... done
[17:46:45.419] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.419] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.419] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:45.419]  length: 3 (resolved future 3)
[17:46:45.419] signalConditionsASAP(NULL, pos=4) ...
[17:46:45.420] - nx: 6
[17:46:45.420] - relay: TRUE
[17:46:45.420] - stdout: TRUE
[17:46:45.420] - signal: TRUE
[17:46:45.420] - resignal: FALSE
[17:46:45.420] - force: TRUE
[17:46:45.420] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.420] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.420]  - until=5
[17:46:45.421]  - relaying element #5
[17:46:45.421] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.421] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.421] signalConditionsASAP(NULL, pos=4) ... done
[17:46:45.421]  length: 2 (resolved future 4)
[17:46:45.421] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.421] - nx: 6
[17:46:45.421] - relay: TRUE
[17:46:45.421] - stdout: TRUE
[17:46:45.422] - signal: TRUE
[17:46:45.422] - resignal: FALSE
[17:46:45.422] - force: TRUE
[17:46:45.422] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.422] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.422]  - until=6
[17:46:45.422]  - relaying element #6
[17:46:45.422] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.422] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.423] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.423]  length: 1 (resolved future 5)
[17:46:45.423] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.423] - nx: 6
[17:46:45.423] - relay: TRUE
[17:46:45.423] - stdout: TRUE
[17:46:45.423] - signal: TRUE
[17:46:45.423] - resignal: FALSE
[17:46:45.423] - force: TRUE
[17:46:45.423] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.424] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.424]  - until=6
[17:46:45.424] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.424] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.424] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.424]  length: 0 (resolved future 6)
[17:46:45.424] Relaying remaining futures
[17:46:45.424] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.424] - nx: 6
[17:46:45.425] - relay: TRUE
[17:46:45.425] - stdout: TRUE
[17:46:45.425] - signal: TRUE
[17:46:45.425] - resignal: FALSE
[17:46:45.425] - force: TRUE
[17:46:45.425] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.425] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:45.425] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.425] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.425] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.426] resolve() on list ... DONE
[17:46:45.426] result() for MulticoreFuture ...
[17:46:45.426] result() for MulticoreFuture ... done
[17:46:45.426] result() for MulticoreFuture ...
[17:46:45.426] result() for MulticoreFuture ... done
[17:46:45.426] result() for MulticoreFuture ...
[17:46:45.426] result() for MulticoreFuture ... done
[17:46:45.426] result() for MulticoreFuture ...
[17:46:45.426] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:46:45.430] getGlobalsAndPackages() ...
[17:46:45.430] Searching for globals...
[17:46:45.431] 
[17:46:45.431] Searching for globals ... DONE
[17:46:45.431] - globals: [0] <none>
[17:46:45.431] getGlobalsAndPackages() ... DONE
[17:46:45.431] run() for ‘Future’ ...
[17:46:45.431] - state: ‘created’
[17:46:45.431] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.435]   - Field: ‘label’
[17:46:45.435]   - Field: ‘local’
[17:46:45.435]   - Field: ‘owner’
[17:46:45.436]   - Field: ‘envir’
[17:46:45.436]   - Field: ‘workers’
[17:46:45.436]   - Field: ‘packages’
[17:46:45.436]   - Field: ‘gc’
[17:46:45.436]   - Field: ‘job’
[17:46:45.436]   - Field: ‘conditions’
[17:46:45.436]   - Field: ‘expr’
[17:46:45.436]   - Field: ‘uuid’
[17:46:45.436]   - Field: ‘seed’
[17:46:45.436]   - Field: ‘version’
[17:46:45.436]   - Field: ‘result’
[17:46:45.437]   - Field: ‘asynchronous’
[17:46:45.437]   - Field: ‘calls’
[17:46:45.437]   - Field: ‘globals’
[17:46:45.437]   - Field: ‘stdout’
[17:46:45.437]   - Field: ‘earlySignal’
[17:46:45.437]   - Field: ‘lazy’
[17:46:45.437]   - Field: ‘state’
[17:46:45.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.437] - Launch lazy future ...
[17:46:45.438] Packages needed by the future expression (n = 0): <none>
[17:46:45.438] Packages needed by future strategies (n = 0): <none>
[17:46:45.438] {
[17:46:45.438]     {
[17:46:45.438]         {
[17:46:45.438]             ...future.startTime <- base::Sys.time()
[17:46:45.438]             {
[17:46:45.438]                 {
[17:46:45.438]                   {
[17:46:45.438]                     {
[17:46:45.438]                       base::local({
[17:46:45.438]                         has_future <- base::requireNamespace("future", 
[17:46:45.438]                           quietly = TRUE)
[17:46:45.438]                         if (has_future) {
[17:46:45.438]                           ns <- base::getNamespace("future")
[17:46:45.438]                           version <- ns[[".package"]][["version"]]
[17:46:45.438]                           if (is.null(version)) 
[17:46:45.438]                             version <- utils::packageVersion("future")
[17:46:45.438]                         }
[17:46:45.438]                         else {
[17:46:45.438]                           version <- NULL
[17:46:45.438]                         }
[17:46:45.438]                         if (!has_future || version < "1.8.0") {
[17:46:45.438]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.438]                             "", base::R.version$version.string), 
[17:46:45.438]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.438]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.438]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.438]                               "release", "version")], collapse = " "), 
[17:46:45.438]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.438]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.438]                             info)
[17:46:45.438]                           info <- base::paste(info, collapse = "; ")
[17:46:45.438]                           if (!has_future) {
[17:46:45.438]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.438]                               info)
[17:46:45.438]                           }
[17:46:45.438]                           else {
[17:46:45.438]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.438]                               info, version)
[17:46:45.438]                           }
[17:46:45.438]                           base::stop(msg)
[17:46:45.438]                         }
[17:46:45.438]                       })
[17:46:45.438]                     }
[17:46:45.438]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.438]                     base::options(mc.cores = 1L)
[17:46:45.438]                   }
[17:46:45.438]                   ...future.strategy.old <- future::plan("list")
[17:46:45.438]                   options(future.plan = NULL)
[17:46:45.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.438]                 }
[17:46:45.438]                 ...future.workdir <- getwd()
[17:46:45.438]             }
[17:46:45.438]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.438]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.438]         }
[17:46:45.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.438]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.438]             base::names(...future.oldOptions))
[17:46:45.438]     }
[17:46:45.438]     if (FALSE) {
[17:46:45.438]     }
[17:46:45.438]     else {
[17:46:45.438]         if (TRUE) {
[17:46:45.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.438]                 open = "w")
[17:46:45.438]         }
[17:46:45.438]         else {
[17:46:45.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.438]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.438]         }
[17:46:45.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.438]             base::sink(type = "output", split = FALSE)
[17:46:45.438]             base::close(...future.stdout)
[17:46:45.438]         }, add = TRUE)
[17:46:45.438]     }
[17:46:45.438]     ...future.frame <- base::sys.nframe()
[17:46:45.438]     ...future.conditions <- base::list()
[17:46:45.438]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.438]     if (FALSE) {
[17:46:45.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.438]     }
[17:46:45.438]     ...future.result <- base::tryCatch({
[17:46:45.438]         base::withCallingHandlers({
[17:46:45.438]             ...future.value <- base::withVisible(base::local({
[17:46:45.438]                 withCallingHandlers({
[17:46:45.438]                   2
[17:46:45.438]                 }, immediateCondition = function(cond) {
[17:46:45.438]                   save_rds <- function (object, pathname, ...) 
[17:46:45.438]                   {
[17:46:45.438]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.438]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.438]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.438]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.438]                         fi_tmp[["mtime"]])
[17:46:45.438]                     }
[17:46:45.438]                     tryCatch({
[17:46:45.438]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.438]                     }, error = function(ex) {
[17:46:45.438]                       msg <- conditionMessage(ex)
[17:46:45.438]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.438]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.438]                         fi_tmp[["mtime"]], msg)
[17:46:45.438]                       ex$message <- msg
[17:46:45.438]                       stop(ex)
[17:46:45.438]                     })
[17:46:45.438]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.438]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.438]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.438]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.438]                       fi <- file.info(pathname)
[17:46:45.438]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.438]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.438]                         fi[["size"]], fi[["mtime"]])
[17:46:45.438]                       stop(msg)
[17:46:45.438]                     }
[17:46:45.438]                     invisible(pathname)
[17:46:45.438]                   }
[17:46:45.438]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.438]                     rootPath = tempdir()) 
[17:46:45.438]                   {
[17:46:45.438]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.438]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.438]                       tmpdir = path, fileext = ".rds")
[17:46:45.438]                     save_rds(obj, file)
[17:46:45.438]                   }
[17:46:45.438]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.438]                   {
[17:46:45.438]                     inherits <- base::inherits
[17:46:45.438]                     invokeRestart <- base::invokeRestart
[17:46:45.438]                     is.null <- base::is.null
[17:46:45.438]                     muffled <- FALSE
[17:46:45.438]                     if (inherits(cond, "message")) {
[17:46:45.438]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.438]                       if (muffled) 
[17:46:45.438]                         invokeRestart("muffleMessage")
[17:46:45.438]                     }
[17:46:45.438]                     else if (inherits(cond, "warning")) {
[17:46:45.438]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.438]                       if (muffled) 
[17:46:45.438]                         invokeRestart("muffleWarning")
[17:46:45.438]                     }
[17:46:45.438]                     else if (inherits(cond, "condition")) {
[17:46:45.438]                       if (!is.null(pattern)) {
[17:46:45.438]                         computeRestarts <- base::computeRestarts
[17:46:45.438]                         grepl <- base::grepl
[17:46:45.438]                         restarts <- computeRestarts(cond)
[17:46:45.438]                         for (restart in restarts) {
[17:46:45.438]                           name <- restart$name
[17:46:45.438]                           if (is.null(name)) 
[17:46:45.438]                             next
[17:46:45.438]                           if (!grepl(pattern, name)) 
[17:46:45.438]                             next
[17:46:45.438]                           invokeRestart(restart)
[17:46:45.438]                           muffled <- TRUE
[17:46:45.438]                           break
[17:46:45.438]                         }
[17:46:45.438]                       }
[17:46:45.438]                     }
[17:46:45.438]                     invisible(muffled)
[17:46:45.438]                   }
[17:46:45.438]                   muffleCondition(cond)
[17:46:45.438]                 })
[17:46:45.438]             }))
[17:46:45.438]             future::FutureResult(value = ...future.value$value, 
[17:46:45.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.438]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.438]                     ...future.globalenv.names))
[17:46:45.438]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.438]         }, condition = base::local({
[17:46:45.438]             c <- base::c
[17:46:45.438]             inherits <- base::inherits
[17:46:45.438]             invokeRestart <- base::invokeRestart
[17:46:45.438]             length <- base::length
[17:46:45.438]             list <- base::list
[17:46:45.438]             seq.int <- base::seq.int
[17:46:45.438]             signalCondition <- base::signalCondition
[17:46:45.438]             sys.calls <- base::sys.calls
[17:46:45.438]             `[[` <- base::`[[`
[17:46:45.438]             `+` <- base::`+`
[17:46:45.438]             `<<-` <- base::`<<-`
[17:46:45.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.438]                   3L)]
[17:46:45.438]             }
[17:46:45.438]             function(cond) {
[17:46:45.438]                 is_error <- inherits(cond, "error")
[17:46:45.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.438]                   NULL)
[17:46:45.438]                 if (is_error) {
[17:46:45.438]                   sessionInformation <- function() {
[17:46:45.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.438]                       search = base::search(), system = base::Sys.info())
[17:46:45.438]                   }
[17:46:45.438]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.438]                     cond$call), session = sessionInformation(), 
[17:46:45.438]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.438]                   signalCondition(cond)
[17:46:45.438]                 }
[17:46:45.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.438]                 "immediateCondition"))) {
[17:46:45.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.438]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.438]                   if (TRUE && !signal) {
[17:46:45.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.438]                     {
[17:46:45.438]                       inherits <- base::inherits
[17:46:45.438]                       invokeRestart <- base::invokeRestart
[17:46:45.438]                       is.null <- base::is.null
[17:46:45.438]                       muffled <- FALSE
[17:46:45.438]                       if (inherits(cond, "message")) {
[17:46:45.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.438]                         if (muffled) 
[17:46:45.438]                           invokeRestart("muffleMessage")
[17:46:45.438]                       }
[17:46:45.438]                       else if (inherits(cond, "warning")) {
[17:46:45.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.438]                         if (muffled) 
[17:46:45.438]                           invokeRestart("muffleWarning")
[17:46:45.438]                       }
[17:46:45.438]                       else if (inherits(cond, "condition")) {
[17:46:45.438]                         if (!is.null(pattern)) {
[17:46:45.438]                           computeRestarts <- base::computeRestarts
[17:46:45.438]                           grepl <- base::grepl
[17:46:45.438]                           restarts <- computeRestarts(cond)
[17:46:45.438]                           for (restart in restarts) {
[17:46:45.438]                             name <- restart$name
[17:46:45.438]                             if (is.null(name)) 
[17:46:45.438]                               next
[17:46:45.438]                             if (!grepl(pattern, name)) 
[17:46:45.438]                               next
[17:46:45.438]                             invokeRestart(restart)
[17:46:45.438]                             muffled <- TRUE
[17:46:45.438]                             break
[17:46:45.438]                           }
[17:46:45.438]                         }
[17:46:45.438]                       }
[17:46:45.438]                       invisible(muffled)
[17:46:45.438]                     }
[17:46:45.438]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.438]                   }
[17:46:45.438]                 }
[17:46:45.438]                 else {
[17:46:45.438]                   if (TRUE) {
[17:46:45.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.438]                     {
[17:46:45.438]                       inherits <- base::inherits
[17:46:45.438]                       invokeRestart <- base::invokeRestart
[17:46:45.438]                       is.null <- base::is.null
[17:46:45.438]                       muffled <- FALSE
[17:46:45.438]                       if (inherits(cond, "message")) {
[17:46:45.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.438]                         if (muffled) 
[17:46:45.438]                           invokeRestart("muffleMessage")
[17:46:45.438]                       }
[17:46:45.438]                       else if (inherits(cond, "warning")) {
[17:46:45.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.438]                         if (muffled) 
[17:46:45.438]                           invokeRestart("muffleWarning")
[17:46:45.438]                       }
[17:46:45.438]                       else if (inherits(cond, "condition")) {
[17:46:45.438]                         if (!is.null(pattern)) {
[17:46:45.438]                           computeRestarts <- base::computeRestarts
[17:46:45.438]                           grepl <- base::grepl
[17:46:45.438]                           restarts <- computeRestarts(cond)
[17:46:45.438]                           for (restart in restarts) {
[17:46:45.438]                             name <- restart$name
[17:46:45.438]                             if (is.null(name)) 
[17:46:45.438]                               next
[17:46:45.438]                             if (!grepl(pattern, name)) 
[17:46:45.438]                               next
[17:46:45.438]                             invokeRestart(restart)
[17:46:45.438]                             muffled <- TRUE
[17:46:45.438]                             break
[17:46:45.438]                           }
[17:46:45.438]                         }
[17:46:45.438]                       }
[17:46:45.438]                       invisible(muffled)
[17:46:45.438]                     }
[17:46:45.438]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.438]                   }
[17:46:45.438]                 }
[17:46:45.438]             }
[17:46:45.438]         }))
[17:46:45.438]     }, error = function(ex) {
[17:46:45.438]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.438]                 ...future.rng), started = ...future.startTime, 
[17:46:45.438]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.438]             version = "1.8"), class = "FutureResult")
[17:46:45.438]     }, finally = {
[17:46:45.438]         if (!identical(...future.workdir, getwd())) 
[17:46:45.438]             setwd(...future.workdir)
[17:46:45.438]         {
[17:46:45.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.438]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.438]             }
[17:46:45.438]             base::options(...future.oldOptions)
[17:46:45.438]             if (.Platform$OS.type == "windows") {
[17:46:45.438]                 old_names <- names(...future.oldEnvVars)
[17:46:45.438]                 envs <- base::Sys.getenv()
[17:46:45.438]                 names <- names(envs)
[17:46:45.438]                 common <- intersect(names, old_names)
[17:46:45.438]                 added <- setdiff(names, old_names)
[17:46:45.438]                 removed <- setdiff(old_names, names)
[17:46:45.438]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.438]                   envs[common]]
[17:46:45.438]                 NAMES <- toupper(changed)
[17:46:45.438]                 args <- list()
[17:46:45.438]                 for (kk in seq_along(NAMES)) {
[17:46:45.438]                   name <- changed[[kk]]
[17:46:45.438]                   NAME <- NAMES[[kk]]
[17:46:45.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.438]                     next
[17:46:45.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.438]                 }
[17:46:45.438]                 NAMES <- toupper(added)
[17:46:45.438]                 for (kk in seq_along(NAMES)) {
[17:46:45.438]                   name <- added[[kk]]
[17:46:45.438]                   NAME <- NAMES[[kk]]
[17:46:45.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.438]                     next
[17:46:45.438]                   args[[name]] <- ""
[17:46:45.438]                 }
[17:46:45.438]                 NAMES <- toupper(removed)
[17:46:45.438]                 for (kk in seq_along(NAMES)) {
[17:46:45.438]                   name <- removed[[kk]]
[17:46:45.438]                   NAME <- NAMES[[kk]]
[17:46:45.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.438]                     next
[17:46:45.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.438]                 }
[17:46:45.438]                 if (length(args) > 0) 
[17:46:45.438]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.438]             }
[17:46:45.438]             else {
[17:46:45.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.438]             }
[17:46:45.438]             {
[17:46:45.438]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.438]                   0L) {
[17:46:45.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.438]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.438]                   base::options(opts)
[17:46:45.438]                 }
[17:46:45.438]                 {
[17:46:45.438]                   {
[17:46:45.438]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.438]                     NULL
[17:46:45.438]                   }
[17:46:45.438]                   options(future.plan = NULL)
[17:46:45.438]                   if (is.na(NA_character_)) 
[17:46:45.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.438]                     .init = FALSE)
[17:46:45.438]                 }
[17:46:45.438]             }
[17:46:45.438]         }
[17:46:45.438]     })
[17:46:45.438]     if (TRUE) {
[17:46:45.438]         base::sink(type = "output", split = FALSE)
[17:46:45.438]         if (TRUE) {
[17:46:45.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.438]         }
[17:46:45.438]         else {
[17:46:45.438]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.438]         }
[17:46:45.438]         base::close(...future.stdout)
[17:46:45.438]         ...future.stdout <- NULL
[17:46:45.438]     }
[17:46:45.438]     ...future.result$conditions <- ...future.conditions
[17:46:45.438]     ...future.result$finished <- base::Sys.time()
[17:46:45.438]     ...future.result
[17:46:45.438] }
[17:46:45.440] requestCore(): workers = 2
[17:46:45.442] MulticoreFuture started
[17:46:45.442] - Launch lazy future ... done
[17:46:45.443] run() for ‘MulticoreFuture’ ... done
[17:46:45.443] getGlobalsAndPackages() ...
[17:46:45.443] Searching for globals...
[17:46:45.443] plan(): Setting new future strategy stack:
[17:46:45.444] 
[17:46:45.444] Searching for globals ... DONE
[17:46:45.444] List of future strategies:
[17:46:45.444] 1. sequential:
[17:46:45.444]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.444]    - tweaked: FALSE
[17:46:45.444]    - call: NULL
[17:46:45.444] - globals: [0] <none>
[17:46:45.444] getGlobalsAndPackages() ... DONE
[17:46:45.445] plan(): nbrOfWorkers() = 1
[17:46:45.445] run() for ‘Future’ ...
[17:46:45.445] - state: ‘created’
[17:46:45.445] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:45.446] plan(): Setting new future strategy stack:
[17:46:45.447] List of future strategies:
[17:46:45.447] 1. multicore:
[17:46:45.447]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.447]    - tweaked: FALSE
[17:46:45.447]    - call: plan(strategy)
[17:46:45.450] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:45.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:45.451]   - Field: ‘label’
[17:46:45.451] plan(): nbrOfWorkers() = 2
[17:46:45.451]   - Field: ‘local’
[17:46:45.451]   - Field: ‘owner’
[17:46:45.451]   - Field: ‘envir’
[17:46:45.451]   - Field: ‘workers’
[17:46:45.451]   - Field: ‘packages’
[17:46:45.452]   - Field: ‘gc’
[17:46:45.452]   - Field: ‘job’
[17:46:45.452]   - Field: ‘conditions’
[17:46:45.452]   - Field: ‘expr’
[17:46:45.452]   - Field: ‘uuid’
[17:46:45.452]   - Field: ‘seed’
[17:46:45.452]   - Field: ‘version’
[17:46:45.453]   - Field: ‘result’
[17:46:45.453]   - Field: ‘asynchronous’
[17:46:45.453]   - Field: ‘calls’
[17:46:45.453]   - Field: ‘globals’
[17:46:45.453]   - Field: ‘stdout’
[17:46:45.453]   - Field: ‘earlySignal’
[17:46:45.453]   - Field: ‘lazy’
[17:46:45.454]   - Field: ‘state’
[17:46:45.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:45.454] - Launch lazy future ...
[17:46:45.454] Packages needed by the future expression (n = 0): <none>
[17:46:45.455] Packages needed by future strategies (n = 0): <none>
[17:46:45.455] {
[17:46:45.455]     {
[17:46:45.455]         {
[17:46:45.455]             ...future.startTime <- base::Sys.time()
[17:46:45.455]             {
[17:46:45.455]                 {
[17:46:45.455]                   {
[17:46:45.455]                     {
[17:46:45.455]                       base::local({
[17:46:45.455]                         has_future <- base::requireNamespace("future", 
[17:46:45.455]                           quietly = TRUE)
[17:46:45.455]                         if (has_future) {
[17:46:45.455]                           ns <- base::getNamespace("future")
[17:46:45.455]                           version <- ns[[".package"]][["version"]]
[17:46:45.455]                           if (is.null(version)) 
[17:46:45.455]                             version <- utils::packageVersion("future")
[17:46:45.455]                         }
[17:46:45.455]                         else {
[17:46:45.455]                           version <- NULL
[17:46:45.455]                         }
[17:46:45.455]                         if (!has_future || version < "1.8.0") {
[17:46:45.455]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:45.455]                             "", base::R.version$version.string), 
[17:46:45.455]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:45.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:45.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:45.455]                               "release", "version")], collapse = " "), 
[17:46:45.455]                             hostname = base::Sys.info()[["nodename"]])
[17:46:45.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:45.455]                             info)
[17:46:45.455]                           info <- base::paste(info, collapse = "; ")
[17:46:45.455]                           if (!has_future) {
[17:46:45.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:45.455]                               info)
[17:46:45.455]                           }
[17:46:45.455]                           else {
[17:46:45.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:45.455]                               info, version)
[17:46:45.455]                           }
[17:46:45.455]                           base::stop(msg)
[17:46:45.455]                         }
[17:46:45.455]                       })
[17:46:45.455]                     }
[17:46:45.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:45.455]                     base::options(mc.cores = 1L)
[17:46:45.455]                   }
[17:46:45.455]                   ...future.strategy.old <- future::plan("list")
[17:46:45.455]                   options(future.plan = NULL)
[17:46:45.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:45.455]                 }
[17:46:45.455]                 ...future.workdir <- getwd()
[17:46:45.455]             }
[17:46:45.455]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:45.455]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:45.455]         }
[17:46:45.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:45.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:45.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:45.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:45.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:45.455]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:45.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:45.455]             base::names(...future.oldOptions))
[17:46:45.455]     }
[17:46:45.455]     if (FALSE) {
[17:46:45.455]     }
[17:46:45.455]     else {
[17:46:45.455]         if (TRUE) {
[17:46:45.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:45.455]                 open = "w")
[17:46:45.455]         }
[17:46:45.455]         else {
[17:46:45.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:45.455]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:45.455]         }
[17:46:45.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:45.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:45.455]             base::sink(type = "output", split = FALSE)
[17:46:45.455]             base::close(...future.stdout)
[17:46:45.455]         }, add = TRUE)
[17:46:45.455]     }
[17:46:45.455]     ...future.frame <- base::sys.nframe()
[17:46:45.455]     ...future.conditions <- base::list()
[17:46:45.455]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:45.455]     if (FALSE) {
[17:46:45.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:45.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:45.455]     }
[17:46:45.455]     ...future.result <- base::tryCatch({
[17:46:45.455]         base::withCallingHandlers({
[17:46:45.455]             ...future.value <- base::withVisible(base::local({
[17:46:45.455]                 withCallingHandlers({
[17:46:45.455]                   NULL
[17:46:45.455]                 }, immediateCondition = function(cond) {
[17:46:45.455]                   save_rds <- function (object, pathname, ...) 
[17:46:45.455]                   {
[17:46:45.455]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:45.455]                     if (file_test("-f", pathname_tmp)) {
[17:46:45.455]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.455]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:45.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.455]                         fi_tmp[["mtime"]])
[17:46:45.455]                     }
[17:46:45.455]                     tryCatch({
[17:46:45.455]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:45.455]                     }, error = function(ex) {
[17:46:45.455]                       msg <- conditionMessage(ex)
[17:46:45.455]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.455]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:45.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.455]                         fi_tmp[["mtime"]], msg)
[17:46:45.455]                       ex$message <- msg
[17:46:45.455]                       stop(ex)
[17:46:45.455]                     })
[17:46:45.455]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:45.455]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:45.455]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:45.455]                       fi_tmp <- file.info(pathname_tmp)
[17:46:45.455]                       fi <- file.info(pathname)
[17:46:45.455]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:45.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:45.455]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:45.455]                         fi[["size"]], fi[["mtime"]])
[17:46:45.455]                       stop(msg)
[17:46:45.455]                     }
[17:46:45.455]                     invisible(pathname)
[17:46:45.455]                   }
[17:46:45.455]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:45.455]                     rootPath = tempdir()) 
[17:46:45.455]                   {
[17:46:45.455]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:45.455]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:45.455]                       tmpdir = path, fileext = ".rds")
[17:46:45.455]                     save_rds(obj, file)
[17:46:45.455]                   }
[17:46:45.455]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:45.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.455]                   {
[17:46:45.455]                     inherits <- base::inherits
[17:46:45.455]                     invokeRestart <- base::invokeRestart
[17:46:45.455]                     is.null <- base::is.null
[17:46:45.455]                     muffled <- FALSE
[17:46:45.455]                     if (inherits(cond, "message")) {
[17:46:45.455]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:45.455]                       if (muffled) 
[17:46:45.455]                         invokeRestart("muffleMessage")
[17:46:45.455]                     }
[17:46:45.455]                     else if (inherits(cond, "warning")) {
[17:46:45.455]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:45.455]                       if (muffled) 
[17:46:45.455]                         invokeRestart("muffleWarning")
[17:46:45.455]                     }
[17:46:45.455]                     else if (inherits(cond, "condition")) {
[17:46:45.455]                       if (!is.null(pattern)) {
[17:46:45.455]                         computeRestarts <- base::computeRestarts
[17:46:45.455]                         grepl <- base::grepl
[17:46:45.455]                         restarts <- computeRestarts(cond)
[17:46:45.455]                         for (restart in restarts) {
[17:46:45.455]                           name <- restart$name
[17:46:45.455]                           if (is.null(name)) 
[17:46:45.455]                             next
[17:46:45.455]                           if (!grepl(pattern, name)) 
[17:46:45.455]                             next
[17:46:45.455]                           invokeRestart(restart)
[17:46:45.455]                           muffled <- TRUE
[17:46:45.455]                           break
[17:46:45.455]                         }
[17:46:45.455]                       }
[17:46:45.455]                     }
[17:46:45.455]                     invisible(muffled)
[17:46:45.455]                   }
[17:46:45.455]                   muffleCondition(cond)
[17:46:45.455]                 })
[17:46:45.455]             }))
[17:46:45.455]             future::FutureResult(value = ...future.value$value, 
[17:46:45.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.455]                   ...future.rng), globalenv = if (FALSE) 
[17:46:45.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:45.455]                     ...future.globalenv.names))
[17:46:45.455]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:45.455]         }, condition = base::local({
[17:46:45.455]             c <- base::c
[17:46:45.455]             inherits <- base::inherits
[17:46:45.455]             invokeRestart <- base::invokeRestart
[17:46:45.455]             length <- base::length
[17:46:45.455]             list <- base::list
[17:46:45.455]             seq.int <- base::seq.int
[17:46:45.455]             signalCondition <- base::signalCondition
[17:46:45.455]             sys.calls <- base::sys.calls
[17:46:45.455]             `[[` <- base::`[[`
[17:46:45.455]             `+` <- base::`+`
[17:46:45.455]             `<<-` <- base::`<<-`
[17:46:45.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:45.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:45.455]                   3L)]
[17:46:45.455]             }
[17:46:45.455]             function(cond) {
[17:46:45.455]                 is_error <- inherits(cond, "error")
[17:46:45.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:45.455]                   NULL)
[17:46:45.455]                 if (is_error) {
[17:46:45.455]                   sessionInformation <- function() {
[17:46:45.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:45.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:45.455]                       search = base::search(), system = base::Sys.info())
[17:46:45.455]                   }
[17:46:45.455]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:45.455]                     cond$call), session = sessionInformation(), 
[17:46:45.455]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:45.455]                   signalCondition(cond)
[17:46:45.455]                 }
[17:46:45.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:45.455]                 "immediateCondition"))) {
[17:46:45.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:45.455]                   ...future.conditions[[length(...future.conditions) + 
[17:46:45.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:45.455]                   if (TRUE && !signal) {
[17:46:45.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.455]                     {
[17:46:45.455]                       inherits <- base::inherits
[17:46:45.455]                       invokeRestart <- base::invokeRestart
[17:46:45.455]                       is.null <- base::is.null
[17:46:45.455]                       muffled <- FALSE
[17:46:45.455]                       if (inherits(cond, "message")) {
[17:46:45.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.455]                         if (muffled) 
[17:46:45.455]                           invokeRestart("muffleMessage")
[17:46:45.455]                       }
[17:46:45.455]                       else if (inherits(cond, "warning")) {
[17:46:45.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.455]                         if (muffled) 
[17:46:45.455]                           invokeRestart("muffleWarning")
[17:46:45.455]                       }
[17:46:45.455]                       else if (inherits(cond, "condition")) {
[17:46:45.455]                         if (!is.null(pattern)) {
[17:46:45.455]                           computeRestarts <- base::computeRestarts
[17:46:45.455]                           grepl <- base::grepl
[17:46:45.455]                           restarts <- computeRestarts(cond)
[17:46:45.455]                           for (restart in restarts) {
[17:46:45.455]                             name <- restart$name
[17:46:45.455]                             if (is.null(name)) 
[17:46:45.455]                               next
[17:46:45.455]                             if (!grepl(pattern, name)) 
[17:46:45.455]                               next
[17:46:45.455]                             invokeRestart(restart)
[17:46:45.455]                             muffled <- TRUE
[17:46:45.455]                             break
[17:46:45.455]                           }
[17:46:45.455]                         }
[17:46:45.455]                       }
[17:46:45.455]                       invisible(muffled)
[17:46:45.455]                     }
[17:46:45.455]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.455]                   }
[17:46:45.455]                 }
[17:46:45.455]                 else {
[17:46:45.455]                   if (TRUE) {
[17:46:45.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:45.455]                     {
[17:46:45.455]                       inherits <- base::inherits
[17:46:45.455]                       invokeRestart <- base::invokeRestart
[17:46:45.455]                       is.null <- base::is.null
[17:46:45.455]                       muffled <- FALSE
[17:46:45.455]                       if (inherits(cond, "message")) {
[17:46:45.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:45.455]                         if (muffled) 
[17:46:45.455]                           invokeRestart("muffleMessage")
[17:46:45.455]                       }
[17:46:45.455]                       else if (inherits(cond, "warning")) {
[17:46:45.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:45.455]                         if (muffled) 
[17:46:45.455]                           invokeRestart("muffleWarning")
[17:46:45.455]                       }
[17:46:45.455]                       else if (inherits(cond, "condition")) {
[17:46:45.455]                         if (!is.null(pattern)) {
[17:46:45.455]                           computeRestarts <- base::computeRestarts
[17:46:45.455]                           grepl <- base::grepl
[17:46:45.455]                           restarts <- computeRestarts(cond)
[17:46:45.455]                           for (restart in restarts) {
[17:46:45.455]                             name <- restart$name
[17:46:45.455]                             if (is.null(name)) 
[17:46:45.455]                               next
[17:46:45.455]                             if (!grepl(pattern, name)) 
[17:46:45.455]                               next
[17:46:45.455]                             invokeRestart(restart)
[17:46:45.455]                             muffled <- TRUE
[17:46:45.455]                             break
[17:46:45.455]                           }
[17:46:45.455]                         }
[17:46:45.455]                       }
[17:46:45.455]                       invisible(muffled)
[17:46:45.455]                     }
[17:46:45.455]                     muffleCondition(cond, pattern = "^muffle")
[17:46:45.455]                   }
[17:46:45.455]                 }
[17:46:45.455]             }
[17:46:45.455]         }))
[17:46:45.455]     }, error = function(ex) {
[17:46:45.455]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:45.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:45.455]                 ...future.rng), started = ...future.startTime, 
[17:46:45.455]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:45.455]             version = "1.8"), class = "FutureResult")
[17:46:45.455]     }, finally = {
[17:46:45.455]         if (!identical(...future.workdir, getwd())) 
[17:46:45.455]             setwd(...future.workdir)
[17:46:45.455]         {
[17:46:45.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:45.455]                 ...future.oldOptions$nwarnings <- NULL
[17:46:45.455]             }
[17:46:45.455]             base::options(...future.oldOptions)
[17:46:45.455]             if (.Platform$OS.type == "windows") {
[17:46:45.455]                 old_names <- names(...future.oldEnvVars)
[17:46:45.455]                 envs <- base::Sys.getenv()
[17:46:45.455]                 names <- names(envs)
[17:46:45.455]                 common <- intersect(names, old_names)
[17:46:45.455]                 added <- setdiff(names, old_names)
[17:46:45.455]                 removed <- setdiff(old_names, names)
[17:46:45.455]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:45.455]                   envs[common]]
[17:46:45.455]                 NAMES <- toupper(changed)
[17:46:45.455]                 args <- list()
[17:46:45.455]                 for (kk in seq_along(NAMES)) {
[17:46:45.455]                   name <- changed[[kk]]
[17:46:45.455]                   NAME <- NAMES[[kk]]
[17:46:45.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.455]                     next
[17:46:45.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.455]                 }
[17:46:45.455]                 NAMES <- toupper(added)
[17:46:45.455]                 for (kk in seq_along(NAMES)) {
[17:46:45.455]                   name <- added[[kk]]
[17:46:45.455]                   NAME <- NAMES[[kk]]
[17:46:45.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.455]                     next
[17:46:45.455]                   args[[name]] <- ""
[17:46:45.455]                 }
[17:46:45.455]                 NAMES <- toupper(removed)
[17:46:45.455]                 for (kk in seq_along(NAMES)) {
[17:46:45.455]                   name <- removed[[kk]]
[17:46:45.455]                   NAME <- NAMES[[kk]]
[17:46:45.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:45.455]                     next
[17:46:45.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:45.455]                 }
[17:46:45.455]                 if (length(args) > 0) 
[17:46:45.455]                   base::do.call(base::Sys.setenv, args = args)
[17:46:45.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:45.455]             }
[17:46:45.455]             else {
[17:46:45.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:45.455]             }
[17:46:45.455]             {
[17:46:45.455]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:45.455]                   0L) {
[17:46:45.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:45.455]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:45.455]                   base::options(opts)
[17:46:45.455]                 }
[17:46:45.455]                 {
[17:46:45.455]                   {
[17:46:45.455]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:45.455]                     NULL
[17:46:45.455]                   }
[17:46:45.455]                   options(future.plan = NULL)
[17:46:45.455]                   if (is.na(NA_character_)) 
[17:46:45.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:45.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:45.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:45.455]                     .init = FALSE)
[17:46:45.455]                 }
[17:46:45.455]             }
[17:46:45.455]         }
[17:46:45.455]     })
[17:46:45.455]     if (TRUE) {
[17:46:45.455]         base::sink(type = "output", split = FALSE)
[17:46:45.455]         if (TRUE) {
[17:46:45.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:45.455]         }
[17:46:45.455]         else {
[17:46:45.455]             ...future.result["stdout"] <- base::list(NULL)
[17:46:45.455]         }
[17:46:45.455]         base::close(...future.stdout)
[17:46:45.455]         ...future.stdout <- NULL
[17:46:45.455]     }
[17:46:45.455]     ...future.result$conditions <- ...future.conditions
[17:46:45.455]     ...future.result$finished <- base::Sys.time()
[17:46:45.455]     ...future.result
[17:46:45.455] }
[17:46:45.459] requestCore(): workers = 2
[17:46:45.465] MulticoreFuture started
[17:46:45.466] - Launch lazy future ... done
[17:46:45.466] run() for ‘MulticoreFuture’ ... done
[17:46:45.466] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:46:45.467] List of future strategies:
[17:46:45.467] 1. sequential:
[17:46:45.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:45.467]    - tweaked: FALSE
[17:46:45.467]    - call: NULL
[17:46:45.469] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617876deb90> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787c92450> 
 $  :[17:46:45.471] plan(): Setting new future strategy stack:
 NULL
 $  : NULL
 $  :[17:46:45.472] List of future strategies:
[17:46:45.472] 1. multicore:
[17:46:45.472]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:45.472]    - tweaked: FALSE
[17:46:45.472]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617876deb90> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561787c92450> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")=[17:46:45.477] plan(): nbrOfWorkers() = 2
 int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:45.483] resolve() on list ...
[17:46:45.483]  recursive: 0
[17:46:45.483]  length: 6
[17:46:45.483]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:45.483] signalConditionsASAP(numeric, pos=1) ...
[17:46:45.483] - nx: 6
[17:46:45.484] - relay: TRUE
[17:46:45.484] - stdout: TRUE
[17:46:45.484] - signal: TRUE
[17:46:45.484] - resignal: FALSE
[17:46:45.484] - force: TRUE
[17:46:45.484] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.484] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.484]  - until=2
[17:46:45.485]  - relaying element #2
[17:46:45.485] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.485] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.485] signalConditionsASAP(NULL, pos=1) ... done
[17:46:45.485]  length: 5 (resolved future 1)
[17:46:45.485] Future #2
[17:46:45.486] result() for MulticoreFuture ...
[17:46:45.486] result() for MulticoreFuture ...
[17:46:45.486] result() for MulticoreFuture ... done
[17:46:45.487] result() for MulticoreFuture ... done
[17:46:45.487] result() for MulticoreFuture ...
[17:46:45.487] result() for MulticoreFuture ... done
[17:46:45.487] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:45.487] - nx: 6
[17:46:45.487] - relay: TRUE
[17:46:45.487] - stdout: TRUE
[17:46:45.487] - signal: TRUE
[17:46:45.488] - resignal: FALSE
[17:46:45.488] - force: TRUE
[17:46:45.488] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.488] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:45.488]  - until=2
[17:46:45.488]  - relaying element #2
[17:46:45.488] result() for MulticoreFuture ...
[17:46:45.488] result() for MulticoreFuture ... done
[17:46:45.489] result() for MulticoreFuture ...
[17:46:45.489] result() for MulticoreFuture ... done
[17:46:45.489] result() for MulticoreFuture ...
[17:46:45.489] result() for MulticoreFuture ... done
[17:46:45.489] result() for MulticoreFuture ...
[17:46:45.489] result() for MulticoreFuture ... done
[17:46:45.489] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.490] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.490] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:45.490]  length: 4 (resolved future 2)
[17:46:45.490] Future #3
[17:46:45.490] result() for MulticoreFuture ...
[17:46:45.491] result() for MulticoreFuture ...
[17:46:45.491] result() for MulticoreFuture ... done
[17:46:45.491] result() for MulticoreFuture ... done
[17:46:45.491] result() for MulticoreFuture ...
[17:46:45.491] result() for MulticoreFuture ... done
[17:46:45.491] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:45.492] - nx: 6
[17:46:45.492] - relay: TRUE
[17:46:45.492] - stdout: TRUE
[17:46:45.492] - signal: TRUE
[17:46:45.492] - resignal: FALSE
[17:46:45.492] - force: TRUE
[17:46:45.492] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.492] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:45.492]  - until=3
[17:46:45.492]  - relaying element #3
[17:46:45.493] result() for MulticoreFuture ...
[17:46:45.493] result() for MulticoreFuture ... done
[17:46:45.493] result() for MulticoreFuture ...
[17:46:45.493] result() for MulticoreFuture ... done
[17:46:45.493] result() for MulticoreFuture ...
[17:46:45.493] result() for MulticoreFuture ... done
[17:46:45.493] result() for MulticoreFuture ...
[17:46:45.493] result() for MulticoreFuture ... done
[17:46:45.493] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.494] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.494] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:45.494]  length: 3 (resolved future 3)
[17:46:45.494] signalConditionsASAP(NULL, pos=4) ...
[17:46:45.494] - nx: 6
[17:46:45.494] - relay: TRUE
[17:46:45.494] - stdout: TRUE
[17:46:45.494] - signal: TRUE
[17:46:45.494] - resignal: FALSE
[17:46:45.494] - force: TRUE
[17:46:45.495] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.495]  - until=5
[17:46:45.495]  - relaying element #5
[17:46:45.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.495] signalConditionsASAP(NULL, pos=4) ... done
[17:46:45.495]  length: 2 (resolved future 4)
[17:46:45.495] signalConditionsASAP(NULL, pos=5) ...
[17:46:45.496] - nx: 6
[17:46:45.496] - relay: TRUE
[17:46:45.496] - stdout: TRUE
[17:46:45.496] - signal: TRUE
[17:46:45.496] - resignal: FALSE
[17:46:45.496] - force: TRUE
[17:46:45.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:45.496] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.496]  - until=6
[17:46:45.496]  - relaying element #6
[17:46:45.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.497] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.497] signalConditionsASAP(NULL, pos=5) ... done
[17:46:45.497]  length: 1 (resolved future 5)
[17:46:45.497] signalConditionsASAP(numeric, pos=6) ...
[17:46:45.497] - nx: 6
[17:46:45.497] - relay: TRUE
[17:46:45.497] - stdout: TRUE
[17:46:45.497] - signal: TRUE
[17:46:45.497] - resignal: FALSE
[17:46:45.497] - force: TRUE
[17:46:45.497] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:45.498] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.498]  - until=6
[17:46:45.498] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.498] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.498] signalConditionsASAP(numeric, pos=6) ... done
[17:46:45.498]  length: 0 (resolved future 6)
[17:46:45.498] Relaying remaining futures
[17:46:45.498] signalConditionsASAP(NULL, pos=0) ...
[17:46:45.498] - nx: 6
[17:46:45.498] - relay: TRUE
[17:46:45.499] - stdout: TRUE
[17:46:45.499] - signal: TRUE
[17:46:45.499] - resignal: FALSE
[17:46:45.499] - force: TRUE
[17:46:45.499] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.499] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:45.499] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:45.499] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:45.499] signalConditionsASAP(NULL, pos=0) ... done
[17:46:45.500] resolve() on list ... DONE
[17:46:45.500] result() for MulticoreFuture ...
[17:46:45.500] result() for MulticoreFuture ... done
[17:46:45.500] result() for MulticoreFuture ...
[17:46:45.500] result() for MulticoreFuture ... done
[17:46:45.500] result() for MulticoreFuture ...
[17:46:45.500] result() for MulticoreFuture ... done
[17:46:45.500] result() for MulticoreFuture ...
[17:46:45.500] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:46:45.506] plan(): Setting new future strategy stack:
[17:46:45.507] List of future strategies:
[17:46:45.507] 1. multisession:
[17:46:45.507]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:45.507]    - tweaked: FALSE
[17:46:45.507]    - call: plan(strategy)
[17:46:45.507] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:46:45.507] multisession:
[17:46:45.507] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:45.507] - tweaked: FALSE
[17:46:45.507] - call: plan(strategy)
[17:46:45.513] getGlobalsAndPackages() ...
[17:46:45.514] Not searching for globals
[17:46:45.514] - globals: [0] <none>
[17:46:45.514] getGlobalsAndPackages() ... DONE
[17:46:45.514] [local output] makeClusterPSOCK() ...
[17:46:45.557] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:46:45.558] [local output] Base port: 11808
[17:46:45.559] [local output] Getting setup options for 2 cluster nodes ...
[17:46:45.559] [local output]  - Node 1 of 2 ...
[17:46:45.559] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:45.560] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a47460de92a0.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a47460de92a0.pid")'’
[17:46:45.746] - Possible to infer worker's PID: TRUE
[17:46:45.746] [local output] Rscript port: 11808

[17:46:45.747] [local output]  - Node 2 of 2 ...
[17:46:45.747] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:45.748] [local output] Rscript port: 11808

[17:46:45.748] [local output] Getting setup options for 2 cluster nodes ... done
[17:46:45.748] [local output]  - Parallel setup requested for some PSOCK nodes
[17:46:45.748] [local output] Setting up PSOCK nodes in parallel
[17:46:45.749] List of 36
[17:46:45.749]  $ worker          : chr "localhost"
[17:46:45.749]   ..- attr(*, "localhost")= logi TRUE
[17:46:45.749]  $ master          : chr "localhost"
[17:46:45.749]  $ port            : int 11808
[17:46:45.749]  $ connectTimeout  : num 120
[17:46:45.749]  $ timeout         : num 2592000
[17:46:45.749]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:46:45.749]  $ homogeneous     : logi TRUE
[17:46:45.749]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:46:45.749]  $ rscript_envs    : NULL
[17:46:45.749]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:45.749]  $ rscript_startup : NULL
[17:46:45.749]  $ rscript_sh      : chr "sh"
[17:46:45.749]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:45.749]  $ methods         : logi TRUE
[17:46:45.749]  $ socketOptions   : chr "no-delay"
[17:46:45.749]  $ useXDR          : logi FALSE
[17:46:45.749]  $ outfile         : chr "/dev/null"
[17:46:45.749]  $ renice          : int NA
[17:46:45.749]  $ rshcmd          : NULL
[17:46:45.749]  $ user            : chr(0) 
[17:46:45.749]  $ revtunnel       : logi FALSE
[17:46:45.749]  $ rshlogfile      : NULL
[17:46:45.749]  $ rshopts         : chr(0) 
[17:46:45.749]  $ rank            : int 1
[17:46:45.749]  $ manual          : logi FALSE
[17:46:45.749]  $ dryrun          : logi FALSE
[17:46:45.749]  $ quiet           : logi FALSE
[17:46:45.749]  $ setup_strategy  : chr "parallel"
[17:46:45.749]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:45.749]  $ pidfile         : chr "/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a47460de92a0.pid"
[17:46:45.749]  $ rshcmd_label    : NULL
[17:46:45.749]  $ rsh_call        : NULL
[17:46:45.749]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:45.749]  $ localMachine    : logi TRUE
[17:46:45.749]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:46:45.749]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:46:45.749]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:46:45.749]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:46:45.749]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:46:45.749]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:46:45.749]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:46:45.749]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:46:45.749]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:46:45.749]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:46:45.749]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:46:45.749]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:46:45.749]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:46:45.749]  $ arguments       :List of 28
[17:46:45.749]   ..$ worker          : chr "localhost"
[17:46:45.749]   ..$ master          : NULL
[17:46:45.749]   ..$ port            : int 11808
[17:46:45.749]   ..$ connectTimeout  : num 120
[17:46:45.749]   ..$ timeout         : num 2592000
[17:46:45.749]   ..$ rscript         : NULL
[17:46:45.749]   ..$ homogeneous     : NULL
[17:46:45.749]   ..$ rscript_args    : NULL
[17:46:45.749]   ..$ rscript_envs    : NULL
[17:46:45.749]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:45.749]   ..$ rscript_startup : NULL
[17:46:45.749]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:46:45.749]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:45.749]   ..$ methods         : logi TRUE
[17:46:45.749]   ..$ socketOptions   : chr "no-delay"
[17:46:45.749]   ..$ useXDR          : logi FALSE
[17:46:45.749]   ..$ outfile         : chr "/dev/null"
[17:46:45.749]   ..$ renice          : int NA
[17:46:45.749]   ..$ rshcmd          : NULL
[17:46:45.749]   ..$ user            : NULL
[17:46:45.749]   ..$ revtunnel       : logi NA
[17:46:45.749]   ..$ rshlogfile      : NULL
[17:46:45.749]   ..$ rshopts         : NULL
[17:46:45.749]   ..$ rank            : int 1
[17:46:45.749]   ..$ manual          : logi FALSE
[17:46:45.749]   ..$ dryrun          : logi FALSE
[17:46:45.749]   ..$ quiet           : logi FALSE
[17:46:45.749]   ..$ setup_strategy  : chr "parallel"
[17:46:45.749]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:46:45.765] [local output] System call to launch all workers:
[17:46:45.765] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a47460de92a0.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11808 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:46:45.765] [local output] Starting PSOCK main server
[17:46:45.770] [local output] Workers launched
[17:46:45.771] [local output] Waiting for workers to connect back
[17:46:45.771]  - [local output] 0 workers out of 2 ready
[17:46:46.019]  - [local output] 0 workers out of 2 ready
[17:46:46.020]  - [local output] 1 workers out of 2 ready
[17:46:46.020]  - [local output] 2 workers out of 2 ready
[17:46:46.020] [local output] Launching of workers completed
[17:46:46.020] [local output] Collecting session information from workers
[17:46:46.021] [local output]  - Worker #1 of 2
[17:46:46.022] [local output]  - Worker #2 of 2
[17:46:46.022] [local output] makeClusterPSOCK() ... done
[17:46:46.033] Packages needed by the future expression (n = 0): <none>
[17:46:46.033] Packages needed by future strategies (n = 0): <none>
[17:46:46.033] {
[17:46:46.033]     {
[17:46:46.033]         {
[17:46:46.033]             ...future.startTime <- base::Sys.time()
[17:46:46.033]             {
[17:46:46.033]                 {
[17:46:46.033]                   {
[17:46:46.033]                     {
[17:46:46.033]                       base::local({
[17:46:46.033]                         has_future <- base::requireNamespace("future", 
[17:46:46.033]                           quietly = TRUE)
[17:46:46.033]                         if (has_future) {
[17:46:46.033]                           ns <- base::getNamespace("future")
[17:46:46.033]                           version <- ns[[".package"]][["version"]]
[17:46:46.033]                           if (is.null(version)) 
[17:46:46.033]                             version <- utils::packageVersion("future")
[17:46:46.033]                         }
[17:46:46.033]                         else {
[17:46:46.033]                           version <- NULL
[17:46:46.033]                         }
[17:46:46.033]                         if (!has_future || version < "1.8.0") {
[17:46:46.033]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.033]                             "", base::R.version$version.string), 
[17:46:46.033]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.033]                               "release", "version")], collapse = " "), 
[17:46:46.033]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.033]                             info)
[17:46:46.033]                           info <- base::paste(info, collapse = "; ")
[17:46:46.033]                           if (!has_future) {
[17:46:46.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.033]                               info)
[17:46:46.033]                           }
[17:46:46.033]                           else {
[17:46:46.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.033]                               info, version)
[17:46:46.033]                           }
[17:46:46.033]                           base::stop(msg)
[17:46:46.033]                         }
[17:46:46.033]                       })
[17:46:46.033]                     }
[17:46:46.033]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.033]                     base::options(mc.cores = 1L)
[17:46:46.033]                   }
[17:46:46.033]                   ...future.strategy.old <- future::plan("list")
[17:46:46.033]                   options(future.plan = NULL)
[17:46:46.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.033]                 }
[17:46:46.033]                 ...future.workdir <- getwd()
[17:46:46.033]             }
[17:46:46.033]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.033]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.033]         }
[17:46:46.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.033]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.033]             base::names(...future.oldOptions))
[17:46:46.033]     }
[17:46:46.033]     if (FALSE) {
[17:46:46.033]     }
[17:46:46.033]     else {
[17:46:46.033]         if (TRUE) {
[17:46:46.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.033]                 open = "w")
[17:46:46.033]         }
[17:46:46.033]         else {
[17:46:46.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.033]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.033]         }
[17:46:46.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.033]             base::sink(type = "output", split = FALSE)
[17:46:46.033]             base::close(...future.stdout)
[17:46:46.033]         }, add = TRUE)
[17:46:46.033]     }
[17:46:46.033]     ...future.frame <- base::sys.nframe()
[17:46:46.033]     ...future.conditions <- base::list()
[17:46:46.033]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.033]     if (FALSE) {
[17:46:46.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.033]     }
[17:46:46.033]     ...future.result <- base::tryCatch({
[17:46:46.033]         base::withCallingHandlers({
[17:46:46.033]             ...future.value <- base::withVisible(base::local({
[17:46:46.033]                 ...future.makeSendCondition <- base::local({
[17:46:46.033]                   sendCondition <- NULL
[17:46:46.033]                   function(frame = 1L) {
[17:46:46.033]                     if (is.function(sendCondition)) 
[17:46:46.033]                       return(sendCondition)
[17:46:46.033]                     ns <- getNamespace("parallel")
[17:46:46.033]                     if (exists("sendData", mode = "function", 
[17:46:46.033]                       envir = ns)) {
[17:46:46.033]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.033]                         envir = ns)
[17:46:46.033]                       envir <- sys.frame(frame)
[17:46:46.033]                       master <- NULL
[17:46:46.033]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.033]                         !identical(envir, emptyenv())) {
[17:46:46.033]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.033]                           inherits = FALSE)) {
[17:46:46.033]                           master <- get("master", mode = "list", 
[17:46:46.033]                             envir = envir, inherits = FALSE)
[17:46:46.033]                           if (inherits(master, c("SOCKnode", 
[17:46:46.033]                             "SOCK0node"))) {
[17:46:46.033]                             sendCondition <<- function(cond) {
[17:46:46.033]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.033]                                 success = TRUE)
[17:46:46.033]                               parallel_sendData(master, data)
[17:46:46.033]                             }
[17:46:46.033]                             return(sendCondition)
[17:46:46.033]                           }
[17:46:46.033]                         }
[17:46:46.033]                         frame <- frame + 1L
[17:46:46.033]                         envir <- sys.frame(frame)
[17:46:46.033]                       }
[17:46:46.033]                     }
[17:46:46.033]                     sendCondition <<- function(cond) NULL
[17:46:46.033]                   }
[17:46:46.033]                 })
[17:46:46.033]                 withCallingHandlers({
[17:46:46.033]                   NA
[17:46:46.033]                 }, immediateCondition = function(cond) {
[17:46:46.033]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.033]                   sendCondition(cond)
[17:46:46.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.033]                   {
[17:46:46.033]                     inherits <- base::inherits
[17:46:46.033]                     invokeRestart <- base::invokeRestart
[17:46:46.033]                     is.null <- base::is.null
[17:46:46.033]                     muffled <- FALSE
[17:46:46.033]                     if (inherits(cond, "message")) {
[17:46:46.033]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.033]                       if (muffled) 
[17:46:46.033]                         invokeRestart("muffleMessage")
[17:46:46.033]                     }
[17:46:46.033]                     else if (inherits(cond, "warning")) {
[17:46:46.033]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.033]                       if (muffled) 
[17:46:46.033]                         invokeRestart("muffleWarning")
[17:46:46.033]                     }
[17:46:46.033]                     else if (inherits(cond, "condition")) {
[17:46:46.033]                       if (!is.null(pattern)) {
[17:46:46.033]                         computeRestarts <- base::computeRestarts
[17:46:46.033]                         grepl <- base::grepl
[17:46:46.033]                         restarts <- computeRestarts(cond)
[17:46:46.033]                         for (restart in restarts) {
[17:46:46.033]                           name <- restart$name
[17:46:46.033]                           if (is.null(name)) 
[17:46:46.033]                             next
[17:46:46.033]                           if (!grepl(pattern, name)) 
[17:46:46.033]                             next
[17:46:46.033]                           invokeRestart(restart)
[17:46:46.033]                           muffled <- TRUE
[17:46:46.033]                           break
[17:46:46.033]                         }
[17:46:46.033]                       }
[17:46:46.033]                     }
[17:46:46.033]                     invisible(muffled)
[17:46:46.033]                   }
[17:46:46.033]                   muffleCondition(cond)
[17:46:46.033]                 })
[17:46:46.033]             }))
[17:46:46.033]             future::FutureResult(value = ...future.value$value, 
[17:46:46.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.033]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.033]                     ...future.globalenv.names))
[17:46:46.033]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.033]         }, condition = base::local({
[17:46:46.033]             c <- base::c
[17:46:46.033]             inherits <- base::inherits
[17:46:46.033]             invokeRestart <- base::invokeRestart
[17:46:46.033]             length <- base::length
[17:46:46.033]             list <- base::list
[17:46:46.033]             seq.int <- base::seq.int
[17:46:46.033]             signalCondition <- base::signalCondition
[17:46:46.033]             sys.calls <- base::sys.calls
[17:46:46.033]             `[[` <- base::`[[`
[17:46:46.033]             `+` <- base::`+`
[17:46:46.033]             `<<-` <- base::`<<-`
[17:46:46.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.033]                   3L)]
[17:46:46.033]             }
[17:46:46.033]             function(cond) {
[17:46:46.033]                 is_error <- inherits(cond, "error")
[17:46:46.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.033]                   NULL)
[17:46:46.033]                 if (is_error) {
[17:46:46.033]                   sessionInformation <- function() {
[17:46:46.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.033]                       search = base::search(), system = base::Sys.info())
[17:46:46.033]                   }
[17:46:46.033]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.033]                     cond$call), session = sessionInformation(), 
[17:46:46.033]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.033]                   signalCondition(cond)
[17:46:46.033]                 }
[17:46:46.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.033]                 "immediateCondition"))) {
[17:46:46.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.033]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.033]                   if (TRUE && !signal) {
[17:46:46.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.033]                     {
[17:46:46.033]                       inherits <- base::inherits
[17:46:46.033]                       invokeRestart <- base::invokeRestart
[17:46:46.033]                       is.null <- base::is.null
[17:46:46.033]                       muffled <- FALSE
[17:46:46.033]                       if (inherits(cond, "message")) {
[17:46:46.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.033]                         if (muffled) 
[17:46:46.033]                           invokeRestart("muffleMessage")
[17:46:46.033]                       }
[17:46:46.033]                       else if (inherits(cond, "warning")) {
[17:46:46.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.033]                         if (muffled) 
[17:46:46.033]                           invokeRestart("muffleWarning")
[17:46:46.033]                       }
[17:46:46.033]                       else if (inherits(cond, "condition")) {
[17:46:46.033]                         if (!is.null(pattern)) {
[17:46:46.033]                           computeRestarts <- base::computeRestarts
[17:46:46.033]                           grepl <- base::grepl
[17:46:46.033]                           restarts <- computeRestarts(cond)
[17:46:46.033]                           for (restart in restarts) {
[17:46:46.033]                             name <- restart$name
[17:46:46.033]                             if (is.null(name)) 
[17:46:46.033]                               next
[17:46:46.033]                             if (!grepl(pattern, name)) 
[17:46:46.033]                               next
[17:46:46.033]                             invokeRestart(restart)
[17:46:46.033]                             muffled <- TRUE
[17:46:46.033]                             break
[17:46:46.033]                           }
[17:46:46.033]                         }
[17:46:46.033]                       }
[17:46:46.033]                       invisible(muffled)
[17:46:46.033]                     }
[17:46:46.033]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.033]                   }
[17:46:46.033]                 }
[17:46:46.033]                 else {
[17:46:46.033]                   if (TRUE) {
[17:46:46.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.033]                     {
[17:46:46.033]                       inherits <- base::inherits
[17:46:46.033]                       invokeRestart <- base::invokeRestart
[17:46:46.033]                       is.null <- base::is.null
[17:46:46.033]                       muffled <- FALSE
[17:46:46.033]                       if (inherits(cond, "message")) {
[17:46:46.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.033]                         if (muffled) 
[17:46:46.033]                           invokeRestart("muffleMessage")
[17:46:46.033]                       }
[17:46:46.033]                       else if (inherits(cond, "warning")) {
[17:46:46.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.033]                         if (muffled) 
[17:46:46.033]                           invokeRestart("muffleWarning")
[17:46:46.033]                       }
[17:46:46.033]                       else if (inherits(cond, "condition")) {
[17:46:46.033]                         if (!is.null(pattern)) {
[17:46:46.033]                           computeRestarts <- base::computeRestarts
[17:46:46.033]                           grepl <- base::grepl
[17:46:46.033]                           restarts <- computeRestarts(cond)
[17:46:46.033]                           for (restart in restarts) {
[17:46:46.033]                             name <- restart$name
[17:46:46.033]                             if (is.null(name)) 
[17:46:46.033]                               next
[17:46:46.033]                             if (!grepl(pattern, name)) 
[17:46:46.033]                               next
[17:46:46.033]                             invokeRestart(restart)
[17:46:46.033]                             muffled <- TRUE
[17:46:46.033]                             break
[17:46:46.033]                           }
[17:46:46.033]                         }
[17:46:46.033]                       }
[17:46:46.033]                       invisible(muffled)
[17:46:46.033]                     }
[17:46:46.033]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.033]                   }
[17:46:46.033]                 }
[17:46:46.033]             }
[17:46:46.033]         }))
[17:46:46.033]     }, error = function(ex) {
[17:46:46.033]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.033]                 ...future.rng), started = ...future.startTime, 
[17:46:46.033]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.033]             version = "1.8"), class = "FutureResult")
[17:46:46.033]     }, finally = {
[17:46:46.033]         if (!identical(...future.workdir, getwd())) 
[17:46:46.033]             setwd(...future.workdir)
[17:46:46.033]         {
[17:46:46.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.033]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.033]             }
[17:46:46.033]             base::options(...future.oldOptions)
[17:46:46.033]             if (.Platform$OS.type == "windows") {
[17:46:46.033]                 old_names <- names(...future.oldEnvVars)
[17:46:46.033]                 envs <- base::Sys.getenv()
[17:46:46.033]                 names <- names(envs)
[17:46:46.033]                 common <- intersect(names, old_names)
[17:46:46.033]                 added <- setdiff(names, old_names)
[17:46:46.033]                 removed <- setdiff(old_names, names)
[17:46:46.033]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.033]                   envs[common]]
[17:46:46.033]                 NAMES <- toupper(changed)
[17:46:46.033]                 args <- list()
[17:46:46.033]                 for (kk in seq_along(NAMES)) {
[17:46:46.033]                   name <- changed[[kk]]
[17:46:46.033]                   NAME <- NAMES[[kk]]
[17:46:46.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.033]                     next
[17:46:46.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.033]                 }
[17:46:46.033]                 NAMES <- toupper(added)
[17:46:46.033]                 for (kk in seq_along(NAMES)) {
[17:46:46.033]                   name <- added[[kk]]
[17:46:46.033]                   NAME <- NAMES[[kk]]
[17:46:46.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.033]                     next
[17:46:46.033]                   args[[name]] <- ""
[17:46:46.033]                 }
[17:46:46.033]                 NAMES <- toupper(removed)
[17:46:46.033]                 for (kk in seq_along(NAMES)) {
[17:46:46.033]                   name <- removed[[kk]]
[17:46:46.033]                   NAME <- NAMES[[kk]]
[17:46:46.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.033]                     next
[17:46:46.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.033]                 }
[17:46:46.033]                 if (length(args) > 0) 
[17:46:46.033]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.033]             }
[17:46:46.033]             else {
[17:46:46.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.033]             }
[17:46:46.033]             {
[17:46:46.033]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.033]                   0L) {
[17:46:46.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.033]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.033]                   base::options(opts)
[17:46:46.033]                 }
[17:46:46.033]                 {
[17:46:46.033]                   {
[17:46:46.033]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.033]                     NULL
[17:46:46.033]                   }
[17:46:46.033]                   options(future.plan = NULL)
[17:46:46.033]                   if (is.na(NA_character_)) 
[17:46:46.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.033]                     .init = FALSE)
[17:46:46.033]                 }
[17:46:46.033]             }
[17:46:46.033]         }
[17:46:46.033]     })
[17:46:46.033]     if (TRUE) {
[17:46:46.033]         base::sink(type = "output", split = FALSE)
[17:46:46.033]         if (TRUE) {
[17:46:46.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.033]         }
[17:46:46.033]         else {
[17:46:46.033]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.033]         }
[17:46:46.033]         base::close(...future.stdout)
[17:46:46.033]         ...future.stdout <- NULL
[17:46:46.033]     }
[17:46:46.033]     ...future.result$conditions <- ...future.conditions
[17:46:46.033]     ...future.result$finished <- base::Sys.time()
[17:46:46.033]     ...future.result
[17:46:46.033] }
[17:46:46.084] MultisessionFuture started
[17:46:46.085] result() for ClusterFuture ...
[17:46:46.085] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.086] - Validating connection of MultisessionFuture
[17:46:46.117] - received message: FutureResult
[17:46:46.117] - Received FutureResult
[17:46:46.117] - Erased future from FutureRegistry
[17:46:46.117] result() for ClusterFuture ...
[17:46:46.117] - result already collected: FutureResult
[17:46:46.117] result() for ClusterFuture ... done
[17:46:46.117] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:46.118] result() for ClusterFuture ... done
[17:46:46.118] result() for ClusterFuture ...
[17:46:46.118] - result already collected: FutureResult
[17:46:46.118] result() for ClusterFuture ... done
[17:46:46.118] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:46:46.122] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:46:46.123] getGlobalsAndPackages() ...
[17:46:46.123] Searching for globals...
[17:46:46.123] 
[17:46:46.123] Searching for globals ... DONE
[17:46:46.124] - globals: [0] <none>
[17:46:46.124] getGlobalsAndPackages() ... DONE
[17:46:46.124] run() for ‘Future’ ...
[17:46:46.124] - state: ‘created’
[17:46:46.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.139] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.139]   - Field: ‘node’
[17:46:46.139]   - Field: ‘label’
[17:46:46.139]   - Field: ‘local’
[17:46:46.139]   - Field: ‘owner’
[17:46:46.139]   - Field: ‘envir’
[17:46:46.139]   - Field: ‘workers’
[17:46:46.140]   - Field: ‘packages’
[17:46:46.140]   - Field: ‘gc’
[17:46:46.140]   - Field: ‘conditions’
[17:46:46.140]   - Field: ‘persistent’
[17:46:46.140]   - Field: ‘expr’
[17:46:46.140]   - Field: ‘uuid’
[17:46:46.140]   - Field: ‘seed’
[17:46:46.140]   - Field: ‘version’
[17:46:46.140]   - Field: ‘result’
[17:46:46.141]   - Field: ‘asynchronous’
[17:46:46.141]   - Field: ‘calls’
[17:46:46.141]   - Field: ‘globals’
[17:46:46.141]   - Field: ‘stdout’
[17:46:46.141]   - Field: ‘earlySignal’
[17:46:46.141]   - Field: ‘lazy’
[17:46:46.141]   - Field: ‘state’
[17:46:46.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.141] - Launch lazy future ...
[17:46:46.142] Packages needed by the future expression (n = 0): <none>
[17:46:46.142] Packages needed by future strategies (n = 0): <none>
[17:46:46.143] {
[17:46:46.143]     {
[17:46:46.143]         {
[17:46:46.143]             ...future.startTime <- base::Sys.time()
[17:46:46.143]             {
[17:46:46.143]                 {
[17:46:46.143]                   {
[17:46:46.143]                     {
[17:46:46.143]                       base::local({
[17:46:46.143]                         has_future <- base::requireNamespace("future", 
[17:46:46.143]                           quietly = TRUE)
[17:46:46.143]                         if (has_future) {
[17:46:46.143]                           ns <- base::getNamespace("future")
[17:46:46.143]                           version <- ns[[".package"]][["version"]]
[17:46:46.143]                           if (is.null(version)) 
[17:46:46.143]                             version <- utils::packageVersion("future")
[17:46:46.143]                         }
[17:46:46.143]                         else {
[17:46:46.143]                           version <- NULL
[17:46:46.143]                         }
[17:46:46.143]                         if (!has_future || version < "1.8.0") {
[17:46:46.143]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.143]                             "", base::R.version$version.string), 
[17:46:46.143]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.143]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.143]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.143]                               "release", "version")], collapse = " "), 
[17:46:46.143]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.143]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.143]                             info)
[17:46:46.143]                           info <- base::paste(info, collapse = "; ")
[17:46:46.143]                           if (!has_future) {
[17:46:46.143]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.143]                               info)
[17:46:46.143]                           }
[17:46:46.143]                           else {
[17:46:46.143]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.143]                               info, version)
[17:46:46.143]                           }
[17:46:46.143]                           base::stop(msg)
[17:46:46.143]                         }
[17:46:46.143]                       })
[17:46:46.143]                     }
[17:46:46.143]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.143]                     base::options(mc.cores = 1L)
[17:46:46.143]                   }
[17:46:46.143]                   ...future.strategy.old <- future::plan("list")
[17:46:46.143]                   options(future.plan = NULL)
[17:46:46.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.143]                 }
[17:46:46.143]                 ...future.workdir <- getwd()
[17:46:46.143]             }
[17:46:46.143]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.143]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.143]         }
[17:46:46.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.143]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.143]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.143]             base::names(...future.oldOptions))
[17:46:46.143]     }
[17:46:46.143]     if (FALSE) {
[17:46:46.143]     }
[17:46:46.143]     else {
[17:46:46.143]         if (TRUE) {
[17:46:46.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.143]                 open = "w")
[17:46:46.143]         }
[17:46:46.143]         else {
[17:46:46.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.143]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.143]         }
[17:46:46.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.143]             base::sink(type = "output", split = FALSE)
[17:46:46.143]             base::close(...future.stdout)
[17:46:46.143]         }, add = TRUE)
[17:46:46.143]     }
[17:46:46.143]     ...future.frame <- base::sys.nframe()
[17:46:46.143]     ...future.conditions <- base::list()
[17:46:46.143]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.143]     if (FALSE) {
[17:46:46.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.143]     }
[17:46:46.143]     ...future.result <- base::tryCatch({
[17:46:46.143]         base::withCallingHandlers({
[17:46:46.143]             ...future.value <- base::withVisible(base::local({
[17:46:46.143]                 ...future.makeSendCondition <- base::local({
[17:46:46.143]                   sendCondition <- NULL
[17:46:46.143]                   function(frame = 1L) {
[17:46:46.143]                     if (is.function(sendCondition)) 
[17:46:46.143]                       return(sendCondition)
[17:46:46.143]                     ns <- getNamespace("parallel")
[17:46:46.143]                     if (exists("sendData", mode = "function", 
[17:46:46.143]                       envir = ns)) {
[17:46:46.143]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.143]                         envir = ns)
[17:46:46.143]                       envir <- sys.frame(frame)
[17:46:46.143]                       master <- NULL
[17:46:46.143]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.143]                         !identical(envir, emptyenv())) {
[17:46:46.143]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.143]                           inherits = FALSE)) {
[17:46:46.143]                           master <- get("master", mode = "list", 
[17:46:46.143]                             envir = envir, inherits = FALSE)
[17:46:46.143]                           if (inherits(master, c("SOCKnode", 
[17:46:46.143]                             "SOCK0node"))) {
[17:46:46.143]                             sendCondition <<- function(cond) {
[17:46:46.143]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.143]                                 success = TRUE)
[17:46:46.143]                               parallel_sendData(master, data)
[17:46:46.143]                             }
[17:46:46.143]                             return(sendCondition)
[17:46:46.143]                           }
[17:46:46.143]                         }
[17:46:46.143]                         frame <- frame + 1L
[17:46:46.143]                         envir <- sys.frame(frame)
[17:46:46.143]                       }
[17:46:46.143]                     }
[17:46:46.143]                     sendCondition <<- function(cond) NULL
[17:46:46.143]                   }
[17:46:46.143]                 })
[17:46:46.143]                 withCallingHandlers({
[17:46:46.143]                   2
[17:46:46.143]                 }, immediateCondition = function(cond) {
[17:46:46.143]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.143]                   sendCondition(cond)
[17:46:46.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.143]                   {
[17:46:46.143]                     inherits <- base::inherits
[17:46:46.143]                     invokeRestart <- base::invokeRestart
[17:46:46.143]                     is.null <- base::is.null
[17:46:46.143]                     muffled <- FALSE
[17:46:46.143]                     if (inherits(cond, "message")) {
[17:46:46.143]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.143]                       if (muffled) 
[17:46:46.143]                         invokeRestart("muffleMessage")
[17:46:46.143]                     }
[17:46:46.143]                     else if (inherits(cond, "warning")) {
[17:46:46.143]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.143]                       if (muffled) 
[17:46:46.143]                         invokeRestart("muffleWarning")
[17:46:46.143]                     }
[17:46:46.143]                     else if (inherits(cond, "condition")) {
[17:46:46.143]                       if (!is.null(pattern)) {
[17:46:46.143]                         computeRestarts <- base::computeRestarts
[17:46:46.143]                         grepl <- base::grepl
[17:46:46.143]                         restarts <- computeRestarts(cond)
[17:46:46.143]                         for (restart in restarts) {
[17:46:46.143]                           name <- restart$name
[17:46:46.143]                           if (is.null(name)) 
[17:46:46.143]                             next
[17:46:46.143]                           if (!grepl(pattern, name)) 
[17:46:46.143]                             next
[17:46:46.143]                           invokeRestart(restart)
[17:46:46.143]                           muffled <- TRUE
[17:46:46.143]                           break
[17:46:46.143]                         }
[17:46:46.143]                       }
[17:46:46.143]                     }
[17:46:46.143]                     invisible(muffled)
[17:46:46.143]                   }
[17:46:46.143]                   muffleCondition(cond)
[17:46:46.143]                 })
[17:46:46.143]             }))
[17:46:46.143]             future::FutureResult(value = ...future.value$value, 
[17:46:46.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.143]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.143]                     ...future.globalenv.names))
[17:46:46.143]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.143]         }, condition = base::local({
[17:46:46.143]             c <- base::c
[17:46:46.143]             inherits <- base::inherits
[17:46:46.143]             invokeRestart <- base::invokeRestart
[17:46:46.143]             length <- base::length
[17:46:46.143]             list <- base::list
[17:46:46.143]             seq.int <- base::seq.int
[17:46:46.143]             signalCondition <- base::signalCondition
[17:46:46.143]             sys.calls <- base::sys.calls
[17:46:46.143]             `[[` <- base::`[[`
[17:46:46.143]             `+` <- base::`+`
[17:46:46.143]             `<<-` <- base::`<<-`
[17:46:46.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.143]                   3L)]
[17:46:46.143]             }
[17:46:46.143]             function(cond) {
[17:46:46.143]                 is_error <- inherits(cond, "error")
[17:46:46.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.143]                   NULL)
[17:46:46.143]                 if (is_error) {
[17:46:46.143]                   sessionInformation <- function() {
[17:46:46.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.143]                       search = base::search(), system = base::Sys.info())
[17:46:46.143]                   }
[17:46:46.143]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.143]                     cond$call), session = sessionInformation(), 
[17:46:46.143]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.143]                   signalCondition(cond)
[17:46:46.143]                 }
[17:46:46.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.143]                 "immediateCondition"))) {
[17:46:46.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.143]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.143]                   if (TRUE && !signal) {
[17:46:46.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.143]                     {
[17:46:46.143]                       inherits <- base::inherits
[17:46:46.143]                       invokeRestart <- base::invokeRestart
[17:46:46.143]                       is.null <- base::is.null
[17:46:46.143]                       muffled <- FALSE
[17:46:46.143]                       if (inherits(cond, "message")) {
[17:46:46.143]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.143]                         if (muffled) 
[17:46:46.143]                           invokeRestart("muffleMessage")
[17:46:46.143]                       }
[17:46:46.143]                       else if (inherits(cond, "warning")) {
[17:46:46.143]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.143]                         if (muffled) 
[17:46:46.143]                           invokeRestart("muffleWarning")
[17:46:46.143]                       }
[17:46:46.143]                       else if (inherits(cond, "condition")) {
[17:46:46.143]                         if (!is.null(pattern)) {
[17:46:46.143]                           computeRestarts <- base::computeRestarts
[17:46:46.143]                           grepl <- base::grepl
[17:46:46.143]                           restarts <- computeRestarts(cond)
[17:46:46.143]                           for (restart in restarts) {
[17:46:46.143]                             name <- restart$name
[17:46:46.143]                             if (is.null(name)) 
[17:46:46.143]                               next
[17:46:46.143]                             if (!grepl(pattern, name)) 
[17:46:46.143]                               next
[17:46:46.143]                             invokeRestart(restart)
[17:46:46.143]                             muffled <- TRUE
[17:46:46.143]                             break
[17:46:46.143]                           }
[17:46:46.143]                         }
[17:46:46.143]                       }
[17:46:46.143]                       invisible(muffled)
[17:46:46.143]                     }
[17:46:46.143]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.143]                   }
[17:46:46.143]                 }
[17:46:46.143]                 else {
[17:46:46.143]                   if (TRUE) {
[17:46:46.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.143]                     {
[17:46:46.143]                       inherits <- base::inherits
[17:46:46.143]                       invokeRestart <- base::invokeRestart
[17:46:46.143]                       is.null <- base::is.null
[17:46:46.143]                       muffled <- FALSE
[17:46:46.143]                       if (inherits(cond, "message")) {
[17:46:46.143]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.143]                         if (muffled) 
[17:46:46.143]                           invokeRestart("muffleMessage")
[17:46:46.143]                       }
[17:46:46.143]                       else if (inherits(cond, "warning")) {
[17:46:46.143]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.143]                         if (muffled) 
[17:46:46.143]                           invokeRestart("muffleWarning")
[17:46:46.143]                       }
[17:46:46.143]                       else if (inherits(cond, "condition")) {
[17:46:46.143]                         if (!is.null(pattern)) {
[17:46:46.143]                           computeRestarts <- base::computeRestarts
[17:46:46.143]                           grepl <- base::grepl
[17:46:46.143]                           restarts <- computeRestarts(cond)
[17:46:46.143]                           for (restart in restarts) {
[17:46:46.143]                             name <- restart$name
[17:46:46.143]                             if (is.null(name)) 
[17:46:46.143]                               next
[17:46:46.143]                             if (!grepl(pattern, name)) 
[17:46:46.143]                               next
[17:46:46.143]                             invokeRestart(restart)
[17:46:46.143]                             muffled <- TRUE
[17:46:46.143]                             break
[17:46:46.143]                           }
[17:46:46.143]                         }
[17:46:46.143]                       }
[17:46:46.143]                       invisible(muffled)
[17:46:46.143]                     }
[17:46:46.143]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.143]                   }
[17:46:46.143]                 }
[17:46:46.143]             }
[17:46:46.143]         }))
[17:46:46.143]     }, error = function(ex) {
[17:46:46.143]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.143]                 ...future.rng), started = ...future.startTime, 
[17:46:46.143]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.143]             version = "1.8"), class = "FutureResult")
[17:46:46.143]     }, finally = {
[17:46:46.143]         if (!identical(...future.workdir, getwd())) 
[17:46:46.143]             setwd(...future.workdir)
[17:46:46.143]         {
[17:46:46.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.143]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.143]             }
[17:46:46.143]             base::options(...future.oldOptions)
[17:46:46.143]             if (.Platform$OS.type == "windows") {
[17:46:46.143]                 old_names <- names(...future.oldEnvVars)
[17:46:46.143]                 envs <- base::Sys.getenv()
[17:46:46.143]                 names <- names(envs)
[17:46:46.143]                 common <- intersect(names, old_names)
[17:46:46.143]                 added <- setdiff(names, old_names)
[17:46:46.143]                 removed <- setdiff(old_names, names)
[17:46:46.143]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.143]                   envs[common]]
[17:46:46.143]                 NAMES <- toupper(changed)
[17:46:46.143]                 args <- list()
[17:46:46.143]                 for (kk in seq_along(NAMES)) {
[17:46:46.143]                   name <- changed[[kk]]
[17:46:46.143]                   NAME <- NAMES[[kk]]
[17:46:46.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.143]                     next
[17:46:46.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.143]                 }
[17:46:46.143]                 NAMES <- toupper(added)
[17:46:46.143]                 for (kk in seq_along(NAMES)) {
[17:46:46.143]                   name <- added[[kk]]
[17:46:46.143]                   NAME <- NAMES[[kk]]
[17:46:46.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.143]                     next
[17:46:46.143]                   args[[name]] <- ""
[17:46:46.143]                 }
[17:46:46.143]                 NAMES <- toupper(removed)
[17:46:46.143]                 for (kk in seq_along(NAMES)) {
[17:46:46.143]                   name <- removed[[kk]]
[17:46:46.143]                   NAME <- NAMES[[kk]]
[17:46:46.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.143]                     next
[17:46:46.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.143]                 }
[17:46:46.143]                 if (length(args) > 0) 
[17:46:46.143]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.143]             }
[17:46:46.143]             else {
[17:46:46.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.143]             }
[17:46:46.143]             {
[17:46:46.143]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.143]                   0L) {
[17:46:46.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.143]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.143]                   base::options(opts)
[17:46:46.143]                 }
[17:46:46.143]                 {
[17:46:46.143]                   {
[17:46:46.143]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.143]                     NULL
[17:46:46.143]                   }
[17:46:46.143]                   options(future.plan = NULL)
[17:46:46.143]                   if (is.na(NA_character_)) 
[17:46:46.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.143]                     .init = FALSE)
[17:46:46.143]                 }
[17:46:46.143]             }
[17:46:46.143]         }
[17:46:46.143]     })
[17:46:46.143]     if (TRUE) {
[17:46:46.143]         base::sink(type = "output", split = FALSE)
[17:46:46.143]         if (TRUE) {
[17:46:46.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.143]         }
[17:46:46.143]         else {
[17:46:46.143]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.143]         }
[17:46:46.143]         base::close(...future.stdout)
[17:46:46.143]         ...future.stdout <- NULL
[17:46:46.143]     }
[17:46:46.143]     ...future.result$conditions <- ...future.conditions
[17:46:46.143]     ...future.result$finished <- base::Sys.time()
[17:46:46.143]     ...future.result
[17:46:46.143] }
[17:46:46.146] MultisessionFuture started
[17:46:46.146] - Launch lazy future ... done
[17:46:46.146] run() for ‘MultisessionFuture’ ... done
[17:46:46.146] getGlobalsAndPackages() ...
[17:46:46.146] Searching for globals...
[17:46:46.147] 
[17:46:46.147] Searching for globals ... DONE
[17:46:46.147] - globals: [0] <none>
[17:46:46.147] getGlobalsAndPackages() ... DONE
[17:46:46.147] run() for ‘Future’ ...
[17:46:46.148] - state: ‘created’
[17:46:46.148] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.162] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.162]   - Field: ‘node’
[17:46:46.162]   - Field: ‘label’
[17:46:46.162]   - Field: ‘local’
[17:46:46.162]   - Field: ‘owner’
[17:46:46.162]   - Field: ‘envir’
[17:46:46.162]   - Field: ‘workers’
[17:46:46.162]   - Field: ‘packages’
[17:46:46.163]   - Field: ‘gc’
[17:46:46.163]   - Field: ‘conditions’
[17:46:46.163]   - Field: ‘persistent’
[17:46:46.163]   - Field: ‘expr’
[17:46:46.163]   - Field: ‘uuid’
[17:46:46.163]   - Field: ‘seed’
[17:46:46.163]   - Field: ‘version’
[17:46:46.163]   - Field: ‘result’
[17:46:46.164]   - Field: ‘asynchronous’
[17:46:46.164]   - Field: ‘calls’
[17:46:46.164]   - Field: ‘globals’
[17:46:46.164]   - Field: ‘stdout’
[17:46:46.164]   - Field: ‘earlySignal’
[17:46:46.164]   - Field: ‘lazy’
[17:46:46.164]   - Field: ‘state’
[17:46:46.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.164] - Launch lazy future ...
[17:46:46.165] Packages needed by the future expression (n = 0): <none>
[17:46:46.165] Packages needed by future strategies (n = 0): <none>
[17:46:46.165] {
[17:46:46.165]     {
[17:46:46.165]         {
[17:46:46.165]             ...future.startTime <- base::Sys.time()
[17:46:46.165]             {
[17:46:46.165]                 {
[17:46:46.165]                   {
[17:46:46.165]                     {
[17:46:46.165]                       base::local({
[17:46:46.165]                         has_future <- base::requireNamespace("future", 
[17:46:46.165]                           quietly = TRUE)
[17:46:46.165]                         if (has_future) {
[17:46:46.165]                           ns <- base::getNamespace("future")
[17:46:46.165]                           version <- ns[[".package"]][["version"]]
[17:46:46.165]                           if (is.null(version)) 
[17:46:46.165]                             version <- utils::packageVersion("future")
[17:46:46.165]                         }
[17:46:46.165]                         else {
[17:46:46.165]                           version <- NULL
[17:46:46.165]                         }
[17:46:46.165]                         if (!has_future || version < "1.8.0") {
[17:46:46.165]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.165]                             "", base::R.version$version.string), 
[17:46:46.165]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.165]                               "release", "version")], collapse = " "), 
[17:46:46.165]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.165]                             info)
[17:46:46.165]                           info <- base::paste(info, collapse = "; ")
[17:46:46.165]                           if (!has_future) {
[17:46:46.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.165]                               info)
[17:46:46.165]                           }
[17:46:46.165]                           else {
[17:46:46.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.165]                               info, version)
[17:46:46.165]                           }
[17:46:46.165]                           base::stop(msg)
[17:46:46.165]                         }
[17:46:46.165]                       })
[17:46:46.165]                     }
[17:46:46.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.165]                     base::options(mc.cores = 1L)
[17:46:46.165]                   }
[17:46:46.165]                   ...future.strategy.old <- future::plan("list")
[17:46:46.165]                   options(future.plan = NULL)
[17:46:46.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.165]                 }
[17:46:46.165]                 ...future.workdir <- getwd()
[17:46:46.165]             }
[17:46:46.165]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.165]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.165]         }
[17:46:46.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.165]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.165]             base::names(...future.oldOptions))
[17:46:46.165]     }
[17:46:46.165]     if (FALSE) {
[17:46:46.165]     }
[17:46:46.165]     else {
[17:46:46.165]         if (TRUE) {
[17:46:46.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.165]                 open = "w")
[17:46:46.165]         }
[17:46:46.165]         else {
[17:46:46.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.165]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.165]         }
[17:46:46.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.165]             base::sink(type = "output", split = FALSE)
[17:46:46.165]             base::close(...future.stdout)
[17:46:46.165]         }, add = TRUE)
[17:46:46.165]     }
[17:46:46.165]     ...future.frame <- base::sys.nframe()
[17:46:46.165]     ...future.conditions <- base::list()
[17:46:46.165]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.165]     if (FALSE) {
[17:46:46.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.165]     }
[17:46:46.165]     ...future.result <- base::tryCatch({
[17:46:46.165]         base::withCallingHandlers({
[17:46:46.165]             ...future.value <- base::withVisible(base::local({
[17:46:46.165]                 ...future.makeSendCondition <- base::local({
[17:46:46.165]                   sendCondition <- NULL
[17:46:46.165]                   function(frame = 1L) {
[17:46:46.165]                     if (is.function(sendCondition)) 
[17:46:46.165]                       return(sendCondition)
[17:46:46.165]                     ns <- getNamespace("parallel")
[17:46:46.165]                     if (exists("sendData", mode = "function", 
[17:46:46.165]                       envir = ns)) {
[17:46:46.165]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.165]                         envir = ns)
[17:46:46.165]                       envir <- sys.frame(frame)
[17:46:46.165]                       master <- NULL
[17:46:46.165]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.165]                         !identical(envir, emptyenv())) {
[17:46:46.165]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.165]                           inherits = FALSE)) {
[17:46:46.165]                           master <- get("master", mode = "list", 
[17:46:46.165]                             envir = envir, inherits = FALSE)
[17:46:46.165]                           if (inherits(master, c("SOCKnode", 
[17:46:46.165]                             "SOCK0node"))) {
[17:46:46.165]                             sendCondition <<- function(cond) {
[17:46:46.165]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.165]                                 success = TRUE)
[17:46:46.165]                               parallel_sendData(master, data)
[17:46:46.165]                             }
[17:46:46.165]                             return(sendCondition)
[17:46:46.165]                           }
[17:46:46.165]                         }
[17:46:46.165]                         frame <- frame + 1L
[17:46:46.165]                         envir <- sys.frame(frame)
[17:46:46.165]                       }
[17:46:46.165]                     }
[17:46:46.165]                     sendCondition <<- function(cond) NULL
[17:46:46.165]                   }
[17:46:46.165]                 })
[17:46:46.165]                 withCallingHandlers({
[17:46:46.165]                   NULL
[17:46:46.165]                 }, immediateCondition = function(cond) {
[17:46:46.165]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.165]                   sendCondition(cond)
[17:46:46.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.165]                   {
[17:46:46.165]                     inherits <- base::inherits
[17:46:46.165]                     invokeRestart <- base::invokeRestart
[17:46:46.165]                     is.null <- base::is.null
[17:46:46.165]                     muffled <- FALSE
[17:46:46.165]                     if (inherits(cond, "message")) {
[17:46:46.165]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.165]                       if (muffled) 
[17:46:46.165]                         invokeRestart("muffleMessage")
[17:46:46.165]                     }
[17:46:46.165]                     else if (inherits(cond, "warning")) {
[17:46:46.165]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.165]                       if (muffled) 
[17:46:46.165]                         invokeRestart("muffleWarning")
[17:46:46.165]                     }
[17:46:46.165]                     else if (inherits(cond, "condition")) {
[17:46:46.165]                       if (!is.null(pattern)) {
[17:46:46.165]                         computeRestarts <- base::computeRestarts
[17:46:46.165]                         grepl <- base::grepl
[17:46:46.165]                         restarts <- computeRestarts(cond)
[17:46:46.165]                         for (restart in restarts) {
[17:46:46.165]                           name <- restart$name
[17:46:46.165]                           if (is.null(name)) 
[17:46:46.165]                             next
[17:46:46.165]                           if (!grepl(pattern, name)) 
[17:46:46.165]                             next
[17:46:46.165]                           invokeRestart(restart)
[17:46:46.165]                           muffled <- TRUE
[17:46:46.165]                           break
[17:46:46.165]                         }
[17:46:46.165]                       }
[17:46:46.165]                     }
[17:46:46.165]                     invisible(muffled)
[17:46:46.165]                   }
[17:46:46.165]                   muffleCondition(cond)
[17:46:46.165]                 })
[17:46:46.165]             }))
[17:46:46.165]             future::FutureResult(value = ...future.value$value, 
[17:46:46.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.165]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.165]                     ...future.globalenv.names))
[17:46:46.165]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.165]         }, condition = base::local({
[17:46:46.165]             c <- base::c
[17:46:46.165]             inherits <- base::inherits
[17:46:46.165]             invokeRestart <- base::invokeRestart
[17:46:46.165]             length <- base::length
[17:46:46.165]             list <- base::list
[17:46:46.165]             seq.int <- base::seq.int
[17:46:46.165]             signalCondition <- base::signalCondition
[17:46:46.165]             sys.calls <- base::sys.calls
[17:46:46.165]             `[[` <- base::`[[`
[17:46:46.165]             `+` <- base::`+`
[17:46:46.165]             `<<-` <- base::`<<-`
[17:46:46.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.165]                   3L)]
[17:46:46.165]             }
[17:46:46.165]             function(cond) {
[17:46:46.165]                 is_error <- inherits(cond, "error")
[17:46:46.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.165]                   NULL)
[17:46:46.165]                 if (is_error) {
[17:46:46.165]                   sessionInformation <- function() {
[17:46:46.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.165]                       search = base::search(), system = base::Sys.info())
[17:46:46.165]                   }
[17:46:46.165]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.165]                     cond$call), session = sessionInformation(), 
[17:46:46.165]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.165]                   signalCondition(cond)
[17:46:46.165]                 }
[17:46:46.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.165]                 "immediateCondition"))) {
[17:46:46.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.165]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.165]                   if (TRUE && !signal) {
[17:46:46.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.165]                     {
[17:46:46.165]                       inherits <- base::inherits
[17:46:46.165]                       invokeRestart <- base::invokeRestart
[17:46:46.165]                       is.null <- base::is.null
[17:46:46.165]                       muffled <- FALSE
[17:46:46.165]                       if (inherits(cond, "message")) {
[17:46:46.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.165]                         if (muffled) 
[17:46:46.165]                           invokeRestart("muffleMessage")
[17:46:46.165]                       }
[17:46:46.165]                       else if (inherits(cond, "warning")) {
[17:46:46.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.165]                         if (muffled) 
[17:46:46.165]                           invokeRestart("muffleWarning")
[17:46:46.165]                       }
[17:46:46.165]                       else if (inherits(cond, "condition")) {
[17:46:46.165]                         if (!is.null(pattern)) {
[17:46:46.165]                           computeRestarts <- base::computeRestarts
[17:46:46.165]                           grepl <- base::grepl
[17:46:46.165]                           restarts <- computeRestarts(cond)
[17:46:46.165]                           for (restart in restarts) {
[17:46:46.165]                             name <- restart$name
[17:46:46.165]                             if (is.null(name)) 
[17:46:46.165]                               next
[17:46:46.165]                             if (!grepl(pattern, name)) 
[17:46:46.165]                               next
[17:46:46.165]                             invokeRestart(restart)
[17:46:46.165]                             muffled <- TRUE
[17:46:46.165]                             break
[17:46:46.165]                           }
[17:46:46.165]                         }
[17:46:46.165]                       }
[17:46:46.165]                       invisible(muffled)
[17:46:46.165]                     }
[17:46:46.165]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.165]                   }
[17:46:46.165]                 }
[17:46:46.165]                 else {
[17:46:46.165]                   if (TRUE) {
[17:46:46.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.165]                     {
[17:46:46.165]                       inherits <- base::inherits
[17:46:46.165]                       invokeRestart <- base::invokeRestart
[17:46:46.165]                       is.null <- base::is.null
[17:46:46.165]                       muffled <- FALSE
[17:46:46.165]                       if (inherits(cond, "message")) {
[17:46:46.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.165]                         if (muffled) 
[17:46:46.165]                           invokeRestart("muffleMessage")
[17:46:46.165]                       }
[17:46:46.165]                       else if (inherits(cond, "warning")) {
[17:46:46.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.165]                         if (muffled) 
[17:46:46.165]                           invokeRestart("muffleWarning")
[17:46:46.165]                       }
[17:46:46.165]                       else if (inherits(cond, "condition")) {
[17:46:46.165]                         if (!is.null(pattern)) {
[17:46:46.165]                           computeRestarts <- base::computeRestarts
[17:46:46.165]                           grepl <- base::grepl
[17:46:46.165]                           restarts <- computeRestarts(cond)
[17:46:46.165]                           for (restart in restarts) {
[17:46:46.165]                             name <- restart$name
[17:46:46.165]                             if (is.null(name)) 
[17:46:46.165]                               next
[17:46:46.165]                             if (!grepl(pattern, name)) 
[17:46:46.165]                               next
[17:46:46.165]                             invokeRestart(restart)
[17:46:46.165]                             muffled <- TRUE
[17:46:46.165]                             break
[17:46:46.165]                           }
[17:46:46.165]                         }
[17:46:46.165]                       }
[17:46:46.165]                       invisible(muffled)
[17:46:46.165]                     }
[17:46:46.165]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.165]                   }
[17:46:46.165]                 }
[17:46:46.165]             }
[17:46:46.165]         }))
[17:46:46.165]     }, error = function(ex) {
[17:46:46.165]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.165]                 ...future.rng), started = ...future.startTime, 
[17:46:46.165]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.165]             version = "1.8"), class = "FutureResult")
[17:46:46.165]     }, finally = {
[17:46:46.165]         if (!identical(...future.workdir, getwd())) 
[17:46:46.165]             setwd(...future.workdir)
[17:46:46.165]         {
[17:46:46.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.165]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.165]             }
[17:46:46.165]             base::options(...future.oldOptions)
[17:46:46.165]             if (.Platform$OS.type == "windows") {
[17:46:46.165]                 old_names <- names(...future.oldEnvVars)
[17:46:46.165]                 envs <- base::Sys.getenv()
[17:46:46.165]                 names <- names(envs)
[17:46:46.165]                 common <- intersect(names, old_names)
[17:46:46.165]                 added <- setdiff(names, old_names)
[17:46:46.165]                 removed <- setdiff(old_names, names)
[17:46:46.165]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.165]                   envs[common]]
[17:46:46.165]                 NAMES <- toupper(changed)
[17:46:46.165]                 args <- list()
[17:46:46.165]                 for (kk in seq_along(NAMES)) {
[17:46:46.165]                   name <- changed[[kk]]
[17:46:46.165]                   NAME <- NAMES[[kk]]
[17:46:46.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.165]                     next
[17:46:46.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.165]                 }
[17:46:46.165]                 NAMES <- toupper(added)
[17:46:46.165]                 for (kk in seq_along(NAMES)) {
[17:46:46.165]                   name <- added[[kk]]
[17:46:46.165]                   NAME <- NAMES[[kk]]
[17:46:46.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.165]                     next
[17:46:46.165]                   args[[name]] <- ""
[17:46:46.165]                 }
[17:46:46.165]                 NAMES <- toupper(removed)
[17:46:46.165]                 for (kk in seq_along(NAMES)) {
[17:46:46.165]                   name <- removed[[kk]]
[17:46:46.165]                   NAME <- NAMES[[kk]]
[17:46:46.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.165]                     next
[17:46:46.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.165]                 }
[17:46:46.165]                 if (length(args) > 0) 
[17:46:46.165]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.165]             }
[17:46:46.165]             else {
[17:46:46.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.165]             }
[17:46:46.165]             {
[17:46:46.165]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.165]                   0L) {
[17:46:46.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.165]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.165]                   base::options(opts)
[17:46:46.165]                 }
[17:46:46.165]                 {
[17:46:46.165]                   {
[17:46:46.165]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.165]                     NULL
[17:46:46.165]                   }
[17:46:46.165]                   options(future.plan = NULL)
[17:46:46.165]                   if (is.na(NA_character_)) 
[17:46:46.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.165]                     .init = FALSE)
[17:46:46.165]                 }
[17:46:46.165]             }
[17:46:46.165]         }
[17:46:46.165]     })
[17:46:46.165]     if (TRUE) {
[17:46:46.165]         base::sink(type = "output", split = FALSE)
[17:46:46.165]         if (TRUE) {
[17:46:46.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.165]         }
[17:46:46.165]         else {
[17:46:46.165]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.165]         }
[17:46:46.165]         base::close(...future.stdout)
[17:46:46.165]         ...future.stdout <- NULL
[17:46:46.165]     }
[17:46:46.165]     ...future.result$conditions <- ...future.conditions
[17:46:46.165]     ...future.result$finished <- base::Sys.time()
[17:46:46.165]     ...future.result
[17:46:46.165] }
[17:46:46.218] MultisessionFuture started
[17:46:46.218] - Launch lazy future ... done
[17:46:46.218] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561788cd43e8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561789134e78> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561788cd43e8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561789134e78> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:46:46.224] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.224] - Validating connection of MultisessionFuture
[17:46:46.224] - received message: FutureResult
[17:46:46.225] - Received FutureResult
[17:46:46.225] - Erased future from FutureRegistry
[17:46:46.225] result() for ClusterFuture ...
[17:46:46.225] - result already collected: FutureResult
[17:46:46.225] result() for ClusterFuture ... done
[17:46:46.225] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:46.237] resolve() on list ...
[17:46:46.237]  recursive: 0
[17:46:46.237]  length: 6
[17:46:46.237]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:46.237] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.237] - nx: 6
[17:46:46.237] - relay: TRUE
[17:46:46.238] - stdout: TRUE
[17:46:46.238] - signal: TRUE
[17:46:46.238] - resignal: FALSE
[17:46:46.238] - force: TRUE
[17:46:46.238] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.238] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.238]  - until=2
[17:46:46.238]  - relaying element #2
[17:46:46.238] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.239] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.239] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.239]  length: 5 (resolved future 1)
[17:46:46.239] Future #2
[17:46:46.239] result() for ClusterFuture ...
[17:46:46.239] - result already collected: FutureResult
[17:46:46.239] result() for ClusterFuture ... done
[17:46:46.239] result() for ClusterFuture ...
[17:46:46.240] - result already collected: FutureResult
[17:46:46.240] result() for ClusterFuture ... done
[17:46:46.240] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:46.240] - nx: 6
[17:46:46.240] - relay: TRUE
[17:46:46.240] - stdout: TRUE
[17:46:46.240] - signal: TRUE
[17:46:46.240] - resignal: FALSE
[17:46:46.240] - force: TRUE
[17:46:46.241] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.241] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.241]  - until=2
[17:46:46.241]  - relaying element #2
[17:46:46.241] result() for ClusterFuture ...
[17:46:46.241] - result already collected: FutureResult
[17:46:46.241] result() for ClusterFuture ... done
[17:46:46.241] result() for ClusterFuture ...
[17:46:46.241] - result already collected: FutureResult
[17:46:46.242] result() for ClusterFuture ... done
[17:46:46.242] result() for ClusterFuture ...
[17:46:46.242] - result already collected: FutureResult
[17:46:46.242] result() for ClusterFuture ... done
[17:46:46.242] result() for ClusterFuture ...
[17:46:46.242] - result already collected: FutureResult
[17:46:46.242] result() for ClusterFuture ... done
[17:46:46.242] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.242] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.243] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:46.243]  length: 4 (resolved future 2)
[17:46:46.250] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.251] - Validating connection of MultisessionFuture
[17:46:46.251] - received message: FutureResult
[17:46:46.251] - Received FutureResult
[17:46:46.251] - Erased future from FutureRegistry
[17:46:46.251] result() for ClusterFuture ...
[17:46:46.251] - result already collected: FutureResult
[17:46:46.252] result() for ClusterFuture ... done
[17:46:46.252] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:46.252] Future #3
[17:46:46.252] result() for ClusterFuture ...
[17:46:46.252] - result already collected: FutureResult
[17:46:46.252] result() for ClusterFuture ... done
[17:46:46.252] result() for ClusterFuture ...
[17:46:46.252] - result already collected: FutureResult
[17:46:46.252] result() for ClusterFuture ... done
[17:46:46.253] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:46.253] - nx: 6
[17:46:46.253] - relay: TRUE
[17:46:46.253] - stdout: TRUE
[17:46:46.253] - signal: TRUE
[17:46:46.253] - resignal: FALSE
[17:46:46.253] - force: TRUE
[17:46:46.253] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.253] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.253]  - until=3
[17:46:46.254]  - relaying element #3
[17:46:46.254] result() for ClusterFuture ...
[17:46:46.254] - result already collected: FutureResult
[17:46:46.254] result() for ClusterFuture ... done
[17:46:46.254] result() for ClusterFuture ...
[17:46:46.254] - result already collected: FutureResult
[17:46:46.254] result() for ClusterFuture ... done
[17:46:46.254] result() for ClusterFuture ...
[17:46:46.254] - result already collected: FutureResult
[17:46:46.255] result() for ClusterFuture ... done
[17:46:46.255] result() for ClusterFuture ...
[17:46:46.255] - result already collected: FutureResult
[17:46:46.255] result() for ClusterFuture ... done
[17:46:46.255] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.255] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.255] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:46.255]  length: 3 (resolved future 3)
[17:46:46.256] signalConditionsASAP(NULL, pos=4) ...
[17:46:46.256] - nx: 6
[17:46:46.256] - relay: TRUE
[17:46:46.256] - stdout: TRUE
[17:46:46.256] - signal: TRUE
[17:46:46.256] - resignal: FALSE
[17:46:46.256] - force: TRUE
[17:46:46.256] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.256] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.256]  - until=5
[17:46:46.257]  - relaying element #5
[17:46:46.257] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.257] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.257] signalConditionsASAP(NULL, pos=4) ... done
[17:46:46.257]  length: 2 (resolved future 4)
[17:46:46.257] signalConditionsASAP(NULL, pos=5) ...
[17:46:46.257] - nx: 6
[17:46:46.257] - relay: TRUE
[17:46:46.257] - stdout: TRUE
[17:46:46.258] - signal: TRUE
[17:46:46.258] - resignal: FALSE
[17:46:46.258] - force: TRUE
[17:46:46.258] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.258] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.258]  - until=6
[17:46:46.258]  - relaying element #6
[17:46:46.258] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.258] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.259] signalConditionsASAP(NULL, pos=5) ... done
[17:46:46.259]  length: 1 (resolved future 5)
[17:46:46.259] signalConditionsASAP(numeric, pos=6) ...
[17:46:46.259] - nx: 6
[17:46:46.259] - relay: TRUE
[17:46:46.259] - stdout: TRUE
[17:46:46.259] - signal: TRUE
[17:46:46.259] - resignal: FALSE
[17:46:46.259] - force: TRUE
[17:46:46.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.260] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.260]  - until=6
[17:46:46.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.260] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.260] signalConditionsASAP(numeric, pos=6) ... done
[17:46:46.260]  length: 0 (resolved future 6)
[17:46:46.260] Relaying remaining futures
[17:46:46.260] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.261] - nx: 6
[17:46:46.261] - relay: TRUE
[17:46:46.261] - stdout: TRUE
[17:46:46.261] - signal: TRUE
[17:46:46.261] - resignal: FALSE
[17:46:46.261] - force: TRUE
[17:46:46.261] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.261] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:46.261] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.262] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.262] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.262] resolve() on list ... DONE
[17:46:46.262] result() for ClusterFuture ...
[17:46:46.262] - result already collected: FutureResult
[17:46:46.264] result() for ClusterFuture ... done
[17:46:46.265] result() for ClusterFuture ...
[17:46:46.265] - result already collected: FutureResult
[17:46:46.265] result() for ClusterFuture ... done
[17:46:46.265] result() for ClusterFuture ...
[17:46:46.265] - result already collected: FutureResult
[17:46:46.265] result() for ClusterFuture ... done
[17:46:46.265] result() for ClusterFuture ...
[17:46:46.265] - result already collected: FutureResult
[17:46:46.265] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:46:46.267] getGlobalsAndPackages() ...
[17:46:46.268] Searching for globals...
[17:46:46.268] 
[17:46:46.268] Searching for globals ... DONE
[17:46:46.268] - globals: [0] <none>
[17:46:46.268] getGlobalsAndPackages() ... DONE
[17:46:46.268] run() for ‘Future’ ...
[17:46:46.268] - state: ‘created’
[17:46:46.269] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.283] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.283]   - Field: ‘node’
[17:46:46.283]   - Field: ‘label’
[17:46:46.283]   - Field: ‘local’
[17:46:46.283]   - Field: ‘owner’
[17:46:46.283]   - Field: ‘envir’
[17:46:46.284]   - Field: ‘workers’
[17:46:46.284]   - Field: ‘packages’
[17:46:46.284]   - Field: ‘gc’
[17:46:46.284]   - Field: ‘conditions’
[17:46:46.284]   - Field: ‘persistent’
[17:46:46.284]   - Field: ‘expr’
[17:46:46.284]   - Field: ‘uuid’
[17:46:46.284]   - Field: ‘seed’
[17:46:46.284]   - Field: ‘version’
[17:46:46.284]   - Field: ‘result’
[17:46:46.284]   - Field: ‘asynchronous’
[17:46:46.285]   - Field: ‘calls’
[17:46:46.285]   - Field: ‘globals’
[17:46:46.285]   - Field: ‘stdout’
[17:46:46.285]   - Field: ‘earlySignal’
[17:46:46.285]   - Field: ‘lazy’
[17:46:46.285]   - Field: ‘state’
[17:46:46.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.285] - Launch lazy future ...
[17:46:46.285] Packages needed by the future expression (n = 0): <none>
[17:46:46.285] Packages needed by future strategies (n = 0): <none>
[17:46:46.286] {
[17:46:46.286]     {
[17:46:46.286]         {
[17:46:46.286]             ...future.startTime <- base::Sys.time()
[17:46:46.286]             {
[17:46:46.286]                 {
[17:46:46.286]                   {
[17:46:46.286]                     {
[17:46:46.286]                       base::local({
[17:46:46.286]                         has_future <- base::requireNamespace("future", 
[17:46:46.286]                           quietly = TRUE)
[17:46:46.286]                         if (has_future) {
[17:46:46.286]                           ns <- base::getNamespace("future")
[17:46:46.286]                           version <- ns[[".package"]][["version"]]
[17:46:46.286]                           if (is.null(version)) 
[17:46:46.286]                             version <- utils::packageVersion("future")
[17:46:46.286]                         }
[17:46:46.286]                         else {
[17:46:46.286]                           version <- NULL
[17:46:46.286]                         }
[17:46:46.286]                         if (!has_future || version < "1.8.0") {
[17:46:46.286]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.286]                             "", base::R.version$version.string), 
[17:46:46.286]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.286]                               "release", "version")], collapse = " "), 
[17:46:46.286]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.286]                             info)
[17:46:46.286]                           info <- base::paste(info, collapse = "; ")
[17:46:46.286]                           if (!has_future) {
[17:46:46.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.286]                               info)
[17:46:46.286]                           }
[17:46:46.286]                           else {
[17:46:46.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.286]                               info, version)
[17:46:46.286]                           }
[17:46:46.286]                           base::stop(msg)
[17:46:46.286]                         }
[17:46:46.286]                       })
[17:46:46.286]                     }
[17:46:46.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.286]                     base::options(mc.cores = 1L)
[17:46:46.286]                   }
[17:46:46.286]                   ...future.strategy.old <- future::plan("list")
[17:46:46.286]                   options(future.plan = NULL)
[17:46:46.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.286]                 }
[17:46:46.286]                 ...future.workdir <- getwd()
[17:46:46.286]             }
[17:46:46.286]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.286]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.286]         }
[17:46:46.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.286]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.286]             base::names(...future.oldOptions))
[17:46:46.286]     }
[17:46:46.286]     if (FALSE) {
[17:46:46.286]     }
[17:46:46.286]     else {
[17:46:46.286]         if (TRUE) {
[17:46:46.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.286]                 open = "w")
[17:46:46.286]         }
[17:46:46.286]         else {
[17:46:46.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.286]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.286]         }
[17:46:46.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.286]             base::sink(type = "output", split = FALSE)
[17:46:46.286]             base::close(...future.stdout)
[17:46:46.286]         }, add = TRUE)
[17:46:46.286]     }
[17:46:46.286]     ...future.frame <- base::sys.nframe()
[17:46:46.286]     ...future.conditions <- base::list()
[17:46:46.286]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.286]     if (FALSE) {
[17:46:46.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.286]     }
[17:46:46.286]     ...future.result <- base::tryCatch({
[17:46:46.286]         base::withCallingHandlers({
[17:46:46.286]             ...future.value <- base::withVisible(base::local({
[17:46:46.286]                 ...future.makeSendCondition <- base::local({
[17:46:46.286]                   sendCondition <- NULL
[17:46:46.286]                   function(frame = 1L) {
[17:46:46.286]                     if (is.function(sendCondition)) 
[17:46:46.286]                       return(sendCondition)
[17:46:46.286]                     ns <- getNamespace("parallel")
[17:46:46.286]                     if (exists("sendData", mode = "function", 
[17:46:46.286]                       envir = ns)) {
[17:46:46.286]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.286]                         envir = ns)
[17:46:46.286]                       envir <- sys.frame(frame)
[17:46:46.286]                       master <- NULL
[17:46:46.286]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.286]                         !identical(envir, emptyenv())) {
[17:46:46.286]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.286]                           inherits = FALSE)) {
[17:46:46.286]                           master <- get("master", mode = "list", 
[17:46:46.286]                             envir = envir, inherits = FALSE)
[17:46:46.286]                           if (inherits(master, c("SOCKnode", 
[17:46:46.286]                             "SOCK0node"))) {
[17:46:46.286]                             sendCondition <<- function(cond) {
[17:46:46.286]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.286]                                 success = TRUE)
[17:46:46.286]                               parallel_sendData(master, data)
[17:46:46.286]                             }
[17:46:46.286]                             return(sendCondition)
[17:46:46.286]                           }
[17:46:46.286]                         }
[17:46:46.286]                         frame <- frame + 1L
[17:46:46.286]                         envir <- sys.frame(frame)
[17:46:46.286]                       }
[17:46:46.286]                     }
[17:46:46.286]                     sendCondition <<- function(cond) NULL
[17:46:46.286]                   }
[17:46:46.286]                 })
[17:46:46.286]                 withCallingHandlers({
[17:46:46.286]                   2
[17:46:46.286]                 }, immediateCondition = function(cond) {
[17:46:46.286]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.286]                   sendCondition(cond)
[17:46:46.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.286]                   {
[17:46:46.286]                     inherits <- base::inherits
[17:46:46.286]                     invokeRestart <- base::invokeRestart
[17:46:46.286]                     is.null <- base::is.null
[17:46:46.286]                     muffled <- FALSE
[17:46:46.286]                     if (inherits(cond, "message")) {
[17:46:46.286]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.286]                       if (muffled) 
[17:46:46.286]                         invokeRestart("muffleMessage")
[17:46:46.286]                     }
[17:46:46.286]                     else if (inherits(cond, "warning")) {
[17:46:46.286]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.286]                       if (muffled) 
[17:46:46.286]                         invokeRestart("muffleWarning")
[17:46:46.286]                     }
[17:46:46.286]                     else if (inherits(cond, "condition")) {
[17:46:46.286]                       if (!is.null(pattern)) {
[17:46:46.286]                         computeRestarts <- base::computeRestarts
[17:46:46.286]                         grepl <- base::grepl
[17:46:46.286]                         restarts <- computeRestarts(cond)
[17:46:46.286]                         for (restart in restarts) {
[17:46:46.286]                           name <- restart$name
[17:46:46.286]                           if (is.null(name)) 
[17:46:46.286]                             next
[17:46:46.286]                           if (!grepl(pattern, name)) 
[17:46:46.286]                             next
[17:46:46.286]                           invokeRestart(restart)
[17:46:46.286]                           muffled <- TRUE
[17:46:46.286]                           break
[17:46:46.286]                         }
[17:46:46.286]                       }
[17:46:46.286]                     }
[17:46:46.286]                     invisible(muffled)
[17:46:46.286]                   }
[17:46:46.286]                   muffleCondition(cond)
[17:46:46.286]                 })
[17:46:46.286]             }))
[17:46:46.286]             future::FutureResult(value = ...future.value$value, 
[17:46:46.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.286]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.286]                     ...future.globalenv.names))
[17:46:46.286]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.286]         }, condition = base::local({
[17:46:46.286]             c <- base::c
[17:46:46.286]             inherits <- base::inherits
[17:46:46.286]             invokeRestart <- base::invokeRestart
[17:46:46.286]             length <- base::length
[17:46:46.286]             list <- base::list
[17:46:46.286]             seq.int <- base::seq.int
[17:46:46.286]             signalCondition <- base::signalCondition
[17:46:46.286]             sys.calls <- base::sys.calls
[17:46:46.286]             `[[` <- base::`[[`
[17:46:46.286]             `+` <- base::`+`
[17:46:46.286]             `<<-` <- base::`<<-`
[17:46:46.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.286]                   3L)]
[17:46:46.286]             }
[17:46:46.286]             function(cond) {
[17:46:46.286]                 is_error <- inherits(cond, "error")
[17:46:46.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.286]                   NULL)
[17:46:46.286]                 if (is_error) {
[17:46:46.286]                   sessionInformation <- function() {
[17:46:46.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.286]                       search = base::search(), system = base::Sys.info())
[17:46:46.286]                   }
[17:46:46.286]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.286]                     cond$call), session = sessionInformation(), 
[17:46:46.286]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.286]                   signalCondition(cond)
[17:46:46.286]                 }
[17:46:46.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.286]                 "immediateCondition"))) {
[17:46:46.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.286]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.286]                   if (TRUE && !signal) {
[17:46:46.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.286]                     {
[17:46:46.286]                       inherits <- base::inherits
[17:46:46.286]                       invokeRestart <- base::invokeRestart
[17:46:46.286]                       is.null <- base::is.null
[17:46:46.286]                       muffled <- FALSE
[17:46:46.286]                       if (inherits(cond, "message")) {
[17:46:46.286]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.286]                         if (muffled) 
[17:46:46.286]                           invokeRestart("muffleMessage")
[17:46:46.286]                       }
[17:46:46.286]                       else if (inherits(cond, "warning")) {
[17:46:46.286]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.286]                         if (muffled) 
[17:46:46.286]                           invokeRestart("muffleWarning")
[17:46:46.286]                       }
[17:46:46.286]                       else if (inherits(cond, "condition")) {
[17:46:46.286]                         if (!is.null(pattern)) {
[17:46:46.286]                           computeRestarts <- base::computeRestarts
[17:46:46.286]                           grepl <- base::grepl
[17:46:46.286]                           restarts <- computeRestarts(cond)
[17:46:46.286]                           for (restart in restarts) {
[17:46:46.286]                             name <- restart$name
[17:46:46.286]                             if (is.null(name)) 
[17:46:46.286]                               next
[17:46:46.286]                             if (!grepl(pattern, name)) 
[17:46:46.286]                               next
[17:46:46.286]                             invokeRestart(restart)
[17:46:46.286]                             muffled <- TRUE
[17:46:46.286]                             break
[17:46:46.286]                           }
[17:46:46.286]                         }
[17:46:46.286]                       }
[17:46:46.286]                       invisible(muffled)
[17:46:46.286]                     }
[17:46:46.286]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.286]                   }
[17:46:46.286]                 }
[17:46:46.286]                 else {
[17:46:46.286]                   if (TRUE) {
[17:46:46.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.286]                     {
[17:46:46.286]                       inherits <- base::inherits
[17:46:46.286]                       invokeRestart <- base::invokeRestart
[17:46:46.286]                       is.null <- base::is.null
[17:46:46.286]                       muffled <- FALSE
[17:46:46.286]                       if (inherits(cond, "message")) {
[17:46:46.286]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.286]                         if (muffled) 
[17:46:46.286]                           invokeRestart("muffleMessage")
[17:46:46.286]                       }
[17:46:46.286]                       else if (inherits(cond, "warning")) {
[17:46:46.286]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.286]                         if (muffled) 
[17:46:46.286]                           invokeRestart("muffleWarning")
[17:46:46.286]                       }
[17:46:46.286]                       else if (inherits(cond, "condition")) {
[17:46:46.286]                         if (!is.null(pattern)) {
[17:46:46.286]                           computeRestarts <- base::computeRestarts
[17:46:46.286]                           grepl <- base::grepl
[17:46:46.286]                           restarts <- computeRestarts(cond)
[17:46:46.286]                           for (restart in restarts) {
[17:46:46.286]                             name <- restart$name
[17:46:46.286]                             if (is.null(name)) 
[17:46:46.286]                               next
[17:46:46.286]                             if (!grepl(pattern, name)) 
[17:46:46.286]                               next
[17:46:46.286]                             invokeRestart(restart)
[17:46:46.286]                             muffled <- TRUE
[17:46:46.286]                             break
[17:46:46.286]                           }
[17:46:46.286]                         }
[17:46:46.286]                       }
[17:46:46.286]                       invisible(muffled)
[17:46:46.286]                     }
[17:46:46.286]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.286]                   }
[17:46:46.286]                 }
[17:46:46.286]             }
[17:46:46.286]         }))
[17:46:46.286]     }, error = function(ex) {
[17:46:46.286]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.286]                 ...future.rng), started = ...future.startTime, 
[17:46:46.286]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.286]             version = "1.8"), class = "FutureResult")
[17:46:46.286]     }, finally = {
[17:46:46.286]         if (!identical(...future.workdir, getwd())) 
[17:46:46.286]             setwd(...future.workdir)
[17:46:46.286]         {
[17:46:46.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.286]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.286]             }
[17:46:46.286]             base::options(...future.oldOptions)
[17:46:46.286]             if (.Platform$OS.type == "windows") {
[17:46:46.286]                 old_names <- names(...future.oldEnvVars)
[17:46:46.286]                 envs <- base::Sys.getenv()
[17:46:46.286]                 names <- names(envs)
[17:46:46.286]                 common <- intersect(names, old_names)
[17:46:46.286]                 added <- setdiff(names, old_names)
[17:46:46.286]                 removed <- setdiff(old_names, names)
[17:46:46.286]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.286]                   envs[common]]
[17:46:46.286]                 NAMES <- toupper(changed)
[17:46:46.286]                 args <- list()
[17:46:46.286]                 for (kk in seq_along(NAMES)) {
[17:46:46.286]                   name <- changed[[kk]]
[17:46:46.286]                   NAME <- NAMES[[kk]]
[17:46:46.286]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.286]                     next
[17:46:46.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.286]                 }
[17:46:46.286]                 NAMES <- toupper(added)
[17:46:46.286]                 for (kk in seq_along(NAMES)) {
[17:46:46.286]                   name <- added[[kk]]
[17:46:46.286]                   NAME <- NAMES[[kk]]
[17:46:46.286]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.286]                     next
[17:46:46.286]                   args[[name]] <- ""
[17:46:46.286]                 }
[17:46:46.286]                 NAMES <- toupper(removed)
[17:46:46.286]                 for (kk in seq_along(NAMES)) {
[17:46:46.286]                   name <- removed[[kk]]
[17:46:46.286]                   NAME <- NAMES[[kk]]
[17:46:46.286]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.286]                     next
[17:46:46.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.286]                 }
[17:46:46.286]                 if (length(args) > 0) 
[17:46:46.286]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.286]             }
[17:46:46.286]             else {
[17:46:46.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.286]             }
[17:46:46.286]             {
[17:46:46.286]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.286]                   0L) {
[17:46:46.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.286]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.286]                   base::options(opts)
[17:46:46.286]                 }
[17:46:46.286]                 {
[17:46:46.286]                   {
[17:46:46.286]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.286]                     NULL
[17:46:46.286]                   }
[17:46:46.286]                   options(future.plan = NULL)
[17:46:46.286]                   if (is.na(NA_character_)) 
[17:46:46.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.286]                     .init = FALSE)
[17:46:46.286]                 }
[17:46:46.286]             }
[17:46:46.286]         }
[17:46:46.286]     })
[17:46:46.286]     if (TRUE) {
[17:46:46.286]         base::sink(type = "output", split = FALSE)
[17:46:46.286]         if (TRUE) {
[17:46:46.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.286]         }
[17:46:46.286]         else {
[17:46:46.286]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.286]         }
[17:46:46.286]         base::close(...future.stdout)
[17:46:46.286]         ...future.stdout <- NULL
[17:46:46.286]     }
[17:46:46.286]     ...future.result$conditions <- ...future.conditions
[17:46:46.286]     ...future.result$finished <- base::Sys.time()
[17:46:46.286]     ...future.result
[17:46:46.286] }
[17:46:46.289] MultisessionFuture started
[17:46:46.289] - Launch lazy future ... done
[17:46:46.289] run() for ‘MultisessionFuture’ ... done
[17:46:46.289] getGlobalsAndPackages() ...
[17:46:46.289] Searching for globals...
[17:46:46.290] 
[17:46:46.290] Searching for globals ... DONE
[17:46:46.290] - globals: [0] <none>
[17:46:46.290] getGlobalsAndPackages() ... DONE
[17:46:46.290] run() for ‘Future’ ...
[17:46:46.290] - state: ‘created’
[17:46:46.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.304] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.305]   - Field: ‘node’
[17:46:46.305]   - Field: ‘label’
[17:46:46.305]   - Field: ‘local’
[17:46:46.305]   - Field: ‘owner’
[17:46:46.305]   - Field: ‘envir’
[17:46:46.305]   - Field: ‘workers’
[17:46:46.305]   - Field: ‘packages’
[17:46:46.305]   - Field: ‘gc’
[17:46:46.305]   - Field: ‘conditions’
[17:46:46.305]   - Field: ‘persistent’
[17:46:46.305]   - Field: ‘expr’
[17:46:46.306]   - Field: ‘uuid’
[17:46:46.306]   - Field: ‘seed’
[17:46:46.306]   - Field: ‘version’
[17:46:46.306]   - Field: ‘result’
[17:46:46.306]   - Field: ‘asynchronous’
[17:46:46.306]   - Field: ‘calls’
[17:46:46.306]   - Field: ‘globals’
[17:46:46.306]   - Field: ‘stdout’
[17:46:46.306]   - Field: ‘earlySignal’
[17:46:46.306]   - Field: ‘lazy’
[17:46:46.306]   - Field: ‘state’
[17:46:46.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.307] - Launch lazy future ...
[17:46:46.307] Packages needed by the future expression (n = 0): <none>
[17:46:46.307] Packages needed by future strategies (n = 0): <none>
[17:46:46.307] {
[17:46:46.307]     {
[17:46:46.307]         {
[17:46:46.307]             ...future.startTime <- base::Sys.time()
[17:46:46.307]             {
[17:46:46.307]                 {
[17:46:46.307]                   {
[17:46:46.307]                     {
[17:46:46.307]                       base::local({
[17:46:46.307]                         has_future <- base::requireNamespace("future", 
[17:46:46.307]                           quietly = TRUE)
[17:46:46.307]                         if (has_future) {
[17:46:46.307]                           ns <- base::getNamespace("future")
[17:46:46.307]                           version <- ns[[".package"]][["version"]]
[17:46:46.307]                           if (is.null(version)) 
[17:46:46.307]                             version <- utils::packageVersion("future")
[17:46:46.307]                         }
[17:46:46.307]                         else {
[17:46:46.307]                           version <- NULL
[17:46:46.307]                         }
[17:46:46.307]                         if (!has_future || version < "1.8.0") {
[17:46:46.307]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.307]                             "", base::R.version$version.string), 
[17:46:46.307]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.307]                               "release", "version")], collapse = " "), 
[17:46:46.307]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.307]                             info)
[17:46:46.307]                           info <- base::paste(info, collapse = "; ")
[17:46:46.307]                           if (!has_future) {
[17:46:46.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.307]                               info)
[17:46:46.307]                           }
[17:46:46.307]                           else {
[17:46:46.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.307]                               info, version)
[17:46:46.307]                           }
[17:46:46.307]                           base::stop(msg)
[17:46:46.307]                         }
[17:46:46.307]                       })
[17:46:46.307]                     }
[17:46:46.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.307]                     base::options(mc.cores = 1L)
[17:46:46.307]                   }
[17:46:46.307]                   ...future.strategy.old <- future::plan("list")
[17:46:46.307]                   options(future.plan = NULL)
[17:46:46.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.307]                 }
[17:46:46.307]                 ...future.workdir <- getwd()
[17:46:46.307]             }
[17:46:46.307]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.307]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.307]         }
[17:46:46.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.307]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.307]             base::names(...future.oldOptions))
[17:46:46.307]     }
[17:46:46.307]     if (FALSE) {
[17:46:46.307]     }
[17:46:46.307]     else {
[17:46:46.307]         if (TRUE) {
[17:46:46.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.307]                 open = "w")
[17:46:46.307]         }
[17:46:46.307]         else {
[17:46:46.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.307]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.307]         }
[17:46:46.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.307]             base::sink(type = "output", split = FALSE)
[17:46:46.307]             base::close(...future.stdout)
[17:46:46.307]         }, add = TRUE)
[17:46:46.307]     }
[17:46:46.307]     ...future.frame <- base::sys.nframe()
[17:46:46.307]     ...future.conditions <- base::list()
[17:46:46.307]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.307]     if (FALSE) {
[17:46:46.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.307]     }
[17:46:46.307]     ...future.result <- base::tryCatch({
[17:46:46.307]         base::withCallingHandlers({
[17:46:46.307]             ...future.value <- base::withVisible(base::local({
[17:46:46.307]                 ...future.makeSendCondition <- base::local({
[17:46:46.307]                   sendCondition <- NULL
[17:46:46.307]                   function(frame = 1L) {
[17:46:46.307]                     if (is.function(sendCondition)) 
[17:46:46.307]                       return(sendCondition)
[17:46:46.307]                     ns <- getNamespace("parallel")
[17:46:46.307]                     if (exists("sendData", mode = "function", 
[17:46:46.307]                       envir = ns)) {
[17:46:46.307]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.307]                         envir = ns)
[17:46:46.307]                       envir <- sys.frame(frame)
[17:46:46.307]                       master <- NULL
[17:46:46.307]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.307]                         !identical(envir, emptyenv())) {
[17:46:46.307]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.307]                           inherits = FALSE)) {
[17:46:46.307]                           master <- get("master", mode = "list", 
[17:46:46.307]                             envir = envir, inherits = FALSE)
[17:46:46.307]                           if (inherits(master, c("SOCKnode", 
[17:46:46.307]                             "SOCK0node"))) {
[17:46:46.307]                             sendCondition <<- function(cond) {
[17:46:46.307]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.307]                                 success = TRUE)
[17:46:46.307]                               parallel_sendData(master, data)
[17:46:46.307]                             }
[17:46:46.307]                             return(sendCondition)
[17:46:46.307]                           }
[17:46:46.307]                         }
[17:46:46.307]                         frame <- frame + 1L
[17:46:46.307]                         envir <- sys.frame(frame)
[17:46:46.307]                       }
[17:46:46.307]                     }
[17:46:46.307]                     sendCondition <<- function(cond) NULL
[17:46:46.307]                   }
[17:46:46.307]                 })
[17:46:46.307]                 withCallingHandlers({
[17:46:46.307]                   NULL
[17:46:46.307]                 }, immediateCondition = function(cond) {
[17:46:46.307]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.307]                   sendCondition(cond)
[17:46:46.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.307]                   {
[17:46:46.307]                     inherits <- base::inherits
[17:46:46.307]                     invokeRestart <- base::invokeRestart
[17:46:46.307]                     is.null <- base::is.null
[17:46:46.307]                     muffled <- FALSE
[17:46:46.307]                     if (inherits(cond, "message")) {
[17:46:46.307]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.307]                       if (muffled) 
[17:46:46.307]                         invokeRestart("muffleMessage")
[17:46:46.307]                     }
[17:46:46.307]                     else if (inherits(cond, "warning")) {
[17:46:46.307]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.307]                       if (muffled) 
[17:46:46.307]                         invokeRestart("muffleWarning")
[17:46:46.307]                     }
[17:46:46.307]                     else if (inherits(cond, "condition")) {
[17:46:46.307]                       if (!is.null(pattern)) {
[17:46:46.307]                         computeRestarts <- base::computeRestarts
[17:46:46.307]                         grepl <- base::grepl
[17:46:46.307]                         restarts <- computeRestarts(cond)
[17:46:46.307]                         for (restart in restarts) {
[17:46:46.307]                           name <- restart$name
[17:46:46.307]                           if (is.null(name)) 
[17:46:46.307]                             next
[17:46:46.307]                           if (!grepl(pattern, name)) 
[17:46:46.307]                             next
[17:46:46.307]                           invokeRestart(restart)
[17:46:46.307]                           muffled <- TRUE
[17:46:46.307]                           break
[17:46:46.307]                         }
[17:46:46.307]                       }
[17:46:46.307]                     }
[17:46:46.307]                     invisible(muffled)
[17:46:46.307]                   }
[17:46:46.307]                   muffleCondition(cond)
[17:46:46.307]                 })
[17:46:46.307]             }))
[17:46:46.307]             future::FutureResult(value = ...future.value$value, 
[17:46:46.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.307]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.307]                     ...future.globalenv.names))
[17:46:46.307]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.307]         }, condition = base::local({
[17:46:46.307]             c <- base::c
[17:46:46.307]             inherits <- base::inherits
[17:46:46.307]             invokeRestart <- base::invokeRestart
[17:46:46.307]             length <- base::length
[17:46:46.307]             list <- base::list
[17:46:46.307]             seq.int <- base::seq.int
[17:46:46.307]             signalCondition <- base::signalCondition
[17:46:46.307]             sys.calls <- base::sys.calls
[17:46:46.307]             `[[` <- base::`[[`
[17:46:46.307]             `+` <- base::`+`
[17:46:46.307]             `<<-` <- base::`<<-`
[17:46:46.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.307]                   3L)]
[17:46:46.307]             }
[17:46:46.307]             function(cond) {
[17:46:46.307]                 is_error <- inherits(cond, "error")
[17:46:46.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.307]                   NULL)
[17:46:46.307]                 if (is_error) {
[17:46:46.307]                   sessionInformation <- function() {
[17:46:46.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.307]                       search = base::search(), system = base::Sys.info())
[17:46:46.307]                   }
[17:46:46.307]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.307]                     cond$call), session = sessionInformation(), 
[17:46:46.307]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.307]                   signalCondition(cond)
[17:46:46.307]                 }
[17:46:46.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.307]                 "immediateCondition"))) {
[17:46:46.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.307]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.307]                   if (TRUE && !signal) {
[17:46:46.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.307]                     {
[17:46:46.307]                       inherits <- base::inherits
[17:46:46.307]                       invokeRestart <- base::invokeRestart
[17:46:46.307]                       is.null <- base::is.null
[17:46:46.307]                       muffled <- FALSE
[17:46:46.307]                       if (inherits(cond, "message")) {
[17:46:46.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.307]                         if (muffled) 
[17:46:46.307]                           invokeRestart("muffleMessage")
[17:46:46.307]                       }
[17:46:46.307]                       else if (inherits(cond, "warning")) {
[17:46:46.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.307]                         if (muffled) 
[17:46:46.307]                           invokeRestart("muffleWarning")
[17:46:46.307]                       }
[17:46:46.307]                       else if (inherits(cond, "condition")) {
[17:46:46.307]                         if (!is.null(pattern)) {
[17:46:46.307]                           computeRestarts <- base::computeRestarts
[17:46:46.307]                           grepl <- base::grepl
[17:46:46.307]                           restarts <- computeRestarts(cond)
[17:46:46.307]                           for (restart in restarts) {
[17:46:46.307]                             name <- restart$name
[17:46:46.307]                             if (is.null(name)) 
[17:46:46.307]                               next
[17:46:46.307]                             if (!grepl(pattern, name)) 
[17:46:46.307]                               next
[17:46:46.307]                             invokeRestart(restart)
[17:46:46.307]                             muffled <- TRUE
[17:46:46.307]                             break
[17:46:46.307]                           }
[17:46:46.307]                         }
[17:46:46.307]                       }
[17:46:46.307]                       invisible(muffled)
[17:46:46.307]                     }
[17:46:46.307]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.307]                   }
[17:46:46.307]                 }
[17:46:46.307]                 else {
[17:46:46.307]                   if (TRUE) {
[17:46:46.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.307]                     {
[17:46:46.307]                       inherits <- base::inherits
[17:46:46.307]                       invokeRestart <- base::invokeRestart
[17:46:46.307]                       is.null <- base::is.null
[17:46:46.307]                       muffled <- FALSE
[17:46:46.307]                       if (inherits(cond, "message")) {
[17:46:46.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.307]                         if (muffled) 
[17:46:46.307]                           invokeRestart("muffleMessage")
[17:46:46.307]                       }
[17:46:46.307]                       else if (inherits(cond, "warning")) {
[17:46:46.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.307]                         if (muffled) 
[17:46:46.307]                           invokeRestart("muffleWarning")
[17:46:46.307]                       }
[17:46:46.307]                       else if (inherits(cond, "condition")) {
[17:46:46.307]                         if (!is.null(pattern)) {
[17:46:46.307]                           computeRestarts <- base::computeRestarts
[17:46:46.307]                           grepl <- base::grepl
[17:46:46.307]                           restarts <- computeRestarts(cond)
[17:46:46.307]                           for (restart in restarts) {
[17:46:46.307]                             name <- restart$name
[17:46:46.307]                             if (is.null(name)) 
[17:46:46.307]                               next
[17:46:46.307]                             if (!grepl(pattern, name)) 
[17:46:46.307]                               next
[17:46:46.307]                             invokeRestart(restart)
[17:46:46.307]                             muffled <- TRUE
[17:46:46.307]                             break
[17:46:46.307]                           }
[17:46:46.307]                         }
[17:46:46.307]                       }
[17:46:46.307]                       invisible(muffled)
[17:46:46.307]                     }
[17:46:46.307]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.307]                   }
[17:46:46.307]                 }
[17:46:46.307]             }
[17:46:46.307]         }))
[17:46:46.307]     }, error = function(ex) {
[17:46:46.307]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.307]                 ...future.rng), started = ...future.startTime, 
[17:46:46.307]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.307]             version = "1.8"), class = "FutureResult")
[17:46:46.307]     }, finally = {
[17:46:46.307]         if (!identical(...future.workdir, getwd())) 
[17:46:46.307]             setwd(...future.workdir)
[17:46:46.307]         {
[17:46:46.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.307]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.307]             }
[17:46:46.307]             base::options(...future.oldOptions)
[17:46:46.307]             if (.Platform$OS.type == "windows") {
[17:46:46.307]                 old_names <- names(...future.oldEnvVars)
[17:46:46.307]                 envs <- base::Sys.getenv()
[17:46:46.307]                 names <- names(envs)
[17:46:46.307]                 common <- intersect(names, old_names)
[17:46:46.307]                 added <- setdiff(names, old_names)
[17:46:46.307]                 removed <- setdiff(old_names, names)
[17:46:46.307]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.307]                   envs[common]]
[17:46:46.307]                 NAMES <- toupper(changed)
[17:46:46.307]                 args <- list()
[17:46:46.307]                 for (kk in seq_along(NAMES)) {
[17:46:46.307]                   name <- changed[[kk]]
[17:46:46.307]                   NAME <- NAMES[[kk]]
[17:46:46.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.307]                     next
[17:46:46.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.307]                 }
[17:46:46.307]                 NAMES <- toupper(added)
[17:46:46.307]                 for (kk in seq_along(NAMES)) {
[17:46:46.307]                   name <- added[[kk]]
[17:46:46.307]                   NAME <- NAMES[[kk]]
[17:46:46.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.307]                     next
[17:46:46.307]                   args[[name]] <- ""
[17:46:46.307]                 }
[17:46:46.307]                 NAMES <- toupper(removed)
[17:46:46.307]                 for (kk in seq_along(NAMES)) {
[17:46:46.307]                   name <- removed[[kk]]
[17:46:46.307]                   NAME <- NAMES[[kk]]
[17:46:46.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.307]                     next
[17:46:46.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.307]                 }
[17:46:46.307]                 if (length(args) > 0) 
[17:46:46.307]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.307]             }
[17:46:46.307]             else {
[17:46:46.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.307]             }
[17:46:46.307]             {
[17:46:46.307]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.307]                   0L) {
[17:46:46.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.307]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.307]                   base::options(opts)
[17:46:46.307]                 }
[17:46:46.307]                 {
[17:46:46.307]                   {
[17:46:46.307]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.307]                     NULL
[17:46:46.307]                   }
[17:46:46.307]                   options(future.plan = NULL)
[17:46:46.307]                   if (is.na(NA_character_)) 
[17:46:46.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.307]                     .init = FALSE)
[17:46:46.307]                 }
[17:46:46.307]             }
[17:46:46.307]         }
[17:46:46.307]     })
[17:46:46.307]     if (TRUE) {
[17:46:46.307]         base::sink(type = "output", split = FALSE)
[17:46:46.307]         if (TRUE) {
[17:46:46.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.307]         }
[17:46:46.307]         else {
[17:46:46.307]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.307]         }
[17:46:46.307]         base::close(...future.stdout)
[17:46:46.307]         ...future.stdout <- NULL
[17:46:46.307]     }
[17:46:46.307]     ...future.result$conditions <- ...future.conditions
[17:46:46.307]     ...future.result$finished <- base::Sys.time()
[17:46:46.307]     ...future.result
[17:46:46.307] }
[17:46:46.310] MultisessionFuture started
[17:46:46.310] - Launch lazy future ... done
[17:46:46.310] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617882644d0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617879de8f0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617882644d0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617879de8f0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:46:46.316] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.316] - Validating connection of MultisessionFuture
[17:46:46.316] - received message: FutureResult
[17:46:46.316] - Received FutureResult
[17:46:46.316] - Erased future from FutureRegistry
[17:46:46.316] result() for ClusterFuture ...
[17:46:46.316] - result already collected: FutureResult
[17:46:46.317] result() for ClusterFuture ... done
[17:46:46.317] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:46.317] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.317] - Validating connection of MultisessionFuture
[17:46:46.317] - received message: FutureResult
[17:46:46.317] - Received FutureResult
[17:46:46.318] - Erased future from FutureRegistry
[17:46:46.318] result() for ClusterFuture ...
[17:46:46.318] - result already collected: FutureResult
[17:46:46.318] result() for ClusterFuture ... done
[17:46:46.318] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:46.319] resolve() on list ...
[17:46:46.320]  recursive: 0
[17:46:46.320]  length: 6
[17:46:46.320]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:46.320] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.320] - nx: 6
[17:46:46.320] - relay: TRUE
[17:46:46.320] - stdout: TRUE
[17:46:46.320] - signal: TRUE
[17:46:46.320] - resignal: FALSE
[17:46:46.320] - force: TRUE
[17:46:46.320] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.321] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.321]  - until=2
[17:46:46.321]  - relaying element #2
[17:46:46.321] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.321] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.321] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.321]  length: 5 (resolved future 1)
[17:46:46.321] Future #2
[17:46:46.321] result() for ClusterFuture ...
[17:46:46.321] - result already collected: FutureResult
[17:46:46.321] result() for ClusterFuture ... done
[17:46:46.322] result() for ClusterFuture ...
[17:46:46.322] - result already collected: FutureResult
[17:46:46.322] result() for ClusterFuture ... done
[17:46:46.322] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:46.322] - nx: 6
[17:46:46.322] - relay: TRUE
[17:46:46.322] - stdout: TRUE
[17:46:46.322] - signal: TRUE
[17:46:46.322] - resignal: FALSE
[17:46:46.322] - force: TRUE
[17:46:46.322] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.322] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.323]  - until=2
[17:46:46.323]  - relaying element #2
[17:46:46.323] result() for ClusterFuture ...
[17:46:46.323] - result already collected: FutureResult
[17:46:46.323] result() for ClusterFuture ... done
[17:46:46.323] result() for ClusterFuture ...
[17:46:46.323] - result already collected: FutureResult
[17:46:46.323] result() for ClusterFuture ... done
[17:46:46.323] result() for ClusterFuture ...
[17:46:46.323] - result already collected: FutureResult
[17:46:46.323] result() for ClusterFuture ... done
[17:46:46.324] result() for ClusterFuture ...
[17:46:46.324] - result already collected: FutureResult
[17:46:46.324] result() for ClusterFuture ... done
[17:46:46.324] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.324] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.324] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:46.324]  length: 4 (resolved future 2)
[17:46:46.324] Future #3
[17:46:46.324] result() for ClusterFuture ...
[17:46:46.324] - result already collected: FutureResult
[17:46:46.324] result() for ClusterFuture ... done
[17:46:46.325] result() for ClusterFuture ...
[17:46:46.325] - result already collected: FutureResult
[17:46:46.325] result() for ClusterFuture ... done
[17:46:46.325] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:46.325] - nx: 6
[17:46:46.325] - relay: TRUE
[17:46:46.325] - stdout: TRUE
[17:46:46.325] - signal: TRUE
[17:46:46.325] - resignal: FALSE
[17:46:46.325] - force: TRUE
[17:46:46.325] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.325] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.326]  - until=3
[17:46:46.326]  - relaying element #3
[17:46:46.326] result() for ClusterFuture ...
[17:46:46.326] - result already collected: FutureResult
[17:46:46.326] result() for ClusterFuture ... done
[17:46:46.326] result() for ClusterFuture ...
[17:46:46.326] - result already collected: FutureResult
[17:46:46.326] result() for ClusterFuture ... done
[17:46:46.326] result() for ClusterFuture ...
[17:46:46.326] - result already collected: FutureResult
[17:46:46.326] result() for ClusterFuture ... done
[17:46:46.326] result() for ClusterFuture ...
[17:46:46.327] - result already collected: FutureResult
[17:46:46.327] result() for ClusterFuture ... done
[17:46:46.327] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.327] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.327] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:46.327]  length: 3 (resolved future 3)
[17:46:46.327] signalConditionsASAP(NULL, pos=4) ...
[17:46:46.327] - nx: 6
[17:46:46.327] - relay: TRUE
[17:46:46.327] - stdout: TRUE
[17:46:46.327] - signal: TRUE
[17:46:46.328] - resignal: FALSE
[17:46:46.328] - force: TRUE
[17:46:46.328] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.328] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.328]  - until=5
[17:46:46.328]  - relaying element #5
[17:46:46.328] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.328] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.328] signalConditionsASAP(NULL, pos=4) ... done
[17:46:46.328]  length: 2 (resolved future 4)
[17:46:46.328] signalConditionsASAP(NULL, pos=5) ...
[17:46:46.328] - nx: 6
[17:46:46.329] - relay: TRUE
[17:46:46.329] - stdout: TRUE
[17:46:46.329] - signal: TRUE
[17:46:46.329] - resignal: FALSE
[17:46:46.329] - force: TRUE
[17:46:46.329] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.329] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.329]  - until=6
[17:46:46.329]  - relaying element #6
[17:46:46.329] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.329] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.329] signalConditionsASAP(NULL, pos=5) ... done
[17:46:46.330]  length: 1 (resolved future 5)
[17:46:46.330] signalConditionsASAP(numeric, pos=6) ...
[17:46:46.330] - nx: 6
[17:46:46.330] - relay: TRUE
[17:46:46.330] - stdout: TRUE
[17:46:46.330] - signal: TRUE
[17:46:46.330] - resignal: FALSE
[17:46:46.330] - force: TRUE
[17:46:46.330] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.330] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.330]  - until=6
[17:46:46.330] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.331] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.331] signalConditionsASAP(numeric, pos=6) ... done
[17:46:46.331]  length: 0 (resolved future 6)
[17:46:46.331] Relaying remaining futures
[17:46:46.331] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.331] - nx: 6
[17:46:46.331] - relay: TRUE
[17:46:46.331] - stdout: TRUE
[17:46:46.331] - signal: TRUE
[17:46:46.331] - resignal: FALSE
[17:46:46.331] - force: TRUE
[17:46:46.331] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.332] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:46.332] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.332] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.332] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.332] resolve() on list ... DONE
[17:46:46.332] result() for ClusterFuture ...
[17:46:46.332] - result already collected: FutureResult
[17:46:46.332] result() for ClusterFuture ... done
[17:46:46.332] result() for ClusterFuture ...
[17:46:46.332] - result already collected: FutureResult
[17:46:46.332] result() for ClusterFuture ... done
[17:46:46.333] result() for ClusterFuture ...
[17:46:46.333] - result already collected: FutureResult
[17:46:46.333] result() for ClusterFuture ... done
[17:46:46.333] result() for ClusterFuture ...
[17:46:46.333] - result already collected: FutureResult
[17:46:46.333] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:46:46.336] getGlobalsAndPackages() ...
[17:46:46.336] Searching for globals...
[17:46:46.337] 
[17:46:46.337] Searching for globals ... DONE
[17:46:46.337] - globals: [0] <none>
[17:46:46.337] getGlobalsAndPackages() ... DONE
[17:46:46.337] run() for ‘Future’ ...
[17:46:46.337] - state: ‘created’
[17:46:46.337] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.351] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.351]   - Field: ‘node’
[17:46:46.352]   - Field: ‘label’
[17:46:46.352]   - Field: ‘local’
[17:46:46.352]   - Field: ‘owner’
[17:46:46.352]   - Field: ‘envir’
[17:46:46.352]   - Field: ‘workers’
[17:46:46.352]   - Field: ‘packages’
[17:46:46.352]   - Field: ‘gc’
[17:46:46.352]   - Field: ‘conditions’
[17:46:46.352]   - Field: ‘persistent’
[17:46:46.352]   - Field: ‘expr’
[17:46:46.352]   - Field: ‘uuid’
[17:46:46.353]   - Field: ‘seed’
[17:46:46.353]   - Field: ‘version’
[17:46:46.353]   - Field: ‘result’
[17:46:46.353]   - Field: ‘asynchronous’
[17:46:46.353]   - Field: ‘calls’
[17:46:46.353]   - Field: ‘globals’
[17:46:46.353]   - Field: ‘stdout’
[17:46:46.353]   - Field: ‘earlySignal’
[17:46:46.353]   - Field: ‘lazy’
[17:46:46.353]   - Field: ‘state’
[17:46:46.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.354] - Launch lazy future ...
[17:46:46.354] Packages needed by the future expression (n = 0): <none>
[17:46:46.354] Packages needed by future strategies (n = 0): <none>
[17:46:46.354] {
[17:46:46.354]     {
[17:46:46.354]         {
[17:46:46.354]             ...future.startTime <- base::Sys.time()
[17:46:46.354]             {
[17:46:46.354]                 {
[17:46:46.354]                   {
[17:46:46.354]                     {
[17:46:46.354]                       base::local({
[17:46:46.354]                         has_future <- base::requireNamespace("future", 
[17:46:46.354]                           quietly = TRUE)
[17:46:46.354]                         if (has_future) {
[17:46:46.354]                           ns <- base::getNamespace("future")
[17:46:46.354]                           version <- ns[[".package"]][["version"]]
[17:46:46.354]                           if (is.null(version)) 
[17:46:46.354]                             version <- utils::packageVersion("future")
[17:46:46.354]                         }
[17:46:46.354]                         else {
[17:46:46.354]                           version <- NULL
[17:46:46.354]                         }
[17:46:46.354]                         if (!has_future || version < "1.8.0") {
[17:46:46.354]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.354]                             "", base::R.version$version.string), 
[17:46:46.354]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.354]                               "release", "version")], collapse = " "), 
[17:46:46.354]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.354]                             info)
[17:46:46.354]                           info <- base::paste(info, collapse = "; ")
[17:46:46.354]                           if (!has_future) {
[17:46:46.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.354]                               info)
[17:46:46.354]                           }
[17:46:46.354]                           else {
[17:46:46.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.354]                               info, version)
[17:46:46.354]                           }
[17:46:46.354]                           base::stop(msg)
[17:46:46.354]                         }
[17:46:46.354]                       })
[17:46:46.354]                     }
[17:46:46.354]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.354]                     base::options(mc.cores = 1L)
[17:46:46.354]                   }
[17:46:46.354]                   ...future.strategy.old <- future::plan("list")
[17:46:46.354]                   options(future.plan = NULL)
[17:46:46.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.354]                 }
[17:46:46.354]                 ...future.workdir <- getwd()
[17:46:46.354]             }
[17:46:46.354]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.354]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.354]         }
[17:46:46.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.354]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.354]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.354]             base::names(...future.oldOptions))
[17:46:46.354]     }
[17:46:46.354]     if (FALSE) {
[17:46:46.354]     }
[17:46:46.354]     else {
[17:46:46.354]         if (TRUE) {
[17:46:46.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.354]                 open = "w")
[17:46:46.354]         }
[17:46:46.354]         else {
[17:46:46.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.354]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.354]         }
[17:46:46.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.354]             base::sink(type = "output", split = FALSE)
[17:46:46.354]             base::close(...future.stdout)
[17:46:46.354]         }, add = TRUE)
[17:46:46.354]     }
[17:46:46.354]     ...future.frame <- base::sys.nframe()
[17:46:46.354]     ...future.conditions <- base::list()
[17:46:46.354]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.354]     if (FALSE) {
[17:46:46.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.354]     }
[17:46:46.354]     ...future.result <- base::tryCatch({
[17:46:46.354]         base::withCallingHandlers({
[17:46:46.354]             ...future.value <- base::withVisible(base::local({
[17:46:46.354]                 ...future.makeSendCondition <- base::local({
[17:46:46.354]                   sendCondition <- NULL
[17:46:46.354]                   function(frame = 1L) {
[17:46:46.354]                     if (is.function(sendCondition)) 
[17:46:46.354]                       return(sendCondition)
[17:46:46.354]                     ns <- getNamespace("parallel")
[17:46:46.354]                     if (exists("sendData", mode = "function", 
[17:46:46.354]                       envir = ns)) {
[17:46:46.354]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.354]                         envir = ns)
[17:46:46.354]                       envir <- sys.frame(frame)
[17:46:46.354]                       master <- NULL
[17:46:46.354]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.354]                         !identical(envir, emptyenv())) {
[17:46:46.354]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.354]                           inherits = FALSE)) {
[17:46:46.354]                           master <- get("master", mode = "list", 
[17:46:46.354]                             envir = envir, inherits = FALSE)
[17:46:46.354]                           if (inherits(master, c("SOCKnode", 
[17:46:46.354]                             "SOCK0node"))) {
[17:46:46.354]                             sendCondition <<- function(cond) {
[17:46:46.354]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.354]                                 success = TRUE)
[17:46:46.354]                               parallel_sendData(master, data)
[17:46:46.354]                             }
[17:46:46.354]                             return(sendCondition)
[17:46:46.354]                           }
[17:46:46.354]                         }
[17:46:46.354]                         frame <- frame + 1L
[17:46:46.354]                         envir <- sys.frame(frame)
[17:46:46.354]                       }
[17:46:46.354]                     }
[17:46:46.354]                     sendCondition <<- function(cond) NULL
[17:46:46.354]                   }
[17:46:46.354]                 })
[17:46:46.354]                 withCallingHandlers({
[17:46:46.354]                   2
[17:46:46.354]                 }, immediateCondition = function(cond) {
[17:46:46.354]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.354]                   sendCondition(cond)
[17:46:46.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.354]                   {
[17:46:46.354]                     inherits <- base::inherits
[17:46:46.354]                     invokeRestart <- base::invokeRestart
[17:46:46.354]                     is.null <- base::is.null
[17:46:46.354]                     muffled <- FALSE
[17:46:46.354]                     if (inherits(cond, "message")) {
[17:46:46.354]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.354]                       if (muffled) 
[17:46:46.354]                         invokeRestart("muffleMessage")
[17:46:46.354]                     }
[17:46:46.354]                     else if (inherits(cond, "warning")) {
[17:46:46.354]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.354]                       if (muffled) 
[17:46:46.354]                         invokeRestart("muffleWarning")
[17:46:46.354]                     }
[17:46:46.354]                     else if (inherits(cond, "condition")) {
[17:46:46.354]                       if (!is.null(pattern)) {
[17:46:46.354]                         computeRestarts <- base::computeRestarts
[17:46:46.354]                         grepl <- base::grepl
[17:46:46.354]                         restarts <- computeRestarts(cond)
[17:46:46.354]                         for (restart in restarts) {
[17:46:46.354]                           name <- restart$name
[17:46:46.354]                           if (is.null(name)) 
[17:46:46.354]                             next
[17:46:46.354]                           if (!grepl(pattern, name)) 
[17:46:46.354]                             next
[17:46:46.354]                           invokeRestart(restart)
[17:46:46.354]                           muffled <- TRUE
[17:46:46.354]                           break
[17:46:46.354]                         }
[17:46:46.354]                       }
[17:46:46.354]                     }
[17:46:46.354]                     invisible(muffled)
[17:46:46.354]                   }
[17:46:46.354]                   muffleCondition(cond)
[17:46:46.354]                 })
[17:46:46.354]             }))
[17:46:46.354]             future::FutureResult(value = ...future.value$value, 
[17:46:46.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.354]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.354]                     ...future.globalenv.names))
[17:46:46.354]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.354]         }, condition = base::local({
[17:46:46.354]             c <- base::c
[17:46:46.354]             inherits <- base::inherits
[17:46:46.354]             invokeRestart <- base::invokeRestart
[17:46:46.354]             length <- base::length
[17:46:46.354]             list <- base::list
[17:46:46.354]             seq.int <- base::seq.int
[17:46:46.354]             signalCondition <- base::signalCondition
[17:46:46.354]             sys.calls <- base::sys.calls
[17:46:46.354]             `[[` <- base::`[[`
[17:46:46.354]             `+` <- base::`+`
[17:46:46.354]             `<<-` <- base::`<<-`
[17:46:46.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.354]                   3L)]
[17:46:46.354]             }
[17:46:46.354]             function(cond) {
[17:46:46.354]                 is_error <- inherits(cond, "error")
[17:46:46.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.354]                   NULL)
[17:46:46.354]                 if (is_error) {
[17:46:46.354]                   sessionInformation <- function() {
[17:46:46.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.354]                       search = base::search(), system = base::Sys.info())
[17:46:46.354]                   }
[17:46:46.354]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.354]                     cond$call), session = sessionInformation(), 
[17:46:46.354]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.354]                   signalCondition(cond)
[17:46:46.354]                 }
[17:46:46.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.354]                 "immediateCondition"))) {
[17:46:46.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.354]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.354]                   if (TRUE && !signal) {
[17:46:46.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.354]                     {
[17:46:46.354]                       inherits <- base::inherits
[17:46:46.354]                       invokeRestart <- base::invokeRestart
[17:46:46.354]                       is.null <- base::is.null
[17:46:46.354]                       muffled <- FALSE
[17:46:46.354]                       if (inherits(cond, "message")) {
[17:46:46.354]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.354]                         if (muffled) 
[17:46:46.354]                           invokeRestart("muffleMessage")
[17:46:46.354]                       }
[17:46:46.354]                       else if (inherits(cond, "warning")) {
[17:46:46.354]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.354]                         if (muffled) 
[17:46:46.354]                           invokeRestart("muffleWarning")
[17:46:46.354]                       }
[17:46:46.354]                       else if (inherits(cond, "condition")) {
[17:46:46.354]                         if (!is.null(pattern)) {
[17:46:46.354]                           computeRestarts <- base::computeRestarts
[17:46:46.354]                           grepl <- base::grepl
[17:46:46.354]                           restarts <- computeRestarts(cond)
[17:46:46.354]                           for (restart in restarts) {
[17:46:46.354]                             name <- restart$name
[17:46:46.354]                             if (is.null(name)) 
[17:46:46.354]                               next
[17:46:46.354]                             if (!grepl(pattern, name)) 
[17:46:46.354]                               next
[17:46:46.354]                             invokeRestart(restart)
[17:46:46.354]                             muffled <- TRUE
[17:46:46.354]                             break
[17:46:46.354]                           }
[17:46:46.354]                         }
[17:46:46.354]                       }
[17:46:46.354]                       invisible(muffled)
[17:46:46.354]                     }
[17:46:46.354]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.354]                   }
[17:46:46.354]                 }
[17:46:46.354]                 else {
[17:46:46.354]                   if (TRUE) {
[17:46:46.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.354]                     {
[17:46:46.354]                       inherits <- base::inherits
[17:46:46.354]                       invokeRestart <- base::invokeRestart
[17:46:46.354]                       is.null <- base::is.null
[17:46:46.354]                       muffled <- FALSE
[17:46:46.354]                       if (inherits(cond, "message")) {
[17:46:46.354]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.354]                         if (muffled) 
[17:46:46.354]                           invokeRestart("muffleMessage")
[17:46:46.354]                       }
[17:46:46.354]                       else if (inherits(cond, "warning")) {
[17:46:46.354]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.354]                         if (muffled) 
[17:46:46.354]                           invokeRestart("muffleWarning")
[17:46:46.354]                       }
[17:46:46.354]                       else if (inherits(cond, "condition")) {
[17:46:46.354]                         if (!is.null(pattern)) {
[17:46:46.354]                           computeRestarts <- base::computeRestarts
[17:46:46.354]                           grepl <- base::grepl
[17:46:46.354]                           restarts <- computeRestarts(cond)
[17:46:46.354]                           for (restart in restarts) {
[17:46:46.354]                             name <- restart$name
[17:46:46.354]                             if (is.null(name)) 
[17:46:46.354]                               next
[17:46:46.354]                             if (!grepl(pattern, name)) 
[17:46:46.354]                               next
[17:46:46.354]                             invokeRestart(restart)
[17:46:46.354]                             muffled <- TRUE
[17:46:46.354]                             break
[17:46:46.354]                           }
[17:46:46.354]                         }
[17:46:46.354]                       }
[17:46:46.354]                       invisible(muffled)
[17:46:46.354]                     }
[17:46:46.354]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.354]                   }
[17:46:46.354]                 }
[17:46:46.354]             }
[17:46:46.354]         }))
[17:46:46.354]     }, error = function(ex) {
[17:46:46.354]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.354]                 ...future.rng), started = ...future.startTime, 
[17:46:46.354]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.354]             version = "1.8"), class = "FutureResult")
[17:46:46.354]     }, finally = {
[17:46:46.354]         if (!identical(...future.workdir, getwd())) 
[17:46:46.354]             setwd(...future.workdir)
[17:46:46.354]         {
[17:46:46.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.354]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.354]             }
[17:46:46.354]             base::options(...future.oldOptions)
[17:46:46.354]             if (.Platform$OS.type == "windows") {
[17:46:46.354]                 old_names <- names(...future.oldEnvVars)
[17:46:46.354]                 envs <- base::Sys.getenv()
[17:46:46.354]                 names <- names(envs)
[17:46:46.354]                 common <- intersect(names, old_names)
[17:46:46.354]                 added <- setdiff(names, old_names)
[17:46:46.354]                 removed <- setdiff(old_names, names)
[17:46:46.354]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.354]                   envs[common]]
[17:46:46.354]                 NAMES <- toupper(changed)
[17:46:46.354]                 args <- list()
[17:46:46.354]                 for (kk in seq_along(NAMES)) {
[17:46:46.354]                   name <- changed[[kk]]
[17:46:46.354]                   NAME <- NAMES[[kk]]
[17:46:46.354]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.354]                     next
[17:46:46.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.354]                 }
[17:46:46.354]                 NAMES <- toupper(added)
[17:46:46.354]                 for (kk in seq_along(NAMES)) {
[17:46:46.354]                   name <- added[[kk]]
[17:46:46.354]                   NAME <- NAMES[[kk]]
[17:46:46.354]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.354]                     next
[17:46:46.354]                   args[[name]] <- ""
[17:46:46.354]                 }
[17:46:46.354]                 NAMES <- toupper(removed)
[17:46:46.354]                 for (kk in seq_along(NAMES)) {
[17:46:46.354]                   name <- removed[[kk]]
[17:46:46.354]                   NAME <- NAMES[[kk]]
[17:46:46.354]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.354]                     next
[17:46:46.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.354]                 }
[17:46:46.354]                 if (length(args) > 0) 
[17:46:46.354]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.354]             }
[17:46:46.354]             else {
[17:46:46.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.354]             }
[17:46:46.354]             {
[17:46:46.354]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.354]                   0L) {
[17:46:46.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.354]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.354]                   base::options(opts)
[17:46:46.354]                 }
[17:46:46.354]                 {
[17:46:46.354]                   {
[17:46:46.354]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.354]                     NULL
[17:46:46.354]                   }
[17:46:46.354]                   options(future.plan = NULL)
[17:46:46.354]                   if (is.na(NA_character_)) 
[17:46:46.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.354]                     .init = FALSE)
[17:46:46.354]                 }
[17:46:46.354]             }
[17:46:46.354]         }
[17:46:46.354]     })
[17:46:46.354]     if (TRUE) {
[17:46:46.354]         base::sink(type = "output", split = FALSE)
[17:46:46.354]         if (TRUE) {
[17:46:46.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.354]         }
[17:46:46.354]         else {
[17:46:46.354]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.354]         }
[17:46:46.354]         base::close(...future.stdout)
[17:46:46.354]         ...future.stdout <- NULL
[17:46:46.354]     }
[17:46:46.354]     ...future.result$conditions <- ...future.conditions
[17:46:46.354]     ...future.result$finished <- base::Sys.time()
[17:46:46.354]     ...future.result
[17:46:46.354] }
[17:46:46.357] MultisessionFuture started
[17:46:46.357] - Launch lazy future ... done
[17:46:46.358] run() for ‘MultisessionFuture’ ... done
[17:46:46.358] getGlobalsAndPackages() ...
[17:46:46.358] Searching for globals...
[17:46:46.358] 
[17:46:46.359] Searching for globals ... DONE
[17:46:46.359] - globals: [0] <none>
[17:46:46.359] getGlobalsAndPackages() ... DONE
[17:46:46.359] run() for ‘Future’ ...
[17:46:46.359] - state: ‘created’
[17:46:46.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.373] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.373]   - Field: ‘node’
[17:46:46.374]   - Field: ‘label’
[17:46:46.374]   - Field: ‘local’
[17:46:46.374]   - Field: ‘owner’
[17:46:46.374]   - Field: ‘envir’
[17:46:46.374]   - Field: ‘workers’
[17:46:46.374]   - Field: ‘packages’
[17:46:46.374]   - Field: ‘gc’
[17:46:46.374]   - Field: ‘conditions’
[17:46:46.374]   - Field: ‘persistent’
[17:46:46.374]   - Field: ‘expr’
[17:46:46.375]   - Field: ‘uuid’
[17:46:46.375]   - Field: ‘seed’
[17:46:46.375]   - Field: ‘version’
[17:46:46.375]   - Field: ‘result’
[17:46:46.375]   - Field: ‘asynchronous’
[17:46:46.375]   - Field: ‘calls’
[17:46:46.375]   - Field: ‘globals’
[17:46:46.375]   - Field: ‘stdout’
[17:46:46.375]   - Field: ‘earlySignal’
[17:46:46.375]   - Field: ‘lazy’
[17:46:46.375]   - Field: ‘state’
[17:46:46.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.376] - Launch lazy future ...
[17:46:46.376] Packages needed by the future expression (n = 0): <none>
[17:46:46.376] Packages needed by future strategies (n = 0): <none>
[17:46:46.376] {
[17:46:46.376]     {
[17:46:46.376]         {
[17:46:46.376]             ...future.startTime <- base::Sys.time()
[17:46:46.376]             {
[17:46:46.376]                 {
[17:46:46.376]                   {
[17:46:46.376]                     {
[17:46:46.376]                       base::local({
[17:46:46.376]                         has_future <- base::requireNamespace("future", 
[17:46:46.376]                           quietly = TRUE)
[17:46:46.376]                         if (has_future) {
[17:46:46.376]                           ns <- base::getNamespace("future")
[17:46:46.376]                           version <- ns[[".package"]][["version"]]
[17:46:46.376]                           if (is.null(version)) 
[17:46:46.376]                             version <- utils::packageVersion("future")
[17:46:46.376]                         }
[17:46:46.376]                         else {
[17:46:46.376]                           version <- NULL
[17:46:46.376]                         }
[17:46:46.376]                         if (!has_future || version < "1.8.0") {
[17:46:46.376]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.376]                             "", base::R.version$version.string), 
[17:46:46.376]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.376]                               "release", "version")], collapse = " "), 
[17:46:46.376]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.376]                             info)
[17:46:46.376]                           info <- base::paste(info, collapse = "; ")
[17:46:46.376]                           if (!has_future) {
[17:46:46.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.376]                               info)
[17:46:46.376]                           }
[17:46:46.376]                           else {
[17:46:46.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.376]                               info, version)
[17:46:46.376]                           }
[17:46:46.376]                           base::stop(msg)
[17:46:46.376]                         }
[17:46:46.376]                       })
[17:46:46.376]                     }
[17:46:46.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.376]                     base::options(mc.cores = 1L)
[17:46:46.376]                   }
[17:46:46.376]                   ...future.strategy.old <- future::plan("list")
[17:46:46.376]                   options(future.plan = NULL)
[17:46:46.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.376]                 }
[17:46:46.376]                 ...future.workdir <- getwd()
[17:46:46.376]             }
[17:46:46.376]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.376]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.376]         }
[17:46:46.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.376]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.376]             base::names(...future.oldOptions))
[17:46:46.376]     }
[17:46:46.376]     if (FALSE) {
[17:46:46.376]     }
[17:46:46.376]     else {
[17:46:46.376]         if (TRUE) {
[17:46:46.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.376]                 open = "w")
[17:46:46.376]         }
[17:46:46.376]         else {
[17:46:46.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.376]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.376]         }
[17:46:46.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.376]             base::sink(type = "output", split = FALSE)
[17:46:46.376]             base::close(...future.stdout)
[17:46:46.376]         }, add = TRUE)
[17:46:46.376]     }
[17:46:46.376]     ...future.frame <- base::sys.nframe()
[17:46:46.376]     ...future.conditions <- base::list()
[17:46:46.376]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.376]     if (FALSE) {
[17:46:46.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.376]     }
[17:46:46.376]     ...future.result <- base::tryCatch({
[17:46:46.376]         base::withCallingHandlers({
[17:46:46.376]             ...future.value <- base::withVisible(base::local({
[17:46:46.376]                 ...future.makeSendCondition <- base::local({
[17:46:46.376]                   sendCondition <- NULL
[17:46:46.376]                   function(frame = 1L) {
[17:46:46.376]                     if (is.function(sendCondition)) 
[17:46:46.376]                       return(sendCondition)
[17:46:46.376]                     ns <- getNamespace("parallel")
[17:46:46.376]                     if (exists("sendData", mode = "function", 
[17:46:46.376]                       envir = ns)) {
[17:46:46.376]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.376]                         envir = ns)
[17:46:46.376]                       envir <- sys.frame(frame)
[17:46:46.376]                       master <- NULL
[17:46:46.376]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.376]                         !identical(envir, emptyenv())) {
[17:46:46.376]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.376]                           inherits = FALSE)) {
[17:46:46.376]                           master <- get("master", mode = "list", 
[17:46:46.376]                             envir = envir, inherits = FALSE)
[17:46:46.376]                           if (inherits(master, c("SOCKnode", 
[17:46:46.376]                             "SOCK0node"))) {
[17:46:46.376]                             sendCondition <<- function(cond) {
[17:46:46.376]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.376]                                 success = TRUE)
[17:46:46.376]                               parallel_sendData(master, data)
[17:46:46.376]                             }
[17:46:46.376]                             return(sendCondition)
[17:46:46.376]                           }
[17:46:46.376]                         }
[17:46:46.376]                         frame <- frame + 1L
[17:46:46.376]                         envir <- sys.frame(frame)
[17:46:46.376]                       }
[17:46:46.376]                     }
[17:46:46.376]                     sendCondition <<- function(cond) NULL
[17:46:46.376]                   }
[17:46:46.376]                 })
[17:46:46.376]                 withCallingHandlers({
[17:46:46.376]                   NULL
[17:46:46.376]                 }, immediateCondition = function(cond) {
[17:46:46.376]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.376]                   sendCondition(cond)
[17:46:46.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.376]                   {
[17:46:46.376]                     inherits <- base::inherits
[17:46:46.376]                     invokeRestart <- base::invokeRestart
[17:46:46.376]                     is.null <- base::is.null
[17:46:46.376]                     muffled <- FALSE
[17:46:46.376]                     if (inherits(cond, "message")) {
[17:46:46.376]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.376]                       if (muffled) 
[17:46:46.376]                         invokeRestart("muffleMessage")
[17:46:46.376]                     }
[17:46:46.376]                     else if (inherits(cond, "warning")) {
[17:46:46.376]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.376]                       if (muffled) 
[17:46:46.376]                         invokeRestart("muffleWarning")
[17:46:46.376]                     }
[17:46:46.376]                     else if (inherits(cond, "condition")) {
[17:46:46.376]                       if (!is.null(pattern)) {
[17:46:46.376]                         computeRestarts <- base::computeRestarts
[17:46:46.376]                         grepl <- base::grepl
[17:46:46.376]                         restarts <- computeRestarts(cond)
[17:46:46.376]                         for (restart in restarts) {
[17:46:46.376]                           name <- restart$name
[17:46:46.376]                           if (is.null(name)) 
[17:46:46.376]                             next
[17:46:46.376]                           if (!grepl(pattern, name)) 
[17:46:46.376]                             next
[17:46:46.376]                           invokeRestart(restart)
[17:46:46.376]                           muffled <- TRUE
[17:46:46.376]                           break
[17:46:46.376]                         }
[17:46:46.376]                       }
[17:46:46.376]                     }
[17:46:46.376]                     invisible(muffled)
[17:46:46.376]                   }
[17:46:46.376]                   muffleCondition(cond)
[17:46:46.376]                 })
[17:46:46.376]             }))
[17:46:46.376]             future::FutureResult(value = ...future.value$value, 
[17:46:46.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.376]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.376]                     ...future.globalenv.names))
[17:46:46.376]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.376]         }, condition = base::local({
[17:46:46.376]             c <- base::c
[17:46:46.376]             inherits <- base::inherits
[17:46:46.376]             invokeRestart <- base::invokeRestart
[17:46:46.376]             length <- base::length
[17:46:46.376]             list <- base::list
[17:46:46.376]             seq.int <- base::seq.int
[17:46:46.376]             signalCondition <- base::signalCondition
[17:46:46.376]             sys.calls <- base::sys.calls
[17:46:46.376]             `[[` <- base::`[[`
[17:46:46.376]             `+` <- base::`+`
[17:46:46.376]             `<<-` <- base::`<<-`
[17:46:46.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.376]                   3L)]
[17:46:46.376]             }
[17:46:46.376]             function(cond) {
[17:46:46.376]                 is_error <- inherits(cond, "error")
[17:46:46.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.376]                   NULL)
[17:46:46.376]                 if (is_error) {
[17:46:46.376]                   sessionInformation <- function() {
[17:46:46.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.376]                       search = base::search(), system = base::Sys.info())
[17:46:46.376]                   }
[17:46:46.376]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.376]                     cond$call), session = sessionInformation(), 
[17:46:46.376]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.376]                   signalCondition(cond)
[17:46:46.376]                 }
[17:46:46.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.376]                 "immediateCondition"))) {
[17:46:46.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.376]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.376]                   if (TRUE && !signal) {
[17:46:46.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.376]                     {
[17:46:46.376]                       inherits <- base::inherits
[17:46:46.376]                       invokeRestart <- base::invokeRestart
[17:46:46.376]                       is.null <- base::is.null
[17:46:46.376]                       muffled <- FALSE
[17:46:46.376]                       if (inherits(cond, "message")) {
[17:46:46.376]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.376]                         if (muffled) 
[17:46:46.376]                           invokeRestart("muffleMessage")
[17:46:46.376]                       }
[17:46:46.376]                       else if (inherits(cond, "warning")) {
[17:46:46.376]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.376]                         if (muffled) 
[17:46:46.376]                           invokeRestart("muffleWarning")
[17:46:46.376]                       }
[17:46:46.376]                       else if (inherits(cond, "condition")) {
[17:46:46.376]                         if (!is.null(pattern)) {
[17:46:46.376]                           computeRestarts <- base::computeRestarts
[17:46:46.376]                           grepl <- base::grepl
[17:46:46.376]                           restarts <- computeRestarts(cond)
[17:46:46.376]                           for (restart in restarts) {
[17:46:46.376]                             name <- restart$name
[17:46:46.376]                             if (is.null(name)) 
[17:46:46.376]                               next
[17:46:46.376]                             if (!grepl(pattern, name)) 
[17:46:46.376]                               next
[17:46:46.376]                             invokeRestart(restart)
[17:46:46.376]                             muffled <- TRUE
[17:46:46.376]                             break
[17:46:46.376]                           }
[17:46:46.376]                         }
[17:46:46.376]                       }
[17:46:46.376]                       invisible(muffled)
[17:46:46.376]                     }
[17:46:46.376]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.376]                   }
[17:46:46.376]                 }
[17:46:46.376]                 else {
[17:46:46.376]                   if (TRUE) {
[17:46:46.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.376]                     {
[17:46:46.376]                       inherits <- base::inherits
[17:46:46.376]                       invokeRestart <- base::invokeRestart
[17:46:46.376]                       is.null <- base::is.null
[17:46:46.376]                       muffled <- FALSE
[17:46:46.376]                       if (inherits(cond, "message")) {
[17:46:46.376]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.376]                         if (muffled) 
[17:46:46.376]                           invokeRestart("muffleMessage")
[17:46:46.376]                       }
[17:46:46.376]                       else if (inherits(cond, "warning")) {
[17:46:46.376]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.376]                         if (muffled) 
[17:46:46.376]                           invokeRestart("muffleWarning")
[17:46:46.376]                       }
[17:46:46.376]                       else if (inherits(cond, "condition")) {
[17:46:46.376]                         if (!is.null(pattern)) {
[17:46:46.376]                           computeRestarts <- base::computeRestarts
[17:46:46.376]                           grepl <- base::grepl
[17:46:46.376]                           restarts <- computeRestarts(cond)
[17:46:46.376]                           for (restart in restarts) {
[17:46:46.376]                             name <- restart$name
[17:46:46.376]                             if (is.null(name)) 
[17:46:46.376]                               next
[17:46:46.376]                             if (!grepl(pattern, name)) 
[17:46:46.376]                               next
[17:46:46.376]                             invokeRestart(restart)
[17:46:46.376]                             muffled <- TRUE
[17:46:46.376]                             break
[17:46:46.376]                           }
[17:46:46.376]                         }
[17:46:46.376]                       }
[17:46:46.376]                       invisible(muffled)
[17:46:46.376]                     }
[17:46:46.376]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.376]                   }
[17:46:46.376]                 }
[17:46:46.376]             }
[17:46:46.376]         }))
[17:46:46.376]     }, error = function(ex) {
[17:46:46.376]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.376]                 ...future.rng), started = ...future.startTime, 
[17:46:46.376]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.376]             version = "1.8"), class = "FutureResult")
[17:46:46.376]     }, finally = {
[17:46:46.376]         if (!identical(...future.workdir, getwd())) 
[17:46:46.376]             setwd(...future.workdir)
[17:46:46.376]         {
[17:46:46.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.376]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.376]             }
[17:46:46.376]             base::options(...future.oldOptions)
[17:46:46.376]             if (.Platform$OS.type == "windows") {
[17:46:46.376]                 old_names <- names(...future.oldEnvVars)
[17:46:46.376]                 envs <- base::Sys.getenv()
[17:46:46.376]                 names <- names(envs)
[17:46:46.376]                 common <- intersect(names, old_names)
[17:46:46.376]                 added <- setdiff(names, old_names)
[17:46:46.376]                 removed <- setdiff(old_names, names)
[17:46:46.376]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.376]                   envs[common]]
[17:46:46.376]                 NAMES <- toupper(changed)
[17:46:46.376]                 args <- list()
[17:46:46.376]                 for (kk in seq_along(NAMES)) {
[17:46:46.376]                   name <- changed[[kk]]
[17:46:46.376]                   NAME <- NAMES[[kk]]
[17:46:46.376]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.376]                     next
[17:46:46.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.376]                 }
[17:46:46.376]                 NAMES <- toupper(added)
[17:46:46.376]                 for (kk in seq_along(NAMES)) {
[17:46:46.376]                   name <- added[[kk]]
[17:46:46.376]                   NAME <- NAMES[[kk]]
[17:46:46.376]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.376]                     next
[17:46:46.376]                   args[[name]] <- ""
[17:46:46.376]                 }
[17:46:46.376]                 NAMES <- toupper(removed)
[17:46:46.376]                 for (kk in seq_along(NAMES)) {
[17:46:46.376]                   name <- removed[[kk]]
[17:46:46.376]                   NAME <- NAMES[[kk]]
[17:46:46.376]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.376]                     next
[17:46:46.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.376]                 }
[17:46:46.376]                 if (length(args) > 0) 
[17:46:46.376]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.376]             }
[17:46:46.376]             else {
[17:46:46.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.376]             }
[17:46:46.376]             {
[17:46:46.376]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.376]                   0L) {
[17:46:46.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.376]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.376]                   base::options(opts)
[17:46:46.376]                 }
[17:46:46.376]                 {
[17:46:46.376]                   {
[17:46:46.376]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.376]                     NULL
[17:46:46.376]                   }
[17:46:46.376]                   options(future.plan = NULL)
[17:46:46.376]                   if (is.na(NA_character_)) 
[17:46:46.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.376]                     .init = FALSE)
[17:46:46.376]                 }
[17:46:46.376]             }
[17:46:46.376]         }
[17:46:46.376]     })
[17:46:46.376]     if (TRUE) {
[17:46:46.376]         base::sink(type = "output", split = FALSE)
[17:46:46.376]         if (TRUE) {
[17:46:46.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.376]         }
[17:46:46.376]         else {
[17:46:46.376]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.376]         }
[17:46:46.376]         base::close(...future.stdout)
[17:46:46.376]         ...future.stdout <- NULL
[17:46:46.376]     }
[17:46:46.376]     ...future.result$conditions <- ...future.conditions
[17:46:46.376]     ...future.result$finished <- base::Sys.time()
[17:46:46.376]     ...future.result
[17:46:46.376] }
[17:46:46.379] MultisessionFuture started
[17:46:46.379] - Launch lazy future ... done
[17:46:46.380] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617893d8b58> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617897e5cd0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617893d8b58> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617897e5cd0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:46:46.385] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.385] - Validating connection of MultisessionFuture
[17:46:46.385] - received message: FutureResult
[17:46:46.385] - Received FutureResult
[17:46:46.385] - Erased future from FutureRegistry
[17:46:46.386] result() for ClusterFuture ...
[17:46:46.386] - result already collected: FutureResult
[17:46:46.386] result() for ClusterFuture ... done
[17:46:46.386] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:46.386] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.386] - Validating connection of MultisessionFuture
[17:46:46.387] - received message: FutureResult
[17:46:46.387] - Received FutureResult
[17:46:46.387] - Erased future from FutureRegistry
[17:46:46.387] result() for ClusterFuture ...
[17:46:46.387] - result already collected: FutureResult
[17:46:46.387] result() for ClusterFuture ... done
[17:46:46.387] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:46.390] resolve() on list ...
[17:46:46.391]  recursive: 0
[17:46:46.391]  length: 6
[17:46:46.391]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:46.391] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.391] - nx: 6
[17:46:46.391] - relay: TRUE
[17:46:46.391] - stdout: TRUE
[17:46:46.391] - signal: TRUE
[17:46:46.391] - resignal: FALSE
[17:46:46.391] - force: TRUE
[17:46:46.391] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.392] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.392]  - until=2
[17:46:46.392]  - relaying element #2
[17:46:46.392] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.392] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.392] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.392]  length: 5 (resolved future 1)
[17:46:46.392] Future #2
[17:46:46.392] result() for ClusterFuture ...
[17:46:46.392] - result already collected: FutureResult
[17:46:46.392] result() for ClusterFuture ... done
[17:46:46.393] result() for ClusterFuture ...
[17:46:46.393] - result already collected: FutureResult
[17:46:46.393] result() for ClusterFuture ... done
[17:46:46.393] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:46.393] - nx: 6
[17:46:46.393] - relay: TRUE
[17:46:46.393] - stdout: TRUE
[17:46:46.393] - signal: TRUE
[17:46:46.393] - resignal: FALSE
[17:46:46.393] - force: TRUE
[17:46:46.393] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.393] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.394]  - until=2
[17:46:46.394]  - relaying element #2
[17:46:46.394] result() for ClusterFuture ...
[17:46:46.394] - result already collected: FutureResult
[17:46:46.394] result() for ClusterFuture ... done
[17:46:46.394] result() for ClusterFuture ...
[17:46:46.394] - result already collected: FutureResult
[17:46:46.394] result() for ClusterFuture ... done
[17:46:46.394] result() for ClusterFuture ...
[17:46:46.394] - result already collected: FutureResult
[17:46:46.394] result() for ClusterFuture ... done
[17:46:46.394] result() for ClusterFuture ...
[17:46:46.395] - result already collected: FutureResult
[17:46:46.395] result() for ClusterFuture ... done
[17:46:46.395] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.395] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.395] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:46.395]  length: 4 (resolved future 2)
[17:46:46.395] Future #3
[17:46:46.395] result() for ClusterFuture ...
[17:46:46.395] - result already collected: FutureResult
[17:46:46.395] result() for ClusterFuture ... done
[17:46:46.395] result() for ClusterFuture ...
[17:46:46.396] - result already collected: FutureResult
[17:46:46.396] result() for ClusterFuture ... done
[17:46:46.396] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:46.396] - nx: 6
[17:46:46.396] - relay: TRUE
[17:46:46.396] - stdout: TRUE
[17:46:46.396] - signal: TRUE
[17:46:46.396] - resignal: FALSE
[17:46:46.396] - force: TRUE
[17:46:46.396] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.396] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.396]  - until=3
[17:46:46.397]  - relaying element #3
[17:46:46.397] result() for ClusterFuture ...
[17:46:46.397] - result already collected: FutureResult
[17:46:46.397] result() for ClusterFuture ... done
[17:46:46.397] result() for ClusterFuture ...
[17:46:46.397] - result already collected: FutureResult
[17:46:46.397] result() for ClusterFuture ... done
[17:46:46.397] result() for ClusterFuture ...
[17:46:46.397] - result already collected: FutureResult
[17:46:46.397] result() for ClusterFuture ... done
[17:46:46.397] result() for ClusterFuture ...
[17:46:46.397] - result already collected: FutureResult
[17:46:46.398] result() for ClusterFuture ... done
[17:46:46.398] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.398] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.398] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:46.398]  length: 3 (resolved future 3)
[17:46:46.398] signalConditionsASAP(NULL, pos=4) ...
[17:46:46.398] - nx: 6
[17:46:46.398] - relay: TRUE
[17:46:46.398] - stdout: TRUE
[17:46:46.398] - signal: TRUE
[17:46:46.398] - resignal: FALSE
[17:46:46.399] - force: TRUE
[17:46:46.399] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.399] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.399]  - until=5
[17:46:46.399]  - relaying element #5
[17:46:46.399] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.399] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.399] signalConditionsASAP(NULL, pos=4) ... done
[17:46:46.399]  length: 2 (resolved future 4)
[17:46:46.399] signalConditionsASAP(NULL, pos=5) ...
[17:46:46.399] - nx: 6
[17:46:46.400] - relay: TRUE
[17:46:46.400] - stdout: TRUE
[17:46:46.400] - signal: TRUE
[17:46:46.400] - resignal: FALSE
[17:46:46.400] - force: TRUE
[17:46:46.400] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.400] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.400]  - until=6
[17:46:46.400]  - relaying element #6
[17:46:46.400] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.400] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.400] signalConditionsASAP(NULL, pos=5) ... done
[17:46:46.400]  length: 1 (resolved future 5)
[17:46:46.401] signalConditionsASAP(numeric, pos=6) ...
[17:46:46.401] - nx: 6
[17:46:46.401] - relay: TRUE
[17:46:46.401] - stdout: TRUE
[17:46:46.401] - signal: TRUE
[17:46:46.401] - resignal: FALSE
[17:46:46.401] - force: TRUE
[17:46:46.401] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.401] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.401]  - until=6
[17:46:46.401] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.401] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.402] signalConditionsASAP(numeric, pos=6) ... done
[17:46:46.402]  length: 0 (resolved future 6)
[17:46:46.402] Relaying remaining futures
[17:46:46.402] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.402] - nx: 6
[17:46:46.402] - relay: TRUE
[17:46:46.402] - stdout: TRUE
[17:46:46.402] - signal: TRUE
[17:46:46.402] - resignal: FALSE
[17:46:46.402] - force: TRUE
[17:46:46.402] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.402] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:46.403] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.403] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.403] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.403] resolve() on list ... DONE
[17:46:46.403] result() for ClusterFuture ...
[17:46:46.403] - result already collected: FutureResult
[17:46:46.403] result() for ClusterFuture ... done
[17:46:46.403] result() for ClusterFuture ...
[17:46:46.403] - result already collected: FutureResult
[17:46:46.403] result() for ClusterFuture ... done
[17:46:46.403] result() for ClusterFuture ...
[17:46:46.404] - result already collected: FutureResult
[17:46:46.404] result() for ClusterFuture ... done
[17:46:46.404] result() for ClusterFuture ...
[17:46:46.404] - result already collected: FutureResult
[17:46:46.404] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:46:46.407] getGlobalsAndPackages() ...
[17:46:46.407] Searching for globals...
[17:46:46.407] 
[17:46:46.407] Searching for globals ... DONE
[17:46:46.407] - globals: [0] <none>
[17:46:46.408] getGlobalsAndPackages() ... DONE
[17:46:46.408] run() for ‘Future’ ...
[17:46:46.408] - state: ‘created’
[17:46:46.408] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.423]   - Field: ‘node’
[17:46:46.423]   - Field: ‘label’
[17:46:46.424]   - Field: ‘local’
[17:46:46.424]   - Field: ‘owner’
[17:46:46.424]   - Field: ‘envir’
[17:46:46.424]   - Field: ‘workers’
[17:46:46.424]   - Field: ‘packages’
[17:46:46.424]   - Field: ‘gc’
[17:46:46.424]   - Field: ‘conditions’
[17:46:46.424]   - Field: ‘persistent’
[17:46:46.424]   - Field: ‘expr’
[17:46:46.424]   - Field: ‘uuid’
[17:46:46.424]   - Field: ‘seed’
[17:46:46.425]   - Field: ‘version’
[17:46:46.425]   - Field: ‘result’
[17:46:46.425]   - Field: ‘asynchronous’
[17:46:46.425]   - Field: ‘calls’
[17:46:46.425]   - Field: ‘globals’
[17:46:46.425]   - Field: ‘stdout’
[17:46:46.425]   - Field: ‘earlySignal’
[17:46:46.425]   - Field: ‘lazy’
[17:46:46.425]   - Field: ‘state’
[17:46:46.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.425] - Launch lazy future ...
[17:46:46.426] Packages needed by the future expression (n = 0): <none>
[17:46:46.426] Packages needed by future strategies (n = 0): <none>
[17:46:46.426] {
[17:46:46.426]     {
[17:46:46.426]         {
[17:46:46.426]             ...future.startTime <- base::Sys.time()
[17:46:46.426]             {
[17:46:46.426]                 {
[17:46:46.426]                   {
[17:46:46.426]                     {
[17:46:46.426]                       base::local({
[17:46:46.426]                         has_future <- base::requireNamespace("future", 
[17:46:46.426]                           quietly = TRUE)
[17:46:46.426]                         if (has_future) {
[17:46:46.426]                           ns <- base::getNamespace("future")
[17:46:46.426]                           version <- ns[[".package"]][["version"]]
[17:46:46.426]                           if (is.null(version)) 
[17:46:46.426]                             version <- utils::packageVersion("future")
[17:46:46.426]                         }
[17:46:46.426]                         else {
[17:46:46.426]                           version <- NULL
[17:46:46.426]                         }
[17:46:46.426]                         if (!has_future || version < "1.8.0") {
[17:46:46.426]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.426]                             "", base::R.version$version.string), 
[17:46:46.426]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.426]                               "release", "version")], collapse = " "), 
[17:46:46.426]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.426]                             info)
[17:46:46.426]                           info <- base::paste(info, collapse = "; ")
[17:46:46.426]                           if (!has_future) {
[17:46:46.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.426]                               info)
[17:46:46.426]                           }
[17:46:46.426]                           else {
[17:46:46.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.426]                               info, version)
[17:46:46.426]                           }
[17:46:46.426]                           base::stop(msg)
[17:46:46.426]                         }
[17:46:46.426]                       })
[17:46:46.426]                     }
[17:46:46.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.426]                     base::options(mc.cores = 1L)
[17:46:46.426]                   }
[17:46:46.426]                   ...future.strategy.old <- future::plan("list")
[17:46:46.426]                   options(future.plan = NULL)
[17:46:46.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.426]                 }
[17:46:46.426]                 ...future.workdir <- getwd()
[17:46:46.426]             }
[17:46:46.426]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.426]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.426]         }
[17:46:46.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.426]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.426]             base::names(...future.oldOptions))
[17:46:46.426]     }
[17:46:46.426]     if (FALSE) {
[17:46:46.426]     }
[17:46:46.426]     else {
[17:46:46.426]         if (TRUE) {
[17:46:46.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.426]                 open = "w")
[17:46:46.426]         }
[17:46:46.426]         else {
[17:46:46.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.426]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.426]         }
[17:46:46.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.426]             base::sink(type = "output", split = FALSE)
[17:46:46.426]             base::close(...future.stdout)
[17:46:46.426]         }, add = TRUE)
[17:46:46.426]     }
[17:46:46.426]     ...future.frame <- base::sys.nframe()
[17:46:46.426]     ...future.conditions <- base::list()
[17:46:46.426]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.426]     if (FALSE) {
[17:46:46.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.426]     }
[17:46:46.426]     ...future.result <- base::tryCatch({
[17:46:46.426]         base::withCallingHandlers({
[17:46:46.426]             ...future.value <- base::withVisible(base::local({
[17:46:46.426]                 ...future.makeSendCondition <- base::local({
[17:46:46.426]                   sendCondition <- NULL
[17:46:46.426]                   function(frame = 1L) {
[17:46:46.426]                     if (is.function(sendCondition)) 
[17:46:46.426]                       return(sendCondition)
[17:46:46.426]                     ns <- getNamespace("parallel")
[17:46:46.426]                     if (exists("sendData", mode = "function", 
[17:46:46.426]                       envir = ns)) {
[17:46:46.426]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.426]                         envir = ns)
[17:46:46.426]                       envir <- sys.frame(frame)
[17:46:46.426]                       master <- NULL
[17:46:46.426]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.426]                         !identical(envir, emptyenv())) {
[17:46:46.426]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.426]                           inherits = FALSE)) {
[17:46:46.426]                           master <- get("master", mode = "list", 
[17:46:46.426]                             envir = envir, inherits = FALSE)
[17:46:46.426]                           if (inherits(master, c("SOCKnode", 
[17:46:46.426]                             "SOCK0node"))) {
[17:46:46.426]                             sendCondition <<- function(cond) {
[17:46:46.426]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.426]                                 success = TRUE)
[17:46:46.426]                               parallel_sendData(master, data)
[17:46:46.426]                             }
[17:46:46.426]                             return(sendCondition)
[17:46:46.426]                           }
[17:46:46.426]                         }
[17:46:46.426]                         frame <- frame + 1L
[17:46:46.426]                         envir <- sys.frame(frame)
[17:46:46.426]                       }
[17:46:46.426]                     }
[17:46:46.426]                     sendCondition <<- function(cond) NULL
[17:46:46.426]                   }
[17:46:46.426]                 })
[17:46:46.426]                 withCallingHandlers({
[17:46:46.426]                   2
[17:46:46.426]                 }, immediateCondition = function(cond) {
[17:46:46.426]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.426]                   sendCondition(cond)
[17:46:46.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.426]                   {
[17:46:46.426]                     inherits <- base::inherits
[17:46:46.426]                     invokeRestart <- base::invokeRestart
[17:46:46.426]                     is.null <- base::is.null
[17:46:46.426]                     muffled <- FALSE
[17:46:46.426]                     if (inherits(cond, "message")) {
[17:46:46.426]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.426]                       if (muffled) 
[17:46:46.426]                         invokeRestart("muffleMessage")
[17:46:46.426]                     }
[17:46:46.426]                     else if (inherits(cond, "warning")) {
[17:46:46.426]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.426]                       if (muffled) 
[17:46:46.426]                         invokeRestart("muffleWarning")
[17:46:46.426]                     }
[17:46:46.426]                     else if (inherits(cond, "condition")) {
[17:46:46.426]                       if (!is.null(pattern)) {
[17:46:46.426]                         computeRestarts <- base::computeRestarts
[17:46:46.426]                         grepl <- base::grepl
[17:46:46.426]                         restarts <- computeRestarts(cond)
[17:46:46.426]                         for (restart in restarts) {
[17:46:46.426]                           name <- restart$name
[17:46:46.426]                           if (is.null(name)) 
[17:46:46.426]                             next
[17:46:46.426]                           if (!grepl(pattern, name)) 
[17:46:46.426]                             next
[17:46:46.426]                           invokeRestart(restart)
[17:46:46.426]                           muffled <- TRUE
[17:46:46.426]                           break
[17:46:46.426]                         }
[17:46:46.426]                       }
[17:46:46.426]                     }
[17:46:46.426]                     invisible(muffled)
[17:46:46.426]                   }
[17:46:46.426]                   muffleCondition(cond)
[17:46:46.426]                 })
[17:46:46.426]             }))
[17:46:46.426]             future::FutureResult(value = ...future.value$value, 
[17:46:46.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.426]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.426]                     ...future.globalenv.names))
[17:46:46.426]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.426]         }, condition = base::local({
[17:46:46.426]             c <- base::c
[17:46:46.426]             inherits <- base::inherits
[17:46:46.426]             invokeRestart <- base::invokeRestart
[17:46:46.426]             length <- base::length
[17:46:46.426]             list <- base::list
[17:46:46.426]             seq.int <- base::seq.int
[17:46:46.426]             signalCondition <- base::signalCondition
[17:46:46.426]             sys.calls <- base::sys.calls
[17:46:46.426]             `[[` <- base::`[[`
[17:46:46.426]             `+` <- base::`+`
[17:46:46.426]             `<<-` <- base::`<<-`
[17:46:46.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.426]                   3L)]
[17:46:46.426]             }
[17:46:46.426]             function(cond) {
[17:46:46.426]                 is_error <- inherits(cond, "error")
[17:46:46.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.426]                   NULL)
[17:46:46.426]                 if (is_error) {
[17:46:46.426]                   sessionInformation <- function() {
[17:46:46.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.426]                       search = base::search(), system = base::Sys.info())
[17:46:46.426]                   }
[17:46:46.426]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.426]                     cond$call), session = sessionInformation(), 
[17:46:46.426]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.426]                   signalCondition(cond)
[17:46:46.426]                 }
[17:46:46.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.426]                 "immediateCondition"))) {
[17:46:46.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.426]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.426]                   if (TRUE && !signal) {
[17:46:46.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.426]                     {
[17:46:46.426]                       inherits <- base::inherits
[17:46:46.426]                       invokeRestart <- base::invokeRestart
[17:46:46.426]                       is.null <- base::is.null
[17:46:46.426]                       muffled <- FALSE
[17:46:46.426]                       if (inherits(cond, "message")) {
[17:46:46.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.426]                         if (muffled) 
[17:46:46.426]                           invokeRestart("muffleMessage")
[17:46:46.426]                       }
[17:46:46.426]                       else if (inherits(cond, "warning")) {
[17:46:46.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.426]                         if (muffled) 
[17:46:46.426]                           invokeRestart("muffleWarning")
[17:46:46.426]                       }
[17:46:46.426]                       else if (inherits(cond, "condition")) {
[17:46:46.426]                         if (!is.null(pattern)) {
[17:46:46.426]                           computeRestarts <- base::computeRestarts
[17:46:46.426]                           grepl <- base::grepl
[17:46:46.426]                           restarts <- computeRestarts(cond)
[17:46:46.426]                           for (restart in restarts) {
[17:46:46.426]                             name <- restart$name
[17:46:46.426]                             if (is.null(name)) 
[17:46:46.426]                               next
[17:46:46.426]                             if (!grepl(pattern, name)) 
[17:46:46.426]                               next
[17:46:46.426]                             invokeRestart(restart)
[17:46:46.426]                             muffled <- TRUE
[17:46:46.426]                             break
[17:46:46.426]                           }
[17:46:46.426]                         }
[17:46:46.426]                       }
[17:46:46.426]                       invisible(muffled)
[17:46:46.426]                     }
[17:46:46.426]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.426]                   }
[17:46:46.426]                 }
[17:46:46.426]                 else {
[17:46:46.426]                   if (TRUE) {
[17:46:46.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.426]                     {
[17:46:46.426]                       inherits <- base::inherits
[17:46:46.426]                       invokeRestart <- base::invokeRestart
[17:46:46.426]                       is.null <- base::is.null
[17:46:46.426]                       muffled <- FALSE
[17:46:46.426]                       if (inherits(cond, "message")) {
[17:46:46.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.426]                         if (muffled) 
[17:46:46.426]                           invokeRestart("muffleMessage")
[17:46:46.426]                       }
[17:46:46.426]                       else if (inherits(cond, "warning")) {
[17:46:46.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.426]                         if (muffled) 
[17:46:46.426]                           invokeRestart("muffleWarning")
[17:46:46.426]                       }
[17:46:46.426]                       else if (inherits(cond, "condition")) {
[17:46:46.426]                         if (!is.null(pattern)) {
[17:46:46.426]                           computeRestarts <- base::computeRestarts
[17:46:46.426]                           grepl <- base::grepl
[17:46:46.426]                           restarts <- computeRestarts(cond)
[17:46:46.426]                           for (restart in restarts) {
[17:46:46.426]                             name <- restart$name
[17:46:46.426]                             if (is.null(name)) 
[17:46:46.426]                               next
[17:46:46.426]                             if (!grepl(pattern, name)) 
[17:46:46.426]                               next
[17:46:46.426]                             invokeRestart(restart)
[17:46:46.426]                             muffled <- TRUE
[17:46:46.426]                             break
[17:46:46.426]                           }
[17:46:46.426]                         }
[17:46:46.426]                       }
[17:46:46.426]                       invisible(muffled)
[17:46:46.426]                     }
[17:46:46.426]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.426]                   }
[17:46:46.426]                 }
[17:46:46.426]             }
[17:46:46.426]         }))
[17:46:46.426]     }, error = function(ex) {
[17:46:46.426]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.426]                 ...future.rng), started = ...future.startTime, 
[17:46:46.426]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.426]             version = "1.8"), class = "FutureResult")
[17:46:46.426]     }, finally = {
[17:46:46.426]         if (!identical(...future.workdir, getwd())) 
[17:46:46.426]             setwd(...future.workdir)
[17:46:46.426]         {
[17:46:46.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.426]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.426]             }
[17:46:46.426]             base::options(...future.oldOptions)
[17:46:46.426]             if (.Platform$OS.type == "windows") {
[17:46:46.426]                 old_names <- names(...future.oldEnvVars)
[17:46:46.426]                 envs <- base::Sys.getenv()
[17:46:46.426]                 names <- names(envs)
[17:46:46.426]                 common <- intersect(names, old_names)
[17:46:46.426]                 added <- setdiff(names, old_names)
[17:46:46.426]                 removed <- setdiff(old_names, names)
[17:46:46.426]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.426]                   envs[common]]
[17:46:46.426]                 NAMES <- toupper(changed)
[17:46:46.426]                 args <- list()
[17:46:46.426]                 for (kk in seq_along(NAMES)) {
[17:46:46.426]                   name <- changed[[kk]]
[17:46:46.426]                   NAME <- NAMES[[kk]]
[17:46:46.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.426]                     next
[17:46:46.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.426]                 }
[17:46:46.426]                 NAMES <- toupper(added)
[17:46:46.426]                 for (kk in seq_along(NAMES)) {
[17:46:46.426]                   name <- added[[kk]]
[17:46:46.426]                   NAME <- NAMES[[kk]]
[17:46:46.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.426]                     next
[17:46:46.426]                   args[[name]] <- ""
[17:46:46.426]                 }
[17:46:46.426]                 NAMES <- toupper(removed)
[17:46:46.426]                 for (kk in seq_along(NAMES)) {
[17:46:46.426]                   name <- removed[[kk]]
[17:46:46.426]                   NAME <- NAMES[[kk]]
[17:46:46.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.426]                     next
[17:46:46.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.426]                 }
[17:46:46.426]                 if (length(args) > 0) 
[17:46:46.426]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.426]             }
[17:46:46.426]             else {
[17:46:46.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.426]             }
[17:46:46.426]             {
[17:46:46.426]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.426]                   0L) {
[17:46:46.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.426]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.426]                   base::options(opts)
[17:46:46.426]                 }
[17:46:46.426]                 {
[17:46:46.426]                   {
[17:46:46.426]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.426]                     NULL
[17:46:46.426]                   }
[17:46:46.426]                   options(future.plan = NULL)
[17:46:46.426]                   if (is.na(NA_character_)) 
[17:46:46.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.426]                     .init = FALSE)
[17:46:46.426]                 }
[17:46:46.426]             }
[17:46:46.426]         }
[17:46:46.426]     })
[17:46:46.426]     if (TRUE) {
[17:46:46.426]         base::sink(type = "output", split = FALSE)
[17:46:46.426]         if (TRUE) {
[17:46:46.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.426]         }
[17:46:46.426]         else {
[17:46:46.426]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.426]         }
[17:46:46.426]         base::close(...future.stdout)
[17:46:46.426]         ...future.stdout <- NULL
[17:46:46.426]     }
[17:46:46.426]     ...future.result$conditions <- ...future.conditions
[17:46:46.426]     ...future.result$finished <- base::Sys.time()
[17:46:46.426]     ...future.result
[17:46:46.426] }
[17:46:46.429] MultisessionFuture started
[17:46:46.429] - Launch lazy future ... done
[17:46:46.429] run() for ‘MultisessionFuture’ ... done
[17:46:46.430] getGlobalsAndPackages() ...
[17:46:46.430] Searching for globals...
[17:46:46.430] 
[17:46:46.430] Searching for globals ... DONE
[17:46:46.431] - globals: [0] <none>
[17:46:46.431] getGlobalsAndPackages() ... DONE
[17:46:46.431] run() for ‘Future’ ...
[17:46:46.431] - state: ‘created’
[17:46:46.431] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.445] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.445]   - Field: ‘node’
[17:46:46.445]   - Field: ‘label’
[17:46:46.445]   - Field: ‘local’
[17:46:46.445]   - Field: ‘owner’
[17:46:46.445]   - Field: ‘envir’
[17:46:46.446]   - Field: ‘workers’
[17:46:46.446]   - Field: ‘packages’
[17:46:46.446]   - Field: ‘gc’
[17:46:46.446]   - Field: ‘conditions’
[17:46:46.446]   - Field: ‘persistent’
[17:46:46.446]   - Field: ‘expr’
[17:46:46.446]   - Field: ‘uuid’
[17:46:46.446]   - Field: ‘seed’
[17:46:46.446]   - Field: ‘version’
[17:46:46.446]   - Field: ‘result’
[17:46:46.446]   - Field: ‘asynchronous’
[17:46:46.446]   - Field: ‘calls’
[17:46:46.447]   - Field: ‘globals’
[17:46:46.447]   - Field: ‘stdout’
[17:46:46.447]   - Field: ‘earlySignal’
[17:46:46.447]   - Field: ‘lazy’
[17:46:46.447]   - Field: ‘state’
[17:46:46.447] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.447] - Launch lazy future ...
[17:46:46.447] Packages needed by the future expression (n = 0): <none>
[17:46:46.448] Packages needed by future strategies (n = 0): <none>
[17:46:46.448] {
[17:46:46.448]     {
[17:46:46.448]         {
[17:46:46.448]             ...future.startTime <- base::Sys.time()
[17:46:46.448]             {
[17:46:46.448]                 {
[17:46:46.448]                   {
[17:46:46.448]                     {
[17:46:46.448]                       base::local({
[17:46:46.448]                         has_future <- base::requireNamespace("future", 
[17:46:46.448]                           quietly = TRUE)
[17:46:46.448]                         if (has_future) {
[17:46:46.448]                           ns <- base::getNamespace("future")
[17:46:46.448]                           version <- ns[[".package"]][["version"]]
[17:46:46.448]                           if (is.null(version)) 
[17:46:46.448]                             version <- utils::packageVersion("future")
[17:46:46.448]                         }
[17:46:46.448]                         else {
[17:46:46.448]                           version <- NULL
[17:46:46.448]                         }
[17:46:46.448]                         if (!has_future || version < "1.8.0") {
[17:46:46.448]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.448]                             "", base::R.version$version.string), 
[17:46:46.448]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.448]                               "release", "version")], collapse = " "), 
[17:46:46.448]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.448]                             info)
[17:46:46.448]                           info <- base::paste(info, collapse = "; ")
[17:46:46.448]                           if (!has_future) {
[17:46:46.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.448]                               info)
[17:46:46.448]                           }
[17:46:46.448]                           else {
[17:46:46.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.448]                               info, version)
[17:46:46.448]                           }
[17:46:46.448]                           base::stop(msg)
[17:46:46.448]                         }
[17:46:46.448]                       })
[17:46:46.448]                     }
[17:46:46.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.448]                     base::options(mc.cores = 1L)
[17:46:46.448]                   }
[17:46:46.448]                   ...future.strategy.old <- future::plan("list")
[17:46:46.448]                   options(future.plan = NULL)
[17:46:46.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.448]                 }
[17:46:46.448]                 ...future.workdir <- getwd()
[17:46:46.448]             }
[17:46:46.448]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.448]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.448]         }
[17:46:46.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.448]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.448]             base::names(...future.oldOptions))
[17:46:46.448]     }
[17:46:46.448]     if (FALSE) {
[17:46:46.448]     }
[17:46:46.448]     else {
[17:46:46.448]         if (TRUE) {
[17:46:46.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.448]                 open = "w")
[17:46:46.448]         }
[17:46:46.448]         else {
[17:46:46.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.448]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.448]         }
[17:46:46.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.448]             base::sink(type = "output", split = FALSE)
[17:46:46.448]             base::close(...future.stdout)
[17:46:46.448]         }, add = TRUE)
[17:46:46.448]     }
[17:46:46.448]     ...future.frame <- base::sys.nframe()
[17:46:46.448]     ...future.conditions <- base::list()
[17:46:46.448]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.448]     if (FALSE) {
[17:46:46.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.448]     }
[17:46:46.448]     ...future.result <- base::tryCatch({
[17:46:46.448]         base::withCallingHandlers({
[17:46:46.448]             ...future.value <- base::withVisible(base::local({
[17:46:46.448]                 ...future.makeSendCondition <- base::local({
[17:46:46.448]                   sendCondition <- NULL
[17:46:46.448]                   function(frame = 1L) {
[17:46:46.448]                     if (is.function(sendCondition)) 
[17:46:46.448]                       return(sendCondition)
[17:46:46.448]                     ns <- getNamespace("parallel")
[17:46:46.448]                     if (exists("sendData", mode = "function", 
[17:46:46.448]                       envir = ns)) {
[17:46:46.448]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.448]                         envir = ns)
[17:46:46.448]                       envir <- sys.frame(frame)
[17:46:46.448]                       master <- NULL
[17:46:46.448]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.448]                         !identical(envir, emptyenv())) {
[17:46:46.448]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.448]                           inherits = FALSE)) {
[17:46:46.448]                           master <- get("master", mode = "list", 
[17:46:46.448]                             envir = envir, inherits = FALSE)
[17:46:46.448]                           if (inherits(master, c("SOCKnode", 
[17:46:46.448]                             "SOCK0node"))) {
[17:46:46.448]                             sendCondition <<- function(cond) {
[17:46:46.448]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.448]                                 success = TRUE)
[17:46:46.448]                               parallel_sendData(master, data)
[17:46:46.448]                             }
[17:46:46.448]                             return(sendCondition)
[17:46:46.448]                           }
[17:46:46.448]                         }
[17:46:46.448]                         frame <- frame + 1L
[17:46:46.448]                         envir <- sys.frame(frame)
[17:46:46.448]                       }
[17:46:46.448]                     }
[17:46:46.448]                     sendCondition <<- function(cond) NULL
[17:46:46.448]                   }
[17:46:46.448]                 })
[17:46:46.448]                 withCallingHandlers({
[17:46:46.448]                   NULL
[17:46:46.448]                 }, immediateCondition = function(cond) {
[17:46:46.448]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.448]                   sendCondition(cond)
[17:46:46.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.448]                   {
[17:46:46.448]                     inherits <- base::inherits
[17:46:46.448]                     invokeRestart <- base::invokeRestart
[17:46:46.448]                     is.null <- base::is.null
[17:46:46.448]                     muffled <- FALSE
[17:46:46.448]                     if (inherits(cond, "message")) {
[17:46:46.448]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.448]                       if (muffled) 
[17:46:46.448]                         invokeRestart("muffleMessage")
[17:46:46.448]                     }
[17:46:46.448]                     else if (inherits(cond, "warning")) {
[17:46:46.448]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.448]                       if (muffled) 
[17:46:46.448]                         invokeRestart("muffleWarning")
[17:46:46.448]                     }
[17:46:46.448]                     else if (inherits(cond, "condition")) {
[17:46:46.448]                       if (!is.null(pattern)) {
[17:46:46.448]                         computeRestarts <- base::computeRestarts
[17:46:46.448]                         grepl <- base::grepl
[17:46:46.448]                         restarts <- computeRestarts(cond)
[17:46:46.448]                         for (restart in restarts) {
[17:46:46.448]                           name <- restart$name
[17:46:46.448]                           if (is.null(name)) 
[17:46:46.448]                             next
[17:46:46.448]                           if (!grepl(pattern, name)) 
[17:46:46.448]                             next
[17:46:46.448]                           invokeRestart(restart)
[17:46:46.448]                           muffled <- TRUE
[17:46:46.448]                           break
[17:46:46.448]                         }
[17:46:46.448]                       }
[17:46:46.448]                     }
[17:46:46.448]                     invisible(muffled)
[17:46:46.448]                   }
[17:46:46.448]                   muffleCondition(cond)
[17:46:46.448]                 })
[17:46:46.448]             }))
[17:46:46.448]             future::FutureResult(value = ...future.value$value, 
[17:46:46.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.448]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.448]                     ...future.globalenv.names))
[17:46:46.448]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.448]         }, condition = base::local({
[17:46:46.448]             c <- base::c
[17:46:46.448]             inherits <- base::inherits
[17:46:46.448]             invokeRestart <- base::invokeRestart
[17:46:46.448]             length <- base::length
[17:46:46.448]             list <- base::list
[17:46:46.448]             seq.int <- base::seq.int
[17:46:46.448]             signalCondition <- base::signalCondition
[17:46:46.448]             sys.calls <- base::sys.calls
[17:46:46.448]             `[[` <- base::`[[`
[17:46:46.448]             `+` <- base::`+`
[17:46:46.448]             `<<-` <- base::`<<-`
[17:46:46.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.448]                   3L)]
[17:46:46.448]             }
[17:46:46.448]             function(cond) {
[17:46:46.448]                 is_error <- inherits(cond, "error")
[17:46:46.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.448]                   NULL)
[17:46:46.448]                 if (is_error) {
[17:46:46.448]                   sessionInformation <- function() {
[17:46:46.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.448]                       search = base::search(), system = base::Sys.info())
[17:46:46.448]                   }
[17:46:46.448]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.448]                     cond$call), session = sessionInformation(), 
[17:46:46.448]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.448]                   signalCondition(cond)
[17:46:46.448]                 }
[17:46:46.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.448]                 "immediateCondition"))) {
[17:46:46.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.448]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.448]                   if (TRUE && !signal) {
[17:46:46.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.448]                     {
[17:46:46.448]                       inherits <- base::inherits
[17:46:46.448]                       invokeRestart <- base::invokeRestart
[17:46:46.448]                       is.null <- base::is.null
[17:46:46.448]                       muffled <- FALSE
[17:46:46.448]                       if (inherits(cond, "message")) {
[17:46:46.448]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.448]                         if (muffled) 
[17:46:46.448]                           invokeRestart("muffleMessage")
[17:46:46.448]                       }
[17:46:46.448]                       else if (inherits(cond, "warning")) {
[17:46:46.448]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.448]                         if (muffled) 
[17:46:46.448]                           invokeRestart("muffleWarning")
[17:46:46.448]                       }
[17:46:46.448]                       else if (inherits(cond, "condition")) {
[17:46:46.448]                         if (!is.null(pattern)) {
[17:46:46.448]                           computeRestarts <- base::computeRestarts
[17:46:46.448]                           grepl <- base::grepl
[17:46:46.448]                           restarts <- computeRestarts(cond)
[17:46:46.448]                           for (restart in restarts) {
[17:46:46.448]                             name <- restart$name
[17:46:46.448]                             if (is.null(name)) 
[17:46:46.448]                               next
[17:46:46.448]                             if (!grepl(pattern, name)) 
[17:46:46.448]                               next
[17:46:46.448]                             invokeRestart(restart)
[17:46:46.448]                             muffled <- TRUE
[17:46:46.448]                             break
[17:46:46.448]                           }
[17:46:46.448]                         }
[17:46:46.448]                       }
[17:46:46.448]                       invisible(muffled)
[17:46:46.448]                     }
[17:46:46.448]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.448]                   }
[17:46:46.448]                 }
[17:46:46.448]                 else {
[17:46:46.448]                   if (TRUE) {
[17:46:46.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.448]                     {
[17:46:46.448]                       inherits <- base::inherits
[17:46:46.448]                       invokeRestart <- base::invokeRestart
[17:46:46.448]                       is.null <- base::is.null
[17:46:46.448]                       muffled <- FALSE
[17:46:46.448]                       if (inherits(cond, "message")) {
[17:46:46.448]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.448]                         if (muffled) 
[17:46:46.448]                           invokeRestart("muffleMessage")
[17:46:46.448]                       }
[17:46:46.448]                       else if (inherits(cond, "warning")) {
[17:46:46.448]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.448]                         if (muffled) 
[17:46:46.448]                           invokeRestart("muffleWarning")
[17:46:46.448]                       }
[17:46:46.448]                       else if (inherits(cond, "condition")) {
[17:46:46.448]                         if (!is.null(pattern)) {
[17:46:46.448]                           computeRestarts <- base::computeRestarts
[17:46:46.448]                           grepl <- base::grepl
[17:46:46.448]                           restarts <- computeRestarts(cond)
[17:46:46.448]                           for (restart in restarts) {
[17:46:46.448]                             name <- restart$name
[17:46:46.448]                             if (is.null(name)) 
[17:46:46.448]                               next
[17:46:46.448]                             if (!grepl(pattern, name)) 
[17:46:46.448]                               next
[17:46:46.448]                             invokeRestart(restart)
[17:46:46.448]                             muffled <- TRUE
[17:46:46.448]                             break
[17:46:46.448]                           }
[17:46:46.448]                         }
[17:46:46.448]                       }
[17:46:46.448]                       invisible(muffled)
[17:46:46.448]                     }
[17:46:46.448]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.448]                   }
[17:46:46.448]                 }
[17:46:46.448]             }
[17:46:46.448]         }))
[17:46:46.448]     }, error = function(ex) {
[17:46:46.448]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.448]                 ...future.rng), started = ...future.startTime, 
[17:46:46.448]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.448]             version = "1.8"), class = "FutureResult")
[17:46:46.448]     }, finally = {
[17:46:46.448]         if (!identical(...future.workdir, getwd())) 
[17:46:46.448]             setwd(...future.workdir)
[17:46:46.448]         {
[17:46:46.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.448]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.448]             }
[17:46:46.448]             base::options(...future.oldOptions)
[17:46:46.448]             if (.Platform$OS.type == "windows") {
[17:46:46.448]                 old_names <- names(...future.oldEnvVars)
[17:46:46.448]                 envs <- base::Sys.getenv()
[17:46:46.448]                 names <- names(envs)
[17:46:46.448]                 common <- intersect(names, old_names)
[17:46:46.448]                 added <- setdiff(names, old_names)
[17:46:46.448]                 removed <- setdiff(old_names, names)
[17:46:46.448]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.448]                   envs[common]]
[17:46:46.448]                 NAMES <- toupper(changed)
[17:46:46.448]                 args <- list()
[17:46:46.448]                 for (kk in seq_along(NAMES)) {
[17:46:46.448]                   name <- changed[[kk]]
[17:46:46.448]                   NAME <- NAMES[[kk]]
[17:46:46.448]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.448]                     next
[17:46:46.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.448]                 }
[17:46:46.448]                 NAMES <- toupper(added)
[17:46:46.448]                 for (kk in seq_along(NAMES)) {
[17:46:46.448]                   name <- added[[kk]]
[17:46:46.448]                   NAME <- NAMES[[kk]]
[17:46:46.448]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.448]                     next
[17:46:46.448]                   args[[name]] <- ""
[17:46:46.448]                 }
[17:46:46.448]                 NAMES <- toupper(removed)
[17:46:46.448]                 for (kk in seq_along(NAMES)) {
[17:46:46.448]                   name <- removed[[kk]]
[17:46:46.448]                   NAME <- NAMES[[kk]]
[17:46:46.448]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.448]                     next
[17:46:46.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.448]                 }
[17:46:46.448]                 if (length(args) > 0) 
[17:46:46.448]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.448]             }
[17:46:46.448]             else {
[17:46:46.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.448]             }
[17:46:46.448]             {
[17:46:46.448]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.448]                   0L) {
[17:46:46.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.448]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.448]                   base::options(opts)
[17:46:46.448]                 }
[17:46:46.448]                 {
[17:46:46.448]                   {
[17:46:46.448]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.448]                     NULL
[17:46:46.448]                   }
[17:46:46.448]                   options(future.plan = NULL)
[17:46:46.448]                   if (is.na(NA_character_)) 
[17:46:46.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.448]                     .init = FALSE)
[17:46:46.448]                 }
[17:46:46.448]             }
[17:46:46.448]         }
[17:46:46.448]     })
[17:46:46.448]     if (TRUE) {
[17:46:46.448]         base::sink(type = "output", split = FALSE)
[17:46:46.448]         if (TRUE) {
[17:46:46.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.448]         }
[17:46:46.448]         else {
[17:46:46.448]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.448]         }
[17:46:46.448]         base::close(...future.stdout)
[17:46:46.448]         ...future.stdout <- NULL
[17:46:46.448]     }
[17:46:46.448]     ...future.result$conditions <- ...future.conditions
[17:46:46.448]     ...future.result$finished <- base::Sys.time()
[17:46:46.448]     ...future.result
[17:46:46.448] }
[17:46:46.451] MultisessionFuture started
[17:46:46.451] - Launch lazy future ... done
[17:46:46.451] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617863ba1f8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56178851ecd8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617863ba1f8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56178851ecd8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:46.456] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.457] - Validating connection of MultisessionFuture
[17:46:46.457] - received message: FutureResult
[17:46:46.457] - Received FutureResult
[17:46:46.457] - Erased future from FutureRegistry
[17:46:46.457] result() for ClusterFuture ...
[17:46:46.457] - result already collected: FutureResult
[17:46:46.457] result() for ClusterFuture ... done
[17:46:46.457] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:46.458] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.458] - Validating connection of MultisessionFuture
[17:46:46.458] - received message: FutureResult
[17:46:46.458] - Received FutureResult
[17:46:46.458] - Erased future from FutureRegistry
[17:46:46.458] result() for ClusterFuture ...
[17:46:46.458] - result already collected: FutureResult
[17:46:46.459] result() for ClusterFuture ... done
[17:46:46.459] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:46.460] resolve() on list ...
[17:46:46.460]  recursive: 0
[17:46:46.461]  length: 6
[17:46:46.461]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:46.461] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.461] - nx: 6
[17:46:46.461] - relay: TRUE
[17:46:46.461] - stdout: TRUE
[17:46:46.461] - signal: TRUE
[17:46:46.461] - resignal: FALSE
[17:46:46.461] - force: TRUE
[17:46:46.461] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.461] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.462]  - until=2
[17:46:46.462]  - relaying element #2
[17:46:46.462] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.462] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.462] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.462]  length: 5 (resolved future 1)
[17:46:46.462] Future #2
[17:46:46.462] result() for ClusterFuture ...
[17:46:46.462] - result already collected: FutureResult
[17:46:46.462] result() for ClusterFuture ... done
[17:46:46.462] result() for ClusterFuture ...
[17:46:46.463] - result already collected: FutureResult
[17:46:46.463] result() for ClusterFuture ... done
[17:46:46.463] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:46.463] - nx: 6
[17:46:46.463] - relay: TRUE
[17:46:46.463] - stdout: TRUE
[17:46:46.463] - signal: TRUE
[17:46:46.463] - resignal: FALSE
[17:46:46.463] - force: TRUE
[17:46:46.463] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.463] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.464]  - until=2
[17:46:46.464]  - relaying element #2
[17:46:46.464] result() for ClusterFuture ...
[17:46:46.464] - result already collected: FutureResult
[17:46:46.464] result() for ClusterFuture ... done
[17:46:46.464] result() for ClusterFuture ...
[17:46:46.464] - result already collected: FutureResult
[17:46:46.464] result() for ClusterFuture ... done
[17:46:46.464] result() for ClusterFuture ...
[17:46:46.464] - result already collected: FutureResult
[17:46:46.464] result() for ClusterFuture ... done
[17:46:46.465] result() for ClusterFuture ...
[17:46:46.465] - result already collected: FutureResult
[17:46:46.465] result() for ClusterFuture ... done
[17:46:46.465] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.465] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.465] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:46.465]  length: 4 (resolved future 2)
[17:46:46.465] Future #3
[17:46:46.465] result() for ClusterFuture ...
[17:46:46.465] - result already collected: FutureResult
[17:46:46.465] result() for ClusterFuture ... done
[17:46:46.465] result() for ClusterFuture ...
[17:46:46.466] - result already collected: FutureResult
[17:46:46.466] result() for ClusterFuture ... done
[17:46:46.466] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:46.466] - nx: 6
[17:46:46.466] - relay: TRUE
[17:46:46.466] - stdout: TRUE
[17:46:46.466] - signal: TRUE
[17:46:46.466] - resignal: FALSE
[17:46:46.466] - force: TRUE
[17:46:46.466] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.466] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.466]  - until=3
[17:46:46.467]  - relaying element #3
[17:46:46.467] result() for ClusterFuture ...
[17:46:46.467] - result already collected: FutureResult
[17:46:46.467] result() for ClusterFuture ... done
[17:46:46.467] result() for ClusterFuture ...
[17:46:46.467] - result already collected: FutureResult
[17:46:46.467] result() for ClusterFuture ... done
[17:46:46.467] result() for ClusterFuture ...
[17:46:46.467] - result already collected: FutureResult
[17:46:46.467] result() for ClusterFuture ... done
[17:46:46.468] result() for ClusterFuture ...
[17:46:46.468] - result already collected: FutureResult
[17:46:46.468] result() for ClusterFuture ... done
[17:46:46.468] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.468] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.468] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:46.468]  length: 3 (resolved future 3)
[17:46:46.468] signalConditionsASAP(NULL, pos=4) ...
[17:46:46.468] - nx: 6
[17:46:46.468] - relay: TRUE
[17:46:46.468] - stdout: TRUE
[17:46:46.468] - signal: TRUE
[17:46:46.469] - resignal: FALSE
[17:46:46.469] - force: TRUE
[17:46:46.469] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.469] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.469]  - until=5
[17:46:46.469]  - relaying element #5
[17:46:46.469] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.469] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.469] signalConditionsASAP(NULL, pos=4) ... done
[17:46:46.469]  length: 2 (resolved future 4)
[17:46:46.469] signalConditionsASAP(NULL, pos=5) ...
[17:46:46.469] - nx: 6
[17:46:46.470] - relay: TRUE
[17:46:46.470] - stdout: TRUE
[17:46:46.470] - signal: TRUE
[17:46:46.470] - resignal: FALSE
[17:46:46.470] - force: TRUE
[17:46:46.470] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.470] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.470]  - until=6
[17:46:46.470]  - relaying element #6
[17:46:46.470] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.470] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.470] signalConditionsASAP(NULL, pos=5) ... done
[17:46:46.471]  length: 1 (resolved future 5)
[17:46:46.471] signalConditionsASAP(numeric, pos=6) ...
[17:46:46.471] - nx: 6
[17:46:46.471] - relay: TRUE
[17:46:46.471] - stdout: TRUE
[17:46:46.471] - signal: TRUE
[17:46:46.471] - resignal: FALSE
[17:46:46.471] - force: TRUE
[17:46:46.471] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.471] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.471]  - until=6
[17:46:46.471] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.472] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.472] signalConditionsASAP(numeric, pos=6) ... done
[17:46:46.472]  length: 0 (resolved future 6)
[17:46:46.472] Relaying remaining futures
[17:46:46.472] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.472] - nx: 6
[17:46:46.472] - relay: TRUE
[17:46:46.472] - stdout: TRUE
[17:46:46.472] - signal: TRUE
[17:46:46.472] - resignal: FALSE
[17:46:46.472] - force: TRUE
[17:46:46.472] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.472] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:46.473] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.473] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.473] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.473] resolve() on list ... DONE
[17:46:46.473] result() for ClusterFuture ...
[17:46:46.473] - result already collected: FutureResult
[17:46:46.473] result() for ClusterFuture ... done
[17:46:46.473] result() for ClusterFuture ...
[17:46:46.473] - result already collected: FutureResult
[17:46:46.473] result() for ClusterFuture ... done
[17:46:46.474] result() for ClusterFuture ...
[17:46:46.474] - result already collected: FutureResult
[17:46:46.474] result() for ClusterFuture ... done
[17:46:46.474] result() for ClusterFuture ...
[17:46:46.474] - result already collected: FutureResult
[17:46:46.474] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:46:46.477] getGlobalsAndPackages() ...
[17:46:46.477] Searching for globals...
[17:46:46.478] 
[17:46:46.478] Searching for globals ... DONE
[17:46:46.478] - globals: [0] <none>
[17:46:46.478] getGlobalsAndPackages() ... DONE
[17:46:46.478] run() for ‘Future’ ...
[17:46:46.478] - state: ‘created’
[17:46:46.478] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.492] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.492]   - Field: ‘node’
[17:46:46.492]   - Field: ‘label’
[17:46:46.492]   - Field: ‘local’
[17:46:46.492]   - Field: ‘owner’
[17:46:46.492]   - Field: ‘envir’
[17:46:46.492]   - Field: ‘workers’
[17:46:46.493]   - Field: ‘packages’
[17:46:46.493]   - Field: ‘gc’
[17:46:46.493]   - Field: ‘conditions’
[17:46:46.493]   - Field: ‘persistent’
[17:46:46.493]   - Field: ‘expr’
[17:46:46.493]   - Field: ‘uuid’
[17:46:46.493]   - Field: ‘seed’
[17:46:46.493]   - Field: ‘version’
[17:46:46.493]   - Field: ‘result’
[17:46:46.493]   - Field: ‘asynchronous’
[17:46:46.495]   - Field: ‘calls’
[17:46:46.495]   - Field: ‘globals’
[17:46:46.495]   - Field: ‘stdout’
[17:46:46.496]   - Field: ‘earlySignal’
[17:46:46.496]   - Field: ‘lazy’
[17:46:46.496]   - Field: ‘state’
[17:46:46.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.496] - Launch lazy future ...
[17:46:46.496] Packages needed by the future expression (n = 0): <none>
[17:46:46.496] Packages needed by future strategies (n = 0): <none>
[17:46:46.497] {
[17:46:46.497]     {
[17:46:46.497]         {
[17:46:46.497]             ...future.startTime <- base::Sys.time()
[17:46:46.497]             {
[17:46:46.497]                 {
[17:46:46.497]                   {
[17:46:46.497]                     {
[17:46:46.497]                       base::local({
[17:46:46.497]                         has_future <- base::requireNamespace("future", 
[17:46:46.497]                           quietly = TRUE)
[17:46:46.497]                         if (has_future) {
[17:46:46.497]                           ns <- base::getNamespace("future")
[17:46:46.497]                           version <- ns[[".package"]][["version"]]
[17:46:46.497]                           if (is.null(version)) 
[17:46:46.497]                             version <- utils::packageVersion("future")
[17:46:46.497]                         }
[17:46:46.497]                         else {
[17:46:46.497]                           version <- NULL
[17:46:46.497]                         }
[17:46:46.497]                         if (!has_future || version < "1.8.0") {
[17:46:46.497]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.497]                             "", base::R.version$version.string), 
[17:46:46.497]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.497]                               "release", "version")], collapse = " "), 
[17:46:46.497]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.497]                             info)
[17:46:46.497]                           info <- base::paste(info, collapse = "; ")
[17:46:46.497]                           if (!has_future) {
[17:46:46.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.497]                               info)
[17:46:46.497]                           }
[17:46:46.497]                           else {
[17:46:46.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.497]                               info, version)
[17:46:46.497]                           }
[17:46:46.497]                           base::stop(msg)
[17:46:46.497]                         }
[17:46:46.497]                       })
[17:46:46.497]                     }
[17:46:46.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.497]                     base::options(mc.cores = 1L)
[17:46:46.497]                   }
[17:46:46.497]                   ...future.strategy.old <- future::plan("list")
[17:46:46.497]                   options(future.plan = NULL)
[17:46:46.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.497]                 }
[17:46:46.497]                 ...future.workdir <- getwd()
[17:46:46.497]             }
[17:46:46.497]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.497]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.497]         }
[17:46:46.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.497]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.497]             base::names(...future.oldOptions))
[17:46:46.497]     }
[17:46:46.497]     if (FALSE) {
[17:46:46.497]     }
[17:46:46.497]     else {
[17:46:46.497]         if (TRUE) {
[17:46:46.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.497]                 open = "w")
[17:46:46.497]         }
[17:46:46.497]         else {
[17:46:46.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.497]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.497]         }
[17:46:46.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.497]             base::sink(type = "output", split = FALSE)
[17:46:46.497]             base::close(...future.stdout)
[17:46:46.497]         }, add = TRUE)
[17:46:46.497]     }
[17:46:46.497]     ...future.frame <- base::sys.nframe()
[17:46:46.497]     ...future.conditions <- base::list()
[17:46:46.497]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.497]     if (FALSE) {
[17:46:46.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.497]     }
[17:46:46.497]     ...future.result <- base::tryCatch({
[17:46:46.497]         base::withCallingHandlers({
[17:46:46.497]             ...future.value <- base::withVisible(base::local({
[17:46:46.497]                 ...future.makeSendCondition <- base::local({
[17:46:46.497]                   sendCondition <- NULL
[17:46:46.497]                   function(frame = 1L) {
[17:46:46.497]                     if (is.function(sendCondition)) 
[17:46:46.497]                       return(sendCondition)
[17:46:46.497]                     ns <- getNamespace("parallel")
[17:46:46.497]                     if (exists("sendData", mode = "function", 
[17:46:46.497]                       envir = ns)) {
[17:46:46.497]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.497]                         envir = ns)
[17:46:46.497]                       envir <- sys.frame(frame)
[17:46:46.497]                       master <- NULL
[17:46:46.497]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.497]                         !identical(envir, emptyenv())) {
[17:46:46.497]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.497]                           inherits = FALSE)) {
[17:46:46.497]                           master <- get("master", mode = "list", 
[17:46:46.497]                             envir = envir, inherits = FALSE)
[17:46:46.497]                           if (inherits(master, c("SOCKnode", 
[17:46:46.497]                             "SOCK0node"))) {
[17:46:46.497]                             sendCondition <<- function(cond) {
[17:46:46.497]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.497]                                 success = TRUE)
[17:46:46.497]                               parallel_sendData(master, data)
[17:46:46.497]                             }
[17:46:46.497]                             return(sendCondition)
[17:46:46.497]                           }
[17:46:46.497]                         }
[17:46:46.497]                         frame <- frame + 1L
[17:46:46.497]                         envir <- sys.frame(frame)
[17:46:46.497]                       }
[17:46:46.497]                     }
[17:46:46.497]                     sendCondition <<- function(cond) NULL
[17:46:46.497]                   }
[17:46:46.497]                 })
[17:46:46.497]                 withCallingHandlers({
[17:46:46.497]                   2
[17:46:46.497]                 }, immediateCondition = function(cond) {
[17:46:46.497]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.497]                   sendCondition(cond)
[17:46:46.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.497]                   {
[17:46:46.497]                     inherits <- base::inherits
[17:46:46.497]                     invokeRestart <- base::invokeRestart
[17:46:46.497]                     is.null <- base::is.null
[17:46:46.497]                     muffled <- FALSE
[17:46:46.497]                     if (inherits(cond, "message")) {
[17:46:46.497]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.497]                       if (muffled) 
[17:46:46.497]                         invokeRestart("muffleMessage")
[17:46:46.497]                     }
[17:46:46.497]                     else if (inherits(cond, "warning")) {
[17:46:46.497]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.497]                       if (muffled) 
[17:46:46.497]                         invokeRestart("muffleWarning")
[17:46:46.497]                     }
[17:46:46.497]                     else if (inherits(cond, "condition")) {
[17:46:46.497]                       if (!is.null(pattern)) {
[17:46:46.497]                         computeRestarts <- base::computeRestarts
[17:46:46.497]                         grepl <- base::grepl
[17:46:46.497]                         restarts <- computeRestarts(cond)
[17:46:46.497]                         for (restart in restarts) {
[17:46:46.497]                           name <- restart$name
[17:46:46.497]                           if (is.null(name)) 
[17:46:46.497]                             next
[17:46:46.497]                           if (!grepl(pattern, name)) 
[17:46:46.497]                             next
[17:46:46.497]                           invokeRestart(restart)
[17:46:46.497]                           muffled <- TRUE
[17:46:46.497]                           break
[17:46:46.497]                         }
[17:46:46.497]                       }
[17:46:46.497]                     }
[17:46:46.497]                     invisible(muffled)
[17:46:46.497]                   }
[17:46:46.497]                   muffleCondition(cond)
[17:46:46.497]                 })
[17:46:46.497]             }))
[17:46:46.497]             future::FutureResult(value = ...future.value$value, 
[17:46:46.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.497]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.497]                     ...future.globalenv.names))
[17:46:46.497]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.497]         }, condition = base::local({
[17:46:46.497]             c <- base::c
[17:46:46.497]             inherits <- base::inherits
[17:46:46.497]             invokeRestart <- base::invokeRestart
[17:46:46.497]             length <- base::length
[17:46:46.497]             list <- base::list
[17:46:46.497]             seq.int <- base::seq.int
[17:46:46.497]             signalCondition <- base::signalCondition
[17:46:46.497]             sys.calls <- base::sys.calls
[17:46:46.497]             `[[` <- base::`[[`
[17:46:46.497]             `+` <- base::`+`
[17:46:46.497]             `<<-` <- base::`<<-`
[17:46:46.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.497]                   3L)]
[17:46:46.497]             }
[17:46:46.497]             function(cond) {
[17:46:46.497]                 is_error <- inherits(cond, "error")
[17:46:46.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.497]                   NULL)
[17:46:46.497]                 if (is_error) {
[17:46:46.497]                   sessionInformation <- function() {
[17:46:46.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.497]                       search = base::search(), system = base::Sys.info())
[17:46:46.497]                   }
[17:46:46.497]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.497]                     cond$call), session = sessionInformation(), 
[17:46:46.497]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.497]                   signalCondition(cond)
[17:46:46.497]                 }
[17:46:46.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.497]                 "immediateCondition"))) {
[17:46:46.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.497]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.497]                   if (TRUE && !signal) {
[17:46:46.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.497]                     {
[17:46:46.497]                       inherits <- base::inherits
[17:46:46.497]                       invokeRestart <- base::invokeRestart
[17:46:46.497]                       is.null <- base::is.null
[17:46:46.497]                       muffled <- FALSE
[17:46:46.497]                       if (inherits(cond, "message")) {
[17:46:46.497]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.497]                         if (muffled) 
[17:46:46.497]                           invokeRestart("muffleMessage")
[17:46:46.497]                       }
[17:46:46.497]                       else if (inherits(cond, "warning")) {
[17:46:46.497]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.497]                         if (muffled) 
[17:46:46.497]                           invokeRestart("muffleWarning")
[17:46:46.497]                       }
[17:46:46.497]                       else if (inherits(cond, "condition")) {
[17:46:46.497]                         if (!is.null(pattern)) {
[17:46:46.497]                           computeRestarts <- base::computeRestarts
[17:46:46.497]                           grepl <- base::grepl
[17:46:46.497]                           restarts <- computeRestarts(cond)
[17:46:46.497]                           for (restart in restarts) {
[17:46:46.497]                             name <- restart$name
[17:46:46.497]                             if (is.null(name)) 
[17:46:46.497]                               next
[17:46:46.497]                             if (!grepl(pattern, name)) 
[17:46:46.497]                               next
[17:46:46.497]                             invokeRestart(restart)
[17:46:46.497]                             muffled <- TRUE
[17:46:46.497]                             break
[17:46:46.497]                           }
[17:46:46.497]                         }
[17:46:46.497]                       }
[17:46:46.497]                       invisible(muffled)
[17:46:46.497]                     }
[17:46:46.497]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.497]                   }
[17:46:46.497]                 }
[17:46:46.497]                 else {
[17:46:46.497]                   if (TRUE) {
[17:46:46.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.497]                     {
[17:46:46.497]                       inherits <- base::inherits
[17:46:46.497]                       invokeRestart <- base::invokeRestart
[17:46:46.497]                       is.null <- base::is.null
[17:46:46.497]                       muffled <- FALSE
[17:46:46.497]                       if (inherits(cond, "message")) {
[17:46:46.497]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.497]                         if (muffled) 
[17:46:46.497]                           invokeRestart("muffleMessage")
[17:46:46.497]                       }
[17:46:46.497]                       else if (inherits(cond, "warning")) {
[17:46:46.497]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.497]                         if (muffled) 
[17:46:46.497]                           invokeRestart("muffleWarning")
[17:46:46.497]                       }
[17:46:46.497]                       else if (inherits(cond, "condition")) {
[17:46:46.497]                         if (!is.null(pattern)) {
[17:46:46.497]                           computeRestarts <- base::computeRestarts
[17:46:46.497]                           grepl <- base::grepl
[17:46:46.497]                           restarts <- computeRestarts(cond)
[17:46:46.497]                           for (restart in restarts) {
[17:46:46.497]                             name <- restart$name
[17:46:46.497]                             if (is.null(name)) 
[17:46:46.497]                               next
[17:46:46.497]                             if (!grepl(pattern, name)) 
[17:46:46.497]                               next
[17:46:46.497]                             invokeRestart(restart)
[17:46:46.497]                             muffled <- TRUE
[17:46:46.497]                             break
[17:46:46.497]                           }
[17:46:46.497]                         }
[17:46:46.497]                       }
[17:46:46.497]                       invisible(muffled)
[17:46:46.497]                     }
[17:46:46.497]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.497]                   }
[17:46:46.497]                 }
[17:46:46.497]             }
[17:46:46.497]         }))
[17:46:46.497]     }, error = function(ex) {
[17:46:46.497]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.497]                 ...future.rng), started = ...future.startTime, 
[17:46:46.497]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.497]             version = "1.8"), class = "FutureResult")
[17:46:46.497]     }, finally = {
[17:46:46.497]         if (!identical(...future.workdir, getwd())) 
[17:46:46.497]             setwd(...future.workdir)
[17:46:46.497]         {
[17:46:46.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.497]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.497]             }
[17:46:46.497]             base::options(...future.oldOptions)
[17:46:46.497]             if (.Platform$OS.type == "windows") {
[17:46:46.497]                 old_names <- names(...future.oldEnvVars)
[17:46:46.497]                 envs <- base::Sys.getenv()
[17:46:46.497]                 names <- names(envs)
[17:46:46.497]                 common <- intersect(names, old_names)
[17:46:46.497]                 added <- setdiff(names, old_names)
[17:46:46.497]                 removed <- setdiff(old_names, names)
[17:46:46.497]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.497]                   envs[common]]
[17:46:46.497]                 NAMES <- toupper(changed)
[17:46:46.497]                 args <- list()
[17:46:46.497]                 for (kk in seq_along(NAMES)) {
[17:46:46.497]                   name <- changed[[kk]]
[17:46:46.497]                   NAME <- NAMES[[kk]]
[17:46:46.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.497]                     next
[17:46:46.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.497]                 }
[17:46:46.497]                 NAMES <- toupper(added)
[17:46:46.497]                 for (kk in seq_along(NAMES)) {
[17:46:46.497]                   name <- added[[kk]]
[17:46:46.497]                   NAME <- NAMES[[kk]]
[17:46:46.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.497]                     next
[17:46:46.497]                   args[[name]] <- ""
[17:46:46.497]                 }
[17:46:46.497]                 NAMES <- toupper(removed)
[17:46:46.497]                 for (kk in seq_along(NAMES)) {
[17:46:46.497]                   name <- removed[[kk]]
[17:46:46.497]                   NAME <- NAMES[[kk]]
[17:46:46.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.497]                     next
[17:46:46.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.497]                 }
[17:46:46.497]                 if (length(args) > 0) 
[17:46:46.497]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.497]             }
[17:46:46.497]             else {
[17:46:46.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.497]             }
[17:46:46.497]             {
[17:46:46.497]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.497]                   0L) {
[17:46:46.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.497]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.497]                   base::options(opts)
[17:46:46.497]                 }
[17:46:46.497]                 {
[17:46:46.497]                   {
[17:46:46.497]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.497]                     NULL
[17:46:46.497]                   }
[17:46:46.497]                   options(future.plan = NULL)
[17:46:46.497]                   if (is.na(NA_character_)) 
[17:46:46.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.497]                     .init = FALSE)
[17:46:46.497]                 }
[17:46:46.497]             }
[17:46:46.497]         }
[17:46:46.497]     })
[17:46:46.497]     if (TRUE) {
[17:46:46.497]         base::sink(type = "output", split = FALSE)
[17:46:46.497]         if (TRUE) {
[17:46:46.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.497]         }
[17:46:46.497]         else {
[17:46:46.497]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.497]         }
[17:46:46.497]         base::close(...future.stdout)
[17:46:46.497]         ...future.stdout <- NULL
[17:46:46.497]     }
[17:46:46.497]     ...future.result$conditions <- ...future.conditions
[17:46:46.497]     ...future.result$finished <- base::Sys.time()
[17:46:46.497]     ...future.result
[17:46:46.497] }
[17:46:46.499] MultisessionFuture started
[17:46:46.500] - Launch lazy future ... done
[17:46:46.500] run() for ‘MultisessionFuture’ ... done
[17:46:46.500] getGlobalsAndPackages() ...
[17:46:46.500] Searching for globals...
[17:46:46.500] 
[17:46:46.500] Searching for globals ... DONE
[17:46:46.500] - globals: [0] <none>
[17:46:46.500] getGlobalsAndPackages() ... DONE
[17:46:46.501] run() for ‘Future’ ...
[17:46:46.501] - state: ‘created’
[17:46:46.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:46.514]   - Field: ‘node’
[17:46:46.514]   - Field: ‘label’
[17:46:46.515]   - Field: ‘local’
[17:46:46.515]   - Field: ‘owner’
[17:46:46.515]   - Field: ‘envir’
[17:46:46.515]   - Field: ‘workers’
[17:46:46.515]   - Field: ‘packages’
[17:46:46.515]   - Field: ‘gc’
[17:46:46.515]   - Field: ‘conditions’
[17:46:46.515]   - Field: ‘persistent’
[17:46:46.515]   - Field: ‘expr’
[17:46:46.515]   - Field: ‘uuid’
[17:46:46.515]   - Field: ‘seed’
[17:46:46.516]   - Field: ‘version’
[17:46:46.516]   - Field: ‘result’
[17:46:46.516]   - Field: ‘asynchronous’
[17:46:46.516]   - Field: ‘calls’
[17:46:46.516]   - Field: ‘globals’
[17:46:46.516]   - Field: ‘stdout’
[17:46:46.516]   - Field: ‘earlySignal’
[17:46:46.516]   - Field: ‘lazy’
[17:46:46.516]   - Field: ‘state’
[17:46:46.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:46.516] - Launch lazy future ...
[17:46:46.517] Packages needed by the future expression (n = 0): <none>
[17:46:46.517] Packages needed by future strategies (n = 0): <none>
[17:46:46.517] {
[17:46:46.517]     {
[17:46:46.517]         {
[17:46:46.517]             ...future.startTime <- base::Sys.time()
[17:46:46.517]             {
[17:46:46.517]                 {
[17:46:46.517]                   {
[17:46:46.517]                     {
[17:46:46.517]                       base::local({
[17:46:46.517]                         has_future <- base::requireNamespace("future", 
[17:46:46.517]                           quietly = TRUE)
[17:46:46.517]                         if (has_future) {
[17:46:46.517]                           ns <- base::getNamespace("future")
[17:46:46.517]                           version <- ns[[".package"]][["version"]]
[17:46:46.517]                           if (is.null(version)) 
[17:46:46.517]                             version <- utils::packageVersion("future")
[17:46:46.517]                         }
[17:46:46.517]                         else {
[17:46:46.517]                           version <- NULL
[17:46:46.517]                         }
[17:46:46.517]                         if (!has_future || version < "1.8.0") {
[17:46:46.517]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.517]                             "", base::R.version$version.string), 
[17:46:46.517]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.517]                               "release", "version")], collapse = " "), 
[17:46:46.517]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.517]                             info)
[17:46:46.517]                           info <- base::paste(info, collapse = "; ")
[17:46:46.517]                           if (!has_future) {
[17:46:46.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.517]                               info)
[17:46:46.517]                           }
[17:46:46.517]                           else {
[17:46:46.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.517]                               info, version)
[17:46:46.517]                           }
[17:46:46.517]                           base::stop(msg)
[17:46:46.517]                         }
[17:46:46.517]                       })
[17:46:46.517]                     }
[17:46:46.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.517]                     base::options(mc.cores = 1L)
[17:46:46.517]                   }
[17:46:46.517]                   ...future.strategy.old <- future::plan("list")
[17:46:46.517]                   options(future.plan = NULL)
[17:46:46.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.517]                 }
[17:46:46.517]                 ...future.workdir <- getwd()
[17:46:46.517]             }
[17:46:46.517]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.517]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.517]         }
[17:46:46.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.517]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.517]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.517]             base::names(...future.oldOptions))
[17:46:46.517]     }
[17:46:46.517]     if (FALSE) {
[17:46:46.517]     }
[17:46:46.517]     else {
[17:46:46.517]         if (TRUE) {
[17:46:46.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.517]                 open = "w")
[17:46:46.517]         }
[17:46:46.517]         else {
[17:46:46.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.517]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.517]         }
[17:46:46.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.517]             base::sink(type = "output", split = FALSE)
[17:46:46.517]             base::close(...future.stdout)
[17:46:46.517]         }, add = TRUE)
[17:46:46.517]     }
[17:46:46.517]     ...future.frame <- base::sys.nframe()
[17:46:46.517]     ...future.conditions <- base::list()
[17:46:46.517]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.517]     if (FALSE) {
[17:46:46.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.517]     }
[17:46:46.517]     ...future.result <- base::tryCatch({
[17:46:46.517]         base::withCallingHandlers({
[17:46:46.517]             ...future.value <- base::withVisible(base::local({
[17:46:46.517]                 ...future.makeSendCondition <- base::local({
[17:46:46.517]                   sendCondition <- NULL
[17:46:46.517]                   function(frame = 1L) {
[17:46:46.517]                     if (is.function(sendCondition)) 
[17:46:46.517]                       return(sendCondition)
[17:46:46.517]                     ns <- getNamespace("parallel")
[17:46:46.517]                     if (exists("sendData", mode = "function", 
[17:46:46.517]                       envir = ns)) {
[17:46:46.517]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:46.517]                         envir = ns)
[17:46:46.517]                       envir <- sys.frame(frame)
[17:46:46.517]                       master <- NULL
[17:46:46.517]                       while (!identical(envir, .GlobalEnv) && 
[17:46:46.517]                         !identical(envir, emptyenv())) {
[17:46:46.517]                         if (exists("master", mode = "list", envir = envir, 
[17:46:46.517]                           inherits = FALSE)) {
[17:46:46.517]                           master <- get("master", mode = "list", 
[17:46:46.517]                             envir = envir, inherits = FALSE)
[17:46:46.517]                           if (inherits(master, c("SOCKnode", 
[17:46:46.517]                             "SOCK0node"))) {
[17:46:46.517]                             sendCondition <<- function(cond) {
[17:46:46.517]                               data <- list(type = "VALUE", value = cond, 
[17:46:46.517]                                 success = TRUE)
[17:46:46.517]                               parallel_sendData(master, data)
[17:46:46.517]                             }
[17:46:46.517]                             return(sendCondition)
[17:46:46.517]                           }
[17:46:46.517]                         }
[17:46:46.517]                         frame <- frame + 1L
[17:46:46.517]                         envir <- sys.frame(frame)
[17:46:46.517]                       }
[17:46:46.517]                     }
[17:46:46.517]                     sendCondition <<- function(cond) NULL
[17:46:46.517]                   }
[17:46:46.517]                 })
[17:46:46.517]                 withCallingHandlers({
[17:46:46.517]                   NULL
[17:46:46.517]                 }, immediateCondition = function(cond) {
[17:46:46.517]                   sendCondition <- ...future.makeSendCondition()
[17:46:46.517]                   sendCondition(cond)
[17:46:46.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.517]                   {
[17:46:46.517]                     inherits <- base::inherits
[17:46:46.517]                     invokeRestart <- base::invokeRestart
[17:46:46.517]                     is.null <- base::is.null
[17:46:46.517]                     muffled <- FALSE
[17:46:46.517]                     if (inherits(cond, "message")) {
[17:46:46.517]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.517]                       if (muffled) 
[17:46:46.517]                         invokeRestart("muffleMessage")
[17:46:46.517]                     }
[17:46:46.517]                     else if (inherits(cond, "warning")) {
[17:46:46.517]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.517]                       if (muffled) 
[17:46:46.517]                         invokeRestart("muffleWarning")
[17:46:46.517]                     }
[17:46:46.517]                     else if (inherits(cond, "condition")) {
[17:46:46.517]                       if (!is.null(pattern)) {
[17:46:46.517]                         computeRestarts <- base::computeRestarts
[17:46:46.517]                         grepl <- base::grepl
[17:46:46.517]                         restarts <- computeRestarts(cond)
[17:46:46.517]                         for (restart in restarts) {
[17:46:46.517]                           name <- restart$name
[17:46:46.517]                           if (is.null(name)) 
[17:46:46.517]                             next
[17:46:46.517]                           if (!grepl(pattern, name)) 
[17:46:46.517]                             next
[17:46:46.517]                           invokeRestart(restart)
[17:46:46.517]                           muffled <- TRUE
[17:46:46.517]                           break
[17:46:46.517]                         }
[17:46:46.517]                       }
[17:46:46.517]                     }
[17:46:46.517]                     invisible(muffled)
[17:46:46.517]                   }
[17:46:46.517]                   muffleCondition(cond)
[17:46:46.517]                 })
[17:46:46.517]             }))
[17:46:46.517]             future::FutureResult(value = ...future.value$value, 
[17:46:46.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.517]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.517]                     ...future.globalenv.names))
[17:46:46.517]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.517]         }, condition = base::local({
[17:46:46.517]             c <- base::c
[17:46:46.517]             inherits <- base::inherits
[17:46:46.517]             invokeRestart <- base::invokeRestart
[17:46:46.517]             length <- base::length
[17:46:46.517]             list <- base::list
[17:46:46.517]             seq.int <- base::seq.int
[17:46:46.517]             signalCondition <- base::signalCondition
[17:46:46.517]             sys.calls <- base::sys.calls
[17:46:46.517]             `[[` <- base::`[[`
[17:46:46.517]             `+` <- base::`+`
[17:46:46.517]             `<<-` <- base::`<<-`
[17:46:46.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.517]                   3L)]
[17:46:46.517]             }
[17:46:46.517]             function(cond) {
[17:46:46.517]                 is_error <- inherits(cond, "error")
[17:46:46.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.517]                   NULL)
[17:46:46.517]                 if (is_error) {
[17:46:46.517]                   sessionInformation <- function() {
[17:46:46.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.517]                       search = base::search(), system = base::Sys.info())
[17:46:46.517]                   }
[17:46:46.517]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.517]                     cond$call), session = sessionInformation(), 
[17:46:46.517]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.517]                   signalCondition(cond)
[17:46:46.517]                 }
[17:46:46.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.517]                 "immediateCondition"))) {
[17:46:46.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.517]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.517]                   if (TRUE && !signal) {
[17:46:46.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.517]                     {
[17:46:46.517]                       inherits <- base::inherits
[17:46:46.517]                       invokeRestart <- base::invokeRestart
[17:46:46.517]                       is.null <- base::is.null
[17:46:46.517]                       muffled <- FALSE
[17:46:46.517]                       if (inherits(cond, "message")) {
[17:46:46.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.517]                         if (muffled) 
[17:46:46.517]                           invokeRestart("muffleMessage")
[17:46:46.517]                       }
[17:46:46.517]                       else if (inherits(cond, "warning")) {
[17:46:46.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.517]                         if (muffled) 
[17:46:46.517]                           invokeRestart("muffleWarning")
[17:46:46.517]                       }
[17:46:46.517]                       else if (inherits(cond, "condition")) {
[17:46:46.517]                         if (!is.null(pattern)) {
[17:46:46.517]                           computeRestarts <- base::computeRestarts
[17:46:46.517]                           grepl <- base::grepl
[17:46:46.517]                           restarts <- computeRestarts(cond)
[17:46:46.517]                           for (restart in restarts) {
[17:46:46.517]                             name <- restart$name
[17:46:46.517]                             if (is.null(name)) 
[17:46:46.517]                               next
[17:46:46.517]                             if (!grepl(pattern, name)) 
[17:46:46.517]                               next
[17:46:46.517]                             invokeRestart(restart)
[17:46:46.517]                             muffled <- TRUE
[17:46:46.517]                             break
[17:46:46.517]                           }
[17:46:46.517]                         }
[17:46:46.517]                       }
[17:46:46.517]                       invisible(muffled)
[17:46:46.517]                     }
[17:46:46.517]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.517]                   }
[17:46:46.517]                 }
[17:46:46.517]                 else {
[17:46:46.517]                   if (TRUE) {
[17:46:46.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.517]                     {
[17:46:46.517]                       inherits <- base::inherits
[17:46:46.517]                       invokeRestart <- base::invokeRestart
[17:46:46.517]                       is.null <- base::is.null
[17:46:46.517]                       muffled <- FALSE
[17:46:46.517]                       if (inherits(cond, "message")) {
[17:46:46.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.517]                         if (muffled) 
[17:46:46.517]                           invokeRestart("muffleMessage")
[17:46:46.517]                       }
[17:46:46.517]                       else if (inherits(cond, "warning")) {
[17:46:46.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.517]                         if (muffled) 
[17:46:46.517]                           invokeRestart("muffleWarning")
[17:46:46.517]                       }
[17:46:46.517]                       else if (inherits(cond, "condition")) {
[17:46:46.517]                         if (!is.null(pattern)) {
[17:46:46.517]                           computeRestarts <- base::computeRestarts
[17:46:46.517]                           grepl <- base::grepl
[17:46:46.517]                           restarts <- computeRestarts(cond)
[17:46:46.517]                           for (restart in restarts) {
[17:46:46.517]                             name <- restart$name
[17:46:46.517]                             if (is.null(name)) 
[17:46:46.517]                               next
[17:46:46.517]                             if (!grepl(pattern, name)) 
[17:46:46.517]                               next
[17:46:46.517]                             invokeRestart(restart)
[17:46:46.517]                             muffled <- TRUE
[17:46:46.517]                             break
[17:46:46.517]                           }
[17:46:46.517]                         }
[17:46:46.517]                       }
[17:46:46.517]                       invisible(muffled)
[17:46:46.517]                     }
[17:46:46.517]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.517]                   }
[17:46:46.517]                 }
[17:46:46.517]             }
[17:46:46.517]         }))
[17:46:46.517]     }, error = function(ex) {
[17:46:46.517]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.517]                 ...future.rng), started = ...future.startTime, 
[17:46:46.517]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.517]             version = "1.8"), class = "FutureResult")
[17:46:46.517]     }, finally = {
[17:46:46.517]         if (!identical(...future.workdir, getwd())) 
[17:46:46.517]             setwd(...future.workdir)
[17:46:46.517]         {
[17:46:46.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.517]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.517]             }
[17:46:46.517]             base::options(...future.oldOptions)
[17:46:46.517]             if (.Platform$OS.type == "windows") {
[17:46:46.517]                 old_names <- names(...future.oldEnvVars)
[17:46:46.517]                 envs <- base::Sys.getenv()
[17:46:46.517]                 names <- names(envs)
[17:46:46.517]                 common <- intersect(names, old_names)
[17:46:46.517]                 added <- setdiff(names, old_names)
[17:46:46.517]                 removed <- setdiff(old_names, names)
[17:46:46.517]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.517]                   envs[common]]
[17:46:46.517]                 NAMES <- toupper(changed)
[17:46:46.517]                 args <- list()
[17:46:46.517]                 for (kk in seq_along(NAMES)) {
[17:46:46.517]                   name <- changed[[kk]]
[17:46:46.517]                   NAME <- NAMES[[kk]]
[17:46:46.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.517]                     next
[17:46:46.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.517]                 }
[17:46:46.517]                 NAMES <- toupper(added)
[17:46:46.517]                 for (kk in seq_along(NAMES)) {
[17:46:46.517]                   name <- added[[kk]]
[17:46:46.517]                   NAME <- NAMES[[kk]]
[17:46:46.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.517]                     next
[17:46:46.517]                   args[[name]] <- ""
[17:46:46.517]                 }
[17:46:46.517]                 NAMES <- toupper(removed)
[17:46:46.517]                 for (kk in seq_along(NAMES)) {
[17:46:46.517]                   name <- removed[[kk]]
[17:46:46.517]                   NAME <- NAMES[[kk]]
[17:46:46.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.517]                     next
[17:46:46.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.517]                 }
[17:46:46.517]                 if (length(args) > 0) 
[17:46:46.517]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.517]             }
[17:46:46.517]             else {
[17:46:46.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.517]             }
[17:46:46.517]             {
[17:46:46.517]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.517]                   0L) {
[17:46:46.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.517]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.517]                   base::options(opts)
[17:46:46.517]                 }
[17:46:46.517]                 {
[17:46:46.517]                   {
[17:46:46.517]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.517]                     NULL
[17:46:46.517]                   }
[17:46:46.517]                   options(future.plan = NULL)
[17:46:46.517]                   if (is.na(NA_character_)) 
[17:46:46.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.517]                     .init = FALSE)
[17:46:46.517]                 }
[17:46:46.517]             }
[17:46:46.517]         }
[17:46:46.517]     })
[17:46:46.517]     if (TRUE) {
[17:46:46.517]         base::sink(type = "output", split = FALSE)
[17:46:46.517]         if (TRUE) {
[17:46:46.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.517]         }
[17:46:46.517]         else {
[17:46:46.517]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.517]         }
[17:46:46.517]         base::close(...future.stdout)
[17:46:46.517]         ...future.stdout <- NULL
[17:46:46.517]     }
[17:46:46.517]     ...future.result$conditions <- ...future.conditions
[17:46:46.517]     ...future.result$finished <- base::Sys.time()
[17:46:46.517]     ...future.result
[17:46:46.517] }
[17:46:46.520] MultisessionFuture started
[17:46:46.520] - Launch lazy future ... done
[17:46:46.520] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561789c1a328> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617882f0368> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561789c1a328> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5617882f0368> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:46.526] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.526] - Validating connection of MultisessionFuture
[17:46:46.526] - received message: FutureResult
[17:46:46.526] - Received FutureResult
[17:46:46.526] - Erased future from FutureRegistry
[17:46:46.526] result() for ClusterFuture ...
[17:46:46.526] - result already collected: FutureResult
[17:46:46.526] result() for ClusterFuture ... done
[17:46:46.527] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:46.527] receiveMessageFromWorker() for ClusterFuture ...
[17:46:46.527] - Validating connection of MultisessionFuture
[17:46:46.527] - received message: FutureResult
[17:46:46.527] - Received FutureResult
[17:46:46.527] - Erased future from FutureRegistry
[17:46:46.528] result() for ClusterFuture ...
[17:46:46.528] - result already collected: FutureResult
[17:46:46.528] result() for ClusterFuture ... done
[17:46:46.528] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:46:46.530] resolve() on list ...
[17:46:46.530]  recursive: 0
[17:46:46.530]  length: 6
[17:46:46.530]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:46:46.530] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.530] - nx: 6
[17:46:46.530] - relay: TRUE
[17:46:46.530] - stdout: TRUE
[17:46:46.530] - signal: TRUE
[17:46:46.531] - resignal: FALSE
[17:46:46.531] - force: TRUE
[17:46:46.531] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.531] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.531]  - until=2
[17:46:46.531]  - relaying element #2
[17:46:46.531] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.531] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.531] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.531]  length: 5 (resolved future 1)
[17:46:46.531] Future #2
[17:46:46.532] result() for ClusterFuture ...
[17:46:46.532] - result already collected: FutureResult
[17:46:46.532] result() for ClusterFuture ... done
[17:46:46.532] result() for ClusterFuture ...
[17:46:46.532] - result already collected: FutureResult
[17:46:46.532] result() for ClusterFuture ... done
[17:46:46.532] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:46.532] - nx: 6
[17:46:46.532] - relay: TRUE
[17:46:46.532] - stdout: TRUE
[17:46:46.532] - signal: TRUE
[17:46:46.533] - resignal: FALSE
[17:46:46.533] - force: TRUE
[17:46:46.533] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.533] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:46.533]  - until=2
[17:46:46.533]  - relaying element #2
[17:46:46.533] result() for ClusterFuture ...
[17:46:46.533] - result already collected: FutureResult
[17:46:46.533] result() for ClusterFuture ... done
[17:46:46.533] result() for ClusterFuture ...
[17:46:46.533] - result already collected: FutureResult
[17:46:46.533] result() for ClusterFuture ... done
[17:46:46.534] result() for ClusterFuture ...
[17:46:46.534] - result already collected: FutureResult
[17:46:46.534] result() for ClusterFuture ... done
[17:46:46.534] result() for ClusterFuture ...
[17:46:46.534] - result already collected: FutureResult
[17:46:46.534] result() for ClusterFuture ... done
[17:46:46.534] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.534] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.534] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:46.534]  length: 4 (resolved future 2)
[17:46:46.534] Future #3
[17:46:46.535] result() for ClusterFuture ...
[17:46:46.535] - result already collected: FutureResult
[17:46:46.535] result() for ClusterFuture ... done
[17:46:46.535] result() for ClusterFuture ...
[17:46:46.535] - result already collected: FutureResult
[17:46:46.535] result() for ClusterFuture ... done
[17:46:46.535] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:46.535] - nx: 6
[17:46:46.535] - relay: TRUE
[17:46:46.535] - stdout: TRUE
[17:46:46.535] - signal: TRUE
[17:46:46.536] - resignal: FALSE
[17:46:46.536] - force: TRUE
[17:46:46.536] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.536] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:46.536]  - until=3
[17:46:46.536]  - relaying element #3
[17:46:46.536] result() for ClusterFuture ...
[17:46:46.536] - result already collected: FutureResult
[17:46:46.536] result() for ClusterFuture ... done
[17:46:46.536] result() for ClusterFuture ...
[17:46:46.536] - result already collected: FutureResult
[17:46:46.536] result() for ClusterFuture ... done
[17:46:46.537] result() for ClusterFuture ...
[17:46:46.537] - result already collected: FutureResult
[17:46:46.537] result() for ClusterFuture ... done
[17:46:46.537] result() for ClusterFuture ...
[17:46:46.537] - result already collected: FutureResult
[17:46:46.537] result() for ClusterFuture ... done
[17:46:46.537] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.537] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.537] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:46.537]  length: 3 (resolved future 3)
[17:46:46.538] signalConditionsASAP(NULL, pos=4) ...
[17:46:46.538] - nx: 6
[17:46:46.538] - relay: TRUE
[17:46:46.538] - stdout: TRUE
[17:46:46.538] - signal: TRUE
[17:46:46.538] - resignal: FALSE
[17:46:46.538] - force: TRUE
[17:46:46.538] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.538] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.538]  - until=5
[17:46:46.538]  - relaying element #5
[17:46:46.538] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.538] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.539] signalConditionsASAP(NULL, pos=4) ... done
[17:46:46.539]  length: 2 (resolved future 4)
[17:46:46.539] signalConditionsASAP(NULL, pos=5) ...
[17:46:46.539] - nx: 6
[17:46:46.539] - relay: TRUE
[17:46:46.539] - stdout: TRUE
[17:46:46.539] - signal: TRUE
[17:46:46.539] - resignal: FALSE
[17:46:46.539] - force: TRUE
[17:46:46.539] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:46.539] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.540]  - until=6
[17:46:46.540]  - relaying element #6
[17:46:46.540] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.540] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.540] signalConditionsASAP(NULL, pos=5) ... done
[17:46:46.540]  length: 1 (resolved future 5)
[17:46:46.540] signalConditionsASAP(numeric, pos=6) ...
[17:46:46.540] - nx: 6
[17:46:46.540] - relay: TRUE
[17:46:46.540] - stdout: TRUE
[17:46:46.540] - signal: TRUE
[17:46:46.540] - resignal: FALSE
[17:46:46.541] - force: TRUE
[17:46:46.541] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:46.541] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.541]  - until=6
[17:46:46.541] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.541] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.541] signalConditionsASAP(numeric, pos=6) ... done
[17:46:46.541]  length: 0 (resolved future 6)
[17:46:46.541] Relaying remaining futures
[17:46:46.541] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.541] - nx: 6
[17:46:46.542] - relay: TRUE
[17:46:46.542] - stdout: TRUE
[17:46:46.542] - signal: TRUE
[17:46:46.542] - resignal: FALSE
[17:46:46.542] - force: TRUE
[17:46:46.542] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.542] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:46:46.542] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:46.542] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:46.542] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.542] resolve() on list ... DONE
[17:46:46.542] result() for ClusterFuture ...
[17:46:46.543] - result already collected: FutureResult
[17:46:46.543] result() for ClusterFuture ... done
[17:46:46.543] result() for ClusterFuture ...
[17:46:46.543] - result already collected: FutureResult
[17:46:46.543] result() for ClusterFuture ... done
[17:46:46.543] result() for ClusterFuture ...
[17:46:46.543] - result already collected: FutureResult
[17:46:46.543] result() for ClusterFuture ... done
[17:46:46.543] result() for ClusterFuture ...
[17:46:46.543] - result already collected: FutureResult
[17:46:46.544] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[17:46:46.548] plan(): Setting new future strategy stack:
[17:46:46.548] List of future strategies:
[17:46:46.548] 1. multicore:
[17:46:46.548]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.548]    - tweaked: FALSE
[17:46:46.548]    - call: plan(strategy)
[17:46:46.553] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:46:46.553] getGlobalsAndPackages() ...
[17:46:46.553] Searching for globals...
[17:46:46.554] 
[17:46:46.554] Searching for globals ... DONE
[17:46:46.554] - globals: [0] <none>
[17:46:46.554] getGlobalsAndPackages() ... DONE
[17:46:46.555] run() for ‘Future’ ...
[17:46:46.555] - state: ‘created’
[17:46:46.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.560] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.560] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.560]   - Field: ‘label’
[17:46:46.560]   - Field: ‘local’
[17:46:46.560]   - Field: ‘owner’
[17:46:46.560]   - Field: ‘envir’
[17:46:46.560]   - Field: ‘workers’
[17:46:46.560]   - Field: ‘packages’
[17:46:46.560]   - Field: ‘gc’
[17:46:46.561]   - Field: ‘job’
[17:46:46.561]   - Field: ‘conditions’
[17:46:46.561]   - Field: ‘expr’
[17:46:46.561]   - Field: ‘uuid’
[17:46:46.561]   - Field: ‘seed’
[17:46:46.561]   - Field: ‘version’
[17:46:46.561]   - Field: ‘result’
[17:46:46.561]   - Field: ‘asynchronous’
[17:46:46.561]   - Field: ‘calls’
[17:46:46.561]   - Field: ‘globals’
[17:46:46.561]   - Field: ‘stdout’
[17:46:46.562]   - Field: ‘earlySignal’
[17:46:46.562]   - Field: ‘lazy’
[17:46:46.562]   - Field: ‘state’
[17:46:46.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.562] - Launch lazy future ...
[17:46:46.562] Packages needed by the future expression (n = 0): <none>
[17:46:46.562] Packages needed by future strategies (n = 0): <none>
[17:46:46.563] {
[17:46:46.563]     {
[17:46:46.563]         {
[17:46:46.563]             ...future.startTime <- base::Sys.time()
[17:46:46.563]             {
[17:46:46.563]                 {
[17:46:46.563]                   {
[17:46:46.563]                     {
[17:46:46.563]                       base::local({
[17:46:46.563]                         has_future <- base::requireNamespace("future", 
[17:46:46.563]                           quietly = TRUE)
[17:46:46.563]                         if (has_future) {
[17:46:46.563]                           ns <- base::getNamespace("future")
[17:46:46.563]                           version <- ns[[".package"]][["version"]]
[17:46:46.563]                           if (is.null(version)) 
[17:46:46.563]                             version <- utils::packageVersion("future")
[17:46:46.563]                         }
[17:46:46.563]                         else {
[17:46:46.563]                           version <- NULL
[17:46:46.563]                         }
[17:46:46.563]                         if (!has_future || version < "1.8.0") {
[17:46:46.563]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.563]                             "", base::R.version$version.string), 
[17:46:46.563]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.563]                               "release", "version")], collapse = " "), 
[17:46:46.563]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.563]                             info)
[17:46:46.563]                           info <- base::paste(info, collapse = "; ")
[17:46:46.563]                           if (!has_future) {
[17:46:46.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.563]                               info)
[17:46:46.563]                           }
[17:46:46.563]                           else {
[17:46:46.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.563]                               info, version)
[17:46:46.563]                           }
[17:46:46.563]                           base::stop(msg)
[17:46:46.563]                         }
[17:46:46.563]                       })
[17:46:46.563]                     }
[17:46:46.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.563]                     base::options(mc.cores = 1L)
[17:46:46.563]                   }
[17:46:46.563]                   ...future.strategy.old <- future::plan("list")
[17:46:46.563]                   options(future.plan = NULL)
[17:46:46.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.563]                 }
[17:46:46.563]                 ...future.workdir <- getwd()
[17:46:46.563]             }
[17:46:46.563]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.563]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.563]         }
[17:46:46.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.563]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.563]             base::names(...future.oldOptions))
[17:46:46.563]     }
[17:46:46.563]     if (FALSE) {
[17:46:46.563]     }
[17:46:46.563]     else {
[17:46:46.563]         if (TRUE) {
[17:46:46.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.563]                 open = "w")
[17:46:46.563]         }
[17:46:46.563]         else {
[17:46:46.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.563]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.563]         }
[17:46:46.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.563]             base::sink(type = "output", split = FALSE)
[17:46:46.563]             base::close(...future.stdout)
[17:46:46.563]         }, add = TRUE)
[17:46:46.563]     }
[17:46:46.563]     ...future.frame <- base::sys.nframe()
[17:46:46.563]     ...future.conditions <- base::list()
[17:46:46.563]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.563]     if (FALSE) {
[17:46:46.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.563]     }
[17:46:46.563]     ...future.result <- base::tryCatch({
[17:46:46.563]         base::withCallingHandlers({
[17:46:46.563]             ...future.value <- base::withVisible(base::local({
[17:46:46.563]                 withCallingHandlers({
[17:46:46.563]                   2
[17:46:46.563]                 }, immediateCondition = function(cond) {
[17:46:46.563]                   save_rds <- function (object, pathname, ...) 
[17:46:46.563]                   {
[17:46:46.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.563]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.563]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.563]                         fi_tmp[["mtime"]])
[17:46:46.563]                     }
[17:46:46.563]                     tryCatch({
[17:46:46.563]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.563]                     }, error = function(ex) {
[17:46:46.563]                       msg <- conditionMessage(ex)
[17:46:46.563]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.563]                         fi_tmp[["mtime"]], msg)
[17:46:46.563]                       ex$message <- msg
[17:46:46.563]                       stop(ex)
[17:46:46.563]                     })
[17:46:46.563]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.563]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.563]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.563]                       fi <- file.info(pathname)
[17:46:46.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.563]                         fi[["size"]], fi[["mtime"]])
[17:46:46.563]                       stop(msg)
[17:46:46.563]                     }
[17:46:46.563]                     invisible(pathname)
[17:46:46.563]                   }
[17:46:46.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.563]                     rootPath = tempdir()) 
[17:46:46.563]                   {
[17:46:46.563]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.563]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.563]                       tmpdir = path, fileext = ".rds")
[17:46:46.563]                     save_rds(obj, file)
[17:46:46.563]                   }
[17:46:46.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.563]                   {
[17:46:46.563]                     inherits <- base::inherits
[17:46:46.563]                     invokeRestart <- base::invokeRestart
[17:46:46.563]                     is.null <- base::is.null
[17:46:46.563]                     muffled <- FALSE
[17:46:46.563]                     if (inherits(cond, "message")) {
[17:46:46.563]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.563]                       if (muffled) 
[17:46:46.563]                         invokeRestart("muffleMessage")
[17:46:46.563]                     }
[17:46:46.563]                     else if (inherits(cond, "warning")) {
[17:46:46.563]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.563]                       if (muffled) 
[17:46:46.563]                         invokeRestart("muffleWarning")
[17:46:46.563]                     }
[17:46:46.563]                     else if (inherits(cond, "condition")) {
[17:46:46.563]                       if (!is.null(pattern)) {
[17:46:46.563]                         computeRestarts <- base::computeRestarts
[17:46:46.563]                         grepl <- base::grepl
[17:46:46.563]                         restarts <- computeRestarts(cond)
[17:46:46.563]                         for (restart in restarts) {
[17:46:46.563]                           name <- restart$name
[17:46:46.563]                           if (is.null(name)) 
[17:46:46.563]                             next
[17:46:46.563]                           if (!grepl(pattern, name)) 
[17:46:46.563]                             next
[17:46:46.563]                           invokeRestart(restart)
[17:46:46.563]                           muffled <- TRUE
[17:46:46.563]                           break
[17:46:46.563]                         }
[17:46:46.563]                       }
[17:46:46.563]                     }
[17:46:46.563]                     invisible(muffled)
[17:46:46.563]                   }
[17:46:46.563]                   muffleCondition(cond)
[17:46:46.563]                 })
[17:46:46.563]             }))
[17:46:46.563]             future::FutureResult(value = ...future.value$value, 
[17:46:46.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.563]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.563]                     ...future.globalenv.names))
[17:46:46.563]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.563]         }, condition = base::local({
[17:46:46.563]             c <- base::c
[17:46:46.563]             inherits <- base::inherits
[17:46:46.563]             invokeRestart <- base::invokeRestart
[17:46:46.563]             length <- base::length
[17:46:46.563]             list <- base::list
[17:46:46.563]             seq.int <- base::seq.int
[17:46:46.563]             signalCondition <- base::signalCondition
[17:46:46.563]             sys.calls <- base::sys.calls
[17:46:46.563]             `[[` <- base::`[[`
[17:46:46.563]             `+` <- base::`+`
[17:46:46.563]             `<<-` <- base::`<<-`
[17:46:46.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.563]                   3L)]
[17:46:46.563]             }
[17:46:46.563]             function(cond) {
[17:46:46.563]                 is_error <- inherits(cond, "error")
[17:46:46.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.563]                   NULL)
[17:46:46.563]                 if (is_error) {
[17:46:46.563]                   sessionInformation <- function() {
[17:46:46.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.563]                       search = base::search(), system = base::Sys.info())
[17:46:46.563]                   }
[17:46:46.563]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.563]                     cond$call), session = sessionInformation(), 
[17:46:46.563]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.563]                   signalCondition(cond)
[17:46:46.563]                 }
[17:46:46.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.563]                 "immediateCondition"))) {
[17:46:46.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.563]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.563]                   if (TRUE && !signal) {
[17:46:46.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.563]                     {
[17:46:46.563]                       inherits <- base::inherits
[17:46:46.563]                       invokeRestart <- base::invokeRestart
[17:46:46.563]                       is.null <- base::is.null
[17:46:46.563]                       muffled <- FALSE
[17:46:46.563]                       if (inherits(cond, "message")) {
[17:46:46.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.563]                         if (muffled) 
[17:46:46.563]                           invokeRestart("muffleMessage")
[17:46:46.563]                       }
[17:46:46.563]                       else if (inherits(cond, "warning")) {
[17:46:46.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.563]                         if (muffled) 
[17:46:46.563]                           invokeRestart("muffleWarning")
[17:46:46.563]                       }
[17:46:46.563]                       else if (inherits(cond, "condition")) {
[17:46:46.563]                         if (!is.null(pattern)) {
[17:46:46.563]                           computeRestarts <- base::computeRestarts
[17:46:46.563]                           grepl <- base::grepl
[17:46:46.563]                           restarts <- computeRestarts(cond)
[17:46:46.563]                           for (restart in restarts) {
[17:46:46.563]                             name <- restart$name
[17:46:46.563]                             if (is.null(name)) 
[17:46:46.563]                               next
[17:46:46.563]                             if (!grepl(pattern, name)) 
[17:46:46.563]                               next
[17:46:46.563]                             invokeRestart(restart)
[17:46:46.563]                             muffled <- TRUE
[17:46:46.563]                             break
[17:46:46.563]                           }
[17:46:46.563]                         }
[17:46:46.563]                       }
[17:46:46.563]                       invisible(muffled)
[17:46:46.563]                     }
[17:46:46.563]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.563]                   }
[17:46:46.563]                 }
[17:46:46.563]                 else {
[17:46:46.563]                   if (TRUE) {
[17:46:46.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.563]                     {
[17:46:46.563]                       inherits <- base::inherits
[17:46:46.563]                       invokeRestart <- base::invokeRestart
[17:46:46.563]                       is.null <- base::is.null
[17:46:46.563]                       muffled <- FALSE
[17:46:46.563]                       if (inherits(cond, "message")) {
[17:46:46.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.563]                         if (muffled) 
[17:46:46.563]                           invokeRestart("muffleMessage")
[17:46:46.563]                       }
[17:46:46.563]                       else if (inherits(cond, "warning")) {
[17:46:46.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.563]                         if (muffled) 
[17:46:46.563]                           invokeRestart("muffleWarning")
[17:46:46.563]                       }
[17:46:46.563]                       else if (inherits(cond, "condition")) {
[17:46:46.563]                         if (!is.null(pattern)) {
[17:46:46.563]                           computeRestarts <- base::computeRestarts
[17:46:46.563]                           grepl <- base::grepl
[17:46:46.563]                           restarts <- computeRestarts(cond)
[17:46:46.563]                           for (restart in restarts) {
[17:46:46.563]                             name <- restart$name
[17:46:46.563]                             if (is.null(name)) 
[17:46:46.563]                               next
[17:46:46.563]                             if (!grepl(pattern, name)) 
[17:46:46.563]                               next
[17:46:46.563]                             invokeRestart(restart)
[17:46:46.563]                             muffled <- TRUE
[17:46:46.563]                             break
[17:46:46.563]                           }
[17:46:46.563]                         }
[17:46:46.563]                       }
[17:46:46.563]                       invisible(muffled)
[17:46:46.563]                     }
[17:46:46.563]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.563]                   }
[17:46:46.563]                 }
[17:46:46.563]             }
[17:46:46.563]         }))
[17:46:46.563]     }, error = function(ex) {
[17:46:46.563]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.563]                 ...future.rng), started = ...future.startTime, 
[17:46:46.563]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.563]             version = "1.8"), class = "FutureResult")
[17:46:46.563]     }, finally = {
[17:46:46.563]         if (!identical(...future.workdir, getwd())) 
[17:46:46.563]             setwd(...future.workdir)
[17:46:46.563]         {
[17:46:46.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.563]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.563]             }
[17:46:46.563]             base::options(...future.oldOptions)
[17:46:46.563]             if (.Platform$OS.type == "windows") {
[17:46:46.563]                 old_names <- names(...future.oldEnvVars)
[17:46:46.563]                 envs <- base::Sys.getenv()
[17:46:46.563]                 names <- names(envs)
[17:46:46.563]                 common <- intersect(names, old_names)
[17:46:46.563]                 added <- setdiff(names, old_names)
[17:46:46.563]                 removed <- setdiff(old_names, names)
[17:46:46.563]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.563]                   envs[common]]
[17:46:46.563]                 NAMES <- toupper(changed)
[17:46:46.563]                 args <- list()
[17:46:46.563]                 for (kk in seq_along(NAMES)) {
[17:46:46.563]                   name <- changed[[kk]]
[17:46:46.563]                   NAME <- NAMES[[kk]]
[17:46:46.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.563]                     next
[17:46:46.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.563]                 }
[17:46:46.563]                 NAMES <- toupper(added)
[17:46:46.563]                 for (kk in seq_along(NAMES)) {
[17:46:46.563]                   name <- added[[kk]]
[17:46:46.563]                   NAME <- NAMES[[kk]]
[17:46:46.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.563]                     next
[17:46:46.563]                   args[[name]] <- ""
[17:46:46.563]                 }
[17:46:46.563]                 NAMES <- toupper(removed)
[17:46:46.563]                 for (kk in seq_along(NAMES)) {
[17:46:46.563]                   name <- removed[[kk]]
[17:46:46.563]                   NAME <- NAMES[[kk]]
[17:46:46.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.563]                     next
[17:46:46.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.563]                 }
[17:46:46.563]                 if (length(args) > 0) 
[17:46:46.563]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.563]             }
[17:46:46.563]             else {
[17:46:46.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.563]             }
[17:46:46.563]             {
[17:46:46.563]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.563]                   0L) {
[17:46:46.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.563]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.563]                   base::options(opts)
[17:46:46.563]                 }
[17:46:46.563]                 {
[17:46:46.563]                   {
[17:46:46.563]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.563]                     NULL
[17:46:46.563]                   }
[17:46:46.563]                   options(future.plan = NULL)
[17:46:46.563]                   if (is.na(NA_character_)) 
[17:46:46.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.563]                     .init = FALSE)
[17:46:46.563]                 }
[17:46:46.563]             }
[17:46:46.563]         }
[17:46:46.563]     })
[17:46:46.563]     if (TRUE) {
[17:46:46.563]         base::sink(type = "output", split = FALSE)
[17:46:46.563]         if (TRUE) {
[17:46:46.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.563]         }
[17:46:46.563]         else {
[17:46:46.563]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.563]         }
[17:46:46.563]         base::close(...future.stdout)
[17:46:46.563]         ...future.stdout <- NULL
[17:46:46.563]     }
[17:46:46.563]     ...future.result$conditions <- ...future.conditions
[17:46:46.563]     ...future.result$finished <- base::Sys.time()
[17:46:46.563]     ...future.result
[17:46:46.563] }
[17:46:46.565] requestCore(): workers = 2
[17:46:46.568] MulticoreFuture started
[17:46:46.568] - Launch lazy future ... done
[17:46:46.568] run() for ‘MulticoreFuture’ ... done
[17:46:46.569] getGlobalsAndPackages() ...
[17:46:46.569] Searching for globals...
[17:46:46.569] plan(): Setting new future strategy stack:
[17:46:46.570] 
[17:46:46.570] Searching for globals ... DONE
[17:46:46.570] - globals: [0] <none>
[17:46:46.570] getGlobalsAndPackages() ... DONE
[17:46:46.570] List of future strategies:
[17:46:46.570] 1. sequential:
[17:46:46.570]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.570]    - tweaked: FALSE
[17:46:46.570]    - call: NULL
[17:46:46.571] plan(): nbrOfWorkers() = 1
[17:46:46.571] run() for ‘Future’ ...
[17:46:46.571] - state: ‘created’
[17:46:46.571] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.573] plan(): Setting new future strategy stack:
[17:46:46.573] List of future strategies:
[17:46:46.573] 1. multicore:
[17:46:46.573]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.573]    - tweaked: FALSE
[17:46:46.573]    - call: plan(strategy)
[17:46:46.577] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.577] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.577]   - Field: ‘label’
[17:46:46.577] plan(): nbrOfWorkers() = 2
[17:46:46.577]   - Field: ‘local’
[17:46:46.578]   - Field: ‘owner’
[17:46:46.578]   - Field: ‘envir’
[17:46:46.578]   - Field: ‘workers’
[17:46:46.578]   - Field: ‘packages’
[17:46:46.578]   - Field: ‘gc’
[17:46:46.578]   - Field: ‘job’
[17:46:46.578]   - Field: ‘conditions’
[17:46:46.578]   - Field: ‘expr’
[17:46:46.579]   - Field: ‘uuid’
[17:46:46.579]   - Field: ‘seed’
[17:46:46.579]   - Field: ‘version’
[17:46:46.579]   - Field: ‘result’
[17:46:46.579]   - Field: ‘asynchronous’
[17:46:46.579]   - Field: ‘calls’
[17:46:46.579]   - Field: ‘globals’
[17:46:46.580]   - Field: ‘stdout’
[17:46:46.580]   - Field: ‘earlySignal’
[17:46:46.580]   - Field: ‘lazy’
[17:46:46.580]   - Field: ‘state’
[17:46:46.580] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.580] - Launch lazy future ...
[17:46:46.581] Packages needed by the future expression (n = 0): <none>
[17:46:46.581] Packages needed by future strategies (n = 0): <none>
[17:46:46.582] {
[17:46:46.582]     {
[17:46:46.582]         {
[17:46:46.582]             ...future.startTime <- base::Sys.time()
[17:46:46.582]             {
[17:46:46.582]                 {
[17:46:46.582]                   {
[17:46:46.582]                     {
[17:46:46.582]                       base::local({
[17:46:46.582]                         has_future <- base::requireNamespace("future", 
[17:46:46.582]                           quietly = TRUE)
[17:46:46.582]                         if (has_future) {
[17:46:46.582]                           ns <- base::getNamespace("future")
[17:46:46.582]                           version <- ns[[".package"]][["version"]]
[17:46:46.582]                           if (is.null(version)) 
[17:46:46.582]                             version <- utils::packageVersion("future")
[17:46:46.582]                         }
[17:46:46.582]                         else {
[17:46:46.582]                           version <- NULL
[17:46:46.582]                         }
[17:46:46.582]                         if (!has_future || version < "1.8.0") {
[17:46:46.582]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.582]                             "", base::R.version$version.string), 
[17:46:46.582]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.582]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.582]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.582]                               "release", "version")], collapse = " "), 
[17:46:46.582]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.582]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.582]                             info)
[17:46:46.582]                           info <- base::paste(info, collapse = "; ")
[17:46:46.582]                           if (!has_future) {
[17:46:46.582]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.582]                               info)
[17:46:46.582]                           }
[17:46:46.582]                           else {
[17:46:46.582]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.582]                               info, version)
[17:46:46.582]                           }
[17:46:46.582]                           base::stop(msg)
[17:46:46.582]                         }
[17:46:46.582]                       })
[17:46:46.582]                     }
[17:46:46.582]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.582]                     base::options(mc.cores = 1L)
[17:46:46.582]                   }
[17:46:46.582]                   ...future.strategy.old <- future::plan("list")
[17:46:46.582]                   options(future.plan = NULL)
[17:46:46.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.582]                 }
[17:46:46.582]                 ...future.workdir <- getwd()
[17:46:46.582]             }
[17:46:46.582]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.582]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.582]         }
[17:46:46.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.582]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.582]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.582]             base::names(...future.oldOptions))
[17:46:46.582]     }
[17:46:46.582]     if (FALSE) {
[17:46:46.582]     }
[17:46:46.582]     else {
[17:46:46.582]         if (TRUE) {
[17:46:46.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.582]                 open = "w")
[17:46:46.582]         }
[17:46:46.582]         else {
[17:46:46.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.582]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.582]         }
[17:46:46.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.582]             base::sink(type = "output", split = FALSE)
[17:46:46.582]             base::close(...future.stdout)
[17:46:46.582]         }, add = TRUE)
[17:46:46.582]     }
[17:46:46.582]     ...future.frame <- base::sys.nframe()
[17:46:46.582]     ...future.conditions <- base::list()
[17:46:46.582]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.582]     if (FALSE) {
[17:46:46.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.582]     }
[17:46:46.582]     ...future.result <- base::tryCatch({
[17:46:46.582]         base::withCallingHandlers({
[17:46:46.582]             ...future.value <- base::withVisible(base::local({
[17:46:46.582]                 withCallingHandlers({
[17:46:46.582]                   NULL
[17:46:46.582]                 }, immediateCondition = function(cond) {
[17:46:46.582]                   save_rds <- function (object, pathname, ...) 
[17:46:46.582]                   {
[17:46:46.582]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.582]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.582]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.582]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.582]                         fi_tmp[["mtime"]])
[17:46:46.582]                     }
[17:46:46.582]                     tryCatch({
[17:46:46.582]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.582]                     }, error = function(ex) {
[17:46:46.582]                       msg <- conditionMessage(ex)
[17:46:46.582]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.582]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.582]                         fi_tmp[["mtime"]], msg)
[17:46:46.582]                       ex$message <- msg
[17:46:46.582]                       stop(ex)
[17:46:46.582]                     })
[17:46:46.582]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.582]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.582]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.582]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.582]                       fi <- file.info(pathname)
[17:46:46.582]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.582]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.582]                         fi[["size"]], fi[["mtime"]])
[17:46:46.582]                       stop(msg)
[17:46:46.582]                     }
[17:46:46.582]                     invisible(pathname)
[17:46:46.582]                   }
[17:46:46.582]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.582]                     rootPath = tempdir()) 
[17:46:46.582]                   {
[17:46:46.582]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.582]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.582]                       tmpdir = path, fileext = ".rds")
[17:46:46.582]                     save_rds(obj, file)
[17:46:46.582]                   }
[17:46:46.582]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.582]                   {
[17:46:46.582]                     inherits <- base::inherits
[17:46:46.582]                     invokeRestart <- base::invokeRestart
[17:46:46.582]                     is.null <- base::is.null
[17:46:46.582]                     muffled <- FALSE
[17:46:46.582]                     if (inherits(cond, "message")) {
[17:46:46.582]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.582]                       if (muffled) 
[17:46:46.582]                         invokeRestart("muffleMessage")
[17:46:46.582]                     }
[17:46:46.582]                     else if (inherits(cond, "warning")) {
[17:46:46.582]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.582]                       if (muffled) 
[17:46:46.582]                         invokeRestart("muffleWarning")
[17:46:46.582]                     }
[17:46:46.582]                     else if (inherits(cond, "condition")) {
[17:46:46.582]                       if (!is.null(pattern)) {
[17:46:46.582]                         computeRestarts <- base::computeRestarts
[17:46:46.582]                         grepl <- base::grepl
[17:46:46.582]                         restarts <- computeRestarts(cond)
[17:46:46.582]                         for (restart in restarts) {
[17:46:46.582]                           name <- restart$name
[17:46:46.582]                           if (is.null(name)) 
[17:46:46.582]                             next
[17:46:46.582]                           if (!grepl(pattern, name)) 
[17:46:46.582]                             next
[17:46:46.582]                           invokeRestart(restart)
[17:46:46.582]                           muffled <- TRUE
[17:46:46.582]                           break
[17:46:46.582]                         }
[17:46:46.582]                       }
[17:46:46.582]                     }
[17:46:46.582]                     invisible(muffled)
[17:46:46.582]                   }
[17:46:46.582]                   muffleCondition(cond)
[17:46:46.582]                 })
[17:46:46.582]             }))
[17:46:46.582]             future::FutureResult(value = ...future.value$value, 
[17:46:46.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.582]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.582]                     ...future.globalenv.names))
[17:46:46.582]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.582]         }, condition = base::local({
[17:46:46.582]             c <- base::c
[17:46:46.582]             inherits <- base::inherits
[17:46:46.582]             invokeRestart <- base::invokeRestart
[17:46:46.582]             length <- base::length
[17:46:46.582]             list <- base::list
[17:46:46.582]             seq.int <- base::seq.int
[17:46:46.582]             signalCondition <- base::signalCondition
[17:46:46.582]             sys.calls <- base::sys.calls
[17:46:46.582]             `[[` <- base::`[[`
[17:46:46.582]             `+` <- base::`+`
[17:46:46.582]             `<<-` <- base::`<<-`
[17:46:46.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.582]                   3L)]
[17:46:46.582]             }
[17:46:46.582]             function(cond) {
[17:46:46.582]                 is_error <- inherits(cond, "error")
[17:46:46.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.582]                   NULL)
[17:46:46.582]                 if (is_error) {
[17:46:46.582]                   sessionInformation <- function() {
[17:46:46.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.582]                       search = base::search(), system = base::Sys.info())
[17:46:46.582]                   }
[17:46:46.582]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.582]                     cond$call), session = sessionInformation(), 
[17:46:46.582]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.582]                   signalCondition(cond)
[17:46:46.582]                 }
[17:46:46.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.582]                 "immediateCondition"))) {
[17:46:46.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.582]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.582]                   if (TRUE && !signal) {
[17:46:46.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.582]                     {
[17:46:46.582]                       inherits <- base::inherits
[17:46:46.582]                       invokeRestart <- base::invokeRestart
[17:46:46.582]                       is.null <- base::is.null
[17:46:46.582]                       muffled <- FALSE
[17:46:46.582]                       if (inherits(cond, "message")) {
[17:46:46.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.582]                         if (muffled) 
[17:46:46.582]                           invokeRestart("muffleMessage")
[17:46:46.582]                       }
[17:46:46.582]                       else if (inherits(cond, "warning")) {
[17:46:46.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.582]                         if (muffled) 
[17:46:46.582]                           invokeRestart("muffleWarning")
[17:46:46.582]                       }
[17:46:46.582]                       else if (inherits(cond, "condition")) {
[17:46:46.582]                         if (!is.null(pattern)) {
[17:46:46.582]                           computeRestarts <- base::computeRestarts
[17:46:46.582]                           grepl <- base::grepl
[17:46:46.582]                           restarts <- computeRestarts(cond)
[17:46:46.582]                           for (restart in restarts) {
[17:46:46.582]                             name <- restart$name
[17:46:46.582]                             if (is.null(name)) 
[17:46:46.582]                               next
[17:46:46.582]                             if (!grepl(pattern, name)) 
[17:46:46.582]                               next
[17:46:46.582]                             invokeRestart(restart)
[17:46:46.582]                             muffled <- TRUE
[17:46:46.582]                             break
[17:46:46.582]                           }
[17:46:46.582]                         }
[17:46:46.582]                       }
[17:46:46.582]                       invisible(muffled)
[17:46:46.582]                     }
[17:46:46.582]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.582]                   }
[17:46:46.582]                 }
[17:46:46.582]                 else {
[17:46:46.582]                   if (TRUE) {
[17:46:46.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.582]                     {
[17:46:46.582]                       inherits <- base::inherits
[17:46:46.582]                       invokeRestart <- base::invokeRestart
[17:46:46.582]                       is.null <- base::is.null
[17:46:46.582]                       muffled <- FALSE
[17:46:46.582]                       if (inherits(cond, "message")) {
[17:46:46.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.582]                         if (muffled) 
[17:46:46.582]                           invokeRestart("muffleMessage")
[17:46:46.582]                       }
[17:46:46.582]                       else if (inherits(cond, "warning")) {
[17:46:46.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.582]                         if (muffled) 
[17:46:46.582]                           invokeRestart("muffleWarning")
[17:46:46.582]                       }
[17:46:46.582]                       else if (inherits(cond, "condition")) {
[17:46:46.582]                         if (!is.null(pattern)) {
[17:46:46.582]                           computeRestarts <- base::computeRestarts
[17:46:46.582]                           grepl <- base::grepl
[17:46:46.582]                           restarts <- computeRestarts(cond)
[17:46:46.582]                           for (restart in restarts) {
[17:46:46.582]                             name <- restart$name
[17:46:46.582]                             if (is.null(name)) 
[17:46:46.582]                               next
[17:46:46.582]                             if (!grepl(pattern, name)) 
[17:46:46.582]                               next
[17:46:46.582]                             invokeRestart(restart)
[17:46:46.582]                             muffled <- TRUE
[17:46:46.582]                             break
[17:46:46.582]                           }
[17:46:46.582]                         }
[17:46:46.582]                       }
[17:46:46.582]                       invisible(muffled)
[17:46:46.582]                     }
[17:46:46.582]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.582]                   }
[17:46:46.582]                 }
[17:46:46.582]             }
[17:46:46.582]         }))
[17:46:46.582]     }, error = function(ex) {
[17:46:46.582]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.582]                 ...future.rng), started = ...future.startTime, 
[17:46:46.582]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.582]             version = "1.8"), class = "FutureResult")
[17:46:46.582]     }, finally = {
[17:46:46.582]         if (!identical(...future.workdir, getwd())) 
[17:46:46.582]             setwd(...future.workdir)
[17:46:46.582]         {
[17:46:46.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.582]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.582]             }
[17:46:46.582]             base::options(...future.oldOptions)
[17:46:46.582]             if (.Platform$OS.type == "windows") {
[17:46:46.582]                 old_names <- names(...future.oldEnvVars)
[17:46:46.582]                 envs <- base::Sys.getenv()
[17:46:46.582]                 names <- names(envs)
[17:46:46.582]                 common <- intersect(names, old_names)
[17:46:46.582]                 added <- setdiff(names, old_names)
[17:46:46.582]                 removed <- setdiff(old_names, names)
[17:46:46.582]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.582]                   envs[common]]
[17:46:46.582]                 NAMES <- toupper(changed)
[17:46:46.582]                 args <- list()
[17:46:46.582]                 for (kk in seq_along(NAMES)) {
[17:46:46.582]                   name <- changed[[kk]]
[17:46:46.582]                   NAME <- NAMES[[kk]]
[17:46:46.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.582]                     next
[17:46:46.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.582]                 }
[17:46:46.582]                 NAMES <- toupper(added)
[17:46:46.582]                 for (kk in seq_along(NAMES)) {
[17:46:46.582]                   name <- added[[kk]]
[17:46:46.582]                   NAME <- NAMES[[kk]]
[17:46:46.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.582]                     next
[17:46:46.582]                   args[[name]] <- ""
[17:46:46.582]                 }
[17:46:46.582]                 NAMES <- toupper(removed)
[17:46:46.582]                 for (kk in seq_along(NAMES)) {
[17:46:46.582]                   name <- removed[[kk]]
[17:46:46.582]                   NAME <- NAMES[[kk]]
[17:46:46.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.582]                     next
[17:46:46.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.582]                 }
[17:46:46.582]                 if (length(args) > 0) 
[17:46:46.582]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.582]             }
[17:46:46.582]             else {
[17:46:46.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.582]             }
[17:46:46.582]             {
[17:46:46.582]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.582]                   0L) {
[17:46:46.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.582]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.582]                   base::options(opts)
[17:46:46.582]                 }
[17:46:46.582]                 {
[17:46:46.582]                   {
[17:46:46.582]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.582]                     NULL
[17:46:46.582]                   }
[17:46:46.582]                   options(future.plan = NULL)
[17:46:46.582]                   if (is.na(NA_character_)) 
[17:46:46.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.582]                     .init = FALSE)
[17:46:46.582]                 }
[17:46:46.582]             }
[17:46:46.582]         }
[17:46:46.582]     })
[17:46:46.582]     if (TRUE) {
[17:46:46.582]         base::sink(type = "output", split = FALSE)
[17:46:46.582]         if (TRUE) {
[17:46:46.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.582]         }
[17:46:46.582]         else {
[17:46:46.582]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.582]         }
[17:46:46.582]         base::close(...future.stdout)
[17:46:46.582]         ...future.stdout <- NULL
[17:46:46.582]     }
[17:46:46.582]     ...future.result$conditions <- ...future.conditions
[17:46:46.582]     ...future.result$finished <- base::Sys.time()
[17:46:46.582]     ...future.result
[17:46:46.582] }
[17:46:46.585] requestCore(): workers = 2
[17:46:46.588] MulticoreFuture started
[17:46:46.588] - Launch lazy future ... done
[17:46:46.588] run() for ‘MulticoreFuture’ ... done
[17:46:46.589] plan(): Setting new future strategy stack:
[17:46:46.589] getGlobalsAndPackages() ...
[17:46:46.589] Searching for globals...
[17:46:46.589] List of future strategies:
[17:46:46.589] 1. sequential:
[17:46:46.589]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.589]    - tweaked: FALSE
[17:46:46.589]    - call: NULL
[17:46:46.590] plan(): nbrOfWorkers() = 1
[17:46:46.591] - globals found: [1] ‘{’
[17:46:46.591] Searching for globals ... DONE
[17:46:46.591] Resolving globals: FALSE
[17:46:46.591] 
[17:46:46.592] 
[17:46:46.592] getGlobalsAndPackages() ... DONE
[17:46:46.592] plan(): Setting new future strategy stack:
[17:46:46.592] run() for ‘Future’ ...
[17:46:46.592] - state: ‘created’
[17:46:46.592] List of future strategies:
[17:46:46.592] 1. multicore:
[17:46:46.592]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.592]    - tweaked: FALSE
[17:46:46.592]    - call: plan(strategy)
[17:46:46.593] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.597] plan(): nbrOfWorkers() = 2
[17:46:46.597] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.598]   - Field: ‘label’
[17:46:46.598]   - Field: ‘local’
[17:46:46.598]   - Field: ‘owner’
[17:46:46.598]   - Field: ‘envir’
[17:46:46.598]   - Field: ‘workers’
[17:46:46.598]   - Field: ‘packages’
[17:46:46.598]   - Field: ‘gc’
[17:46:46.598]   - Field: ‘job’
[17:46:46.599]   - Field: ‘conditions’
[17:46:46.599]   - Field: ‘expr’
[17:46:46.599]   - Field: ‘uuid’
[17:46:46.599]   - Field: ‘seed’
[17:46:46.599]   - Field: ‘version’
[17:46:46.599]   - Field: ‘result’
[17:46:46.599]   - Field: ‘asynchronous’
[17:46:46.600]   - Field: ‘calls’
[17:46:46.600]   - Field: ‘globals’
[17:46:46.600]   - Field: ‘stdout’
[17:46:46.600]   - Field: ‘earlySignal’
[17:46:46.600]   - Field: ‘lazy’
[17:46:46.600]   - Field: ‘state’
[17:46:46.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.600] - Launch lazy future ...
[17:46:46.601] Packages needed by the future expression (n = 0): <none>
[17:46:46.601] Packages needed by future strategies (n = 0): <none>
[17:46:46.602] {
[17:46:46.602]     {
[17:46:46.602]         {
[17:46:46.602]             ...future.startTime <- base::Sys.time()
[17:46:46.602]             {
[17:46:46.602]                 {
[17:46:46.602]                   {
[17:46:46.602]                     {
[17:46:46.602]                       base::local({
[17:46:46.602]                         has_future <- base::requireNamespace("future", 
[17:46:46.602]                           quietly = TRUE)
[17:46:46.602]                         if (has_future) {
[17:46:46.602]                           ns <- base::getNamespace("future")
[17:46:46.602]                           version <- ns[[".package"]][["version"]]
[17:46:46.602]                           if (is.null(version)) 
[17:46:46.602]                             version <- utils::packageVersion("future")
[17:46:46.602]                         }
[17:46:46.602]                         else {
[17:46:46.602]                           version <- NULL
[17:46:46.602]                         }
[17:46:46.602]                         if (!has_future || version < "1.8.0") {
[17:46:46.602]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.602]                             "", base::R.version$version.string), 
[17:46:46.602]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.602]                               "release", "version")], collapse = " "), 
[17:46:46.602]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.602]                             info)
[17:46:46.602]                           info <- base::paste(info, collapse = "; ")
[17:46:46.602]                           if (!has_future) {
[17:46:46.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.602]                               info)
[17:46:46.602]                           }
[17:46:46.602]                           else {
[17:46:46.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.602]                               info, version)
[17:46:46.602]                           }
[17:46:46.602]                           base::stop(msg)
[17:46:46.602]                         }
[17:46:46.602]                       })
[17:46:46.602]                     }
[17:46:46.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.602]                     base::options(mc.cores = 1L)
[17:46:46.602]                   }
[17:46:46.602]                   ...future.strategy.old <- future::plan("list")
[17:46:46.602]                   options(future.plan = NULL)
[17:46:46.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.602]                 }
[17:46:46.602]                 ...future.workdir <- getwd()
[17:46:46.602]             }
[17:46:46.602]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.602]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.602]         }
[17:46:46.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.602]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.602]             base::names(...future.oldOptions))
[17:46:46.602]     }
[17:46:46.602]     if (FALSE) {
[17:46:46.602]     }
[17:46:46.602]     else {
[17:46:46.602]         if (TRUE) {
[17:46:46.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.602]                 open = "w")
[17:46:46.602]         }
[17:46:46.602]         else {
[17:46:46.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.602]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.602]         }
[17:46:46.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.602]             base::sink(type = "output", split = FALSE)
[17:46:46.602]             base::close(...future.stdout)
[17:46:46.602]         }, add = TRUE)
[17:46:46.602]     }
[17:46:46.602]     ...future.frame <- base::sys.nframe()
[17:46:46.602]     ...future.conditions <- base::list()
[17:46:46.602]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.602]     if (FALSE) {
[17:46:46.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.602]     }
[17:46:46.602]     ...future.result <- base::tryCatch({
[17:46:46.602]         base::withCallingHandlers({
[17:46:46.602]             ...future.value <- base::withVisible(base::local({
[17:46:46.602]                 withCallingHandlers({
[17:46:46.602]                   {
[17:46:46.602]                     4
[17:46:46.602]                   }
[17:46:46.602]                 }, immediateCondition = function(cond) {
[17:46:46.602]                   save_rds <- function (object, pathname, ...) 
[17:46:46.602]                   {
[17:46:46.602]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.602]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.602]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.602]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.602]                         fi_tmp[["mtime"]])
[17:46:46.602]                     }
[17:46:46.602]                     tryCatch({
[17:46:46.602]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.602]                     }, error = function(ex) {
[17:46:46.602]                       msg <- conditionMessage(ex)
[17:46:46.602]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.602]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.602]                         fi_tmp[["mtime"]], msg)
[17:46:46.602]                       ex$message <- msg
[17:46:46.602]                       stop(ex)
[17:46:46.602]                     })
[17:46:46.602]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.602]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.602]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.602]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.602]                       fi <- file.info(pathname)
[17:46:46.602]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.602]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.602]                         fi[["size"]], fi[["mtime"]])
[17:46:46.602]                       stop(msg)
[17:46:46.602]                     }
[17:46:46.602]                     invisible(pathname)
[17:46:46.602]                   }
[17:46:46.602]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.602]                     rootPath = tempdir()) 
[17:46:46.602]                   {
[17:46:46.602]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.602]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.602]                       tmpdir = path, fileext = ".rds")
[17:46:46.602]                     save_rds(obj, file)
[17:46:46.602]                   }
[17:46:46.602]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.602]                   {
[17:46:46.602]                     inherits <- base::inherits
[17:46:46.602]                     invokeRestart <- base::invokeRestart
[17:46:46.602]                     is.null <- base::is.null
[17:46:46.602]                     muffled <- FALSE
[17:46:46.602]                     if (inherits(cond, "message")) {
[17:46:46.602]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.602]                       if (muffled) 
[17:46:46.602]                         invokeRestart("muffleMessage")
[17:46:46.602]                     }
[17:46:46.602]                     else if (inherits(cond, "warning")) {
[17:46:46.602]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.602]                       if (muffled) 
[17:46:46.602]                         invokeRestart("muffleWarning")
[17:46:46.602]                     }
[17:46:46.602]                     else if (inherits(cond, "condition")) {
[17:46:46.602]                       if (!is.null(pattern)) {
[17:46:46.602]                         computeRestarts <- base::computeRestarts
[17:46:46.602]                         grepl <- base::grepl
[17:46:46.602]                         restarts <- computeRestarts(cond)
[17:46:46.602]                         for (restart in restarts) {
[17:46:46.602]                           name <- restart$name
[17:46:46.602]                           if (is.null(name)) 
[17:46:46.602]                             next
[17:46:46.602]                           if (!grepl(pattern, name)) 
[17:46:46.602]                             next
[17:46:46.602]                           invokeRestart(restart)
[17:46:46.602]                           muffled <- TRUE
[17:46:46.602]                           break
[17:46:46.602]                         }
[17:46:46.602]                       }
[17:46:46.602]                     }
[17:46:46.602]                     invisible(muffled)
[17:46:46.602]                   }
[17:46:46.602]                   muffleCondition(cond)
[17:46:46.602]                 })
[17:46:46.602]             }))
[17:46:46.602]             future::FutureResult(value = ...future.value$value, 
[17:46:46.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.602]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.602]                     ...future.globalenv.names))
[17:46:46.602]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.602]         }, condition = base::local({
[17:46:46.602]             c <- base::c
[17:46:46.602]             inherits <- base::inherits
[17:46:46.602]             invokeRestart <- base::invokeRestart
[17:46:46.602]             length <- base::length
[17:46:46.602]             list <- base::list
[17:46:46.602]             seq.int <- base::seq.int
[17:46:46.602]             signalCondition <- base::signalCondition
[17:46:46.602]             sys.calls <- base::sys.calls
[17:46:46.602]             `[[` <- base::`[[`
[17:46:46.602]             `+` <- base::`+`
[17:46:46.602]             `<<-` <- base::`<<-`
[17:46:46.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.602]                   3L)]
[17:46:46.602]             }
[17:46:46.602]             function(cond) {
[17:46:46.602]                 is_error <- inherits(cond, "error")
[17:46:46.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.602]                   NULL)
[17:46:46.602]                 if (is_error) {
[17:46:46.602]                   sessionInformation <- function() {
[17:46:46.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.602]                       search = base::search(), system = base::Sys.info())
[17:46:46.602]                   }
[17:46:46.602]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.602]                     cond$call), session = sessionInformation(), 
[17:46:46.602]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.602]                   signalCondition(cond)
[17:46:46.602]                 }
[17:46:46.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.602]                 "immediateCondition"))) {
[17:46:46.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.602]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.602]                   if (TRUE && !signal) {
[17:46:46.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.602]                     {
[17:46:46.602]                       inherits <- base::inherits
[17:46:46.602]                       invokeRestart <- base::invokeRestart
[17:46:46.602]                       is.null <- base::is.null
[17:46:46.602]                       muffled <- FALSE
[17:46:46.602]                       if (inherits(cond, "message")) {
[17:46:46.602]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.602]                         if (muffled) 
[17:46:46.602]                           invokeRestart("muffleMessage")
[17:46:46.602]                       }
[17:46:46.602]                       else if (inherits(cond, "warning")) {
[17:46:46.602]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.602]                         if (muffled) 
[17:46:46.602]                           invokeRestart("muffleWarning")
[17:46:46.602]                       }
[17:46:46.602]                       else if (inherits(cond, "condition")) {
[17:46:46.602]                         if (!is.null(pattern)) {
[17:46:46.602]                           computeRestarts <- base::computeRestarts
[17:46:46.602]                           grepl <- base::grepl
[17:46:46.602]                           restarts <- computeRestarts(cond)
[17:46:46.602]                           for (restart in restarts) {
[17:46:46.602]                             name <- restart$name
[17:46:46.602]                             if (is.null(name)) 
[17:46:46.602]                               next
[17:46:46.602]                             if (!grepl(pattern, name)) 
[17:46:46.602]                               next
[17:46:46.602]                             invokeRestart(restart)
[17:46:46.602]                             muffled <- TRUE
[17:46:46.602]                             break
[17:46:46.602]                           }
[17:46:46.602]                         }
[17:46:46.602]                       }
[17:46:46.602]                       invisible(muffled)
[17:46:46.602]                     }
[17:46:46.602]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.602]                   }
[17:46:46.602]                 }
[17:46:46.602]                 else {
[17:46:46.602]                   if (TRUE) {
[17:46:46.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.602]                     {
[17:46:46.602]                       inherits <- base::inherits
[17:46:46.602]                       invokeRestart <- base::invokeRestart
[17:46:46.602]                       is.null <- base::is.null
[17:46:46.602]                       muffled <- FALSE
[17:46:46.602]                       if (inherits(cond, "message")) {
[17:46:46.602]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.602]                         if (muffled) 
[17:46:46.602]                           invokeRestart("muffleMessage")
[17:46:46.602]                       }
[17:46:46.602]                       else if (inherits(cond, "warning")) {
[17:46:46.602]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.602]                         if (muffled) 
[17:46:46.602]                           invokeRestart("muffleWarning")
[17:46:46.602]                       }
[17:46:46.602]                       else if (inherits(cond, "condition")) {
[17:46:46.602]                         if (!is.null(pattern)) {
[17:46:46.602]                           computeRestarts <- base::computeRestarts
[17:46:46.602]                           grepl <- base::grepl
[17:46:46.602]                           restarts <- computeRestarts(cond)
[17:46:46.602]                           for (restart in restarts) {
[17:46:46.602]                             name <- restart$name
[17:46:46.602]                             if (is.null(name)) 
[17:46:46.602]                               next
[17:46:46.602]                             if (!grepl(pattern, name)) 
[17:46:46.602]                               next
[17:46:46.602]                             invokeRestart(restart)
[17:46:46.602]                             muffled <- TRUE
[17:46:46.602]                             break
[17:46:46.602]                           }
[17:46:46.602]                         }
[17:46:46.602]                       }
[17:46:46.602]                       invisible(muffled)
[17:46:46.602]                     }
[17:46:46.602]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.602]                   }
[17:46:46.602]                 }
[17:46:46.602]             }
[17:46:46.602]         }))
[17:46:46.602]     }, error = function(ex) {
[17:46:46.602]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.602]                 ...future.rng), started = ...future.startTime, 
[17:46:46.602]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.602]             version = "1.8"), class = "FutureResult")
[17:46:46.602]     }, finally = {
[17:46:46.602]         if (!identical(...future.workdir, getwd())) 
[17:46:46.602]             setwd(...future.workdir)
[17:46:46.602]         {
[17:46:46.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.602]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.602]             }
[17:46:46.602]             base::options(...future.oldOptions)
[17:46:46.602]             if (.Platform$OS.type == "windows") {
[17:46:46.602]                 old_names <- names(...future.oldEnvVars)
[17:46:46.602]                 envs <- base::Sys.getenv()
[17:46:46.602]                 names <- names(envs)
[17:46:46.602]                 common <- intersect(names, old_names)
[17:46:46.602]                 added <- setdiff(names, old_names)
[17:46:46.602]                 removed <- setdiff(old_names, names)
[17:46:46.602]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.602]                   envs[common]]
[17:46:46.602]                 NAMES <- toupper(changed)
[17:46:46.602]                 args <- list()
[17:46:46.602]                 for (kk in seq_along(NAMES)) {
[17:46:46.602]                   name <- changed[[kk]]
[17:46:46.602]                   NAME <- NAMES[[kk]]
[17:46:46.602]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.602]                     next
[17:46:46.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.602]                 }
[17:46:46.602]                 NAMES <- toupper(added)
[17:46:46.602]                 for (kk in seq_along(NAMES)) {
[17:46:46.602]                   name <- added[[kk]]
[17:46:46.602]                   NAME <- NAMES[[kk]]
[17:46:46.602]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.602]                     next
[17:46:46.602]                   args[[name]] <- ""
[17:46:46.602]                 }
[17:46:46.602]                 NAMES <- toupper(removed)
[17:46:46.602]                 for (kk in seq_along(NAMES)) {
[17:46:46.602]                   name <- removed[[kk]]
[17:46:46.602]                   NAME <- NAMES[[kk]]
[17:46:46.602]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.602]                     next
[17:46:46.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.602]                 }
[17:46:46.602]                 if (length(args) > 0) 
[17:46:46.602]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.602]             }
[17:46:46.602]             else {
[17:46:46.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.602]             }
[17:46:46.602]             {
[17:46:46.602]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.602]                   0L) {
[17:46:46.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.602]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.602]                   base::options(opts)
[17:46:46.602]                 }
[17:46:46.602]                 {
[17:46:46.602]                   {
[17:46:46.602]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.602]                     NULL
[17:46:46.602]                   }
[17:46:46.602]                   options(future.plan = NULL)
[17:46:46.602]                   if (is.na(NA_character_)) 
[17:46:46.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.602]                     .init = FALSE)
[17:46:46.602]                 }
[17:46:46.602]             }
[17:46:46.602]         }
[17:46:46.602]     })
[17:46:46.602]     if (TRUE) {
[17:46:46.602]         base::sink(type = "output", split = FALSE)
[17:46:46.602]         if (TRUE) {
[17:46:46.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.602]         }
[17:46:46.602]         else {
[17:46:46.602]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.602]         }
[17:46:46.602]         base::close(...future.stdout)
[17:46:46.602]         ...future.stdout <- NULL
[17:46:46.602]     }
[17:46:46.602]     ...future.result$conditions <- ...future.conditions
[17:46:46.602]     ...future.result$finished <- base::Sys.time()
[17:46:46.602]     ...future.result
[17:46:46.602] }
[17:46:46.605] requestCore(): workers = 2
[17:46:46.605] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:46.616] result() for MulticoreFuture ...
[17:46:46.617] result() for MulticoreFuture ...
[17:46:46.617] result() for MulticoreFuture ... done
[17:46:46.617] result() for MulticoreFuture ... done
[17:46:46.617] result() for MulticoreFuture ...
[17:46:46.617] result() for MulticoreFuture ... done
[17:46:46.620] MulticoreFuture started
[17:46:46.620] - Launch lazy future ... done
[17:46:46.620] run() for ‘MulticoreFuture’ ... done
[17:46:46.621] plan(): Setting new future strategy stack:
<environment: 0x5617890eb4c0> 
[17:46:46.621] List of future strategies:
[17:46:46.621] 1. sequential:
[17:46:46.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.621]    - tweaked: FALSE
[17:46:46.621]    - call: NULL
[17:46:46.623] plan(): nbrOfWorkers() = 1
<environment: 0x561789b911e8> 
[17:46:46.625] plan(): Setting new future strategy stack:
[17:46:46.625] List of future strategies:
[17:46:46.625] 1. multicore:
[17:46:46.625]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.625]    - tweaked: FALSE
[17:46:46.625]    - call: plan(strategy)
[17:46:46.630] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:46.633] resolve() on environment ...
[17:46:46.633]  recursive: 0
[17:46:46.634]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:46.634] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.634] - nx: 4
[17:46:46.634] - relay: TRUE
[17:46:46.634] - stdout: TRUE
[17:46:46.634] - signal: TRUE
[17:46:46.634] - resignal: FALSE
[17:46:46.634] - force: TRUE
[17:46:46.635] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.635] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.635]  - until=2
[17:46:46.635]  - relaying element #2
[17:46:46.635] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.635] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.635] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.635]  length: 3 (resolved future 1)
[17:46:46.636] Future #2
[17:46:46.636] result() for MulticoreFuture ...
[17:46:46.636] result() for MulticoreFuture ... done
[17:46:46.636] result() for MulticoreFuture ...
[17:46:46.636] result() for MulticoreFuture ... done
[17:46:46.636] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:46.637] - nx: 4
[17:46:46.637] - relay: TRUE
[17:46:46.637] - stdout: TRUE
[17:46:46.637] - signal: TRUE
[17:46:46.637] - resignal: FALSE
[17:46:46.637] - force: TRUE
[17:46:46.637] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.637] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.637]  - until=2
[17:46:46.638]  - relaying element #2
[17:46:46.644] result() for MulticoreFuture ...
[17:46:46.644] result() for MulticoreFuture ... done
[17:46:46.644] result() for MulticoreFuture ...
[17:46:46.644] result() for MulticoreFuture ... done
[17:46:46.644] result() for MulticoreFuture ...
[17:46:46.645] result() for MulticoreFuture ... done
[17:46:46.645] result() for MulticoreFuture ...
[17:46:46.645] result() for MulticoreFuture ... done
[17:46:46.645] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.645] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.645] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:46.645]  length: 2 (resolved future 2)
[17:46:46.646] Future #3
[17:46:46.646] result() for MulticoreFuture ...
[17:46:46.647] result() for MulticoreFuture ...
[17:46:46.647] result() for MulticoreFuture ... done
[17:46:46.647] result() for MulticoreFuture ... done
[17:46:46.647] result() for MulticoreFuture ...
[17:46:46.647] result() for MulticoreFuture ... done
[17:46:46.647] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:46.648] - nx: 4
[17:46:46.648] - relay: TRUE
[17:46:46.648] - stdout: TRUE
[17:46:46.648] - signal: TRUE
[17:46:46.648] - resignal: FALSE
[17:46:46.648] - force: TRUE
[17:46:46.648] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.648] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.649]  - until=3
[17:46:46.649]  - relaying element #3
[17:46:46.649] result() for MulticoreFuture ...
[17:46:46.649] result() for MulticoreFuture ... done
[17:46:46.649] result() for MulticoreFuture ...
[17:46:46.649] result() for MulticoreFuture ... done
[17:46:46.649] result() for MulticoreFuture ...
[17:46:46.650] result() for MulticoreFuture ... done
[17:46:46.650] result() for MulticoreFuture ...
[17:46:46.650] result() for MulticoreFuture ... done
[17:46:46.650] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.650] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.650] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:46.650]  length: 1 (resolved future 3)
[17:46:46.651] Future #4
[17:46:46.651] result() for MulticoreFuture ...
[17:46:46.652] result() for MulticoreFuture ...
[17:46:46.652] result() for MulticoreFuture ... done
[17:46:46.652] result() for MulticoreFuture ... done
[17:46:46.652] result() for MulticoreFuture ...
[17:46:46.652] result() for MulticoreFuture ... done
[17:46:46.652] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:46.653] - nx: 4
[17:46:46.653] - relay: TRUE
[17:46:46.653] - stdout: TRUE
[17:46:46.653] - signal: TRUE
[17:46:46.653] - resignal: FALSE
[17:46:46.653] - force: TRUE
[17:46:46.654] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.654] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.654]  - until=4
[17:46:46.654]  - relaying element #4
[17:46:46.654] result() for MulticoreFuture ...
[17:46:46.654] result() for MulticoreFuture ... done
[17:46:46.654] result() for MulticoreFuture ...
[17:46:46.655] result() for MulticoreFuture ... done
[17:46:46.655] result() for MulticoreFuture ...
[17:46:46.655] result() for MulticoreFuture ... done
[17:46:46.655] result() for MulticoreFuture ...
[17:46:46.655] result() for MulticoreFuture ... done
[17:46:46.655] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.656] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.656] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:46.656]  length: 0 (resolved future 4)
[17:46:46.656] Relaying remaining futures
[17:46:46.656] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.656] - nx: 4
[17:46:46.656] - relay: TRUE
[17:46:46.656] - stdout: TRUE
[17:46:46.656] - signal: TRUE
[17:46:46.656] - resignal: FALSE
[17:46:46.656] - force: TRUE
[17:46:46.657] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.657] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:46.657] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.657] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.657] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.657] resolve() on environment ... DONE
[17:46:46.657] result() for MulticoreFuture ...
[17:46:46.657] result() for MulticoreFuture ... done
[17:46:46.657] result() for MulticoreFuture ...
[17:46:46.658] result() for MulticoreFuture ... done
[17:46:46.658] result() for MulticoreFuture ...
[17:46:46.658] result() for MulticoreFuture ... done
[17:46:46.658] result() for MulticoreFuture ...
[17:46:46.658] result() for MulticoreFuture ... done
[17:46:46.658] result() for MulticoreFuture ...
[17:46:46.658] result() for MulticoreFuture ... done
[17:46:46.658] result() for MulticoreFuture ...
[17:46:46.658] result() for MulticoreFuture ... done
<environment: 0x561789c45170> 
Dimensions: c(1, 6)
[17:46:46.659] getGlobalsAndPackages() ...
[17:46:46.659] Searching for globals...
[17:46:46.660] 
[17:46:46.660] Searching for globals ... DONE
[17:46:46.660] - globals: [0] <none>
[17:46:46.660] getGlobalsAndPackages() ... DONE
[17:46:46.660] run() for ‘Future’ ...
[17:46:46.660] - state: ‘created’
[17:46:46.660] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.665] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.665]   - Field: ‘label’
[17:46:46.665]   - Field: ‘local’
[17:46:46.665]   - Field: ‘owner’
[17:46:46.665]   - Field: ‘envir’
[17:46:46.665]   - Field: ‘workers’
[17:46:46.665]   - Field: ‘packages’
[17:46:46.666]   - Field: ‘gc’
[17:46:46.666]   - Field: ‘job’
[17:46:46.666]   - Field: ‘conditions’
[17:46:46.666]   - Field: ‘expr’
[17:46:46.666]   - Field: ‘uuid’
[17:46:46.666]   - Field: ‘seed’
[17:46:46.666]   - Field: ‘version’
[17:46:46.666]   - Field: ‘result’
[17:46:46.666]   - Field: ‘asynchronous’
[17:46:46.666]   - Field: ‘calls’
[17:46:46.667]   - Field: ‘globals’
[17:46:46.667]   - Field: ‘stdout’
[17:46:46.667]   - Field: ‘earlySignal’
[17:46:46.667]   - Field: ‘lazy’
[17:46:46.667]   - Field: ‘state’
[17:46:46.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.667] - Launch lazy future ...
[17:46:46.668] Packages needed by the future expression (n = 0): <none>
[17:46:46.668] Packages needed by future strategies (n = 0): <none>
[17:46:46.668] {
[17:46:46.668]     {
[17:46:46.668]         {
[17:46:46.668]             ...future.startTime <- base::Sys.time()
[17:46:46.668]             {
[17:46:46.668]                 {
[17:46:46.668]                   {
[17:46:46.668]                     {
[17:46:46.668]                       base::local({
[17:46:46.668]                         has_future <- base::requireNamespace("future", 
[17:46:46.668]                           quietly = TRUE)
[17:46:46.668]                         if (has_future) {
[17:46:46.668]                           ns <- base::getNamespace("future")
[17:46:46.668]                           version <- ns[[".package"]][["version"]]
[17:46:46.668]                           if (is.null(version)) 
[17:46:46.668]                             version <- utils::packageVersion("future")
[17:46:46.668]                         }
[17:46:46.668]                         else {
[17:46:46.668]                           version <- NULL
[17:46:46.668]                         }
[17:46:46.668]                         if (!has_future || version < "1.8.0") {
[17:46:46.668]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.668]                             "", base::R.version$version.string), 
[17:46:46.668]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.668]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.668]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.668]                               "release", "version")], collapse = " "), 
[17:46:46.668]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.668]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.668]                             info)
[17:46:46.668]                           info <- base::paste(info, collapse = "; ")
[17:46:46.668]                           if (!has_future) {
[17:46:46.668]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.668]                               info)
[17:46:46.668]                           }
[17:46:46.668]                           else {
[17:46:46.668]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.668]                               info, version)
[17:46:46.668]                           }
[17:46:46.668]                           base::stop(msg)
[17:46:46.668]                         }
[17:46:46.668]                       })
[17:46:46.668]                     }
[17:46:46.668]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.668]                     base::options(mc.cores = 1L)
[17:46:46.668]                   }
[17:46:46.668]                   ...future.strategy.old <- future::plan("list")
[17:46:46.668]                   options(future.plan = NULL)
[17:46:46.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.668]                 }
[17:46:46.668]                 ...future.workdir <- getwd()
[17:46:46.668]             }
[17:46:46.668]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.668]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.668]         }
[17:46:46.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.668]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.668]             base::names(...future.oldOptions))
[17:46:46.668]     }
[17:46:46.668]     if (FALSE) {
[17:46:46.668]     }
[17:46:46.668]     else {
[17:46:46.668]         if (TRUE) {
[17:46:46.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.668]                 open = "w")
[17:46:46.668]         }
[17:46:46.668]         else {
[17:46:46.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.668]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.668]         }
[17:46:46.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.668]             base::sink(type = "output", split = FALSE)
[17:46:46.668]             base::close(...future.stdout)
[17:46:46.668]         }, add = TRUE)
[17:46:46.668]     }
[17:46:46.668]     ...future.frame <- base::sys.nframe()
[17:46:46.668]     ...future.conditions <- base::list()
[17:46:46.668]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.668]     if (FALSE) {
[17:46:46.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.668]     }
[17:46:46.668]     ...future.result <- base::tryCatch({
[17:46:46.668]         base::withCallingHandlers({
[17:46:46.668]             ...future.value <- base::withVisible(base::local({
[17:46:46.668]                 withCallingHandlers({
[17:46:46.668]                   2
[17:46:46.668]                 }, immediateCondition = function(cond) {
[17:46:46.668]                   save_rds <- function (object, pathname, ...) 
[17:46:46.668]                   {
[17:46:46.668]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.668]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.668]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.668]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.668]                         fi_tmp[["mtime"]])
[17:46:46.668]                     }
[17:46:46.668]                     tryCatch({
[17:46:46.668]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.668]                     }, error = function(ex) {
[17:46:46.668]                       msg <- conditionMessage(ex)
[17:46:46.668]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.668]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.668]                         fi_tmp[["mtime"]], msg)
[17:46:46.668]                       ex$message <- msg
[17:46:46.668]                       stop(ex)
[17:46:46.668]                     })
[17:46:46.668]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.668]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.668]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.668]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.668]                       fi <- file.info(pathname)
[17:46:46.668]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.668]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.668]                         fi[["size"]], fi[["mtime"]])
[17:46:46.668]                       stop(msg)
[17:46:46.668]                     }
[17:46:46.668]                     invisible(pathname)
[17:46:46.668]                   }
[17:46:46.668]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.668]                     rootPath = tempdir()) 
[17:46:46.668]                   {
[17:46:46.668]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.668]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.668]                       tmpdir = path, fileext = ".rds")
[17:46:46.668]                     save_rds(obj, file)
[17:46:46.668]                   }
[17:46:46.668]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.668]                   {
[17:46:46.668]                     inherits <- base::inherits
[17:46:46.668]                     invokeRestart <- base::invokeRestart
[17:46:46.668]                     is.null <- base::is.null
[17:46:46.668]                     muffled <- FALSE
[17:46:46.668]                     if (inherits(cond, "message")) {
[17:46:46.668]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.668]                       if (muffled) 
[17:46:46.668]                         invokeRestart("muffleMessage")
[17:46:46.668]                     }
[17:46:46.668]                     else if (inherits(cond, "warning")) {
[17:46:46.668]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.668]                       if (muffled) 
[17:46:46.668]                         invokeRestart("muffleWarning")
[17:46:46.668]                     }
[17:46:46.668]                     else if (inherits(cond, "condition")) {
[17:46:46.668]                       if (!is.null(pattern)) {
[17:46:46.668]                         computeRestarts <- base::computeRestarts
[17:46:46.668]                         grepl <- base::grepl
[17:46:46.668]                         restarts <- computeRestarts(cond)
[17:46:46.668]                         for (restart in restarts) {
[17:46:46.668]                           name <- restart$name
[17:46:46.668]                           if (is.null(name)) 
[17:46:46.668]                             next
[17:46:46.668]                           if (!grepl(pattern, name)) 
[17:46:46.668]                             next
[17:46:46.668]                           invokeRestart(restart)
[17:46:46.668]                           muffled <- TRUE
[17:46:46.668]                           break
[17:46:46.668]                         }
[17:46:46.668]                       }
[17:46:46.668]                     }
[17:46:46.668]                     invisible(muffled)
[17:46:46.668]                   }
[17:46:46.668]                   muffleCondition(cond)
[17:46:46.668]                 })
[17:46:46.668]             }))
[17:46:46.668]             future::FutureResult(value = ...future.value$value, 
[17:46:46.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.668]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.668]                     ...future.globalenv.names))
[17:46:46.668]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.668]         }, condition = base::local({
[17:46:46.668]             c <- base::c
[17:46:46.668]             inherits <- base::inherits
[17:46:46.668]             invokeRestart <- base::invokeRestart
[17:46:46.668]             length <- base::length
[17:46:46.668]             list <- base::list
[17:46:46.668]             seq.int <- base::seq.int
[17:46:46.668]             signalCondition <- base::signalCondition
[17:46:46.668]             sys.calls <- base::sys.calls
[17:46:46.668]             `[[` <- base::`[[`
[17:46:46.668]             `+` <- base::`+`
[17:46:46.668]             `<<-` <- base::`<<-`
[17:46:46.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.668]                   3L)]
[17:46:46.668]             }
[17:46:46.668]             function(cond) {
[17:46:46.668]                 is_error <- inherits(cond, "error")
[17:46:46.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.668]                   NULL)
[17:46:46.668]                 if (is_error) {
[17:46:46.668]                   sessionInformation <- function() {
[17:46:46.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.668]                       search = base::search(), system = base::Sys.info())
[17:46:46.668]                   }
[17:46:46.668]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.668]                     cond$call), session = sessionInformation(), 
[17:46:46.668]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.668]                   signalCondition(cond)
[17:46:46.668]                 }
[17:46:46.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.668]                 "immediateCondition"))) {
[17:46:46.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.668]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.668]                   if (TRUE && !signal) {
[17:46:46.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.668]                     {
[17:46:46.668]                       inherits <- base::inherits
[17:46:46.668]                       invokeRestart <- base::invokeRestart
[17:46:46.668]                       is.null <- base::is.null
[17:46:46.668]                       muffled <- FALSE
[17:46:46.668]                       if (inherits(cond, "message")) {
[17:46:46.668]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.668]                         if (muffled) 
[17:46:46.668]                           invokeRestart("muffleMessage")
[17:46:46.668]                       }
[17:46:46.668]                       else if (inherits(cond, "warning")) {
[17:46:46.668]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.668]                         if (muffled) 
[17:46:46.668]                           invokeRestart("muffleWarning")
[17:46:46.668]                       }
[17:46:46.668]                       else if (inherits(cond, "condition")) {
[17:46:46.668]                         if (!is.null(pattern)) {
[17:46:46.668]                           computeRestarts <- base::computeRestarts
[17:46:46.668]                           grepl <- base::grepl
[17:46:46.668]                           restarts <- computeRestarts(cond)
[17:46:46.668]                           for (restart in restarts) {
[17:46:46.668]                             name <- restart$name
[17:46:46.668]                             if (is.null(name)) 
[17:46:46.668]                               next
[17:46:46.668]                             if (!grepl(pattern, name)) 
[17:46:46.668]                               next
[17:46:46.668]                             invokeRestart(restart)
[17:46:46.668]                             muffled <- TRUE
[17:46:46.668]                             break
[17:46:46.668]                           }
[17:46:46.668]                         }
[17:46:46.668]                       }
[17:46:46.668]                       invisible(muffled)
[17:46:46.668]                     }
[17:46:46.668]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.668]                   }
[17:46:46.668]                 }
[17:46:46.668]                 else {
[17:46:46.668]                   if (TRUE) {
[17:46:46.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.668]                     {
[17:46:46.668]                       inherits <- base::inherits
[17:46:46.668]                       invokeRestart <- base::invokeRestart
[17:46:46.668]                       is.null <- base::is.null
[17:46:46.668]                       muffled <- FALSE
[17:46:46.668]                       if (inherits(cond, "message")) {
[17:46:46.668]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.668]                         if (muffled) 
[17:46:46.668]                           invokeRestart("muffleMessage")
[17:46:46.668]                       }
[17:46:46.668]                       else if (inherits(cond, "warning")) {
[17:46:46.668]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.668]                         if (muffled) 
[17:46:46.668]                           invokeRestart("muffleWarning")
[17:46:46.668]                       }
[17:46:46.668]                       else if (inherits(cond, "condition")) {
[17:46:46.668]                         if (!is.null(pattern)) {
[17:46:46.668]                           computeRestarts <- base::computeRestarts
[17:46:46.668]                           grepl <- base::grepl
[17:46:46.668]                           restarts <- computeRestarts(cond)
[17:46:46.668]                           for (restart in restarts) {
[17:46:46.668]                             name <- restart$name
[17:46:46.668]                             if (is.null(name)) 
[17:46:46.668]                               next
[17:46:46.668]                             if (!grepl(pattern, name)) 
[17:46:46.668]                               next
[17:46:46.668]                             invokeRestart(restart)
[17:46:46.668]                             muffled <- TRUE
[17:46:46.668]                             break
[17:46:46.668]                           }
[17:46:46.668]                         }
[17:46:46.668]                       }
[17:46:46.668]                       invisible(muffled)
[17:46:46.668]                     }
[17:46:46.668]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.668]                   }
[17:46:46.668]                 }
[17:46:46.668]             }
[17:46:46.668]         }))
[17:46:46.668]     }, error = function(ex) {
[17:46:46.668]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.668]                 ...future.rng), started = ...future.startTime, 
[17:46:46.668]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.668]             version = "1.8"), class = "FutureResult")
[17:46:46.668]     }, finally = {
[17:46:46.668]         if (!identical(...future.workdir, getwd())) 
[17:46:46.668]             setwd(...future.workdir)
[17:46:46.668]         {
[17:46:46.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.668]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.668]             }
[17:46:46.668]             base::options(...future.oldOptions)
[17:46:46.668]             if (.Platform$OS.type == "windows") {
[17:46:46.668]                 old_names <- names(...future.oldEnvVars)
[17:46:46.668]                 envs <- base::Sys.getenv()
[17:46:46.668]                 names <- names(envs)
[17:46:46.668]                 common <- intersect(names, old_names)
[17:46:46.668]                 added <- setdiff(names, old_names)
[17:46:46.668]                 removed <- setdiff(old_names, names)
[17:46:46.668]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.668]                   envs[common]]
[17:46:46.668]                 NAMES <- toupper(changed)
[17:46:46.668]                 args <- list()
[17:46:46.668]                 for (kk in seq_along(NAMES)) {
[17:46:46.668]                   name <- changed[[kk]]
[17:46:46.668]                   NAME <- NAMES[[kk]]
[17:46:46.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.668]                     next
[17:46:46.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.668]                 }
[17:46:46.668]                 NAMES <- toupper(added)
[17:46:46.668]                 for (kk in seq_along(NAMES)) {
[17:46:46.668]                   name <- added[[kk]]
[17:46:46.668]                   NAME <- NAMES[[kk]]
[17:46:46.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.668]                     next
[17:46:46.668]                   args[[name]] <- ""
[17:46:46.668]                 }
[17:46:46.668]                 NAMES <- toupper(removed)
[17:46:46.668]                 for (kk in seq_along(NAMES)) {
[17:46:46.668]                   name <- removed[[kk]]
[17:46:46.668]                   NAME <- NAMES[[kk]]
[17:46:46.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.668]                     next
[17:46:46.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.668]                 }
[17:46:46.668]                 if (length(args) > 0) 
[17:46:46.668]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.668]             }
[17:46:46.668]             else {
[17:46:46.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.668]             }
[17:46:46.668]             {
[17:46:46.668]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.668]                   0L) {
[17:46:46.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.668]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.668]                   base::options(opts)
[17:46:46.668]                 }
[17:46:46.668]                 {
[17:46:46.668]                   {
[17:46:46.668]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.668]                     NULL
[17:46:46.668]                   }
[17:46:46.668]                   options(future.plan = NULL)
[17:46:46.668]                   if (is.na(NA_character_)) 
[17:46:46.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.668]                     .init = FALSE)
[17:46:46.668]                 }
[17:46:46.668]             }
[17:46:46.668]         }
[17:46:46.668]     })
[17:46:46.668]     if (TRUE) {
[17:46:46.668]         base::sink(type = "output", split = FALSE)
[17:46:46.668]         if (TRUE) {
[17:46:46.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.668]         }
[17:46:46.668]         else {
[17:46:46.668]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.668]         }
[17:46:46.668]         base::close(...future.stdout)
[17:46:46.668]         ...future.stdout <- NULL
[17:46:46.668]     }
[17:46:46.668]     ...future.result$conditions <- ...future.conditions
[17:46:46.668]     ...future.result$finished <- base::Sys.time()
[17:46:46.668]     ...future.result
[17:46:46.668] }
[17:46:46.670] requestCore(): workers = 2
[17:46:46.673] MulticoreFuture started
[17:46:46.673] - Launch lazy future ... done
[17:46:46.673] run() for ‘MulticoreFuture’ ... done
[17:46:46.673] getGlobalsAndPackages() ...
[17:46:46.674] Searching for globals...
[17:46:46.674] plan(): Setting new future strategy stack:
[17:46:46.674] 
[17:46:46.674] List of future strategies:
[17:46:46.674] 1. sequential:
[17:46:46.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.674]    - tweaked: FALSE
[17:46:46.674]    - call: NULL
[17:46:46.675] Searching for globals ... DONE
[17:46:46.675] - globals: [0] <none>
[17:46:46.675] plan(): nbrOfWorkers() = 1
[17:46:46.675] getGlobalsAndPackages() ... DONE
[17:46:46.675] run() for ‘Future’ ...
[17:46:46.676] - state: ‘created’
[17:46:46.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.677] plan(): Setting new future strategy stack:
[17:46:46.677] List of future strategies:
[17:46:46.677] 1. multicore:
[17:46:46.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.677]    - tweaked: FALSE
[17:46:46.677]    - call: plan(strategy)
[17:46:46.681] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.681] plan(): nbrOfWorkers() = 2
[17:46:46.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.681]   - Field: ‘label’
[17:46:46.681]   - Field: ‘local’
[17:46:46.682]   - Field: ‘owner’
[17:46:46.682]   - Field: ‘envir’
[17:46:46.682]   - Field: ‘workers’
[17:46:46.682]   - Field: ‘packages’
[17:46:46.682]   - Field: ‘gc’
[17:46:46.682]   - Field: ‘job’
[17:46:46.683]   - Field: ‘conditions’
[17:46:46.683]   - Field: ‘expr’
[17:46:46.683]   - Field: ‘uuid’
[17:46:46.683]   - Field: ‘seed’
[17:46:46.683]   - Field: ‘version’
[17:46:46.683]   - Field: ‘result’
[17:46:46.684]   - Field: ‘asynchronous’
[17:46:46.684]   - Field: ‘calls’
[17:46:46.684]   - Field: ‘globals’
[17:46:46.684]   - Field: ‘stdout’
[17:46:46.684]   - Field: ‘earlySignal’
[17:46:46.684]   - Field: ‘lazy’
[17:46:46.685]   - Field: ‘state’
[17:46:46.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.685] - Launch lazy future ...
[17:46:46.685] Packages needed by the future expression (n = 0): <none>
[17:46:46.686] Packages needed by future strategies (n = 0): <none>
[17:46:46.687] {
[17:46:46.687]     {
[17:46:46.687]         {
[17:46:46.687]             ...future.startTime <- base::Sys.time()
[17:46:46.687]             {
[17:46:46.687]                 {
[17:46:46.687]                   {
[17:46:46.687]                     {
[17:46:46.687]                       base::local({
[17:46:46.687]                         has_future <- base::requireNamespace("future", 
[17:46:46.687]                           quietly = TRUE)
[17:46:46.687]                         if (has_future) {
[17:46:46.687]                           ns <- base::getNamespace("future")
[17:46:46.687]                           version <- ns[[".package"]][["version"]]
[17:46:46.687]                           if (is.null(version)) 
[17:46:46.687]                             version <- utils::packageVersion("future")
[17:46:46.687]                         }
[17:46:46.687]                         else {
[17:46:46.687]                           version <- NULL
[17:46:46.687]                         }
[17:46:46.687]                         if (!has_future || version < "1.8.0") {
[17:46:46.687]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.687]                             "", base::R.version$version.string), 
[17:46:46.687]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.687]                               "release", "version")], collapse = " "), 
[17:46:46.687]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.687]                             info)
[17:46:46.687]                           info <- base::paste(info, collapse = "; ")
[17:46:46.687]                           if (!has_future) {
[17:46:46.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.687]                               info)
[17:46:46.687]                           }
[17:46:46.687]                           else {
[17:46:46.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.687]                               info, version)
[17:46:46.687]                           }
[17:46:46.687]                           base::stop(msg)
[17:46:46.687]                         }
[17:46:46.687]                       })
[17:46:46.687]                     }
[17:46:46.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.687]                     base::options(mc.cores = 1L)
[17:46:46.687]                   }
[17:46:46.687]                   ...future.strategy.old <- future::plan("list")
[17:46:46.687]                   options(future.plan = NULL)
[17:46:46.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.687]                 }
[17:46:46.687]                 ...future.workdir <- getwd()
[17:46:46.687]             }
[17:46:46.687]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.687]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.687]         }
[17:46:46.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.687]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.687]             base::names(...future.oldOptions))
[17:46:46.687]     }
[17:46:46.687]     if (FALSE) {
[17:46:46.687]     }
[17:46:46.687]     else {
[17:46:46.687]         if (TRUE) {
[17:46:46.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.687]                 open = "w")
[17:46:46.687]         }
[17:46:46.687]         else {
[17:46:46.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.687]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.687]         }
[17:46:46.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.687]             base::sink(type = "output", split = FALSE)
[17:46:46.687]             base::close(...future.stdout)
[17:46:46.687]         }, add = TRUE)
[17:46:46.687]     }
[17:46:46.687]     ...future.frame <- base::sys.nframe()
[17:46:46.687]     ...future.conditions <- base::list()
[17:46:46.687]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.687]     if (FALSE) {
[17:46:46.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.687]     }
[17:46:46.687]     ...future.result <- base::tryCatch({
[17:46:46.687]         base::withCallingHandlers({
[17:46:46.687]             ...future.value <- base::withVisible(base::local({
[17:46:46.687]                 withCallingHandlers({
[17:46:46.687]                   NULL
[17:46:46.687]                 }, immediateCondition = function(cond) {
[17:46:46.687]                   save_rds <- function (object, pathname, ...) 
[17:46:46.687]                   {
[17:46:46.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.687]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.687]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.687]                         fi_tmp[["mtime"]])
[17:46:46.687]                     }
[17:46:46.687]                     tryCatch({
[17:46:46.687]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.687]                     }, error = function(ex) {
[17:46:46.687]                       msg <- conditionMessage(ex)
[17:46:46.687]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.687]                         fi_tmp[["mtime"]], msg)
[17:46:46.687]                       ex$message <- msg
[17:46:46.687]                       stop(ex)
[17:46:46.687]                     })
[17:46:46.687]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.687]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.687]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.687]                       fi <- file.info(pathname)
[17:46:46.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.687]                         fi[["size"]], fi[["mtime"]])
[17:46:46.687]                       stop(msg)
[17:46:46.687]                     }
[17:46:46.687]                     invisible(pathname)
[17:46:46.687]                   }
[17:46:46.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.687]                     rootPath = tempdir()) 
[17:46:46.687]                   {
[17:46:46.687]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.687]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.687]                       tmpdir = path, fileext = ".rds")
[17:46:46.687]                     save_rds(obj, file)
[17:46:46.687]                   }
[17:46:46.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.687]                   {
[17:46:46.687]                     inherits <- base::inherits
[17:46:46.687]                     invokeRestart <- base::invokeRestart
[17:46:46.687]                     is.null <- base::is.null
[17:46:46.687]                     muffled <- FALSE
[17:46:46.687]                     if (inherits(cond, "message")) {
[17:46:46.687]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.687]                       if (muffled) 
[17:46:46.687]                         invokeRestart("muffleMessage")
[17:46:46.687]                     }
[17:46:46.687]                     else if (inherits(cond, "warning")) {
[17:46:46.687]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.687]                       if (muffled) 
[17:46:46.687]                         invokeRestart("muffleWarning")
[17:46:46.687]                     }
[17:46:46.687]                     else if (inherits(cond, "condition")) {
[17:46:46.687]                       if (!is.null(pattern)) {
[17:46:46.687]                         computeRestarts <- base::computeRestarts
[17:46:46.687]                         grepl <- base::grepl
[17:46:46.687]                         restarts <- computeRestarts(cond)
[17:46:46.687]                         for (restart in restarts) {
[17:46:46.687]                           name <- restart$name
[17:46:46.687]                           if (is.null(name)) 
[17:46:46.687]                             next
[17:46:46.687]                           if (!grepl(pattern, name)) 
[17:46:46.687]                             next
[17:46:46.687]                           invokeRestart(restart)
[17:46:46.687]                           muffled <- TRUE
[17:46:46.687]                           break
[17:46:46.687]                         }
[17:46:46.687]                       }
[17:46:46.687]                     }
[17:46:46.687]                     invisible(muffled)
[17:46:46.687]                   }
[17:46:46.687]                   muffleCondition(cond)
[17:46:46.687]                 })
[17:46:46.687]             }))
[17:46:46.687]             future::FutureResult(value = ...future.value$value, 
[17:46:46.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.687]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.687]                     ...future.globalenv.names))
[17:46:46.687]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.687]         }, condition = base::local({
[17:46:46.687]             c <- base::c
[17:46:46.687]             inherits <- base::inherits
[17:46:46.687]             invokeRestart <- base::invokeRestart
[17:46:46.687]             length <- base::length
[17:46:46.687]             list <- base::list
[17:46:46.687]             seq.int <- base::seq.int
[17:46:46.687]             signalCondition <- base::signalCondition
[17:46:46.687]             sys.calls <- base::sys.calls
[17:46:46.687]             `[[` <- base::`[[`
[17:46:46.687]             `+` <- base::`+`
[17:46:46.687]             `<<-` <- base::`<<-`
[17:46:46.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.687]                   3L)]
[17:46:46.687]             }
[17:46:46.687]             function(cond) {
[17:46:46.687]                 is_error <- inherits(cond, "error")
[17:46:46.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.687]                   NULL)
[17:46:46.687]                 if (is_error) {
[17:46:46.687]                   sessionInformation <- function() {
[17:46:46.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.687]                       search = base::search(), system = base::Sys.info())
[17:46:46.687]                   }
[17:46:46.687]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.687]                     cond$call), session = sessionInformation(), 
[17:46:46.687]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.687]                   signalCondition(cond)
[17:46:46.687]                 }
[17:46:46.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.687]                 "immediateCondition"))) {
[17:46:46.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.687]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.687]                   if (TRUE && !signal) {
[17:46:46.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.687]                     {
[17:46:46.687]                       inherits <- base::inherits
[17:46:46.687]                       invokeRestart <- base::invokeRestart
[17:46:46.687]                       is.null <- base::is.null
[17:46:46.687]                       muffled <- FALSE
[17:46:46.687]                       if (inherits(cond, "message")) {
[17:46:46.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.687]                         if (muffled) 
[17:46:46.687]                           invokeRestart("muffleMessage")
[17:46:46.687]                       }
[17:46:46.687]                       else if (inherits(cond, "warning")) {
[17:46:46.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.687]                         if (muffled) 
[17:46:46.687]                           invokeRestart("muffleWarning")
[17:46:46.687]                       }
[17:46:46.687]                       else if (inherits(cond, "condition")) {
[17:46:46.687]                         if (!is.null(pattern)) {
[17:46:46.687]                           computeRestarts <- base::computeRestarts
[17:46:46.687]                           grepl <- base::grepl
[17:46:46.687]                           restarts <- computeRestarts(cond)
[17:46:46.687]                           for (restart in restarts) {
[17:46:46.687]                             name <- restart$name
[17:46:46.687]                             if (is.null(name)) 
[17:46:46.687]                               next
[17:46:46.687]                             if (!grepl(pattern, name)) 
[17:46:46.687]                               next
[17:46:46.687]                             invokeRestart(restart)
[17:46:46.687]                             muffled <- TRUE
[17:46:46.687]                             break
[17:46:46.687]                           }
[17:46:46.687]                         }
[17:46:46.687]                       }
[17:46:46.687]                       invisible(muffled)
[17:46:46.687]                     }
[17:46:46.687]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.687]                   }
[17:46:46.687]                 }
[17:46:46.687]                 else {
[17:46:46.687]                   if (TRUE) {
[17:46:46.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.687]                     {
[17:46:46.687]                       inherits <- base::inherits
[17:46:46.687]                       invokeRestart <- base::invokeRestart
[17:46:46.687]                       is.null <- base::is.null
[17:46:46.687]                       muffled <- FALSE
[17:46:46.687]                       if (inherits(cond, "message")) {
[17:46:46.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.687]                         if (muffled) 
[17:46:46.687]                           invokeRestart("muffleMessage")
[17:46:46.687]                       }
[17:46:46.687]                       else if (inherits(cond, "warning")) {
[17:46:46.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.687]                         if (muffled) 
[17:46:46.687]                           invokeRestart("muffleWarning")
[17:46:46.687]                       }
[17:46:46.687]                       else if (inherits(cond, "condition")) {
[17:46:46.687]                         if (!is.null(pattern)) {
[17:46:46.687]                           computeRestarts <- base::computeRestarts
[17:46:46.687]                           grepl <- base::grepl
[17:46:46.687]                           restarts <- computeRestarts(cond)
[17:46:46.687]                           for (restart in restarts) {
[17:46:46.687]                             name <- restart$name
[17:46:46.687]                             if (is.null(name)) 
[17:46:46.687]                               next
[17:46:46.687]                             if (!grepl(pattern, name)) 
[17:46:46.687]                               next
[17:46:46.687]                             invokeRestart(restart)
[17:46:46.687]                             muffled <- TRUE
[17:46:46.687]                             break
[17:46:46.687]                           }
[17:46:46.687]                         }
[17:46:46.687]                       }
[17:46:46.687]                       invisible(muffled)
[17:46:46.687]                     }
[17:46:46.687]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.687]                   }
[17:46:46.687]                 }
[17:46:46.687]             }
[17:46:46.687]         }))
[17:46:46.687]     }, error = function(ex) {
[17:46:46.687]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.687]                 ...future.rng), started = ...future.startTime, 
[17:46:46.687]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.687]             version = "1.8"), class = "FutureResult")
[17:46:46.687]     }, finally = {
[17:46:46.687]         if (!identical(...future.workdir, getwd())) 
[17:46:46.687]             setwd(...future.workdir)
[17:46:46.687]         {
[17:46:46.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.687]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.687]             }
[17:46:46.687]             base::options(...future.oldOptions)
[17:46:46.687]             if (.Platform$OS.type == "windows") {
[17:46:46.687]                 old_names <- names(...future.oldEnvVars)
[17:46:46.687]                 envs <- base::Sys.getenv()
[17:46:46.687]                 names <- names(envs)
[17:46:46.687]                 common <- intersect(names, old_names)
[17:46:46.687]                 added <- setdiff(names, old_names)
[17:46:46.687]                 removed <- setdiff(old_names, names)
[17:46:46.687]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.687]                   envs[common]]
[17:46:46.687]                 NAMES <- toupper(changed)
[17:46:46.687]                 args <- list()
[17:46:46.687]                 for (kk in seq_along(NAMES)) {
[17:46:46.687]                   name <- changed[[kk]]
[17:46:46.687]                   NAME <- NAMES[[kk]]
[17:46:46.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.687]                     next
[17:46:46.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.687]                 }
[17:46:46.687]                 NAMES <- toupper(added)
[17:46:46.687]                 for (kk in seq_along(NAMES)) {
[17:46:46.687]                   name <- added[[kk]]
[17:46:46.687]                   NAME <- NAMES[[kk]]
[17:46:46.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.687]                     next
[17:46:46.687]                   args[[name]] <- ""
[17:46:46.687]                 }
[17:46:46.687]                 NAMES <- toupper(removed)
[17:46:46.687]                 for (kk in seq_along(NAMES)) {
[17:46:46.687]                   name <- removed[[kk]]
[17:46:46.687]                   NAME <- NAMES[[kk]]
[17:46:46.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.687]                     next
[17:46:46.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.687]                 }
[17:46:46.687]                 if (length(args) > 0) 
[17:46:46.687]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.687]             }
[17:46:46.687]             else {
[17:46:46.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.687]             }
[17:46:46.687]             {
[17:46:46.687]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.687]                   0L) {
[17:46:46.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.687]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.687]                   base::options(opts)
[17:46:46.687]                 }
[17:46:46.687]                 {
[17:46:46.687]                   {
[17:46:46.687]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.687]                     NULL
[17:46:46.687]                   }
[17:46:46.687]                   options(future.plan = NULL)
[17:46:46.687]                   if (is.na(NA_character_)) 
[17:46:46.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.687]                     .init = FALSE)
[17:46:46.687]                 }
[17:46:46.687]             }
[17:46:46.687]         }
[17:46:46.687]     })
[17:46:46.687]     if (TRUE) {
[17:46:46.687]         base::sink(type = "output", split = FALSE)
[17:46:46.687]         if (TRUE) {
[17:46:46.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.687]         }
[17:46:46.687]         else {
[17:46:46.687]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.687]         }
[17:46:46.687]         base::close(...future.stdout)
[17:46:46.687]         ...future.stdout <- NULL
[17:46:46.687]     }
[17:46:46.687]     ...future.result$conditions <- ...future.conditions
[17:46:46.687]     ...future.result$finished <- base::Sys.time()
[17:46:46.687]     ...future.result
[17:46:46.687] }
[17:46:46.690] requestCore(): workers = 2
[17:46:46.693] MulticoreFuture started
[17:46:46.693] - Launch lazy future ... done
[17:46:46.693] run() for ‘MulticoreFuture’ ... done
[17:46:46.694] plan(): Setting new future strategy stack:
[17:46:46.694] getGlobalsAndPackages() ...
[17:46:46.694] Searching for globals...
[17:46:46.694] List of future strategies:
[17:46:46.694] 1. sequential:
[17:46:46.694]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.694]    - tweaked: FALSE
[17:46:46.694]    - call: NULL
[17:46:46.695] plan(): nbrOfWorkers() = 1
[17:46:46.696] - globals found: [1] ‘{’
[17:46:46.696] Searching for globals ... DONE
[17:46:46.697] Resolving globals: FALSE
[17:46:46.697] 
[17:46:46.697] 
[17:46:46.698] getGlobalsAndPackages() ... DONE
[17:46:46.698] plan(): Setting new future strategy stack:
[17:46:46.698] run() for ‘Future’ ...
[17:46:46.698] List of future strategies:
[17:46:46.698] 1. multicore:
[17:46:46.698]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.698]    - tweaked: FALSE
[17:46:46.698]    - call: plan(strategy)
[17:46:46.698] - state: ‘created’
[17:46:46.698] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.703] plan(): nbrOfWorkers() = 2
[17:46:46.703] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.704]   - Field: ‘label’
[17:46:46.704]   - Field: ‘local’
[17:46:46.704]   - Field: ‘owner’
[17:46:46.704]   - Field: ‘envir’
[17:46:46.704]   - Field: ‘workers’
[17:46:46.705]   - Field: ‘packages’
[17:46:46.705]   - Field: ‘gc’
[17:46:46.705]   - Field: ‘job’
[17:46:46.705]   - Field: ‘conditions’
[17:46:46.705]   - Field: ‘expr’
[17:46:46.705]   - Field: ‘uuid’
[17:46:46.705]   - Field: ‘seed’
[17:46:46.706]   - Field: ‘version’
[17:46:46.706]   - Field: ‘result’
[17:46:46.706]   - Field: ‘asynchronous’
[17:46:46.706]   - Field: ‘calls’
[17:46:46.706]   - Field: ‘globals’
[17:46:46.706]   - Field: ‘stdout’
[17:46:46.706]   - Field: ‘earlySignal’
[17:46:46.707]   - Field: ‘lazy’
[17:46:46.707]   - Field: ‘state’
[17:46:46.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.707] - Launch lazy future ...
[17:46:46.708] Packages needed by the future expression (n = 0): <none>
[17:46:46.708] Packages needed by future strategies (n = 0): <none>
[17:46:46.708] {
[17:46:46.708]     {
[17:46:46.708]         {
[17:46:46.708]             ...future.startTime <- base::Sys.time()
[17:46:46.708]             {
[17:46:46.708]                 {
[17:46:46.708]                   {
[17:46:46.708]                     {
[17:46:46.708]                       base::local({
[17:46:46.708]                         has_future <- base::requireNamespace("future", 
[17:46:46.708]                           quietly = TRUE)
[17:46:46.708]                         if (has_future) {
[17:46:46.708]                           ns <- base::getNamespace("future")
[17:46:46.708]                           version <- ns[[".package"]][["version"]]
[17:46:46.708]                           if (is.null(version)) 
[17:46:46.708]                             version <- utils::packageVersion("future")
[17:46:46.708]                         }
[17:46:46.708]                         else {
[17:46:46.708]                           version <- NULL
[17:46:46.708]                         }
[17:46:46.708]                         if (!has_future || version < "1.8.0") {
[17:46:46.708]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.708]                             "", base::R.version$version.string), 
[17:46:46.708]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.708]                               "release", "version")], collapse = " "), 
[17:46:46.708]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.708]                             info)
[17:46:46.708]                           info <- base::paste(info, collapse = "; ")
[17:46:46.708]                           if (!has_future) {
[17:46:46.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.708]                               info)
[17:46:46.708]                           }
[17:46:46.708]                           else {
[17:46:46.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.708]                               info, version)
[17:46:46.708]                           }
[17:46:46.708]                           base::stop(msg)
[17:46:46.708]                         }
[17:46:46.708]                       })
[17:46:46.708]                     }
[17:46:46.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.708]                     base::options(mc.cores = 1L)
[17:46:46.708]                   }
[17:46:46.708]                   ...future.strategy.old <- future::plan("list")
[17:46:46.708]                   options(future.plan = NULL)
[17:46:46.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.708]                 }
[17:46:46.708]                 ...future.workdir <- getwd()
[17:46:46.708]             }
[17:46:46.708]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.708]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.708]         }
[17:46:46.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.708]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.708]             base::names(...future.oldOptions))
[17:46:46.708]     }
[17:46:46.708]     if (FALSE) {
[17:46:46.708]     }
[17:46:46.708]     else {
[17:46:46.708]         if (TRUE) {
[17:46:46.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.708]                 open = "w")
[17:46:46.708]         }
[17:46:46.708]         else {
[17:46:46.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.708]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.708]         }
[17:46:46.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.708]             base::sink(type = "output", split = FALSE)
[17:46:46.708]             base::close(...future.stdout)
[17:46:46.708]         }, add = TRUE)
[17:46:46.708]     }
[17:46:46.708]     ...future.frame <- base::sys.nframe()
[17:46:46.708]     ...future.conditions <- base::list()
[17:46:46.708]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.708]     if (FALSE) {
[17:46:46.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.708]     }
[17:46:46.708]     ...future.result <- base::tryCatch({
[17:46:46.708]         base::withCallingHandlers({
[17:46:46.708]             ...future.value <- base::withVisible(base::local({
[17:46:46.708]                 withCallingHandlers({
[17:46:46.708]                   {
[17:46:46.708]                     4
[17:46:46.708]                   }
[17:46:46.708]                 }, immediateCondition = function(cond) {
[17:46:46.708]                   save_rds <- function (object, pathname, ...) 
[17:46:46.708]                   {
[17:46:46.708]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.708]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.708]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.708]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.708]                         fi_tmp[["mtime"]])
[17:46:46.708]                     }
[17:46:46.708]                     tryCatch({
[17:46:46.708]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.708]                     }, error = function(ex) {
[17:46:46.708]                       msg <- conditionMessage(ex)
[17:46:46.708]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.708]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.708]                         fi_tmp[["mtime"]], msg)
[17:46:46.708]                       ex$message <- msg
[17:46:46.708]                       stop(ex)
[17:46:46.708]                     })
[17:46:46.708]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.708]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.708]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.708]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.708]                       fi <- file.info(pathname)
[17:46:46.708]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.708]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.708]                         fi[["size"]], fi[["mtime"]])
[17:46:46.708]                       stop(msg)
[17:46:46.708]                     }
[17:46:46.708]                     invisible(pathname)
[17:46:46.708]                   }
[17:46:46.708]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.708]                     rootPath = tempdir()) 
[17:46:46.708]                   {
[17:46:46.708]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.708]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.708]                       tmpdir = path, fileext = ".rds")
[17:46:46.708]                     save_rds(obj, file)
[17:46:46.708]                   }
[17:46:46.708]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.708]                   {
[17:46:46.708]                     inherits <- base::inherits
[17:46:46.708]                     invokeRestart <- base::invokeRestart
[17:46:46.708]                     is.null <- base::is.null
[17:46:46.708]                     muffled <- FALSE
[17:46:46.708]                     if (inherits(cond, "message")) {
[17:46:46.708]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.708]                       if (muffled) 
[17:46:46.708]                         invokeRestart("muffleMessage")
[17:46:46.708]                     }
[17:46:46.708]                     else if (inherits(cond, "warning")) {
[17:46:46.708]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.708]                       if (muffled) 
[17:46:46.708]                         invokeRestart("muffleWarning")
[17:46:46.708]                     }
[17:46:46.708]                     else if (inherits(cond, "condition")) {
[17:46:46.708]                       if (!is.null(pattern)) {
[17:46:46.708]                         computeRestarts <- base::computeRestarts
[17:46:46.708]                         grepl <- base::grepl
[17:46:46.708]                         restarts <- computeRestarts(cond)
[17:46:46.708]                         for (restart in restarts) {
[17:46:46.708]                           name <- restart$name
[17:46:46.708]                           if (is.null(name)) 
[17:46:46.708]                             next
[17:46:46.708]                           if (!grepl(pattern, name)) 
[17:46:46.708]                             next
[17:46:46.708]                           invokeRestart(restart)
[17:46:46.708]                           muffled <- TRUE
[17:46:46.708]                           break
[17:46:46.708]                         }
[17:46:46.708]                       }
[17:46:46.708]                     }
[17:46:46.708]                     invisible(muffled)
[17:46:46.708]                   }
[17:46:46.708]                   muffleCondition(cond)
[17:46:46.708]                 })
[17:46:46.708]             }))
[17:46:46.708]             future::FutureResult(value = ...future.value$value, 
[17:46:46.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.708]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.708]                     ...future.globalenv.names))
[17:46:46.708]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.708]         }, condition = base::local({
[17:46:46.708]             c <- base::c
[17:46:46.708]             inherits <- base::inherits
[17:46:46.708]             invokeRestart <- base::invokeRestart
[17:46:46.708]             length <- base::length
[17:46:46.708]             list <- base::list
[17:46:46.708]             seq.int <- base::seq.int
[17:46:46.708]             signalCondition <- base::signalCondition
[17:46:46.708]             sys.calls <- base::sys.calls
[17:46:46.708]             `[[` <- base::`[[`
[17:46:46.708]             `+` <- base::`+`
[17:46:46.708]             `<<-` <- base::`<<-`
[17:46:46.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.708]                   3L)]
[17:46:46.708]             }
[17:46:46.708]             function(cond) {
[17:46:46.708]                 is_error <- inherits(cond, "error")
[17:46:46.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.708]                   NULL)
[17:46:46.708]                 if (is_error) {
[17:46:46.708]                   sessionInformation <- function() {
[17:46:46.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.708]                       search = base::search(), system = base::Sys.info())
[17:46:46.708]                   }
[17:46:46.708]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.708]                     cond$call), session = sessionInformation(), 
[17:46:46.708]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.708]                   signalCondition(cond)
[17:46:46.708]                 }
[17:46:46.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.708]                 "immediateCondition"))) {
[17:46:46.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.708]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.708]                   if (TRUE && !signal) {
[17:46:46.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.708]                     {
[17:46:46.708]                       inherits <- base::inherits
[17:46:46.708]                       invokeRestart <- base::invokeRestart
[17:46:46.708]                       is.null <- base::is.null
[17:46:46.708]                       muffled <- FALSE
[17:46:46.708]                       if (inherits(cond, "message")) {
[17:46:46.708]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.708]                         if (muffled) 
[17:46:46.708]                           invokeRestart("muffleMessage")
[17:46:46.708]                       }
[17:46:46.708]                       else if (inherits(cond, "warning")) {
[17:46:46.708]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.708]                         if (muffled) 
[17:46:46.708]                           invokeRestart("muffleWarning")
[17:46:46.708]                       }
[17:46:46.708]                       else if (inherits(cond, "condition")) {
[17:46:46.708]                         if (!is.null(pattern)) {
[17:46:46.708]                           computeRestarts <- base::computeRestarts
[17:46:46.708]                           grepl <- base::grepl
[17:46:46.708]                           restarts <- computeRestarts(cond)
[17:46:46.708]                           for (restart in restarts) {
[17:46:46.708]                             name <- restart$name
[17:46:46.708]                             if (is.null(name)) 
[17:46:46.708]                               next
[17:46:46.708]                             if (!grepl(pattern, name)) 
[17:46:46.708]                               next
[17:46:46.708]                             invokeRestart(restart)
[17:46:46.708]                             muffled <- TRUE
[17:46:46.708]                             break
[17:46:46.708]                           }
[17:46:46.708]                         }
[17:46:46.708]                       }
[17:46:46.708]                       invisible(muffled)
[17:46:46.708]                     }
[17:46:46.708]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.708]                   }
[17:46:46.708]                 }
[17:46:46.708]                 else {
[17:46:46.708]                   if (TRUE) {
[17:46:46.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.708]                     {
[17:46:46.708]                       inherits <- base::inherits
[17:46:46.708]                       invokeRestart <- base::invokeRestart
[17:46:46.708]                       is.null <- base::is.null
[17:46:46.708]                       muffled <- FALSE
[17:46:46.708]                       if (inherits(cond, "message")) {
[17:46:46.708]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.708]                         if (muffled) 
[17:46:46.708]                           invokeRestart("muffleMessage")
[17:46:46.708]                       }
[17:46:46.708]                       else if (inherits(cond, "warning")) {
[17:46:46.708]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.708]                         if (muffled) 
[17:46:46.708]                           invokeRestart("muffleWarning")
[17:46:46.708]                       }
[17:46:46.708]                       else if (inherits(cond, "condition")) {
[17:46:46.708]                         if (!is.null(pattern)) {
[17:46:46.708]                           computeRestarts <- base::computeRestarts
[17:46:46.708]                           grepl <- base::grepl
[17:46:46.708]                           restarts <- computeRestarts(cond)
[17:46:46.708]                           for (restart in restarts) {
[17:46:46.708]                             name <- restart$name
[17:46:46.708]                             if (is.null(name)) 
[17:46:46.708]                               next
[17:46:46.708]                             if (!grepl(pattern, name)) 
[17:46:46.708]                               next
[17:46:46.708]                             invokeRestart(restart)
[17:46:46.708]                             muffled <- TRUE
[17:46:46.708]                             break
[17:46:46.708]                           }
[17:46:46.708]                         }
[17:46:46.708]                       }
[17:46:46.708]                       invisible(muffled)
[17:46:46.708]                     }
[17:46:46.708]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.708]                   }
[17:46:46.708]                 }
[17:46:46.708]             }
[17:46:46.708]         }))
[17:46:46.708]     }, error = function(ex) {
[17:46:46.708]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.708]                 ...future.rng), started = ...future.startTime, 
[17:46:46.708]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.708]             version = "1.8"), class = "FutureResult")
[17:46:46.708]     }, finally = {
[17:46:46.708]         if (!identical(...future.workdir, getwd())) 
[17:46:46.708]             setwd(...future.workdir)
[17:46:46.708]         {
[17:46:46.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.708]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.708]             }
[17:46:46.708]             base::options(...future.oldOptions)
[17:46:46.708]             if (.Platform$OS.type == "windows") {
[17:46:46.708]                 old_names <- names(...future.oldEnvVars)
[17:46:46.708]                 envs <- base::Sys.getenv()
[17:46:46.708]                 names <- names(envs)
[17:46:46.708]                 common <- intersect(names, old_names)
[17:46:46.708]                 added <- setdiff(names, old_names)
[17:46:46.708]                 removed <- setdiff(old_names, names)
[17:46:46.708]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.708]                   envs[common]]
[17:46:46.708]                 NAMES <- toupper(changed)
[17:46:46.708]                 args <- list()
[17:46:46.708]                 for (kk in seq_along(NAMES)) {
[17:46:46.708]                   name <- changed[[kk]]
[17:46:46.708]                   NAME <- NAMES[[kk]]
[17:46:46.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.708]                     next
[17:46:46.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.708]                 }
[17:46:46.708]                 NAMES <- toupper(added)
[17:46:46.708]                 for (kk in seq_along(NAMES)) {
[17:46:46.708]                   name <- added[[kk]]
[17:46:46.708]                   NAME <- NAMES[[kk]]
[17:46:46.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.708]                     next
[17:46:46.708]                   args[[name]] <- ""
[17:46:46.708]                 }
[17:46:46.708]                 NAMES <- toupper(removed)
[17:46:46.708]                 for (kk in seq_along(NAMES)) {
[17:46:46.708]                   name <- removed[[kk]]
[17:46:46.708]                   NAME <- NAMES[[kk]]
[17:46:46.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.708]                     next
[17:46:46.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.708]                 }
[17:46:46.708]                 if (length(args) > 0) 
[17:46:46.708]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.708]             }
[17:46:46.708]             else {
[17:46:46.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.708]             }
[17:46:46.708]             {
[17:46:46.708]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.708]                   0L) {
[17:46:46.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.708]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.708]                   base::options(opts)
[17:46:46.708]                 }
[17:46:46.708]                 {
[17:46:46.708]                   {
[17:46:46.708]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.708]                     NULL
[17:46:46.708]                   }
[17:46:46.708]                   options(future.plan = NULL)
[17:46:46.708]                   if (is.na(NA_character_)) 
[17:46:46.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.708]                     .init = FALSE)
[17:46:46.708]                 }
[17:46:46.708]             }
[17:46:46.708]         }
[17:46:46.708]     })
[17:46:46.708]     if (TRUE) {
[17:46:46.708]         base::sink(type = "output", split = FALSE)
[17:46:46.708]         if (TRUE) {
[17:46:46.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.708]         }
[17:46:46.708]         else {
[17:46:46.708]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.708]         }
[17:46:46.708]         base::close(...future.stdout)
[17:46:46.708]         ...future.stdout <- NULL
[17:46:46.708]     }
[17:46:46.708]     ...future.result$conditions <- ...future.conditions
[17:46:46.708]     ...future.result$finished <- base::Sys.time()
[17:46:46.708]     ...future.result
[17:46:46.708] }
[17:46:46.712] requestCore(): workers = 2
[17:46:46.712] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:46.735] result() for MulticoreFuture ...
[17:46:46.736] result() for MulticoreFuture ...
[17:46:46.736] result() for MulticoreFuture ... done
[17:46:46.736] result() for MulticoreFuture ... done
[17:46:46.736] result() for MulticoreFuture ...
[17:46:46.736] result() for MulticoreFuture ... done
[17:46:46.739] MulticoreFuture started
[17:46:46.739] - Launch lazy future ... done
[17:46:46.740] run() for ‘MulticoreFuture’ ... done
[17:46:46.740] plan(): Setting new future strategy stack:
<environment: 0x561787af5558> 
[17:46:46.741] List of future strategies:
[17:46:46.741] 1. sequential:
[17:46:46.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.741]    - tweaked: FALSE
[17:46:46.741]    - call: NULL
[17:46:46.742] plan(): nbrOfWorkers() = 1
<environment: 0x5617891c3750> 
[17:46:46.744] plan(): Setting new future strategy stack:
[17:46:46.745] List of future strategies:
[17:46:46.745] 1. multicore:
[17:46:46.745]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.745]    - tweaked: FALSE
[17:46:46.745]    - call: plan(strategy)
[17:46:46.750] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:46.752] resolve() on environment ...
[17:46:46.752]  recursive: 0
[17:46:46.753]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:46.753] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.753] - nx: 4
[17:46:46.753] - relay: TRUE
[17:46:46.753] - stdout: TRUE
[17:46:46.753] - signal: TRUE
[17:46:46.754] - resignal: FALSE
[17:46:46.754] - force: TRUE
[17:46:46.754] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.754] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.754]  - until=2
[17:46:46.754]  - relaying element #2
[17:46:46.754] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.754] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.755] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.755]  length: 3 (resolved future 1)
[17:46:46.755] Future #2
[17:46:46.755] result() for MulticoreFuture ...
[17:46:46.755] result() for MulticoreFuture ... done
[17:46:46.755] result() for MulticoreFuture ...
[17:46:46.756] result() for MulticoreFuture ... done
[17:46:46.756] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:46.756] - nx: 4
[17:46:46.756] - relay: TRUE
[17:46:46.756] - stdout: TRUE
[17:46:46.756] - signal: TRUE
[17:46:46.756] - resignal: FALSE
[17:46:46.756] - force: TRUE
[17:46:46.757] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.757] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.757]  - until=2
[17:46:46.757]  - relaying element #2
[17:46:46.757] result() for MulticoreFuture ...
[17:46:46.757] result() for MulticoreFuture ... done
[17:46:46.757] result() for MulticoreFuture ...
[17:46:46.757] result() for MulticoreFuture ... done
[17:46:46.758] result() for MulticoreFuture ...
[17:46:46.758] result() for MulticoreFuture ... done
[17:46:46.758] result() for MulticoreFuture ...
[17:46:46.758] result() for MulticoreFuture ... done
[17:46:46.758] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.758] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.758] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:46.759]  length: 2 (resolved future 2)
[17:46:46.759] Future #3
[17:46:46.759] result() for MulticoreFuture ...
[17:46:46.760] result() for MulticoreFuture ...
[17:46:46.760] result() for MulticoreFuture ... done
[17:46:46.760] result() for MulticoreFuture ... done
[17:46:46.760] result() for MulticoreFuture ...
[17:46:46.760] result() for MulticoreFuture ... done
[17:46:46.760] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:46.761] - nx: 4
[17:46:46.761] - relay: TRUE
[17:46:46.761] - stdout: TRUE
[17:46:46.761] - signal: TRUE
[17:46:46.761] - resignal: FALSE
[17:46:46.761] - force: TRUE
[17:46:46.761] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.761] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.762]  - until=3
[17:46:46.762]  - relaying element #3
[17:46:46.762] result() for MulticoreFuture ...
[17:46:46.762] result() for MulticoreFuture ... done
[17:46:46.762] result() for MulticoreFuture ...
[17:46:46.762] result() for MulticoreFuture ... done
[17:46:46.762] result() for MulticoreFuture ...
[17:46:46.762] result() for MulticoreFuture ... done
[17:46:46.763] result() for MulticoreFuture ...
[17:46:46.763] result() for MulticoreFuture ... done
[17:46:46.763] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.763] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.763] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:46.763]  length: 1 (resolved future 3)
[17:46:46.764] Future #4
[17:46:46.764] result() for MulticoreFuture ...
[17:46:46.764] result() for MulticoreFuture ...
[17:46:46.765] result() for MulticoreFuture ... done
[17:46:46.765] result() for MulticoreFuture ... done
[17:46:46.765] result() for MulticoreFuture ...
[17:46:46.765] result() for MulticoreFuture ... done
[17:46:46.765] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:46.765] - nx: 4
[17:46:46.766] - relay: TRUE
[17:46:46.766] - stdout: TRUE
[17:46:46.766] - signal: TRUE
[17:46:46.766] - resignal: FALSE
[17:46:46.766] - force: TRUE
[17:46:46.766] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.767] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.767]  - until=4
[17:46:46.767]  - relaying element #4
[17:46:46.767] result() for MulticoreFuture ...
[17:46:46.767] result() for MulticoreFuture ... done
[17:46:46.767] result() for MulticoreFuture ...
[17:46:46.768] result() for MulticoreFuture ... done
[17:46:46.768] result() for MulticoreFuture ...
[17:46:46.768] result() for MulticoreFuture ... done
[17:46:46.768] result() for MulticoreFuture ...
[17:46:46.768] result() for MulticoreFuture ... done
[17:46:46.768] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.768] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.768] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:46.768]  length: 0 (resolved future 4)
[17:46:46.769] Relaying remaining futures
[17:46:46.769] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.769] - nx: 4
[17:46:46.769] - relay: TRUE
[17:46:46.769] - stdout: TRUE
[17:46:46.769] - signal: TRUE
[17:46:46.769] - resignal: FALSE
[17:46:46.769] - force: TRUE
[17:46:46.769] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.769] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:46.770] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.770] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.770] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.770] resolve() on environment ... DONE
[17:46:46.770] result() for MulticoreFuture ...
[17:46:46.770] result() for MulticoreFuture ... done
[17:46:46.770] result() for MulticoreFuture ...
[17:46:46.770] result() for MulticoreFuture ... done
[17:46:46.770] result() for MulticoreFuture ...
[17:46:46.771] result() for MulticoreFuture ... done
[17:46:46.771] result() for MulticoreFuture ...
[17:46:46.771] result() for MulticoreFuture ... done
[17:46:46.771] result() for MulticoreFuture ...
[17:46:46.771] result() for MulticoreFuture ... done
[17:46:46.771] result() for MulticoreFuture ...
[17:46:46.771] result() for MulticoreFuture ... done
<environment: 0x561789281f10> 
Dimensions: c(2, 3)
[17:46:46.772] getGlobalsAndPackages() ...
[17:46:46.772] Searching for globals...
[17:46:46.772] 
[17:46:46.772] Searching for globals ... DONE
[17:46:46.773] - globals: [0] <none>
[17:46:46.773] getGlobalsAndPackages() ... DONE
[17:46:46.773] run() for ‘Future’ ...
[17:46:46.773] - state: ‘created’
[17:46:46.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.778]   - Field: ‘label’
[17:46:46.778]   - Field: ‘local’
[17:46:46.778]   - Field: ‘owner’
[17:46:46.778]   - Field: ‘envir’
[17:46:46.778]   - Field: ‘workers’
[17:46:46.778]   - Field: ‘packages’
[17:46:46.778]   - Field: ‘gc’
[17:46:46.778]   - Field: ‘job’
[17:46:46.778]   - Field: ‘conditions’
[17:46:46.778]   - Field: ‘expr’
[17:46:46.779]   - Field: ‘uuid’
[17:46:46.779]   - Field: ‘seed’
[17:46:46.779]   - Field: ‘version’
[17:46:46.779]   - Field: ‘result’
[17:46:46.779]   - Field: ‘asynchronous’
[17:46:46.779]   - Field: ‘calls’
[17:46:46.779]   - Field: ‘globals’
[17:46:46.779]   - Field: ‘stdout’
[17:46:46.779]   - Field: ‘earlySignal’
[17:46:46.780]   - Field: ‘lazy’
[17:46:46.780]   - Field: ‘state’
[17:46:46.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.780] - Launch lazy future ...
[17:46:46.780] Packages needed by the future expression (n = 0): <none>
[17:46:46.780] Packages needed by future strategies (n = 0): <none>
[17:46:46.781] {
[17:46:46.781]     {
[17:46:46.781]         {
[17:46:46.781]             ...future.startTime <- base::Sys.time()
[17:46:46.781]             {
[17:46:46.781]                 {
[17:46:46.781]                   {
[17:46:46.781]                     {
[17:46:46.781]                       base::local({
[17:46:46.781]                         has_future <- base::requireNamespace("future", 
[17:46:46.781]                           quietly = TRUE)
[17:46:46.781]                         if (has_future) {
[17:46:46.781]                           ns <- base::getNamespace("future")
[17:46:46.781]                           version <- ns[[".package"]][["version"]]
[17:46:46.781]                           if (is.null(version)) 
[17:46:46.781]                             version <- utils::packageVersion("future")
[17:46:46.781]                         }
[17:46:46.781]                         else {
[17:46:46.781]                           version <- NULL
[17:46:46.781]                         }
[17:46:46.781]                         if (!has_future || version < "1.8.0") {
[17:46:46.781]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.781]                             "", base::R.version$version.string), 
[17:46:46.781]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.781]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.781]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.781]                               "release", "version")], collapse = " "), 
[17:46:46.781]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.781]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.781]                             info)
[17:46:46.781]                           info <- base::paste(info, collapse = "; ")
[17:46:46.781]                           if (!has_future) {
[17:46:46.781]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.781]                               info)
[17:46:46.781]                           }
[17:46:46.781]                           else {
[17:46:46.781]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.781]                               info, version)
[17:46:46.781]                           }
[17:46:46.781]                           base::stop(msg)
[17:46:46.781]                         }
[17:46:46.781]                       })
[17:46:46.781]                     }
[17:46:46.781]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.781]                     base::options(mc.cores = 1L)
[17:46:46.781]                   }
[17:46:46.781]                   ...future.strategy.old <- future::plan("list")
[17:46:46.781]                   options(future.plan = NULL)
[17:46:46.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.781]                 }
[17:46:46.781]                 ...future.workdir <- getwd()
[17:46:46.781]             }
[17:46:46.781]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.781]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.781]         }
[17:46:46.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.781]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.781]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.781]             base::names(...future.oldOptions))
[17:46:46.781]     }
[17:46:46.781]     if (FALSE) {
[17:46:46.781]     }
[17:46:46.781]     else {
[17:46:46.781]         if (TRUE) {
[17:46:46.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.781]                 open = "w")
[17:46:46.781]         }
[17:46:46.781]         else {
[17:46:46.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.781]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.781]         }
[17:46:46.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.781]             base::sink(type = "output", split = FALSE)
[17:46:46.781]             base::close(...future.stdout)
[17:46:46.781]         }, add = TRUE)
[17:46:46.781]     }
[17:46:46.781]     ...future.frame <- base::sys.nframe()
[17:46:46.781]     ...future.conditions <- base::list()
[17:46:46.781]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.781]     if (FALSE) {
[17:46:46.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.781]     }
[17:46:46.781]     ...future.result <- base::tryCatch({
[17:46:46.781]         base::withCallingHandlers({
[17:46:46.781]             ...future.value <- base::withVisible(base::local({
[17:46:46.781]                 withCallingHandlers({
[17:46:46.781]                   2
[17:46:46.781]                 }, immediateCondition = function(cond) {
[17:46:46.781]                   save_rds <- function (object, pathname, ...) 
[17:46:46.781]                   {
[17:46:46.781]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.781]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.781]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.781]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.781]                         fi_tmp[["mtime"]])
[17:46:46.781]                     }
[17:46:46.781]                     tryCatch({
[17:46:46.781]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.781]                     }, error = function(ex) {
[17:46:46.781]                       msg <- conditionMessage(ex)
[17:46:46.781]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.781]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.781]                         fi_tmp[["mtime"]], msg)
[17:46:46.781]                       ex$message <- msg
[17:46:46.781]                       stop(ex)
[17:46:46.781]                     })
[17:46:46.781]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.781]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.781]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.781]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.781]                       fi <- file.info(pathname)
[17:46:46.781]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.781]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.781]                         fi[["size"]], fi[["mtime"]])
[17:46:46.781]                       stop(msg)
[17:46:46.781]                     }
[17:46:46.781]                     invisible(pathname)
[17:46:46.781]                   }
[17:46:46.781]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.781]                     rootPath = tempdir()) 
[17:46:46.781]                   {
[17:46:46.781]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.781]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.781]                       tmpdir = path, fileext = ".rds")
[17:46:46.781]                     save_rds(obj, file)
[17:46:46.781]                   }
[17:46:46.781]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.781]                   {
[17:46:46.781]                     inherits <- base::inherits
[17:46:46.781]                     invokeRestart <- base::invokeRestart
[17:46:46.781]                     is.null <- base::is.null
[17:46:46.781]                     muffled <- FALSE
[17:46:46.781]                     if (inherits(cond, "message")) {
[17:46:46.781]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.781]                       if (muffled) 
[17:46:46.781]                         invokeRestart("muffleMessage")
[17:46:46.781]                     }
[17:46:46.781]                     else if (inherits(cond, "warning")) {
[17:46:46.781]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.781]                       if (muffled) 
[17:46:46.781]                         invokeRestart("muffleWarning")
[17:46:46.781]                     }
[17:46:46.781]                     else if (inherits(cond, "condition")) {
[17:46:46.781]                       if (!is.null(pattern)) {
[17:46:46.781]                         computeRestarts <- base::computeRestarts
[17:46:46.781]                         grepl <- base::grepl
[17:46:46.781]                         restarts <- computeRestarts(cond)
[17:46:46.781]                         for (restart in restarts) {
[17:46:46.781]                           name <- restart$name
[17:46:46.781]                           if (is.null(name)) 
[17:46:46.781]                             next
[17:46:46.781]                           if (!grepl(pattern, name)) 
[17:46:46.781]                             next
[17:46:46.781]                           invokeRestart(restart)
[17:46:46.781]                           muffled <- TRUE
[17:46:46.781]                           break
[17:46:46.781]                         }
[17:46:46.781]                       }
[17:46:46.781]                     }
[17:46:46.781]                     invisible(muffled)
[17:46:46.781]                   }
[17:46:46.781]                   muffleCondition(cond)
[17:46:46.781]                 })
[17:46:46.781]             }))
[17:46:46.781]             future::FutureResult(value = ...future.value$value, 
[17:46:46.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.781]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.781]                     ...future.globalenv.names))
[17:46:46.781]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.781]         }, condition = base::local({
[17:46:46.781]             c <- base::c
[17:46:46.781]             inherits <- base::inherits
[17:46:46.781]             invokeRestart <- base::invokeRestart
[17:46:46.781]             length <- base::length
[17:46:46.781]             list <- base::list
[17:46:46.781]             seq.int <- base::seq.int
[17:46:46.781]             signalCondition <- base::signalCondition
[17:46:46.781]             sys.calls <- base::sys.calls
[17:46:46.781]             `[[` <- base::`[[`
[17:46:46.781]             `+` <- base::`+`
[17:46:46.781]             `<<-` <- base::`<<-`
[17:46:46.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.781]                   3L)]
[17:46:46.781]             }
[17:46:46.781]             function(cond) {
[17:46:46.781]                 is_error <- inherits(cond, "error")
[17:46:46.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.781]                   NULL)
[17:46:46.781]                 if (is_error) {
[17:46:46.781]                   sessionInformation <- function() {
[17:46:46.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.781]                       search = base::search(), system = base::Sys.info())
[17:46:46.781]                   }
[17:46:46.781]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.781]                     cond$call), session = sessionInformation(), 
[17:46:46.781]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.781]                   signalCondition(cond)
[17:46:46.781]                 }
[17:46:46.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.781]                 "immediateCondition"))) {
[17:46:46.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.781]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.781]                   if (TRUE && !signal) {
[17:46:46.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.781]                     {
[17:46:46.781]                       inherits <- base::inherits
[17:46:46.781]                       invokeRestart <- base::invokeRestart
[17:46:46.781]                       is.null <- base::is.null
[17:46:46.781]                       muffled <- FALSE
[17:46:46.781]                       if (inherits(cond, "message")) {
[17:46:46.781]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.781]                         if (muffled) 
[17:46:46.781]                           invokeRestart("muffleMessage")
[17:46:46.781]                       }
[17:46:46.781]                       else if (inherits(cond, "warning")) {
[17:46:46.781]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.781]                         if (muffled) 
[17:46:46.781]                           invokeRestart("muffleWarning")
[17:46:46.781]                       }
[17:46:46.781]                       else if (inherits(cond, "condition")) {
[17:46:46.781]                         if (!is.null(pattern)) {
[17:46:46.781]                           computeRestarts <- base::computeRestarts
[17:46:46.781]                           grepl <- base::grepl
[17:46:46.781]                           restarts <- computeRestarts(cond)
[17:46:46.781]                           for (restart in restarts) {
[17:46:46.781]                             name <- restart$name
[17:46:46.781]                             if (is.null(name)) 
[17:46:46.781]                               next
[17:46:46.781]                             if (!grepl(pattern, name)) 
[17:46:46.781]                               next
[17:46:46.781]                             invokeRestart(restart)
[17:46:46.781]                             muffled <- TRUE
[17:46:46.781]                             break
[17:46:46.781]                           }
[17:46:46.781]                         }
[17:46:46.781]                       }
[17:46:46.781]                       invisible(muffled)
[17:46:46.781]                     }
[17:46:46.781]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.781]                   }
[17:46:46.781]                 }
[17:46:46.781]                 else {
[17:46:46.781]                   if (TRUE) {
[17:46:46.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.781]                     {
[17:46:46.781]                       inherits <- base::inherits
[17:46:46.781]                       invokeRestart <- base::invokeRestart
[17:46:46.781]                       is.null <- base::is.null
[17:46:46.781]                       muffled <- FALSE
[17:46:46.781]                       if (inherits(cond, "message")) {
[17:46:46.781]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.781]                         if (muffled) 
[17:46:46.781]                           invokeRestart("muffleMessage")
[17:46:46.781]                       }
[17:46:46.781]                       else if (inherits(cond, "warning")) {
[17:46:46.781]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.781]                         if (muffled) 
[17:46:46.781]                           invokeRestart("muffleWarning")
[17:46:46.781]                       }
[17:46:46.781]                       else if (inherits(cond, "condition")) {
[17:46:46.781]                         if (!is.null(pattern)) {
[17:46:46.781]                           computeRestarts <- base::computeRestarts
[17:46:46.781]                           grepl <- base::grepl
[17:46:46.781]                           restarts <- computeRestarts(cond)
[17:46:46.781]                           for (restart in restarts) {
[17:46:46.781]                             name <- restart$name
[17:46:46.781]                             if (is.null(name)) 
[17:46:46.781]                               next
[17:46:46.781]                             if (!grepl(pattern, name)) 
[17:46:46.781]                               next
[17:46:46.781]                             invokeRestart(restart)
[17:46:46.781]                             muffled <- TRUE
[17:46:46.781]                             break
[17:46:46.781]                           }
[17:46:46.781]                         }
[17:46:46.781]                       }
[17:46:46.781]                       invisible(muffled)
[17:46:46.781]                     }
[17:46:46.781]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.781]                   }
[17:46:46.781]                 }
[17:46:46.781]             }
[17:46:46.781]         }))
[17:46:46.781]     }, error = function(ex) {
[17:46:46.781]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.781]                 ...future.rng), started = ...future.startTime, 
[17:46:46.781]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.781]             version = "1.8"), class = "FutureResult")
[17:46:46.781]     }, finally = {
[17:46:46.781]         if (!identical(...future.workdir, getwd())) 
[17:46:46.781]             setwd(...future.workdir)
[17:46:46.781]         {
[17:46:46.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.781]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.781]             }
[17:46:46.781]             base::options(...future.oldOptions)
[17:46:46.781]             if (.Platform$OS.type == "windows") {
[17:46:46.781]                 old_names <- names(...future.oldEnvVars)
[17:46:46.781]                 envs <- base::Sys.getenv()
[17:46:46.781]                 names <- names(envs)
[17:46:46.781]                 common <- intersect(names, old_names)
[17:46:46.781]                 added <- setdiff(names, old_names)
[17:46:46.781]                 removed <- setdiff(old_names, names)
[17:46:46.781]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.781]                   envs[common]]
[17:46:46.781]                 NAMES <- toupper(changed)
[17:46:46.781]                 args <- list()
[17:46:46.781]                 for (kk in seq_along(NAMES)) {
[17:46:46.781]                   name <- changed[[kk]]
[17:46:46.781]                   NAME <- NAMES[[kk]]
[17:46:46.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.781]                     next
[17:46:46.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.781]                 }
[17:46:46.781]                 NAMES <- toupper(added)
[17:46:46.781]                 for (kk in seq_along(NAMES)) {
[17:46:46.781]                   name <- added[[kk]]
[17:46:46.781]                   NAME <- NAMES[[kk]]
[17:46:46.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.781]                     next
[17:46:46.781]                   args[[name]] <- ""
[17:46:46.781]                 }
[17:46:46.781]                 NAMES <- toupper(removed)
[17:46:46.781]                 for (kk in seq_along(NAMES)) {
[17:46:46.781]                   name <- removed[[kk]]
[17:46:46.781]                   NAME <- NAMES[[kk]]
[17:46:46.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.781]                     next
[17:46:46.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.781]                 }
[17:46:46.781]                 if (length(args) > 0) 
[17:46:46.781]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.781]             }
[17:46:46.781]             else {
[17:46:46.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.781]             }
[17:46:46.781]             {
[17:46:46.781]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.781]                   0L) {
[17:46:46.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.781]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.781]                   base::options(opts)
[17:46:46.781]                 }
[17:46:46.781]                 {
[17:46:46.781]                   {
[17:46:46.781]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.781]                     NULL
[17:46:46.781]                   }
[17:46:46.781]                   options(future.plan = NULL)
[17:46:46.781]                   if (is.na(NA_character_)) 
[17:46:46.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.781]                     .init = FALSE)
[17:46:46.781]                 }
[17:46:46.781]             }
[17:46:46.781]         }
[17:46:46.781]     })
[17:46:46.781]     if (TRUE) {
[17:46:46.781]         base::sink(type = "output", split = FALSE)
[17:46:46.781]         if (TRUE) {
[17:46:46.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.781]         }
[17:46:46.781]         else {
[17:46:46.781]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.781]         }
[17:46:46.781]         base::close(...future.stdout)
[17:46:46.781]         ...future.stdout <- NULL
[17:46:46.781]     }
[17:46:46.781]     ...future.result$conditions <- ...future.conditions
[17:46:46.781]     ...future.result$finished <- base::Sys.time()
[17:46:46.781]     ...future.result
[17:46:46.781] }
[17:46:46.783] requestCore(): workers = 2
[17:46:46.785] MulticoreFuture started
[17:46:46.786] - Launch lazy future ... done
[17:46:46.786] run() for ‘MulticoreFuture’ ... done
[17:46:46.786] getGlobalsAndPackages() ...
[17:46:46.786] Searching for globals...
[17:46:46.786] plan(): Setting new future strategy stack:
[17:46:46.787] 
[17:46:46.787] List of future strategies:
[17:46:46.787] 1. sequential:
[17:46:46.787]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.787]    - tweaked: FALSE
[17:46:46.787]    - call: NULL
[17:46:46.787] Searching for globals ... DONE
[17:46:46.787] - globals: [0] <none>
[17:46:46.788] plan(): nbrOfWorkers() = 1
[17:46:46.788] getGlobalsAndPackages() ... DONE
[17:46:46.788] run() for ‘Future’ ...
[17:46:46.788] - state: ‘created’
[17:46:46.788] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.789] plan(): Setting new future strategy stack:
[17:46:46.789] List of future strategies:
[17:46:46.789] 1. multicore:
[17:46:46.789]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.789]    - tweaked: FALSE
[17:46:46.789]    - call: plan(strategy)
[17:46:46.793] plan(): nbrOfWorkers() = 2
[17:46:46.793] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.800]   - Field: ‘label’
[17:46:46.800]   - Field: ‘local’
[17:46:46.800]   - Field: ‘owner’
[17:46:46.800]   - Field: ‘envir’
[17:46:46.800]   - Field: ‘workers’
[17:46:46.800]   - Field: ‘packages’
[17:46:46.801]   - Field: ‘gc’
[17:46:46.801]   - Field: ‘job’
[17:46:46.801]   - Field: ‘conditions’
[17:46:46.801]   - Field: ‘expr’
[17:46:46.801]   - Field: ‘uuid’
[17:46:46.801]   - Field: ‘seed’
[17:46:46.801]   - Field: ‘version’
[17:46:46.801]   - Field: ‘result’
[17:46:46.802]   - Field: ‘asynchronous’
[17:46:46.802]   - Field: ‘calls’
[17:46:46.802]   - Field: ‘globals’
[17:46:46.802]   - Field: ‘stdout’
[17:46:46.802]   - Field: ‘earlySignal’
[17:46:46.802]   - Field: ‘lazy’
[17:46:46.802]   - Field: ‘state’
[17:46:46.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.803] - Launch lazy future ...
[17:46:46.803] Packages needed by the future expression (n = 0): <none>
[17:46:46.803] Packages needed by future strategies (n = 0): <none>
[17:46:46.804] {
[17:46:46.804]     {
[17:46:46.804]         {
[17:46:46.804]             ...future.startTime <- base::Sys.time()
[17:46:46.804]             {
[17:46:46.804]                 {
[17:46:46.804]                   {
[17:46:46.804]                     {
[17:46:46.804]                       base::local({
[17:46:46.804]                         has_future <- base::requireNamespace("future", 
[17:46:46.804]                           quietly = TRUE)
[17:46:46.804]                         if (has_future) {
[17:46:46.804]                           ns <- base::getNamespace("future")
[17:46:46.804]                           version <- ns[[".package"]][["version"]]
[17:46:46.804]                           if (is.null(version)) 
[17:46:46.804]                             version <- utils::packageVersion("future")
[17:46:46.804]                         }
[17:46:46.804]                         else {
[17:46:46.804]                           version <- NULL
[17:46:46.804]                         }
[17:46:46.804]                         if (!has_future || version < "1.8.0") {
[17:46:46.804]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.804]                             "", base::R.version$version.string), 
[17:46:46.804]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.804]                               "release", "version")], collapse = " "), 
[17:46:46.804]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.804]                             info)
[17:46:46.804]                           info <- base::paste(info, collapse = "; ")
[17:46:46.804]                           if (!has_future) {
[17:46:46.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.804]                               info)
[17:46:46.804]                           }
[17:46:46.804]                           else {
[17:46:46.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.804]                               info, version)
[17:46:46.804]                           }
[17:46:46.804]                           base::stop(msg)
[17:46:46.804]                         }
[17:46:46.804]                       })
[17:46:46.804]                     }
[17:46:46.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.804]                     base::options(mc.cores = 1L)
[17:46:46.804]                   }
[17:46:46.804]                   ...future.strategy.old <- future::plan("list")
[17:46:46.804]                   options(future.plan = NULL)
[17:46:46.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.804]                 }
[17:46:46.804]                 ...future.workdir <- getwd()
[17:46:46.804]             }
[17:46:46.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.804]         }
[17:46:46.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.804]             base::names(...future.oldOptions))
[17:46:46.804]     }
[17:46:46.804]     if (FALSE) {
[17:46:46.804]     }
[17:46:46.804]     else {
[17:46:46.804]         if (TRUE) {
[17:46:46.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.804]                 open = "w")
[17:46:46.804]         }
[17:46:46.804]         else {
[17:46:46.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.804]         }
[17:46:46.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.804]             base::sink(type = "output", split = FALSE)
[17:46:46.804]             base::close(...future.stdout)
[17:46:46.804]         }, add = TRUE)
[17:46:46.804]     }
[17:46:46.804]     ...future.frame <- base::sys.nframe()
[17:46:46.804]     ...future.conditions <- base::list()
[17:46:46.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.804]     if (FALSE) {
[17:46:46.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.804]     }
[17:46:46.804]     ...future.result <- base::tryCatch({
[17:46:46.804]         base::withCallingHandlers({
[17:46:46.804]             ...future.value <- base::withVisible(base::local({
[17:46:46.804]                 withCallingHandlers({
[17:46:46.804]                   NULL
[17:46:46.804]                 }, immediateCondition = function(cond) {
[17:46:46.804]                   save_rds <- function (object, pathname, ...) 
[17:46:46.804]                   {
[17:46:46.804]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.804]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.804]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.804]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.804]                         fi_tmp[["mtime"]])
[17:46:46.804]                     }
[17:46:46.804]                     tryCatch({
[17:46:46.804]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.804]                     }, error = function(ex) {
[17:46:46.804]                       msg <- conditionMessage(ex)
[17:46:46.804]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.804]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.804]                         fi_tmp[["mtime"]], msg)
[17:46:46.804]                       ex$message <- msg
[17:46:46.804]                       stop(ex)
[17:46:46.804]                     })
[17:46:46.804]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.804]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.804]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.804]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.804]                       fi <- file.info(pathname)
[17:46:46.804]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.804]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.804]                         fi[["size"]], fi[["mtime"]])
[17:46:46.804]                       stop(msg)
[17:46:46.804]                     }
[17:46:46.804]                     invisible(pathname)
[17:46:46.804]                   }
[17:46:46.804]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.804]                     rootPath = tempdir()) 
[17:46:46.804]                   {
[17:46:46.804]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.804]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.804]                       tmpdir = path, fileext = ".rds")
[17:46:46.804]                     save_rds(obj, file)
[17:46:46.804]                   }
[17:46:46.804]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.804]                   {
[17:46:46.804]                     inherits <- base::inherits
[17:46:46.804]                     invokeRestart <- base::invokeRestart
[17:46:46.804]                     is.null <- base::is.null
[17:46:46.804]                     muffled <- FALSE
[17:46:46.804]                     if (inherits(cond, "message")) {
[17:46:46.804]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.804]                       if (muffled) 
[17:46:46.804]                         invokeRestart("muffleMessage")
[17:46:46.804]                     }
[17:46:46.804]                     else if (inherits(cond, "warning")) {
[17:46:46.804]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.804]                       if (muffled) 
[17:46:46.804]                         invokeRestart("muffleWarning")
[17:46:46.804]                     }
[17:46:46.804]                     else if (inherits(cond, "condition")) {
[17:46:46.804]                       if (!is.null(pattern)) {
[17:46:46.804]                         computeRestarts <- base::computeRestarts
[17:46:46.804]                         grepl <- base::grepl
[17:46:46.804]                         restarts <- computeRestarts(cond)
[17:46:46.804]                         for (restart in restarts) {
[17:46:46.804]                           name <- restart$name
[17:46:46.804]                           if (is.null(name)) 
[17:46:46.804]                             next
[17:46:46.804]                           if (!grepl(pattern, name)) 
[17:46:46.804]                             next
[17:46:46.804]                           invokeRestart(restart)
[17:46:46.804]                           muffled <- TRUE
[17:46:46.804]                           break
[17:46:46.804]                         }
[17:46:46.804]                       }
[17:46:46.804]                     }
[17:46:46.804]                     invisible(muffled)
[17:46:46.804]                   }
[17:46:46.804]                   muffleCondition(cond)
[17:46:46.804]                 })
[17:46:46.804]             }))
[17:46:46.804]             future::FutureResult(value = ...future.value$value, 
[17:46:46.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.804]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.804]                     ...future.globalenv.names))
[17:46:46.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.804]         }, condition = base::local({
[17:46:46.804]             c <- base::c
[17:46:46.804]             inherits <- base::inherits
[17:46:46.804]             invokeRestart <- base::invokeRestart
[17:46:46.804]             length <- base::length
[17:46:46.804]             list <- base::list
[17:46:46.804]             seq.int <- base::seq.int
[17:46:46.804]             signalCondition <- base::signalCondition
[17:46:46.804]             sys.calls <- base::sys.calls
[17:46:46.804]             `[[` <- base::`[[`
[17:46:46.804]             `+` <- base::`+`
[17:46:46.804]             `<<-` <- base::`<<-`
[17:46:46.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.804]                   3L)]
[17:46:46.804]             }
[17:46:46.804]             function(cond) {
[17:46:46.804]                 is_error <- inherits(cond, "error")
[17:46:46.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.804]                   NULL)
[17:46:46.804]                 if (is_error) {
[17:46:46.804]                   sessionInformation <- function() {
[17:46:46.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.804]                       search = base::search(), system = base::Sys.info())
[17:46:46.804]                   }
[17:46:46.804]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.804]                     cond$call), session = sessionInformation(), 
[17:46:46.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.804]                   signalCondition(cond)
[17:46:46.804]                 }
[17:46:46.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.804]                 "immediateCondition"))) {
[17:46:46.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.804]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.804]                   if (TRUE && !signal) {
[17:46:46.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.804]                     {
[17:46:46.804]                       inherits <- base::inherits
[17:46:46.804]                       invokeRestart <- base::invokeRestart
[17:46:46.804]                       is.null <- base::is.null
[17:46:46.804]                       muffled <- FALSE
[17:46:46.804]                       if (inherits(cond, "message")) {
[17:46:46.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.804]                         if (muffled) 
[17:46:46.804]                           invokeRestart("muffleMessage")
[17:46:46.804]                       }
[17:46:46.804]                       else if (inherits(cond, "warning")) {
[17:46:46.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.804]                         if (muffled) 
[17:46:46.804]                           invokeRestart("muffleWarning")
[17:46:46.804]                       }
[17:46:46.804]                       else if (inherits(cond, "condition")) {
[17:46:46.804]                         if (!is.null(pattern)) {
[17:46:46.804]                           computeRestarts <- base::computeRestarts
[17:46:46.804]                           grepl <- base::grepl
[17:46:46.804]                           restarts <- computeRestarts(cond)
[17:46:46.804]                           for (restart in restarts) {
[17:46:46.804]                             name <- restart$name
[17:46:46.804]                             if (is.null(name)) 
[17:46:46.804]                               next
[17:46:46.804]                             if (!grepl(pattern, name)) 
[17:46:46.804]                               next
[17:46:46.804]                             invokeRestart(restart)
[17:46:46.804]                             muffled <- TRUE
[17:46:46.804]                             break
[17:46:46.804]                           }
[17:46:46.804]                         }
[17:46:46.804]                       }
[17:46:46.804]                       invisible(muffled)
[17:46:46.804]                     }
[17:46:46.804]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.804]                   }
[17:46:46.804]                 }
[17:46:46.804]                 else {
[17:46:46.804]                   if (TRUE) {
[17:46:46.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.804]                     {
[17:46:46.804]                       inherits <- base::inherits
[17:46:46.804]                       invokeRestart <- base::invokeRestart
[17:46:46.804]                       is.null <- base::is.null
[17:46:46.804]                       muffled <- FALSE
[17:46:46.804]                       if (inherits(cond, "message")) {
[17:46:46.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.804]                         if (muffled) 
[17:46:46.804]                           invokeRestart("muffleMessage")
[17:46:46.804]                       }
[17:46:46.804]                       else if (inherits(cond, "warning")) {
[17:46:46.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.804]                         if (muffled) 
[17:46:46.804]                           invokeRestart("muffleWarning")
[17:46:46.804]                       }
[17:46:46.804]                       else if (inherits(cond, "condition")) {
[17:46:46.804]                         if (!is.null(pattern)) {
[17:46:46.804]                           computeRestarts <- base::computeRestarts
[17:46:46.804]                           grepl <- base::grepl
[17:46:46.804]                           restarts <- computeRestarts(cond)
[17:46:46.804]                           for (restart in restarts) {
[17:46:46.804]                             name <- restart$name
[17:46:46.804]                             if (is.null(name)) 
[17:46:46.804]                               next
[17:46:46.804]                             if (!grepl(pattern, name)) 
[17:46:46.804]                               next
[17:46:46.804]                             invokeRestart(restart)
[17:46:46.804]                             muffled <- TRUE
[17:46:46.804]                             break
[17:46:46.804]                           }
[17:46:46.804]                         }
[17:46:46.804]                       }
[17:46:46.804]                       invisible(muffled)
[17:46:46.804]                     }
[17:46:46.804]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.804]                   }
[17:46:46.804]                 }
[17:46:46.804]             }
[17:46:46.804]         }))
[17:46:46.804]     }, error = function(ex) {
[17:46:46.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.804]                 ...future.rng), started = ...future.startTime, 
[17:46:46.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.804]             version = "1.8"), class = "FutureResult")
[17:46:46.804]     }, finally = {
[17:46:46.804]         if (!identical(...future.workdir, getwd())) 
[17:46:46.804]             setwd(...future.workdir)
[17:46:46.804]         {
[17:46:46.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.804]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.804]             }
[17:46:46.804]             base::options(...future.oldOptions)
[17:46:46.804]             if (.Platform$OS.type == "windows") {
[17:46:46.804]                 old_names <- names(...future.oldEnvVars)
[17:46:46.804]                 envs <- base::Sys.getenv()
[17:46:46.804]                 names <- names(envs)
[17:46:46.804]                 common <- intersect(names, old_names)
[17:46:46.804]                 added <- setdiff(names, old_names)
[17:46:46.804]                 removed <- setdiff(old_names, names)
[17:46:46.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.804]                   envs[common]]
[17:46:46.804]                 NAMES <- toupper(changed)
[17:46:46.804]                 args <- list()
[17:46:46.804]                 for (kk in seq_along(NAMES)) {
[17:46:46.804]                   name <- changed[[kk]]
[17:46:46.804]                   NAME <- NAMES[[kk]]
[17:46:46.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.804]                     next
[17:46:46.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.804]                 }
[17:46:46.804]                 NAMES <- toupper(added)
[17:46:46.804]                 for (kk in seq_along(NAMES)) {
[17:46:46.804]                   name <- added[[kk]]
[17:46:46.804]                   NAME <- NAMES[[kk]]
[17:46:46.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.804]                     next
[17:46:46.804]                   args[[name]] <- ""
[17:46:46.804]                 }
[17:46:46.804]                 NAMES <- toupper(removed)
[17:46:46.804]                 for (kk in seq_along(NAMES)) {
[17:46:46.804]                   name <- removed[[kk]]
[17:46:46.804]                   NAME <- NAMES[[kk]]
[17:46:46.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.804]                     next
[17:46:46.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.804]                 }
[17:46:46.804]                 if (length(args) > 0) 
[17:46:46.804]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.804]             }
[17:46:46.804]             else {
[17:46:46.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.804]             }
[17:46:46.804]             {
[17:46:46.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.804]                   0L) {
[17:46:46.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.804]                   base::options(opts)
[17:46:46.804]                 }
[17:46:46.804]                 {
[17:46:46.804]                   {
[17:46:46.804]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.804]                     NULL
[17:46:46.804]                   }
[17:46:46.804]                   options(future.plan = NULL)
[17:46:46.804]                   if (is.na(NA_character_)) 
[17:46:46.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.804]                     .init = FALSE)
[17:46:46.804]                 }
[17:46:46.804]             }
[17:46:46.804]         }
[17:46:46.804]     })
[17:46:46.804]     if (TRUE) {
[17:46:46.804]         base::sink(type = "output", split = FALSE)
[17:46:46.804]         if (TRUE) {
[17:46:46.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.804]         }
[17:46:46.804]         else {
[17:46:46.804]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.804]         }
[17:46:46.804]         base::close(...future.stdout)
[17:46:46.804]         ...future.stdout <- NULL
[17:46:46.804]     }
[17:46:46.804]     ...future.result$conditions <- ...future.conditions
[17:46:46.804]     ...future.result$finished <- base::Sys.time()
[17:46:46.804]     ...future.result
[17:46:46.804] }
[17:46:46.807] requestCore(): workers = 2
[17:46:46.809] MulticoreFuture started
[17:46:46.809] - Launch lazy future ... done
[17:46:46.810] run() for ‘MulticoreFuture’ ... done
[17:46:46.810] plan(): Setting new future strategy stack:
[17:46:46.810] getGlobalsAndPackages() ...
[17:46:46.811] Searching for globals...
[17:46:46.810] List of future strategies:
[17:46:46.810] 1. sequential:
[17:46:46.810]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.810]    - tweaked: FALSE
[17:46:46.810]    - call: NULL
[17:46:46.811] plan(): nbrOfWorkers() = 1
[17:46:46.812] - globals found: [1] ‘{’
[17:46:46.812] Searching for globals ... DONE
[17:46:46.812] Resolving globals: FALSE
[17:46:46.813] 
[17:46:46.813] 
[17:46:46.813] getGlobalsAndPackages() ... DONE
[17:46:46.813] plan(): Setting new future strategy stack:
[17:46:46.814] run() for ‘Future’ ...
[17:46:46.814] List of future strategies:
[17:46:46.814] 1. multicore:
[17:46:46.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.814]    - tweaked: FALSE
[17:46:46.814]    - call: plan(strategy)
[17:46:46.814] - state: ‘created’
[17:46:46.814] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.820] plan(): nbrOfWorkers() = 2
[17:46:46.820] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.821]   - Field: ‘label’
[17:46:46.821]   - Field: ‘local’
[17:46:46.821]   - Field: ‘owner’
[17:46:46.821]   - Field: ‘envir’
[17:46:46.821]   - Field: ‘workers’
[17:46:46.821]   - Field: ‘packages’
[17:46:46.821]   - Field: ‘gc’
[17:46:46.821]   - Field: ‘job’
[17:46:46.822]   - Field: ‘conditions’
[17:46:46.822]   - Field: ‘expr’
[17:46:46.822]   - Field: ‘uuid’
[17:46:46.822]   - Field: ‘seed’
[17:46:46.822]   - Field: ‘version’
[17:46:46.822]   - Field: ‘result’
[17:46:46.822]   - Field: ‘asynchronous’
[17:46:46.823]   - Field: ‘calls’
[17:46:46.823]   - Field: ‘globals’
[17:46:46.823]   - Field: ‘stdout’
[17:46:46.823]   - Field: ‘earlySignal’
[17:46:46.823]   - Field: ‘lazy’
[17:46:46.823]   - Field: ‘state’
[17:46:46.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.824] - Launch lazy future ...
[17:46:46.824] Packages needed by the future expression (n = 0): <none>
[17:46:46.824] Packages needed by future strategies (n = 0): <none>
[17:46:46.825] {
[17:46:46.825]     {
[17:46:46.825]         {
[17:46:46.825]             ...future.startTime <- base::Sys.time()
[17:46:46.825]             {
[17:46:46.825]                 {
[17:46:46.825]                   {
[17:46:46.825]                     {
[17:46:46.825]                       base::local({
[17:46:46.825]                         has_future <- base::requireNamespace("future", 
[17:46:46.825]                           quietly = TRUE)
[17:46:46.825]                         if (has_future) {
[17:46:46.825]                           ns <- base::getNamespace("future")
[17:46:46.825]                           version <- ns[[".package"]][["version"]]
[17:46:46.825]                           if (is.null(version)) 
[17:46:46.825]                             version <- utils::packageVersion("future")
[17:46:46.825]                         }
[17:46:46.825]                         else {
[17:46:46.825]                           version <- NULL
[17:46:46.825]                         }
[17:46:46.825]                         if (!has_future || version < "1.8.0") {
[17:46:46.825]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.825]                             "", base::R.version$version.string), 
[17:46:46.825]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.825]                               "release", "version")], collapse = " "), 
[17:46:46.825]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.825]                             info)
[17:46:46.825]                           info <- base::paste(info, collapse = "; ")
[17:46:46.825]                           if (!has_future) {
[17:46:46.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.825]                               info)
[17:46:46.825]                           }
[17:46:46.825]                           else {
[17:46:46.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.825]                               info, version)
[17:46:46.825]                           }
[17:46:46.825]                           base::stop(msg)
[17:46:46.825]                         }
[17:46:46.825]                       })
[17:46:46.825]                     }
[17:46:46.825]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.825]                     base::options(mc.cores = 1L)
[17:46:46.825]                   }
[17:46:46.825]                   ...future.strategy.old <- future::plan("list")
[17:46:46.825]                   options(future.plan = NULL)
[17:46:46.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.825]                 }
[17:46:46.825]                 ...future.workdir <- getwd()
[17:46:46.825]             }
[17:46:46.825]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.825]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.825]         }
[17:46:46.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.825]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.825]             base::names(...future.oldOptions))
[17:46:46.825]     }
[17:46:46.825]     if (FALSE) {
[17:46:46.825]     }
[17:46:46.825]     else {
[17:46:46.825]         if (TRUE) {
[17:46:46.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.825]                 open = "w")
[17:46:46.825]         }
[17:46:46.825]         else {
[17:46:46.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.825]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.825]         }
[17:46:46.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.825]             base::sink(type = "output", split = FALSE)
[17:46:46.825]             base::close(...future.stdout)
[17:46:46.825]         }, add = TRUE)
[17:46:46.825]     }
[17:46:46.825]     ...future.frame <- base::sys.nframe()
[17:46:46.825]     ...future.conditions <- base::list()
[17:46:46.825]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.825]     if (FALSE) {
[17:46:46.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.825]     }
[17:46:46.825]     ...future.result <- base::tryCatch({
[17:46:46.825]         base::withCallingHandlers({
[17:46:46.825]             ...future.value <- base::withVisible(base::local({
[17:46:46.825]                 withCallingHandlers({
[17:46:46.825]                   {
[17:46:46.825]                     4
[17:46:46.825]                   }
[17:46:46.825]                 }, immediateCondition = function(cond) {
[17:46:46.825]                   save_rds <- function (object, pathname, ...) 
[17:46:46.825]                   {
[17:46:46.825]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.825]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.825]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.825]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.825]                         fi_tmp[["mtime"]])
[17:46:46.825]                     }
[17:46:46.825]                     tryCatch({
[17:46:46.825]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.825]                     }, error = function(ex) {
[17:46:46.825]                       msg <- conditionMessage(ex)
[17:46:46.825]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.825]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.825]                         fi_tmp[["mtime"]], msg)
[17:46:46.825]                       ex$message <- msg
[17:46:46.825]                       stop(ex)
[17:46:46.825]                     })
[17:46:46.825]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.825]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.825]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.825]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.825]                       fi <- file.info(pathname)
[17:46:46.825]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.825]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.825]                         fi[["size"]], fi[["mtime"]])
[17:46:46.825]                       stop(msg)
[17:46:46.825]                     }
[17:46:46.825]                     invisible(pathname)
[17:46:46.825]                   }
[17:46:46.825]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.825]                     rootPath = tempdir()) 
[17:46:46.825]                   {
[17:46:46.825]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.825]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.825]                       tmpdir = path, fileext = ".rds")
[17:46:46.825]                     save_rds(obj, file)
[17:46:46.825]                   }
[17:46:46.825]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.825]                   {
[17:46:46.825]                     inherits <- base::inherits
[17:46:46.825]                     invokeRestart <- base::invokeRestart
[17:46:46.825]                     is.null <- base::is.null
[17:46:46.825]                     muffled <- FALSE
[17:46:46.825]                     if (inherits(cond, "message")) {
[17:46:46.825]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.825]                       if (muffled) 
[17:46:46.825]                         invokeRestart("muffleMessage")
[17:46:46.825]                     }
[17:46:46.825]                     else if (inherits(cond, "warning")) {
[17:46:46.825]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.825]                       if (muffled) 
[17:46:46.825]                         invokeRestart("muffleWarning")
[17:46:46.825]                     }
[17:46:46.825]                     else if (inherits(cond, "condition")) {
[17:46:46.825]                       if (!is.null(pattern)) {
[17:46:46.825]                         computeRestarts <- base::computeRestarts
[17:46:46.825]                         grepl <- base::grepl
[17:46:46.825]                         restarts <- computeRestarts(cond)
[17:46:46.825]                         for (restart in restarts) {
[17:46:46.825]                           name <- restart$name
[17:46:46.825]                           if (is.null(name)) 
[17:46:46.825]                             next
[17:46:46.825]                           if (!grepl(pattern, name)) 
[17:46:46.825]                             next
[17:46:46.825]                           invokeRestart(restart)
[17:46:46.825]                           muffled <- TRUE
[17:46:46.825]                           break
[17:46:46.825]                         }
[17:46:46.825]                       }
[17:46:46.825]                     }
[17:46:46.825]                     invisible(muffled)
[17:46:46.825]                   }
[17:46:46.825]                   muffleCondition(cond)
[17:46:46.825]                 })
[17:46:46.825]             }))
[17:46:46.825]             future::FutureResult(value = ...future.value$value, 
[17:46:46.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.825]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.825]                     ...future.globalenv.names))
[17:46:46.825]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.825]         }, condition = base::local({
[17:46:46.825]             c <- base::c
[17:46:46.825]             inherits <- base::inherits
[17:46:46.825]             invokeRestart <- base::invokeRestart
[17:46:46.825]             length <- base::length
[17:46:46.825]             list <- base::list
[17:46:46.825]             seq.int <- base::seq.int
[17:46:46.825]             signalCondition <- base::signalCondition
[17:46:46.825]             sys.calls <- base::sys.calls
[17:46:46.825]             `[[` <- base::`[[`
[17:46:46.825]             `+` <- base::`+`
[17:46:46.825]             `<<-` <- base::`<<-`
[17:46:46.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.825]                   3L)]
[17:46:46.825]             }
[17:46:46.825]             function(cond) {
[17:46:46.825]                 is_error <- inherits(cond, "error")
[17:46:46.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.825]                   NULL)
[17:46:46.825]                 if (is_error) {
[17:46:46.825]                   sessionInformation <- function() {
[17:46:46.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.825]                       search = base::search(), system = base::Sys.info())
[17:46:46.825]                   }
[17:46:46.825]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.825]                     cond$call), session = sessionInformation(), 
[17:46:46.825]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.825]                   signalCondition(cond)
[17:46:46.825]                 }
[17:46:46.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.825]                 "immediateCondition"))) {
[17:46:46.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.825]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.825]                   if (TRUE && !signal) {
[17:46:46.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.825]                     {
[17:46:46.825]                       inherits <- base::inherits
[17:46:46.825]                       invokeRestart <- base::invokeRestart
[17:46:46.825]                       is.null <- base::is.null
[17:46:46.825]                       muffled <- FALSE
[17:46:46.825]                       if (inherits(cond, "message")) {
[17:46:46.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.825]                         if (muffled) 
[17:46:46.825]                           invokeRestart("muffleMessage")
[17:46:46.825]                       }
[17:46:46.825]                       else if (inherits(cond, "warning")) {
[17:46:46.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.825]                         if (muffled) 
[17:46:46.825]                           invokeRestart("muffleWarning")
[17:46:46.825]                       }
[17:46:46.825]                       else if (inherits(cond, "condition")) {
[17:46:46.825]                         if (!is.null(pattern)) {
[17:46:46.825]                           computeRestarts <- base::computeRestarts
[17:46:46.825]                           grepl <- base::grepl
[17:46:46.825]                           restarts <- computeRestarts(cond)
[17:46:46.825]                           for (restart in restarts) {
[17:46:46.825]                             name <- restart$name
[17:46:46.825]                             if (is.null(name)) 
[17:46:46.825]                               next
[17:46:46.825]                             if (!grepl(pattern, name)) 
[17:46:46.825]                               next
[17:46:46.825]                             invokeRestart(restart)
[17:46:46.825]                             muffled <- TRUE
[17:46:46.825]                             break
[17:46:46.825]                           }
[17:46:46.825]                         }
[17:46:46.825]                       }
[17:46:46.825]                       invisible(muffled)
[17:46:46.825]                     }
[17:46:46.825]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.825]                   }
[17:46:46.825]                 }
[17:46:46.825]                 else {
[17:46:46.825]                   if (TRUE) {
[17:46:46.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.825]                     {
[17:46:46.825]                       inherits <- base::inherits
[17:46:46.825]                       invokeRestart <- base::invokeRestart
[17:46:46.825]                       is.null <- base::is.null
[17:46:46.825]                       muffled <- FALSE
[17:46:46.825]                       if (inherits(cond, "message")) {
[17:46:46.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.825]                         if (muffled) 
[17:46:46.825]                           invokeRestart("muffleMessage")
[17:46:46.825]                       }
[17:46:46.825]                       else if (inherits(cond, "warning")) {
[17:46:46.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.825]                         if (muffled) 
[17:46:46.825]                           invokeRestart("muffleWarning")
[17:46:46.825]                       }
[17:46:46.825]                       else if (inherits(cond, "condition")) {
[17:46:46.825]                         if (!is.null(pattern)) {
[17:46:46.825]                           computeRestarts <- base::computeRestarts
[17:46:46.825]                           grepl <- base::grepl
[17:46:46.825]                           restarts <- computeRestarts(cond)
[17:46:46.825]                           for (restart in restarts) {
[17:46:46.825]                             name <- restart$name
[17:46:46.825]                             if (is.null(name)) 
[17:46:46.825]                               next
[17:46:46.825]                             if (!grepl(pattern, name)) 
[17:46:46.825]                               next
[17:46:46.825]                             invokeRestart(restart)
[17:46:46.825]                             muffled <- TRUE
[17:46:46.825]                             break
[17:46:46.825]                           }
[17:46:46.825]                         }
[17:46:46.825]                       }
[17:46:46.825]                       invisible(muffled)
[17:46:46.825]                     }
[17:46:46.825]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.825]                   }
[17:46:46.825]                 }
[17:46:46.825]             }
[17:46:46.825]         }))
[17:46:46.825]     }, error = function(ex) {
[17:46:46.825]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.825]                 ...future.rng), started = ...future.startTime, 
[17:46:46.825]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.825]             version = "1.8"), class = "FutureResult")
[17:46:46.825]     }, finally = {
[17:46:46.825]         if (!identical(...future.workdir, getwd())) 
[17:46:46.825]             setwd(...future.workdir)
[17:46:46.825]         {
[17:46:46.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.825]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.825]             }
[17:46:46.825]             base::options(...future.oldOptions)
[17:46:46.825]             if (.Platform$OS.type == "windows") {
[17:46:46.825]                 old_names <- names(...future.oldEnvVars)
[17:46:46.825]                 envs <- base::Sys.getenv()
[17:46:46.825]                 names <- names(envs)
[17:46:46.825]                 common <- intersect(names, old_names)
[17:46:46.825]                 added <- setdiff(names, old_names)
[17:46:46.825]                 removed <- setdiff(old_names, names)
[17:46:46.825]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.825]                   envs[common]]
[17:46:46.825]                 NAMES <- toupper(changed)
[17:46:46.825]                 args <- list()
[17:46:46.825]                 for (kk in seq_along(NAMES)) {
[17:46:46.825]                   name <- changed[[kk]]
[17:46:46.825]                   NAME <- NAMES[[kk]]
[17:46:46.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.825]                     next
[17:46:46.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.825]                 }
[17:46:46.825]                 NAMES <- toupper(added)
[17:46:46.825]                 for (kk in seq_along(NAMES)) {
[17:46:46.825]                   name <- added[[kk]]
[17:46:46.825]                   NAME <- NAMES[[kk]]
[17:46:46.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.825]                     next
[17:46:46.825]                   args[[name]] <- ""
[17:46:46.825]                 }
[17:46:46.825]                 NAMES <- toupper(removed)
[17:46:46.825]                 for (kk in seq_along(NAMES)) {
[17:46:46.825]                   name <- removed[[kk]]
[17:46:46.825]                   NAME <- NAMES[[kk]]
[17:46:46.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.825]                     next
[17:46:46.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.825]                 }
[17:46:46.825]                 if (length(args) > 0) 
[17:46:46.825]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.825]             }
[17:46:46.825]             else {
[17:46:46.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.825]             }
[17:46:46.825]             {
[17:46:46.825]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.825]                   0L) {
[17:46:46.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.825]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.825]                   base::options(opts)
[17:46:46.825]                 }
[17:46:46.825]                 {
[17:46:46.825]                   {
[17:46:46.825]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.825]                     NULL
[17:46:46.825]                   }
[17:46:46.825]                   options(future.plan = NULL)
[17:46:46.825]                   if (is.na(NA_character_)) 
[17:46:46.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.825]                     .init = FALSE)
[17:46:46.825]                 }
[17:46:46.825]             }
[17:46:46.825]         }
[17:46:46.825]     })
[17:46:46.825]     if (TRUE) {
[17:46:46.825]         base::sink(type = "output", split = FALSE)
[17:46:46.825]         if (TRUE) {
[17:46:46.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.825]         }
[17:46:46.825]         else {
[17:46:46.825]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.825]         }
[17:46:46.825]         base::close(...future.stdout)
[17:46:46.825]         ...future.stdout <- NULL
[17:46:46.825]     }
[17:46:46.825]     ...future.result$conditions <- ...future.conditions
[17:46:46.825]     ...future.result$finished <- base::Sys.time()
[17:46:46.825]     ...future.result
[17:46:46.825] }
[17:46:46.828] requestCore(): workers = 2
[17:46:46.829] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:46.839] result() for MulticoreFuture ...
[17:46:46.840] result() for MulticoreFuture ...
[17:46:46.841] result() for MulticoreFuture ... done
[17:46:46.841] result() for MulticoreFuture ... done
[17:46:46.841] result() for MulticoreFuture ...
[17:46:46.841] result() for MulticoreFuture ... done
[17:46:46.844] MulticoreFuture started
[17:46:46.844] - Launch lazy future ... done
[17:46:46.844] run() for ‘MulticoreFuture’ ... done
[17:46:46.845] plan(): Setting new future strategy stack:
<environment: 0x5617899e8878> 
[17:46:46.845] List of future strategies:
[17:46:46.845] 1. sequential:
[17:46:46.845]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.845]    - tweaked: FALSE
[17:46:46.845]    - call: NULL
[17:46:46.847] plan(): nbrOfWorkers() = 1
<environment: 0x561787924ec8> 
[17:46:46.849] plan(): Setting new future strategy stack:
[17:46:46.849] List of future strategies:
[17:46:46.849] 1. multicore:
[17:46:46.849]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.849]    - tweaked: FALSE
[17:46:46.849]    - call: plan(strategy)
[17:46:46.855] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:46.857] resolve() on environment ...
[17:46:46.858]  recursive: 0
[17:46:46.858]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:46.859] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.859] - nx: 4
[17:46:46.859] - relay: TRUE
[17:46:46.859] - stdout: TRUE
[17:46:46.859] - signal: TRUE
[17:46:46.859] - resignal: FALSE
[17:46:46.859] - force: TRUE
[17:46:46.859] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.860] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.860]  - until=2
[17:46:46.860]  - relaying element #2
[17:46:46.860] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.860] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.860] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.860]  length: 3 (resolved future 1)
[17:46:46.861] Future #2
[17:46:46.861] result() for MulticoreFuture ...
[17:46:46.861] result() for MulticoreFuture ... done
[17:46:46.861] result() for MulticoreFuture ...
[17:46:46.861] result() for MulticoreFuture ... done
[17:46:46.861] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:46.862] - nx: 4
[17:46:46.862] - relay: TRUE
[17:46:46.862] - stdout: TRUE
[17:46:46.862] - signal: TRUE
[17:46:46.862] - resignal: FALSE
[17:46:46.862] - force: TRUE
[17:46:46.862] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.862] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.863]  - until=2
[17:46:46.863]  - relaying element #2
[17:46:46.863] result() for MulticoreFuture ...
[17:46:46.863] result() for MulticoreFuture ... done
[17:46:46.863] result() for MulticoreFuture ...
[17:46:46.863] result() for MulticoreFuture ... done
[17:46:46.864] result() for MulticoreFuture ...
[17:46:46.864] result() for MulticoreFuture ... done
[17:46:46.864] result() for MulticoreFuture ...
[17:46:46.864] result() for MulticoreFuture ... done
[17:46:46.864] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.864] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.865] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:46.865]  length: 2 (resolved future 2)
[17:46:46.865] Future #3
[17:46:46.865] result() for MulticoreFuture ...
[17:46:46.866] result() for MulticoreFuture ...
[17:46:46.866] result() for MulticoreFuture ... done
[17:46:46.867] result() for MulticoreFuture ... done
[17:46:46.867] result() for MulticoreFuture ...
[17:46:46.867] result() for MulticoreFuture ... done
[17:46:46.867] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:46.867] - nx: 4
[17:46:46.868] - relay: TRUE
[17:46:46.868] - stdout: TRUE
[17:46:46.868] - signal: TRUE
[17:46:46.868] - resignal: FALSE
[17:46:46.868] - force: TRUE
[17:46:46.869] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.869] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.869]  - until=3
[17:46:46.869]  - relaying element #3
[17:46:46.870] result() for MulticoreFuture ...
[17:46:46.870] result() for MulticoreFuture ... done
[17:46:46.870] result() for MulticoreFuture ...
[17:46:46.870] result() for MulticoreFuture ... done
[17:46:46.870] result() for MulticoreFuture ...
[17:46:46.871] result() for MulticoreFuture ... done
[17:46:46.871] result() for MulticoreFuture ...
[17:46:46.871] result() for MulticoreFuture ... done
[17:46:46.871] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.871] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.871] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:46.872]  length: 1 (resolved future 3)
[17:46:46.872] Future #4
[17:46:46.872] result() for MulticoreFuture ...
[17:46:46.873] result() for MulticoreFuture ...
[17:46:46.873] result() for MulticoreFuture ... done
[17:46:46.873] result() for MulticoreFuture ... done
[17:46:46.874] result() for MulticoreFuture ...
[17:46:46.874] result() for MulticoreFuture ... done
[17:46:46.874] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:46.874] - nx: 4
[17:46:46.874] - relay: TRUE
[17:46:46.875] - stdout: TRUE
[17:46:46.875] - signal: TRUE
[17:46:46.875] - resignal: FALSE
[17:46:46.875] - force: TRUE
[17:46:46.875] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.875] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.876]  - until=4
[17:46:46.876]  - relaying element #4
[17:46:46.876] result() for MulticoreFuture ...
[17:46:46.876] result() for MulticoreFuture ... done
[17:46:46.876] result() for MulticoreFuture ...
[17:46:46.876] result() for MulticoreFuture ... done
[17:46:46.877] result() for MulticoreFuture ...
[17:46:46.877] result() for MulticoreFuture ... done
[17:46:46.877] result() for MulticoreFuture ...
[17:46:46.877] result() for MulticoreFuture ... done
[17:46:46.877] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.877] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.877] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:46.877]  length: 0 (resolved future 4)
[17:46:46.878] Relaying remaining futures
[17:46:46.878] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.878] - nx: 4
[17:46:46.878] - relay: TRUE
[17:46:46.878] - stdout: TRUE
[17:46:46.878] - signal: TRUE
[17:46:46.878] - resignal: FALSE
[17:46:46.878] - force: TRUE
[17:46:46.878] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.879] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:46.879] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.879] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.879] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.879] resolve() on environment ... DONE
[17:46:46.879] result() for MulticoreFuture ...
[17:46:46.879] result() for MulticoreFuture ... done
[17:46:46.879] result() for MulticoreFuture ...
[17:46:46.880] result() for MulticoreFuture ... done
[17:46:46.880] result() for MulticoreFuture ...
[17:46:46.880] result() for MulticoreFuture ... done
[17:46:46.880] result() for MulticoreFuture ...
[17:46:46.880] result() for MulticoreFuture ... done
[17:46:46.880] result() for MulticoreFuture ...
[17:46:46.880] result() for MulticoreFuture ... done
[17:46:46.880] result() for MulticoreFuture ...
[17:46:46.880] result() for MulticoreFuture ... done
<environment: 0x5617876dedf8> 
Dimensions: c(2, 3, 1)
[17:46:46.881] getGlobalsAndPackages() ...
[17:46:46.881] Searching for globals...
[17:46:46.882] 
[17:46:46.882] Searching for globals ... DONE
[17:46:46.882] - globals: [0] <none>
[17:46:46.882] getGlobalsAndPackages() ... DONE
[17:46:46.882] run() for ‘Future’ ...
[17:46:46.882] - state: ‘created’
[17:46:46.882] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.886] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.887]   - Field: ‘label’
[17:46:46.887]   - Field: ‘local’
[17:46:46.887]   - Field: ‘owner’
[17:46:46.887]   - Field: ‘envir’
[17:46:46.887]   - Field: ‘workers’
[17:46:46.887]   - Field: ‘packages’
[17:46:46.887]   - Field: ‘gc’
[17:46:46.888]   - Field: ‘job’
[17:46:46.888]   - Field: ‘conditions’
[17:46:46.888]   - Field: ‘expr’
[17:46:46.888]   - Field: ‘uuid’
[17:46:46.888]   - Field: ‘seed’
[17:46:46.888]   - Field: ‘version’
[17:46:46.888]   - Field: ‘result’
[17:46:46.888]   - Field: ‘asynchronous’
[17:46:46.888]   - Field: ‘calls’
[17:46:46.889]   - Field: ‘globals’
[17:46:46.889]   - Field: ‘stdout’
[17:46:46.889]   - Field: ‘earlySignal’
[17:46:46.889]   - Field: ‘lazy’
[17:46:46.889]   - Field: ‘state’
[17:46:46.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.889] - Launch lazy future ...
[17:46:46.890] Packages needed by the future expression (n = 0): <none>
[17:46:46.890] Packages needed by future strategies (n = 0): <none>
[17:46:46.890] {
[17:46:46.890]     {
[17:46:46.890]         {
[17:46:46.890]             ...future.startTime <- base::Sys.time()
[17:46:46.890]             {
[17:46:46.890]                 {
[17:46:46.890]                   {
[17:46:46.890]                     {
[17:46:46.890]                       base::local({
[17:46:46.890]                         has_future <- base::requireNamespace("future", 
[17:46:46.890]                           quietly = TRUE)
[17:46:46.890]                         if (has_future) {
[17:46:46.890]                           ns <- base::getNamespace("future")
[17:46:46.890]                           version <- ns[[".package"]][["version"]]
[17:46:46.890]                           if (is.null(version)) 
[17:46:46.890]                             version <- utils::packageVersion("future")
[17:46:46.890]                         }
[17:46:46.890]                         else {
[17:46:46.890]                           version <- NULL
[17:46:46.890]                         }
[17:46:46.890]                         if (!has_future || version < "1.8.0") {
[17:46:46.890]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.890]                             "", base::R.version$version.string), 
[17:46:46.890]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.890]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.890]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.890]                               "release", "version")], collapse = " "), 
[17:46:46.890]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.890]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.890]                             info)
[17:46:46.890]                           info <- base::paste(info, collapse = "; ")
[17:46:46.890]                           if (!has_future) {
[17:46:46.890]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.890]                               info)
[17:46:46.890]                           }
[17:46:46.890]                           else {
[17:46:46.890]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.890]                               info, version)
[17:46:46.890]                           }
[17:46:46.890]                           base::stop(msg)
[17:46:46.890]                         }
[17:46:46.890]                       })
[17:46:46.890]                     }
[17:46:46.890]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.890]                     base::options(mc.cores = 1L)
[17:46:46.890]                   }
[17:46:46.890]                   ...future.strategy.old <- future::plan("list")
[17:46:46.890]                   options(future.plan = NULL)
[17:46:46.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.890]                 }
[17:46:46.890]                 ...future.workdir <- getwd()
[17:46:46.890]             }
[17:46:46.890]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.890]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.890]         }
[17:46:46.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.890]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.890]             base::names(...future.oldOptions))
[17:46:46.890]     }
[17:46:46.890]     if (FALSE) {
[17:46:46.890]     }
[17:46:46.890]     else {
[17:46:46.890]         if (TRUE) {
[17:46:46.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.890]                 open = "w")
[17:46:46.890]         }
[17:46:46.890]         else {
[17:46:46.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.890]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.890]         }
[17:46:46.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.890]             base::sink(type = "output", split = FALSE)
[17:46:46.890]             base::close(...future.stdout)
[17:46:46.890]         }, add = TRUE)
[17:46:46.890]     }
[17:46:46.890]     ...future.frame <- base::sys.nframe()
[17:46:46.890]     ...future.conditions <- base::list()
[17:46:46.890]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.890]     if (FALSE) {
[17:46:46.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.890]     }
[17:46:46.890]     ...future.result <- base::tryCatch({
[17:46:46.890]         base::withCallingHandlers({
[17:46:46.890]             ...future.value <- base::withVisible(base::local({
[17:46:46.890]                 withCallingHandlers({
[17:46:46.890]                   2
[17:46:46.890]                 }, immediateCondition = function(cond) {
[17:46:46.890]                   save_rds <- function (object, pathname, ...) 
[17:46:46.890]                   {
[17:46:46.890]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.890]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.890]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.890]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.890]                         fi_tmp[["mtime"]])
[17:46:46.890]                     }
[17:46:46.890]                     tryCatch({
[17:46:46.890]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.890]                     }, error = function(ex) {
[17:46:46.890]                       msg <- conditionMessage(ex)
[17:46:46.890]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.890]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.890]                         fi_tmp[["mtime"]], msg)
[17:46:46.890]                       ex$message <- msg
[17:46:46.890]                       stop(ex)
[17:46:46.890]                     })
[17:46:46.890]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.890]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.890]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.890]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.890]                       fi <- file.info(pathname)
[17:46:46.890]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.890]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.890]                         fi[["size"]], fi[["mtime"]])
[17:46:46.890]                       stop(msg)
[17:46:46.890]                     }
[17:46:46.890]                     invisible(pathname)
[17:46:46.890]                   }
[17:46:46.890]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.890]                     rootPath = tempdir()) 
[17:46:46.890]                   {
[17:46:46.890]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.890]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.890]                       tmpdir = path, fileext = ".rds")
[17:46:46.890]                     save_rds(obj, file)
[17:46:46.890]                   }
[17:46:46.890]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.890]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.890]                   {
[17:46:46.890]                     inherits <- base::inherits
[17:46:46.890]                     invokeRestart <- base::invokeRestart
[17:46:46.890]                     is.null <- base::is.null
[17:46:46.890]                     muffled <- FALSE
[17:46:46.890]                     if (inherits(cond, "message")) {
[17:46:46.890]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.890]                       if (muffled) 
[17:46:46.890]                         invokeRestart("muffleMessage")
[17:46:46.890]                     }
[17:46:46.890]                     else if (inherits(cond, "warning")) {
[17:46:46.890]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.890]                       if (muffled) 
[17:46:46.890]                         invokeRestart("muffleWarning")
[17:46:46.890]                     }
[17:46:46.890]                     else if (inherits(cond, "condition")) {
[17:46:46.890]                       if (!is.null(pattern)) {
[17:46:46.890]                         computeRestarts <- base::computeRestarts
[17:46:46.890]                         grepl <- base::grepl
[17:46:46.890]                         restarts <- computeRestarts(cond)
[17:46:46.890]                         for (restart in restarts) {
[17:46:46.890]                           name <- restart$name
[17:46:46.890]                           if (is.null(name)) 
[17:46:46.890]                             next
[17:46:46.890]                           if (!grepl(pattern, name)) 
[17:46:46.890]                             next
[17:46:46.890]                           invokeRestart(restart)
[17:46:46.890]                           muffled <- TRUE
[17:46:46.890]                           break
[17:46:46.890]                         }
[17:46:46.890]                       }
[17:46:46.890]                     }
[17:46:46.890]                     invisible(muffled)
[17:46:46.890]                   }
[17:46:46.890]                   muffleCondition(cond)
[17:46:46.890]                 })
[17:46:46.890]             }))
[17:46:46.890]             future::FutureResult(value = ...future.value$value, 
[17:46:46.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.890]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.890]                     ...future.globalenv.names))
[17:46:46.890]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.890]         }, condition = base::local({
[17:46:46.890]             c <- base::c
[17:46:46.890]             inherits <- base::inherits
[17:46:46.890]             invokeRestart <- base::invokeRestart
[17:46:46.890]             length <- base::length
[17:46:46.890]             list <- base::list
[17:46:46.890]             seq.int <- base::seq.int
[17:46:46.890]             signalCondition <- base::signalCondition
[17:46:46.890]             sys.calls <- base::sys.calls
[17:46:46.890]             `[[` <- base::`[[`
[17:46:46.890]             `+` <- base::`+`
[17:46:46.890]             `<<-` <- base::`<<-`
[17:46:46.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.890]                   3L)]
[17:46:46.890]             }
[17:46:46.890]             function(cond) {
[17:46:46.890]                 is_error <- inherits(cond, "error")
[17:46:46.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.890]                   NULL)
[17:46:46.890]                 if (is_error) {
[17:46:46.890]                   sessionInformation <- function() {
[17:46:46.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.890]                       search = base::search(), system = base::Sys.info())
[17:46:46.890]                   }
[17:46:46.890]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.890]                     cond$call), session = sessionInformation(), 
[17:46:46.890]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.890]                   signalCondition(cond)
[17:46:46.890]                 }
[17:46:46.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.890]                 "immediateCondition"))) {
[17:46:46.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.890]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.890]                   if (TRUE && !signal) {
[17:46:46.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.890]                     {
[17:46:46.890]                       inherits <- base::inherits
[17:46:46.890]                       invokeRestart <- base::invokeRestart
[17:46:46.890]                       is.null <- base::is.null
[17:46:46.890]                       muffled <- FALSE
[17:46:46.890]                       if (inherits(cond, "message")) {
[17:46:46.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.890]                         if (muffled) 
[17:46:46.890]                           invokeRestart("muffleMessage")
[17:46:46.890]                       }
[17:46:46.890]                       else if (inherits(cond, "warning")) {
[17:46:46.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.890]                         if (muffled) 
[17:46:46.890]                           invokeRestart("muffleWarning")
[17:46:46.890]                       }
[17:46:46.890]                       else if (inherits(cond, "condition")) {
[17:46:46.890]                         if (!is.null(pattern)) {
[17:46:46.890]                           computeRestarts <- base::computeRestarts
[17:46:46.890]                           grepl <- base::grepl
[17:46:46.890]                           restarts <- computeRestarts(cond)
[17:46:46.890]                           for (restart in restarts) {
[17:46:46.890]                             name <- restart$name
[17:46:46.890]                             if (is.null(name)) 
[17:46:46.890]                               next
[17:46:46.890]                             if (!grepl(pattern, name)) 
[17:46:46.890]                               next
[17:46:46.890]                             invokeRestart(restart)
[17:46:46.890]                             muffled <- TRUE
[17:46:46.890]                             break
[17:46:46.890]                           }
[17:46:46.890]                         }
[17:46:46.890]                       }
[17:46:46.890]                       invisible(muffled)
[17:46:46.890]                     }
[17:46:46.890]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.890]                   }
[17:46:46.890]                 }
[17:46:46.890]                 else {
[17:46:46.890]                   if (TRUE) {
[17:46:46.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.890]                     {
[17:46:46.890]                       inherits <- base::inherits
[17:46:46.890]                       invokeRestart <- base::invokeRestart
[17:46:46.890]                       is.null <- base::is.null
[17:46:46.890]                       muffled <- FALSE
[17:46:46.890]                       if (inherits(cond, "message")) {
[17:46:46.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.890]                         if (muffled) 
[17:46:46.890]                           invokeRestart("muffleMessage")
[17:46:46.890]                       }
[17:46:46.890]                       else if (inherits(cond, "warning")) {
[17:46:46.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.890]                         if (muffled) 
[17:46:46.890]                           invokeRestart("muffleWarning")
[17:46:46.890]                       }
[17:46:46.890]                       else if (inherits(cond, "condition")) {
[17:46:46.890]                         if (!is.null(pattern)) {
[17:46:46.890]                           computeRestarts <- base::computeRestarts
[17:46:46.890]                           grepl <- base::grepl
[17:46:46.890]                           restarts <- computeRestarts(cond)
[17:46:46.890]                           for (restart in restarts) {
[17:46:46.890]                             name <- restart$name
[17:46:46.890]                             if (is.null(name)) 
[17:46:46.890]                               next
[17:46:46.890]                             if (!grepl(pattern, name)) 
[17:46:46.890]                               next
[17:46:46.890]                             invokeRestart(restart)
[17:46:46.890]                             muffled <- TRUE
[17:46:46.890]                             break
[17:46:46.890]                           }
[17:46:46.890]                         }
[17:46:46.890]                       }
[17:46:46.890]                       invisible(muffled)
[17:46:46.890]                     }
[17:46:46.890]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.890]                   }
[17:46:46.890]                 }
[17:46:46.890]             }
[17:46:46.890]         }))
[17:46:46.890]     }, error = function(ex) {
[17:46:46.890]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.890]                 ...future.rng), started = ...future.startTime, 
[17:46:46.890]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.890]             version = "1.8"), class = "FutureResult")
[17:46:46.890]     }, finally = {
[17:46:46.890]         if (!identical(...future.workdir, getwd())) 
[17:46:46.890]             setwd(...future.workdir)
[17:46:46.890]         {
[17:46:46.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.890]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.890]             }
[17:46:46.890]             base::options(...future.oldOptions)
[17:46:46.890]             if (.Platform$OS.type == "windows") {
[17:46:46.890]                 old_names <- names(...future.oldEnvVars)
[17:46:46.890]                 envs <- base::Sys.getenv()
[17:46:46.890]                 names <- names(envs)
[17:46:46.890]                 common <- intersect(names, old_names)
[17:46:46.890]                 added <- setdiff(names, old_names)
[17:46:46.890]                 removed <- setdiff(old_names, names)
[17:46:46.890]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.890]                   envs[common]]
[17:46:46.890]                 NAMES <- toupper(changed)
[17:46:46.890]                 args <- list()
[17:46:46.890]                 for (kk in seq_along(NAMES)) {
[17:46:46.890]                   name <- changed[[kk]]
[17:46:46.890]                   NAME <- NAMES[[kk]]
[17:46:46.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.890]                     next
[17:46:46.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.890]                 }
[17:46:46.890]                 NAMES <- toupper(added)
[17:46:46.890]                 for (kk in seq_along(NAMES)) {
[17:46:46.890]                   name <- added[[kk]]
[17:46:46.890]                   NAME <- NAMES[[kk]]
[17:46:46.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.890]                     next
[17:46:46.890]                   args[[name]] <- ""
[17:46:46.890]                 }
[17:46:46.890]                 NAMES <- toupper(removed)
[17:46:46.890]                 for (kk in seq_along(NAMES)) {
[17:46:46.890]                   name <- removed[[kk]]
[17:46:46.890]                   NAME <- NAMES[[kk]]
[17:46:46.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.890]                     next
[17:46:46.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.890]                 }
[17:46:46.890]                 if (length(args) > 0) 
[17:46:46.890]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.890]             }
[17:46:46.890]             else {
[17:46:46.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.890]             }
[17:46:46.890]             {
[17:46:46.890]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.890]                   0L) {
[17:46:46.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.890]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.890]                   base::options(opts)
[17:46:46.890]                 }
[17:46:46.890]                 {
[17:46:46.890]                   {
[17:46:46.890]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.890]                     NULL
[17:46:46.890]                   }
[17:46:46.890]                   options(future.plan = NULL)
[17:46:46.890]                   if (is.na(NA_character_)) 
[17:46:46.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.890]                     .init = FALSE)
[17:46:46.890]                 }
[17:46:46.890]             }
[17:46:46.890]         }
[17:46:46.890]     })
[17:46:46.890]     if (TRUE) {
[17:46:46.890]         base::sink(type = "output", split = FALSE)
[17:46:46.890]         if (TRUE) {
[17:46:46.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.890]         }
[17:46:46.890]         else {
[17:46:46.890]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.890]         }
[17:46:46.890]         base::close(...future.stdout)
[17:46:46.890]         ...future.stdout <- NULL
[17:46:46.890]     }
[17:46:46.890]     ...future.result$conditions <- ...future.conditions
[17:46:46.890]     ...future.result$finished <- base::Sys.time()
[17:46:46.890]     ...future.result
[17:46:46.890] }
[17:46:46.893] requestCore(): workers = 2
[17:46:46.895] MulticoreFuture started
[17:46:46.895] - Launch lazy future ... done
[17:46:46.895] run() for ‘MulticoreFuture’ ... done
[17:46:46.896] getGlobalsAndPackages() ...
[17:46:46.896] Searching for globals...
[17:46:46.896] plan(): Setting new future strategy stack:
[17:46:46.897] 
[17:46:46.897] Searching for globals ... DONE
[17:46:46.896] List of future strategies:
[17:46:46.896] 1. sequential:
[17:46:46.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.896]    - tweaked: FALSE
[17:46:46.896]    - call: NULL
[17:46:46.897] - globals: [0] <none>
[17:46:46.897] getGlobalsAndPackages() ... DONE
[17:46:46.897] plan(): nbrOfWorkers() = 1
[17:46:46.898] run() for ‘Future’ ...
[17:46:46.898] - state: ‘created’
[17:46:46.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.899] plan(): Setting new future strategy stack:
[17:46:46.899] List of future strategies:
[17:46:46.899] 1. multicore:
[17:46:46.899]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.899]    - tweaked: FALSE
[17:46:46.899]    - call: plan(strategy)
[17:46:46.903] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.903] plan(): nbrOfWorkers() = 2
[17:46:46.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.904]   - Field: ‘label’
[17:46:46.904]   - Field: ‘local’
[17:46:46.904]   - Field: ‘owner’
[17:46:46.904]   - Field: ‘envir’
[17:46:46.904]   - Field: ‘workers’
[17:46:46.904]   - Field: ‘packages’
[17:46:46.904]   - Field: ‘gc’
[17:46:46.904]   - Field: ‘job’
[17:46:46.905]   - Field: ‘conditions’
[17:46:46.905]   - Field: ‘expr’
[17:46:46.905]   - Field: ‘uuid’
[17:46:46.905]   - Field: ‘seed’
[17:46:46.905]   - Field: ‘version’
[17:46:46.905]   - Field: ‘result’
[17:46:46.905]   - Field: ‘asynchronous’
[17:46:46.906]   - Field: ‘calls’
[17:46:46.906]   - Field: ‘globals’
[17:46:46.906]   - Field: ‘stdout’
[17:46:46.906]   - Field: ‘earlySignal’
[17:46:46.906]   - Field: ‘lazy’
[17:46:46.906]   - Field: ‘state’
[17:46:46.906] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.906] - Launch lazy future ...
[17:46:46.907] Packages needed by the future expression (n = 0): <none>
[17:46:46.907] Packages needed by future strategies (n = 0): <none>
[17:46:46.908] {
[17:46:46.908]     {
[17:46:46.908]         {
[17:46:46.908]             ...future.startTime <- base::Sys.time()
[17:46:46.908]             {
[17:46:46.908]                 {
[17:46:46.908]                   {
[17:46:46.908]                     {
[17:46:46.908]                       base::local({
[17:46:46.908]                         has_future <- base::requireNamespace("future", 
[17:46:46.908]                           quietly = TRUE)
[17:46:46.908]                         if (has_future) {
[17:46:46.908]                           ns <- base::getNamespace("future")
[17:46:46.908]                           version <- ns[[".package"]][["version"]]
[17:46:46.908]                           if (is.null(version)) 
[17:46:46.908]                             version <- utils::packageVersion("future")
[17:46:46.908]                         }
[17:46:46.908]                         else {
[17:46:46.908]                           version <- NULL
[17:46:46.908]                         }
[17:46:46.908]                         if (!has_future || version < "1.8.0") {
[17:46:46.908]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.908]                             "", base::R.version$version.string), 
[17:46:46.908]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.908]                               "release", "version")], collapse = " "), 
[17:46:46.908]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.908]                             info)
[17:46:46.908]                           info <- base::paste(info, collapse = "; ")
[17:46:46.908]                           if (!has_future) {
[17:46:46.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.908]                               info)
[17:46:46.908]                           }
[17:46:46.908]                           else {
[17:46:46.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.908]                               info, version)
[17:46:46.908]                           }
[17:46:46.908]                           base::stop(msg)
[17:46:46.908]                         }
[17:46:46.908]                       })
[17:46:46.908]                     }
[17:46:46.908]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.908]                     base::options(mc.cores = 1L)
[17:46:46.908]                   }
[17:46:46.908]                   ...future.strategy.old <- future::plan("list")
[17:46:46.908]                   options(future.plan = NULL)
[17:46:46.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.908]                 }
[17:46:46.908]                 ...future.workdir <- getwd()
[17:46:46.908]             }
[17:46:46.908]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.908]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.908]         }
[17:46:46.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.908]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.908]             base::names(...future.oldOptions))
[17:46:46.908]     }
[17:46:46.908]     if (FALSE) {
[17:46:46.908]     }
[17:46:46.908]     else {
[17:46:46.908]         if (TRUE) {
[17:46:46.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.908]                 open = "w")
[17:46:46.908]         }
[17:46:46.908]         else {
[17:46:46.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.908]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.908]         }
[17:46:46.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.908]             base::sink(type = "output", split = FALSE)
[17:46:46.908]             base::close(...future.stdout)
[17:46:46.908]         }, add = TRUE)
[17:46:46.908]     }
[17:46:46.908]     ...future.frame <- base::sys.nframe()
[17:46:46.908]     ...future.conditions <- base::list()
[17:46:46.908]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.908]     if (FALSE) {
[17:46:46.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.908]     }
[17:46:46.908]     ...future.result <- base::tryCatch({
[17:46:46.908]         base::withCallingHandlers({
[17:46:46.908]             ...future.value <- base::withVisible(base::local({
[17:46:46.908]                 withCallingHandlers({
[17:46:46.908]                   NULL
[17:46:46.908]                 }, immediateCondition = function(cond) {
[17:46:46.908]                   save_rds <- function (object, pathname, ...) 
[17:46:46.908]                   {
[17:46:46.908]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.908]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.908]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.908]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.908]                         fi_tmp[["mtime"]])
[17:46:46.908]                     }
[17:46:46.908]                     tryCatch({
[17:46:46.908]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.908]                     }, error = function(ex) {
[17:46:46.908]                       msg <- conditionMessage(ex)
[17:46:46.908]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.908]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.908]                         fi_tmp[["mtime"]], msg)
[17:46:46.908]                       ex$message <- msg
[17:46:46.908]                       stop(ex)
[17:46:46.908]                     })
[17:46:46.908]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.908]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.908]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.908]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.908]                       fi <- file.info(pathname)
[17:46:46.908]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.908]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.908]                         fi[["size"]], fi[["mtime"]])
[17:46:46.908]                       stop(msg)
[17:46:46.908]                     }
[17:46:46.908]                     invisible(pathname)
[17:46:46.908]                   }
[17:46:46.908]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.908]                     rootPath = tempdir()) 
[17:46:46.908]                   {
[17:46:46.908]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.908]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.908]                       tmpdir = path, fileext = ".rds")
[17:46:46.908]                     save_rds(obj, file)
[17:46:46.908]                   }
[17:46:46.908]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.908]                   {
[17:46:46.908]                     inherits <- base::inherits
[17:46:46.908]                     invokeRestart <- base::invokeRestart
[17:46:46.908]                     is.null <- base::is.null
[17:46:46.908]                     muffled <- FALSE
[17:46:46.908]                     if (inherits(cond, "message")) {
[17:46:46.908]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.908]                       if (muffled) 
[17:46:46.908]                         invokeRestart("muffleMessage")
[17:46:46.908]                     }
[17:46:46.908]                     else if (inherits(cond, "warning")) {
[17:46:46.908]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.908]                       if (muffled) 
[17:46:46.908]                         invokeRestart("muffleWarning")
[17:46:46.908]                     }
[17:46:46.908]                     else if (inherits(cond, "condition")) {
[17:46:46.908]                       if (!is.null(pattern)) {
[17:46:46.908]                         computeRestarts <- base::computeRestarts
[17:46:46.908]                         grepl <- base::grepl
[17:46:46.908]                         restarts <- computeRestarts(cond)
[17:46:46.908]                         for (restart in restarts) {
[17:46:46.908]                           name <- restart$name
[17:46:46.908]                           if (is.null(name)) 
[17:46:46.908]                             next
[17:46:46.908]                           if (!grepl(pattern, name)) 
[17:46:46.908]                             next
[17:46:46.908]                           invokeRestart(restart)
[17:46:46.908]                           muffled <- TRUE
[17:46:46.908]                           break
[17:46:46.908]                         }
[17:46:46.908]                       }
[17:46:46.908]                     }
[17:46:46.908]                     invisible(muffled)
[17:46:46.908]                   }
[17:46:46.908]                   muffleCondition(cond)
[17:46:46.908]                 })
[17:46:46.908]             }))
[17:46:46.908]             future::FutureResult(value = ...future.value$value, 
[17:46:46.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.908]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.908]                     ...future.globalenv.names))
[17:46:46.908]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.908]         }, condition = base::local({
[17:46:46.908]             c <- base::c
[17:46:46.908]             inherits <- base::inherits
[17:46:46.908]             invokeRestart <- base::invokeRestart
[17:46:46.908]             length <- base::length
[17:46:46.908]             list <- base::list
[17:46:46.908]             seq.int <- base::seq.int
[17:46:46.908]             signalCondition <- base::signalCondition
[17:46:46.908]             sys.calls <- base::sys.calls
[17:46:46.908]             `[[` <- base::`[[`
[17:46:46.908]             `+` <- base::`+`
[17:46:46.908]             `<<-` <- base::`<<-`
[17:46:46.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.908]                   3L)]
[17:46:46.908]             }
[17:46:46.908]             function(cond) {
[17:46:46.908]                 is_error <- inherits(cond, "error")
[17:46:46.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.908]                   NULL)
[17:46:46.908]                 if (is_error) {
[17:46:46.908]                   sessionInformation <- function() {
[17:46:46.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.908]                       search = base::search(), system = base::Sys.info())
[17:46:46.908]                   }
[17:46:46.908]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.908]                     cond$call), session = sessionInformation(), 
[17:46:46.908]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.908]                   signalCondition(cond)
[17:46:46.908]                 }
[17:46:46.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.908]                 "immediateCondition"))) {
[17:46:46.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.908]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.908]                   if (TRUE && !signal) {
[17:46:46.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.908]                     {
[17:46:46.908]                       inherits <- base::inherits
[17:46:46.908]                       invokeRestart <- base::invokeRestart
[17:46:46.908]                       is.null <- base::is.null
[17:46:46.908]                       muffled <- FALSE
[17:46:46.908]                       if (inherits(cond, "message")) {
[17:46:46.908]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.908]                         if (muffled) 
[17:46:46.908]                           invokeRestart("muffleMessage")
[17:46:46.908]                       }
[17:46:46.908]                       else if (inherits(cond, "warning")) {
[17:46:46.908]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.908]                         if (muffled) 
[17:46:46.908]                           invokeRestart("muffleWarning")
[17:46:46.908]                       }
[17:46:46.908]                       else if (inherits(cond, "condition")) {
[17:46:46.908]                         if (!is.null(pattern)) {
[17:46:46.908]                           computeRestarts <- base::computeRestarts
[17:46:46.908]                           grepl <- base::grepl
[17:46:46.908]                           restarts <- computeRestarts(cond)
[17:46:46.908]                           for (restart in restarts) {
[17:46:46.908]                             name <- restart$name
[17:46:46.908]                             if (is.null(name)) 
[17:46:46.908]                               next
[17:46:46.908]                             if (!grepl(pattern, name)) 
[17:46:46.908]                               next
[17:46:46.908]                             invokeRestart(restart)
[17:46:46.908]                             muffled <- TRUE
[17:46:46.908]                             break
[17:46:46.908]                           }
[17:46:46.908]                         }
[17:46:46.908]                       }
[17:46:46.908]                       invisible(muffled)
[17:46:46.908]                     }
[17:46:46.908]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.908]                   }
[17:46:46.908]                 }
[17:46:46.908]                 else {
[17:46:46.908]                   if (TRUE) {
[17:46:46.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.908]                     {
[17:46:46.908]                       inherits <- base::inherits
[17:46:46.908]                       invokeRestart <- base::invokeRestart
[17:46:46.908]                       is.null <- base::is.null
[17:46:46.908]                       muffled <- FALSE
[17:46:46.908]                       if (inherits(cond, "message")) {
[17:46:46.908]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.908]                         if (muffled) 
[17:46:46.908]                           invokeRestart("muffleMessage")
[17:46:46.908]                       }
[17:46:46.908]                       else if (inherits(cond, "warning")) {
[17:46:46.908]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.908]                         if (muffled) 
[17:46:46.908]                           invokeRestart("muffleWarning")
[17:46:46.908]                       }
[17:46:46.908]                       else if (inherits(cond, "condition")) {
[17:46:46.908]                         if (!is.null(pattern)) {
[17:46:46.908]                           computeRestarts <- base::computeRestarts
[17:46:46.908]                           grepl <- base::grepl
[17:46:46.908]                           restarts <- computeRestarts(cond)
[17:46:46.908]                           for (restart in restarts) {
[17:46:46.908]                             name <- restart$name
[17:46:46.908]                             if (is.null(name)) 
[17:46:46.908]                               next
[17:46:46.908]                             if (!grepl(pattern, name)) 
[17:46:46.908]                               next
[17:46:46.908]                             invokeRestart(restart)
[17:46:46.908]                             muffled <- TRUE
[17:46:46.908]                             break
[17:46:46.908]                           }
[17:46:46.908]                         }
[17:46:46.908]                       }
[17:46:46.908]                       invisible(muffled)
[17:46:46.908]                     }
[17:46:46.908]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.908]                   }
[17:46:46.908]                 }
[17:46:46.908]             }
[17:46:46.908]         }))
[17:46:46.908]     }, error = function(ex) {
[17:46:46.908]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.908]                 ...future.rng), started = ...future.startTime, 
[17:46:46.908]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.908]             version = "1.8"), class = "FutureResult")
[17:46:46.908]     }, finally = {
[17:46:46.908]         if (!identical(...future.workdir, getwd())) 
[17:46:46.908]             setwd(...future.workdir)
[17:46:46.908]         {
[17:46:46.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.908]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.908]             }
[17:46:46.908]             base::options(...future.oldOptions)
[17:46:46.908]             if (.Platform$OS.type == "windows") {
[17:46:46.908]                 old_names <- names(...future.oldEnvVars)
[17:46:46.908]                 envs <- base::Sys.getenv()
[17:46:46.908]                 names <- names(envs)
[17:46:46.908]                 common <- intersect(names, old_names)
[17:46:46.908]                 added <- setdiff(names, old_names)
[17:46:46.908]                 removed <- setdiff(old_names, names)
[17:46:46.908]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.908]                   envs[common]]
[17:46:46.908]                 NAMES <- toupper(changed)
[17:46:46.908]                 args <- list()
[17:46:46.908]                 for (kk in seq_along(NAMES)) {
[17:46:46.908]                   name <- changed[[kk]]
[17:46:46.908]                   NAME <- NAMES[[kk]]
[17:46:46.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.908]                     next
[17:46:46.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.908]                 }
[17:46:46.908]                 NAMES <- toupper(added)
[17:46:46.908]                 for (kk in seq_along(NAMES)) {
[17:46:46.908]                   name <- added[[kk]]
[17:46:46.908]                   NAME <- NAMES[[kk]]
[17:46:46.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.908]                     next
[17:46:46.908]                   args[[name]] <- ""
[17:46:46.908]                 }
[17:46:46.908]                 NAMES <- toupper(removed)
[17:46:46.908]                 for (kk in seq_along(NAMES)) {
[17:46:46.908]                   name <- removed[[kk]]
[17:46:46.908]                   NAME <- NAMES[[kk]]
[17:46:46.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.908]                     next
[17:46:46.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.908]                 }
[17:46:46.908]                 if (length(args) > 0) 
[17:46:46.908]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.908]             }
[17:46:46.908]             else {
[17:46:46.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.908]             }
[17:46:46.908]             {
[17:46:46.908]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.908]                   0L) {
[17:46:46.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.908]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.908]                   base::options(opts)
[17:46:46.908]                 }
[17:46:46.908]                 {
[17:46:46.908]                   {
[17:46:46.908]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.908]                     NULL
[17:46:46.908]                   }
[17:46:46.908]                   options(future.plan = NULL)
[17:46:46.908]                   if (is.na(NA_character_)) 
[17:46:46.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.908]                     .init = FALSE)
[17:46:46.908]                 }
[17:46:46.908]             }
[17:46:46.908]         }
[17:46:46.908]     })
[17:46:46.908]     if (TRUE) {
[17:46:46.908]         base::sink(type = "output", split = FALSE)
[17:46:46.908]         if (TRUE) {
[17:46:46.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.908]         }
[17:46:46.908]         else {
[17:46:46.908]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.908]         }
[17:46:46.908]         base::close(...future.stdout)
[17:46:46.908]         ...future.stdout <- NULL
[17:46:46.908]     }
[17:46:46.908]     ...future.result$conditions <- ...future.conditions
[17:46:46.908]     ...future.result$finished <- base::Sys.time()
[17:46:46.908]     ...future.result
[17:46:46.908] }
[17:46:46.911] requestCore(): workers = 2
[17:46:46.914] MulticoreFuture started
[17:46:46.914] - Launch lazy future ... done
[17:46:46.914] run() for ‘MulticoreFuture’ ... done
[17:46:46.915] plan(): Setting new future strategy stack:
[17:46:46.915] getGlobalsAndPackages() ...
[17:46:46.915] Searching for globals...
[17:46:46.915] List of future strategies:
[17:46:46.915] 1. sequential:
[17:46:46.915]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.915]    - tweaked: FALSE
[17:46:46.915]    - call: NULL
[17:46:46.916] plan(): nbrOfWorkers() = 1
[17:46:46.917] - globals found: [1] ‘{’
[17:46:46.917] Searching for globals ... DONE
[17:46:46.917] Resolving globals: FALSE
[17:46:46.917] 
[17:46:46.918] 
[17:46:46.918] getGlobalsAndPackages() ... DONE
[17:46:46.918] plan(): Setting new future strategy stack:
[17:46:46.918] run() for ‘Future’ ...
[17:46:46.918] - state: ‘created’
[17:46:46.918] List of future strategies:
[17:46:46.918] 1. multicore:
[17:46:46.918]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.918]    - tweaked: FALSE
[17:46:46.918]    - call: plan(strategy)
[17:46:46.918] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.923] plan(): nbrOfWorkers() = 2
[17:46:46.923] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.923]   - Field: ‘label’
[17:46:46.924]   - Field: ‘local’
[17:46:46.924]   - Field: ‘owner’
[17:46:46.924]   - Field: ‘envir’
[17:46:46.924]   - Field: ‘workers’
[17:46:46.924]   - Field: ‘packages’
[17:46:46.924]   - Field: ‘gc’
[17:46:46.924]   - Field: ‘job’
[17:46:46.925]   - Field: ‘conditions’
[17:46:46.925]   - Field: ‘expr’
[17:46:46.925]   - Field: ‘uuid’
[17:46:46.925]   - Field: ‘seed’
[17:46:46.925]   - Field: ‘version’
[17:46:46.925]   - Field: ‘result’
[17:46:46.925]   - Field: ‘asynchronous’
[17:46:46.925]   - Field: ‘calls’
[17:46:46.926]   - Field: ‘globals’
[17:46:46.926]   - Field: ‘stdout’
[17:46:46.926]   - Field: ‘earlySignal’
[17:46:46.926]   - Field: ‘lazy’
[17:46:46.926]   - Field: ‘state’
[17:46:46.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.926] - Launch lazy future ...
[17:46:46.927] Packages needed by the future expression (n = 0): <none>
[17:46:46.927] Packages needed by future strategies (n = 0): <none>
[17:46:46.928] {
[17:46:46.928]     {
[17:46:46.928]         {
[17:46:46.928]             ...future.startTime <- base::Sys.time()
[17:46:46.928]             {
[17:46:46.928]                 {
[17:46:46.928]                   {
[17:46:46.928]                     {
[17:46:46.928]                       base::local({
[17:46:46.928]                         has_future <- base::requireNamespace("future", 
[17:46:46.928]                           quietly = TRUE)
[17:46:46.928]                         if (has_future) {
[17:46:46.928]                           ns <- base::getNamespace("future")
[17:46:46.928]                           version <- ns[[".package"]][["version"]]
[17:46:46.928]                           if (is.null(version)) 
[17:46:46.928]                             version <- utils::packageVersion("future")
[17:46:46.928]                         }
[17:46:46.928]                         else {
[17:46:46.928]                           version <- NULL
[17:46:46.928]                         }
[17:46:46.928]                         if (!has_future || version < "1.8.0") {
[17:46:46.928]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.928]                             "", base::R.version$version.string), 
[17:46:46.928]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.928]                               "release", "version")], collapse = " "), 
[17:46:46.928]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.928]                             info)
[17:46:46.928]                           info <- base::paste(info, collapse = "; ")
[17:46:46.928]                           if (!has_future) {
[17:46:46.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.928]                               info)
[17:46:46.928]                           }
[17:46:46.928]                           else {
[17:46:46.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.928]                               info, version)
[17:46:46.928]                           }
[17:46:46.928]                           base::stop(msg)
[17:46:46.928]                         }
[17:46:46.928]                       })
[17:46:46.928]                     }
[17:46:46.928]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.928]                     base::options(mc.cores = 1L)
[17:46:46.928]                   }
[17:46:46.928]                   ...future.strategy.old <- future::plan("list")
[17:46:46.928]                   options(future.plan = NULL)
[17:46:46.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.928]                 }
[17:46:46.928]                 ...future.workdir <- getwd()
[17:46:46.928]             }
[17:46:46.928]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.928]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.928]         }
[17:46:46.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.928]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.928]             base::names(...future.oldOptions))
[17:46:46.928]     }
[17:46:46.928]     if (FALSE) {
[17:46:46.928]     }
[17:46:46.928]     else {
[17:46:46.928]         if (TRUE) {
[17:46:46.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.928]                 open = "w")
[17:46:46.928]         }
[17:46:46.928]         else {
[17:46:46.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.928]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.928]         }
[17:46:46.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.928]             base::sink(type = "output", split = FALSE)
[17:46:46.928]             base::close(...future.stdout)
[17:46:46.928]         }, add = TRUE)
[17:46:46.928]     }
[17:46:46.928]     ...future.frame <- base::sys.nframe()
[17:46:46.928]     ...future.conditions <- base::list()
[17:46:46.928]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.928]     if (FALSE) {
[17:46:46.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.928]     }
[17:46:46.928]     ...future.result <- base::tryCatch({
[17:46:46.928]         base::withCallingHandlers({
[17:46:46.928]             ...future.value <- base::withVisible(base::local({
[17:46:46.928]                 withCallingHandlers({
[17:46:46.928]                   {
[17:46:46.928]                     4
[17:46:46.928]                   }
[17:46:46.928]                 }, immediateCondition = function(cond) {
[17:46:46.928]                   save_rds <- function (object, pathname, ...) 
[17:46:46.928]                   {
[17:46:46.928]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.928]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.928]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.928]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.928]                         fi_tmp[["mtime"]])
[17:46:46.928]                     }
[17:46:46.928]                     tryCatch({
[17:46:46.928]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.928]                     }, error = function(ex) {
[17:46:46.928]                       msg <- conditionMessage(ex)
[17:46:46.928]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.928]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.928]                         fi_tmp[["mtime"]], msg)
[17:46:46.928]                       ex$message <- msg
[17:46:46.928]                       stop(ex)
[17:46:46.928]                     })
[17:46:46.928]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.928]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.928]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.928]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.928]                       fi <- file.info(pathname)
[17:46:46.928]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.928]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.928]                         fi[["size"]], fi[["mtime"]])
[17:46:46.928]                       stop(msg)
[17:46:46.928]                     }
[17:46:46.928]                     invisible(pathname)
[17:46:46.928]                   }
[17:46:46.928]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.928]                     rootPath = tempdir()) 
[17:46:46.928]                   {
[17:46:46.928]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.928]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.928]                       tmpdir = path, fileext = ".rds")
[17:46:46.928]                     save_rds(obj, file)
[17:46:46.928]                   }
[17:46:46.928]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.928]                   {
[17:46:46.928]                     inherits <- base::inherits
[17:46:46.928]                     invokeRestart <- base::invokeRestart
[17:46:46.928]                     is.null <- base::is.null
[17:46:46.928]                     muffled <- FALSE
[17:46:46.928]                     if (inherits(cond, "message")) {
[17:46:46.928]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.928]                       if (muffled) 
[17:46:46.928]                         invokeRestart("muffleMessage")
[17:46:46.928]                     }
[17:46:46.928]                     else if (inherits(cond, "warning")) {
[17:46:46.928]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.928]                       if (muffled) 
[17:46:46.928]                         invokeRestart("muffleWarning")
[17:46:46.928]                     }
[17:46:46.928]                     else if (inherits(cond, "condition")) {
[17:46:46.928]                       if (!is.null(pattern)) {
[17:46:46.928]                         computeRestarts <- base::computeRestarts
[17:46:46.928]                         grepl <- base::grepl
[17:46:46.928]                         restarts <- computeRestarts(cond)
[17:46:46.928]                         for (restart in restarts) {
[17:46:46.928]                           name <- restart$name
[17:46:46.928]                           if (is.null(name)) 
[17:46:46.928]                             next
[17:46:46.928]                           if (!grepl(pattern, name)) 
[17:46:46.928]                             next
[17:46:46.928]                           invokeRestart(restart)
[17:46:46.928]                           muffled <- TRUE
[17:46:46.928]                           break
[17:46:46.928]                         }
[17:46:46.928]                       }
[17:46:46.928]                     }
[17:46:46.928]                     invisible(muffled)
[17:46:46.928]                   }
[17:46:46.928]                   muffleCondition(cond)
[17:46:46.928]                 })
[17:46:46.928]             }))
[17:46:46.928]             future::FutureResult(value = ...future.value$value, 
[17:46:46.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.928]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.928]                     ...future.globalenv.names))
[17:46:46.928]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.928]         }, condition = base::local({
[17:46:46.928]             c <- base::c
[17:46:46.928]             inherits <- base::inherits
[17:46:46.928]             invokeRestart <- base::invokeRestart
[17:46:46.928]             length <- base::length
[17:46:46.928]             list <- base::list
[17:46:46.928]             seq.int <- base::seq.int
[17:46:46.928]             signalCondition <- base::signalCondition
[17:46:46.928]             sys.calls <- base::sys.calls
[17:46:46.928]             `[[` <- base::`[[`
[17:46:46.928]             `+` <- base::`+`
[17:46:46.928]             `<<-` <- base::`<<-`
[17:46:46.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.928]                   3L)]
[17:46:46.928]             }
[17:46:46.928]             function(cond) {
[17:46:46.928]                 is_error <- inherits(cond, "error")
[17:46:46.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.928]                   NULL)
[17:46:46.928]                 if (is_error) {
[17:46:46.928]                   sessionInformation <- function() {
[17:46:46.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.928]                       search = base::search(), system = base::Sys.info())
[17:46:46.928]                   }
[17:46:46.928]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.928]                     cond$call), session = sessionInformation(), 
[17:46:46.928]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.928]                   signalCondition(cond)
[17:46:46.928]                 }
[17:46:46.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.928]                 "immediateCondition"))) {
[17:46:46.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.928]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.928]                   if (TRUE && !signal) {
[17:46:46.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.928]                     {
[17:46:46.928]                       inherits <- base::inherits
[17:46:46.928]                       invokeRestart <- base::invokeRestart
[17:46:46.928]                       is.null <- base::is.null
[17:46:46.928]                       muffled <- FALSE
[17:46:46.928]                       if (inherits(cond, "message")) {
[17:46:46.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.928]                         if (muffled) 
[17:46:46.928]                           invokeRestart("muffleMessage")
[17:46:46.928]                       }
[17:46:46.928]                       else if (inherits(cond, "warning")) {
[17:46:46.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.928]                         if (muffled) 
[17:46:46.928]                           invokeRestart("muffleWarning")
[17:46:46.928]                       }
[17:46:46.928]                       else if (inherits(cond, "condition")) {
[17:46:46.928]                         if (!is.null(pattern)) {
[17:46:46.928]                           computeRestarts <- base::computeRestarts
[17:46:46.928]                           grepl <- base::grepl
[17:46:46.928]                           restarts <- computeRestarts(cond)
[17:46:46.928]                           for (restart in restarts) {
[17:46:46.928]                             name <- restart$name
[17:46:46.928]                             if (is.null(name)) 
[17:46:46.928]                               next
[17:46:46.928]                             if (!grepl(pattern, name)) 
[17:46:46.928]                               next
[17:46:46.928]                             invokeRestart(restart)
[17:46:46.928]                             muffled <- TRUE
[17:46:46.928]                             break
[17:46:46.928]                           }
[17:46:46.928]                         }
[17:46:46.928]                       }
[17:46:46.928]                       invisible(muffled)
[17:46:46.928]                     }
[17:46:46.928]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.928]                   }
[17:46:46.928]                 }
[17:46:46.928]                 else {
[17:46:46.928]                   if (TRUE) {
[17:46:46.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.928]                     {
[17:46:46.928]                       inherits <- base::inherits
[17:46:46.928]                       invokeRestart <- base::invokeRestart
[17:46:46.928]                       is.null <- base::is.null
[17:46:46.928]                       muffled <- FALSE
[17:46:46.928]                       if (inherits(cond, "message")) {
[17:46:46.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.928]                         if (muffled) 
[17:46:46.928]                           invokeRestart("muffleMessage")
[17:46:46.928]                       }
[17:46:46.928]                       else if (inherits(cond, "warning")) {
[17:46:46.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.928]                         if (muffled) 
[17:46:46.928]                           invokeRestart("muffleWarning")
[17:46:46.928]                       }
[17:46:46.928]                       else if (inherits(cond, "condition")) {
[17:46:46.928]                         if (!is.null(pattern)) {
[17:46:46.928]                           computeRestarts <- base::computeRestarts
[17:46:46.928]                           grepl <- base::grepl
[17:46:46.928]                           restarts <- computeRestarts(cond)
[17:46:46.928]                           for (restart in restarts) {
[17:46:46.928]                             name <- restart$name
[17:46:46.928]                             if (is.null(name)) 
[17:46:46.928]                               next
[17:46:46.928]                             if (!grepl(pattern, name)) 
[17:46:46.928]                               next
[17:46:46.928]                             invokeRestart(restart)
[17:46:46.928]                             muffled <- TRUE
[17:46:46.928]                             break
[17:46:46.928]                           }
[17:46:46.928]                         }
[17:46:46.928]                       }
[17:46:46.928]                       invisible(muffled)
[17:46:46.928]                     }
[17:46:46.928]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.928]                   }
[17:46:46.928]                 }
[17:46:46.928]             }
[17:46:46.928]         }))
[17:46:46.928]     }, error = function(ex) {
[17:46:46.928]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.928]                 ...future.rng), started = ...future.startTime, 
[17:46:46.928]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.928]             version = "1.8"), class = "FutureResult")
[17:46:46.928]     }, finally = {
[17:46:46.928]         if (!identical(...future.workdir, getwd())) 
[17:46:46.928]             setwd(...future.workdir)
[17:46:46.928]         {
[17:46:46.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.928]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.928]             }
[17:46:46.928]             base::options(...future.oldOptions)
[17:46:46.928]             if (.Platform$OS.type == "windows") {
[17:46:46.928]                 old_names <- names(...future.oldEnvVars)
[17:46:46.928]                 envs <- base::Sys.getenv()
[17:46:46.928]                 names <- names(envs)
[17:46:46.928]                 common <- intersect(names, old_names)
[17:46:46.928]                 added <- setdiff(names, old_names)
[17:46:46.928]                 removed <- setdiff(old_names, names)
[17:46:46.928]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.928]                   envs[common]]
[17:46:46.928]                 NAMES <- toupper(changed)
[17:46:46.928]                 args <- list()
[17:46:46.928]                 for (kk in seq_along(NAMES)) {
[17:46:46.928]                   name <- changed[[kk]]
[17:46:46.928]                   NAME <- NAMES[[kk]]
[17:46:46.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.928]                     next
[17:46:46.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.928]                 }
[17:46:46.928]                 NAMES <- toupper(added)
[17:46:46.928]                 for (kk in seq_along(NAMES)) {
[17:46:46.928]                   name <- added[[kk]]
[17:46:46.928]                   NAME <- NAMES[[kk]]
[17:46:46.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.928]                     next
[17:46:46.928]                   args[[name]] <- ""
[17:46:46.928]                 }
[17:46:46.928]                 NAMES <- toupper(removed)
[17:46:46.928]                 for (kk in seq_along(NAMES)) {
[17:46:46.928]                   name <- removed[[kk]]
[17:46:46.928]                   NAME <- NAMES[[kk]]
[17:46:46.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.928]                     next
[17:46:46.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.928]                 }
[17:46:46.928]                 if (length(args) > 0) 
[17:46:46.928]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.928]             }
[17:46:46.928]             else {
[17:46:46.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.928]             }
[17:46:46.928]             {
[17:46:46.928]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.928]                   0L) {
[17:46:46.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.928]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.928]                   base::options(opts)
[17:46:46.928]                 }
[17:46:46.928]                 {
[17:46:46.928]                   {
[17:46:46.928]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.928]                     NULL
[17:46:46.928]                   }
[17:46:46.928]                   options(future.plan = NULL)
[17:46:46.928]                   if (is.na(NA_character_)) 
[17:46:46.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.928]                     .init = FALSE)
[17:46:46.928]                 }
[17:46:46.928]             }
[17:46:46.928]         }
[17:46:46.928]     })
[17:46:46.928]     if (TRUE) {
[17:46:46.928]         base::sink(type = "output", split = FALSE)
[17:46:46.928]         if (TRUE) {
[17:46:46.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.928]         }
[17:46:46.928]         else {
[17:46:46.928]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.928]         }
[17:46:46.928]         base::close(...future.stdout)
[17:46:46.928]         ...future.stdout <- NULL
[17:46:46.928]     }
[17:46:46.928]     ...future.result$conditions <- ...future.conditions
[17:46:46.928]     ...future.result$finished <- base::Sys.time()
[17:46:46.928]     ...future.result
[17:46:46.928] }
[17:46:46.931] requestCore(): workers = 2
[17:46:46.931] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:46.942] result() for MulticoreFuture ...
[17:46:46.943] result() for MulticoreFuture ...
[17:46:46.943] result() for MulticoreFuture ... done
[17:46:46.943] result() for MulticoreFuture ... done
[17:46:46.943] result() for MulticoreFuture ...
[17:46:46.944] result() for MulticoreFuture ... done
[17:46:46.946] MulticoreFuture started
[17:46:46.947] - Launch lazy future ... done
[17:46:46.947] run() for ‘MulticoreFuture’ ... done
[17:46:46.947] plan(): Setting new future strategy stack:
<environment: 0x561788631b08> 
[17:46:46.948] List of future strategies:
[17:46:46.948] 1. sequential:
[17:46:46.948]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.948]    - tweaked: FALSE
[17:46:46.948]    - call: NULL
[17:46:46.949] plan(): nbrOfWorkers() = 1
<environment: 0x5617896556b0> 
[17:46:46.952] plan(): Setting new future strategy stack:
[17:46:46.952] List of future strategies:
[17:46:46.952] 1. multicore:
[17:46:46.952]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:46.952]    - tweaked: FALSE
[17:46:46.952]    - call: plan(strategy)
[17:46:46.957] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:46.960] resolve() on environment ...
[17:46:46.960]  recursive: 0
[17:46:46.960]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:46.961] signalConditionsASAP(numeric, pos=1) ...
[17:46:46.961] - nx: 4
[17:46:46.961] - relay: TRUE
[17:46:46.961] - stdout: TRUE
[17:46:46.961] - signal: TRUE
[17:46:46.961] - resignal: FALSE
[17:46:46.961] - force: TRUE
[17:46:46.962] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.962] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.962]  - until=2
[17:46:46.962]  - relaying element #2
[17:46:46.962] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.962] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.962] signalConditionsASAP(NULL, pos=1) ... done
[17:46:46.962]  length: 3 (resolved future 1)
[17:46:46.963] Future #2
[17:46:46.963] result() for MulticoreFuture ...
[17:46:46.963] result() for MulticoreFuture ... done
[17:46:46.963] result() for MulticoreFuture ...
[17:46:46.963] result() for MulticoreFuture ... done
[17:46:46.963] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:46.964] - nx: 4
[17:46:46.964] - relay: TRUE
[17:46:46.964] - stdout: TRUE
[17:46:46.964] - signal: TRUE
[17:46:46.964] - resignal: FALSE
[17:46:46.964] - force: TRUE
[17:46:46.964] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:46.964] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:46.965]  - until=2
[17:46:46.965]  - relaying element #2
[17:46:46.965] result() for MulticoreFuture ...
[17:46:46.965] result() for MulticoreFuture ... done
[17:46:46.965] result() for MulticoreFuture ...
[17:46:46.965] result() for MulticoreFuture ... done
[17:46:46.965] result() for MulticoreFuture ...
[17:46:46.965] result() for MulticoreFuture ... done
[17:46:46.966] result() for MulticoreFuture ...
[17:46:46.966] result() for MulticoreFuture ... done
[17:46:46.966] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.966] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.966] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:46.966]  length: 2 (resolved future 2)
[17:46:46.967] Future #3
[17:46:46.967] result() for MulticoreFuture ...
[17:46:46.968] result() for MulticoreFuture ...
[17:46:46.968] result() for MulticoreFuture ... done
[17:46:46.968] result() for MulticoreFuture ... done
[17:46:46.968] result() for MulticoreFuture ...
[17:46:46.968] result() for MulticoreFuture ... done
[17:46:46.968] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:46.968] - nx: 4
[17:46:46.968] - relay: TRUE
[17:46:46.969] - stdout: TRUE
[17:46:46.969] - signal: TRUE
[17:46:46.969] - resignal: FALSE
[17:46:46.969] - force: TRUE
[17:46:46.969] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:46.969] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:46.969]  - until=3
[17:46:46.969]  - relaying element #3
[17:46:46.970] result() for MulticoreFuture ...
[17:46:46.970] result() for MulticoreFuture ... done
[17:46:46.970] result() for MulticoreFuture ...
[17:46:46.970] result() for MulticoreFuture ... done
[17:46:46.970] result() for MulticoreFuture ...
[17:46:46.970] result() for MulticoreFuture ... done
[17:46:46.970] result() for MulticoreFuture ...
[17:46:46.970] result() for MulticoreFuture ... done
[17:46:46.971] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.971] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.971] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:46.971]  length: 1 (resolved future 3)
[17:46:46.971] Future #4
[17:46:46.971] result() for MulticoreFuture ...
[17:46:46.972] result() for MulticoreFuture ...
[17:46:46.972] result() for MulticoreFuture ... done
[17:46:46.972] result() for MulticoreFuture ... done
[17:46:46.973] result() for MulticoreFuture ...
[17:46:46.973] result() for MulticoreFuture ... done
[17:46:46.973] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:46.973] - nx: 4
[17:46:46.973] - relay: TRUE
[17:46:46.973] - stdout: TRUE
[17:46:46.974] - signal: TRUE
[17:46:46.974] - resignal: FALSE
[17:46:46.974] - force: TRUE
[17:46:46.974] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:46.974] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:46.974]  - until=4
[17:46:46.975]  - relaying element #4
[17:46:46.975] result() for MulticoreFuture ...
[17:46:46.975] result() for MulticoreFuture ... done
[17:46:46.975] result() for MulticoreFuture ...
[17:46:46.975] result() for MulticoreFuture ... done
[17:46:46.975] result() for MulticoreFuture ...
[17:46:46.975] result() for MulticoreFuture ... done
[17:46:46.976] result() for MulticoreFuture ...
[17:46:46.976] result() for MulticoreFuture ... done
[17:46:46.976] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.976] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.976] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:46.976]  length: 0 (resolved future 4)
[17:46:46.976] Relaying remaining futures
[17:46:46.976] signalConditionsASAP(NULL, pos=0) ...
[17:46:46.976] - nx: 4
[17:46:46.977] - relay: TRUE
[17:46:46.977] - stdout: TRUE
[17:46:46.977] - signal: TRUE
[17:46:46.977] - resignal: FALSE
[17:46:46.977] - force: TRUE
[17:46:46.977] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.977] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:46.977] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:46.977] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:46.977] signalConditionsASAP(NULL, pos=0) ... done
[17:46:46.978] resolve() on environment ... DONE
[17:46:46.978] result() for MulticoreFuture ...
[17:46:46.978] result() for MulticoreFuture ... done
[17:46:46.978] result() for MulticoreFuture ...
[17:46:46.978] result() for MulticoreFuture ... done
[17:46:46.978] result() for MulticoreFuture ...
[17:46:46.978] result() for MulticoreFuture ... done
[17:46:46.978] result() for MulticoreFuture ...
[17:46:46.978] result() for MulticoreFuture ... done
[17:46:46.979] result() for MulticoreFuture ...
[17:46:46.979] result() for MulticoreFuture ... done
[17:46:46.979] result() for MulticoreFuture ...
[17:46:46.979] result() for MulticoreFuture ... done
<environment: 0x5617897216d0> 
Dimensions: c(2, 1, 3, 1)
[17:46:46.979] getGlobalsAndPackages() ...
[17:46:46.980] Searching for globals...
[17:46:46.984] 
[17:46:46.984] Searching for globals ... DONE
[17:46:46.984] - globals: [0] <none>
[17:46:46.984] getGlobalsAndPackages() ... DONE
[17:46:46.984] run() for ‘Future’ ...
[17:46:46.985] - state: ‘created’
[17:46:46.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:46.989] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:46.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:46.989]   - Field: ‘label’
[17:46:46.989]   - Field: ‘local’
[17:46:46.989]   - Field: ‘owner’
[17:46:46.989]   - Field: ‘envir’
[17:46:46.990]   - Field: ‘workers’
[17:46:46.990]   - Field: ‘packages’
[17:46:46.990]   - Field: ‘gc’
[17:46:46.990]   - Field: ‘job’
[17:46:46.990]   - Field: ‘conditions’
[17:46:46.990]   - Field: ‘expr’
[17:46:46.990]   - Field: ‘uuid’
[17:46:46.990]   - Field: ‘seed’
[17:46:46.990]   - Field: ‘version’
[17:46:46.991]   - Field: ‘result’
[17:46:46.991]   - Field: ‘asynchronous’
[17:46:46.991]   - Field: ‘calls’
[17:46:46.991]   - Field: ‘globals’
[17:46:46.991]   - Field: ‘stdout’
[17:46:46.991]   - Field: ‘earlySignal’
[17:46:46.991]   - Field: ‘lazy’
[17:46:46.991]   - Field: ‘state’
[17:46:46.991] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:46.992] - Launch lazy future ...
[17:46:46.992] Packages needed by the future expression (n = 0): <none>
[17:46:46.992] Packages needed by future strategies (n = 0): <none>
[17:46:46.993] {
[17:46:46.993]     {
[17:46:46.993]         {
[17:46:46.993]             ...future.startTime <- base::Sys.time()
[17:46:46.993]             {
[17:46:46.993]                 {
[17:46:46.993]                   {
[17:46:46.993]                     {
[17:46:46.993]                       base::local({
[17:46:46.993]                         has_future <- base::requireNamespace("future", 
[17:46:46.993]                           quietly = TRUE)
[17:46:46.993]                         if (has_future) {
[17:46:46.993]                           ns <- base::getNamespace("future")
[17:46:46.993]                           version <- ns[[".package"]][["version"]]
[17:46:46.993]                           if (is.null(version)) 
[17:46:46.993]                             version <- utils::packageVersion("future")
[17:46:46.993]                         }
[17:46:46.993]                         else {
[17:46:46.993]                           version <- NULL
[17:46:46.993]                         }
[17:46:46.993]                         if (!has_future || version < "1.8.0") {
[17:46:46.993]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:46.993]                             "", base::R.version$version.string), 
[17:46:46.993]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:46.993]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:46.993]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:46.993]                               "release", "version")], collapse = " "), 
[17:46:46.993]                             hostname = base::Sys.info()[["nodename"]])
[17:46:46.993]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:46.993]                             info)
[17:46:46.993]                           info <- base::paste(info, collapse = "; ")
[17:46:46.993]                           if (!has_future) {
[17:46:46.993]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:46.993]                               info)
[17:46:46.993]                           }
[17:46:46.993]                           else {
[17:46:46.993]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:46.993]                               info, version)
[17:46:46.993]                           }
[17:46:46.993]                           base::stop(msg)
[17:46:46.993]                         }
[17:46:46.993]                       })
[17:46:46.993]                     }
[17:46:46.993]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:46.993]                     base::options(mc.cores = 1L)
[17:46:46.993]                   }
[17:46:46.993]                   ...future.strategy.old <- future::plan("list")
[17:46:46.993]                   options(future.plan = NULL)
[17:46:46.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:46.993]                 }
[17:46:46.993]                 ...future.workdir <- getwd()
[17:46:46.993]             }
[17:46:46.993]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:46.993]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:46.993]         }
[17:46:46.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:46.993]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:46.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:46.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:46.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:46.993]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:46.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:46.993]             base::names(...future.oldOptions))
[17:46:46.993]     }
[17:46:46.993]     if (FALSE) {
[17:46:46.993]     }
[17:46:46.993]     else {
[17:46:46.993]         if (TRUE) {
[17:46:46.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:46.993]                 open = "w")
[17:46:46.993]         }
[17:46:46.993]         else {
[17:46:46.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:46.993]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:46.993]         }
[17:46:46.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:46.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:46.993]             base::sink(type = "output", split = FALSE)
[17:46:46.993]             base::close(...future.stdout)
[17:46:46.993]         }, add = TRUE)
[17:46:46.993]     }
[17:46:46.993]     ...future.frame <- base::sys.nframe()
[17:46:46.993]     ...future.conditions <- base::list()
[17:46:46.993]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:46.993]     if (FALSE) {
[17:46:46.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:46.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:46.993]     }
[17:46:46.993]     ...future.result <- base::tryCatch({
[17:46:46.993]         base::withCallingHandlers({
[17:46:46.993]             ...future.value <- base::withVisible(base::local({
[17:46:46.993]                 withCallingHandlers({
[17:46:46.993]                   2
[17:46:46.993]                 }, immediateCondition = function(cond) {
[17:46:46.993]                   save_rds <- function (object, pathname, ...) 
[17:46:46.993]                   {
[17:46:46.993]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:46.993]                     if (file_test("-f", pathname_tmp)) {
[17:46:46.993]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.993]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:46.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.993]                         fi_tmp[["mtime"]])
[17:46:46.993]                     }
[17:46:46.993]                     tryCatch({
[17:46:46.993]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:46.993]                     }, error = function(ex) {
[17:46:46.993]                       msg <- conditionMessage(ex)
[17:46:46.993]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.993]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:46.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.993]                         fi_tmp[["mtime"]], msg)
[17:46:46.993]                       ex$message <- msg
[17:46:46.993]                       stop(ex)
[17:46:46.993]                     })
[17:46:46.993]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:46.993]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:46.993]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:46.993]                       fi_tmp <- file.info(pathname_tmp)
[17:46:46.993]                       fi <- file.info(pathname)
[17:46:46.993]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:46.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:46.993]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:46.993]                         fi[["size"]], fi[["mtime"]])
[17:46:46.993]                       stop(msg)
[17:46:46.993]                     }
[17:46:46.993]                     invisible(pathname)
[17:46:46.993]                   }
[17:46:46.993]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:46.993]                     rootPath = tempdir()) 
[17:46:46.993]                   {
[17:46:46.993]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:46.993]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:46.993]                       tmpdir = path, fileext = ".rds")
[17:46:46.993]                     save_rds(obj, file)
[17:46:46.993]                   }
[17:46:46.993]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:46.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.993]                   {
[17:46:46.993]                     inherits <- base::inherits
[17:46:46.993]                     invokeRestart <- base::invokeRestart
[17:46:46.993]                     is.null <- base::is.null
[17:46:46.993]                     muffled <- FALSE
[17:46:46.993]                     if (inherits(cond, "message")) {
[17:46:46.993]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:46.993]                       if (muffled) 
[17:46:46.993]                         invokeRestart("muffleMessage")
[17:46:46.993]                     }
[17:46:46.993]                     else if (inherits(cond, "warning")) {
[17:46:46.993]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:46.993]                       if (muffled) 
[17:46:46.993]                         invokeRestart("muffleWarning")
[17:46:46.993]                     }
[17:46:46.993]                     else if (inherits(cond, "condition")) {
[17:46:46.993]                       if (!is.null(pattern)) {
[17:46:46.993]                         computeRestarts <- base::computeRestarts
[17:46:46.993]                         grepl <- base::grepl
[17:46:46.993]                         restarts <- computeRestarts(cond)
[17:46:46.993]                         for (restart in restarts) {
[17:46:46.993]                           name <- restart$name
[17:46:46.993]                           if (is.null(name)) 
[17:46:46.993]                             next
[17:46:46.993]                           if (!grepl(pattern, name)) 
[17:46:46.993]                             next
[17:46:46.993]                           invokeRestart(restart)
[17:46:46.993]                           muffled <- TRUE
[17:46:46.993]                           break
[17:46:46.993]                         }
[17:46:46.993]                       }
[17:46:46.993]                     }
[17:46:46.993]                     invisible(muffled)
[17:46:46.993]                   }
[17:46:46.993]                   muffleCondition(cond)
[17:46:46.993]                 })
[17:46:46.993]             }))
[17:46:46.993]             future::FutureResult(value = ...future.value$value, 
[17:46:46.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.993]                   ...future.rng), globalenv = if (FALSE) 
[17:46:46.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:46.993]                     ...future.globalenv.names))
[17:46:46.993]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:46.993]         }, condition = base::local({
[17:46:46.993]             c <- base::c
[17:46:46.993]             inherits <- base::inherits
[17:46:46.993]             invokeRestart <- base::invokeRestart
[17:46:46.993]             length <- base::length
[17:46:46.993]             list <- base::list
[17:46:46.993]             seq.int <- base::seq.int
[17:46:46.993]             signalCondition <- base::signalCondition
[17:46:46.993]             sys.calls <- base::sys.calls
[17:46:46.993]             `[[` <- base::`[[`
[17:46:46.993]             `+` <- base::`+`
[17:46:46.993]             `<<-` <- base::`<<-`
[17:46:46.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:46.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:46.993]                   3L)]
[17:46:46.993]             }
[17:46:46.993]             function(cond) {
[17:46:46.993]                 is_error <- inherits(cond, "error")
[17:46:46.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:46.993]                   NULL)
[17:46:46.993]                 if (is_error) {
[17:46:46.993]                   sessionInformation <- function() {
[17:46:46.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:46.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:46.993]                       search = base::search(), system = base::Sys.info())
[17:46:46.993]                   }
[17:46:46.993]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:46.993]                     cond$call), session = sessionInformation(), 
[17:46:46.993]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:46.993]                   signalCondition(cond)
[17:46:46.993]                 }
[17:46:46.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:46.993]                 "immediateCondition"))) {
[17:46:46.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:46.993]                   ...future.conditions[[length(...future.conditions) + 
[17:46:46.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:46.993]                   if (TRUE && !signal) {
[17:46:46.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.993]                     {
[17:46:46.993]                       inherits <- base::inherits
[17:46:46.993]                       invokeRestart <- base::invokeRestart
[17:46:46.993]                       is.null <- base::is.null
[17:46:46.993]                       muffled <- FALSE
[17:46:46.993]                       if (inherits(cond, "message")) {
[17:46:46.993]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.993]                         if (muffled) 
[17:46:46.993]                           invokeRestart("muffleMessage")
[17:46:46.993]                       }
[17:46:46.993]                       else if (inherits(cond, "warning")) {
[17:46:46.993]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.993]                         if (muffled) 
[17:46:46.993]                           invokeRestart("muffleWarning")
[17:46:46.993]                       }
[17:46:46.993]                       else if (inherits(cond, "condition")) {
[17:46:46.993]                         if (!is.null(pattern)) {
[17:46:46.993]                           computeRestarts <- base::computeRestarts
[17:46:46.993]                           grepl <- base::grepl
[17:46:46.993]                           restarts <- computeRestarts(cond)
[17:46:46.993]                           for (restart in restarts) {
[17:46:46.993]                             name <- restart$name
[17:46:46.993]                             if (is.null(name)) 
[17:46:46.993]                               next
[17:46:46.993]                             if (!grepl(pattern, name)) 
[17:46:46.993]                               next
[17:46:46.993]                             invokeRestart(restart)
[17:46:46.993]                             muffled <- TRUE
[17:46:46.993]                             break
[17:46:46.993]                           }
[17:46:46.993]                         }
[17:46:46.993]                       }
[17:46:46.993]                       invisible(muffled)
[17:46:46.993]                     }
[17:46:46.993]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.993]                   }
[17:46:46.993]                 }
[17:46:46.993]                 else {
[17:46:46.993]                   if (TRUE) {
[17:46:46.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:46.993]                     {
[17:46:46.993]                       inherits <- base::inherits
[17:46:46.993]                       invokeRestart <- base::invokeRestart
[17:46:46.993]                       is.null <- base::is.null
[17:46:46.993]                       muffled <- FALSE
[17:46:46.993]                       if (inherits(cond, "message")) {
[17:46:46.993]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:46.993]                         if (muffled) 
[17:46:46.993]                           invokeRestart("muffleMessage")
[17:46:46.993]                       }
[17:46:46.993]                       else if (inherits(cond, "warning")) {
[17:46:46.993]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:46.993]                         if (muffled) 
[17:46:46.993]                           invokeRestart("muffleWarning")
[17:46:46.993]                       }
[17:46:46.993]                       else if (inherits(cond, "condition")) {
[17:46:46.993]                         if (!is.null(pattern)) {
[17:46:46.993]                           computeRestarts <- base::computeRestarts
[17:46:46.993]                           grepl <- base::grepl
[17:46:46.993]                           restarts <- computeRestarts(cond)
[17:46:46.993]                           for (restart in restarts) {
[17:46:46.993]                             name <- restart$name
[17:46:46.993]                             if (is.null(name)) 
[17:46:46.993]                               next
[17:46:46.993]                             if (!grepl(pattern, name)) 
[17:46:46.993]                               next
[17:46:46.993]                             invokeRestart(restart)
[17:46:46.993]                             muffled <- TRUE
[17:46:46.993]                             break
[17:46:46.993]                           }
[17:46:46.993]                         }
[17:46:46.993]                       }
[17:46:46.993]                       invisible(muffled)
[17:46:46.993]                     }
[17:46:46.993]                     muffleCondition(cond, pattern = "^muffle")
[17:46:46.993]                   }
[17:46:46.993]                 }
[17:46:46.993]             }
[17:46:46.993]         }))
[17:46:46.993]     }, error = function(ex) {
[17:46:46.993]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:46.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:46.993]                 ...future.rng), started = ...future.startTime, 
[17:46:46.993]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:46.993]             version = "1.8"), class = "FutureResult")
[17:46:46.993]     }, finally = {
[17:46:46.993]         if (!identical(...future.workdir, getwd())) 
[17:46:46.993]             setwd(...future.workdir)
[17:46:46.993]         {
[17:46:46.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:46.993]                 ...future.oldOptions$nwarnings <- NULL
[17:46:46.993]             }
[17:46:46.993]             base::options(...future.oldOptions)
[17:46:46.993]             if (.Platform$OS.type == "windows") {
[17:46:46.993]                 old_names <- names(...future.oldEnvVars)
[17:46:46.993]                 envs <- base::Sys.getenv()
[17:46:46.993]                 names <- names(envs)
[17:46:46.993]                 common <- intersect(names, old_names)
[17:46:46.993]                 added <- setdiff(names, old_names)
[17:46:46.993]                 removed <- setdiff(old_names, names)
[17:46:46.993]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:46.993]                   envs[common]]
[17:46:46.993]                 NAMES <- toupper(changed)
[17:46:46.993]                 args <- list()
[17:46:46.993]                 for (kk in seq_along(NAMES)) {
[17:46:46.993]                   name <- changed[[kk]]
[17:46:46.993]                   NAME <- NAMES[[kk]]
[17:46:46.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.993]                     next
[17:46:46.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.993]                 }
[17:46:46.993]                 NAMES <- toupper(added)
[17:46:46.993]                 for (kk in seq_along(NAMES)) {
[17:46:46.993]                   name <- added[[kk]]
[17:46:46.993]                   NAME <- NAMES[[kk]]
[17:46:46.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.993]                     next
[17:46:46.993]                   args[[name]] <- ""
[17:46:46.993]                 }
[17:46:46.993]                 NAMES <- toupper(removed)
[17:46:46.993]                 for (kk in seq_along(NAMES)) {
[17:46:46.993]                   name <- removed[[kk]]
[17:46:46.993]                   NAME <- NAMES[[kk]]
[17:46:46.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:46.993]                     next
[17:46:46.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:46.993]                 }
[17:46:46.993]                 if (length(args) > 0) 
[17:46:46.993]                   base::do.call(base::Sys.setenv, args = args)
[17:46:46.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:46.993]             }
[17:46:46.993]             else {
[17:46:46.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:46.993]             }
[17:46:46.993]             {
[17:46:46.993]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:46.993]                   0L) {
[17:46:46.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:46.993]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:46.993]                   base::options(opts)
[17:46:46.993]                 }
[17:46:46.993]                 {
[17:46:46.993]                   {
[17:46:46.993]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:46.993]                     NULL
[17:46:46.993]                   }
[17:46:46.993]                   options(future.plan = NULL)
[17:46:46.993]                   if (is.na(NA_character_)) 
[17:46:46.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:46.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:46.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:46.993]                     .init = FALSE)
[17:46:46.993]                 }
[17:46:46.993]             }
[17:46:46.993]         }
[17:46:46.993]     })
[17:46:46.993]     if (TRUE) {
[17:46:46.993]         base::sink(type = "output", split = FALSE)
[17:46:46.993]         if (TRUE) {
[17:46:46.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:46.993]         }
[17:46:46.993]         else {
[17:46:46.993]             ...future.result["stdout"] <- base::list(NULL)
[17:46:46.993]         }
[17:46:46.993]         base::close(...future.stdout)
[17:46:46.993]         ...future.stdout <- NULL
[17:46:46.993]     }
[17:46:46.993]     ...future.result$conditions <- ...future.conditions
[17:46:46.993]     ...future.result$finished <- base::Sys.time()
[17:46:46.993]     ...future.result
[17:46:46.993] }
[17:46:46.995] requestCore(): workers = 2
[17:46:46.997] MulticoreFuture started
[17:46:46.997] - Launch lazy future ... done
[17:46:46.998] run() for ‘MulticoreFuture’ ... done
[17:46:46.998] getGlobalsAndPackages() ...
[17:46:46.998] Searching for globals...
[17:46:46.998] plan(): Setting new future strategy stack:
[17:46:46.999] 
[17:46:46.998] List of future strategies:
[17:46:46.998] 1. sequential:
[17:46:46.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:46.998]    - tweaked: FALSE
[17:46:46.998]    - call: NULL
[17:46:46.999] Searching for globals ... DONE
[17:46:46.999] plan(): nbrOfWorkers() = 1
[17:46:46.999] - globals: [0] <none>
[17:46:46.999] getGlobalsAndPackages() ... DONE
[17:46:47.000] run() for ‘Future’ ...
[17:46:47.000] - state: ‘created’
[17:46:47.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.001] plan(): Setting new future strategy stack:
[17:46:47.001] List of future strategies:
[17:46:47.001] 1. multicore:
[17:46:47.001]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:47.001]    - tweaked: FALSE
[17:46:47.001]    - call: plan(strategy)
[17:46:47.005] plan(): nbrOfWorkers() = 2
[17:46:47.005] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:47.006]   - Field: ‘label’
[17:46:47.006]   - Field: ‘local’
[17:46:47.006]   - Field: ‘owner’
[17:46:47.006]   - Field: ‘envir’
[17:46:47.006]   - Field: ‘workers’
[17:46:47.006]   - Field: ‘packages’
[17:46:47.006]   - Field: ‘gc’
[17:46:47.007]   - Field: ‘job’
[17:46:47.007]   - Field: ‘conditions’
[17:46:47.007]   - Field: ‘expr’
[17:46:47.007]   - Field: ‘uuid’
[17:46:47.007]   - Field: ‘seed’
[17:46:47.007]   - Field: ‘version’
[17:46:47.007]   - Field: ‘result’
[17:46:47.008]   - Field: ‘asynchronous’
[17:46:47.008]   - Field: ‘calls’
[17:46:47.008]   - Field: ‘globals’
[17:46:47.008]   - Field: ‘stdout’
[17:46:47.008]   - Field: ‘earlySignal’
[17:46:47.008]   - Field: ‘lazy’
[17:46:47.008]   - Field: ‘state’
[17:46:47.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:47.009] - Launch lazy future ...
[17:46:47.009] Packages needed by the future expression (n = 0): <none>
[17:46:47.009] Packages needed by future strategies (n = 0): <none>
[17:46:47.010] {
[17:46:47.010]     {
[17:46:47.010]         {
[17:46:47.010]             ...future.startTime <- base::Sys.time()
[17:46:47.010]             {
[17:46:47.010]                 {
[17:46:47.010]                   {
[17:46:47.010]                     {
[17:46:47.010]                       base::local({
[17:46:47.010]                         has_future <- base::requireNamespace("future", 
[17:46:47.010]                           quietly = TRUE)
[17:46:47.010]                         if (has_future) {
[17:46:47.010]                           ns <- base::getNamespace("future")
[17:46:47.010]                           version <- ns[[".package"]][["version"]]
[17:46:47.010]                           if (is.null(version)) 
[17:46:47.010]                             version <- utils::packageVersion("future")
[17:46:47.010]                         }
[17:46:47.010]                         else {
[17:46:47.010]                           version <- NULL
[17:46:47.010]                         }
[17:46:47.010]                         if (!has_future || version < "1.8.0") {
[17:46:47.010]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.010]                             "", base::R.version$version.string), 
[17:46:47.010]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.010]                               "release", "version")], collapse = " "), 
[17:46:47.010]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.010]                             info)
[17:46:47.010]                           info <- base::paste(info, collapse = "; ")
[17:46:47.010]                           if (!has_future) {
[17:46:47.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.010]                               info)
[17:46:47.010]                           }
[17:46:47.010]                           else {
[17:46:47.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.010]                               info, version)
[17:46:47.010]                           }
[17:46:47.010]                           base::stop(msg)
[17:46:47.010]                         }
[17:46:47.010]                       })
[17:46:47.010]                     }
[17:46:47.010]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.010]                     base::options(mc.cores = 1L)
[17:46:47.010]                   }
[17:46:47.010]                   ...future.strategy.old <- future::plan("list")
[17:46:47.010]                   options(future.plan = NULL)
[17:46:47.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.010]                 }
[17:46:47.010]                 ...future.workdir <- getwd()
[17:46:47.010]             }
[17:46:47.010]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.010]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.010]         }
[17:46:47.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.010]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.010]             base::names(...future.oldOptions))
[17:46:47.010]     }
[17:46:47.010]     if (FALSE) {
[17:46:47.010]     }
[17:46:47.010]     else {
[17:46:47.010]         if (TRUE) {
[17:46:47.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.010]                 open = "w")
[17:46:47.010]         }
[17:46:47.010]         else {
[17:46:47.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.010]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.010]         }
[17:46:47.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.010]             base::sink(type = "output", split = FALSE)
[17:46:47.010]             base::close(...future.stdout)
[17:46:47.010]         }, add = TRUE)
[17:46:47.010]     }
[17:46:47.010]     ...future.frame <- base::sys.nframe()
[17:46:47.010]     ...future.conditions <- base::list()
[17:46:47.010]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.010]     if (FALSE) {
[17:46:47.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.010]     }
[17:46:47.010]     ...future.result <- base::tryCatch({
[17:46:47.010]         base::withCallingHandlers({
[17:46:47.010]             ...future.value <- base::withVisible(base::local({
[17:46:47.010]                 withCallingHandlers({
[17:46:47.010]                   NULL
[17:46:47.010]                 }, immediateCondition = function(cond) {
[17:46:47.010]                   save_rds <- function (object, pathname, ...) 
[17:46:47.010]                   {
[17:46:47.010]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:47.010]                     if (file_test("-f", pathname_tmp)) {
[17:46:47.010]                       fi_tmp <- file.info(pathname_tmp)
[17:46:47.010]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:47.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:47.010]                         fi_tmp[["mtime"]])
[17:46:47.010]                     }
[17:46:47.010]                     tryCatch({
[17:46:47.010]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:47.010]                     }, error = function(ex) {
[17:46:47.010]                       msg <- conditionMessage(ex)
[17:46:47.010]                       fi_tmp <- file.info(pathname_tmp)
[17:46:47.010]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:47.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:47.010]                         fi_tmp[["mtime"]], msg)
[17:46:47.010]                       ex$message <- msg
[17:46:47.010]                       stop(ex)
[17:46:47.010]                     })
[17:46:47.010]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:47.010]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:47.010]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:47.010]                       fi_tmp <- file.info(pathname_tmp)
[17:46:47.010]                       fi <- file.info(pathname)
[17:46:47.010]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:47.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:47.010]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:47.010]                         fi[["size"]], fi[["mtime"]])
[17:46:47.010]                       stop(msg)
[17:46:47.010]                     }
[17:46:47.010]                     invisible(pathname)
[17:46:47.010]                   }
[17:46:47.010]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:47.010]                     rootPath = tempdir()) 
[17:46:47.010]                   {
[17:46:47.010]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:47.010]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:47.010]                       tmpdir = path, fileext = ".rds")
[17:46:47.010]                     save_rds(obj, file)
[17:46:47.010]                   }
[17:46:47.010]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:47.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.010]                   {
[17:46:47.010]                     inherits <- base::inherits
[17:46:47.010]                     invokeRestart <- base::invokeRestart
[17:46:47.010]                     is.null <- base::is.null
[17:46:47.010]                     muffled <- FALSE
[17:46:47.010]                     if (inherits(cond, "message")) {
[17:46:47.010]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.010]                       if (muffled) 
[17:46:47.010]                         invokeRestart("muffleMessage")
[17:46:47.010]                     }
[17:46:47.010]                     else if (inherits(cond, "warning")) {
[17:46:47.010]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.010]                       if (muffled) 
[17:46:47.010]                         invokeRestart("muffleWarning")
[17:46:47.010]                     }
[17:46:47.010]                     else if (inherits(cond, "condition")) {
[17:46:47.010]                       if (!is.null(pattern)) {
[17:46:47.010]                         computeRestarts <- base::computeRestarts
[17:46:47.010]                         grepl <- base::grepl
[17:46:47.010]                         restarts <- computeRestarts(cond)
[17:46:47.010]                         for (restart in restarts) {
[17:46:47.010]                           name <- restart$name
[17:46:47.010]                           if (is.null(name)) 
[17:46:47.010]                             next
[17:46:47.010]                           if (!grepl(pattern, name)) 
[17:46:47.010]                             next
[17:46:47.010]                           invokeRestart(restart)
[17:46:47.010]                           muffled <- TRUE
[17:46:47.010]                           break
[17:46:47.010]                         }
[17:46:47.010]                       }
[17:46:47.010]                     }
[17:46:47.010]                     invisible(muffled)
[17:46:47.010]                   }
[17:46:47.010]                   muffleCondition(cond)
[17:46:47.010]                 })
[17:46:47.010]             }))
[17:46:47.010]             future::FutureResult(value = ...future.value$value, 
[17:46:47.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.010]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.010]                     ...future.globalenv.names))
[17:46:47.010]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.010]         }, condition = base::local({
[17:46:47.010]             c <- base::c
[17:46:47.010]             inherits <- base::inherits
[17:46:47.010]             invokeRestart <- base::invokeRestart
[17:46:47.010]             length <- base::length
[17:46:47.010]             list <- base::list
[17:46:47.010]             seq.int <- base::seq.int
[17:46:47.010]             signalCondition <- base::signalCondition
[17:46:47.010]             sys.calls <- base::sys.calls
[17:46:47.010]             `[[` <- base::`[[`
[17:46:47.010]             `+` <- base::`+`
[17:46:47.010]             `<<-` <- base::`<<-`
[17:46:47.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.010]                   3L)]
[17:46:47.010]             }
[17:46:47.010]             function(cond) {
[17:46:47.010]                 is_error <- inherits(cond, "error")
[17:46:47.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.010]                   NULL)
[17:46:47.010]                 if (is_error) {
[17:46:47.010]                   sessionInformation <- function() {
[17:46:47.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.010]                       search = base::search(), system = base::Sys.info())
[17:46:47.010]                   }
[17:46:47.010]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.010]                     cond$call), session = sessionInformation(), 
[17:46:47.010]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.010]                   signalCondition(cond)
[17:46:47.010]                 }
[17:46:47.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.010]                 "immediateCondition"))) {
[17:46:47.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.010]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.010]                   if (TRUE && !signal) {
[17:46:47.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.010]                     {
[17:46:47.010]                       inherits <- base::inherits
[17:46:47.010]                       invokeRestart <- base::invokeRestart
[17:46:47.010]                       is.null <- base::is.null
[17:46:47.010]                       muffled <- FALSE
[17:46:47.010]                       if (inherits(cond, "message")) {
[17:46:47.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.010]                         if (muffled) 
[17:46:47.010]                           invokeRestart("muffleMessage")
[17:46:47.010]                       }
[17:46:47.010]                       else if (inherits(cond, "warning")) {
[17:46:47.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.010]                         if (muffled) 
[17:46:47.010]                           invokeRestart("muffleWarning")
[17:46:47.010]                       }
[17:46:47.010]                       else if (inherits(cond, "condition")) {
[17:46:47.010]                         if (!is.null(pattern)) {
[17:46:47.010]                           computeRestarts <- base::computeRestarts
[17:46:47.010]                           grepl <- base::grepl
[17:46:47.010]                           restarts <- computeRestarts(cond)
[17:46:47.010]                           for (restart in restarts) {
[17:46:47.010]                             name <- restart$name
[17:46:47.010]                             if (is.null(name)) 
[17:46:47.010]                               next
[17:46:47.010]                             if (!grepl(pattern, name)) 
[17:46:47.010]                               next
[17:46:47.010]                             invokeRestart(restart)
[17:46:47.010]                             muffled <- TRUE
[17:46:47.010]                             break
[17:46:47.010]                           }
[17:46:47.010]                         }
[17:46:47.010]                       }
[17:46:47.010]                       invisible(muffled)
[17:46:47.010]                     }
[17:46:47.010]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.010]                   }
[17:46:47.010]                 }
[17:46:47.010]                 else {
[17:46:47.010]                   if (TRUE) {
[17:46:47.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.010]                     {
[17:46:47.010]                       inherits <- base::inherits
[17:46:47.010]                       invokeRestart <- base::invokeRestart
[17:46:47.010]                       is.null <- base::is.null
[17:46:47.010]                       muffled <- FALSE
[17:46:47.010]                       if (inherits(cond, "message")) {
[17:46:47.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.010]                         if (muffled) 
[17:46:47.010]                           invokeRestart("muffleMessage")
[17:46:47.010]                       }
[17:46:47.010]                       else if (inherits(cond, "warning")) {
[17:46:47.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.010]                         if (muffled) 
[17:46:47.010]                           invokeRestart("muffleWarning")
[17:46:47.010]                       }
[17:46:47.010]                       else if (inherits(cond, "condition")) {
[17:46:47.010]                         if (!is.null(pattern)) {
[17:46:47.010]                           computeRestarts <- base::computeRestarts
[17:46:47.010]                           grepl <- base::grepl
[17:46:47.010]                           restarts <- computeRestarts(cond)
[17:46:47.010]                           for (restart in restarts) {
[17:46:47.010]                             name <- restart$name
[17:46:47.010]                             if (is.null(name)) 
[17:46:47.010]                               next
[17:46:47.010]                             if (!grepl(pattern, name)) 
[17:46:47.010]                               next
[17:46:47.010]                             invokeRestart(restart)
[17:46:47.010]                             muffled <- TRUE
[17:46:47.010]                             break
[17:46:47.010]                           }
[17:46:47.010]                         }
[17:46:47.010]                       }
[17:46:47.010]                       invisible(muffled)
[17:46:47.010]                     }
[17:46:47.010]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.010]                   }
[17:46:47.010]                 }
[17:46:47.010]             }
[17:46:47.010]         }))
[17:46:47.010]     }, error = function(ex) {
[17:46:47.010]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.010]                 ...future.rng), started = ...future.startTime, 
[17:46:47.010]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.010]             version = "1.8"), class = "FutureResult")
[17:46:47.010]     }, finally = {
[17:46:47.010]         if (!identical(...future.workdir, getwd())) 
[17:46:47.010]             setwd(...future.workdir)
[17:46:47.010]         {
[17:46:47.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.010]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.010]             }
[17:46:47.010]             base::options(...future.oldOptions)
[17:46:47.010]             if (.Platform$OS.type == "windows") {
[17:46:47.010]                 old_names <- names(...future.oldEnvVars)
[17:46:47.010]                 envs <- base::Sys.getenv()
[17:46:47.010]                 names <- names(envs)
[17:46:47.010]                 common <- intersect(names, old_names)
[17:46:47.010]                 added <- setdiff(names, old_names)
[17:46:47.010]                 removed <- setdiff(old_names, names)
[17:46:47.010]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.010]                   envs[common]]
[17:46:47.010]                 NAMES <- toupper(changed)
[17:46:47.010]                 args <- list()
[17:46:47.010]                 for (kk in seq_along(NAMES)) {
[17:46:47.010]                   name <- changed[[kk]]
[17:46:47.010]                   NAME <- NAMES[[kk]]
[17:46:47.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.010]                     next
[17:46:47.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.010]                 }
[17:46:47.010]                 NAMES <- toupper(added)
[17:46:47.010]                 for (kk in seq_along(NAMES)) {
[17:46:47.010]                   name <- added[[kk]]
[17:46:47.010]                   NAME <- NAMES[[kk]]
[17:46:47.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.010]                     next
[17:46:47.010]                   args[[name]] <- ""
[17:46:47.010]                 }
[17:46:47.010]                 NAMES <- toupper(removed)
[17:46:47.010]                 for (kk in seq_along(NAMES)) {
[17:46:47.010]                   name <- removed[[kk]]
[17:46:47.010]                   NAME <- NAMES[[kk]]
[17:46:47.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.010]                     next
[17:46:47.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.010]                 }
[17:46:47.010]                 if (length(args) > 0) 
[17:46:47.010]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.010]             }
[17:46:47.010]             else {
[17:46:47.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.010]             }
[17:46:47.010]             {
[17:46:47.010]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.010]                   0L) {
[17:46:47.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.010]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.010]                   base::options(opts)
[17:46:47.010]                 }
[17:46:47.010]                 {
[17:46:47.010]                   {
[17:46:47.010]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.010]                     NULL
[17:46:47.010]                   }
[17:46:47.010]                   options(future.plan = NULL)
[17:46:47.010]                   if (is.na(NA_character_)) 
[17:46:47.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.010]                     .init = FALSE)
[17:46:47.010]                 }
[17:46:47.010]             }
[17:46:47.010]         }
[17:46:47.010]     })
[17:46:47.010]     if (TRUE) {
[17:46:47.010]         base::sink(type = "output", split = FALSE)
[17:46:47.010]         if (TRUE) {
[17:46:47.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.010]         }
[17:46:47.010]         else {
[17:46:47.010]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.010]         }
[17:46:47.010]         base::close(...future.stdout)
[17:46:47.010]         ...future.stdout <- NULL
[17:46:47.010]     }
[17:46:47.010]     ...future.result$conditions <- ...future.conditions
[17:46:47.010]     ...future.result$finished <- base::Sys.time()
[17:46:47.010]     ...future.result
[17:46:47.010] }
[17:46:47.014] requestCore(): workers = 2
[17:46:47.016] MulticoreFuture started
[17:46:47.016] - Launch lazy future ... done
[17:46:47.016] run() for ‘MulticoreFuture’ ... done
[17:46:47.017] plan(): Setting new future strategy stack:
[17:46:47.017] getGlobalsAndPackages() ...
[17:46:47.017] Searching for globals...
[17:46:47.017] List of future strategies:
[17:46:47.017] 1. sequential:
[17:46:47.017]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:47.017]    - tweaked: FALSE
[17:46:47.017]    - call: NULL
[17:46:47.018] plan(): nbrOfWorkers() = 1
[17:46:47.019] - globals found: [1] ‘{’
[17:46:47.019] Searching for globals ... DONE
[17:46:47.019] Resolving globals: FALSE
[17:46:47.020] 
[17:46:47.020] 
[17:46:47.020] getGlobalsAndPackages() ... DONE
[17:46:47.020] plan(): Setting new future strategy stack:
[17:46:47.021] run() for ‘Future’ ...
[17:46:47.021] - state: ‘created’
[17:46:47.021] List of future strategies:
[17:46:47.021] 1. multicore:
[17:46:47.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:47.021]    - tweaked: FALSE
[17:46:47.021]    - call: plan(strategy)
[17:46:47.021] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.026] plan(): nbrOfWorkers() = 2
[17:46:47.026] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.027] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:47.027]   - Field: ‘label’
[17:46:47.027]   - Field: ‘local’
[17:46:47.027]   - Field: ‘owner’
[17:46:47.027]   - Field: ‘envir’
[17:46:47.027]   - Field: ‘workers’
[17:46:47.028]   - Field: ‘packages’
[17:46:47.028]   - Field: ‘gc’
[17:46:47.028]   - Field: ‘job’
[17:46:47.028]   - Field: ‘conditions’
[17:46:47.028]   - Field: ‘expr’
[17:46:47.028]   - Field: ‘uuid’
[17:46:47.029]   - Field: ‘seed’
[17:46:47.029]   - Field: ‘version’
[17:46:47.029]   - Field: ‘result’
[17:46:47.029]   - Field: ‘asynchronous’
[17:46:47.029]   - Field: ‘calls’
[17:46:47.029]   - Field: ‘globals’
[17:46:47.029]   - Field: ‘stdout’
[17:46:47.030]   - Field: ‘earlySignal’
[17:46:47.030]   - Field: ‘lazy’
[17:46:47.030]   - Field: ‘state’
[17:46:47.030] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:47.030] - Launch lazy future ...
[17:46:47.031] Packages needed by the future expression (n = 0): <none>
[17:46:47.031] Packages needed by future strategies (n = 0): <none>
[17:46:47.032] {
[17:46:47.032]     {
[17:46:47.032]         {
[17:46:47.032]             ...future.startTime <- base::Sys.time()
[17:46:47.032]             {
[17:46:47.032]                 {
[17:46:47.032]                   {
[17:46:47.032]                     {
[17:46:47.032]                       base::local({
[17:46:47.032]                         has_future <- base::requireNamespace("future", 
[17:46:47.032]                           quietly = TRUE)
[17:46:47.032]                         if (has_future) {
[17:46:47.032]                           ns <- base::getNamespace("future")
[17:46:47.032]                           version <- ns[[".package"]][["version"]]
[17:46:47.032]                           if (is.null(version)) 
[17:46:47.032]                             version <- utils::packageVersion("future")
[17:46:47.032]                         }
[17:46:47.032]                         else {
[17:46:47.032]                           version <- NULL
[17:46:47.032]                         }
[17:46:47.032]                         if (!has_future || version < "1.8.0") {
[17:46:47.032]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.032]                             "", base::R.version$version.string), 
[17:46:47.032]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.032]                               "release", "version")], collapse = " "), 
[17:46:47.032]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.032]                             info)
[17:46:47.032]                           info <- base::paste(info, collapse = "; ")
[17:46:47.032]                           if (!has_future) {
[17:46:47.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.032]                               info)
[17:46:47.032]                           }
[17:46:47.032]                           else {
[17:46:47.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.032]                               info, version)
[17:46:47.032]                           }
[17:46:47.032]                           base::stop(msg)
[17:46:47.032]                         }
[17:46:47.032]                       })
[17:46:47.032]                     }
[17:46:47.032]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.032]                     base::options(mc.cores = 1L)
[17:46:47.032]                   }
[17:46:47.032]                   ...future.strategy.old <- future::plan("list")
[17:46:47.032]                   options(future.plan = NULL)
[17:46:47.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.032]                 }
[17:46:47.032]                 ...future.workdir <- getwd()
[17:46:47.032]             }
[17:46:47.032]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.032]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.032]         }
[17:46:47.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.032]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.032]             base::names(...future.oldOptions))
[17:46:47.032]     }
[17:46:47.032]     if (FALSE) {
[17:46:47.032]     }
[17:46:47.032]     else {
[17:46:47.032]         if (TRUE) {
[17:46:47.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.032]                 open = "w")
[17:46:47.032]         }
[17:46:47.032]         else {
[17:46:47.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.032]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.032]         }
[17:46:47.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.032]             base::sink(type = "output", split = FALSE)
[17:46:47.032]             base::close(...future.stdout)
[17:46:47.032]         }, add = TRUE)
[17:46:47.032]     }
[17:46:47.032]     ...future.frame <- base::sys.nframe()
[17:46:47.032]     ...future.conditions <- base::list()
[17:46:47.032]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.032]     if (FALSE) {
[17:46:47.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.032]     }
[17:46:47.032]     ...future.result <- base::tryCatch({
[17:46:47.032]         base::withCallingHandlers({
[17:46:47.032]             ...future.value <- base::withVisible(base::local({
[17:46:47.032]                 withCallingHandlers({
[17:46:47.032]                   {
[17:46:47.032]                     4
[17:46:47.032]                   }
[17:46:47.032]                 }, immediateCondition = function(cond) {
[17:46:47.032]                   save_rds <- function (object, pathname, ...) 
[17:46:47.032]                   {
[17:46:47.032]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:47.032]                     if (file_test("-f", pathname_tmp)) {
[17:46:47.032]                       fi_tmp <- file.info(pathname_tmp)
[17:46:47.032]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:47.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:47.032]                         fi_tmp[["mtime"]])
[17:46:47.032]                     }
[17:46:47.032]                     tryCatch({
[17:46:47.032]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:47.032]                     }, error = function(ex) {
[17:46:47.032]                       msg <- conditionMessage(ex)
[17:46:47.032]                       fi_tmp <- file.info(pathname_tmp)
[17:46:47.032]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:47.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:47.032]                         fi_tmp[["mtime"]], msg)
[17:46:47.032]                       ex$message <- msg
[17:46:47.032]                       stop(ex)
[17:46:47.032]                     })
[17:46:47.032]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:47.032]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:47.032]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:47.032]                       fi_tmp <- file.info(pathname_tmp)
[17:46:47.032]                       fi <- file.info(pathname)
[17:46:47.032]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:47.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:47.032]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:47.032]                         fi[["size"]], fi[["mtime"]])
[17:46:47.032]                       stop(msg)
[17:46:47.032]                     }
[17:46:47.032]                     invisible(pathname)
[17:46:47.032]                   }
[17:46:47.032]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:47.032]                     rootPath = tempdir()) 
[17:46:47.032]                   {
[17:46:47.032]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:47.032]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:47.032]                       tmpdir = path, fileext = ".rds")
[17:46:47.032]                     save_rds(obj, file)
[17:46:47.032]                   }
[17:46:47.032]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:47.032]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.032]                   {
[17:46:47.032]                     inherits <- base::inherits
[17:46:47.032]                     invokeRestart <- base::invokeRestart
[17:46:47.032]                     is.null <- base::is.null
[17:46:47.032]                     muffled <- FALSE
[17:46:47.032]                     if (inherits(cond, "message")) {
[17:46:47.032]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.032]                       if (muffled) 
[17:46:47.032]                         invokeRestart("muffleMessage")
[17:46:47.032]                     }
[17:46:47.032]                     else if (inherits(cond, "warning")) {
[17:46:47.032]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.032]                       if (muffled) 
[17:46:47.032]                         invokeRestart("muffleWarning")
[17:46:47.032]                     }
[17:46:47.032]                     else if (inherits(cond, "condition")) {
[17:46:47.032]                       if (!is.null(pattern)) {
[17:46:47.032]                         computeRestarts <- base::computeRestarts
[17:46:47.032]                         grepl <- base::grepl
[17:46:47.032]                         restarts <- computeRestarts(cond)
[17:46:47.032]                         for (restart in restarts) {
[17:46:47.032]                           name <- restart$name
[17:46:47.032]                           if (is.null(name)) 
[17:46:47.032]                             next
[17:46:47.032]                           if (!grepl(pattern, name)) 
[17:46:47.032]                             next
[17:46:47.032]                           invokeRestart(restart)
[17:46:47.032]                           muffled <- TRUE
[17:46:47.032]                           break
[17:46:47.032]                         }
[17:46:47.032]                       }
[17:46:47.032]                     }
[17:46:47.032]                     invisible(muffled)
[17:46:47.032]                   }
[17:46:47.032]                   muffleCondition(cond)
[17:46:47.032]                 })
[17:46:47.032]             }))
[17:46:47.032]             future::FutureResult(value = ...future.value$value, 
[17:46:47.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.032]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.032]                     ...future.globalenv.names))
[17:46:47.032]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.032]         }, condition = base::local({
[17:46:47.032]             c <- base::c
[17:46:47.032]             inherits <- base::inherits
[17:46:47.032]             invokeRestart <- base::invokeRestart
[17:46:47.032]             length <- base::length
[17:46:47.032]             list <- base::list
[17:46:47.032]             seq.int <- base::seq.int
[17:46:47.032]             signalCondition <- base::signalCondition
[17:46:47.032]             sys.calls <- base::sys.calls
[17:46:47.032]             `[[` <- base::`[[`
[17:46:47.032]             `+` <- base::`+`
[17:46:47.032]             `<<-` <- base::`<<-`
[17:46:47.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.032]                   3L)]
[17:46:47.032]             }
[17:46:47.032]             function(cond) {
[17:46:47.032]                 is_error <- inherits(cond, "error")
[17:46:47.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.032]                   NULL)
[17:46:47.032]                 if (is_error) {
[17:46:47.032]                   sessionInformation <- function() {
[17:46:47.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.032]                       search = base::search(), system = base::Sys.info())
[17:46:47.032]                   }
[17:46:47.032]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.032]                     cond$call), session = sessionInformation(), 
[17:46:47.032]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.032]                   signalCondition(cond)
[17:46:47.032]                 }
[17:46:47.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.032]                 "immediateCondition"))) {
[17:46:47.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.032]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.032]                   if (TRUE && !signal) {
[17:46:47.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.032]                     {
[17:46:47.032]                       inherits <- base::inherits
[17:46:47.032]                       invokeRestart <- base::invokeRestart
[17:46:47.032]                       is.null <- base::is.null
[17:46:47.032]                       muffled <- FALSE
[17:46:47.032]                       if (inherits(cond, "message")) {
[17:46:47.032]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.032]                         if (muffled) 
[17:46:47.032]                           invokeRestart("muffleMessage")
[17:46:47.032]                       }
[17:46:47.032]                       else if (inherits(cond, "warning")) {
[17:46:47.032]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.032]                         if (muffled) 
[17:46:47.032]                           invokeRestart("muffleWarning")
[17:46:47.032]                       }
[17:46:47.032]                       else if (inherits(cond, "condition")) {
[17:46:47.032]                         if (!is.null(pattern)) {
[17:46:47.032]                           computeRestarts <- base::computeRestarts
[17:46:47.032]                           grepl <- base::grepl
[17:46:47.032]                           restarts <- computeRestarts(cond)
[17:46:47.032]                           for (restart in restarts) {
[17:46:47.032]                             name <- restart$name
[17:46:47.032]                             if (is.null(name)) 
[17:46:47.032]                               next
[17:46:47.032]                             if (!grepl(pattern, name)) 
[17:46:47.032]                               next
[17:46:47.032]                             invokeRestart(restart)
[17:46:47.032]                             muffled <- TRUE
[17:46:47.032]                             break
[17:46:47.032]                           }
[17:46:47.032]                         }
[17:46:47.032]                       }
[17:46:47.032]                       invisible(muffled)
[17:46:47.032]                     }
[17:46:47.032]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.032]                   }
[17:46:47.032]                 }
[17:46:47.032]                 else {
[17:46:47.032]                   if (TRUE) {
[17:46:47.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.032]                     {
[17:46:47.032]                       inherits <- base::inherits
[17:46:47.032]                       invokeRestart <- base::invokeRestart
[17:46:47.032]                       is.null <- base::is.null
[17:46:47.032]                       muffled <- FALSE
[17:46:47.032]                       if (inherits(cond, "message")) {
[17:46:47.032]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.032]                         if (muffled) 
[17:46:47.032]                           invokeRestart("muffleMessage")
[17:46:47.032]                       }
[17:46:47.032]                       else if (inherits(cond, "warning")) {
[17:46:47.032]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.032]                         if (muffled) 
[17:46:47.032]                           invokeRestart("muffleWarning")
[17:46:47.032]                       }
[17:46:47.032]                       else if (inherits(cond, "condition")) {
[17:46:47.032]                         if (!is.null(pattern)) {
[17:46:47.032]                           computeRestarts <- base::computeRestarts
[17:46:47.032]                           grepl <- base::grepl
[17:46:47.032]                           restarts <- computeRestarts(cond)
[17:46:47.032]                           for (restart in restarts) {
[17:46:47.032]                             name <- restart$name
[17:46:47.032]                             if (is.null(name)) 
[17:46:47.032]                               next
[17:46:47.032]                             if (!grepl(pattern, name)) 
[17:46:47.032]                               next
[17:46:47.032]                             invokeRestart(restart)
[17:46:47.032]                             muffled <- TRUE
[17:46:47.032]                             break
[17:46:47.032]                           }
[17:46:47.032]                         }
[17:46:47.032]                       }
[17:46:47.032]                       invisible(muffled)
[17:46:47.032]                     }
[17:46:47.032]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.032]                   }
[17:46:47.032]                 }
[17:46:47.032]             }
[17:46:47.032]         }))
[17:46:47.032]     }, error = function(ex) {
[17:46:47.032]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.032]                 ...future.rng), started = ...future.startTime, 
[17:46:47.032]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.032]             version = "1.8"), class = "FutureResult")
[17:46:47.032]     }, finally = {
[17:46:47.032]         if (!identical(...future.workdir, getwd())) 
[17:46:47.032]             setwd(...future.workdir)
[17:46:47.032]         {
[17:46:47.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.032]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.032]             }
[17:46:47.032]             base::options(...future.oldOptions)
[17:46:47.032]             if (.Platform$OS.type == "windows") {
[17:46:47.032]                 old_names <- names(...future.oldEnvVars)
[17:46:47.032]                 envs <- base::Sys.getenv()
[17:46:47.032]                 names <- names(envs)
[17:46:47.032]                 common <- intersect(names, old_names)
[17:46:47.032]                 added <- setdiff(names, old_names)
[17:46:47.032]                 removed <- setdiff(old_names, names)
[17:46:47.032]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.032]                   envs[common]]
[17:46:47.032]                 NAMES <- toupper(changed)
[17:46:47.032]                 args <- list()
[17:46:47.032]                 for (kk in seq_along(NAMES)) {
[17:46:47.032]                   name <- changed[[kk]]
[17:46:47.032]                   NAME <- NAMES[[kk]]
[17:46:47.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.032]                     next
[17:46:47.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.032]                 }
[17:46:47.032]                 NAMES <- toupper(added)
[17:46:47.032]                 for (kk in seq_along(NAMES)) {
[17:46:47.032]                   name <- added[[kk]]
[17:46:47.032]                   NAME <- NAMES[[kk]]
[17:46:47.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.032]                     next
[17:46:47.032]                   args[[name]] <- ""
[17:46:47.032]                 }
[17:46:47.032]                 NAMES <- toupper(removed)
[17:46:47.032]                 for (kk in seq_along(NAMES)) {
[17:46:47.032]                   name <- removed[[kk]]
[17:46:47.032]                   NAME <- NAMES[[kk]]
[17:46:47.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.032]                     next
[17:46:47.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.032]                 }
[17:46:47.032]                 if (length(args) > 0) 
[17:46:47.032]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.032]             }
[17:46:47.032]             else {
[17:46:47.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.032]             }
[17:46:47.032]             {
[17:46:47.032]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.032]                   0L) {
[17:46:47.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.032]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.032]                   base::options(opts)
[17:46:47.032]                 }
[17:46:47.032]                 {
[17:46:47.032]                   {
[17:46:47.032]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.032]                     NULL
[17:46:47.032]                   }
[17:46:47.032]                   options(future.plan = NULL)
[17:46:47.032]                   if (is.na(NA_character_)) 
[17:46:47.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.032]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.032]                     .init = FALSE)
[17:46:47.032]                 }
[17:46:47.032]             }
[17:46:47.032]         }
[17:46:47.032]     })
[17:46:47.032]     if (TRUE) {
[17:46:47.032]         base::sink(type = "output", split = FALSE)
[17:46:47.032]         if (TRUE) {
[17:46:47.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.032]         }
[17:46:47.032]         else {
[17:46:47.032]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.032]         }
[17:46:47.032]         base::close(...future.stdout)
[17:46:47.032]         ...future.stdout <- NULL
[17:46:47.032]     }
[17:46:47.032]     ...future.result$conditions <- ...future.conditions
[17:46:47.032]     ...future.result$finished <- base::Sys.time()
[17:46:47.032]     ...future.result
[17:46:47.032] }
[17:46:47.035] requestCore(): workers = 2
[17:46:47.035] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:47.046] result() for MulticoreFuture ...
[17:46:47.047] result() for MulticoreFuture ...
[17:46:47.047] result() for MulticoreFuture ... done
[17:46:47.047] result() for MulticoreFuture ... done
[17:46:47.048] result() for MulticoreFuture ...
[17:46:47.048] result() for MulticoreFuture ... done
[17:46:47.050] MulticoreFuture started
[17:46:47.051] - Launch lazy future ... done
[17:46:47.051] run() for ‘MulticoreFuture’ ... done
[17:46:47.052] plan(): Setting new future strategy stack:
<environment: 0x561789d5b258> 
[17:46:47.052] List of future strategies:
[17:46:47.052] 1. sequential:
[17:46:47.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:47.052]    - tweaked: FALSE
[17:46:47.052]    - call: NULL
[17:46:47.054] plan(): nbrOfWorkers() = 1
<environment: 0x5617865eee48> 
[17:46:47.056] plan(): Setting new future strategy stack:
[17:46:47.057] List of future strategies:
[17:46:47.057] 1. multicore:
[17:46:47.057]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:47.057]    - tweaked: FALSE
[17:46:47.057]    - call: plan(strategy)
[17:46:47.062] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:47.065] resolve() on environment ...
[17:46:47.065]  recursive: 0
[17:46:47.066]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:47.067] signalConditionsASAP(numeric, pos=1) ...
[17:46:47.067] - nx: 4
[17:46:47.067] - relay: TRUE
[17:46:47.067] - stdout: TRUE
[17:46:47.067] - signal: TRUE
[17:46:47.067] - resignal: FALSE
[17:46:47.067] - force: TRUE
[17:46:47.068] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.068] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.068]  - until=2
[17:46:47.068]  - relaying element #2
[17:46:47.068] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.068] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.069] signalConditionsASAP(NULL, pos=1) ... done
[17:46:47.069]  length: 3 (resolved future 1)
[17:46:47.069] Future #2
[17:46:47.069] result() for MulticoreFuture ...
[17:46:47.069] result() for MulticoreFuture ... done
[17:46:47.069] result() for MulticoreFuture ...
[17:46:47.070] result() for MulticoreFuture ... done
[17:46:47.070] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:47.070] - nx: 4
[17:46:47.070] - relay: TRUE
[17:46:47.070] - stdout: TRUE
[17:46:47.070] - signal: TRUE
[17:46:47.070] - resignal: FALSE
[17:46:47.071] - force: TRUE
[17:46:47.071] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.071] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.071]  - until=2
[17:46:47.071]  - relaying element #2
[17:46:47.071] result() for MulticoreFuture ...
[17:46:47.071] result() for MulticoreFuture ... done
[17:46:47.072] result() for MulticoreFuture ...
[17:46:47.072] result() for MulticoreFuture ... done
[17:46:47.072] result() for MulticoreFuture ...
[17:46:47.072] result() for MulticoreFuture ... done
[17:46:47.072] result() for MulticoreFuture ...
[17:46:47.072] result() for MulticoreFuture ... done
[17:46:47.072] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.073] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.073] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:47.073]  length: 2 (resolved future 2)
[17:46:47.073] Future #3
[17:46:47.073] result() for MulticoreFuture ...
[17:46:47.074] result() for MulticoreFuture ...
[17:46:47.074] result() for MulticoreFuture ... done
[17:46:47.074] result() for MulticoreFuture ... done
[17:46:47.075] result() for MulticoreFuture ...
[17:46:47.075] result() for MulticoreFuture ... done
[17:46:47.075] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:47.075] - nx: 4
[17:46:47.075] - relay: TRUE
[17:46:47.075] - stdout: TRUE
[17:46:47.075] - signal: TRUE
[17:46:47.076] - resignal: FALSE
[17:46:47.076] - force: TRUE
[17:46:47.076] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.076] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.076]  - until=3
[17:46:47.076]  - relaying element #3
[17:46:47.076] result() for MulticoreFuture ...
[17:46:47.077] result() for MulticoreFuture ... done
[17:46:47.077] result() for MulticoreFuture ...
[17:46:47.077] result() for MulticoreFuture ... done
[17:46:47.077] result() for MulticoreFuture ...
[17:46:47.077] result() for MulticoreFuture ... done
[17:46:47.077] result() for MulticoreFuture ...
[17:46:47.077] result() for MulticoreFuture ... done
[17:46:47.078] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.078] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.078] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:47.078]  length: 1 (resolved future 3)
[17:46:47.078] Future #4
[17:46:47.078] result() for MulticoreFuture ...
[17:46:47.079] result() for MulticoreFuture ...
[17:46:47.079] result() for MulticoreFuture ... done
[17:46:47.080] result() for MulticoreFuture ... done
[17:46:47.080] result() for MulticoreFuture ...
[17:46:47.080] result() for MulticoreFuture ... done
[17:46:47.080] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:47.080] - nx: 4
[17:46:47.080] - relay: TRUE
[17:46:47.081] - stdout: TRUE
[17:46:47.081] - signal: TRUE
[17:46:47.081] - resignal: FALSE
[17:46:47.081] - force: TRUE
[17:46:47.081] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.081] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.082]  - until=4
[17:46:47.082]  - relaying element #4
[17:46:47.082] result() for MulticoreFuture ...
[17:46:47.082] result() for MulticoreFuture ... done
[17:46:47.082] result() for MulticoreFuture ...
[17:46:47.082] result() for MulticoreFuture ... done
[17:46:47.082] result() for MulticoreFuture ...
[17:46:47.083] result() for MulticoreFuture ... done
[17:46:47.083] result() for MulticoreFuture ...
[17:46:47.083] result() for MulticoreFuture ... done
[17:46:47.083] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.083] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.083] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:47.083]  length: 0 (resolved future 4)
[17:46:47.084] Relaying remaining futures
[17:46:47.084] signalConditionsASAP(NULL, pos=0) ...
[17:46:47.084] - nx: 4
[17:46:47.084] - relay: TRUE
[17:46:47.084] - stdout: TRUE
[17:46:47.084] - signal: TRUE
[17:46:47.084] - resignal: FALSE
[17:46:47.084] - force: TRUE
[17:46:47.084] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.084] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:47.085] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.085] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.085] signalConditionsASAP(NULL, pos=0) ... done
[17:46:47.085] resolve() on environment ... DONE
[17:46:47.085] result() for MulticoreFuture ...
[17:46:47.085] result() for MulticoreFuture ... done
[17:46:47.085] result() for MulticoreFuture ...
[17:46:47.085] result() for MulticoreFuture ... done
[17:46:47.085] result() for MulticoreFuture ...
[17:46:47.086] result() for MulticoreFuture ... done
[17:46:47.086] result() for MulticoreFuture ...
[17:46:47.086] result() for MulticoreFuture ... done
[17:46:47.086] result() for MulticoreFuture ...
[17:46:47.086] result() for MulticoreFuture ... done
[17:46:47.086] result() for MulticoreFuture ...
[17:46:47.086] result() for MulticoreFuture ... done
<environment: 0x5617860d1648> 
Type of future: multisession
[17:46:47.087] plan(): Setting new future strategy stack:
[17:46:47.087] List of future strategies:
[17:46:47.087] 1. multisession:
[17:46:47.087]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:47.087]    - tweaked: FALSE
[17:46:47.087]    - call: plan(strategy)
[17:46:47.087] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:46:47.087] multisession:
[17:46:47.087] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:47.087] - tweaked: FALSE
[17:46:47.087] - call: plan(strategy)
[17:46:47.091] getGlobalsAndPackages() ...
[17:46:47.092] Not searching for globals
[17:46:47.092] - globals: [0] <none>
[17:46:47.092] getGlobalsAndPackages() ... DONE
[17:46:47.092] [local output] makeClusterPSOCK() ...
[17:46:47.096] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:46:47.096] [local output] Base port: 11869
[17:46:47.096] [local output] Getting setup options for 2 cluster nodes ...
[17:46:47.096] [local output]  - Node 1 of 2 ...
[17:46:47.097] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:47.098] [local output] Rscript port: 11869

[17:46:47.098] [local output]  - Node 2 of 2 ...
[17:46:47.098] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:47.099] [local output] Rscript port: 11869

[17:46:47.099] [local output] Getting setup options for 2 cluster nodes ... done
[17:46:47.099] [local output]  - Parallel setup requested for some PSOCK nodes
[17:46:47.100] [local output] Setting up PSOCK nodes in parallel
[17:46:47.100] List of 36
[17:46:47.100]  $ worker          : chr "localhost"
[17:46:47.100]   ..- attr(*, "localhost")= logi TRUE
[17:46:47.100]  $ master          : chr "localhost"
[17:46:47.100]  $ port            : int 11869
[17:46:47.100]  $ connectTimeout  : num 120
[17:46:47.100]  $ timeout         : num 2592000
[17:46:47.100]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:46:47.100]  $ homogeneous     : logi TRUE
[17:46:47.100]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:46:47.100]  $ rscript_envs    : NULL
[17:46:47.100]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:47.100]  $ rscript_startup : NULL
[17:46:47.100]  $ rscript_sh      : chr "sh"
[17:46:47.100]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:47.100]  $ methods         : logi TRUE
[17:46:47.100]  $ socketOptions   : chr "no-delay"
[17:46:47.100]  $ useXDR          : logi FALSE
[17:46:47.100]  $ outfile         : chr "/dev/null"
[17:46:47.100]  $ renice          : int NA
[17:46:47.100]  $ rshcmd          : NULL
[17:46:47.100]  $ user            : chr(0) 
[17:46:47.100]  $ revtunnel       : logi FALSE
[17:46:47.100]  $ rshlogfile      : NULL
[17:46:47.100]  $ rshopts         : chr(0) 
[17:46:47.100]  $ rank            : int 1
[17:46:47.100]  $ manual          : logi FALSE
[17:46:47.100]  $ dryrun          : logi FALSE
[17:46:47.100]  $ quiet           : logi FALSE
[17:46:47.100]  $ setup_strategy  : chr "parallel"
[17:46:47.100]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:47.100]  $ pidfile         : chr "/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a4744c448c18.pid"
[17:46:47.100]  $ rshcmd_label    : NULL
[17:46:47.100]  $ rsh_call        : NULL
[17:46:47.100]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:47.100]  $ localMachine    : logi TRUE
[17:46:47.100]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:46:47.100]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:46:47.100]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:46:47.100]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:46:47.100]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:46:47.100]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:46:47.100]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:46:47.100]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:46:47.100]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:46:47.100]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:46:47.100]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:46:47.100]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:46:47.100]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:46:47.100]  $ arguments       :List of 28
[17:46:47.100]   ..$ worker          : chr "localhost"
[17:46:47.100]   ..$ master          : NULL
[17:46:47.100]   ..$ port            : int 11869
[17:46:47.100]   ..$ connectTimeout  : num 120
[17:46:47.100]   ..$ timeout         : num 2592000
[17:46:47.100]   ..$ rscript         : NULL
[17:46:47.100]   ..$ homogeneous     : NULL
[17:46:47.100]   ..$ rscript_args    : NULL
[17:46:47.100]   ..$ rscript_envs    : NULL
[17:46:47.100]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:47.100]   ..$ rscript_startup : NULL
[17:46:47.100]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:46:47.100]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:47.100]   ..$ methods         : logi TRUE
[17:46:47.100]   ..$ socketOptions   : chr "no-delay"
[17:46:47.100]   ..$ useXDR          : logi FALSE
[17:46:47.100]   ..$ outfile         : chr "/dev/null"
[17:46:47.100]   ..$ renice          : int NA
[17:46:47.100]   ..$ rshcmd          : NULL
[17:46:47.100]   ..$ user            : NULL
[17:46:47.100]   ..$ revtunnel       : logi NA
[17:46:47.100]   ..$ rshlogfile      : NULL
[17:46:47.100]   ..$ rshopts         : NULL
[17:46:47.100]   ..$ rank            : int 1
[17:46:47.100]   ..$ manual          : logi FALSE
[17:46:47.100]   ..$ dryrun          : logi FALSE
[17:46:47.100]   ..$ quiet           : logi FALSE
[17:46:47.100]   ..$ setup_strategy  : chr "parallel"
[17:46:47.100]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:46:47.119] [local output] System call to launch all workers:
[17:46:47.119] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a4744c448c18.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11869 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:46:47.119] [local output] Starting PSOCK main server
[17:46:47.120] [local output] Workers launched
[17:46:47.121] [local output] Waiting for workers to connect back
[17:46:47.121]  - [local output] 0 workers out of 2 ready
[17:46:47.370]  - [local output] 0 workers out of 2 ready
[17:46:47.370]  - [local output] 1 workers out of 2 ready
[17:46:47.380]  - [local output] 1 workers out of 2 ready
[17:46:47.381]  - [local output] 2 workers out of 2 ready
[17:46:47.381] [local output] Launching of workers completed
[17:46:47.381] [local output] Collecting session information from workers
[17:46:47.382] [local output]  - Worker #1 of 2
[17:46:47.382] [local output]  - Worker #2 of 2
[17:46:47.383] [local output] makeClusterPSOCK() ... done
[17:46:47.394] Packages needed by the future expression (n = 0): <none>
[17:46:47.394] Packages needed by future strategies (n = 0): <none>
[17:46:47.398] {
[17:46:47.398]     {
[17:46:47.398]         {
[17:46:47.398]             ...future.startTime <- base::Sys.time()
[17:46:47.398]             {
[17:46:47.398]                 {
[17:46:47.398]                   {
[17:46:47.398]                     {
[17:46:47.398]                       base::local({
[17:46:47.398]                         has_future <- base::requireNamespace("future", 
[17:46:47.398]                           quietly = TRUE)
[17:46:47.398]                         if (has_future) {
[17:46:47.398]                           ns <- base::getNamespace("future")
[17:46:47.398]                           version <- ns[[".package"]][["version"]]
[17:46:47.398]                           if (is.null(version)) 
[17:46:47.398]                             version <- utils::packageVersion("future")
[17:46:47.398]                         }
[17:46:47.398]                         else {
[17:46:47.398]                           version <- NULL
[17:46:47.398]                         }
[17:46:47.398]                         if (!has_future || version < "1.8.0") {
[17:46:47.398]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.398]                             "", base::R.version$version.string), 
[17:46:47.398]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.398]                               "release", "version")], collapse = " "), 
[17:46:47.398]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.398]                             info)
[17:46:47.398]                           info <- base::paste(info, collapse = "; ")
[17:46:47.398]                           if (!has_future) {
[17:46:47.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.398]                               info)
[17:46:47.398]                           }
[17:46:47.398]                           else {
[17:46:47.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.398]                               info, version)
[17:46:47.398]                           }
[17:46:47.398]                           base::stop(msg)
[17:46:47.398]                         }
[17:46:47.398]                       })
[17:46:47.398]                     }
[17:46:47.398]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.398]                     base::options(mc.cores = 1L)
[17:46:47.398]                   }
[17:46:47.398]                   ...future.strategy.old <- future::plan("list")
[17:46:47.398]                   options(future.plan = NULL)
[17:46:47.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.398]                 }
[17:46:47.398]                 ...future.workdir <- getwd()
[17:46:47.398]             }
[17:46:47.398]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.398]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.398]         }
[17:46:47.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.398]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.398]             base::names(...future.oldOptions))
[17:46:47.398]     }
[17:46:47.398]     if (FALSE) {
[17:46:47.398]     }
[17:46:47.398]     else {
[17:46:47.398]         if (TRUE) {
[17:46:47.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.398]                 open = "w")
[17:46:47.398]         }
[17:46:47.398]         else {
[17:46:47.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.398]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.398]         }
[17:46:47.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.398]             base::sink(type = "output", split = FALSE)
[17:46:47.398]             base::close(...future.stdout)
[17:46:47.398]         }, add = TRUE)
[17:46:47.398]     }
[17:46:47.398]     ...future.frame <- base::sys.nframe()
[17:46:47.398]     ...future.conditions <- base::list()
[17:46:47.398]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.398]     if (FALSE) {
[17:46:47.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.398]     }
[17:46:47.398]     ...future.result <- base::tryCatch({
[17:46:47.398]         base::withCallingHandlers({
[17:46:47.398]             ...future.value <- base::withVisible(base::local({
[17:46:47.398]                 ...future.makeSendCondition <- base::local({
[17:46:47.398]                   sendCondition <- NULL
[17:46:47.398]                   function(frame = 1L) {
[17:46:47.398]                     if (is.function(sendCondition)) 
[17:46:47.398]                       return(sendCondition)
[17:46:47.398]                     ns <- getNamespace("parallel")
[17:46:47.398]                     if (exists("sendData", mode = "function", 
[17:46:47.398]                       envir = ns)) {
[17:46:47.398]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.398]                         envir = ns)
[17:46:47.398]                       envir <- sys.frame(frame)
[17:46:47.398]                       master <- NULL
[17:46:47.398]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.398]                         !identical(envir, emptyenv())) {
[17:46:47.398]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.398]                           inherits = FALSE)) {
[17:46:47.398]                           master <- get("master", mode = "list", 
[17:46:47.398]                             envir = envir, inherits = FALSE)
[17:46:47.398]                           if (inherits(master, c("SOCKnode", 
[17:46:47.398]                             "SOCK0node"))) {
[17:46:47.398]                             sendCondition <<- function(cond) {
[17:46:47.398]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.398]                                 success = TRUE)
[17:46:47.398]                               parallel_sendData(master, data)
[17:46:47.398]                             }
[17:46:47.398]                             return(sendCondition)
[17:46:47.398]                           }
[17:46:47.398]                         }
[17:46:47.398]                         frame <- frame + 1L
[17:46:47.398]                         envir <- sys.frame(frame)
[17:46:47.398]                       }
[17:46:47.398]                     }
[17:46:47.398]                     sendCondition <<- function(cond) NULL
[17:46:47.398]                   }
[17:46:47.398]                 })
[17:46:47.398]                 withCallingHandlers({
[17:46:47.398]                   NA
[17:46:47.398]                 }, immediateCondition = function(cond) {
[17:46:47.398]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.398]                   sendCondition(cond)
[17:46:47.398]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.398]                   {
[17:46:47.398]                     inherits <- base::inherits
[17:46:47.398]                     invokeRestart <- base::invokeRestart
[17:46:47.398]                     is.null <- base::is.null
[17:46:47.398]                     muffled <- FALSE
[17:46:47.398]                     if (inherits(cond, "message")) {
[17:46:47.398]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.398]                       if (muffled) 
[17:46:47.398]                         invokeRestart("muffleMessage")
[17:46:47.398]                     }
[17:46:47.398]                     else if (inherits(cond, "warning")) {
[17:46:47.398]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.398]                       if (muffled) 
[17:46:47.398]                         invokeRestart("muffleWarning")
[17:46:47.398]                     }
[17:46:47.398]                     else if (inherits(cond, "condition")) {
[17:46:47.398]                       if (!is.null(pattern)) {
[17:46:47.398]                         computeRestarts <- base::computeRestarts
[17:46:47.398]                         grepl <- base::grepl
[17:46:47.398]                         restarts <- computeRestarts(cond)
[17:46:47.398]                         for (restart in restarts) {
[17:46:47.398]                           name <- restart$name
[17:46:47.398]                           if (is.null(name)) 
[17:46:47.398]                             next
[17:46:47.398]                           if (!grepl(pattern, name)) 
[17:46:47.398]                             next
[17:46:47.398]                           invokeRestart(restart)
[17:46:47.398]                           muffled <- TRUE
[17:46:47.398]                           break
[17:46:47.398]                         }
[17:46:47.398]                       }
[17:46:47.398]                     }
[17:46:47.398]                     invisible(muffled)
[17:46:47.398]                   }
[17:46:47.398]                   muffleCondition(cond)
[17:46:47.398]                 })
[17:46:47.398]             }))
[17:46:47.398]             future::FutureResult(value = ...future.value$value, 
[17:46:47.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.398]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.398]                     ...future.globalenv.names))
[17:46:47.398]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.398]         }, condition = base::local({
[17:46:47.398]             c <- base::c
[17:46:47.398]             inherits <- base::inherits
[17:46:47.398]             invokeRestart <- base::invokeRestart
[17:46:47.398]             length <- base::length
[17:46:47.398]             list <- base::list
[17:46:47.398]             seq.int <- base::seq.int
[17:46:47.398]             signalCondition <- base::signalCondition
[17:46:47.398]             sys.calls <- base::sys.calls
[17:46:47.398]             `[[` <- base::`[[`
[17:46:47.398]             `+` <- base::`+`
[17:46:47.398]             `<<-` <- base::`<<-`
[17:46:47.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.398]                   3L)]
[17:46:47.398]             }
[17:46:47.398]             function(cond) {
[17:46:47.398]                 is_error <- inherits(cond, "error")
[17:46:47.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.398]                   NULL)
[17:46:47.398]                 if (is_error) {
[17:46:47.398]                   sessionInformation <- function() {
[17:46:47.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.398]                       search = base::search(), system = base::Sys.info())
[17:46:47.398]                   }
[17:46:47.398]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.398]                     cond$call), session = sessionInformation(), 
[17:46:47.398]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.398]                   signalCondition(cond)
[17:46:47.398]                 }
[17:46:47.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.398]                 "immediateCondition"))) {
[17:46:47.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.398]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.398]                   if (TRUE && !signal) {
[17:46:47.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.398]                     {
[17:46:47.398]                       inherits <- base::inherits
[17:46:47.398]                       invokeRestart <- base::invokeRestart
[17:46:47.398]                       is.null <- base::is.null
[17:46:47.398]                       muffled <- FALSE
[17:46:47.398]                       if (inherits(cond, "message")) {
[17:46:47.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.398]                         if (muffled) 
[17:46:47.398]                           invokeRestart("muffleMessage")
[17:46:47.398]                       }
[17:46:47.398]                       else if (inherits(cond, "warning")) {
[17:46:47.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.398]                         if (muffled) 
[17:46:47.398]                           invokeRestart("muffleWarning")
[17:46:47.398]                       }
[17:46:47.398]                       else if (inherits(cond, "condition")) {
[17:46:47.398]                         if (!is.null(pattern)) {
[17:46:47.398]                           computeRestarts <- base::computeRestarts
[17:46:47.398]                           grepl <- base::grepl
[17:46:47.398]                           restarts <- computeRestarts(cond)
[17:46:47.398]                           for (restart in restarts) {
[17:46:47.398]                             name <- restart$name
[17:46:47.398]                             if (is.null(name)) 
[17:46:47.398]                               next
[17:46:47.398]                             if (!grepl(pattern, name)) 
[17:46:47.398]                               next
[17:46:47.398]                             invokeRestart(restart)
[17:46:47.398]                             muffled <- TRUE
[17:46:47.398]                             break
[17:46:47.398]                           }
[17:46:47.398]                         }
[17:46:47.398]                       }
[17:46:47.398]                       invisible(muffled)
[17:46:47.398]                     }
[17:46:47.398]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.398]                   }
[17:46:47.398]                 }
[17:46:47.398]                 else {
[17:46:47.398]                   if (TRUE) {
[17:46:47.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.398]                     {
[17:46:47.398]                       inherits <- base::inherits
[17:46:47.398]                       invokeRestart <- base::invokeRestart
[17:46:47.398]                       is.null <- base::is.null
[17:46:47.398]                       muffled <- FALSE
[17:46:47.398]                       if (inherits(cond, "message")) {
[17:46:47.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.398]                         if (muffled) 
[17:46:47.398]                           invokeRestart("muffleMessage")
[17:46:47.398]                       }
[17:46:47.398]                       else if (inherits(cond, "warning")) {
[17:46:47.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.398]                         if (muffled) 
[17:46:47.398]                           invokeRestart("muffleWarning")
[17:46:47.398]                       }
[17:46:47.398]                       else if (inherits(cond, "condition")) {
[17:46:47.398]                         if (!is.null(pattern)) {
[17:46:47.398]                           computeRestarts <- base::computeRestarts
[17:46:47.398]                           grepl <- base::grepl
[17:46:47.398]                           restarts <- computeRestarts(cond)
[17:46:47.398]                           for (restart in restarts) {
[17:46:47.398]                             name <- restart$name
[17:46:47.398]                             if (is.null(name)) 
[17:46:47.398]                               next
[17:46:47.398]                             if (!grepl(pattern, name)) 
[17:46:47.398]                               next
[17:46:47.398]                             invokeRestart(restart)
[17:46:47.398]                             muffled <- TRUE
[17:46:47.398]                             break
[17:46:47.398]                           }
[17:46:47.398]                         }
[17:46:47.398]                       }
[17:46:47.398]                       invisible(muffled)
[17:46:47.398]                     }
[17:46:47.398]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.398]                   }
[17:46:47.398]                 }
[17:46:47.398]             }
[17:46:47.398]         }))
[17:46:47.398]     }, error = function(ex) {
[17:46:47.398]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.398]                 ...future.rng), started = ...future.startTime, 
[17:46:47.398]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.398]             version = "1.8"), class = "FutureResult")
[17:46:47.398]     }, finally = {
[17:46:47.398]         if (!identical(...future.workdir, getwd())) 
[17:46:47.398]             setwd(...future.workdir)
[17:46:47.398]         {
[17:46:47.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.398]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.398]             }
[17:46:47.398]             base::options(...future.oldOptions)
[17:46:47.398]             if (.Platform$OS.type == "windows") {
[17:46:47.398]                 old_names <- names(...future.oldEnvVars)
[17:46:47.398]                 envs <- base::Sys.getenv()
[17:46:47.398]                 names <- names(envs)
[17:46:47.398]                 common <- intersect(names, old_names)
[17:46:47.398]                 added <- setdiff(names, old_names)
[17:46:47.398]                 removed <- setdiff(old_names, names)
[17:46:47.398]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.398]                   envs[common]]
[17:46:47.398]                 NAMES <- toupper(changed)
[17:46:47.398]                 args <- list()
[17:46:47.398]                 for (kk in seq_along(NAMES)) {
[17:46:47.398]                   name <- changed[[kk]]
[17:46:47.398]                   NAME <- NAMES[[kk]]
[17:46:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.398]                     next
[17:46:47.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.398]                 }
[17:46:47.398]                 NAMES <- toupper(added)
[17:46:47.398]                 for (kk in seq_along(NAMES)) {
[17:46:47.398]                   name <- added[[kk]]
[17:46:47.398]                   NAME <- NAMES[[kk]]
[17:46:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.398]                     next
[17:46:47.398]                   args[[name]] <- ""
[17:46:47.398]                 }
[17:46:47.398]                 NAMES <- toupper(removed)
[17:46:47.398]                 for (kk in seq_along(NAMES)) {
[17:46:47.398]                   name <- removed[[kk]]
[17:46:47.398]                   NAME <- NAMES[[kk]]
[17:46:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.398]                     next
[17:46:47.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.398]                 }
[17:46:47.398]                 if (length(args) > 0) 
[17:46:47.398]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.398]             }
[17:46:47.398]             else {
[17:46:47.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.398]             }
[17:46:47.398]             {
[17:46:47.398]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.398]                   0L) {
[17:46:47.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.398]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.398]                   base::options(opts)
[17:46:47.398]                 }
[17:46:47.398]                 {
[17:46:47.398]                   {
[17:46:47.398]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.398]                     NULL
[17:46:47.398]                   }
[17:46:47.398]                   options(future.plan = NULL)
[17:46:47.398]                   if (is.na(NA_character_)) 
[17:46:47.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.398]                     .init = FALSE)
[17:46:47.398]                 }
[17:46:47.398]             }
[17:46:47.398]         }
[17:46:47.398]     })
[17:46:47.398]     if (TRUE) {
[17:46:47.398]         base::sink(type = "output", split = FALSE)
[17:46:47.398]         if (TRUE) {
[17:46:47.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.398]         }
[17:46:47.398]         else {
[17:46:47.398]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.398]         }
[17:46:47.398]         base::close(...future.stdout)
[17:46:47.398]         ...future.stdout <- NULL
[17:46:47.398]     }
[17:46:47.398]     ...future.result$conditions <- ...future.conditions
[17:46:47.398]     ...future.result$finished <- base::Sys.time()
[17:46:47.398]     ...future.result
[17:46:47.398] }
[17:46:47.450] MultisessionFuture started
[17:46:47.451] result() for ClusterFuture ...
[17:46:47.451] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.451] - Validating connection of MultisessionFuture
[17:46:47.483] - received message: FutureResult
[17:46:47.483] - Received FutureResult
[17:46:47.483] - Erased future from FutureRegistry
[17:46:47.483] result() for ClusterFuture ...
[17:46:47.483] - result already collected: FutureResult
[17:46:47.484] result() for ClusterFuture ... done
[17:46:47.484] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.484] result() for ClusterFuture ... done
[17:46:47.484] result() for ClusterFuture ...
[17:46:47.484] - result already collected: FutureResult
[17:46:47.484] result() for ClusterFuture ... done
[17:46:47.484] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:46:47.488] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:46:47.488] getGlobalsAndPackages() ...
[17:46:47.488] Searching for globals...
[17:46:47.489] 
[17:46:47.489] Searching for globals ... DONE
[17:46:47.489] - globals: [0] <none>
[17:46:47.489] getGlobalsAndPackages() ... DONE
[17:46:47.489] run() for ‘Future’ ...
[17:46:47.490] - state: ‘created’
[17:46:47.490] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.504]   - Field: ‘node’
[17:46:47.504]   - Field: ‘label’
[17:46:47.504]   - Field: ‘local’
[17:46:47.505]   - Field: ‘owner’
[17:46:47.505]   - Field: ‘envir’
[17:46:47.505]   - Field: ‘workers’
[17:46:47.505]   - Field: ‘packages’
[17:46:47.505]   - Field: ‘gc’
[17:46:47.505]   - Field: ‘conditions’
[17:46:47.505]   - Field: ‘persistent’
[17:46:47.505]   - Field: ‘expr’
[17:46:47.505]   - Field: ‘uuid’
[17:46:47.505]   - Field: ‘seed’
[17:46:47.506]   - Field: ‘version’
[17:46:47.506]   - Field: ‘result’
[17:46:47.506]   - Field: ‘asynchronous’
[17:46:47.506]   - Field: ‘calls’
[17:46:47.506]   - Field: ‘globals’
[17:46:47.506]   - Field: ‘stdout’
[17:46:47.506]   - Field: ‘earlySignal’
[17:46:47.506]   - Field: ‘lazy’
[17:46:47.506]   - Field: ‘state’
[17:46:47.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.507] - Launch lazy future ...
[17:46:47.507] Packages needed by the future expression (n = 0): <none>
[17:46:47.507] Packages needed by future strategies (n = 0): <none>
[17:46:47.508] {
[17:46:47.508]     {
[17:46:47.508]         {
[17:46:47.508]             ...future.startTime <- base::Sys.time()
[17:46:47.508]             {
[17:46:47.508]                 {
[17:46:47.508]                   {
[17:46:47.508]                     {
[17:46:47.508]                       base::local({
[17:46:47.508]                         has_future <- base::requireNamespace("future", 
[17:46:47.508]                           quietly = TRUE)
[17:46:47.508]                         if (has_future) {
[17:46:47.508]                           ns <- base::getNamespace("future")
[17:46:47.508]                           version <- ns[[".package"]][["version"]]
[17:46:47.508]                           if (is.null(version)) 
[17:46:47.508]                             version <- utils::packageVersion("future")
[17:46:47.508]                         }
[17:46:47.508]                         else {
[17:46:47.508]                           version <- NULL
[17:46:47.508]                         }
[17:46:47.508]                         if (!has_future || version < "1.8.0") {
[17:46:47.508]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.508]                             "", base::R.version$version.string), 
[17:46:47.508]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.508]                               "release", "version")], collapse = " "), 
[17:46:47.508]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.508]                             info)
[17:46:47.508]                           info <- base::paste(info, collapse = "; ")
[17:46:47.508]                           if (!has_future) {
[17:46:47.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.508]                               info)
[17:46:47.508]                           }
[17:46:47.508]                           else {
[17:46:47.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.508]                               info, version)
[17:46:47.508]                           }
[17:46:47.508]                           base::stop(msg)
[17:46:47.508]                         }
[17:46:47.508]                       })
[17:46:47.508]                     }
[17:46:47.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.508]                     base::options(mc.cores = 1L)
[17:46:47.508]                   }
[17:46:47.508]                   ...future.strategy.old <- future::plan("list")
[17:46:47.508]                   options(future.plan = NULL)
[17:46:47.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.508]                 }
[17:46:47.508]                 ...future.workdir <- getwd()
[17:46:47.508]             }
[17:46:47.508]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.508]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.508]         }
[17:46:47.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.508]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.508]             base::names(...future.oldOptions))
[17:46:47.508]     }
[17:46:47.508]     if (FALSE) {
[17:46:47.508]     }
[17:46:47.508]     else {
[17:46:47.508]         if (TRUE) {
[17:46:47.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.508]                 open = "w")
[17:46:47.508]         }
[17:46:47.508]         else {
[17:46:47.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.508]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.508]         }
[17:46:47.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.508]             base::sink(type = "output", split = FALSE)
[17:46:47.508]             base::close(...future.stdout)
[17:46:47.508]         }, add = TRUE)
[17:46:47.508]     }
[17:46:47.508]     ...future.frame <- base::sys.nframe()
[17:46:47.508]     ...future.conditions <- base::list()
[17:46:47.508]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.508]     if (FALSE) {
[17:46:47.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.508]     }
[17:46:47.508]     ...future.result <- base::tryCatch({
[17:46:47.508]         base::withCallingHandlers({
[17:46:47.508]             ...future.value <- base::withVisible(base::local({
[17:46:47.508]                 ...future.makeSendCondition <- base::local({
[17:46:47.508]                   sendCondition <- NULL
[17:46:47.508]                   function(frame = 1L) {
[17:46:47.508]                     if (is.function(sendCondition)) 
[17:46:47.508]                       return(sendCondition)
[17:46:47.508]                     ns <- getNamespace("parallel")
[17:46:47.508]                     if (exists("sendData", mode = "function", 
[17:46:47.508]                       envir = ns)) {
[17:46:47.508]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.508]                         envir = ns)
[17:46:47.508]                       envir <- sys.frame(frame)
[17:46:47.508]                       master <- NULL
[17:46:47.508]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.508]                         !identical(envir, emptyenv())) {
[17:46:47.508]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.508]                           inherits = FALSE)) {
[17:46:47.508]                           master <- get("master", mode = "list", 
[17:46:47.508]                             envir = envir, inherits = FALSE)
[17:46:47.508]                           if (inherits(master, c("SOCKnode", 
[17:46:47.508]                             "SOCK0node"))) {
[17:46:47.508]                             sendCondition <<- function(cond) {
[17:46:47.508]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.508]                                 success = TRUE)
[17:46:47.508]                               parallel_sendData(master, data)
[17:46:47.508]                             }
[17:46:47.508]                             return(sendCondition)
[17:46:47.508]                           }
[17:46:47.508]                         }
[17:46:47.508]                         frame <- frame + 1L
[17:46:47.508]                         envir <- sys.frame(frame)
[17:46:47.508]                       }
[17:46:47.508]                     }
[17:46:47.508]                     sendCondition <<- function(cond) NULL
[17:46:47.508]                   }
[17:46:47.508]                 })
[17:46:47.508]                 withCallingHandlers({
[17:46:47.508]                   2
[17:46:47.508]                 }, immediateCondition = function(cond) {
[17:46:47.508]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.508]                   sendCondition(cond)
[17:46:47.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.508]                   {
[17:46:47.508]                     inherits <- base::inherits
[17:46:47.508]                     invokeRestart <- base::invokeRestart
[17:46:47.508]                     is.null <- base::is.null
[17:46:47.508]                     muffled <- FALSE
[17:46:47.508]                     if (inherits(cond, "message")) {
[17:46:47.508]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.508]                       if (muffled) 
[17:46:47.508]                         invokeRestart("muffleMessage")
[17:46:47.508]                     }
[17:46:47.508]                     else if (inherits(cond, "warning")) {
[17:46:47.508]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.508]                       if (muffled) 
[17:46:47.508]                         invokeRestart("muffleWarning")
[17:46:47.508]                     }
[17:46:47.508]                     else if (inherits(cond, "condition")) {
[17:46:47.508]                       if (!is.null(pattern)) {
[17:46:47.508]                         computeRestarts <- base::computeRestarts
[17:46:47.508]                         grepl <- base::grepl
[17:46:47.508]                         restarts <- computeRestarts(cond)
[17:46:47.508]                         for (restart in restarts) {
[17:46:47.508]                           name <- restart$name
[17:46:47.508]                           if (is.null(name)) 
[17:46:47.508]                             next
[17:46:47.508]                           if (!grepl(pattern, name)) 
[17:46:47.508]                             next
[17:46:47.508]                           invokeRestart(restart)
[17:46:47.508]                           muffled <- TRUE
[17:46:47.508]                           break
[17:46:47.508]                         }
[17:46:47.508]                       }
[17:46:47.508]                     }
[17:46:47.508]                     invisible(muffled)
[17:46:47.508]                   }
[17:46:47.508]                   muffleCondition(cond)
[17:46:47.508]                 })
[17:46:47.508]             }))
[17:46:47.508]             future::FutureResult(value = ...future.value$value, 
[17:46:47.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.508]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.508]                     ...future.globalenv.names))
[17:46:47.508]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.508]         }, condition = base::local({
[17:46:47.508]             c <- base::c
[17:46:47.508]             inherits <- base::inherits
[17:46:47.508]             invokeRestart <- base::invokeRestart
[17:46:47.508]             length <- base::length
[17:46:47.508]             list <- base::list
[17:46:47.508]             seq.int <- base::seq.int
[17:46:47.508]             signalCondition <- base::signalCondition
[17:46:47.508]             sys.calls <- base::sys.calls
[17:46:47.508]             `[[` <- base::`[[`
[17:46:47.508]             `+` <- base::`+`
[17:46:47.508]             `<<-` <- base::`<<-`
[17:46:47.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.508]                   3L)]
[17:46:47.508]             }
[17:46:47.508]             function(cond) {
[17:46:47.508]                 is_error <- inherits(cond, "error")
[17:46:47.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.508]                   NULL)
[17:46:47.508]                 if (is_error) {
[17:46:47.508]                   sessionInformation <- function() {
[17:46:47.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.508]                       search = base::search(), system = base::Sys.info())
[17:46:47.508]                   }
[17:46:47.508]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.508]                     cond$call), session = sessionInformation(), 
[17:46:47.508]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.508]                   signalCondition(cond)
[17:46:47.508]                 }
[17:46:47.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.508]                 "immediateCondition"))) {
[17:46:47.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.508]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.508]                   if (TRUE && !signal) {
[17:46:47.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.508]                     {
[17:46:47.508]                       inherits <- base::inherits
[17:46:47.508]                       invokeRestart <- base::invokeRestart
[17:46:47.508]                       is.null <- base::is.null
[17:46:47.508]                       muffled <- FALSE
[17:46:47.508]                       if (inherits(cond, "message")) {
[17:46:47.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.508]                         if (muffled) 
[17:46:47.508]                           invokeRestart("muffleMessage")
[17:46:47.508]                       }
[17:46:47.508]                       else if (inherits(cond, "warning")) {
[17:46:47.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.508]                         if (muffled) 
[17:46:47.508]                           invokeRestart("muffleWarning")
[17:46:47.508]                       }
[17:46:47.508]                       else if (inherits(cond, "condition")) {
[17:46:47.508]                         if (!is.null(pattern)) {
[17:46:47.508]                           computeRestarts <- base::computeRestarts
[17:46:47.508]                           grepl <- base::grepl
[17:46:47.508]                           restarts <- computeRestarts(cond)
[17:46:47.508]                           for (restart in restarts) {
[17:46:47.508]                             name <- restart$name
[17:46:47.508]                             if (is.null(name)) 
[17:46:47.508]                               next
[17:46:47.508]                             if (!grepl(pattern, name)) 
[17:46:47.508]                               next
[17:46:47.508]                             invokeRestart(restart)
[17:46:47.508]                             muffled <- TRUE
[17:46:47.508]                             break
[17:46:47.508]                           }
[17:46:47.508]                         }
[17:46:47.508]                       }
[17:46:47.508]                       invisible(muffled)
[17:46:47.508]                     }
[17:46:47.508]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.508]                   }
[17:46:47.508]                 }
[17:46:47.508]                 else {
[17:46:47.508]                   if (TRUE) {
[17:46:47.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.508]                     {
[17:46:47.508]                       inherits <- base::inherits
[17:46:47.508]                       invokeRestart <- base::invokeRestart
[17:46:47.508]                       is.null <- base::is.null
[17:46:47.508]                       muffled <- FALSE
[17:46:47.508]                       if (inherits(cond, "message")) {
[17:46:47.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.508]                         if (muffled) 
[17:46:47.508]                           invokeRestart("muffleMessage")
[17:46:47.508]                       }
[17:46:47.508]                       else if (inherits(cond, "warning")) {
[17:46:47.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.508]                         if (muffled) 
[17:46:47.508]                           invokeRestart("muffleWarning")
[17:46:47.508]                       }
[17:46:47.508]                       else if (inherits(cond, "condition")) {
[17:46:47.508]                         if (!is.null(pattern)) {
[17:46:47.508]                           computeRestarts <- base::computeRestarts
[17:46:47.508]                           grepl <- base::grepl
[17:46:47.508]                           restarts <- computeRestarts(cond)
[17:46:47.508]                           for (restart in restarts) {
[17:46:47.508]                             name <- restart$name
[17:46:47.508]                             if (is.null(name)) 
[17:46:47.508]                               next
[17:46:47.508]                             if (!grepl(pattern, name)) 
[17:46:47.508]                               next
[17:46:47.508]                             invokeRestart(restart)
[17:46:47.508]                             muffled <- TRUE
[17:46:47.508]                             break
[17:46:47.508]                           }
[17:46:47.508]                         }
[17:46:47.508]                       }
[17:46:47.508]                       invisible(muffled)
[17:46:47.508]                     }
[17:46:47.508]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.508]                   }
[17:46:47.508]                 }
[17:46:47.508]             }
[17:46:47.508]         }))
[17:46:47.508]     }, error = function(ex) {
[17:46:47.508]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.508]                 ...future.rng), started = ...future.startTime, 
[17:46:47.508]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.508]             version = "1.8"), class = "FutureResult")
[17:46:47.508]     }, finally = {
[17:46:47.508]         if (!identical(...future.workdir, getwd())) 
[17:46:47.508]             setwd(...future.workdir)
[17:46:47.508]         {
[17:46:47.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.508]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.508]             }
[17:46:47.508]             base::options(...future.oldOptions)
[17:46:47.508]             if (.Platform$OS.type == "windows") {
[17:46:47.508]                 old_names <- names(...future.oldEnvVars)
[17:46:47.508]                 envs <- base::Sys.getenv()
[17:46:47.508]                 names <- names(envs)
[17:46:47.508]                 common <- intersect(names, old_names)
[17:46:47.508]                 added <- setdiff(names, old_names)
[17:46:47.508]                 removed <- setdiff(old_names, names)
[17:46:47.508]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.508]                   envs[common]]
[17:46:47.508]                 NAMES <- toupper(changed)
[17:46:47.508]                 args <- list()
[17:46:47.508]                 for (kk in seq_along(NAMES)) {
[17:46:47.508]                   name <- changed[[kk]]
[17:46:47.508]                   NAME <- NAMES[[kk]]
[17:46:47.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.508]                     next
[17:46:47.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.508]                 }
[17:46:47.508]                 NAMES <- toupper(added)
[17:46:47.508]                 for (kk in seq_along(NAMES)) {
[17:46:47.508]                   name <- added[[kk]]
[17:46:47.508]                   NAME <- NAMES[[kk]]
[17:46:47.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.508]                     next
[17:46:47.508]                   args[[name]] <- ""
[17:46:47.508]                 }
[17:46:47.508]                 NAMES <- toupper(removed)
[17:46:47.508]                 for (kk in seq_along(NAMES)) {
[17:46:47.508]                   name <- removed[[kk]]
[17:46:47.508]                   NAME <- NAMES[[kk]]
[17:46:47.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.508]                     next
[17:46:47.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.508]                 }
[17:46:47.508]                 if (length(args) > 0) 
[17:46:47.508]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.508]             }
[17:46:47.508]             else {
[17:46:47.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.508]             }
[17:46:47.508]             {
[17:46:47.508]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.508]                   0L) {
[17:46:47.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.508]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.508]                   base::options(opts)
[17:46:47.508]                 }
[17:46:47.508]                 {
[17:46:47.508]                   {
[17:46:47.508]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.508]                     NULL
[17:46:47.508]                   }
[17:46:47.508]                   options(future.plan = NULL)
[17:46:47.508]                   if (is.na(NA_character_)) 
[17:46:47.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.508]                     .init = FALSE)
[17:46:47.508]                 }
[17:46:47.508]             }
[17:46:47.508]         }
[17:46:47.508]     })
[17:46:47.508]     if (TRUE) {
[17:46:47.508]         base::sink(type = "output", split = FALSE)
[17:46:47.508]         if (TRUE) {
[17:46:47.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.508]         }
[17:46:47.508]         else {
[17:46:47.508]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.508]         }
[17:46:47.508]         base::close(...future.stdout)
[17:46:47.508]         ...future.stdout <- NULL
[17:46:47.508]     }
[17:46:47.508]     ...future.result$conditions <- ...future.conditions
[17:46:47.508]     ...future.result$finished <- base::Sys.time()
[17:46:47.508]     ...future.result
[17:46:47.508] }
[17:46:47.511] MultisessionFuture started
[17:46:47.511] - Launch lazy future ... done
[17:46:47.511] run() for ‘MultisessionFuture’ ... done
[17:46:47.511] getGlobalsAndPackages() ...
[17:46:47.511] Searching for globals...
[17:46:47.512] 
[17:46:47.512] Searching for globals ... DONE
[17:46:47.512] - globals: [0] <none>
[17:46:47.513] getGlobalsAndPackages() ... DONE
[17:46:47.513] run() for ‘Future’ ...
[17:46:47.513] - state: ‘created’
[17:46:47.513] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.527] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.527]   - Field: ‘node’
[17:46:47.527]   - Field: ‘label’
[17:46:47.528]   - Field: ‘local’
[17:46:47.528]   - Field: ‘owner’
[17:46:47.528]   - Field: ‘envir’
[17:46:47.528]   - Field: ‘workers’
[17:46:47.528]   - Field: ‘packages’
[17:46:47.528]   - Field: ‘gc’
[17:46:47.528]   - Field: ‘conditions’
[17:46:47.528]   - Field: ‘persistent’
[17:46:47.528]   - Field: ‘expr’
[17:46:47.529]   - Field: ‘uuid’
[17:46:47.529]   - Field: ‘seed’
[17:46:47.529]   - Field: ‘version’
[17:46:47.529]   - Field: ‘result’
[17:46:47.529]   - Field: ‘asynchronous’
[17:46:47.529]   - Field: ‘calls’
[17:46:47.529]   - Field: ‘globals’
[17:46:47.529]   - Field: ‘stdout’
[17:46:47.529]   - Field: ‘earlySignal’
[17:46:47.529]   - Field: ‘lazy’
[17:46:47.530]   - Field: ‘state’
[17:46:47.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.530] - Launch lazy future ...
[17:46:47.530] Packages needed by the future expression (n = 0): <none>
[17:46:47.530] Packages needed by future strategies (n = 0): <none>
[17:46:47.531] {
[17:46:47.531]     {
[17:46:47.531]         {
[17:46:47.531]             ...future.startTime <- base::Sys.time()
[17:46:47.531]             {
[17:46:47.531]                 {
[17:46:47.531]                   {
[17:46:47.531]                     {
[17:46:47.531]                       base::local({
[17:46:47.531]                         has_future <- base::requireNamespace("future", 
[17:46:47.531]                           quietly = TRUE)
[17:46:47.531]                         if (has_future) {
[17:46:47.531]                           ns <- base::getNamespace("future")
[17:46:47.531]                           version <- ns[[".package"]][["version"]]
[17:46:47.531]                           if (is.null(version)) 
[17:46:47.531]                             version <- utils::packageVersion("future")
[17:46:47.531]                         }
[17:46:47.531]                         else {
[17:46:47.531]                           version <- NULL
[17:46:47.531]                         }
[17:46:47.531]                         if (!has_future || version < "1.8.0") {
[17:46:47.531]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.531]                             "", base::R.version$version.string), 
[17:46:47.531]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.531]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.531]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.531]                               "release", "version")], collapse = " "), 
[17:46:47.531]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.531]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.531]                             info)
[17:46:47.531]                           info <- base::paste(info, collapse = "; ")
[17:46:47.531]                           if (!has_future) {
[17:46:47.531]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.531]                               info)
[17:46:47.531]                           }
[17:46:47.531]                           else {
[17:46:47.531]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.531]                               info, version)
[17:46:47.531]                           }
[17:46:47.531]                           base::stop(msg)
[17:46:47.531]                         }
[17:46:47.531]                       })
[17:46:47.531]                     }
[17:46:47.531]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.531]                     base::options(mc.cores = 1L)
[17:46:47.531]                   }
[17:46:47.531]                   ...future.strategy.old <- future::plan("list")
[17:46:47.531]                   options(future.plan = NULL)
[17:46:47.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.531]                 }
[17:46:47.531]                 ...future.workdir <- getwd()
[17:46:47.531]             }
[17:46:47.531]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.531]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.531]         }
[17:46:47.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.531]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.531]             base::names(...future.oldOptions))
[17:46:47.531]     }
[17:46:47.531]     if (FALSE) {
[17:46:47.531]     }
[17:46:47.531]     else {
[17:46:47.531]         if (TRUE) {
[17:46:47.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.531]                 open = "w")
[17:46:47.531]         }
[17:46:47.531]         else {
[17:46:47.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.531]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.531]         }
[17:46:47.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.531]             base::sink(type = "output", split = FALSE)
[17:46:47.531]             base::close(...future.stdout)
[17:46:47.531]         }, add = TRUE)
[17:46:47.531]     }
[17:46:47.531]     ...future.frame <- base::sys.nframe()
[17:46:47.531]     ...future.conditions <- base::list()
[17:46:47.531]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.531]     if (FALSE) {
[17:46:47.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.531]     }
[17:46:47.531]     ...future.result <- base::tryCatch({
[17:46:47.531]         base::withCallingHandlers({
[17:46:47.531]             ...future.value <- base::withVisible(base::local({
[17:46:47.531]                 ...future.makeSendCondition <- base::local({
[17:46:47.531]                   sendCondition <- NULL
[17:46:47.531]                   function(frame = 1L) {
[17:46:47.531]                     if (is.function(sendCondition)) 
[17:46:47.531]                       return(sendCondition)
[17:46:47.531]                     ns <- getNamespace("parallel")
[17:46:47.531]                     if (exists("sendData", mode = "function", 
[17:46:47.531]                       envir = ns)) {
[17:46:47.531]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.531]                         envir = ns)
[17:46:47.531]                       envir <- sys.frame(frame)
[17:46:47.531]                       master <- NULL
[17:46:47.531]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.531]                         !identical(envir, emptyenv())) {
[17:46:47.531]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.531]                           inherits = FALSE)) {
[17:46:47.531]                           master <- get("master", mode = "list", 
[17:46:47.531]                             envir = envir, inherits = FALSE)
[17:46:47.531]                           if (inherits(master, c("SOCKnode", 
[17:46:47.531]                             "SOCK0node"))) {
[17:46:47.531]                             sendCondition <<- function(cond) {
[17:46:47.531]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.531]                                 success = TRUE)
[17:46:47.531]                               parallel_sendData(master, data)
[17:46:47.531]                             }
[17:46:47.531]                             return(sendCondition)
[17:46:47.531]                           }
[17:46:47.531]                         }
[17:46:47.531]                         frame <- frame + 1L
[17:46:47.531]                         envir <- sys.frame(frame)
[17:46:47.531]                       }
[17:46:47.531]                     }
[17:46:47.531]                     sendCondition <<- function(cond) NULL
[17:46:47.531]                   }
[17:46:47.531]                 })
[17:46:47.531]                 withCallingHandlers({
[17:46:47.531]                   NULL
[17:46:47.531]                 }, immediateCondition = function(cond) {
[17:46:47.531]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.531]                   sendCondition(cond)
[17:46:47.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.531]                   {
[17:46:47.531]                     inherits <- base::inherits
[17:46:47.531]                     invokeRestart <- base::invokeRestart
[17:46:47.531]                     is.null <- base::is.null
[17:46:47.531]                     muffled <- FALSE
[17:46:47.531]                     if (inherits(cond, "message")) {
[17:46:47.531]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.531]                       if (muffled) 
[17:46:47.531]                         invokeRestart("muffleMessage")
[17:46:47.531]                     }
[17:46:47.531]                     else if (inherits(cond, "warning")) {
[17:46:47.531]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.531]                       if (muffled) 
[17:46:47.531]                         invokeRestart("muffleWarning")
[17:46:47.531]                     }
[17:46:47.531]                     else if (inherits(cond, "condition")) {
[17:46:47.531]                       if (!is.null(pattern)) {
[17:46:47.531]                         computeRestarts <- base::computeRestarts
[17:46:47.531]                         grepl <- base::grepl
[17:46:47.531]                         restarts <- computeRestarts(cond)
[17:46:47.531]                         for (restart in restarts) {
[17:46:47.531]                           name <- restart$name
[17:46:47.531]                           if (is.null(name)) 
[17:46:47.531]                             next
[17:46:47.531]                           if (!grepl(pattern, name)) 
[17:46:47.531]                             next
[17:46:47.531]                           invokeRestart(restart)
[17:46:47.531]                           muffled <- TRUE
[17:46:47.531]                           break
[17:46:47.531]                         }
[17:46:47.531]                       }
[17:46:47.531]                     }
[17:46:47.531]                     invisible(muffled)
[17:46:47.531]                   }
[17:46:47.531]                   muffleCondition(cond)
[17:46:47.531]                 })
[17:46:47.531]             }))
[17:46:47.531]             future::FutureResult(value = ...future.value$value, 
[17:46:47.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.531]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.531]                     ...future.globalenv.names))
[17:46:47.531]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.531]         }, condition = base::local({
[17:46:47.531]             c <- base::c
[17:46:47.531]             inherits <- base::inherits
[17:46:47.531]             invokeRestart <- base::invokeRestart
[17:46:47.531]             length <- base::length
[17:46:47.531]             list <- base::list
[17:46:47.531]             seq.int <- base::seq.int
[17:46:47.531]             signalCondition <- base::signalCondition
[17:46:47.531]             sys.calls <- base::sys.calls
[17:46:47.531]             `[[` <- base::`[[`
[17:46:47.531]             `+` <- base::`+`
[17:46:47.531]             `<<-` <- base::`<<-`
[17:46:47.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.531]                   3L)]
[17:46:47.531]             }
[17:46:47.531]             function(cond) {
[17:46:47.531]                 is_error <- inherits(cond, "error")
[17:46:47.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.531]                   NULL)
[17:46:47.531]                 if (is_error) {
[17:46:47.531]                   sessionInformation <- function() {
[17:46:47.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.531]                       search = base::search(), system = base::Sys.info())
[17:46:47.531]                   }
[17:46:47.531]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.531]                     cond$call), session = sessionInformation(), 
[17:46:47.531]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.531]                   signalCondition(cond)
[17:46:47.531]                 }
[17:46:47.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.531]                 "immediateCondition"))) {
[17:46:47.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.531]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.531]                   if (TRUE && !signal) {
[17:46:47.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.531]                     {
[17:46:47.531]                       inherits <- base::inherits
[17:46:47.531]                       invokeRestart <- base::invokeRestart
[17:46:47.531]                       is.null <- base::is.null
[17:46:47.531]                       muffled <- FALSE
[17:46:47.531]                       if (inherits(cond, "message")) {
[17:46:47.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.531]                         if (muffled) 
[17:46:47.531]                           invokeRestart("muffleMessage")
[17:46:47.531]                       }
[17:46:47.531]                       else if (inherits(cond, "warning")) {
[17:46:47.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.531]                         if (muffled) 
[17:46:47.531]                           invokeRestart("muffleWarning")
[17:46:47.531]                       }
[17:46:47.531]                       else if (inherits(cond, "condition")) {
[17:46:47.531]                         if (!is.null(pattern)) {
[17:46:47.531]                           computeRestarts <- base::computeRestarts
[17:46:47.531]                           grepl <- base::grepl
[17:46:47.531]                           restarts <- computeRestarts(cond)
[17:46:47.531]                           for (restart in restarts) {
[17:46:47.531]                             name <- restart$name
[17:46:47.531]                             if (is.null(name)) 
[17:46:47.531]                               next
[17:46:47.531]                             if (!grepl(pattern, name)) 
[17:46:47.531]                               next
[17:46:47.531]                             invokeRestart(restart)
[17:46:47.531]                             muffled <- TRUE
[17:46:47.531]                             break
[17:46:47.531]                           }
[17:46:47.531]                         }
[17:46:47.531]                       }
[17:46:47.531]                       invisible(muffled)
[17:46:47.531]                     }
[17:46:47.531]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.531]                   }
[17:46:47.531]                 }
[17:46:47.531]                 else {
[17:46:47.531]                   if (TRUE) {
[17:46:47.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.531]                     {
[17:46:47.531]                       inherits <- base::inherits
[17:46:47.531]                       invokeRestart <- base::invokeRestart
[17:46:47.531]                       is.null <- base::is.null
[17:46:47.531]                       muffled <- FALSE
[17:46:47.531]                       if (inherits(cond, "message")) {
[17:46:47.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.531]                         if (muffled) 
[17:46:47.531]                           invokeRestart("muffleMessage")
[17:46:47.531]                       }
[17:46:47.531]                       else if (inherits(cond, "warning")) {
[17:46:47.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.531]                         if (muffled) 
[17:46:47.531]                           invokeRestart("muffleWarning")
[17:46:47.531]                       }
[17:46:47.531]                       else if (inherits(cond, "condition")) {
[17:46:47.531]                         if (!is.null(pattern)) {
[17:46:47.531]                           computeRestarts <- base::computeRestarts
[17:46:47.531]                           grepl <- base::grepl
[17:46:47.531]                           restarts <- computeRestarts(cond)
[17:46:47.531]                           for (restart in restarts) {
[17:46:47.531]                             name <- restart$name
[17:46:47.531]                             if (is.null(name)) 
[17:46:47.531]                               next
[17:46:47.531]                             if (!grepl(pattern, name)) 
[17:46:47.531]                               next
[17:46:47.531]                             invokeRestart(restart)
[17:46:47.531]                             muffled <- TRUE
[17:46:47.531]                             break
[17:46:47.531]                           }
[17:46:47.531]                         }
[17:46:47.531]                       }
[17:46:47.531]                       invisible(muffled)
[17:46:47.531]                     }
[17:46:47.531]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.531]                   }
[17:46:47.531]                 }
[17:46:47.531]             }
[17:46:47.531]         }))
[17:46:47.531]     }, error = function(ex) {
[17:46:47.531]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.531]                 ...future.rng), started = ...future.startTime, 
[17:46:47.531]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.531]             version = "1.8"), class = "FutureResult")
[17:46:47.531]     }, finally = {
[17:46:47.531]         if (!identical(...future.workdir, getwd())) 
[17:46:47.531]             setwd(...future.workdir)
[17:46:47.531]         {
[17:46:47.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.531]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.531]             }
[17:46:47.531]             base::options(...future.oldOptions)
[17:46:47.531]             if (.Platform$OS.type == "windows") {
[17:46:47.531]                 old_names <- names(...future.oldEnvVars)
[17:46:47.531]                 envs <- base::Sys.getenv()
[17:46:47.531]                 names <- names(envs)
[17:46:47.531]                 common <- intersect(names, old_names)
[17:46:47.531]                 added <- setdiff(names, old_names)
[17:46:47.531]                 removed <- setdiff(old_names, names)
[17:46:47.531]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.531]                   envs[common]]
[17:46:47.531]                 NAMES <- toupper(changed)
[17:46:47.531]                 args <- list()
[17:46:47.531]                 for (kk in seq_along(NAMES)) {
[17:46:47.531]                   name <- changed[[kk]]
[17:46:47.531]                   NAME <- NAMES[[kk]]
[17:46:47.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.531]                     next
[17:46:47.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.531]                 }
[17:46:47.531]                 NAMES <- toupper(added)
[17:46:47.531]                 for (kk in seq_along(NAMES)) {
[17:46:47.531]                   name <- added[[kk]]
[17:46:47.531]                   NAME <- NAMES[[kk]]
[17:46:47.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.531]                     next
[17:46:47.531]                   args[[name]] <- ""
[17:46:47.531]                 }
[17:46:47.531]                 NAMES <- toupper(removed)
[17:46:47.531]                 for (kk in seq_along(NAMES)) {
[17:46:47.531]                   name <- removed[[kk]]
[17:46:47.531]                   NAME <- NAMES[[kk]]
[17:46:47.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.531]                     next
[17:46:47.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.531]                 }
[17:46:47.531]                 if (length(args) > 0) 
[17:46:47.531]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.531]             }
[17:46:47.531]             else {
[17:46:47.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.531]             }
[17:46:47.531]             {
[17:46:47.531]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.531]                   0L) {
[17:46:47.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.531]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.531]                   base::options(opts)
[17:46:47.531]                 }
[17:46:47.531]                 {
[17:46:47.531]                   {
[17:46:47.531]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.531]                     NULL
[17:46:47.531]                   }
[17:46:47.531]                   options(future.plan = NULL)
[17:46:47.531]                   if (is.na(NA_character_)) 
[17:46:47.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.531]                     .init = FALSE)
[17:46:47.531]                 }
[17:46:47.531]             }
[17:46:47.531]         }
[17:46:47.531]     })
[17:46:47.531]     if (TRUE) {
[17:46:47.531]         base::sink(type = "output", split = FALSE)
[17:46:47.531]         if (TRUE) {
[17:46:47.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.531]         }
[17:46:47.531]         else {
[17:46:47.531]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.531]         }
[17:46:47.531]         base::close(...future.stdout)
[17:46:47.531]         ...future.stdout <- NULL
[17:46:47.531]     }
[17:46:47.531]     ...future.result$conditions <- ...future.conditions
[17:46:47.531]     ...future.result$finished <- base::Sys.time()
[17:46:47.531]     ...future.result
[17:46:47.531] }
[17:46:47.584] MultisessionFuture started
[17:46:47.584] - Launch lazy future ... done
[17:46:47.584] run() for ‘MultisessionFuture’ ... done
[17:46:47.585] getGlobalsAndPackages() ...
[17:46:47.585] Searching for globals...
[17:46:47.586] - globals found: [1] ‘{’
[17:46:47.586] Searching for globals ... DONE
[17:46:47.586] Resolving globals: FALSE
[17:46:47.587] 
[17:46:47.587] 
[17:46:47.587] getGlobalsAndPackages() ... DONE
[17:46:47.588] run() for ‘Future’ ...
[17:46:47.588] - state: ‘created’
[17:46:47.588] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.604] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.604] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.604]   - Field: ‘node’
[17:46:47.604]   - Field: ‘label’
[17:46:47.605]   - Field: ‘local’
[17:46:47.605]   - Field: ‘owner’
[17:46:47.605]   - Field: ‘envir’
[17:46:47.605]   - Field: ‘workers’
[17:46:47.605]   - Field: ‘packages’
[17:46:47.605]   - Field: ‘gc’
[17:46:47.605]   - Field: ‘conditions’
[17:46:47.605]   - Field: ‘persistent’
[17:46:47.605]   - Field: ‘expr’
[17:46:47.605]   - Field: ‘uuid’
[17:46:47.605]   - Field: ‘seed’
[17:46:47.606]   - Field: ‘version’
[17:46:47.606]   - Field: ‘result’
[17:46:47.606]   - Field: ‘asynchronous’
[17:46:47.606]   - Field: ‘calls’
[17:46:47.606]   - Field: ‘globals’
[17:46:47.606]   - Field: ‘stdout’
[17:46:47.606]   - Field: ‘earlySignal’
[17:46:47.606]   - Field: ‘lazy’
[17:46:47.606]   - Field: ‘state’
[17:46:47.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.606] - Launch lazy future ...
[17:46:47.607] Packages needed by the future expression (n = 0): <none>
[17:46:47.607] Packages needed by future strategies (n = 0): <none>
[17:46:47.607] {
[17:46:47.607]     {
[17:46:47.607]         {
[17:46:47.607]             ...future.startTime <- base::Sys.time()
[17:46:47.607]             {
[17:46:47.607]                 {
[17:46:47.607]                   {
[17:46:47.607]                     {
[17:46:47.607]                       base::local({
[17:46:47.607]                         has_future <- base::requireNamespace("future", 
[17:46:47.607]                           quietly = TRUE)
[17:46:47.607]                         if (has_future) {
[17:46:47.607]                           ns <- base::getNamespace("future")
[17:46:47.607]                           version <- ns[[".package"]][["version"]]
[17:46:47.607]                           if (is.null(version)) 
[17:46:47.607]                             version <- utils::packageVersion("future")
[17:46:47.607]                         }
[17:46:47.607]                         else {
[17:46:47.607]                           version <- NULL
[17:46:47.607]                         }
[17:46:47.607]                         if (!has_future || version < "1.8.0") {
[17:46:47.607]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.607]                             "", base::R.version$version.string), 
[17:46:47.607]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.607]                               "release", "version")], collapse = " "), 
[17:46:47.607]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.607]                             info)
[17:46:47.607]                           info <- base::paste(info, collapse = "; ")
[17:46:47.607]                           if (!has_future) {
[17:46:47.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.607]                               info)
[17:46:47.607]                           }
[17:46:47.607]                           else {
[17:46:47.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.607]                               info, version)
[17:46:47.607]                           }
[17:46:47.607]                           base::stop(msg)
[17:46:47.607]                         }
[17:46:47.607]                       })
[17:46:47.607]                     }
[17:46:47.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.607]                     base::options(mc.cores = 1L)
[17:46:47.607]                   }
[17:46:47.607]                   ...future.strategy.old <- future::plan("list")
[17:46:47.607]                   options(future.plan = NULL)
[17:46:47.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.607]                 }
[17:46:47.607]                 ...future.workdir <- getwd()
[17:46:47.607]             }
[17:46:47.607]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.607]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.607]         }
[17:46:47.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.607]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.607]             base::names(...future.oldOptions))
[17:46:47.607]     }
[17:46:47.607]     if (FALSE) {
[17:46:47.607]     }
[17:46:47.607]     else {
[17:46:47.607]         if (TRUE) {
[17:46:47.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.607]                 open = "w")
[17:46:47.607]         }
[17:46:47.607]         else {
[17:46:47.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.607]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.607]         }
[17:46:47.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.607]             base::sink(type = "output", split = FALSE)
[17:46:47.607]             base::close(...future.stdout)
[17:46:47.607]         }, add = TRUE)
[17:46:47.607]     }
[17:46:47.607]     ...future.frame <- base::sys.nframe()
[17:46:47.607]     ...future.conditions <- base::list()
[17:46:47.607]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.607]     if (FALSE) {
[17:46:47.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.607]     }
[17:46:47.607]     ...future.result <- base::tryCatch({
[17:46:47.607]         base::withCallingHandlers({
[17:46:47.607]             ...future.value <- base::withVisible(base::local({
[17:46:47.607]                 ...future.makeSendCondition <- base::local({
[17:46:47.607]                   sendCondition <- NULL
[17:46:47.607]                   function(frame = 1L) {
[17:46:47.607]                     if (is.function(sendCondition)) 
[17:46:47.607]                       return(sendCondition)
[17:46:47.607]                     ns <- getNamespace("parallel")
[17:46:47.607]                     if (exists("sendData", mode = "function", 
[17:46:47.607]                       envir = ns)) {
[17:46:47.607]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.607]                         envir = ns)
[17:46:47.607]                       envir <- sys.frame(frame)
[17:46:47.607]                       master <- NULL
[17:46:47.607]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.607]                         !identical(envir, emptyenv())) {
[17:46:47.607]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.607]                           inherits = FALSE)) {
[17:46:47.607]                           master <- get("master", mode = "list", 
[17:46:47.607]                             envir = envir, inherits = FALSE)
[17:46:47.607]                           if (inherits(master, c("SOCKnode", 
[17:46:47.607]                             "SOCK0node"))) {
[17:46:47.607]                             sendCondition <<- function(cond) {
[17:46:47.607]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.607]                                 success = TRUE)
[17:46:47.607]                               parallel_sendData(master, data)
[17:46:47.607]                             }
[17:46:47.607]                             return(sendCondition)
[17:46:47.607]                           }
[17:46:47.607]                         }
[17:46:47.607]                         frame <- frame + 1L
[17:46:47.607]                         envir <- sys.frame(frame)
[17:46:47.607]                       }
[17:46:47.607]                     }
[17:46:47.607]                     sendCondition <<- function(cond) NULL
[17:46:47.607]                   }
[17:46:47.607]                 })
[17:46:47.607]                 withCallingHandlers({
[17:46:47.607]                   {
[17:46:47.607]                     4
[17:46:47.607]                   }
[17:46:47.607]                 }, immediateCondition = function(cond) {
[17:46:47.607]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.607]                   sendCondition(cond)
[17:46:47.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.607]                   {
[17:46:47.607]                     inherits <- base::inherits
[17:46:47.607]                     invokeRestart <- base::invokeRestart
[17:46:47.607]                     is.null <- base::is.null
[17:46:47.607]                     muffled <- FALSE
[17:46:47.607]                     if (inherits(cond, "message")) {
[17:46:47.607]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.607]                       if (muffled) 
[17:46:47.607]                         invokeRestart("muffleMessage")
[17:46:47.607]                     }
[17:46:47.607]                     else if (inherits(cond, "warning")) {
[17:46:47.607]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.607]                       if (muffled) 
[17:46:47.607]                         invokeRestart("muffleWarning")
[17:46:47.607]                     }
[17:46:47.607]                     else if (inherits(cond, "condition")) {
[17:46:47.607]                       if (!is.null(pattern)) {
[17:46:47.607]                         computeRestarts <- base::computeRestarts
[17:46:47.607]                         grepl <- base::grepl
[17:46:47.607]                         restarts <- computeRestarts(cond)
[17:46:47.607]                         for (restart in restarts) {
[17:46:47.607]                           name <- restart$name
[17:46:47.607]                           if (is.null(name)) 
[17:46:47.607]                             next
[17:46:47.607]                           if (!grepl(pattern, name)) 
[17:46:47.607]                             next
[17:46:47.607]                           invokeRestart(restart)
[17:46:47.607]                           muffled <- TRUE
[17:46:47.607]                           break
[17:46:47.607]                         }
[17:46:47.607]                       }
[17:46:47.607]                     }
[17:46:47.607]                     invisible(muffled)
[17:46:47.607]                   }
[17:46:47.607]                   muffleCondition(cond)
[17:46:47.607]                 })
[17:46:47.607]             }))
[17:46:47.607]             future::FutureResult(value = ...future.value$value, 
[17:46:47.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.607]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.607]                     ...future.globalenv.names))
[17:46:47.607]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.607]         }, condition = base::local({
[17:46:47.607]             c <- base::c
[17:46:47.607]             inherits <- base::inherits
[17:46:47.607]             invokeRestart <- base::invokeRestart
[17:46:47.607]             length <- base::length
[17:46:47.607]             list <- base::list
[17:46:47.607]             seq.int <- base::seq.int
[17:46:47.607]             signalCondition <- base::signalCondition
[17:46:47.607]             sys.calls <- base::sys.calls
[17:46:47.607]             `[[` <- base::`[[`
[17:46:47.607]             `+` <- base::`+`
[17:46:47.607]             `<<-` <- base::`<<-`
[17:46:47.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.607]                   3L)]
[17:46:47.607]             }
[17:46:47.607]             function(cond) {
[17:46:47.607]                 is_error <- inherits(cond, "error")
[17:46:47.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.607]                   NULL)
[17:46:47.607]                 if (is_error) {
[17:46:47.607]                   sessionInformation <- function() {
[17:46:47.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.607]                       search = base::search(), system = base::Sys.info())
[17:46:47.607]                   }
[17:46:47.607]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.607]                     cond$call), session = sessionInformation(), 
[17:46:47.607]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.607]                   signalCondition(cond)
[17:46:47.607]                 }
[17:46:47.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.607]                 "immediateCondition"))) {
[17:46:47.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.607]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.607]                   if (TRUE && !signal) {
[17:46:47.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.607]                     {
[17:46:47.607]                       inherits <- base::inherits
[17:46:47.607]                       invokeRestart <- base::invokeRestart
[17:46:47.607]                       is.null <- base::is.null
[17:46:47.607]                       muffled <- FALSE
[17:46:47.607]                       if (inherits(cond, "message")) {
[17:46:47.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.607]                         if (muffled) 
[17:46:47.607]                           invokeRestart("muffleMessage")
[17:46:47.607]                       }
[17:46:47.607]                       else if (inherits(cond, "warning")) {
[17:46:47.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.607]                         if (muffled) 
[17:46:47.607]                           invokeRestart("muffleWarning")
[17:46:47.607]                       }
[17:46:47.607]                       else if (inherits(cond, "condition")) {
[17:46:47.607]                         if (!is.null(pattern)) {
[17:46:47.607]                           computeRestarts <- base::computeRestarts
[17:46:47.607]                           grepl <- base::grepl
[17:46:47.607]                           restarts <- computeRestarts(cond)
[17:46:47.607]                           for (restart in restarts) {
[17:46:47.607]                             name <- restart$name
[17:46:47.607]                             if (is.null(name)) 
[17:46:47.607]                               next
[17:46:47.607]                             if (!grepl(pattern, name)) 
[17:46:47.607]                               next
[17:46:47.607]                             invokeRestart(restart)
[17:46:47.607]                             muffled <- TRUE
[17:46:47.607]                             break
[17:46:47.607]                           }
[17:46:47.607]                         }
[17:46:47.607]                       }
[17:46:47.607]                       invisible(muffled)
[17:46:47.607]                     }
[17:46:47.607]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.607]                   }
[17:46:47.607]                 }
[17:46:47.607]                 else {
[17:46:47.607]                   if (TRUE) {
[17:46:47.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.607]                     {
[17:46:47.607]                       inherits <- base::inherits
[17:46:47.607]                       invokeRestart <- base::invokeRestart
[17:46:47.607]                       is.null <- base::is.null
[17:46:47.607]                       muffled <- FALSE
[17:46:47.607]                       if (inherits(cond, "message")) {
[17:46:47.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.607]                         if (muffled) 
[17:46:47.607]                           invokeRestart("muffleMessage")
[17:46:47.607]                       }
[17:46:47.607]                       else if (inherits(cond, "warning")) {
[17:46:47.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.607]                         if (muffled) 
[17:46:47.607]                           invokeRestart("muffleWarning")
[17:46:47.607]                       }
[17:46:47.607]                       else if (inherits(cond, "condition")) {
[17:46:47.607]                         if (!is.null(pattern)) {
[17:46:47.607]                           computeRestarts <- base::computeRestarts
[17:46:47.607]                           grepl <- base::grepl
[17:46:47.607]                           restarts <- computeRestarts(cond)
[17:46:47.607]                           for (restart in restarts) {
[17:46:47.607]                             name <- restart$name
[17:46:47.607]                             if (is.null(name)) 
[17:46:47.607]                               next
[17:46:47.607]                             if (!grepl(pattern, name)) 
[17:46:47.607]                               next
[17:46:47.607]                             invokeRestart(restart)
[17:46:47.607]                             muffled <- TRUE
[17:46:47.607]                             break
[17:46:47.607]                           }
[17:46:47.607]                         }
[17:46:47.607]                       }
[17:46:47.607]                       invisible(muffled)
[17:46:47.607]                     }
[17:46:47.607]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.607]                   }
[17:46:47.607]                 }
[17:46:47.607]             }
[17:46:47.607]         }))
[17:46:47.607]     }, error = function(ex) {
[17:46:47.607]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.607]                 ...future.rng), started = ...future.startTime, 
[17:46:47.607]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.607]             version = "1.8"), class = "FutureResult")
[17:46:47.607]     }, finally = {
[17:46:47.607]         if (!identical(...future.workdir, getwd())) 
[17:46:47.607]             setwd(...future.workdir)
[17:46:47.607]         {
[17:46:47.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.607]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.607]             }
[17:46:47.607]             base::options(...future.oldOptions)
[17:46:47.607]             if (.Platform$OS.type == "windows") {
[17:46:47.607]                 old_names <- names(...future.oldEnvVars)
[17:46:47.607]                 envs <- base::Sys.getenv()
[17:46:47.607]                 names <- names(envs)
[17:46:47.607]                 common <- intersect(names, old_names)
[17:46:47.607]                 added <- setdiff(names, old_names)
[17:46:47.607]                 removed <- setdiff(old_names, names)
[17:46:47.607]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.607]                   envs[common]]
[17:46:47.607]                 NAMES <- toupper(changed)
[17:46:47.607]                 args <- list()
[17:46:47.607]                 for (kk in seq_along(NAMES)) {
[17:46:47.607]                   name <- changed[[kk]]
[17:46:47.607]                   NAME <- NAMES[[kk]]
[17:46:47.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.607]                     next
[17:46:47.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.607]                 }
[17:46:47.607]                 NAMES <- toupper(added)
[17:46:47.607]                 for (kk in seq_along(NAMES)) {
[17:46:47.607]                   name <- added[[kk]]
[17:46:47.607]                   NAME <- NAMES[[kk]]
[17:46:47.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.607]                     next
[17:46:47.607]                   args[[name]] <- ""
[17:46:47.607]                 }
[17:46:47.607]                 NAMES <- toupper(removed)
[17:46:47.607]                 for (kk in seq_along(NAMES)) {
[17:46:47.607]                   name <- removed[[kk]]
[17:46:47.607]                   NAME <- NAMES[[kk]]
[17:46:47.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.607]                     next
[17:46:47.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.607]                 }
[17:46:47.607]                 if (length(args) > 0) 
[17:46:47.607]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.607]             }
[17:46:47.607]             else {
[17:46:47.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.607]             }
[17:46:47.607]             {
[17:46:47.607]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.607]                   0L) {
[17:46:47.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.607]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.607]                   base::options(opts)
[17:46:47.607]                 }
[17:46:47.607]                 {
[17:46:47.607]                   {
[17:46:47.607]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.607]                     NULL
[17:46:47.607]                   }
[17:46:47.607]                   options(future.plan = NULL)
[17:46:47.607]                   if (is.na(NA_character_)) 
[17:46:47.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.607]                     .init = FALSE)
[17:46:47.607]                 }
[17:46:47.607]             }
[17:46:47.607]         }
[17:46:47.607]     })
[17:46:47.607]     if (TRUE) {
[17:46:47.607]         base::sink(type = "output", split = FALSE)
[17:46:47.607]         if (TRUE) {
[17:46:47.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.607]         }
[17:46:47.607]         else {
[17:46:47.607]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.607]         }
[17:46:47.607]         base::close(...future.stdout)
[17:46:47.607]         ...future.stdout <- NULL
[17:46:47.607]     }
[17:46:47.607]     ...future.result$conditions <- ...future.conditions
[17:46:47.607]     ...future.result$finished <- base::Sys.time()
[17:46:47.607]     ...future.result
[17:46:47.607] }
[17:46:47.610] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:47.620] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.621] - Validating connection of MultisessionFuture
[17:46:47.621] - received message: FutureResult
[17:46:47.621] - Received FutureResult
[17:46:47.621] - Erased future from FutureRegistry
[17:46:47.621] result() for ClusterFuture ...
[17:46:47.621] - result already collected: FutureResult
[17:46:47.621] result() for ClusterFuture ... done
[17:46:47.621] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.621] result() for ClusterFuture ...
[17:46:47.622] - result already collected: FutureResult
[17:46:47.622] result() for ClusterFuture ... done
[17:46:47.622] result() for ClusterFuture ...
[17:46:47.622] - result already collected: FutureResult
[17:46:47.622] result() for ClusterFuture ... done
[17:46:47.623] MultisessionFuture started
[17:46:47.623] - Launch lazy future ... done
[17:46:47.623] run() for ‘MultisessionFuture’ ... done
<environment: 0x5617882b3910> 
<environment: 0x5617888a2838> 
[17:46:47.626] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.626] - Validating connection of MultisessionFuture
[17:46:47.626] - received message: FutureResult
[17:46:47.626] - Received FutureResult
[17:46:47.627] - Erased future from FutureRegistry
[17:46:47.627] result() for ClusterFuture ...
[17:46:47.627] - result already collected: FutureResult
[17:46:47.627] result() for ClusterFuture ... done
[17:46:47.627] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.630] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.630] - Validating connection of MultisessionFuture
[17:46:47.630] - received message: FutureResult
[17:46:47.630] - Received FutureResult
[17:46:47.630] - Erased future from FutureRegistry
[17:46:47.630] result() for ClusterFuture ...
[17:46:47.630] - result already collected: FutureResult
[17:46:47.631] result() for ClusterFuture ... done
[17:46:47.631] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:47.632] resolve() on environment ...
[17:46:47.632]  recursive: 0
[17:46:47.632]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:47.633] signalConditionsASAP(numeric, pos=1) ...
[17:46:47.633] - nx: 4
[17:46:47.633] - relay: TRUE
[17:46:47.633] - stdout: TRUE
[17:46:47.633] - signal: TRUE
[17:46:47.633] - resignal: FALSE
[17:46:47.633] - force: TRUE
[17:46:47.633] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.633] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.633]  - until=2
[17:46:47.633]  - relaying element #2
[17:46:47.634] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.634] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.634] signalConditionsASAP(NULL, pos=1) ... done
[17:46:47.634]  length: 3 (resolved future 1)
[17:46:47.634] Future #2
[17:46:47.634] result() for ClusterFuture ...
[17:46:47.634] - result already collected: FutureResult
[17:46:47.634] result() for ClusterFuture ... done
[17:46:47.634] result() for ClusterFuture ...
[17:46:47.634] - result already collected: FutureResult
[17:46:47.634] result() for ClusterFuture ... done
[17:46:47.635] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:47.635] - nx: 4
[17:46:47.635] - relay: TRUE
[17:46:47.635] - stdout: TRUE
[17:46:47.635] - signal: TRUE
[17:46:47.635] - resignal: FALSE
[17:46:47.635] - force: TRUE
[17:46:47.635] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.635] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.635]  - until=2
[17:46:47.635]  - relaying element #2
[17:46:47.636] result() for ClusterFuture ...
[17:46:47.636] - result already collected: FutureResult
[17:46:47.636] result() for ClusterFuture ... done
[17:46:47.636] result() for ClusterFuture ...
[17:46:47.636] - result already collected: FutureResult
[17:46:47.636] result() for ClusterFuture ... done
[17:46:47.636] result() for ClusterFuture ...
[17:46:47.636] - result already collected: FutureResult
[17:46:47.636] result() for ClusterFuture ... done
[17:46:47.636] result() for ClusterFuture ...
[17:46:47.636] - result already collected: FutureResult
[17:46:47.636] result() for ClusterFuture ... done
[17:46:47.637] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.637] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.637] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:47.637]  length: 2 (resolved future 2)
[17:46:47.637] Future #3
[17:46:47.637] result() for ClusterFuture ...
[17:46:47.637] - result already collected: FutureResult
[17:46:47.637] result() for ClusterFuture ... done
[17:46:47.637] result() for ClusterFuture ...
[17:46:47.637] - result already collected: FutureResult
[17:46:47.637] result() for ClusterFuture ... done
[17:46:47.638] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:47.638] - nx: 4
[17:46:47.638] - relay: TRUE
[17:46:47.638] - stdout: TRUE
[17:46:47.638] - signal: TRUE
[17:46:47.638] - resignal: FALSE
[17:46:47.638] - force: TRUE
[17:46:47.638] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.638] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.638]  - until=3
[17:46:47.638]  - relaying element #3
[17:46:47.638] result() for ClusterFuture ...
[17:46:47.639] - result already collected: FutureResult
[17:46:47.639] result() for ClusterFuture ... done
[17:46:47.639] result() for ClusterFuture ...
[17:46:47.639] - result already collected: FutureResult
[17:46:47.639] result() for ClusterFuture ... done
[17:46:47.639] result() for ClusterFuture ...
[17:46:47.639] - result already collected: FutureResult
[17:46:47.639] result() for ClusterFuture ... done
[17:46:47.639] result() for ClusterFuture ...
[17:46:47.639] - result already collected: FutureResult
[17:46:47.639] result() for ClusterFuture ... done
[17:46:47.640] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.640] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.640] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:47.640]  length: 1 (resolved future 3)
[17:46:47.640] Future #4
[17:46:47.640] result() for ClusterFuture ...
[17:46:47.640] - result already collected: FutureResult
[17:46:47.640] result() for ClusterFuture ... done
[17:46:47.640] result() for ClusterFuture ...
[17:46:47.640] - result already collected: FutureResult
[17:46:47.640] result() for ClusterFuture ... done
[17:46:47.641] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:47.641] - nx: 4
[17:46:47.641] - relay: TRUE
[17:46:47.641] - stdout: TRUE
[17:46:47.641] - signal: TRUE
[17:46:47.641] - resignal: FALSE
[17:46:47.641] - force: TRUE
[17:46:47.641] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.641] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.641]  - until=4
[17:46:47.641]  - relaying element #4
[17:46:47.641] result() for ClusterFuture ...
[17:46:47.642] - result already collected: FutureResult
[17:46:47.642] result() for ClusterFuture ... done
[17:46:47.642] result() for ClusterFuture ...
[17:46:47.642] - result already collected: FutureResult
[17:46:47.642] result() for ClusterFuture ... done
[17:46:47.642] result() for ClusterFuture ...
[17:46:47.642] - result already collected: FutureResult
[17:46:47.642] result() for ClusterFuture ... done
[17:46:47.642] result() for ClusterFuture ...
[17:46:47.642] - result already collected: FutureResult
[17:46:47.642] result() for ClusterFuture ... done
[17:46:47.642] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.643] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.643] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:47.643]  length: 0 (resolved future 4)
[17:46:47.643] Relaying remaining futures
[17:46:47.643] signalConditionsASAP(NULL, pos=0) ...
[17:46:47.643] - nx: 4
[17:46:47.643] - relay: TRUE
[17:46:47.643] - stdout: TRUE
[17:46:47.643] - signal: TRUE
[17:46:47.643] - resignal: FALSE
[17:46:47.643] - force: TRUE
[17:46:47.643] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.644] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:47.644] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.644] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.644] signalConditionsASAP(NULL, pos=0) ... done
[17:46:47.644] resolve() on environment ... DONE
[17:46:47.644] result() for ClusterFuture ...
[17:46:47.644] - result already collected: FutureResult
[17:46:47.644] result() for ClusterFuture ... done
[17:46:47.644] result() for ClusterFuture ...
[17:46:47.644] - result already collected: FutureResult
[17:46:47.644] result() for ClusterFuture ... done
[17:46:47.645] result() for ClusterFuture ...
[17:46:47.645] - result already collected: FutureResult
[17:46:47.645] result() for ClusterFuture ... done
[17:46:47.645] result() for ClusterFuture ...
[17:46:47.645] - result already collected: FutureResult
[17:46:47.645] result() for ClusterFuture ... done
[17:46:47.645] result() for ClusterFuture ...
[17:46:47.645] - result already collected: FutureResult
[17:46:47.645] result() for ClusterFuture ... done
[17:46:47.645] result() for ClusterFuture ...
[17:46:47.645] - result already collected: FutureResult
[17:46:47.646] result() for ClusterFuture ... done
<environment: 0x561788ceda48> 
Dimensions: c(1, 6)
[17:46:47.646] getGlobalsAndPackages() ...
[17:46:47.646] Searching for globals...
[17:46:47.646] 
[17:46:47.646] Searching for globals ... DONE
[17:46:47.647] - globals: [0] <none>
[17:46:47.647] getGlobalsAndPackages() ... DONE
[17:46:47.647] run() for ‘Future’ ...
[17:46:47.647] - state: ‘created’
[17:46:47.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.662]   - Field: ‘node’
[17:46:47.662]   - Field: ‘label’
[17:46:47.662]   - Field: ‘local’
[17:46:47.662]   - Field: ‘owner’
[17:46:47.662]   - Field: ‘envir’
[17:46:47.662]   - Field: ‘workers’
[17:46:47.662]   - Field: ‘packages’
[17:46:47.662]   - Field: ‘gc’
[17:46:47.662]   - Field: ‘conditions’
[17:46:47.663]   - Field: ‘persistent’
[17:46:47.663]   - Field: ‘expr’
[17:46:47.663]   - Field: ‘uuid’
[17:46:47.663]   - Field: ‘seed’
[17:46:47.663]   - Field: ‘version’
[17:46:47.663]   - Field: ‘result’
[17:46:47.663]   - Field: ‘asynchronous’
[17:46:47.663]   - Field: ‘calls’
[17:46:47.663]   - Field: ‘globals’
[17:46:47.663]   - Field: ‘stdout’
[17:46:47.664]   - Field: ‘earlySignal’
[17:46:47.664]   - Field: ‘lazy’
[17:46:47.664]   - Field: ‘state’
[17:46:47.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.664] - Launch lazy future ...
[17:46:47.664] Packages needed by the future expression (n = 0): <none>
[17:46:47.664] Packages needed by future strategies (n = 0): <none>
[17:46:47.665] {
[17:46:47.665]     {
[17:46:47.665]         {
[17:46:47.665]             ...future.startTime <- base::Sys.time()
[17:46:47.665]             {
[17:46:47.665]                 {
[17:46:47.665]                   {
[17:46:47.665]                     {
[17:46:47.665]                       base::local({
[17:46:47.665]                         has_future <- base::requireNamespace("future", 
[17:46:47.665]                           quietly = TRUE)
[17:46:47.665]                         if (has_future) {
[17:46:47.665]                           ns <- base::getNamespace("future")
[17:46:47.665]                           version <- ns[[".package"]][["version"]]
[17:46:47.665]                           if (is.null(version)) 
[17:46:47.665]                             version <- utils::packageVersion("future")
[17:46:47.665]                         }
[17:46:47.665]                         else {
[17:46:47.665]                           version <- NULL
[17:46:47.665]                         }
[17:46:47.665]                         if (!has_future || version < "1.8.0") {
[17:46:47.665]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.665]                             "", base::R.version$version.string), 
[17:46:47.665]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.665]                               "release", "version")], collapse = " "), 
[17:46:47.665]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.665]                             info)
[17:46:47.665]                           info <- base::paste(info, collapse = "; ")
[17:46:47.665]                           if (!has_future) {
[17:46:47.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.665]                               info)
[17:46:47.665]                           }
[17:46:47.665]                           else {
[17:46:47.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.665]                               info, version)
[17:46:47.665]                           }
[17:46:47.665]                           base::stop(msg)
[17:46:47.665]                         }
[17:46:47.665]                       })
[17:46:47.665]                     }
[17:46:47.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.665]                     base::options(mc.cores = 1L)
[17:46:47.665]                   }
[17:46:47.665]                   ...future.strategy.old <- future::plan("list")
[17:46:47.665]                   options(future.plan = NULL)
[17:46:47.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.665]                 }
[17:46:47.665]                 ...future.workdir <- getwd()
[17:46:47.665]             }
[17:46:47.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.665]         }
[17:46:47.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.665]             base::names(...future.oldOptions))
[17:46:47.665]     }
[17:46:47.665]     if (FALSE) {
[17:46:47.665]     }
[17:46:47.665]     else {
[17:46:47.665]         if (TRUE) {
[17:46:47.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.665]                 open = "w")
[17:46:47.665]         }
[17:46:47.665]         else {
[17:46:47.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.665]         }
[17:46:47.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.665]             base::sink(type = "output", split = FALSE)
[17:46:47.665]             base::close(...future.stdout)
[17:46:47.665]         }, add = TRUE)
[17:46:47.665]     }
[17:46:47.665]     ...future.frame <- base::sys.nframe()
[17:46:47.665]     ...future.conditions <- base::list()
[17:46:47.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.665]     if (FALSE) {
[17:46:47.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.665]     }
[17:46:47.665]     ...future.result <- base::tryCatch({
[17:46:47.665]         base::withCallingHandlers({
[17:46:47.665]             ...future.value <- base::withVisible(base::local({
[17:46:47.665]                 ...future.makeSendCondition <- base::local({
[17:46:47.665]                   sendCondition <- NULL
[17:46:47.665]                   function(frame = 1L) {
[17:46:47.665]                     if (is.function(sendCondition)) 
[17:46:47.665]                       return(sendCondition)
[17:46:47.665]                     ns <- getNamespace("parallel")
[17:46:47.665]                     if (exists("sendData", mode = "function", 
[17:46:47.665]                       envir = ns)) {
[17:46:47.665]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.665]                         envir = ns)
[17:46:47.665]                       envir <- sys.frame(frame)
[17:46:47.665]                       master <- NULL
[17:46:47.665]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.665]                         !identical(envir, emptyenv())) {
[17:46:47.665]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.665]                           inherits = FALSE)) {
[17:46:47.665]                           master <- get("master", mode = "list", 
[17:46:47.665]                             envir = envir, inherits = FALSE)
[17:46:47.665]                           if (inherits(master, c("SOCKnode", 
[17:46:47.665]                             "SOCK0node"))) {
[17:46:47.665]                             sendCondition <<- function(cond) {
[17:46:47.665]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.665]                                 success = TRUE)
[17:46:47.665]                               parallel_sendData(master, data)
[17:46:47.665]                             }
[17:46:47.665]                             return(sendCondition)
[17:46:47.665]                           }
[17:46:47.665]                         }
[17:46:47.665]                         frame <- frame + 1L
[17:46:47.665]                         envir <- sys.frame(frame)
[17:46:47.665]                       }
[17:46:47.665]                     }
[17:46:47.665]                     sendCondition <<- function(cond) NULL
[17:46:47.665]                   }
[17:46:47.665]                 })
[17:46:47.665]                 withCallingHandlers({
[17:46:47.665]                   2
[17:46:47.665]                 }, immediateCondition = function(cond) {
[17:46:47.665]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.665]                   sendCondition(cond)
[17:46:47.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.665]                   {
[17:46:47.665]                     inherits <- base::inherits
[17:46:47.665]                     invokeRestart <- base::invokeRestart
[17:46:47.665]                     is.null <- base::is.null
[17:46:47.665]                     muffled <- FALSE
[17:46:47.665]                     if (inherits(cond, "message")) {
[17:46:47.665]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.665]                       if (muffled) 
[17:46:47.665]                         invokeRestart("muffleMessage")
[17:46:47.665]                     }
[17:46:47.665]                     else if (inherits(cond, "warning")) {
[17:46:47.665]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.665]                       if (muffled) 
[17:46:47.665]                         invokeRestart("muffleWarning")
[17:46:47.665]                     }
[17:46:47.665]                     else if (inherits(cond, "condition")) {
[17:46:47.665]                       if (!is.null(pattern)) {
[17:46:47.665]                         computeRestarts <- base::computeRestarts
[17:46:47.665]                         grepl <- base::grepl
[17:46:47.665]                         restarts <- computeRestarts(cond)
[17:46:47.665]                         for (restart in restarts) {
[17:46:47.665]                           name <- restart$name
[17:46:47.665]                           if (is.null(name)) 
[17:46:47.665]                             next
[17:46:47.665]                           if (!grepl(pattern, name)) 
[17:46:47.665]                             next
[17:46:47.665]                           invokeRestart(restart)
[17:46:47.665]                           muffled <- TRUE
[17:46:47.665]                           break
[17:46:47.665]                         }
[17:46:47.665]                       }
[17:46:47.665]                     }
[17:46:47.665]                     invisible(muffled)
[17:46:47.665]                   }
[17:46:47.665]                   muffleCondition(cond)
[17:46:47.665]                 })
[17:46:47.665]             }))
[17:46:47.665]             future::FutureResult(value = ...future.value$value, 
[17:46:47.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.665]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.665]                     ...future.globalenv.names))
[17:46:47.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.665]         }, condition = base::local({
[17:46:47.665]             c <- base::c
[17:46:47.665]             inherits <- base::inherits
[17:46:47.665]             invokeRestart <- base::invokeRestart
[17:46:47.665]             length <- base::length
[17:46:47.665]             list <- base::list
[17:46:47.665]             seq.int <- base::seq.int
[17:46:47.665]             signalCondition <- base::signalCondition
[17:46:47.665]             sys.calls <- base::sys.calls
[17:46:47.665]             `[[` <- base::`[[`
[17:46:47.665]             `+` <- base::`+`
[17:46:47.665]             `<<-` <- base::`<<-`
[17:46:47.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.665]                   3L)]
[17:46:47.665]             }
[17:46:47.665]             function(cond) {
[17:46:47.665]                 is_error <- inherits(cond, "error")
[17:46:47.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.665]                   NULL)
[17:46:47.665]                 if (is_error) {
[17:46:47.665]                   sessionInformation <- function() {
[17:46:47.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.665]                       search = base::search(), system = base::Sys.info())
[17:46:47.665]                   }
[17:46:47.665]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.665]                     cond$call), session = sessionInformation(), 
[17:46:47.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.665]                   signalCondition(cond)
[17:46:47.665]                 }
[17:46:47.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.665]                 "immediateCondition"))) {
[17:46:47.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.665]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.665]                   if (TRUE && !signal) {
[17:46:47.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.665]                     {
[17:46:47.665]                       inherits <- base::inherits
[17:46:47.665]                       invokeRestart <- base::invokeRestart
[17:46:47.665]                       is.null <- base::is.null
[17:46:47.665]                       muffled <- FALSE
[17:46:47.665]                       if (inherits(cond, "message")) {
[17:46:47.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.665]                         if (muffled) 
[17:46:47.665]                           invokeRestart("muffleMessage")
[17:46:47.665]                       }
[17:46:47.665]                       else if (inherits(cond, "warning")) {
[17:46:47.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.665]                         if (muffled) 
[17:46:47.665]                           invokeRestart("muffleWarning")
[17:46:47.665]                       }
[17:46:47.665]                       else if (inherits(cond, "condition")) {
[17:46:47.665]                         if (!is.null(pattern)) {
[17:46:47.665]                           computeRestarts <- base::computeRestarts
[17:46:47.665]                           grepl <- base::grepl
[17:46:47.665]                           restarts <- computeRestarts(cond)
[17:46:47.665]                           for (restart in restarts) {
[17:46:47.665]                             name <- restart$name
[17:46:47.665]                             if (is.null(name)) 
[17:46:47.665]                               next
[17:46:47.665]                             if (!grepl(pattern, name)) 
[17:46:47.665]                               next
[17:46:47.665]                             invokeRestart(restart)
[17:46:47.665]                             muffled <- TRUE
[17:46:47.665]                             break
[17:46:47.665]                           }
[17:46:47.665]                         }
[17:46:47.665]                       }
[17:46:47.665]                       invisible(muffled)
[17:46:47.665]                     }
[17:46:47.665]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.665]                   }
[17:46:47.665]                 }
[17:46:47.665]                 else {
[17:46:47.665]                   if (TRUE) {
[17:46:47.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.665]                     {
[17:46:47.665]                       inherits <- base::inherits
[17:46:47.665]                       invokeRestart <- base::invokeRestart
[17:46:47.665]                       is.null <- base::is.null
[17:46:47.665]                       muffled <- FALSE
[17:46:47.665]                       if (inherits(cond, "message")) {
[17:46:47.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.665]                         if (muffled) 
[17:46:47.665]                           invokeRestart("muffleMessage")
[17:46:47.665]                       }
[17:46:47.665]                       else if (inherits(cond, "warning")) {
[17:46:47.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.665]                         if (muffled) 
[17:46:47.665]                           invokeRestart("muffleWarning")
[17:46:47.665]                       }
[17:46:47.665]                       else if (inherits(cond, "condition")) {
[17:46:47.665]                         if (!is.null(pattern)) {
[17:46:47.665]                           computeRestarts <- base::computeRestarts
[17:46:47.665]                           grepl <- base::grepl
[17:46:47.665]                           restarts <- computeRestarts(cond)
[17:46:47.665]                           for (restart in restarts) {
[17:46:47.665]                             name <- restart$name
[17:46:47.665]                             if (is.null(name)) 
[17:46:47.665]                               next
[17:46:47.665]                             if (!grepl(pattern, name)) 
[17:46:47.665]                               next
[17:46:47.665]                             invokeRestart(restart)
[17:46:47.665]                             muffled <- TRUE
[17:46:47.665]                             break
[17:46:47.665]                           }
[17:46:47.665]                         }
[17:46:47.665]                       }
[17:46:47.665]                       invisible(muffled)
[17:46:47.665]                     }
[17:46:47.665]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.665]                   }
[17:46:47.665]                 }
[17:46:47.665]             }
[17:46:47.665]         }))
[17:46:47.665]     }, error = function(ex) {
[17:46:47.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.665]                 ...future.rng), started = ...future.startTime, 
[17:46:47.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.665]             version = "1.8"), class = "FutureResult")
[17:46:47.665]     }, finally = {
[17:46:47.665]         if (!identical(...future.workdir, getwd())) 
[17:46:47.665]             setwd(...future.workdir)
[17:46:47.665]         {
[17:46:47.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.665]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.665]             }
[17:46:47.665]             base::options(...future.oldOptions)
[17:46:47.665]             if (.Platform$OS.type == "windows") {
[17:46:47.665]                 old_names <- names(...future.oldEnvVars)
[17:46:47.665]                 envs <- base::Sys.getenv()
[17:46:47.665]                 names <- names(envs)
[17:46:47.665]                 common <- intersect(names, old_names)
[17:46:47.665]                 added <- setdiff(names, old_names)
[17:46:47.665]                 removed <- setdiff(old_names, names)
[17:46:47.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.665]                   envs[common]]
[17:46:47.665]                 NAMES <- toupper(changed)
[17:46:47.665]                 args <- list()
[17:46:47.665]                 for (kk in seq_along(NAMES)) {
[17:46:47.665]                   name <- changed[[kk]]
[17:46:47.665]                   NAME <- NAMES[[kk]]
[17:46:47.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.665]                     next
[17:46:47.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.665]                 }
[17:46:47.665]                 NAMES <- toupper(added)
[17:46:47.665]                 for (kk in seq_along(NAMES)) {
[17:46:47.665]                   name <- added[[kk]]
[17:46:47.665]                   NAME <- NAMES[[kk]]
[17:46:47.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.665]                     next
[17:46:47.665]                   args[[name]] <- ""
[17:46:47.665]                 }
[17:46:47.665]                 NAMES <- toupper(removed)
[17:46:47.665]                 for (kk in seq_along(NAMES)) {
[17:46:47.665]                   name <- removed[[kk]]
[17:46:47.665]                   NAME <- NAMES[[kk]]
[17:46:47.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.665]                     next
[17:46:47.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.665]                 }
[17:46:47.665]                 if (length(args) > 0) 
[17:46:47.665]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.665]             }
[17:46:47.665]             else {
[17:46:47.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.665]             }
[17:46:47.665]             {
[17:46:47.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.665]                   0L) {
[17:46:47.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.665]                   base::options(opts)
[17:46:47.665]                 }
[17:46:47.665]                 {
[17:46:47.665]                   {
[17:46:47.665]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.665]                     NULL
[17:46:47.665]                   }
[17:46:47.665]                   options(future.plan = NULL)
[17:46:47.665]                   if (is.na(NA_character_)) 
[17:46:47.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.665]                     .init = FALSE)
[17:46:47.665]                 }
[17:46:47.665]             }
[17:46:47.665]         }
[17:46:47.665]     })
[17:46:47.665]     if (TRUE) {
[17:46:47.665]         base::sink(type = "output", split = FALSE)
[17:46:47.665]         if (TRUE) {
[17:46:47.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.665]         }
[17:46:47.665]         else {
[17:46:47.665]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.665]         }
[17:46:47.665]         base::close(...future.stdout)
[17:46:47.665]         ...future.stdout <- NULL
[17:46:47.665]     }
[17:46:47.665]     ...future.result$conditions <- ...future.conditions
[17:46:47.665]     ...future.result$finished <- base::Sys.time()
[17:46:47.665]     ...future.result
[17:46:47.665] }
[17:46:47.668] MultisessionFuture started
[17:46:47.668] - Launch lazy future ... done
[17:46:47.668] run() for ‘MultisessionFuture’ ... done
[17:46:47.668] getGlobalsAndPackages() ...
[17:46:47.668] Searching for globals...
[17:46:47.669] 
[17:46:47.669] Searching for globals ... DONE
[17:46:47.669] - globals: [0] <none>
[17:46:47.669] getGlobalsAndPackages() ... DONE
[17:46:47.669] run() for ‘Future’ ...
[17:46:47.669] - state: ‘created’
[17:46:47.670] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.684]   - Field: ‘node’
[17:46:47.684]   - Field: ‘label’
[17:46:47.684]   - Field: ‘local’
[17:46:47.684]   - Field: ‘owner’
[17:46:47.684]   - Field: ‘envir’
[17:46:47.684]   - Field: ‘workers’
[17:46:47.684]   - Field: ‘packages’
[17:46:47.684]   - Field: ‘gc’
[17:46:47.684]   - Field: ‘conditions’
[17:46:47.685]   - Field: ‘persistent’
[17:46:47.685]   - Field: ‘expr’
[17:46:47.685]   - Field: ‘uuid’
[17:46:47.685]   - Field: ‘seed’
[17:46:47.685]   - Field: ‘version’
[17:46:47.685]   - Field: ‘result’
[17:46:47.685]   - Field: ‘asynchronous’
[17:46:47.685]   - Field: ‘calls’
[17:46:47.685]   - Field: ‘globals’
[17:46:47.685]   - Field: ‘stdout’
[17:46:47.686]   - Field: ‘earlySignal’
[17:46:47.686]   - Field: ‘lazy’
[17:46:47.686]   - Field: ‘state’
[17:46:47.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.686] - Launch lazy future ...
[17:46:47.686] Packages needed by the future expression (n = 0): <none>
[17:46:47.686] Packages needed by future strategies (n = 0): <none>
[17:46:47.687] {
[17:46:47.687]     {
[17:46:47.687]         {
[17:46:47.687]             ...future.startTime <- base::Sys.time()
[17:46:47.687]             {
[17:46:47.687]                 {
[17:46:47.687]                   {
[17:46:47.687]                     {
[17:46:47.687]                       base::local({
[17:46:47.687]                         has_future <- base::requireNamespace("future", 
[17:46:47.687]                           quietly = TRUE)
[17:46:47.687]                         if (has_future) {
[17:46:47.687]                           ns <- base::getNamespace("future")
[17:46:47.687]                           version <- ns[[".package"]][["version"]]
[17:46:47.687]                           if (is.null(version)) 
[17:46:47.687]                             version <- utils::packageVersion("future")
[17:46:47.687]                         }
[17:46:47.687]                         else {
[17:46:47.687]                           version <- NULL
[17:46:47.687]                         }
[17:46:47.687]                         if (!has_future || version < "1.8.0") {
[17:46:47.687]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.687]                             "", base::R.version$version.string), 
[17:46:47.687]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.687]                               "release", "version")], collapse = " "), 
[17:46:47.687]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.687]                             info)
[17:46:47.687]                           info <- base::paste(info, collapse = "; ")
[17:46:47.687]                           if (!has_future) {
[17:46:47.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.687]                               info)
[17:46:47.687]                           }
[17:46:47.687]                           else {
[17:46:47.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.687]                               info, version)
[17:46:47.687]                           }
[17:46:47.687]                           base::stop(msg)
[17:46:47.687]                         }
[17:46:47.687]                       })
[17:46:47.687]                     }
[17:46:47.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.687]                     base::options(mc.cores = 1L)
[17:46:47.687]                   }
[17:46:47.687]                   ...future.strategy.old <- future::plan("list")
[17:46:47.687]                   options(future.plan = NULL)
[17:46:47.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.687]                 }
[17:46:47.687]                 ...future.workdir <- getwd()
[17:46:47.687]             }
[17:46:47.687]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.687]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.687]         }
[17:46:47.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.687]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.687]             base::names(...future.oldOptions))
[17:46:47.687]     }
[17:46:47.687]     if (FALSE) {
[17:46:47.687]     }
[17:46:47.687]     else {
[17:46:47.687]         if (TRUE) {
[17:46:47.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.687]                 open = "w")
[17:46:47.687]         }
[17:46:47.687]         else {
[17:46:47.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.687]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.687]         }
[17:46:47.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.687]             base::sink(type = "output", split = FALSE)
[17:46:47.687]             base::close(...future.stdout)
[17:46:47.687]         }, add = TRUE)
[17:46:47.687]     }
[17:46:47.687]     ...future.frame <- base::sys.nframe()
[17:46:47.687]     ...future.conditions <- base::list()
[17:46:47.687]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.687]     if (FALSE) {
[17:46:47.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.687]     }
[17:46:47.687]     ...future.result <- base::tryCatch({
[17:46:47.687]         base::withCallingHandlers({
[17:46:47.687]             ...future.value <- base::withVisible(base::local({
[17:46:47.687]                 ...future.makeSendCondition <- base::local({
[17:46:47.687]                   sendCondition <- NULL
[17:46:47.687]                   function(frame = 1L) {
[17:46:47.687]                     if (is.function(sendCondition)) 
[17:46:47.687]                       return(sendCondition)
[17:46:47.687]                     ns <- getNamespace("parallel")
[17:46:47.687]                     if (exists("sendData", mode = "function", 
[17:46:47.687]                       envir = ns)) {
[17:46:47.687]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.687]                         envir = ns)
[17:46:47.687]                       envir <- sys.frame(frame)
[17:46:47.687]                       master <- NULL
[17:46:47.687]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.687]                         !identical(envir, emptyenv())) {
[17:46:47.687]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.687]                           inherits = FALSE)) {
[17:46:47.687]                           master <- get("master", mode = "list", 
[17:46:47.687]                             envir = envir, inherits = FALSE)
[17:46:47.687]                           if (inherits(master, c("SOCKnode", 
[17:46:47.687]                             "SOCK0node"))) {
[17:46:47.687]                             sendCondition <<- function(cond) {
[17:46:47.687]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.687]                                 success = TRUE)
[17:46:47.687]                               parallel_sendData(master, data)
[17:46:47.687]                             }
[17:46:47.687]                             return(sendCondition)
[17:46:47.687]                           }
[17:46:47.687]                         }
[17:46:47.687]                         frame <- frame + 1L
[17:46:47.687]                         envir <- sys.frame(frame)
[17:46:47.687]                       }
[17:46:47.687]                     }
[17:46:47.687]                     sendCondition <<- function(cond) NULL
[17:46:47.687]                   }
[17:46:47.687]                 })
[17:46:47.687]                 withCallingHandlers({
[17:46:47.687]                   NULL
[17:46:47.687]                 }, immediateCondition = function(cond) {
[17:46:47.687]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.687]                   sendCondition(cond)
[17:46:47.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.687]                   {
[17:46:47.687]                     inherits <- base::inherits
[17:46:47.687]                     invokeRestart <- base::invokeRestart
[17:46:47.687]                     is.null <- base::is.null
[17:46:47.687]                     muffled <- FALSE
[17:46:47.687]                     if (inherits(cond, "message")) {
[17:46:47.687]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.687]                       if (muffled) 
[17:46:47.687]                         invokeRestart("muffleMessage")
[17:46:47.687]                     }
[17:46:47.687]                     else if (inherits(cond, "warning")) {
[17:46:47.687]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.687]                       if (muffled) 
[17:46:47.687]                         invokeRestart("muffleWarning")
[17:46:47.687]                     }
[17:46:47.687]                     else if (inherits(cond, "condition")) {
[17:46:47.687]                       if (!is.null(pattern)) {
[17:46:47.687]                         computeRestarts <- base::computeRestarts
[17:46:47.687]                         grepl <- base::grepl
[17:46:47.687]                         restarts <- computeRestarts(cond)
[17:46:47.687]                         for (restart in restarts) {
[17:46:47.687]                           name <- restart$name
[17:46:47.687]                           if (is.null(name)) 
[17:46:47.687]                             next
[17:46:47.687]                           if (!grepl(pattern, name)) 
[17:46:47.687]                             next
[17:46:47.687]                           invokeRestart(restart)
[17:46:47.687]                           muffled <- TRUE
[17:46:47.687]                           break
[17:46:47.687]                         }
[17:46:47.687]                       }
[17:46:47.687]                     }
[17:46:47.687]                     invisible(muffled)
[17:46:47.687]                   }
[17:46:47.687]                   muffleCondition(cond)
[17:46:47.687]                 })
[17:46:47.687]             }))
[17:46:47.687]             future::FutureResult(value = ...future.value$value, 
[17:46:47.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.687]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.687]                     ...future.globalenv.names))
[17:46:47.687]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.687]         }, condition = base::local({
[17:46:47.687]             c <- base::c
[17:46:47.687]             inherits <- base::inherits
[17:46:47.687]             invokeRestart <- base::invokeRestart
[17:46:47.687]             length <- base::length
[17:46:47.687]             list <- base::list
[17:46:47.687]             seq.int <- base::seq.int
[17:46:47.687]             signalCondition <- base::signalCondition
[17:46:47.687]             sys.calls <- base::sys.calls
[17:46:47.687]             `[[` <- base::`[[`
[17:46:47.687]             `+` <- base::`+`
[17:46:47.687]             `<<-` <- base::`<<-`
[17:46:47.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.687]                   3L)]
[17:46:47.687]             }
[17:46:47.687]             function(cond) {
[17:46:47.687]                 is_error <- inherits(cond, "error")
[17:46:47.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.687]                   NULL)
[17:46:47.687]                 if (is_error) {
[17:46:47.687]                   sessionInformation <- function() {
[17:46:47.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.687]                       search = base::search(), system = base::Sys.info())
[17:46:47.687]                   }
[17:46:47.687]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.687]                     cond$call), session = sessionInformation(), 
[17:46:47.687]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.687]                   signalCondition(cond)
[17:46:47.687]                 }
[17:46:47.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.687]                 "immediateCondition"))) {
[17:46:47.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.687]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.687]                   if (TRUE && !signal) {
[17:46:47.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.687]                     {
[17:46:47.687]                       inherits <- base::inherits
[17:46:47.687]                       invokeRestart <- base::invokeRestart
[17:46:47.687]                       is.null <- base::is.null
[17:46:47.687]                       muffled <- FALSE
[17:46:47.687]                       if (inherits(cond, "message")) {
[17:46:47.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.687]                         if (muffled) 
[17:46:47.687]                           invokeRestart("muffleMessage")
[17:46:47.687]                       }
[17:46:47.687]                       else if (inherits(cond, "warning")) {
[17:46:47.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.687]                         if (muffled) 
[17:46:47.687]                           invokeRestart("muffleWarning")
[17:46:47.687]                       }
[17:46:47.687]                       else if (inherits(cond, "condition")) {
[17:46:47.687]                         if (!is.null(pattern)) {
[17:46:47.687]                           computeRestarts <- base::computeRestarts
[17:46:47.687]                           grepl <- base::grepl
[17:46:47.687]                           restarts <- computeRestarts(cond)
[17:46:47.687]                           for (restart in restarts) {
[17:46:47.687]                             name <- restart$name
[17:46:47.687]                             if (is.null(name)) 
[17:46:47.687]                               next
[17:46:47.687]                             if (!grepl(pattern, name)) 
[17:46:47.687]                               next
[17:46:47.687]                             invokeRestart(restart)
[17:46:47.687]                             muffled <- TRUE
[17:46:47.687]                             break
[17:46:47.687]                           }
[17:46:47.687]                         }
[17:46:47.687]                       }
[17:46:47.687]                       invisible(muffled)
[17:46:47.687]                     }
[17:46:47.687]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.687]                   }
[17:46:47.687]                 }
[17:46:47.687]                 else {
[17:46:47.687]                   if (TRUE) {
[17:46:47.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.687]                     {
[17:46:47.687]                       inherits <- base::inherits
[17:46:47.687]                       invokeRestart <- base::invokeRestart
[17:46:47.687]                       is.null <- base::is.null
[17:46:47.687]                       muffled <- FALSE
[17:46:47.687]                       if (inherits(cond, "message")) {
[17:46:47.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.687]                         if (muffled) 
[17:46:47.687]                           invokeRestart("muffleMessage")
[17:46:47.687]                       }
[17:46:47.687]                       else if (inherits(cond, "warning")) {
[17:46:47.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.687]                         if (muffled) 
[17:46:47.687]                           invokeRestart("muffleWarning")
[17:46:47.687]                       }
[17:46:47.687]                       else if (inherits(cond, "condition")) {
[17:46:47.687]                         if (!is.null(pattern)) {
[17:46:47.687]                           computeRestarts <- base::computeRestarts
[17:46:47.687]                           grepl <- base::grepl
[17:46:47.687]                           restarts <- computeRestarts(cond)
[17:46:47.687]                           for (restart in restarts) {
[17:46:47.687]                             name <- restart$name
[17:46:47.687]                             if (is.null(name)) 
[17:46:47.687]                               next
[17:46:47.687]                             if (!grepl(pattern, name)) 
[17:46:47.687]                               next
[17:46:47.687]                             invokeRestart(restart)
[17:46:47.687]                             muffled <- TRUE
[17:46:47.687]                             break
[17:46:47.687]                           }
[17:46:47.687]                         }
[17:46:47.687]                       }
[17:46:47.687]                       invisible(muffled)
[17:46:47.687]                     }
[17:46:47.687]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.687]                   }
[17:46:47.687]                 }
[17:46:47.687]             }
[17:46:47.687]         }))
[17:46:47.687]     }, error = function(ex) {
[17:46:47.687]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.687]                 ...future.rng), started = ...future.startTime, 
[17:46:47.687]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.687]             version = "1.8"), class = "FutureResult")
[17:46:47.687]     }, finally = {
[17:46:47.687]         if (!identical(...future.workdir, getwd())) 
[17:46:47.687]             setwd(...future.workdir)
[17:46:47.687]         {
[17:46:47.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.687]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.687]             }
[17:46:47.687]             base::options(...future.oldOptions)
[17:46:47.687]             if (.Platform$OS.type == "windows") {
[17:46:47.687]                 old_names <- names(...future.oldEnvVars)
[17:46:47.687]                 envs <- base::Sys.getenv()
[17:46:47.687]                 names <- names(envs)
[17:46:47.687]                 common <- intersect(names, old_names)
[17:46:47.687]                 added <- setdiff(names, old_names)
[17:46:47.687]                 removed <- setdiff(old_names, names)
[17:46:47.687]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.687]                   envs[common]]
[17:46:47.687]                 NAMES <- toupper(changed)
[17:46:47.687]                 args <- list()
[17:46:47.687]                 for (kk in seq_along(NAMES)) {
[17:46:47.687]                   name <- changed[[kk]]
[17:46:47.687]                   NAME <- NAMES[[kk]]
[17:46:47.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.687]                     next
[17:46:47.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.687]                 }
[17:46:47.687]                 NAMES <- toupper(added)
[17:46:47.687]                 for (kk in seq_along(NAMES)) {
[17:46:47.687]                   name <- added[[kk]]
[17:46:47.687]                   NAME <- NAMES[[kk]]
[17:46:47.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.687]                     next
[17:46:47.687]                   args[[name]] <- ""
[17:46:47.687]                 }
[17:46:47.687]                 NAMES <- toupper(removed)
[17:46:47.687]                 for (kk in seq_along(NAMES)) {
[17:46:47.687]                   name <- removed[[kk]]
[17:46:47.687]                   NAME <- NAMES[[kk]]
[17:46:47.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.687]                     next
[17:46:47.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.687]                 }
[17:46:47.687]                 if (length(args) > 0) 
[17:46:47.687]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.687]             }
[17:46:47.687]             else {
[17:46:47.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.687]             }
[17:46:47.687]             {
[17:46:47.687]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.687]                   0L) {
[17:46:47.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.687]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.687]                   base::options(opts)
[17:46:47.687]                 }
[17:46:47.687]                 {
[17:46:47.687]                   {
[17:46:47.687]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.687]                     NULL
[17:46:47.687]                   }
[17:46:47.687]                   options(future.plan = NULL)
[17:46:47.687]                   if (is.na(NA_character_)) 
[17:46:47.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.687]                     .init = FALSE)
[17:46:47.687]                 }
[17:46:47.687]             }
[17:46:47.687]         }
[17:46:47.687]     })
[17:46:47.687]     if (TRUE) {
[17:46:47.687]         base::sink(type = "output", split = FALSE)
[17:46:47.687]         if (TRUE) {
[17:46:47.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.687]         }
[17:46:47.687]         else {
[17:46:47.687]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.687]         }
[17:46:47.687]         base::close(...future.stdout)
[17:46:47.687]         ...future.stdout <- NULL
[17:46:47.687]     }
[17:46:47.687]     ...future.result$conditions <- ...future.conditions
[17:46:47.687]     ...future.result$finished <- base::Sys.time()
[17:46:47.687]     ...future.result
[17:46:47.687] }
[17:46:47.690] MultisessionFuture started
[17:46:47.690] - Launch lazy future ... done
[17:46:47.690] run() for ‘MultisessionFuture’ ... done
[17:46:47.690] getGlobalsAndPackages() ...
[17:46:47.691] Searching for globals...
[17:46:47.697] - globals found: [1] ‘{’
[17:46:47.697] Searching for globals ... DONE
[17:46:47.697] Resolving globals: FALSE
[17:46:47.698] 
[17:46:47.698] 
[17:46:47.698] getGlobalsAndPackages() ... DONE
[17:46:47.698] run() for ‘Future’ ...
[17:46:47.698] - state: ‘created’
[17:46:47.698] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.712] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.712] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.712]   - Field: ‘node’
[17:46:47.712]   - Field: ‘label’
[17:46:47.713]   - Field: ‘local’
[17:46:47.713]   - Field: ‘owner’
[17:46:47.713]   - Field: ‘envir’
[17:46:47.713]   - Field: ‘workers’
[17:46:47.713]   - Field: ‘packages’
[17:46:47.713]   - Field: ‘gc’
[17:46:47.713]   - Field: ‘conditions’
[17:46:47.713]   - Field: ‘persistent’
[17:46:47.713]   - Field: ‘expr’
[17:46:47.713]   - Field: ‘uuid’
[17:46:47.713]   - Field: ‘seed’
[17:46:47.713]   - Field: ‘version’
[17:46:47.714]   - Field: ‘result’
[17:46:47.714]   - Field: ‘asynchronous’
[17:46:47.714]   - Field: ‘calls’
[17:46:47.714]   - Field: ‘globals’
[17:46:47.714]   - Field: ‘stdout’
[17:46:47.714]   - Field: ‘earlySignal’
[17:46:47.714]   - Field: ‘lazy’
[17:46:47.714]   - Field: ‘state’
[17:46:47.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.714] - Launch lazy future ...
[17:46:47.715] Packages needed by the future expression (n = 0): <none>
[17:46:47.715] Packages needed by future strategies (n = 0): <none>
[17:46:47.715] {
[17:46:47.715]     {
[17:46:47.715]         {
[17:46:47.715]             ...future.startTime <- base::Sys.time()
[17:46:47.715]             {
[17:46:47.715]                 {
[17:46:47.715]                   {
[17:46:47.715]                     {
[17:46:47.715]                       base::local({
[17:46:47.715]                         has_future <- base::requireNamespace("future", 
[17:46:47.715]                           quietly = TRUE)
[17:46:47.715]                         if (has_future) {
[17:46:47.715]                           ns <- base::getNamespace("future")
[17:46:47.715]                           version <- ns[[".package"]][["version"]]
[17:46:47.715]                           if (is.null(version)) 
[17:46:47.715]                             version <- utils::packageVersion("future")
[17:46:47.715]                         }
[17:46:47.715]                         else {
[17:46:47.715]                           version <- NULL
[17:46:47.715]                         }
[17:46:47.715]                         if (!has_future || version < "1.8.0") {
[17:46:47.715]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.715]                             "", base::R.version$version.string), 
[17:46:47.715]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.715]                               "release", "version")], collapse = " "), 
[17:46:47.715]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.715]                             info)
[17:46:47.715]                           info <- base::paste(info, collapse = "; ")
[17:46:47.715]                           if (!has_future) {
[17:46:47.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.715]                               info)
[17:46:47.715]                           }
[17:46:47.715]                           else {
[17:46:47.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.715]                               info, version)
[17:46:47.715]                           }
[17:46:47.715]                           base::stop(msg)
[17:46:47.715]                         }
[17:46:47.715]                       })
[17:46:47.715]                     }
[17:46:47.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.715]                     base::options(mc.cores = 1L)
[17:46:47.715]                   }
[17:46:47.715]                   ...future.strategy.old <- future::plan("list")
[17:46:47.715]                   options(future.plan = NULL)
[17:46:47.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.715]                 }
[17:46:47.715]                 ...future.workdir <- getwd()
[17:46:47.715]             }
[17:46:47.715]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.715]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.715]         }
[17:46:47.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.715]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.715]             base::names(...future.oldOptions))
[17:46:47.715]     }
[17:46:47.715]     if (FALSE) {
[17:46:47.715]     }
[17:46:47.715]     else {
[17:46:47.715]         if (TRUE) {
[17:46:47.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.715]                 open = "w")
[17:46:47.715]         }
[17:46:47.715]         else {
[17:46:47.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.715]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.715]         }
[17:46:47.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.715]             base::sink(type = "output", split = FALSE)
[17:46:47.715]             base::close(...future.stdout)
[17:46:47.715]         }, add = TRUE)
[17:46:47.715]     }
[17:46:47.715]     ...future.frame <- base::sys.nframe()
[17:46:47.715]     ...future.conditions <- base::list()
[17:46:47.715]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.715]     if (FALSE) {
[17:46:47.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.715]     }
[17:46:47.715]     ...future.result <- base::tryCatch({
[17:46:47.715]         base::withCallingHandlers({
[17:46:47.715]             ...future.value <- base::withVisible(base::local({
[17:46:47.715]                 ...future.makeSendCondition <- base::local({
[17:46:47.715]                   sendCondition <- NULL
[17:46:47.715]                   function(frame = 1L) {
[17:46:47.715]                     if (is.function(sendCondition)) 
[17:46:47.715]                       return(sendCondition)
[17:46:47.715]                     ns <- getNamespace("parallel")
[17:46:47.715]                     if (exists("sendData", mode = "function", 
[17:46:47.715]                       envir = ns)) {
[17:46:47.715]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.715]                         envir = ns)
[17:46:47.715]                       envir <- sys.frame(frame)
[17:46:47.715]                       master <- NULL
[17:46:47.715]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.715]                         !identical(envir, emptyenv())) {
[17:46:47.715]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.715]                           inherits = FALSE)) {
[17:46:47.715]                           master <- get("master", mode = "list", 
[17:46:47.715]                             envir = envir, inherits = FALSE)
[17:46:47.715]                           if (inherits(master, c("SOCKnode", 
[17:46:47.715]                             "SOCK0node"))) {
[17:46:47.715]                             sendCondition <<- function(cond) {
[17:46:47.715]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.715]                                 success = TRUE)
[17:46:47.715]                               parallel_sendData(master, data)
[17:46:47.715]                             }
[17:46:47.715]                             return(sendCondition)
[17:46:47.715]                           }
[17:46:47.715]                         }
[17:46:47.715]                         frame <- frame + 1L
[17:46:47.715]                         envir <- sys.frame(frame)
[17:46:47.715]                       }
[17:46:47.715]                     }
[17:46:47.715]                     sendCondition <<- function(cond) NULL
[17:46:47.715]                   }
[17:46:47.715]                 })
[17:46:47.715]                 withCallingHandlers({
[17:46:47.715]                   {
[17:46:47.715]                     4
[17:46:47.715]                   }
[17:46:47.715]                 }, immediateCondition = function(cond) {
[17:46:47.715]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.715]                   sendCondition(cond)
[17:46:47.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.715]                   {
[17:46:47.715]                     inherits <- base::inherits
[17:46:47.715]                     invokeRestart <- base::invokeRestart
[17:46:47.715]                     is.null <- base::is.null
[17:46:47.715]                     muffled <- FALSE
[17:46:47.715]                     if (inherits(cond, "message")) {
[17:46:47.715]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.715]                       if (muffled) 
[17:46:47.715]                         invokeRestart("muffleMessage")
[17:46:47.715]                     }
[17:46:47.715]                     else if (inherits(cond, "warning")) {
[17:46:47.715]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.715]                       if (muffled) 
[17:46:47.715]                         invokeRestart("muffleWarning")
[17:46:47.715]                     }
[17:46:47.715]                     else if (inherits(cond, "condition")) {
[17:46:47.715]                       if (!is.null(pattern)) {
[17:46:47.715]                         computeRestarts <- base::computeRestarts
[17:46:47.715]                         grepl <- base::grepl
[17:46:47.715]                         restarts <- computeRestarts(cond)
[17:46:47.715]                         for (restart in restarts) {
[17:46:47.715]                           name <- restart$name
[17:46:47.715]                           if (is.null(name)) 
[17:46:47.715]                             next
[17:46:47.715]                           if (!grepl(pattern, name)) 
[17:46:47.715]                             next
[17:46:47.715]                           invokeRestart(restart)
[17:46:47.715]                           muffled <- TRUE
[17:46:47.715]                           break
[17:46:47.715]                         }
[17:46:47.715]                       }
[17:46:47.715]                     }
[17:46:47.715]                     invisible(muffled)
[17:46:47.715]                   }
[17:46:47.715]                   muffleCondition(cond)
[17:46:47.715]                 })
[17:46:47.715]             }))
[17:46:47.715]             future::FutureResult(value = ...future.value$value, 
[17:46:47.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.715]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.715]                     ...future.globalenv.names))
[17:46:47.715]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.715]         }, condition = base::local({
[17:46:47.715]             c <- base::c
[17:46:47.715]             inherits <- base::inherits
[17:46:47.715]             invokeRestart <- base::invokeRestart
[17:46:47.715]             length <- base::length
[17:46:47.715]             list <- base::list
[17:46:47.715]             seq.int <- base::seq.int
[17:46:47.715]             signalCondition <- base::signalCondition
[17:46:47.715]             sys.calls <- base::sys.calls
[17:46:47.715]             `[[` <- base::`[[`
[17:46:47.715]             `+` <- base::`+`
[17:46:47.715]             `<<-` <- base::`<<-`
[17:46:47.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.715]                   3L)]
[17:46:47.715]             }
[17:46:47.715]             function(cond) {
[17:46:47.715]                 is_error <- inherits(cond, "error")
[17:46:47.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.715]                   NULL)
[17:46:47.715]                 if (is_error) {
[17:46:47.715]                   sessionInformation <- function() {
[17:46:47.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.715]                       search = base::search(), system = base::Sys.info())
[17:46:47.715]                   }
[17:46:47.715]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.715]                     cond$call), session = sessionInformation(), 
[17:46:47.715]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.715]                   signalCondition(cond)
[17:46:47.715]                 }
[17:46:47.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.715]                 "immediateCondition"))) {
[17:46:47.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.715]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.715]                   if (TRUE && !signal) {
[17:46:47.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.715]                     {
[17:46:47.715]                       inherits <- base::inherits
[17:46:47.715]                       invokeRestart <- base::invokeRestart
[17:46:47.715]                       is.null <- base::is.null
[17:46:47.715]                       muffled <- FALSE
[17:46:47.715]                       if (inherits(cond, "message")) {
[17:46:47.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.715]                         if (muffled) 
[17:46:47.715]                           invokeRestart("muffleMessage")
[17:46:47.715]                       }
[17:46:47.715]                       else if (inherits(cond, "warning")) {
[17:46:47.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.715]                         if (muffled) 
[17:46:47.715]                           invokeRestart("muffleWarning")
[17:46:47.715]                       }
[17:46:47.715]                       else if (inherits(cond, "condition")) {
[17:46:47.715]                         if (!is.null(pattern)) {
[17:46:47.715]                           computeRestarts <- base::computeRestarts
[17:46:47.715]                           grepl <- base::grepl
[17:46:47.715]                           restarts <- computeRestarts(cond)
[17:46:47.715]                           for (restart in restarts) {
[17:46:47.715]                             name <- restart$name
[17:46:47.715]                             if (is.null(name)) 
[17:46:47.715]                               next
[17:46:47.715]                             if (!grepl(pattern, name)) 
[17:46:47.715]                               next
[17:46:47.715]                             invokeRestart(restart)
[17:46:47.715]                             muffled <- TRUE
[17:46:47.715]                             break
[17:46:47.715]                           }
[17:46:47.715]                         }
[17:46:47.715]                       }
[17:46:47.715]                       invisible(muffled)
[17:46:47.715]                     }
[17:46:47.715]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.715]                   }
[17:46:47.715]                 }
[17:46:47.715]                 else {
[17:46:47.715]                   if (TRUE) {
[17:46:47.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.715]                     {
[17:46:47.715]                       inherits <- base::inherits
[17:46:47.715]                       invokeRestart <- base::invokeRestart
[17:46:47.715]                       is.null <- base::is.null
[17:46:47.715]                       muffled <- FALSE
[17:46:47.715]                       if (inherits(cond, "message")) {
[17:46:47.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.715]                         if (muffled) 
[17:46:47.715]                           invokeRestart("muffleMessage")
[17:46:47.715]                       }
[17:46:47.715]                       else if (inherits(cond, "warning")) {
[17:46:47.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.715]                         if (muffled) 
[17:46:47.715]                           invokeRestart("muffleWarning")
[17:46:47.715]                       }
[17:46:47.715]                       else if (inherits(cond, "condition")) {
[17:46:47.715]                         if (!is.null(pattern)) {
[17:46:47.715]                           computeRestarts <- base::computeRestarts
[17:46:47.715]                           grepl <- base::grepl
[17:46:47.715]                           restarts <- computeRestarts(cond)
[17:46:47.715]                           for (restart in restarts) {
[17:46:47.715]                             name <- restart$name
[17:46:47.715]                             if (is.null(name)) 
[17:46:47.715]                               next
[17:46:47.715]                             if (!grepl(pattern, name)) 
[17:46:47.715]                               next
[17:46:47.715]                             invokeRestart(restart)
[17:46:47.715]                             muffled <- TRUE
[17:46:47.715]                             break
[17:46:47.715]                           }
[17:46:47.715]                         }
[17:46:47.715]                       }
[17:46:47.715]                       invisible(muffled)
[17:46:47.715]                     }
[17:46:47.715]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.715]                   }
[17:46:47.715]                 }
[17:46:47.715]             }
[17:46:47.715]         }))
[17:46:47.715]     }, error = function(ex) {
[17:46:47.715]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.715]                 ...future.rng), started = ...future.startTime, 
[17:46:47.715]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.715]             version = "1.8"), class = "FutureResult")
[17:46:47.715]     }, finally = {
[17:46:47.715]         if (!identical(...future.workdir, getwd())) 
[17:46:47.715]             setwd(...future.workdir)
[17:46:47.715]         {
[17:46:47.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.715]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.715]             }
[17:46:47.715]             base::options(...future.oldOptions)
[17:46:47.715]             if (.Platform$OS.type == "windows") {
[17:46:47.715]                 old_names <- names(...future.oldEnvVars)
[17:46:47.715]                 envs <- base::Sys.getenv()
[17:46:47.715]                 names <- names(envs)
[17:46:47.715]                 common <- intersect(names, old_names)
[17:46:47.715]                 added <- setdiff(names, old_names)
[17:46:47.715]                 removed <- setdiff(old_names, names)
[17:46:47.715]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.715]                   envs[common]]
[17:46:47.715]                 NAMES <- toupper(changed)
[17:46:47.715]                 args <- list()
[17:46:47.715]                 for (kk in seq_along(NAMES)) {
[17:46:47.715]                   name <- changed[[kk]]
[17:46:47.715]                   NAME <- NAMES[[kk]]
[17:46:47.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.715]                     next
[17:46:47.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.715]                 }
[17:46:47.715]                 NAMES <- toupper(added)
[17:46:47.715]                 for (kk in seq_along(NAMES)) {
[17:46:47.715]                   name <- added[[kk]]
[17:46:47.715]                   NAME <- NAMES[[kk]]
[17:46:47.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.715]                     next
[17:46:47.715]                   args[[name]] <- ""
[17:46:47.715]                 }
[17:46:47.715]                 NAMES <- toupper(removed)
[17:46:47.715]                 for (kk in seq_along(NAMES)) {
[17:46:47.715]                   name <- removed[[kk]]
[17:46:47.715]                   NAME <- NAMES[[kk]]
[17:46:47.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.715]                     next
[17:46:47.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.715]                 }
[17:46:47.715]                 if (length(args) > 0) 
[17:46:47.715]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.715]             }
[17:46:47.715]             else {
[17:46:47.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.715]             }
[17:46:47.715]             {
[17:46:47.715]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.715]                   0L) {
[17:46:47.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.715]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.715]                   base::options(opts)
[17:46:47.715]                 }
[17:46:47.715]                 {
[17:46:47.715]                   {
[17:46:47.715]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.715]                     NULL
[17:46:47.715]                   }
[17:46:47.715]                   options(future.plan = NULL)
[17:46:47.715]                   if (is.na(NA_character_)) 
[17:46:47.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.715]                     .init = FALSE)
[17:46:47.715]                 }
[17:46:47.715]             }
[17:46:47.715]         }
[17:46:47.715]     })
[17:46:47.715]     if (TRUE) {
[17:46:47.715]         base::sink(type = "output", split = FALSE)
[17:46:47.715]         if (TRUE) {
[17:46:47.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.715]         }
[17:46:47.715]         else {
[17:46:47.715]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.715]         }
[17:46:47.715]         base::close(...future.stdout)
[17:46:47.715]         ...future.stdout <- NULL
[17:46:47.715]     }
[17:46:47.715]     ...future.result$conditions <- ...future.conditions
[17:46:47.715]     ...future.result$finished <- base::Sys.time()
[17:46:47.715]     ...future.result
[17:46:47.715] }
[17:46:47.717] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:47.728] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.728] - Validating connection of MultisessionFuture
[17:46:47.728] - received message: FutureResult
[17:46:47.728] - Received FutureResult
[17:46:47.728] - Erased future from FutureRegistry
[17:46:47.728] result() for ClusterFuture ...
[17:46:47.729] - result already collected: FutureResult
[17:46:47.729] result() for ClusterFuture ... done
[17:46:47.729] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.729] result() for ClusterFuture ...
[17:46:47.729] - result already collected: FutureResult
[17:46:47.729] result() for ClusterFuture ... done
[17:46:47.729] result() for ClusterFuture ...
[17:46:47.729] - result already collected: FutureResult
[17:46:47.729] result() for ClusterFuture ... done
[17:46:47.730] MultisessionFuture started
[17:46:47.730] - Launch lazy future ... done
[17:46:47.730] run() for ‘MultisessionFuture’ ... done
<environment: 0x5617895d5970> 
<environment: 0x561787b71888> 
[17:46:47.732] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.732] - Validating connection of MultisessionFuture
[17:46:47.732] - received message: FutureResult
[17:46:47.732] - Received FutureResult
[17:46:47.733] - Erased future from FutureRegistry
[17:46:47.733] result() for ClusterFuture ...
[17:46:47.733] - result already collected: FutureResult
[17:46:47.733] result() for ClusterFuture ... done
[17:46:47.733] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.733] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.733] - Validating connection of MultisessionFuture
[17:46:47.734] - received message: FutureResult
[17:46:47.734] - Received FutureResult
[17:46:47.734] - Erased future from FutureRegistry
[17:46:47.734] result() for ClusterFuture ...
[17:46:47.734] - result already collected: FutureResult
[17:46:47.734] result() for ClusterFuture ... done
[17:46:47.734] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:47.735] resolve() on environment ...
[17:46:47.735]  recursive: 0
[17:46:47.736]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:47.736] signalConditionsASAP(numeric, pos=1) ...
[17:46:47.736] - nx: 4
[17:46:47.736] - relay: TRUE
[17:46:47.736] - stdout: TRUE
[17:46:47.736] - signal: TRUE
[17:46:47.736] - resignal: FALSE
[17:46:47.736] - force: TRUE
[17:46:47.736] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.737] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.737]  - until=2
[17:46:47.737]  - relaying element #2
[17:46:47.737] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.737] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.737] signalConditionsASAP(NULL, pos=1) ... done
[17:46:47.737]  length: 3 (resolved future 1)
[17:46:47.737] Future #2
[17:46:47.737] result() for ClusterFuture ...
[17:46:47.737] - result already collected: FutureResult
[17:46:47.737] result() for ClusterFuture ... done
[17:46:47.738] result() for ClusterFuture ...
[17:46:47.738] - result already collected: FutureResult
[17:46:47.738] result() for ClusterFuture ... done
[17:46:47.738] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:47.738] - nx: 4
[17:46:47.738] - relay: TRUE
[17:46:47.738] - stdout: TRUE
[17:46:47.738] - signal: TRUE
[17:46:47.738] - resignal: FALSE
[17:46:47.738] - force: TRUE
[17:46:47.738] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.738] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.739]  - until=2
[17:46:47.739]  - relaying element #2
[17:46:47.739] result() for ClusterFuture ...
[17:46:47.739] - result already collected: FutureResult
[17:46:47.739] result() for ClusterFuture ... done
[17:46:47.739] result() for ClusterFuture ...
[17:46:47.739] - result already collected: FutureResult
[17:46:47.739] result() for ClusterFuture ... done
[17:46:47.739] result() for ClusterFuture ...
[17:46:47.739] - result already collected: FutureResult
[17:46:47.739] result() for ClusterFuture ... done
[17:46:47.740] result() for ClusterFuture ...
[17:46:47.740] - result already collected: FutureResult
[17:46:47.740] result() for ClusterFuture ... done
[17:46:47.740] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.740] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.740] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:47.740]  length: 2 (resolved future 2)
[17:46:47.740] Future #3
[17:46:47.740] result() for ClusterFuture ...
[17:46:47.740] - result already collected: FutureResult
[17:46:47.740] result() for ClusterFuture ... done
[17:46:47.741] result() for ClusterFuture ...
[17:46:47.741] - result already collected: FutureResult
[17:46:47.741] result() for ClusterFuture ... done
[17:46:47.741] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:47.741] - nx: 4
[17:46:47.741] - relay: TRUE
[17:46:47.741] - stdout: TRUE
[17:46:47.741] - signal: TRUE
[17:46:47.741] - resignal: FALSE
[17:46:47.741] - force: TRUE
[17:46:47.741] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.741] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.742]  - until=3
[17:46:47.742]  - relaying element #3
[17:46:47.742] result() for ClusterFuture ...
[17:46:47.742] - result already collected: FutureResult
[17:46:47.742] result() for ClusterFuture ... done
[17:46:47.742] result() for ClusterFuture ...
[17:46:47.742] - result already collected: FutureResult
[17:46:47.742] result() for ClusterFuture ... done
[17:46:47.742] result() for ClusterFuture ...
[17:46:47.742] - result already collected: FutureResult
[17:46:47.742] result() for ClusterFuture ... done
[17:46:47.743] result() for ClusterFuture ...
[17:46:47.743] - result already collected: FutureResult
[17:46:47.743] result() for ClusterFuture ... done
[17:46:47.743] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.743] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.743] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:47.743]  length: 1 (resolved future 3)
[17:46:47.743] Future #4
[17:46:47.743] result() for ClusterFuture ...
[17:46:47.743] - result already collected: FutureResult
[17:46:47.743] result() for ClusterFuture ... done
[17:46:47.744] result() for ClusterFuture ...
[17:46:47.744] - result already collected: FutureResult
[17:46:47.744] result() for ClusterFuture ... done
[17:46:47.744] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:47.744] - nx: 4
[17:46:47.744] - relay: TRUE
[17:46:47.744] - stdout: TRUE
[17:46:47.744] - signal: TRUE
[17:46:47.744] - resignal: FALSE
[17:46:47.744] - force: TRUE
[17:46:47.744] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.744] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.745]  - until=4
[17:46:47.745]  - relaying element #4
[17:46:47.745] result() for ClusterFuture ...
[17:46:47.745] - result already collected: FutureResult
[17:46:47.745] result() for ClusterFuture ... done
[17:46:47.745] result() for ClusterFuture ...
[17:46:47.745] - result already collected: FutureResult
[17:46:47.745] result() for ClusterFuture ... done
[17:46:47.745] result() for ClusterFuture ...
[17:46:47.745] - result already collected: FutureResult
[17:46:47.745] result() for ClusterFuture ... done
[17:46:47.746] result() for ClusterFuture ...
[17:46:47.746] - result already collected: FutureResult
[17:46:47.746] result() for ClusterFuture ... done
[17:46:47.746] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.746] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.746] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:47.746]  length: 0 (resolved future 4)
[17:46:47.746] Relaying remaining futures
[17:46:47.746] signalConditionsASAP(NULL, pos=0) ...
[17:46:47.746] - nx: 4
[17:46:47.746] - relay: TRUE
[17:46:47.746] - stdout: TRUE
[17:46:47.747] - signal: TRUE
[17:46:47.747] - resignal: FALSE
[17:46:47.747] - force: TRUE
[17:46:47.747] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.747] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:47.747] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.747] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.747] signalConditionsASAP(NULL, pos=0) ... done
[17:46:47.747] resolve() on environment ... DONE
[17:46:47.747] result() for ClusterFuture ...
[17:46:47.747] - result already collected: FutureResult
[17:46:47.748] result() for ClusterFuture ... done
[17:46:47.748] result() for ClusterFuture ...
[17:46:47.748] - result already collected: FutureResult
[17:46:47.748] result() for ClusterFuture ... done
[17:46:47.748] result() for ClusterFuture ...
[17:46:47.748] - result already collected: FutureResult
[17:46:47.748] result() for ClusterFuture ... done
[17:46:47.748] result() for ClusterFuture ...
[17:46:47.748] - result already collected: FutureResult
[17:46:47.748] result() for ClusterFuture ... done
[17:46:47.748] result() for ClusterFuture ...
[17:46:47.749] - result already collected: FutureResult
[17:46:47.749] result() for ClusterFuture ... done
[17:46:47.749] result() for ClusterFuture ...
[17:46:47.749] - result already collected: FutureResult
[17:46:47.749] result() for ClusterFuture ... done
<environment: 0x561787899d70> 
Dimensions: c(2, 3)
[17:46:47.749] getGlobalsAndPackages() ...
[17:46:47.749] Searching for globals...
[17:46:47.750] 
[17:46:47.750] Searching for globals ... DONE
[17:46:47.750] - globals: [0] <none>
[17:46:47.750] getGlobalsAndPackages() ... DONE
[17:46:47.750] run() for ‘Future’ ...
[17:46:47.750] - state: ‘created’
[17:46:47.750] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.764]   - Field: ‘node’
[17:46:47.764]   - Field: ‘label’
[17:46:47.764]   - Field: ‘local’
[17:46:47.765]   - Field: ‘owner’
[17:46:47.765]   - Field: ‘envir’
[17:46:47.765]   - Field: ‘workers’
[17:46:47.765]   - Field: ‘packages’
[17:46:47.765]   - Field: ‘gc’
[17:46:47.765]   - Field: ‘conditions’
[17:46:47.765]   - Field: ‘persistent’
[17:46:47.765]   - Field: ‘expr’
[17:46:47.765]   - Field: ‘uuid’
[17:46:47.765]   - Field: ‘seed’
[17:46:47.765]   - Field: ‘version’
[17:46:47.766]   - Field: ‘result’
[17:46:47.766]   - Field: ‘asynchronous’
[17:46:47.766]   - Field: ‘calls’
[17:46:47.766]   - Field: ‘globals’
[17:46:47.766]   - Field: ‘stdout’
[17:46:47.766]   - Field: ‘earlySignal’
[17:46:47.766]   - Field: ‘lazy’
[17:46:47.766]   - Field: ‘state’
[17:46:47.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.766] - Launch lazy future ...
[17:46:47.767] Packages needed by the future expression (n = 0): <none>
[17:46:47.767] Packages needed by future strategies (n = 0): <none>
[17:46:47.767] {
[17:46:47.767]     {
[17:46:47.767]         {
[17:46:47.767]             ...future.startTime <- base::Sys.time()
[17:46:47.767]             {
[17:46:47.767]                 {
[17:46:47.767]                   {
[17:46:47.767]                     {
[17:46:47.767]                       base::local({
[17:46:47.767]                         has_future <- base::requireNamespace("future", 
[17:46:47.767]                           quietly = TRUE)
[17:46:47.767]                         if (has_future) {
[17:46:47.767]                           ns <- base::getNamespace("future")
[17:46:47.767]                           version <- ns[[".package"]][["version"]]
[17:46:47.767]                           if (is.null(version)) 
[17:46:47.767]                             version <- utils::packageVersion("future")
[17:46:47.767]                         }
[17:46:47.767]                         else {
[17:46:47.767]                           version <- NULL
[17:46:47.767]                         }
[17:46:47.767]                         if (!has_future || version < "1.8.0") {
[17:46:47.767]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.767]                             "", base::R.version$version.string), 
[17:46:47.767]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.767]                               "release", "version")], collapse = " "), 
[17:46:47.767]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.767]                             info)
[17:46:47.767]                           info <- base::paste(info, collapse = "; ")
[17:46:47.767]                           if (!has_future) {
[17:46:47.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.767]                               info)
[17:46:47.767]                           }
[17:46:47.767]                           else {
[17:46:47.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.767]                               info, version)
[17:46:47.767]                           }
[17:46:47.767]                           base::stop(msg)
[17:46:47.767]                         }
[17:46:47.767]                       })
[17:46:47.767]                     }
[17:46:47.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.767]                     base::options(mc.cores = 1L)
[17:46:47.767]                   }
[17:46:47.767]                   ...future.strategy.old <- future::plan("list")
[17:46:47.767]                   options(future.plan = NULL)
[17:46:47.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.767]                 }
[17:46:47.767]                 ...future.workdir <- getwd()
[17:46:47.767]             }
[17:46:47.767]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.767]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.767]         }
[17:46:47.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.767]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.767]             base::names(...future.oldOptions))
[17:46:47.767]     }
[17:46:47.767]     if (FALSE) {
[17:46:47.767]     }
[17:46:47.767]     else {
[17:46:47.767]         if (TRUE) {
[17:46:47.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.767]                 open = "w")
[17:46:47.767]         }
[17:46:47.767]         else {
[17:46:47.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.767]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.767]         }
[17:46:47.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.767]             base::sink(type = "output", split = FALSE)
[17:46:47.767]             base::close(...future.stdout)
[17:46:47.767]         }, add = TRUE)
[17:46:47.767]     }
[17:46:47.767]     ...future.frame <- base::sys.nframe()
[17:46:47.767]     ...future.conditions <- base::list()
[17:46:47.767]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.767]     if (FALSE) {
[17:46:47.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.767]     }
[17:46:47.767]     ...future.result <- base::tryCatch({
[17:46:47.767]         base::withCallingHandlers({
[17:46:47.767]             ...future.value <- base::withVisible(base::local({
[17:46:47.767]                 ...future.makeSendCondition <- base::local({
[17:46:47.767]                   sendCondition <- NULL
[17:46:47.767]                   function(frame = 1L) {
[17:46:47.767]                     if (is.function(sendCondition)) 
[17:46:47.767]                       return(sendCondition)
[17:46:47.767]                     ns <- getNamespace("parallel")
[17:46:47.767]                     if (exists("sendData", mode = "function", 
[17:46:47.767]                       envir = ns)) {
[17:46:47.767]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.767]                         envir = ns)
[17:46:47.767]                       envir <- sys.frame(frame)
[17:46:47.767]                       master <- NULL
[17:46:47.767]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.767]                         !identical(envir, emptyenv())) {
[17:46:47.767]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.767]                           inherits = FALSE)) {
[17:46:47.767]                           master <- get("master", mode = "list", 
[17:46:47.767]                             envir = envir, inherits = FALSE)
[17:46:47.767]                           if (inherits(master, c("SOCKnode", 
[17:46:47.767]                             "SOCK0node"))) {
[17:46:47.767]                             sendCondition <<- function(cond) {
[17:46:47.767]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.767]                                 success = TRUE)
[17:46:47.767]                               parallel_sendData(master, data)
[17:46:47.767]                             }
[17:46:47.767]                             return(sendCondition)
[17:46:47.767]                           }
[17:46:47.767]                         }
[17:46:47.767]                         frame <- frame + 1L
[17:46:47.767]                         envir <- sys.frame(frame)
[17:46:47.767]                       }
[17:46:47.767]                     }
[17:46:47.767]                     sendCondition <<- function(cond) NULL
[17:46:47.767]                   }
[17:46:47.767]                 })
[17:46:47.767]                 withCallingHandlers({
[17:46:47.767]                   2
[17:46:47.767]                 }, immediateCondition = function(cond) {
[17:46:47.767]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.767]                   sendCondition(cond)
[17:46:47.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.767]                   {
[17:46:47.767]                     inherits <- base::inherits
[17:46:47.767]                     invokeRestart <- base::invokeRestart
[17:46:47.767]                     is.null <- base::is.null
[17:46:47.767]                     muffled <- FALSE
[17:46:47.767]                     if (inherits(cond, "message")) {
[17:46:47.767]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.767]                       if (muffled) 
[17:46:47.767]                         invokeRestart("muffleMessage")
[17:46:47.767]                     }
[17:46:47.767]                     else if (inherits(cond, "warning")) {
[17:46:47.767]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.767]                       if (muffled) 
[17:46:47.767]                         invokeRestart("muffleWarning")
[17:46:47.767]                     }
[17:46:47.767]                     else if (inherits(cond, "condition")) {
[17:46:47.767]                       if (!is.null(pattern)) {
[17:46:47.767]                         computeRestarts <- base::computeRestarts
[17:46:47.767]                         grepl <- base::grepl
[17:46:47.767]                         restarts <- computeRestarts(cond)
[17:46:47.767]                         for (restart in restarts) {
[17:46:47.767]                           name <- restart$name
[17:46:47.767]                           if (is.null(name)) 
[17:46:47.767]                             next
[17:46:47.767]                           if (!grepl(pattern, name)) 
[17:46:47.767]                             next
[17:46:47.767]                           invokeRestart(restart)
[17:46:47.767]                           muffled <- TRUE
[17:46:47.767]                           break
[17:46:47.767]                         }
[17:46:47.767]                       }
[17:46:47.767]                     }
[17:46:47.767]                     invisible(muffled)
[17:46:47.767]                   }
[17:46:47.767]                   muffleCondition(cond)
[17:46:47.767]                 })
[17:46:47.767]             }))
[17:46:47.767]             future::FutureResult(value = ...future.value$value, 
[17:46:47.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.767]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.767]                     ...future.globalenv.names))
[17:46:47.767]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.767]         }, condition = base::local({
[17:46:47.767]             c <- base::c
[17:46:47.767]             inherits <- base::inherits
[17:46:47.767]             invokeRestart <- base::invokeRestart
[17:46:47.767]             length <- base::length
[17:46:47.767]             list <- base::list
[17:46:47.767]             seq.int <- base::seq.int
[17:46:47.767]             signalCondition <- base::signalCondition
[17:46:47.767]             sys.calls <- base::sys.calls
[17:46:47.767]             `[[` <- base::`[[`
[17:46:47.767]             `+` <- base::`+`
[17:46:47.767]             `<<-` <- base::`<<-`
[17:46:47.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.767]                   3L)]
[17:46:47.767]             }
[17:46:47.767]             function(cond) {
[17:46:47.767]                 is_error <- inherits(cond, "error")
[17:46:47.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.767]                   NULL)
[17:46:47.767]                 if (is_error) {
[17:46:47.767]                   sessionInformation <- function() {
[17:46:47.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.767]                       search = base::search(), system = base::Sys.info())
[17:46:47.767]                   }
[17:46:47.767]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.767]                     cond$call), session = sessionInformation(), 
[17:46:47.767]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.767]                   signalCondition(cond)
[17:46:47.767]                 }
[17:46:47.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.767]                 "immediateCondition"))) {
[17:46:47.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.767]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.767]                   if (TRUE && !signal) {
[17:46:47.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.767]                     {
[17:46:47.767]                       inherits <- base::inherits
[17:46:47.767]                       invokeRestart <- base::invokeRestart
[17:46:47.767]                       is.null <- base::is.null
[17:46:47.767]                       muffled <- FALSE
[17:46:47.767]                       if (inherits(cond, "message")) {
[17:46:47.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.767]                         if (muffled) 
[17:46:47.767]                           invokeRestart("muffleMessage")
[17:46:47.767]                       }
[17:46:47.767]                       else if (inherits(cond, "warning")) {
[17:46:47.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.767]                         if (muffled) 
[17:46:47.767]                           invokeRestart("muffleWarning")
[17:46:47.767]                       }
[17:46:47.767]                       else if (inherits(cond, "condition")) {
[17:46:47.767]                         if (!is.null(pattern)) {
[17:46:47.767]                           computeRestarts <- base::computeRestarts
[17:46:47.767]                           grepl <- base::grepl
[17:46:47.767]                           restarts <- computeRestarts(cond)
[17:46:47.767]                           for (restart in restarts) {
[17:46:47.767]                             name <- restart$name
[17:46:47.767]                             if (is.null(name)) 
[17:46:47.767]                               next
[17:46:47.767]                             if (!grepl(pattern, name)) 
[17:46:47.767]                               next
[17:46:47.767]                             invokeRestart(restart)
[17:46:47.767]                             muffled <- TRUE
[17:46:47.767]                             break
[17:46:47.767]                           }
[17:46:47.767]                         }
[17:46:47.767]                       }
[17:46:47.767]                       invisible(muffled)
[17:46:47.767]                     }
[17:46:47.767]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.767]                   }
[17:46:47.767]                 }
[17:46:47.767]                 else {
[17:46:47.767]                   if (TRUE) {
[17:46:47.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.767]                     {
[17:46:47.767]                       inherits <- base::inherits
[17:46:47.767]                       invokeRestart <- base::invokeRestart
[17:46:47.767]                       is.null <- base::is.null
[17:46:47.767]                       muffled <- FALSE
[17:46:47.767]                       if (inherits(cond, "message")) {
[17:46:47.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.767]                         if (muffled) 
[17:46:47.767]                           invokeRestart("muffleMessage")
[17:46:47.767]                       }
[17:46:47.767]                       else if (inherits(cond, "warning")) {
[17:46:47.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.767]                         if (muffled) 
[17:46:47.767]                           invokeRestart("muffleWarning")
[17:46:47.767]                       }
[17:46:47.767]                       else if (inherits(cond, "condition")) {
[17:46:47.767]                         if (!is.null(pattern)) {
[17:46:47.767]                           computeRestarts <- base::computeRestarts
[17:46:47.767]                           grepl <- base::grepl
[17:46:47.767]                           restarts <- computeRestarts(cond)
[17:46:47.767]                           for (restart in restarts) {
[17:46:47.767]                             name <- restart$name
[17:46:47.767]                             if (is.null(name)) 
[17:46:47.767]                               next
[17:46:47.767]                             if (!grepl(pattern, name)) 
[17:46:47.767]                               next
[17:46:47.767]                             invokeRestart(restart)
[17:46:47.767]                             muffled <- TRUE
[17:46:47.767]                             break
[17:46:47.767]                           }
[17:46:47.767]                         }
[17:46:47.767]                       }
[17:46:47.767]                       invisible(muffled)
[17:46:47.767]                     }
[17:46:47.767]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.767]                   }
[17:46:47.767]                 }
[17:46:47.767]             }
[17:46:47.767]         }))
[17:46:47.767]     }, error = function(ex) {
[17:46:47.767]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.767]                 ...future.rng), started = ...future.startTime, 
[17:46:47.767]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.767]             version = "1.8"), class = "FutureResult")
[17:46:47.767]     }, finally = {
[17:46:47.767]         if (!identical(...future.workdir, getwd())) 
[17:46:47.767]             setwd(...future.workdir)
[17:46:47.767]         {
[17:46:47.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.767]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.767]             }
[17:46:47.767]             base::options(...future.oldOptions)
[17:46:47.767]             if (.Platform$OS.type == "windows") {
[17:46:47.767]                 old_names <- names(...future.oldEnvVars)
[17:46:47.767]                 envs <- base::Sys.getenv()
[17:46:47.767]                 names <- names(envs)
[17:46:47.767]                 common <- intersect(names, old_names)
[17:46:47.767]                 added <- setdiff(names, old_names)
[17:46:47.767]                 removed <- setdiff(old_names, names)
[17:46:47.767]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.767]                   envs[common]]
[17:46:47.767]                 NAMES <- toupper(changed)
[17:46:47.767]                 args <- list()
[17:46:47.767]                 for (kk in seq_along(NAMES)) {
[17:46:47.767]                   name <- changed[[kk]]
[17:46:47.767]                   NAME <- NAMES[[kk]]
[17:46:47.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.767]                     next
[17:46:47.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.767]                 }
[17:46:47.767]                 NAMES <- toupper(added)
[17:46:47.767]                 for (kk in seq_along(NAMES)) {
[17:46:47.767]                   name <- added[[kk]]
[17:46:47.767]                   NAME <- NAMES[[kk]]
[17:46:47.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.767]                     next
[17:46:47.767]                   args[[name]] <- ""
[17:46:47.767]                 }
[17:46:47.767]                 NAMES <- toupper(removed)
[17:46:47.767]                 for (kk in seq_along(NAMES)) {
[17:46:47.767]                   name <- removed[[kk]]
[17:46:47.767]                   NAME <- NAMES[[kk]]
[17:46:47.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.767]                     next
[17:46:47.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.767]                 }
[17:46:47.767]                 if (length(args) > 0) 
[17:46:47.767]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.767]             }
[17:46:47.767]             else {
[17:46:47.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.767]             }
[17:46:47.767]             {
[17:46:47.767]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.767]                   0L) {
[17:46:47.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.767]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.767]                   base::options(opts)
[17:46:47.767]                 }
[17:46:47.767]                 {
[17:46:47.767]                   {
[17:46:47.767]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.767]                     NULL
[17:46:47.767]                   }
[17:46:47.767]                   options(future.plan = NULL)
[17:46:47.767]                   if (is.na(NA_character_)) 
[17:46:47.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.767]                     .init = FALSE)
[17:46:47.767]                 }
[17:46:47.767]             }
[17:46:47.767]         }
[17:46:47.767]     })
[17:46:47.767]     if (TRUE) {
[17:46:47.767]         base::sink(type = "output", split = FALSE)
[17:46:47.767]         if (TRUE) {
[17:46:47.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.767]         }
[17:46:47.767]         else {
[17:46:47.767]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.767]         }
[17:46:47.767]         base::close(...future.stdout)
[17:46:47.767]         ...future.stdout <- NULL
[17:46:47.767]     }
[17:46:47.767]     ...future.result$conditions <- ...future.conditions
[17:46:47.767]     ...future.result$finished <- base::Sys.time()
[17:46:47.767]     ...future.result
[17:46:47.767] }
[17:46:47.770] MultisessionFuture started
[17:46:47.770] - Launch lazy future ... done
[17:46:47.770] run() for ‘MultisessionFuture’ ... done
[17:46:47.770] getGlobalsAndPackages() ...
[17:46:47.771] Searching for globals...
[17:46:47.771] 
[17:46:47.771] Searching for globals ... DONE
[17:46:47.771] - globals: [0] <none>
[17:46:47.772] getGlobalsAndPackages() ... DONE
[17:46:47.772] run() for ‘Future’ ...
[17:46:47.772] - state: ‘created’
[17:46:47.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.786] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.786]   - Field: ‘node’
[17:46:47.786]   - Field: ‘label’
[17:46:47.786]   - Field: ‘local’
[17:46:47.786]   - Field: ‘owner’
[17:46:47.787]   - Field: ‘envir’
[17:46:47.787]   - Field: ‘workers’
[17:46:47.787]   - Field: ‘packages’
[17:46:47.787]   - Field: ‘gc’
[17:46:47.787]   - Field: ‘conditions’
[17:46:47.787]   - Field: ‘persistent’
[17:46:47.787]   - Field: ‘expr’
[17:46:47.787]   - Field: ‘uuid’
[17:46:47.787]   - Field: ‘seed’
[17:46:47.787]   - Field: ‘version’
[17:46:47.787]   - Field: ‘result’
[17:46:47.788]   - Field: ‘asynchronous’
[17:46:47.788]   - Field: ‘calls’
[17:46:47.788]   - Field: ‘globals’
[17:46:47.788]   - Field: ‘stdout’
[17:46:47.788]   - Field: ‘earlySignal’
[17:46:47.788]   - Field: ‘lazy’
[17:46:47.788]   - Field: ‘state’
[17:46:47.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.788] - Launch lazy future ...
[17:46:47.789] Packages needed by the future expression (n = 0): <none>
[17:46:47.789] Packages needed by future strategies (n = 0): <none>
[17:46:47.789] {
[17:46:47.789]     {
[17:46:47.789]         {
[17:46:47.789]             ...future.startTime <- base::Sys.time()
[17:46:47.789]             {
[17:46:47.789]                 {
[17:46:47.789]                   {
[17:46:47.789]                     {
[17:46:47.789]                       base::local({
[17:46:47.789]                         has_future <- base::requireNamespace("future", 
[17:46:47.789]                           quietly = TRUE)
[17:46:47.789]                         if (has_future) {
[17:46:47.789]                           ns <- base::getNamespace("future")
[17:46:47.789]                           version <- ns[[".package"]][["version"]]
[17:46:47.789]                           if (is.null(version)) 
[17:46:47.789]                             version <- utils::packageVersion("future")
[17:46:47.789]                         }
[17:46:47.789]                         else {
[17:46:47.789]                           version <- NULL
[17:46:47.789]                         }
[17:46:47.789]                         if (!has_future || version < "1.8.0") {
[17:46:47.789]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.789]                             "", base::R.version$version.string), 
[17:46:47.789]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.789]                               "release", "version")], collapse = " "), 
[17:46:47.789]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.789]                             info)
[17:46:47.789]                           info <- base::paste(info, collapse = "; ")
[17:46:47.789]                           if (!has_future) {
[17:46:47.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.789]                               info)
[17:46:47.789]                           }
[17:46:47.789]                           else {
[17:46:47.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.789]                               info, version)
[17:46:47.789]                           }
[17:46:47.789]                           base::stop(msg)
[17:46:47.789]                         }
[17:46:47.789]                       })
[17:46:47.789]                     }
[17:46:47.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.789]                     base::options(mc.cores = 1L)
[17:46:47.789]                   }
[17:46:47.789]                   ...future.strategy.old <- future::plan("list")
[17:46:47.789]                   options(future.plan = NULL)
[17:46:47.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.789]                 }
[17:46:47.789]                 ...future.workdir <- getwd()
[17:46:47.789]             }
[17:46:47.789]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.789]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.789]         }
[17:46:47.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.789]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.789]             base::names(...future.oldOptions))
[17:46:47.789]     }
[17:46:47.789]     if (FALSE) {
[17:46:47.789]     }
[17:46:47.789]     else {
[17:46:47.789]         if (TRUE) {
[17:46:47.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.789]                 open = "w")
[17:46:47.789]         }
[17:46:47.789]         else {
[17:46:47.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.789]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.789]         }
[17:46:47.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.789]             base::sink(type = "output", split = FALSE)
[17:46:47.789]             base::close(...future.stdout)
[17:46:47.789]         }, add = TRUE)
[17:46:47.789]     }
[17:46:47.789]     ...future.frame <- base::sys.nframe()
[17:46:47.789]     ...future.conditions <- base::list()
[17:46:47.789]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.789]     if (FALSE) {
[17:46:47.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.789]     }
[17:46:47.789]     ...future.result <- base::tryCatch({
[17:46:47.789]         base::withCallingHandlers({
[17:46:47.789]             ...future.value <- base::withVisible(base::local({
[17:46:47.789]                 ...future.makeSendCondition <- base::local({
[17:46:47.789]                   sendCondition <- NULL
[17:46:47.789]                   function(frame = 1L) {
[17:46:47.789]                     if (is.function(sendCondition)) 
[17:46:47.789]                       return(sendCondition)
[17:46:47.789]                     ns <- getNamespace("parallel")
[17:46:47.789]                     if (exists("sendData", mode = "function", 
[17:46:47.789]                       envir = ns)) {
[17:46:47.789]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.789]                         envir = ns)
[17:46:47.789]                       envir <- sys.frame(frame)
[17:46:47.789]                       master <- NULL
[17:46:47.789]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.789]                         !identical(envir, emptyenv())) {
[17:46:47.789]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.789]                           inherits = FALSE)) {
[17:46:47.789]                           master <- get("master", mode = "list", 
[17:46:47.789]                             envir = envir, inherits = FALSE)
[17:46:47.789]                           if (inherits(master, c("SOCKnode", 
[17:46:47.789]                             "SOCK0node"))) {
[17:46:47.789]                             sendCondition <<- function(cond) {
[17:46:47.789]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.789]                                 success = TRUE)
[17:46:47.789]                               parallel_sendData(master, data)
[17:46:47.789]                             }
[17:46:47.789]                             return(sendCondition)
[17:46:47.789]                           }
[17:46:47.789]                         }
[17:46:47.789]                         frame <- frame + 1L
[17:46:47.789]                         envir <- sys.frame(frame)
[17:46:47.789]                       }
[17:46:47.789]                     }
[17:46:47.789]                     sendCondition <<- function(cond) NULL
[17:46:47.789]                   }
[17:46:47.789]                 })
[17:46:47.789]                 withCallingHandlers({
[17:46:47.789]                   NULL
[17:46:47.789]                 }, immediateCondition = function(cond) {
[17:46:47.789]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.789]                   sendCondition(cond)
[17:46:47.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.789]                   {
[17:46:47.789]                     inherits <- base::inherits
[17:46:47.789]                     invokeRestart <- base::invokeRestart
[17:46:47.789]                     is.null <- base::is.null
[17:46:47.789]                     muffled <- FALSE
[17:46:47.789]                     if (inherits(cond, "message")) {
[17:46:47.789]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.789]                       if (muffled) 
[17:46:47.789]                         invokeRestart("muffleMessage")
[17:46:47.789]                     }
[17:46:47.789]                     else if (inherits(cond, "warning")) {
[17:46:47.789]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.789]                       if (muffled) 
[17:46:47.789]                         invokeRestart("muffleWarning")
[17:46:47.789]                     }
[17:46:47.789]                     else if (inherits(cond, "condition")) {
[17:46:47.789]                       if (!is.null(pattern)) {
[17:46:47.789]                         computeRestarts <- base::computeRestarts
[17:46:47.789]                         grepl <- base::grepl
[17:46:47.789]                         restarts <- computeRestarts(cond)
[17:46:47.789]                         for (restart in restarts) {
[17:46:47.789]                           name <- restart$name
[17:46:47.789]                           if (is.null(name)) 
[17:46:47.789]                             next
[17:46:47.789]                           if (!grepl(pattern, name)) 
[17:46:47.789]                             next
[17:46:47.789]                           invokeRestart(restart)
[17:46:47.789]                           muffled <- TRUE
[17:46:47.789]                           break
[17:46:47.789]                         }
[17:46:47.789]                       }
[17:46:47.789]                     }
[17:46:47.789]                     invisible(muffled)
[17:46:47.789]                   }
[17:46:47.789]                   muffleCondition(cond)
[17:46:47.789]                 })
[17:46:47.789]             }))
[17:46:47.789]             future::FutureResult(value = ...future.value$value, 
[17:46:47.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.789]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.789]                     ...future.globalenv.names))
[17:46:47.789]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.789]         }, condition = base::local({
[17:46:47.789]             c <- base::c
[17:46:47.789]             inherits <- base::inherits
[17:46:47.789]             invokeRestart <- base::invokeRestart
[17:46:47.789]             length <- base::length
[17:46:47.789]             list <- base::list
[17:46:47.789]             seq.int <- base::seq.int
[17:46:47.789]             signalCondition <- base::signalCondition
[17:46:47.789]             sys.calls <- base::sys.calls
[17:46:47.789]             `[[` <- base::`[[`
[17:46:47.789]             `+` <- base::`+`
[17:46:47.789]             `<<-` <- base::`<<-`
[17:46:47.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.789]                   3L)]
[17:46:47.789]             }
[17:46:47.789]             function(cond) {
[17:46:47.789]                 is_error <- inherits(cond, "error")
[17:46:47.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.789]                   NULL)
[17:46:47.789]                 if (is_error) {
[17:46:47.789]                   sessionInformation <- function() {
[17:46:47.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.789]                       search = base::search(), system = base::Sys.info())
[17:46:47.789]                   }
[17:46:47.789]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.789]                     cond$call), session = sessionInformation(), 
[17:46:47.789]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.789]                   signalCondition(cond)
[17:46:47.789]                 }
[17:46:47.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.789]                 "immediateCondition"))) {
[17:46:47.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.789]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.789]                   if (TRUE && !signal) {
[17:46:47.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.789]                     {
[17:46:47.789]                       inherits <- base::inherits
[17:46:47.789]                       invokeRestart <- base::invokeRestart
[17:46:47.789]                       is.null <- base::is.null
[17:46:47.789]                       muffled <- FALSE
[17:46:47.789]                       if (inherits(cond, "message")) {
[17:46:47.789]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.789]                         if (muffled) 
[17:46:47.789]                           invokeRestart("muffleMessage")
[17:46:47.789]                       }
[17:46:47.789]                       else if (inherits(cond, "warning")) {
[17:46:47.789]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.789]                         if (muffled) 
[17:46:47.789]                           invokeRestart("muffleWarning")
[17:46:47.789]                       }
[17:46:47.789]                       else if (inherits(cond, "condition")) {
[17:46:47.789]                         if (!is.null(pattern)) {
[17:46:47.789]                           computeRestarts <- base::computeRestarts
[17:46:47.789]                           grepl <- base::grepl
[17:46:47.789]                           restarts <- computeRestarts(cond)
[17:46:47.789]                           for (restart in restarts) {
[17:46:47.789]                             name <- restart$name
[17:46:47.789]                             if (is.null(name)) 
[17:46:47.789]                               next
[17:46:47.789]                             if (!grepl(pattern, name)) 
[17:46:47.789]                               next
[17:46:47.789]                             invokeRestart(restart)
[17:46:47.789]                             muffled <- TRUE
[17:46:47.789]                             break
[17:46:47.789]                           }
[17:46:47.789]                         }
[17:46:47.789]                       }
[17:46:47.789]                       invisible(muffled)
[17:46:47.789]                     }
[17:46:47.789]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.789]                   }
[17:46:47.789]                 }
[17:46:47.789]                 else {
[17:46:47.789]                   if (TRUE) {
[17:46:47.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.789]                     {
[17:46:47.789]                       inherits <- base::inherits
[17:46:47.789]                       invokeRestart <- base::invokeRestart
[17:46:47.789]                       is.null <- base::is.null
[17:46:47.789]                       muffled <- FALSE
[17:46:47.789]                       if (inherits(cond, "message")) {
[17:46:47.789]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.789]                         if (muffled) 
[17:46:47.789]                           invokeRestart("muffleMessage")
[17:46:47.789]                       }
[17:46:47.789]                       else if (inherits(cond, "warning")) {
[17:46:47.789]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.789]                         if (muffled) 
[17:46:47.789]                           invokeRestart("muffleWarning")
[17:46:47.789]                       }
[17:46:47.789]                       else if (inherits(cond, "condition")) {
[17:46:47.789]                         if (!is.null(pattern)) {
[17:46:47.789]                           computeRestarts <- base::computeRestarts
[17:46:47.789]                           grepl <- base::grepl
[17:46:47.789]                           restarts <- computeRestarts(cond)
[17:46:47.789]                           for (restart in restarts) {
[17:46:47.789]                             name <- restart$name
[17:46:47.789]                             if (is.null(name)) 
[17:46:47.789]                               next
[17:46:47.789]                             if (!grepl(pattern, name)) 
[17:46:47.789]                               next
[17:46:47.789]                             invokeRestart(restart)
[17:46:47.789]                             muffled <- TRUE
[17:46:47.789]                             break
[17:46:47.789]                           }
[17:46:47.789]                         }
[17:46:47.789]                       }
[17:46:47.789]                       invisible(muffled)
[17:46:47.789]                     }
[17:46:47.789]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.789]                   }
[17:46:47.789]                 }
[17:46:47.789]             }
[17:46:47.789]         }))
[17:46:47.789]     }, error = function(ex) {
[17:46:47.789]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.789]                 ...future.rng), started = ...future.startTime, 
[17:46:47.789]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.789]             version = "1.8"), class = "FutureResult")
[17:46:47.789]     }, finally = {
[17:46:47.789]         if (!identical(...future.workdir, getwd())) 
[17:46:47.789]             setwd(...future.workdir)
[17:46:47.789]         {
[17:46:47.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.789]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.789]             }
[17:46:47.789]             base::options(...future.oldOptions)
[17:46:47.789]             if (.Platform$OS.type == "windows") {
[17:46:47.789]                 old_names <- names(...future.oldEnvVars)
[17:46:47.789]                 envs <- base::Sys.getenv()
[17:46:47.789]                 names <- names(envs)
[17:46:47.789]                 common <- intersect(names, old_names)
[17:46:47.789]                 added <- setdiff(names, old_names)
[17:46:47.789]                 removed <- setdiff(old_names, names)
[17:46:47.789]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.789]                   envs[common]]
[17:46:47.789]                 NAMES <- toupper(changed)
[17:46:47.789]                 args <- list()
[17:46:47.789]                 for (kk in seq_along(NAMES)) {
[17:46:47.789]                   name <- changed[[kk]]
[17:46:47.789]                   NAME <- NAMES[[kk]]
[17:46:47.789]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.789]                     next
[17:46:47.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.789]                 }
[17:46:47.789]                 NAMES <- toupper(added)
[17:46:47.789]                 for (kk in seq_along(NAMES)) {
[17:46:47.789]                   name <- added[[kk]]
[17:46:47.789]                   NAME <- NAMES[[kk]]
[17:46:47.789]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.789]                     next
[17:46:47.789]                   args[[name]] <- ""
[17:46:47.789]                 }
[17:46:47.789]                 NAMES <- toupper(removed)
[17:46:47.789]                 for (kk in seq_along(NAMES)) {
[17:46:47.789]                   name <- removed[[kk]]
[17:46:47.789]                   NAME <- NAMES[[kk]]
[17:46:47.789]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.789]                     next
[17:46:47.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.789]                 }
[17:46:47.789]                 if (length(args) > 0) 
[17:46:47.789]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.789]             }
[17:46:47.789]             else {
[17:46:47.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.789]             }
[17:46:47.789]             {
[17:46:47.789]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.789]                   0L) {
[17:46:47.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.789]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.789]                   base::options(opts)
[17:46:47.789]                 }
[17:46:47.789]                 {
[17:46:47.789]                   {
[17:46:47.789]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.789]                     NULL
[17:46:47.789]                   }
[17:46:47.789]                   options(future.plan = NULL)
[17:46:47.789]                   if (is.na(NA_character_)) 
[17:46:47.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.789]                     .init = FALSE)
[17:46:47.789]                 }
[17:46:47.789]             }
[17:46:47.789]         }
[17:46:47.789]     })
[17:46:47.789]     if (TRUE) {
[17:46:47.789]         base::sink(type = "output", split = FALSE)
[17:46:47.789]         if (TRUE) {
[17:46:47.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.789]         }
[17:46:47.789]         else {
[17:46:47.789]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.789]         }
[17:46:47.789]         base::close(...future.stdout)
[17:46:47.789]         ...future.stdout <- NULL
[17:46:47.789]     }
[17:46:47.789]     ...future.result$conditions <- ...future.conditions
[17:46:47.789]     ...future.result$finished <- base::Sys.time()
[17:46:47.789]     ...future.result
[17:46:47.789] }
[17:46:47.792] MultisessionFuture started
[17:46:47.792] - Launch lazy future ... done
[17:46:47.792] run() for ‘MultisessionFuture’ ... done
[17:46:47.793] getGlobalsAndPackages() ...
[17:46:47.793] Searching for globals...
[17:46:47.794] - globals found: [1] ‘{’
[17:46:47.794] Searching for globals ... DONE
[17:46:47.794] Resolving globals: FALSE
[17:46:47.794] 
[17:46:47.795] 
[17:46:47.795] getGlobalsAndPackages() ... DONE
[17:46:47.795] run() for ‘Future’ ...
[17:46:47.795] - state: ‘created’
[17:46:47.795] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.809] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.809] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.809]   - Field: ‘node’
[17:46:47.809]   - Field: ‘label’
[17:46:47.810]   - Field: ‘local’
[17:46:47.810]   - Field: ‘owner’
[17:46:47.810]   - Field: ‘envir’
[17:46:47.810]   - Field: ‘workers’
[17:46:47.810]   - Field: ‘packages’
[17:46:47.810]   - Field: ‘gc’
[17:46:47.810]   - Field: ‘conditions’
[17:46:47.810]   - Field: ‘persistent’
[17:46:47.810]   - Field: ‘expr’
[17:46:47.810]   - Field: ‘uuid’
[17:46:47.810]   - Field: ‘seed’
[17:46:47.811]   - Field: ‘version’
[17:46:47.811]   - Field: ‘result’
[17:46:47.811]   - Field: ‘asynchronous’
[17:46:47.811]   - Field: ‘calls’
[17:46:47.811]   - Field: ‘globals’
[17:46:47.811]   - Field: ‘stdout’
[17:46:47.811]   - Field: ‘earlySignal’
[17:46:47.811]   - Field: ‘lazy’
[17:46:47.811]   - Field: ‘state’
[17:46:47.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.811] - Launch lazy future ...
[17:46:47.812] Packages needed by the future expression (n = 0): <none>
[17:46:47.812] Packages needed by future strategies (n = 0): <none>
[17:46:47.812] {
[17:46:47.812]     {
[17:46:47.812]         {
[17:46:47.812]             ...future.startTime <- base::Sys.time()
[17:46:47.812]             {
[17:46:47.812]                 {
[17:46:47.812]                   {
[17:46:47.812]                     {
[17:46:47.812]                       base::local({
[17:46:47.812]                         has_future <- base::requireNamespace("future", 
[17:46:47.812]                           quietly = TRUE)
[17:46:47.812]                         if (has_future) {
[17:46:47.812]                           ns <- base::getNamespace("future")
[17:46:47.812]                           version <- ns[[".package"]][["version"]]
[17:46:47.812]                           if (is.null(version)) 
[17:46:47.812]                             version <- utils::packageVersion("future")
[17:46:47.812]                         }
[17:46:47.812]                         else {
[17:46:47.812]                           version <- NULL
[17:46:47.812]                         }
[17:46:47.812]                         if (!has_future || version < "1.8.0") {
[17:46:47.812]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.812]                             "", base::R.version$version.string), 
[17:46:47.812]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.812]                               "release", "version")], collapse = " "), 
[17:46:47.812]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.812]                             info)
[17:46:47.812]                           info <- base::paste(info, collapse = "; ")
[17:46:47.812]                           if (!has_future) {
[17:46:47.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.812]                               info)
[17:46:47.812]                           }
[17:46:47.812]                           else {
[17:46:47.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.812]                               info, version)
[17:46:47.812]                           }
[17:46:47.812]                           base::stop(msg)
[17:46:47.812]                         }
[17:46:47.812]                       })
[17:46:47.812]                     }
[17:46:47.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.812]                     base::options(mc.cores = 1L)
[17:46:47.812]                   }
[17:46:47.812]                   ...future.strategy.old <- future::plan("list")
[17:46:47.812]                   options(future.plan = NULL)
[17:46:47.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.812]                 }
[17:46:47.812]                 ...future.workdir <- getwd()
[17:46:47.812]             }
[17:46:47.812]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.812]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.812]         }
[17:46:47.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.812]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.812]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.812]             base::names(...future.oldOptions))
[17:46:47.812]     }
[17:46:47.812]     if (FALSE) {
[17:46:47.812]     }
[17:46:47.812]     else {
[17:46:47.812]         if (TRUE) {
[17:46:47.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.812]                 open = "w")
[17:46:47.812]         }
[17:46:47.812]         else {
[17:46:47.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.812]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.812]         }
[17:46:47.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.812]             base::sink(type = "output", split = FALSE)
[17:46:47.812]             base::close(...future.stdout)
[17:46:47.812]         }, add = TRUE)
[17:46:47.812]     }
[17:46:47.812]     ...future.frame <- base::sys.nframe()
[17:46:47.812]     ...future.conditions <- base::list()
[17:46:47.812]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.812]     if (FALSE) {
[17:46:47.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.812]     }
[17:46:47.812]     ...future.result <- base::tryCatch({
[17:46:47.812]         base::withCallingHandlers({
[17:46:47.812]             ...future.value <- base::withVisible(base::local({
[17:46:47.812]                 ...future.makeSendCondition <- base::local({
[17:46:47.812]                   sendCondition <- NULL
[17:46:47.812]                   function(frame = 1L) {
[17:46:47.812]                     if (is.function(sendCondition)) 
[17:46:47.812]                       return(sendCondition)
[17:46:47.812]                     ns <- getNamespace("parallel")
[17:46:47.812]                     if (exists("sendData", mode = "function", 
[17:46:47.812]                       envir = ns)) {
[17:46:47.812]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.812]                         envir = ns)
[17:46:47.812]                       envir <- sys.frame(frame)
[17:46:47.812]                       master <- NULL
[17:46:47.812]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.812]                         !identical(envir, emptyenv())) {
[17:46:47.812]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.812]                           inherits = FALSE)) {
[17:46:47.812]                           master <- get("master", mode = "list", 
[17:46:47.812]                             envir = envir, inherits = FALSE)
[17:46:47.812]                           if (inherits(master, c("SOCKnode", 
[17:46:47.812]                             "SOCK0node"))) {
[17:46:47.812]                             sendCondition <<- function(cond) {
[17:46:47.812]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.812]                                 success = TRUE)
[17:46:47.812]                               parallel_sendData(master, data)
[17:46:47.812]                             }
[17:46:47.812]                             return(sendCondition)
[17:46:47.812]                           }
[17:46:47.812]                         }
[17:46:47.812]                         frame <- frame + 1L
[17:46:47.812]                         envir <- sys.frame(frame)
[17:46:47.812]                       }
[17:46:47.812]                     }
[17:46:47.812]                     sendCondition <<- function(cond) NULL
[17:46:47.812]                   }
[17:46:47.812]                 })
[17:46:47.812]                 withCallingHandlers({
[17:46:47.812]                   {
[17:46:47.812]                     4
[17:46:47.812]                   }
[17:46:47.812]                 }, immediateCondition = function(cond) {
[17:46:47.812]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.812]                   sendCondition(cond)
[17:46:47.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.812]                   {
[17:46:47.812]                     inherits <- base::inherits
[17:46:47.812]                     invokeRestart <- base::invokeRestart
[17:46:47.812]                     is.null <- base::is.null
[17:46:47.812]                     muffled <- FALSE
[17:46:47.812]                     if (inherits(cond, "message")) {
[17:46:47.812]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.812]                       if (muffled) 
[17:46:47.812]                         invokeRestart("muffleMessage")
[17:46:47.812]                     }
[17:46:47.812]                     else if (inherits(cond, "warning")) {
[17:46:47.812]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.812]                       if (muffled) 
[17:46:47.812]                         invokeRestart("muffleWarning")
[17:46:47.812]                     }
[17:46:47.812]                     else if (inherits(cond, "condition")) {
[17:46:47.812]                       if (!is.null(pattern)) {
[17:46:47.812]                         computeRestarts <- base::computeRestarts
[17:46:47.812]                         grepl <- base::grepl
[17:46:47.812]                         restarts <- computeRestarts(cond)
[17:46:47.812]                         for (restart in restarts) {
[17:46:47.812]                           name <- restart$name
[17:46:47.812]                           if (is.null(name)) 
[17:46:47.812]                             next
[17:46:47.812]                           if (!grepl(pattern, name)) 
[17:46:47.812]                             next
[17:46:47.812]                           invokeRestart(restart)
[17:46:47.812]                           muffled <- TRUE
[17:46:47.812]                           break
[17:46:47.812]                         }
[17:46:47.812]                       }
[17:46:47.812]                     }
[17:46:47.812]                     invisible(muffled)
[17:46:47.812]                   }
[17:46:47.812]                   muffleCondition(cond)
[17:46:47.812]                 })
[17:46:47.812]             }))
[17:46:47.812]             future::FutureResult(value = ...future.value$value, 
[17:46:47.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.812]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.812]                     ...future.globalenv.names))
[17:46:47.812]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.812]         }, condition = base::local({
[17:46:47.812]             c <- base::c
[17:46:47.812]             inherits <- base::inherits
[17:46:47.812]             invokeRestart <- base::invokeRestart
[17:46:47.812]             length <- base::length
[17:46:47.812]             list <- base::list
[17:46:47.812]             seq.int <- base::seq.int
[17:46:47.812]             signalCondition <- base::signalCondition
[17:46:47.812]             sys.calls <- base::sys.calls
[17:46:47.812]             `[[` <- base::`[[`
[17:46:47.812]             `+` <- base::`+`
[17:46:47.812]             `<<-` <- base::`<<-`
[17:46:47.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.812]                   3L)]
[17:46:47.812]             }
[17:46:47.812]             function(cond) {
[17:46:47.812]                 is_error <- inherits(cond, "error")
[17:46:47.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.812]                   NULL)
[17:46:47.812]                 if (is_error) {
[17:46:47.812]                   sessionInformation <- function() {
[17:46:47.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.812]                       search = base::search(), system = base::Sys.info())
[17:46:47.812]                   }
[17:46:47.812]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.812]                     cond$call), session = sessionInformation(), 
[17:46:47.812]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.812]                   signalCondition(cond)
[17:46:47.812]                 }
[17:46:47.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.812]                 "immediateCondition"))) {
[17:46:47.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.812]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.812]                   if (TRUE && !signal) {
[17:46:47.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.812]                     {
[17:46:47.812]                       inherits <- base::inherits
[17:46:47.812]                       invokeRestart <- base::invokeRestart
[17:46:47.812]                       is.null <- base::is.null
[17:46:47.812]                       muffled <- FALSE
[17:46:47.812]                       if (inherits(cond, "message")) {
[17:46:47.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.812]                         if (muffled) 
[17:46:47.812]                           invokeRestart("muffleMessage")
[17:46:47.812]                       }
[17:46:47.812]                       else if (inherits(cond, "warning")) {
[17:46:47.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.812]                         if (muffled) 
[17:46:47.812]                           invokeRestart("muffleWarning")
[17:46:47.812]                       }
[17:46:47.812]                       else if (inherits(cond, "condition")) {
[17:46:47.812]                         if (!is.null(pattern)) {
[17:46:47.812]                           computeRestarts <- base::computeRestarts
[17:46:47.812]                           grepl <- base::grepl
[17:46:47.812]                           restarts <- computeRestarts(cond)
[17:46:47.812]                           for (restart in restarts) {
[17:46:47.812]                             name <- restart$name
[17:46:47.812]                             if (is.null(name)) 
[17:46:47.812]                               next
[17:46:47.812]                             if (!grepl(pattern, name)) 
[17:46:47.812]                               next
[17:46:47.812]                             invokeRestart(restart)
[17:46:47.812]                             muffled <- TRUE
[17:46:47.812]                             break
[17:46:47.812]                           }
[17:46:47.812]                         }
[17:46:47.812]                       }
[17:46:47.812]                       invisible(muffled)
[17:46:47.812]                     }
[17:46:47.812]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.812]                   }
[17:46:47.812]                 }
[17:46:47.812]                 else {
[17:46:47.812]                   if (TRUE) {
[17:46:47.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.812]                     {
[17:46:47.812]                       inherits <- base::inherits
[17:46:47.812]                       invokeRestart <- base::invokeRestart
[17:46:47.812]                       is.null <- base::is.null
[17:46:47.812]                       muffled <- FALSE
[17:46:47.812]                       if (inherits(cond, "message")) {
[17:46:47.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.812]                         if (muffled) 
[17:46:47.812]                           invokeRestart("muffleMessage")
[17:46:47.812]                       }
[17:46:47.812]                       else if (inherits(cond, "warning")) {
[17:46:47.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.812]                         if (muffled) 
[17:46:47.812]                           invokeRestart("muffleWarning")
[17:46:47.812]                       }
[17:46:47.812]                       else if (inherits(cond, "condition")) {
[17:46:47.812]                         if (!is.null(pattern)) {
[17:46:47.812]                           computeRestarts <- base::computeRestarts
[17:46:47.812]                           grepl <- base::grepl
[17:46:47.812]                           restarts <- computeRestarts(cond)
[17:46:47.812]                           for (restart in restarts) {
[17:46:47.812]                             name <- restart$name
[17:46:47.812]                             if (is.null(name)) 
[17:46:47.812]                               next
[17:46:47.812]                             if (!grepl(pattern, name)) 
[17:46:47.812]                               next
[17:46:47.812]                             invokeRestart(restart)
[17:46:47.812]                             muffled <- TRUE
[17:46:47.812]                             break
[17:46:47.812]                           }
[17:46:47.812]                         }
[17:46:47.812]                       }
[17:46:47.812]                       invisible(muffled)
[17:46:47.812]                     }
[17:46:47.812]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.812]                   }
[17:46:47.812]                 }
[17:46:47.812]             }
[17:46:47.812]         }))
[17:46:47.812]     }, error = function(ex) {
[17:46:47.812]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.812]                 ...future.rng), started = ...future.startTime, 
[17:46:47.812]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.812]             version = "1.8"), class = "FutureResult")
[17:46:47.812]     }, finally = {
[17:46:47.812]         if (!identical(...future.workdir, getwd())) 
[17:46:47.812]             setwd(...future.workdir)
[17:46:47.812]         {
[17:46:47.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.812]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.812]             }
[17:46:47.812]             base::options(...future.oldOptions)
[17:46:47.812]             if (.Platform$OS.type == "windows") {
[17:46:47.812]                 old_names <- names(...future.oldEnvVars)
[17:46:47.812]                 envs <- base::Sys.getenv()
[17:46:47.812]                 names <- names(envs)
[17:46:47.812]                 common <- intersect(names, old_names)
[17:46:47.812]                 added <- setdiff(names, old_names)
[17:46:47.812]                 removed <- setdiff(old_names, names)
[17:46:47.812]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.812]                   envs[common]]
[17:46:47.812]                 NAMES <- toupper(changed)
[17:46:47.812]                 args <- list()
[17:46:47.812]                 for (kk in seq_along(NAMES)) {
[17:46:47.812]                   name <- changed[[kk]]
[17:46:47.812]                   NAME <- NAMES[[kk]]
[17:46:47.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.812]                     next
[17:46:47.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.812]                 }
[17:46:47.812]                 NAMES <- toupper(added)
[17:46:47.812]                 for (kk in seq_along(NAMES)) {
[17:46:47.812]                   name <- added[[kk]]
[17:46:47.812]                   NAME <- NAMES[[kk]]
[17:46:47.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.812]                     next
[17:46:47.812]                   args[[name]] <- ""
[17:46:47.812]                 }
[17:46:47.812]                 NAMES <- toupper(removed)
[17:46:47.812]                 for (kk in seq_along(NAMES)) {
[17:46:47.812]                   name <- removed[[kk]]
[17:46:47.812]                   NAME <- NAMES[[kk]]
[17:46:47.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.812]                     next
[17:46:47.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.812]                 }
[17:46:47.812]                 if (length(args) > 0) 
[17:46:47.812]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.812]             }
[17:46:47.812]             else {
[17:46:47.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.812]             }
[17:46:47.812]             {
[17:46:47.812]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.812]                   0L) {
[17:46:47.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.812]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.812]                   base::options(opts)
[17:46:47.812]                 }
[17:46:47.812]                 {
[17:46:47.812]                   {
[17:46:47.812]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.812]                     NULL
[17:46:47.812]                   }
[17:46:47.812]                   options(future.plan = NULL)
[17:46:47.812]                   if (is.na(NA_character_)) 
[17:46:47.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.812]                     .init = FALSE)
[17:46:47.812]                 }
[17:46:47.812]             }
[17:46:47.812]         }
[17:46:47.812]     })
[17:46:47.812]     if (TRUE) {
[17:46:47.812]         base::sink(type = "output", split = FALSE)
[17:46:47.812]         if (TRUE) {
[17:46:47.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.812]         }
[17:46:47.812]         else {
[17:46:47.812]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.812]         }
[17:46:47.812]         base::close(...future.stdout)
[17:46:47.812]         ...future.stdout <- NULL
[17:46:47.812]     }
[17:46:47.812]     ...future.result$conditions <- ...future.conditions
[17:46:47.812]     ...future.result$finished <- base::Sys.time()
[17:46:47.812]     ...future.result
[17:46:47.812] }
[17:46:47.814] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:47.825] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.825] - Validating connection of MultisessionFuture
[17:46:47.825] - received message: FutureResult
[17:46:47.825] - Received FutureResult
[17:46:47.825] - Erased future from FutureRegistry
[17:46:47.826] result() for ClusterFuture ...
[17:46:47.826] - result already collected: FutureResult
[17:46:47.826] result() for ClusterFuture ... done
[17:46:47.826] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.826] result() for ClusterFuture ...
[17:46:47.826] - result already collected: FutureResult
[17:46:47.826] result() for ClusterFuture ... done
[17:46:47.826] result() for ClusterFuture ...
[17:46:47.826] - result already collected: FutureResult
[17:46:47.826] result() for ClusterFuture ... done
[17:46:47.827] MultisessionFuture started
[17:46:47.827] - Launch lazy future ... done
[17:46:47.827] run() for ‘MultisessionFuture’ ... done
<environment: 0x561788a7def8> 
<environment: 0x561789897328> 
[17:46:47.829] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.829] - Validating connection of MultisessionFuture
[17:46:47.829] - received message: FutureResult
[17:46:47.829] - Received FutureResult
[17:46:47.830] - Erased future from FutureRegistry
[17:46:47.830] result() for ClusterFuture ...
[17:46:47.830] - result already collected: FutureResult
[17:46:47.830] result() for ClusterFuture ... done
[17:46:47.830] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.830] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.830] - Validating connection of MultisessionFuture
[17:46:47.831] - received message: FutureResult
[17:46:47.831] - Received FutureResult
[17:46:47.831] - Erased future from FutureRegistry
[17:46:47.831] result() for ClusterFuture ...
[17:46:47.831] - result already collected: FutureResult
[17:46:47.831] result() for ClusterFuture ... done
[17:46:47.831] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:47.832] resolve() on environment ...
[17:46:47.832]  recursive: 0
[17:46:47.833]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:47.833] signalConditionsASAP(numeric, pos=1) ...
[17:46:47.833] - nx: 4
[17:46:47.833] - relay: TRUE
[17:46:47.833] - stdout: TRUE
[17:46:47.833] - signal: TRUE
[17:46:47.833] - resignal: FALSE
[17:46:47.833] - force: TRUE
[17:46:47.834] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.834] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.834]  - until=2
[17:46:47.834]  - relaying element #2
[17:46:47.834] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.834] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.834] signalConditionsASAP(NULL, pos=1) ... done
[17:46:47.834]  length: 3 (resolved future 1)
[17:46:47.834] Future #2
[17:46:47.834] result() for ClusterFuture ...
[17:46:47.834] - result already collected: FutureResult
[17:46:47.834] result() for ClusterFuture ... done
[17:46:47.835] result() for ClusterFuture ...
[17:46:47.835] - result already collected: FutureResult
[17:46:47.835] result() for ClusterFuture ... done
[17:46:47.835] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:47.835] - nx: 4
[17:46:47.835] - relay: TRUE
[17:46:47.835] - stdout: TRUE
[17:46:47.835] - signal: TRUE
[17:46:47.835] - resignal: FALSE
[17:46:47.835] - force: TRUE
[17:46:47.835] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.836] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.836]  - until=2
[17:46:47.836]  - relaying element #2
[17:46:47.836] result() for ClusterFuture ...
[17:46:47.836] - result already collected: FutureResult
[17:46:47.836] result() for ClusterFuture ... done
[17:46:47.836] result() for ClusterFuture ...
[17:46:47.836] - result already collected: FutureResult
[17:46:47.836] result() for ClusterFuture ... done
[17:46:47.836] result() for ClusterFuture ...
[17:46:47.836] - result already collected: FutureResult
[17:46:47.837] result() for ClusterFuture ... done
[17:46:47.837] result() for ClusterFuture ...
[17:46:47.837] - result already collected: FutureResult
[17:46:47.837] result() for ClusterFuture ... done
[17:46:47.837] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.837] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.837] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:47.837]  length: 2 (resolved future 2)
[17:46:47.837] Future #3
[17:46:47.837] result() for ClusterFuture ...
[17:46:47.837] - result already collected: FutureResult
[17:46:47.838] result() for ClusterFuture ... done
[17:46:47.838] result() for ClusterFuture ...
[17:46:47.838] - result already collected: FutureResult
[17:46:47.838] result() for ClusterFuture ... done
[17:46:47.838] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:47.838] - nx: 4
[17:46:47.838] - relay: TRUE
[17:46:47.840] - stdout: TRUE
[17:46:47.841] - signal: TRUE
[17:46:47.841] - resignal: FALSE
[17:46:47.841] - force: TRUE
[17:46:47.841] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.841] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.841]  - until=3
[17:46:47.841]  - relaying element #3
[17:46:47.841] result() for ClusterFuture ...
[17:46:47.841] - result already collected: FutureResult
[17:46:47.842] result() for ClusterFuture ... done
[17:46:47.842] result() for ClusterFuture ...
[17:46:47.842] - result already collected: FutureResult
[17:46:47.842] result() for ClusterFuture ... done
[17:46:47.842] result() for ClusterFuture ...
[17:46:47.842] - result already collected: FutureResult
[17:46:47.842] result() for ClusterFuture ... done
[17:46:47.842] result() for ClusterFuture ...
[17:46:47.842] - result already collected: FutureResult
[17:46:47.842] result() for ClusterFuture ... done
[17:46:47.842] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.842] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.843] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:47.843]  length: 1 (resolved future 3)
[17:46:47.843] Future #4
[17:46:47.843] result() for ClusterFuture ...
[17:46:47.843] - result already collected: FutureResult
[17:46:47.843] result() for ClusterFuture ... done
[17:46:47.843] result() for ClusterFuture ...
[17:46:47.843] - result already collected: FutureResult
[17:46:47.843] result() for ClusterFuture ... done
[17:46:47.843] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:47.843] - nx: 4
[17:46:47.844] - relay: TRUE
[17:46:47.844] - stdout: TRUE
[17:46:47.844] - signal: TRUE
[17:46:47.844] - resignal: FALSE
[17:46:47.844] - force: TRUE
[17:46:47.844] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.844] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.844]  - until=4
[17:46:47.844]  - relaying element #4
[17:46:47.844] result() for ClusterFuture ...
[17:46:47.844] - result already collected: FutureResult
[17:46:47.844] result() for ClusterFuture ... done
[17:46:47.845] result() for ClusterFuture ...
[17:46:47.845] - result already collected: FutureResult
[17:46:47.845] result() for ClusterFuture ... done
[17:46:47.845] result() for ClusterFuture ...
[17:46:47.845] - result already collected: FutureResult
[17:46:47.845] result() for ClusterFuture ... done
[17:46:47.845] result() for ClusterFuture ...
[17:46:47.845] - result already collected: FutureResult
[17:46:47.845] result() for ClusterFuture ... done
[17:46:47.845] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.845] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.845] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:47.846]  length: 0 (resolved future 4)
[17:46:47.846] Relaying remaining futures
[17:46:47.846] signalConditionsASAP(NULL, pos=0) ...
[17:46:47.846] - nx: 4
[17:46:47.846] - relay: TRUE
[17:46:47.846] - stdout: TRUE
[17:46:47.846] - signal: TRUE
[17:46:47.846] - resignal: FALSE
[17:46:47.846] - force: TRUE
[17:46:47.846] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.846] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:47.847] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.847] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.847] signalConditionsASAP(NULL, pos=0) ... done
[17:46:47.847] resolve() on environment ... DONE
[17:46:47.847] result() for ClusterFuture ...
[17:46:47.847] - result already collected: FutureResult
[17:46:47.847] result() for ClusterFuture ... done
[17:46:47.847] result() for ClusterFuture ...
[17:46:47.847] - result already collected: FutureResult
[17:46:47.847] result() for ClusterFuture ... done
[17:46:47.847] result() for ClusterFuture ...
[17:46:47.847] - result already collected: FutureResult
[17:46:47.848] result() for ClusterFuture ... done
[17:46:47.848] result() for ClusterFuture ...
[17:46:47.848] - result already collected: FutureResult
[17:46:47.848] result() for ClusterFuture ... done
[17:46:47.848] result() for ClusterFuture ...
[17:46:47.848] - result already collected: FutureResult
[17:46:47.848] result() for ClusterFuture ... done
[17:46:47.848] result() for ClusterFuture ...
[17:46:47.848] - result already collected: FutureResult
[17:46:47.848] result() for ClusterFuture ... done
<environment: 0x561789a44c20> 
Dimensions: c(2, 3, 1)
[17:46:47.849] getGlobalsAndPackages() ...
[17:46:47.849] Searching for globals...
[17:46:47.849] 
[17:46:47.849] Searching for globals ... DONE
[17:46:47.849] - globals: [0] <none>
[17:46:47.849] getGlobalsAndPackages() ... DONE
[17:46:47.850] run() for ‘Future’ ...
[17:46:47.850] - state: ‘created’
[17:46:47.850] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.863] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.864]   - Field: ‘node’
[17:46:47.864]   - Field: ‘label’
[17:46:47.864]   - Field: ‘local’
[17:46:47.864]   - Field: ‘owner’
[17:46:47.864]   - Field: ‘envir’
[17:46:47.864]   - Field: ‘workers’
[17:46:47.864]   - Field: ‘packages’
[17:46:47.864]   - Field: ‘gc’
[17:46:47.864]   - Field: ‘conditions’
[17:46:47.864]   - Field: ‘persistent’
[17:46:47.865]   - Field: ‘expr’
[17:46:47.865]   - Field: ‘uuid’
[17:46:47.865]   - Field: ‘seed’
[17:46:47.865]   - Field: ‘version’
[17:46:47.865]   - Field: ‘result’
[17:46:47.865]   - Field: ‘asynchronous’
[17:46:47.865]   - Field: ‘calls’
[17:46:47.865]   - Field: ‘globals’
[17:46:47.865]   - Field: ‘stdout’
[17:46:47.865]   - Field: ‘earlySignal’
[17:46:47.865]   - Field: ‘lazy’
[17:46:47.866]   - Field: ‘state’
[17:46:47.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.866] - Launch lazy future ...
[17:46:47.866] Packages needed by the future expression (n = 0): <none>
[17:46:47.866] Packages needed by future strategies (n = 0): <none>
[17:46:47.866] {
[17:46:47.866]     {
[17:46:47.866]         {
[17:46:47.866]             ...future.startTime <- base::Sys.time()
[17:46:47.866]             {
[17:46:47.866]                 {
[17:46:47.866]                   {
[17:46:47.866]                     {
[17:46:47.866]                       base::local({
[17:46:47.866]                         has_future <- base::requireNamespace("future", 
[17:46:47.866]                           quietly = TRUE)
[17:46:47.866]                         if (has_future) {
[17:46:47.866]                           ns <- base::getNamespace("future")
[17:46:47.866]                           version <- ns[[".package"]][["version"]]
[17:46:47.866]                           if (is.null(version)) 
[17:46:47.866]                             version <- utils::packageVersion("future")
[17:46:47.866]                         }
[17:46:47.866]                         else {
[17:46:47.866]                           version <- NULL
[17:46:47.866]                         }
[17:46:47.866]                         if (!has_future || version < "1.8.0") {
[17:46:47.866]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.866]                             "", base::R.version$version.string), 
[17:46:47.866]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.866]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.866]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.866]                               "release", "version")], collapse = " "), 
[17:46:47.866]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.866]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.866]                             info)
[17:46:47.866]                           info <- base::paste(info, collapse = "; ")
[17:46:47.866]                           if (!has_future) {
[17:46:47.866]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.866]                               info)
[17:46:47.866]                           }
[17:46:47.866]                           else {
[17:46:47.866]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.866]                               info, version)
[17:46:47.866]                           }
[17:46:47.866]                           base::stop(msg)
[17:46:47.866]                         }
[17:46:47.866]                       })
[17:46:47.866]                     }
[17:46:47.866]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.866]                     base::options(mc.cores = 1L)
[17:46:47.866]                   }
[17:46:47.866]                   ...future.strategy.old <- future::plan("list")
[17:46:47.866]                   options(future.plan = NULL)
[17:46:47.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.866]                 }
[17:46:47.866]                 ...future.workdir <- getwd()
[17:46:47.866]             }
[17:46:47.866]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.866]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.866]         }
[17:46:47.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.866]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.866]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.866]             base::names(...future.oldOptions))
[17:46:47.866]     }
[17:46:47.866]     if (FALSE) {
[17:46:47.866]     }
[17:46:47.866]     else {
[17:46:47.866]         if (TRUE) {
[17:46:47.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.866]                 open = "w")
[17:46:47.866]         }
[17:46:47.866]         else {
[17:46:47.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.866]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.866]         }
[17:46:47.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.866]             base::sink(type = "output", split = FALSE)
[17:46:47.866]             base::close(...future.stdout)
[17:46:47.866]         }, add = TRUE)
[17:46:47.866]     }
[17:46:47.866]     ...future.frame <- base::sys.nframe()
[17:46:47.866]     ...future.conditions <- base::list()
[17:46:47.866]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.866]     if (FALSE) {
[17:46:47.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.866]     }
[17:46:47.866]     ...future.result <- base::tryCatch({
[17:46:47.866]         base::withCallingHandlers({
[17:46:47.866]             ...future.value <- base::withVisible(base::local({
[17:46:47.866]                 ...future.makeSendCondition <- base::local({
[17:46:47.866]                   sendCondition <- NULL
[17:46:47.866]                   function(frame = 1L) {
[17:46:47.866]                     if (is.function(sendCondition)) 
[17:46:47.866]                       return(sendCondition)
[17:46:47.866]                     ns <- getNamespace("parallel")
[17:46:47.866]                     if (exists("sendData", mode = "function", 
[17:46:47.866]                       envir = ns)) {
[17:46:47.866]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.866]                         envir = ns)
[17:46:47.866]                       envir <- sys.frame(frame)
[17:46:47.866]                       master <- NULL
[17:46:47.866]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.866]                         !identical(envir, emptyenv())) {
[17:46:47.866]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.866]                           inherits = FALSE)) {
[17:46:47.866]                           master <- get("master", mode = "list", 
[17:46:47.866]                             envir = envir, inherits = FALSE)
[17:46:47.866]                           if (inherits(master, c("SOCKnode", 
[17:46:47.866]                             "SOCK0node"))) {
[17:46:47.866]                             sendCondition <<- function(cond) {
[17:46:47.866]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.866]                                 success = TRUE)
[17:46:47.866]                               parallel_sendData(master, data)
[17:46:47.866]                             }
[17:46:47.866]                             return(sendCondition)
[17:46:47.866]                           }
[17:46:47.866]                         }
[17:46:47.866]                         frame <- frame + 1L
[17:46:47.866]                         envir <- sys.frame(frame)
[17:46:47.866]                       }
[17:46:47.866]                     }
[17:46:47.866]                     sendCondition <<- function(cond) NULL
[17:46:47.866]                   }
[17:46:47.866]                 })
[17:46:47.866]                 withCallingHandlers({
[17:46:47.866]                   2
[17:46:47.866]                 }, immediateCondition = function(cond) {
[17:46:47.866]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.866]                   sendCondition(cond)
[17:46:47.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.866]                   {
[17:46:47.866]                     inherits <- base::inherits
[17:46:47.866]                     invokeRestart <- base::invokeRestart
[17:46:47.866]                     is.null <- base::is.null
[17:46:47.866]                     muffled <- FALSE
[17:46:47.866]                     if (inherits(cond, "message")) {
[17:46:47.866]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.866]                       if (muffled) 
[17:46:47.866]                         invokeRestart("muffleMessage")
[17:46:47.866]                     }
[17:46:47.866]                     else if (inherits(cond, "warning")) {
[17:46:47.866]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.866]                       if (muffled) 
[17:46:47.866]                         invokeRestart("muffleWarning")
[17:46:47.866]                     }
[17:46:47.866]                     else if (inherits(cond, "condition")) {
[17:46:47.866]                       if (!is.null(pattern)) {
[17:46:47.866]                         computeRestarts <- base::computeRestarts
[17:46:47.866]                         grepl <- base::grepl
[17:46:47.866]                         restarts <- computeRestarts(cond)
[17:46:47.866]                         for (restart in restarts) {
[17:46:47.866]                           name <- restart$name
[17:46:47.866]                           if (is.null(name)) 
[17:46:47.866]                             next
[17:46:47.866]                           if (!grepl(pattern, name)) 
[17:46:47.866]                             next
[17:46:47.866]                           invokeRestart(restart)
[17:46:47.866]                           muffled <- TRUE
[17:46:47.866]                           break
[17:46:47.866]                         }
[17:46:47.866]                       }
[17:46:47.866]                     }
[17:46:47.866]                     invisible(muffled)
[17:46:47.866]                   }
[17:46:47.866]                   muffleCondition(cond)
[17:46:47.866]                 })
[17:46:47.866]             }))
[17:46:47.866]             future::FutureResult(value = ...future.value$value, 
[17:46:47.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.866]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.866]                     ...future.globalenv.names))
[17:46:47.866]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.866]         }, condition = base::local({
[17:46:47.866]             c <- base::c
[17:46:47.866]             inherits <- base::inherits
[17:46:47.866]             invokeRestart <- base::invokeRestart
[17:46:47.866]             length <- base::length
[17:46:47.866]             list <- base::list
[17:46:47.866]             seq.int <- base::seq.int
[17:46:47.866]             signalCondition <- base::signalCondition
[17:46:47.866]             sys.calls <- base::sys.calls
[17:46:47.866]             `[[` <- base::`[[`
[17:46:47.866]             `+` <- base::`+`
[17:46:47.866]             `<<-` <- base::`<<-`
[17:46:47.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.866]                   3L)]
[17:46:47.866]             }
[17:46:47.866]             function(cond) {
[17:46:47.866]                 is_error <- inherits(cond, "error")
[17:46:47.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.866]                   NULL)
[17:46:47.866]                 if (is_error) {
[17:46:47.866]                   sessionInformation <- function() {
[17:46:47.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.866]                       search = base::search(), system = base::Sys.info())
[17:46:47.866]                   }
[17:46:47.866]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.866]                     cond$call), session = sessionInformation(), 
[17:46:47.866]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.866]                   signalCondition(cond)
[17:46:47.866]                 }
[17:46:47.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.866]                 "immediateCondition"))) {
[17:46:47.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.866]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.866]                   if (TRUE && !signal) {
[17:46:47.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.866]                     {
[17:46:47.866]                       inherits <- base::inherits
[17:46:47.866]                       invokeRestart <- base::invokeRestart
[17:46:47.866]                       is.null <- base::is.null
[17:46:47.866]                       muffled <- FALSE
[17:46:47.866]                       if (inherits(cond, "message")) {
[17:46:47.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.866]                         if (muffled) 
[17:46:47.866]                           invokeRestart("muffleMessage")
[17:46:47.866]                       }
[17:46:47.866]                       else if (inherits(cond, "warning")) {
[17:46:47.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.866]                         if (muffled) 
[17:46:47.866]                           invokeRestart("muffleWarning")
[17:46:47.866]                       }
[17:46:47.866]                       else if (inherits(cond, "condition")) {
[17:46:47.866]                         if (!is.null(pattern)) {
[17:46:47.866]                           computeRestarts <- base::computeRestarts
[17:46:47.866]                           grepl <- base::grepl
[17:46:47.866]                           restarts <- computeRestarts(cond)
[17:46:47.866]                           for (restart in restarts) {
[17:46:47.866]                             name <- restart$name
[17:46:47.866]                             if (is.null(name)) 
[17:46:47.866]                               next
[17:46:47.866]                             if (!grepl(pattern, name)) 
[17:46:47.866]                               next
[17:46:47.866]                             invokeRestart(restart)
[17:46:47.866]                             muffled <- TRUE
[17:46:47.866]                             break
[17:46:47.866]                           }
[17:46:47.866]                         }
[17:46:47.866]                       }
[17:46:47.866]                       invisible(muffled)
[17:46:47.866]                     }
[17:46:47.866]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.866]                   }
[17:46:47.866]                 }
[17:46:47.866]                 else {
[17:46:47.866]                   if (TRUE) {
[17:46:47.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.866]                     {
[17:46:47.866]                       inherits <- base::inherits
[17:46:47.866]                       invokeRestart <- base::invokeRestart
[17:46:47.866]                       is.null <- base::is.null
[17:46:47.866]                       muffled <- FALSE
[17:46:47.866]                       if (inherits(cond, "message")) {
[17:46:47.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.866]                         if (muffled) 
[17:46:47.866]                           invokeRestart("muffleMessage")
[17:46:47.866]                       }
[17:46:47.866]                       else if (inherits(cond, "warning")) {
[17:46:47.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.866]                         if (muffled) 
[17:46:47.866]                           invokeRestart("muffleWarning")
[17:46:47.866]                       }
[17:46:47.866]                       else if (inherits(cond, "condition")) {
[17:46:47.866]                         if (!is.null(pattern)) {
[17:46:47.866]                           computeRestarts <- base::computeRestarts
[17:46:47.866]                           grepl <- base::grepl
[17:46:47.866]                           restarts <- computeRestarts(cond)
[17:46:47.866]                           for (restart in restarts) {
[17:46:47.866]                             name <- restart$name
[17:46:47.866]                             if (is.null(name)) 
[17:46:47.866]                               next
[17:46:47.866]                             if (!grepl(pattern, name)) 
[17:46:47.866]                               next
[17:46:47.866]                             invokeRestart(restart)
[17:46:47.866]                             muffled <- TRUE
[17:46:47.866]                             break
[17:46:47.866]                           }
[17:46:47.866]                         }
[17:46:47.866]                       }
[17:46:47.866]                       invisible(muffled)
[17:46:47.866]                     }
[17:46:47.866]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.866]                   }
[17:46:47.866]                 }
[17:46:47.866]             }
[17:46:47.866]         }))
[17:46:47.866]     }, error = function(ex) {
[17:46:47.866]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.866]                 ...future.rng), started = ...future.startTime, 
[17:46:47.866]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.866]             version = "1.8"), class = "FutureResult")
[17:46:47.866]     }, finally = {
[17:46:47.866]         if (!identical(...future.workdir, getwd())) 
[17:46:47.866]             setwd(...future.workdir)
[17:46:47.866]         {
[17:46:47.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.866]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.866]             }
[17:46:47.866]             base::options(...future.oldOptions)
[17:46:47.866]             if (.Platform$OS.type == "windows") {
[17:46:47.866]                 old_names <- names(...future.oldEnvVars)
[17:46:47.866]                 envs <- base::Sys.getenv()
[17:46:47.866]                 names <- names(envs)
[17:46:47.866]                 common <- intersect(names, old_names)
[17:46:47.866]                 added <- setdiff(names, old_names)
[17:46:47.866]                 removed <- setdiff(old_names, names)
[17:46:47.866]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.866]                   envs[common]]
[17:46:47.866]                 NAMES <- toupper(changed)
[17:46:47.866]                 args <- list()
[17:46:47.866]                 for (kk in seq_along(NAMES)) {
[17:46:47.866]                   name <- changed[[kk]]
[17:46:47.866]                   NAME <- NAMES[[kk]]
[17:46:47.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.866]                     next
[17:46:47.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.866]                 }
[17:46:47.866]                 NAMES <- toupper(added)
[17:46:47.866]                 for (kk in seq_along(NAMES)) {
[17:46:47.866]                   name <- added[[kk]]
[17:46:47.866]                   NAME <- NAMES[[kk]]
[17:46:47.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.866]                     next
[17:46:47.866]                   args[[name]] <- ""
[17:46:47.866]                 }
[17:46:47.866]                 NAMES <- toupper(removed)
[17:46:47.866]                 for (kk in seq_along(NAMES)) {
[17:46:47.866]                   name <- removed[[kk]]
[17:46:47.866]                   NAME <- NAMES[[kk]]
[17:46:47.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.866]                     next
[17:46:47.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.866]                 }
[17:46:47.866]                 if (length(args) > 0) 
[17:46:47.866]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.866]             }
[17:46:47.866]             else {
[17:46:47.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.866]             }
[17:46:47.866]             {
[17:46:47.866]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.866]                   0L) {
[17:46:47.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.866]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.866]                   base::options(opts)
[17:46:47.866]                 }
[17:46:47.866]                 {
[17:46:47.866]                   {
[17:46:47.866]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.866]                     NULL
[17:46:47.866]                   }
[17:46:47.866]                   options(future.plan = NULL)
[17:46:47.866]                   if (is.na(NA_character_)) 
[17:46:47.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.866]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.866]                     .init = FALSE)
[17:46:47.866]                 }
[17:46:47.866]             }
[17:46:47.866]         }
[17:46:47.866]     })
[17:46:47.866]     if (TRUE) {
[17:46:47.866]         base::sink(type = "output", split = FALSE)
[17:46:47.866]         if (TRUE) {
[17:46:47.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.866]         }
[17:46:47.866]         else {
[17:46:47.866]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.866]         }
[17:46:47.866]         base::close(...future.stdout)
[17:46:47.866]         ...future.stdout <- NULL
[17:46:47.866]     }
[17:46:47.866]     ...future.result$conditions <- ...future.conditions
[17:46:47.866]     ...future.result$finished <- base::Sys.time()
[17:46:47.866]     ...future.result
[17:46:47.866] }
[17:46:47.869] MultisessionFuture started
[17:46:47.869] - Launch lazy future ... done
[17:46:47.869] run() for ‘MultisessionFuture’ ... done
[17:46:47.870] getGlobalsAndPackages() ...
[17:46:47.870] Searching for globals...
[17:46:47.870] 
[17:46:47.870] Searching for globals ... DONE
[17:46:47.870] - globals: [0] <none>
[17:46:47.870] getGlobalsAndPackages() ... DONE
[17:46:47.870] run() for ‘Future’ ...
[17:46:47.871] - state: ‘created’
[17:46:47.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.884]   - Field: ‘node’
[17:46:47.885]   - Field: ‘label’
[17:46:47.885]   - Field: ‘local’
[17:46:47.885]   - Field: ‘owner’
[17:46:47.885]   - Field: ‘envir’
[17:46:47.885]   - Field: ‘workers’
[17:46:47.885]   - Field: ‘packages’
[17:46:47.885]   - Field: ‘gc’
[17:46:47.885]   - Field: ‘conditions’
[17:46:47.885]   - Field: ‘persistent’
[17:46:47.885]   - Field: ‘expr’
[17:46:47.885]   - Field: ‘uuid’
[17:46:47.886]   - Field: ‘seed’
[17:46:47.886]   - Field: ‘version’
[17:46:47.886]   - Field: ‘result’
[17:46:47.886]   - Field: ‘asynchronous’
[17:46:47.886]   - Field: ‘calls’
[17:46:47.886]   - Field: ‘globals’
[17:46:47.886]   - Field: ‘stdout’
[17:46:47.886]   - Field: ‘earlySignal’
[17:46:47.886]   - Field: ‘lazy’
[17:46:47.886]   - Field: ‘state’
[17:46:47.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.887] - Launch lazy future ...
[17:46:47.887] Packages needed by the future expression (n = 0): <none>
[17:46:47.887] Packages needed by future strategies (n = 0): <none>
[17:46:47.887] {
[17:46:47.887]     {
[17:46:47.887]         {
[17:46:47.887]             ...future.startTime <- base::Sys.time()
[17:46:47.887]             {
[17:46:47.887]                 {
[17:46:47.887]                   {
[17:46:47.887]                     {
[17:46:47.887]                       base::local({
[17:46:47.887]                         has_future <- base::requireNamespace("future", 
[17:46:47.887]                           quietly = TRUE)
[17:46:47.887]                         if (has_future) {
[17:46:47.887]                           ns <- base::getNamespace("future")
[17:46:47.887]                           version <- ns[[".package"]][["version"]]
[17:46:47.887]                           if (is.null(version)) 
[17:46:47.887]                             version <- utils::packageVersion("future")
[17:46:47.887]                         }
[17:46:47.887]                         else {
[17:46:47.887]                           version <- NULL
[17:46:47.887]                         }
[17:46:47.887]                         if (!has_future || version < "1.8.0") {
[17:46:47.887]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.887]                             "", base::R.version$version.string), 
[17:46:47.887]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.887]                               "release", "version")], collapse = " "), 
[17:46:47.887]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.887]                             info)
[17:46:47.887]                           info <- base::paste(info, collapse = "; ")
[17:46:47.887]                           if (!has_future) {
[17:46:47.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.887]                               info)
[17:46:47.887]                           }
[17:46:47.887]                           else {
[17:46:47.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.887]                               info, version)
[17:46:47.887]                           }
[17:46:47.887]                           base::stop(msg)
[17:46:47.887]                         }
[17:46:47.887]                       })
[17:46:47.887]                     }
[17:46:47.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.887]                     base::options(mc.cores = 1L)
[17:46:47.887]                   }
[17:46:47.887]                   ...future.strategy.old <- future::plan("list")
[17:46:47.887]                   options(future.plan = NULL)
[17:46:47.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.887]                 }
[17:46:47.887]                 ...future.workdir <- getwd()
[17:46:47.887]             }
[17:46:47.887]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.887]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.887]         }
[17:46:47.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.887]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.887]             base::names(...future.oldOptions))
[17:46:47.887]     }
[17:46:47.887]     if (FALSE) {
[17:46:47.887]     }
[17:46:47.887]     else {
[17:46:47.887]         if (TRUE) {
[17:46:47.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.887]                 open = "w")
[17:46:47.887]         }
[17:46:47.887]         else {
[17:46:47.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.887]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.887]         }
[17:46:47.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.887]             base::sink(type = "output", split = FALSE)
[17:46:47.887]             base::close(...future.stdout)
[17:46:47.887]         }, add = TRUE)
[17:46:47.887]     }
[17:46:47.887]     ...future.frame <- base::sys.nframe()
[17:46:47.887]     ...future.conditions <- base::list()
[17:46:47.887]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.887]     if (FALSE) {
[17:46:47.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.887]     }
[17:46:47.887]     ...future.result <- base::tryCatch({
[17:46:47.887]         base::withCallingHandlers({
[17:46:47.887]             ...future.value <- base::withVisible(base::local({
[17:46:47.887]                 ...future.makeSendCondition <- base::local({
[17:46:47.887]                   sendCondition <- NULL
[17:46:47.887]                   function(frame = 1L) {
[17:46:47.887]                     if (is.function(sendCondition)) 
[17:46:47.887]                       return(sendCondition)
[17:46:47.887]                     ns <- getNamespace("parallel")
[17:46:47.887]                     if (exists("sendData", mode = "function", 
[17:46:47.887]                       envir = ns)) {
[17:46:47.887]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.887]                         envir = ns)
[17:46:47.887]                       envir <- sys.frame(frame)
[17:46:47.887]                       master <- NULL
[17:46:47.887]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.887]                         !identical(envir, emptyenv())) {
[17:46:47.887]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.887]                           inherits = FALSE)) {
[17:46:47.887]                           master <- get("master", mode = "list", 
[17:46:47.887]                             envir = envir, inherits = FALSE)
[17:46:47.887]                           if (inherits(master, c("SOCKnode", 
[17:46:47.887]                             "SOCK0node"))) {
[17:46:47.887]                             sendCondition <<- function(cond) {
[17:46:47.887]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.887]                                 success = TRUE)
[17:46:47.887]                               parallel_sendData(master, data)
[17:46:47.887]                             }
[17:46:47.887]                             return(sendCondition)
[17:46:47.887]                           }
[17:46:47.887]                         }
[17:46:47.887]                         frame <- frame + 1L
[17:46:47.887]                         envir <- sys.frame(frame)
[17:46:47.887]                       }
[17:46:47.887]                     }
[17:46:47.887]                     sendCondition <<- function(cond) NULL
[17:46:47.887]                   }
[17:46:47.887]                 })
[17:46:47.887]                 withCallingHandlers({
[17:46:47.887]                   NULL
[17:46:47.887]                 }, immediateCondition = function(cond) {
[17:46:47.887]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.887]                   sendCondition(cond)
[17:46:47.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.887]                   {
[17:46:47.887]                     inherits <- base::inherits
[17:46:47.887]                     invokeRestart <- base::invokeRestart
[17:46:47.887]                     is.null <- base::is.null
[17:46:47.887]                     muffled <- FALSE
[17:46:47.887]                     if (inherits(cond, "message")) {
[17:46:47.887]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.887]                       if (muffled) 
[17:46:47.887]                         invokeRestart("muffleMessage")
[17:46:47.887]                     }
[17:46:47.887]                     else if (inherits(cond, "warning")) {
[17:46:47.887]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.887]                       if (muffled) 
[17:46:47.887]                         invokeRestart("muffleWarning")
[17:46:47.887]                     }
[17:46:47.887]                     else if (inherits(cond, "condition")) {
[17:46:47.887]                       if (!is.null(pattern)) {
[17:46:47.887]                         computeRestarts <- base::computeRestarts
[17:46:47.887]                         grepl <- base::grepl
[17:46:47.887]                         restarts <- computeRestarts(cond)
[17:46:47.887]                         for (restart in restarts) {
[17:46:47.887]                           name <- restart$name
[17:46:47.887]                           if (is.null(name)) 
[17:46:47.887]                             next
[17:46:47.887]                           if (!grepl(pattern, name)) 
[17:46:47.887]                             next
[17:46:47.887]                           invokeRestart(restart)
[17:46:47.887]                           muffled <- TRUE
[17:46:47.887]                           break
[17:46:47.887]                         }
[17:46:47.887]                       }
[17:46:47.887]                     }
[17:46:47.887]                     invisible(muffled)
[17:46:47.887]                   }
[17:46:47.887]                   muffleCondition(cond)
[17:46:47.887]                 })
[17:46:47.887]             }))
[17:46:47.887]             future::FutureResult(value = ...future.value$value, 
[17:46:47.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.887]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.887]                     ...future.globalenv.names))
[17:46:47.887]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.887]         }, condition = base::local({
[17:46:47.887]             c <- base::c
[17:46:47.887]             inherits <- base::inherits
[17:46:47.887]             invokeRestart <- base::invokeRestart
[17:46:47.887]             length <- base::length
[17:46:47.887]             list <- base::list
[17:46:47.887]             seq.int <- base::seq.int
[17:46:47.887]             signalCondition <- base::signalCondition
[17:46:47.887]             sys.calls <- base::sys.calls
[17:46:47.887]             `[[` <- base::`[[`
[17:46:47.887]             `+` <- base::`+`
[17:46:47.887]             `<<-` <- base::`<<-`
[17:46:47.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.887]                   3L)]
[17:46:47.887]             }
[17:46:47.887]             function(cond) {
[17:46:47.887]                 is_error <- inherits(cond, "error")
[17:46:47.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.887]                   NULL)
[17:46:47.887]                 if (is_error) {
[17:46:47.887]                   sessionInformation <- function() {
[17:46:47.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.887]                       search = base::search(), system = base::Sys.info())
[17:46:47.887]                   }
[17:46:47.887]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.887]                     cond$call), session = sessionInformation(), 
[17:46:47.887]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.887]                   signalCondition(cond)
[17:46:47.887]                 }
[17:46:47.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.887]                 "immediateCondition"))) {
[17:46:47.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.887]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.887]                   if (TRUE && !signal) {
[17:46:47.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.887]                     {
[17:46:47.887]                       inherits <- base::inherits
[17:46:47.887]                       invokeRestart <- base::invokeRestart
[17:46:47.887]                       is.null <- base::is.null
[17:46:47.887]                       muffled <- FALSE
[17:46:47.887]                       if (inherits(cond, "message")) {
[17:46:47.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.887]                         if (muffled) 
[17:46:47.887]                           invokeRestart("muffleMessage")
[17:46:47.887]                       }
[17:46:47.887]                       else if (inherits(cond, "warning")) {
[17:46:47.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.887]                         if (muffled) 
[17:46:47.887]                           invokeRestart("muffleWarning")
[17:46:47.887]                       }
[17:46:47.887]                       else if (inherits(cond, "condition")) {
[17:46:47.887]                         if (!is.null(pattern)) {
[17:46:47.887]                           computeRestarts <- base::computeRestarts
[17:46:47.887]                           grepl <- base::grepl
[17:46:47.887]                           restarts <- computeRestarts(cond)
[17:46:47.887]                           for (restart in restarts) {
[17:46:47.887]                             name <- restart$name
[17:46:47.887]                             if (is.null(name)) 
[17:46:47.887]                               next
[17:46:47.887]                             if (!grepl(pattern, name)) 
[17:46:47.887]                               next
[17:46:47.887]                             invokeRestart(restart)
[17:46:47.887]                             muffled <- TRUE
[17:46:47.887]                             break
[17:46:47.887]                           }
[17:46:47.887]                         }
[17:46:47.887]                       }
[17:46:47.887]                       invisible(muffled)
[17:46:47.887]                     }
[17:46:47.887]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.887]                   }
[17:46:47.887]                 }
[17:46:47.887]                 else {
[17:46:47.887]                   if (TRUE) {
[17:46:47.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.887]                     {
[17:46:47.887]                       inherits <- base::inherits
[17:46:47.887]                       invokeRestart <- base::invokeRestart
[17:46:47.887]                       is.null <- base::is.null
[17:46:47.887]                       muffled <- FALSE
[17:46:47.887]                       if (inherits(cond, "message")) {
[17:46:47.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.887]                         if (muffled) 
[17:46:47.887]                           invokeRestart("muffleMessage")
[17:46:47.887]                       }
[17:46:47.887]                       else if (inherits(cond, "warning")) {
[17:46:47.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.887]                         if (muffled) 
[17:46:47.887]                           invokeRestart("muffleWarning")
[17:46:47.887]                       }
[17:46:47.887]                       else if (inherits(cond, "condition")) {
[17:46:47.887]                         if (!is.null(pattern)) {
[17:46:47.887]                           computeRestarts <- base::computeRestarts
[17:46:47.887]                           grepl <- base::grepl
[17:46:47.887]                           restarts <- computeRestarts(cond)
[17:46:47.887]                           for (restart in restarts) {
[17:46:47.887]                             name <- restart$name
[17:46:47.887]                             if (is.null(name)) 
[17:46:47.887]                               next
[17:46:47.887]                             if (!grepl(pattern, name)) 
[17:46:47.887]                               next
[17:46:47.887]                             invokeRestart(restart)
[17:46:47.887]                             muffled <- TRUE
[17:46:47.887]                             break
[17:46:47.887]                           }
[17:46:47.887]                         }
[17:46:47.887]                       }
[17:46:47.887]                       invisible(muffled)
[17:46:47.887]                     }
[17:46:47.887]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.887]                   }
[17:46:47.887]                 }
[17:46:47.887]             }
[17:46:47.887]         }))
[17:46:47.887]     }, error = function(ex) {
[17:46:47.887]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.887]                 ...future.rng), started = ...future.startTime, 
[17:46:47.887]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.887]             version = "1.8"), class = "FutureResult")
[17:46:47.887]     }, finally = {
[17:46:47.887]         if (!identical(...future.workdir, getwd())) 
[17:46:47.887]             setwd(...future.workdir)
[17:46:47.887]         {
[17:46:47.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.887]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.887]             }
[17:46:47.887]             base::options(...future.oldOptions)
[17:46:47.887]             if (.Platform$OS.type == "windows") {
[17:46:47.887]                 old_names <- names(...future.oldEnvVars)
[17:46:47.887]                 envs <- base::Sys.getenv()
[17:46:47.887]                 names <- names(envs)
[17:46:47.887]                 common <- intersect(names, old_names)
[17:46:47.887]                 added <- setdiff(names, old_names)
[17:46:47.887]                 removed <- setdiff(old_names, names)
[17:46:47.887]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.887]                   envs[common]]
[17:46:47.887]                 NAMES <- toupper(changed)
[17:46:47.887]                 args <- list()
[17:46:47.887]                 for (kk in seq_along(NAMES)) {
[17:46:47.887]                   name <- changed[[kk]]
[17:46:47.887]                   NAME <- NAMES[[kk]]
[17:46:47.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.887]                     next
[17:46:47.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.887]                 }
[17:46:47.887]                 NAMES <- toupper(added)
[17:46:47.887]                 for (kk in seq_along(NAMES)) {
[17:46:47.887]                   name <- added[[kk]]
[17:46:47.887]                   NAME <- NAMES[[kk]]
[17:46:47.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.887]                     next
[17:46:47.887]                   args[[name]] <- ""
[17:46:47.887]                 }
[17:46:47.887]                 NAMES <- toupper(removed)
[17:46:47.887]                 for (kk in seq_along(NAMES)) {
[17:46:47.887]                   name <- removed[[kk]]
[17:46:47.887]                   NAME <- NAMES[[kk]]
[17:46:47.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.887]                     next
[17:46:47.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.887]                 }
[17:46:47.887]                 if (length(args) > 0) 
[17:46:47.887]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.887]             }
[17:46:47.887]             else {
[17:46:47.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.887]             }
[17:46:47.887]             {
[17:46:47.887]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.887]                   0L) {
[17:46:47.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.887]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.887]                   base::options(opts)
[17:46:47.887]                 }
[17:46:47.887]                 {
[17:46:47.887]                   {
[17:46:47.887]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.887]                     NULL
[17:46:47.887]                   }
[17:46:47.887]                   options(future.plan = NULL)
[17:46:47.887]                   if (is.na(NA_character_)) 
[17:46:47.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.887]                     .init = FALSE)
[17:46:47.887]                 }
[17:46:47.887]             }
[17:46:47.887]         }
[17:46:47.887]     })
[17:46:47.887]     if (TRUE) {
[17:46:47.887]         base::sink(type = "output", split = FALSE)
[17:46:47.887]         if (TRUE) {
[17:46:47.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.887]         }
[17:46:47.887]         else {
[17:46:47.887]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.887]         }
[17:46:47.887]         base::close(...future.stdout)
[17:46:47.887]         ...future.stdout <- NULL
[17:46:47.887]     }
[17:46:47.887]     ...future.result$conditions <- ...future.conditions
[17:46:47.887]     ...future.result$finished <- base::Sys.time()
[17:46:47.887]     ...future.result
[17:46:47.887] }
[17:46:47.890] MultisessionFuture started
[17:46:47.890] - Launch lazy future ... done
[17:46:47.891] run() for ‘MultisessionFuture’ ... done
[17:46:47.891] getGlobalsAndPackages() ...
[17:46:47.891] Searching for globals...
[17:46:47.892] - globals found: [1] ‘{’
[17:46:47.892] Searching for globals ... DONE
[17:46:47.892] Resolving globals: FALSE
[17:46:47.892] 
[17:46:47.892] 
[17:46:47.892] getGlobalsAndPackages() ... DONE
[17:46:47.892] run() for ‘Future’ ...
[17:46:47.893] - state: ‘created’
[17:46:47.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.906] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.906]   - Field: ‘node’
[17:46:47.906]   - Field: ‘label’
[17:46:47.906]   - Field: ‘local’
[17:46:47.907]   - Field: ‘owner’
[17:46:47.907]   - Field: ‘envir’
[17:46:47.907]   - Field: ‘workers’
[17:46:47.907]   - Field: ‘packages’
[17:46:47.907]   - Field: ‘gc’
[17:46:47.907]   - Field: ‘conditions’
[17:46:47.907]   - Field: ‘persistent’
[17:46:47.907]   - Field: ‘expr’
[17:46:47.907]   - Field: ‘uuid’
[17:46:47.907]   - Field: ‘seed’
[17:46:47.908]   - Field: ‘version’
[17:46:47.908]   - Field: ‘result’
[17:46:47.908]   - Field: ‘asynchronous’
[17:46:47.908]   - Field: ‘calls’
[17:46:47.908]   - Field: ‘globals’
[17:46:47.908]   - Field: ‘stdout’
[17:46:47.908]   - Field: ‘earlySignal’
[17:46:47.908]   - Field: ‘lazy’
[17:46:47.908]   - Field: ‘state’
[17:46:47.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.908] - Launch lazy future ...
[17:46:47.909] Packages needed by the future expression (n = 0): <none>
[17:46:47.909] Packages needed by future strategies (n = 0): <none>
[17:46:47.909] {
[17:46:47.909]     {
[17:46:47.909]         {
[17:46:47.909]             ...future.startTime <- base::Sys.time()
[17:46:47.909]             {
[17:46:47.909]                 {
[17:46:47.909]                   {
[17:46:47.909]                     {
[17:46:47.909]                       base::local({
[17:46:47.909]                         has_future <- base::requireNamespace("future", 
[17:46:47.909]                           quietly = TRUE)
[17:46:47.909]                         if (has_future) {
[17:46:47.909]                           ns <- base::getNamespace("future")
[17:46:47.909]                           version <- ns[[".package"]][["version"]]
[17:46:47.909]                           if (is.null(version)) 
[17:46:47.909]                             version <- utils::packageVersion("future")
[17:46:47.909]                         }
[17:46:47.909]                         else {
[17:46:47.909]                           version <- NULL
[17:46:47.909]                         }
[17:46:47.909]                         if (!has_future || version < "1.8.0") {
[17:46:47.909]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.909]                             "", base::R.version$version.string), 
[17:46:47.909]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.909]                               "release", "version")], collapse = " "), 
[17:46:47.909]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.909]                             info)
[17:46:47.909]                           info <- base::paste(info, collapse = "; ")
[17:46:47.909]                           if (!has_future) {
[17:46:47.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.909]                               info)
[17:46:47.909]                           }
[17:46:47.909]                           else {
[17:46:47.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.909]                               info, version)
[17:46:47.909]                           }
[17:46:47.909]                           base::stop(msg)
[17:46:47.909]                         }
[17:46:47.909]                       })
[17:46:47.909]                     }
[17:46:47.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.909]                     base::options(mc.cores = 1L)
[17:46:47.909]                   }
[17:46:47.909]                   ...future.strategy.old <- future::plan("list")
[17:46:47.909]                   options(future.plan = NULL)
[17:46:47.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.909]                 }
[17:46:47.909]                 ...future.workdir <- getwd()
[17:46:47.909]             }
[17:46:47.909]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.909]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.909]         }
[17:46:47.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.909]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.909]             base::names(...future.oldOptions))
[17:46:47.909]     }
[17:46:47.909]     if (FALSE) {
[17:46:47.909]     }
[17:46:47.909]     else {
[17:46:47.909]         if (TRUE) {
[17:46:47.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.909]                 open = "w")
[17:46:47.909]         }
[17:46:47.909]         else {
[17:46:47.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.909]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.909]         }
[17:46:47.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.909]             base::sink(type = "output", split = FALSE)
[17:46:47.909]             base::close(...future.stdout)
[17:46:47.909]         }, add = TRUE)
[17:46:47.909]     }
[17:46:47.909]     ...future.frame <- base::sys.nframe()
[17:46:47.909]     ...future.conditions <- base::list()
[17:46:47.909]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.909]     if (FALSE) {
[17:46:47.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.909]     }
[17:46:47.909]     ...future.result <- base::tryCatch({
[17:46:47.909]         base::withCallingHandlers({
[17:46:47.909]             ...future.value <- base::withVisible(base::local({
[17:46:47.909]                 ...future.makeSendCondition <- base::local({
[17:46:47.909]                   sendCondition <- NULL
[17:46:47.909]                   function(frame = 1L) {
[17:46:47.909]                     if (is.function(sendCondition)) 
[17:46:47.909]                       return(sendCondition)
[17:46:47.909]                     ns <- getNamespace("parallel")
[17:46:47.909]                     if (exists("sendData", mode = "function", 
[17:46:47.909]                       envir = ns)) {
[17:46:47.909]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.909]                         envir = ns)
[17:46:47.909]                       envir <- sys.frame(frame)
[17:46:47.909]                       master <- NULL
[17:46:47.909]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.909]                         !identical(envir, emptyenv())) {
[17:46:47.909]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.909]                           inherits = FALSE)) {
[17:46:47.909]                           master <- get("master", mode = "list", 
[17:46:47.909]                             envir = envir, inherits = FALSE)
[17:46:47.909]                           if (inherits(master, c("SOCKnode", 
[17:46:47.909]                             "SOCK0node"))) {
[17:46:47.909]                             sendCondition <<- function(cond) {
[17:46:47.909]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.909]                                 success = TRUE)
[17:46:47.909]                               parallel_sendData(master, data)
[17:46:47.909]                             }
[17:46:47.909]                             return(sendCondition)
[17:46:47.909]                           }
[17:46:47.909]                         }
[17:46:47.909]                         frame <- frame + 1L
[17:46:47.909]                         envir <- sys.frame(frame)
[17:46:47.909]                       }
[17:46:47.909]                     }
[17:46:47.909]                     sendCondition <<- function(cond) NULL
[17:46:47.909]                   }
[17:46:47.909]                 })
[17:46:47.909]                 withCallingHandlers({
[17:46:47.909]                   {
[17:46:47.909]                     4
[17:46:47.909]                   }
[17:46:47.909]                 }, immediateCondition = function(cond) {
[17:46:47.909]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.909]                   sendCondition(cond)
[17:46:47.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.909]                   {
[17:46:47.909]                     inherits <- base::inherits
[17:46:47.909]                     invokeRestart <- base::invokeRestart
[17:46:47.909]                     is.null <- base::is.null
[17:46:47.909]                     muffled <- FALSE
[17:46:47.909]                     if (inherits(cond, "message")) {
[17:46:47.909]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.909]                       if (muffled) 
[17:46:47.909]                         invokeRestart("muffleMessage")
[17:46:47.909]                     }
[17:46:47.909]                     else if (inherits(cond, "warning")) {
[17:46:47.909]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.909]                       if (muffled) 
[17:46:47.909]                         invokeRestart("muffleWarning")
[17:46:47.909]                     }
[17:46:47.909]                     else if (inherits(cond, "condition")) {
[17:46:47.909]                       if (!is.null(pattern)) {
[17:46:47.909]                         computeRestarts <- base::computeRestarts
[17:46:47.909]                         grepl <- base::grepl
[17:46:47.909]                         restarts <- computeRestarts(cond)
[17:46:47.909]                         for (restart in restarts) {
[17:46:47.909]                           name <- restart$name
[17:46:47.909]                           if (is.null(name)) 
[17:46:47.909]                             next
[17:46:47.909]                           if (!grepl(pattern, name)) 
[17:46:47.909]                             next
[17:46:47.909]                           invokeRestart(restart)
[17:46:47.909]                           muffled <- TRUE
[17:46:47.909]                           break
[17:46:47.909]                         }
[17:46:47.909]                       }
[17:46:47.909]                     }
[17:46:47.909]                     invisible(muffled)
[17:46:47.909]                   }
[17:46:47.909]                   muffleCondition(cond)
[17:46:47.909]                 })
[17:46:47.909]             }))
[17:46:47.909]             future::FutureResult(value = ...future.value$value, 
[17:46:47.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.909]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.909]                     ...future.globalenv.names))
[17:46:47.909]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.909]         }, condition = base::local({
[17:46:47.909]             c <- base::c
[17:46:47.909]             inherits <- base::inherits
[17:46:47.909]             invokeRestart <- base::invokeRestart
[17:46:47.909]             length <- base::length
[17:46:47.909]             list <- base::list
[17:46:47.909]             seq.int <- base::seq.int
[17:46:47.909]             signalCondition <- base::signalCondition
[17:46:47.909]             sys.calls <- base::sys.calls
[17:46:47.909]             `[[` <- base::`[[`
[17:46:47.909]             `+` <- base::`+`
[17:46:47.909]             `<<-` <- base::`<<-`
[17:46:47.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.909]                   3L)]
[17:46:47.909]             }
[17:46:47.909]             function(cond) {
[17:46:47.909]                 is_error <- inherits(cond, "error")
[17:46:47.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.909]                   NULL)
[17:46:47.909]                 if (is_error) {
[17:46:47.909]                   sessionInformation <- function() {
[17:46:47.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.909]                       search = base::search(), system = base::Sys.info())
[17:46:47.909]                   }
[17:46:47.909]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.909]                     cond$call), session = sessionInformation(), 
[17:46:47.909]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.909]                   signalCondition(cond)
[17:46:47.909]                 }
[17:46:47.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.909]                 "immediateCondition"))) {
[17:46:47.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.909]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.909]                   if (TRUE && !signal) {
[17:46:47.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.909]                     {
[17:46:47.909]                       inherits <- base::inherits
[17:46:47.909]                       invokeRestart <- base::invokeRestart
[17:46:47.909]                       is.null <- base::is.null
[17:46:47.909]                       muffled <- FALSE
[17:46:47.909]                       if (inherits(cond, "message")) {
[17:46:47.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.909]                         if (muffled) 
[17:46:47.909]                           invokeRestart("muffleMessage")
[17:46:47.909]                       }
[17:46:47.909]                       else if (inherits(cond, "warning")) {
[17:46:47.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.909]                         if (muffled) 
[17:46:47.909]                           invokeRestart("muffleWarning")
[17:46:47.909]                       }
[17:46:47.909]                       else if (inherits(cond, "condition")) {
[17:46:47.909]                         if (!is.null(pattern)) {
[17:46:47.909]                           computeRestarts <- base::computeRestarts
[17:46:47.909]                           grepl <- base::grepl
[17:46:47.909]                           restarts <- computeRestarts(cond)
[17:46:47.909]                           for (restart in restarts) {
[17:46:47.909]                             name <- restart$name
[17:46:47.909]                             if (is.null(name)) 
[17:46:47.909]                               next
[17:46:47.909]                             if (!grepl(pattern, name)) 
[17:46:47.909]                               next
[17:46:47.909]                             invokeRestart(restart)
[17:46:47.909]                             muffled <- TRUE
[17:46:47.909]                             break
[17:46:47.909]                           }
[17:46:47.909]                         }
[17:46:47.909]                       }
[17:46:47.909]                       invisible(muffled)
[17:46:47.909]                     }
[17:46:47.909]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.909]                   }
[17:46:47.909]                 }
[17:46:47.909]                 else {
[17:46:47.909]                   if (TRUE) {
[17:46:47.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.909]                     {
[17:46:47.909]                       inherits <- base::inherits
[17:46:47.909]                       invokeRestart <- base::invokeRestart
[17:46:47.909]                       is.null <- base::is.null
[17:46:47.909]                       muffled <- FALSE
[17:46:47.909]                       if (inherits(cond, "message")) {
[17:46:47.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.909]                         if (muffled) 
[17:46:47.909]                           invokeRestart("muffleMessage")
[17:46:47.909]                       }
[17:46:47.909]                       else if (inherits(cond, "warning")) {
[17:46:47.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.909]                         if (muffled) 
[17:46:47.909]                           invokeRestart("muffleWarning")
[17:46:47.909]                       }
[17:46:47.909]                       else if (inherits(cond, "condition")) {
[17:46:47.909]                         if (!is.null(pattern)) {
[17:46:47.909]                           computeRestarts <- base::computeRestarts
[17:46:47.909]                           grepl <- base::grepl
[17:46:47.909]                           restarts <- computeRestarts(cond)
[17:46:47.909]                           for (restart in restarts) {
[17:46:47.909]                             name <- restart$name
[17:46:47.909]                             if (is.null(name)) 
[17:46:47.909]                               next
[17:46:47.909]                             if (!grepl(pattern, name)) 
[17:46:47.909]                               next
[17:46:47.909]                             invokeRestart(restart)
[17:46:47.909]                             muffled <- TRUE
[17:46:47.909]                             break
[17:46:47.909]                           }
[17:46:47.909]                         }
[17:46:47.909]                       }
[17:46:47.909]                       invisible(muffled)
[17:46:47.909]                     }
[17:46:47.909]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.909]                   }
[17:46:47.909]                 }
[17:46:47.909]             }
[17:46:47.909]         }))
[17:46:47.909]     }, error = function(ex) {
[17:46:47.909]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.909]                 ...future.rng), started = ...future.startTime, 
[17:46:47.909]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.909]             version = "1.8"), class = "FutureResult")
[17:46:47.909]     }, finally = {
[17:46:47.909]         if (!identical(...future.workdir, getwd())) 
[17:46:47.909]             setwd(...future.workdir)
[17:46:47.909]         {
[17:46:47.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.909]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.909]             }
[17:46:47.909]             base::options(...future.oldOptions)
[17:46:47.909]             if (.Platform$OS.type == "windows") {
[17:46:47.909]                 old_names <- names(...future.oldEnvVars)
[17:46:47.909]                 envs <- base::Sys.getenv()
[17:46:47.909]                 names <- names(envs)
[17:46:47.909]                 common <- intersect(names, old_names)
[17:46:47.909]                 added <- setdiff(names, old_names)
[17:46:47.909]                 removed <- setdiff(old_names, names)
[17:46:47.909]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.909]                   envs[common]]
[17:46:47.909]                 NAMES <- toupper(changed)
[17:46:47.909]                 args <- list()
[17:46:47.909]                 for (kk in seq_along(NAMES)) {
[17:46:47.909]                   name <- changed[[kk]]
[17:46:47.909]                   NAME <- NAMES[[kk]]
[17:46:47.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.909]                     next
[17:46:47.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.909]                 }
[17:46:47.909]                 NAMES <- toupper(added)
[17:46:47.909]                 for (kk in seq_along(NAMES)) {
[17:46:47.909]                   name <- added[[kk]]
[17:46:47.909]                   NAME <- NAMES[[kk]]
[17:46:47.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.909]                     next
[17:46:47.909]                   args[[name]] <- ""
[17:46:47.909]                 }
[17:46:47.909]                 NAMES <- toupper(removed)
[17:46:47.909]                 for (kk in seq_along(NAMES)) {
[17:46:47.909]                   name <- removed[[kk]]
[17:46:47.909]                   NAME <- NAMES[[kk]]
[17:46:47.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.909]                     next
[17:46:47.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.909]                 }
[17:46:47.909]                 if (length(args) > 0) 
[17:46:47.909]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.909]             }
[17:46:47.909]             else {
[17:46:47.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.909]             }
[17:46:47.909]             {
[17:46:47.909]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.909]                   0L) {
[17:46:47.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.909]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.909]                   base::options(opts)
[17:46:47.909]                 }
[17:46:47.909]                 {
[17:46:47.909]                   {
[17:46:47.909]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.909]                     NULL
[17:46:47.909]                   }
[17:46:47.909]                   options(future.plan = NULL)
[17:46:47.909]                   if (is.na(NA_character_)) 
[17:46:47.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.909]                     .init = FALSE)
[17:46:47.909]                 }
[17:46:47.909]             }
[17:46:47.909]         }
[17:46:47.909]     })
[17:46:47.909]     if (TRUE) {
[17:46:47.909]         base::sink(type = "output", split = FALSE)
[17:46:47.909]         if (TRUE) {
[17:46:47.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.909]         }
[17:46:47.909]         else {
[17:46:47.909]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.909]         }
[17:46:47.909]         base::close(...future.stdout)
[17:46:47.909]         ...future.stdout <- NULL
[17:46:47.909]     }
[17:46:47.909]     ...future.result$conditions <- ...future.conditions
[17:46:47.909]     ...future.result$finished <- base::Sys.time()
[17:46:47.909]     ...future.result
[17:46:47.909] }
[17:46:47.911] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:47.922] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.922] - Validating connection of MultisessionFuture
[17:46:47.922] - received message: FutureResult
[17:46:47.922] - Received FutureResult
[17:46:47.922] - Erased future from FutureRegistry
[17:46:47.923] result() for ClusterFuture ...
[17:46:47.923] - result already collected: FutureResult
[17:46:47.923] result() for ClusterFuture ... done
[17:46:47.923] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.923] result() for ClusterFuture ...
[17:46:47.923] - result already collected: FutureResult
[17:46:47.923] result() for ClusterFuture ... done
[17:46:47.923] result() for ClusterFuture ...
[17:46:47.923] - result already collected: FutureResult
[17:46:47.923] result() for ClusterFuture ... done
[17:46:47.924] MultisessionFuture started
[17:46:47.924] - Launch lazy future ... done
[17:46:47.925] run() for ‘MultisessionFuture’ ... done
<environment: 0x561787c20df8> 
<environment: 0x561788d59940> 
[17:46:47.926] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.926] - Validating connection of MultisessionFuture
[17:46:47.926] - received message: FutureResult
[17:46:47.927] - Received FutureResult
[17:46:47.927] - Erased future from FutureRegistry
[17:46:47.927] result() for ClusterFuture ...
[17:46:47.927] - result already collected: FutureResult
[17:46:47.927] result() for ClusterFuture ... done
[17:46:47.927] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:47.927] receiveMessageFromWorker() for ClusterFuture ...
[17:46:47.928] - Validating connection of MultisessionFuture
[17:46:47.928] - received message: FutureResult
[17:46:47.928] - Received FutureResult
[17:46:47.928] - Erased future from FutureRegistry
[17:46:47.928] result() for ClusterFuture ...
[17:46:47.928] - result already collected: FutureResult
[17:46:47.928] result() for ClusterFuture ... done
[17:46:47.928] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:47.930] resolve() on environment ...
[17:46:47.930]  recursive: 0
[17:46:47.930]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:47.930] signalConditionsASAP(numeric, pos=1) ...
[17:46:47.930] - nx: 4
[17:46:47.930] - relay: TRUE
[17:46:47.930] - stdout: TRUE
[17:46:47.931] - signal: TRUE
[17:46:47.931] - resignal: FALSE
[17:46:47.931] - force: TRUE
[17:46:47.931] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.931] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.931]  - until=2
[17:46:47.931]  - relaying element #2
[17:46:47.931] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.931] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.931] signalConditionsASAP(NULL, pos=1) ... done
[17:46:47.931]  length: 3 (resolved future 1)
[17:46:47.932] Future #2
[17:46:47.932] result() for ClusterFuture ...
[17:46:47.932] - result already collected: FutureResult
[17:46:47.932] result() for ClusterFuture ... done
[17:46:47.932] result() for ClusterFuture ...
[17:46:47.932] - result already collected: FutureResult
[17:46:47.932] result() for ClusterFuture ... done
[17:46:47.932] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:47.932] - nx: 4
[17:46:47.932] - relay: TRUE
[17:46:47.932] - stdout: TRUE
[17:46:47.933] - signal: TRUE
[17:46:47.933] - resignal: FALSE
[17:46:47.933] - force: TRUE
[17:46:47.933] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:47.933] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:47.933]  - until=2
[17:46:47.933]  - relaying element #2
[17:46:47.933] result() for ClusterFuture ...
[17:46:47.933] - result already collected: FutureResult
[17:46:47.933] result() for ClusterFuture ... done
[17:46:47.933] result() for ClusterFuture ...
[17:46:47.933] - result already collected: FutureResult
[17:46:47.934] result() for ClusterFuture ... done
[17:46:47.934] result() for ClusterFuture ...
[17:46:47.934] - result already collected: FutureResult
[17:46:47.934] result() for ClusterFuture ... done
[17:46:47.934] result() for ClusterFuture ...
[17:46:47.934] - result already collected: FutureResult
[17:46:47.934] result() for ClusterFuture ... done
[17:46:47.934] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.934] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.934] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:47.934]  length: 2 (resolved future 2)
[17:46:47.935] Future #3
[17:46:47.935] result() for ClusterFuture ...
[17:46:47.935] - result already collected: FutureResult
[17:46:47.935] result() for ClusterFuture ... done
[17:46:47.935] result() for ClusterFuture ...
[17:46:47.935] - result already collected: FutureResult
[17:46:47.935] result() for ClusterFuture ... done
[17:46:47.935] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:47.935] - nx: 4
[17:46:47.935] - relay: TRUE
[17:46:47.935] - stdout: TRUE
[17:46:47.935] - signal: TRUE
[17:46:47.936] - resignal: FALSE
[17:46:47.936] - force: TRUE
[17:46:47.936] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:47.936] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:47.936]  - until=3
[17:46:47.936]  - relaying element #3
[17:46:47.936] result() for ClusterFuture ...
[17:46:47.936] - result already collected: FutureResult
[17:46:47.936] result() for ClusterFuture ... done
[17:46:47.936] result() for ClusterFuture ...
[17:46:47.936] - result already collected: FutureResult
[17:46:47.937] result() for ClusterFuture ... done
[17:46:47.937] result() for ClusterFuture ...
[17:46:47.937] - result already collected: FutureResult
[17:46:47.937] result() for ClusterFuture ... done
[17:46:47.937] result() for ClusterFuture ...
[17:46:47.937] - result already collected: FutureResult
[17:46:47.937] result() for ClusterFuture ... done
[17:46:47.937] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.937] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.937] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:47.937]  length: 1 (resolved future 3)
[17:46:47.938] Future #4
[17:46:47.938] result() for ClusterFuture ...
[17:46:47.938] - result already collected: FutureResult
[17:46:47.938] result() for ClusterFuture ... done
[17:46:47.938] result() for ClusterFuture ...
[17:46:47.938] - result already collected: FutureResult
[17:46:47.938] result() for ClusterFuture ... done
[17:46:47.938] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:47.938] - nx: 4
[17:46:47.938] - relay: TRUE
[17:46:47.938] - stdout: TRUE
[17:46:47.938] - signal: TRUE
[17:46:47.939] - resignal: FALSE
[17:46:47.939] - force: TRUE
[17:46:47.939] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:47.939] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:47.939]  - until=4
[17:46:47.939]  - relaying element #4
[17:46:47.939] result() for ClusterFuture ...
[17:46:47.939] - result already collected: FutureResult
[17:46:47.939] result() for ClusterFuture ... done
[17:46:47.939] result() for ClusterFuture ...
[17:46:47.939] - result already collected: FutureResult
[17:46:47.940] result() for ClusterFuture ... done
[17:46:47.940] result() for ClusterFuture ...
[17:46:47.940] - result already collected: FutureResult
[17:46:47.940] result() for ClusterFuture ... done
[17:46:47.940] result() for ClusterFuture ...
[17:46:47.940] - result already collected: FutureResult
[17:46:47.940] result() for ClusterFuture ... done
[17:46:47.940] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.940] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.940] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:47.940]  length: 0 (resolved future 4)
[17:46:47.940] Relaying remaining futures
[17:46:47.941] signalConditionsASAP(NULL, pos=0) ...
[17:46:47.941] - nx: 4
[17:46:47.941] - relay: TRUE
[17:46:47.941] - stdout: TRUE
[17:46:47.941] - signal: TRUE
[17:46:47.941] - resignal: FALSE
[17:46:47.941] - force: TRUE
[17:46:47.941] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.941] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:47.941] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:47.941] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:47.942] signalConditionsASAP(NULL, pos=0) ... done
[17:46:47.942] resolve() on environment ... DONE
[17:46:47.942] result() for ClusterFuture ...
[17:46:47.942] - result already collected: FutureResult
[17:46:47.942] result() for ClusterFuture ... done
[17:46:47.942] result() for ClusterFuture ...
[17:46:47.942] - result already collected: FutureResult
[17:46:47.942] result() for ClusterFuture ... done
[17:46:47.942] result() for ClusterFuture ...
[17:46:47.942] - result already collected: FutureResult
[17:46:47.942] result() for ClusterFuture ... done
[17:46:47.942] result() for ClusterFuture ...
[17:46:47.943] - result already collected: FutureResult
[17:46:47.943] result() for ClusterFuture ... done
[17:46:47.943] result() for ClusterFuture ...
[17:46:47.943] - result already collected: FutureResult
[17:46:47.943] result() for ClusterFuture ... done
[17:46:47.943] result() for ClusterFuture ...
[17:46:47.943] - result already collected: FutureResult
[17:46:47.943] result() for ClusterFuture ... done
<environment: 0x561788f7f138> 
Dimensions: c(2, 1, 3, 1)
[17:46:47.944] getGlobalsAndPackages() ...
[17:46:47.944] Searching for globals...
[17:46:47.944] 
[17:46:47.944] Searching for globals ... DONE
[17:46:47.944] - globals: [0] <none>
[17:46:47.944] getGlobalsAndPackages() ... DONE
[17:46:47.944] run() for ‘Future’ ...
[17:46:47.945] - state: ‘created’
[17:46:47.945] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.958] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.959]   - Field: ‘node’
[17:46:47.959]   - Field: ‘label’
[17:46:47.959]   - Field: ‘local’
[17:46:47.959]   - Field: ‘owner’
[17:46:47.959]   - Field: ‘envir’
[17:46:47.959]   - Field: ‘workers’
[17:46:47.959]   - Field: ‘packages’
[17:46:47.959]   - Field: ‘gc’
[17:46:47.959]   - Field: ‘conditions’
[17:46:47.959]   - Field: ‘persistent’
[17:46:47.959]   - Field: ‘expr’
[17:46:47.960]   - Field: ‘uuid’
[17:46:47.960]   - Field: ‘seed’
[17:46:47.960]   - Field: ‘version’
[17:46:47.960]   - Field: ‘result’
[17:46:47.960]   - Field: ‘asynchronous’
[17:46:47.960]   - Field: ‘calls’
[17:46:47.960]   - Field: ‘globals’
[17:46:47.960]   - Field: ‘stdout’
[17:46:47.960]   - Field: ‘earlySignal’
[17:46:47.960]   - Field: ‘lazy’
[17:46:47.960]   - Field: ‘state’
[17:46:47.961] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.961] - Launch lazy future ...
[17:46:47.961] Packages needed by the future expression (n = 0): <none>
[17:46:47.961] Packages needed by future strategies (n = 0): <none>
[17:46:47.961] {
[17:46:47.961]     {
[17:46:47.961]         {
[17:46:47.961]             ...future.startTime <- base::Sys.time()
[17:46:47.961]             {
[17:46:47.961]                 {
[17:46:47.961]                   {
[17:46:47.961]                     {
[17:46:47.961]                       base::local({
[17:46:47.961]                         has_future <- base::requireNamespace("future", 
[17:46:47.961]                           quietly = TRUE)
[17:46:47.961]                         if (has_future) {
[17:46:47.961]                           ns <- base::getNamespace("future")
[17:46:47.961]                           version <- ns[[".package"]][["version"]]
[17:46:47.961]                           if (is.null(version)) 
[17:46:47.961]                             version <- utils::packageVersion("future")
[17:46:47.961]                         }
[17:46:47.961]                         else {
[17:46:47.961]                           version <- NULL
[17:46:47.961]                         }
[17:46:47.961]                         if (!has_future || version < "1.8.0") {
[17:46:47.961]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.961]                             "", base::R.version$version.string), 
[17:46:47.961]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.961]                               "release", "version")], collapse = " "), 
[17:46:47.961]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.961]                             info)
[17:46:47.961]                           info <- base::paste(info, collapse = "; ")
[17:46:47.961]                           if (!has_future) {
[17:46:47.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.961]                               info)
[17:46:47.961]                           }
[17:46:47.961]                           else {
[17:46:47.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.961]                               info, version)
[17:46:47.961]                           }
[17:46:47.961]                           base::stop(msg)
[17:46:47.961]                         }
[17:46:47.961]                       })
[17:46:47.961]                     }
[17:46:47.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.961]                     base::options(mc.cores = 1L)
[17:46:47.961]                   }
[17:46:47.961]                   ...future.strategy.old <- future::plan("list")
[17:46:47.961]                   options(future.plan = NULL)
[17:46:47.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.961]                 }
[17:46:47.961]                 ...future.workdir <- getwd()
[17:46:47.961]             }
[17:46:47.961]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.961]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.961]         }
[17:46:47.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.961]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.961]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.961]             base::names(...future.oldOptions))
[17:46:47.961]     }
[17:46:47.961]     if (FALSE) {
[17:46:47.961]     }
[17:46:47.961]     else {
[17:46:47.961]         if (TRUE) {
[17:46:47.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.961]                 open = "w")
[17:46:47.961]         }
[17:46:47.961]         else {
[17:46:47.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.961]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.961]         }
[17:46:47.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.961]             base::sink(type = "output", split = FALSE)
[17:46:47.961]             base::close(...future.stdout)
[17:46:47.961]         }, add = TRUE)
[17:46:47.961]     }
[17:46:47.961]     ...future.frame <- base::sys.nframe()
[17:46:47.961]     ...future.conditions <- base::list()
[17:46:47.961]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.961]     if (FALSE) {
[17:46:47.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.961]     }
[17:46:47.961]     ...future.result <- base::tryCatch({
[17:46:47.961]         base::withCallingHandlers({
[17:46:47.961]             ...future.value <- base::withVisible(base::local({
[17:46:47.961]                 ...future.makeSendCondition <- base::local({
[17:46:47.961]                   sendCondition <- NULL
[17:46:47.961]                   function(frame = 1L) {
[17:46:47.961]                     if (is.function(sendCondition)) 
[17:46:47.961]                       return(sendCondition)
[17:46:47.961]                     ns <- getNamespace("parallel")
[17:46:47.961]                     if (exists("sendData", mode = "function", 
[17:46:47.961]                       envir = ns)) {
[17:46:47.961]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.961]                         envir = ns)
[17:46:47.961]                       envir <- sys.frame(frame)
[17:46:47.961]                       master <- NULL
[17:46:47.961]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.961]                         !identical(envir, emptyenv())) {
[17:46:47.961]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.961]                           inherits = FALSE)) {
[17:46:47.961]                           master <- get("master", mode = "list", 
[17:46:47.961]                             envir = envir, inherits = FALSE)
[17:46:47.961]                           if (inherits(master, c("SOCKnode", 
[17:46:47.961]                             "SOCK0node"))) {
[17:46:47.961]                             sendCondition <<- function(cond) {
[17:46:47.961]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.961]                                 success = TRUE)
[17:46:47.961]                               parallel_sendData(master, data)
[17:46:47.961]                             }
[17:46:47.961]                             return(sendCondition)
[17:46:47.961]                           }
[17:46:47.961]                         }
[17:46:47.961]                         frame <- frame + 1L
[17:46:47.961]                         envir <- sys.frame(frame)
[17:46:47.961]                       }
[17:46:47.961]                     }
[17:46:47.961]                     sendCondition <<- function(cond) NULL
[17:46:47.961]                   }
[17:46:47.961]                 })
[17:46:47.961]                 withCallingHandlers({
[17:46:47.961]                   2
[17:46:47.961]                 }, immediateCondition = function(cond) {
[17:46:47.961]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.961]                   sendCondition(cond)
[17:46:47.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.961]                   {
[17:46:47.961]                     inherits <- base::inherits
[17:46:47.961]                     invokeRestart <- base::invokeRestart
[17:46:47.961]                     is.null <- base::is.null
[17:46:47.961]                     muffled <- FALSE
[17:46:47.961]                     if (inherits(cond, "message")) {
[17:46:47.961]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.961]                       if (muffled) 
[17:46:47.961]                         invokeRestart("muffleMessage")
[17:46:47.961]                     }
[17:46:47.961]                     else if (inherits(cond, "warning")) {
[17:46:47.961]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.961]                       if (muffled) 
[17:46:47.961]                         invokeRestart("muffleWarning")
[17:46:47.961]                     }
[17:46:47.961]                     else if (inherits(cond, "condition")) {
[17:46:47.961]                       if (!is.null(pattern)) {
[17:46:47.961]                         computeRestarts <- base::computeRestarts
[17:46:47.961]                         grepl <- base::grepl
[17:46:47.961]                         restarts <- computeRestarts(cond)
[17:46:47.961]                         for (restart in restarts) {
[17:46:47.961]                           name <- restart$name
[17:46:47.961]                           if (is.null(name)) 
[17:46:47.961]                             next
[17:46:47.961]                           if (!grepl(pattern, name)) 
[17:46:47.961]                             next
[17:46:47.961]                           invokeRestart(restart)
[17:46:47.961]                           muffled <- TRUE
[17:46:47.961]                           break
[17:46:47.961]                         }
[17:46:47.961]                       }
[17:46:47.961]                     }
[17:46:47.961]                     invisible(muffled)
[17:46:47.961]                   }
[17:46:47.961]                   muffleCondition(cond)
[17:46:47.961]                 })
[17:46:47.961]             }))
[17:46:47.961]             future::FutureResult(value = ...future.value$value, 
[17:46:47.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.961]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.961]                     ...future.globalenv.names))
[17:46:47.961]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.961]         }, condition = base::local({
[17:46:47.961]             c <- base::c
[17:46:47.961]             inherits <- base::inherits
[17:46:47.961]             invokeRestart <- base::invokeRestart
[17:46:47.961]             length <- base::length
[17:46:47.961]             list <- base::list
[17:46:47.961]             seq.int <- base::seq.int
[17:46:47.961]             signalCondition <- base::signalCondition
[17:46:47.961]             sys.calls <- base::sys.calls
[17:46:47.961]             `[[` <- base::`[[`
[17:46:47.961]             `+` <- base::`+`
[17:46:47.961]             `<<-` <- base::`<<-`
[17:46:47.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.961]                   3L)]
[17:46:47.961]             }
[17:46:47.961]             function(cond) {
[17:46:47.961]                 is_error <- inherits(cond, "error")
[17:46:47.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.961]                   NULL)
[17:46:47.961]                 if (is_error) {
[17:46:47.961]                   sessionInformation <- function() {
[17:46:47.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.961]                       search = base::search(), system = base::Sys.info())
[17:46:47.961]                   }
[17:46:47.961]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.961]                     cond$call), session = sessionInformation(), 
[17:46:47.961]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.961]                   signalCondition(cond)
[17:46:47.961]                 }
[17:46:47.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.961]                 "immediateCondition"))) {
[17:46:47.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.961]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.961]                   if (TRUE && !signal) {
[17:46:47.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.961]                     {
[17:46:47.961]                       inherits <- base::inherits
[17:46:47.961]                       invokeRestart <- base::invokeRestart
[17:46:47.961]                       is.null <- base::is.null
[17:46:47.961]                       muffled <- FALSE
[17:46:47.961]                       if (inherits(cond, "message")) {
[17:46:47.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.961]                         if (muffled) 
[17:46:47.961]                           invokeRestart("muffleMessage")
[17:46:47.961]                       }
[17:46:47.961]                       else if (inherits(cond, "warning")) {
[17:46:47.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.961]                         if (muffled) 
[17:46:47.961]                           invokeRestart("muffleWarning")
[17:46:47.961]                       }
[17:46:47.961]                       else if (inherits(cond, "condition")) {
[17:46:47.961]                         if (!is.null(pattern)) {
[17:46:47.961]                           computeRestarts <- base::computeRestarts
[17:46:47.961]                           grepl <- base::grepl
[17:46:47.961]                           restarts <- computeRestarts(cond)
[17:46:47.961]                           for (restart in restarts) {
[17:46:47.961]                             name <- restart$name
[17:46:47.961]                             if (is.null(name)) 
[17:46:47.961]                               next
[17:46:47.961]                             if (!grepl(pattern, name)) 
[17:46:47.961]                               next
[17:46:47.961]                             invokeRestart(restart)
[17:46:47.961]                             muffled <- TRUE
[17:46:47.961]                             break
[17:46:47.961]                           }
[17:46:47.961]                         }
[17:46:47.961]                       }
[17:46:47.961]                       invisible(muffled)
[17:46:47.961]                     }
[17:46:47.961]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.961]                   }
[17:46:47.961]                 }
[17:46:47.961]                 else {
[17:46:47.961]                   if (TRUE) {
[17:46:47.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.961]                     {
[17:46:47.961]                       inherits <- base::inherits
[17:46:47.961]                       invokeRestart <- base::invokeRestart
[17:46:47.961]                       is.null <- base::is.null
[17:46:47.961]                       muffled <- FALSE
[17:46:47.961]                       if (inherits(cond, "message")) {
[17:46:47.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.961]                         if (muffled) 
[17:46:47.961]                           invokeRestart("muffleMessage")
[17:46:47.961]                       }
[17:46:47.961]                       else if (inherits(cond, "warning")) {
[17:46:47.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.961]                         if (muffled) 
[17:46:47.961]                           invokeRestart("muffleWarning")
[17:46:47.961]                       }
[17:46:47.961]                       else if (inherits(cond, "condition")) {
[17:46:47.961]                         if (!is.null(pattern)) {
[17:46:47.961]                           computeRestarts <- base::computeRestarts
[17:46:47.961]                           grepl <- base::grepl
[17:46:47.961]                           restarts <- computeRestarts(cond)
[17:46:47.961]                           for (restart in restarts) {
[17:46:47.961]                             name <- restart$name
[17:46:47.961]                             if (is.null(name)) 
[17:46:47.961]                               next
[17:46:47.961]                             if (!grepl(pattern, name)) 
[17:46:47.961]                               next
[17:46:47.961]                             invokeRestart(restart)
[17:46:47.961]                             muffled <- TRUE
[17:46:47.961]                             break
[17:46:47.961]                           }
[17:46:47.961]                         }
[17:46:47.961]                       }
[17:46:47.961]                       invisible(muffled)
[17:46:47.961]                     }
[17:46:47.961]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.961]                   }
[17:46:47.961]                 }
[17:46:47.961]             }
[17:46:47.961]         }))
[17:46:47.961]     }, error = function(ex) {
[17:46:47.961]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.961]                 ...future.rng), started = ...future.startTime, 
[17:46:47.961]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.961]             version = "1.8"), class = "FutureResult")
[17:46:47.961]     }, finally = {
[17:46:47.961]         if (!identical(...future.workdir, getwd())) 
[17:46:47.961]             setwd(...future.workdir)
[17:46:47.961]         {
[17:46:47.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.961]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.961]             }
[17:46:47.961]             base::options(...future.oldOptions)
[17:46:47.961]             if (.Platform$OS.type == "windows") {
[17:46:47.961]                 old_names <- names(...future.oldEnvVars)
[17:46:47.961]                 envs <- base::Sys.getenv()
[17:46:47.961]                 names <- names(envs)
[17:46:47.961]                 common <- intersect(names, old_names)
[17:46:47.961]                 added <- setdiff(names, old_names)
[17:46:47.961]                 removed <- setdiff(old_names, names)
[17:46:47.961]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.961]                   envs[common]]
[17:46:47.961]                 NAMES <- toupper(changed)
[17:46:47.961]                 args <- list()
[17:46:47.961]                 for (kk in seq_along(NAMES)) {
[17:46:47.961]                   name <- changed[[kk]]
[17:46:47.961]                   NAME <- NAMES[[kk]]
[17:46:47.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.961]                     next
[17:46:47.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.961]                 }
[17:46:47.961]                 NAMES <- toupper(added)
[17:46:47.961]                 for (kk in seq_along(NAMES)) {
[17:46:47.961]                   name <- added[[kk]]
[17:46:47.961]                   NAME <- NAMES[[kk]]
[17:46:47.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.961]                     next
[17:46:47.961]                   args[[name]] <- ""
[17:46:47.961]                 }
[17:46:47.961]                 NAMES <- toupper(removed)
[17:46:47.961]                 for (kk in seq_along(NAMES)) {
[17:46:47.961]                   name <- removed[[kk]]
[17:46:47.961]                   NAME <- NAMES[[kk]]
[17:46:47.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.961]                     next
[17:46:47.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.961]                 }
[17:46:47.961]                 if (length(args) > 0) 
[17:46:47.961]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.961]             }
[17:46:47.961]             else {
[17:46:47.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.961]             }
[17:46:47.961]             {
[17:46:47.961]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.961]                   0L) {
[17:46:47.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.961]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.961]                   base::options(opts)
[17:46:47.961]                 }
[17:46:47.961]                 {
[17:46:47.961]                   {
[17:46:47.961]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.961]                     NULL
[17:46:47.961]                   }
[17:46:47.961]                   options(future.plan = NULL)
[17:46:47.961]                   if (is.na(NA_character_)) 
[17:46:47.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.961]                     .init = FALSE)
[17:46:47.961]                 }
[17:46:47.961]             }
[17:46:47.961]         }
[17:46:47.961]     })
[17:46:47.961]     if (TRUE) {
[17:46:47.961]         base::sink(type = "output", split = FALSE)
[17:46:47.961]         if (TRUE) {
[17:46:47.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.961]         }
[17:46:47.961]         else {
[17:46:47.961]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.961]         }
[17:46:47.961]         base::close(...future.stdout)
[17:46:47.961]         ...future.stdout <- NULL
[17:46:47.961]     }
[17:46:47.961]     ...future.result$conditions <- ...future.conditions
[17:46:47.961]     ...future.result$finished <- base::Sys.time()
[17:46:47.961]     ...future.result
[17:46:47.961] }
[17:46:47.964] MultisessionFuture started
[17:46:47.964] - Launch lazy future ... done
[17:46:47.964] run() for ‘MultisessionFuture’ ... done
[17:46:47.965] getGlobalsAndPackages() ...
[17:46:47.965] Searching for globals...
[17:46:47.965] 
[17:46:47.965] Searching for globals ... DONE
[17:46:47.965] - globals: [0] <none>
[17:46:47.965] getGlobalsAndPackages() ... DONE
[17:46:47.965] run() for ‘Future’ ...
[17:46:47.966] - state: ‘created’
[17:46:47.966] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:47.979] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:47.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:47.982]   - Field: ‘node’
[17:46:47.982]   - Field: ‘label’
[17:46:47.982]   - Field: ‘local’
[17:46:47.982]   - Field: ‘owner’
[17:46:47.982]   - Field: ‘envir’
[17:46:47.982]   - Field: ‘workers’
[17:46:47.983]   - Field: ‘packages’
[17:46:47.983]   - Field: ‘gc’
[17:46:47.983]   - Field: ‘conditions’
[17:46:47.983]   - Field: ‘persistent’
[17:46:47.983]   - Field: ‘expr’
[17:46:47.983]   - Field: ‘uuid’
[17:46:47.983]   - Field: ‘seed’
[17:46:47.983]   - Field: ‘version’
[17:46:47.983]   - Field: ‘result’
[17:46:47.983]   - Field: ‘asynchronous’
[17:46:47.984]   - Field: ‘calls’
[17:46:47.984]   - Field: ‘globals’
[17:46:47.984]   - Field: ‘stdout’
[17:46:47.984]   - Field: ‘earlySignal’
[17:46:47.984]   - Field: ‘lazy’
[17:46:47.984]   - Field: ‘state’
[17:46:47.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:47.984] - Launch lazy future ...
[17:46:47.984] Packages needed by the future expression (n = 0): <none>
[17:46:47.985] Packages needed by future strategies (n = 0): <none>
[17:46:47.985] {
[17:46:47.985]     {
[17:46:47.985]         {
[17:46:47.985]             ...future.startTime <- base::Sys.time()
[17:46:47.985]             {
[17:46:47.985]                 {
[17:46:47.985]                   {
[17:46:47.985]                     {
[17:46:47.985]                       base::local({
[17:46:47.985]                         has_future <- base::requireNamespace("future", 
[17:46:47.985]                           quietly = TRUE)
[17:46:47.985]                         if (has_future) {
[17:46:47.985]                           ns <- base::getNamespace("future")
[17:46:47.985]                           version <- ns[[".package"]][["version"]]
[17:46:47.985]                           if (is.null(version)) 
[17:46:47.985]                             version <- utils::packageVersion("future")
[17:46:47.985]                         }
[17:46:47.985]                         else {
[17:46:47.985]                           version <- NULL
[17:46:47.985]                         }
[17:46:47.985]                         if (!has_future || version < "1.8.0") {
[17:46:47.985]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:47.985]                             "", base::R.version$version.string), 
[17:46:47.985]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:47.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:47.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:47.985]                               "release", "version")], collapse = " "), 
[17:46:47.985]                             hostname = base::Sys.info()[["nodename"]])
[17:46:47.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:47.985]                             info)
[17:46:47.985]                           info <- base::paste(info, collapse = "; ")
[17:46:47.985]                           if (!has_future) {
[17:46:47.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:47.985]                               info)
[17:46:47.985]                           }
[17:46:47.985]                           else {
[17:46:47.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:47.985]                               info, version)
[17:46:47.985]                           }
[17:46:47.985]                           base::stop(msg)
[17:46:47.985]                         }
[17:46:47.985]                       })
[17:46:47.985]                     }
[17:46:47.985]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:47.985]                     base::options(mc.cores = 1L)
[17:46:47.985]                   }
[17:46:47.985]                   ...future.strategy.old <- future::plan("list")
[17:46:47.985]                   options(future.plan = NULL)
[17:46:47.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:47.985]                 }
[17:46:47.985]                 ...future.workdir <- getwd()
[17:46:47.985]             }
[17:46:47.985]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:47.985]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:47.985]         }
[17:46:47.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:47.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:47.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:47.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:47.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:47.985]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:47.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:47.985]             base::names(...future.oldOptions))
[17:46:47.985]     }
[17:46:47.985]     if (FALSE) {
[17:46:47.985]     }
[17:46:47.985]     else {
[17:46:47.985]         if (TRUE) {
[17:46:47.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:47.985]                 open = "w")
[17:46:47.985]         }
[17:46:47.985]         else {
[17:46:47.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:47.985]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:47.985]         }
[17:46:47.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:47.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:47.985]             base::sink(type = "output", split = FALSE)
[17:46:47.985]             base::close(...future.stdout)
[17:46:47.985]         }, add = TRUE)
[17:46:47.985]     }
[17:46:47.985]     ...future.frame <- base::sys.nframe()
[17:46:47.985]     ...future.conditions <- base::list()
[17:46:47.985]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:47.985]     if (FALSE) {
[17:46:47.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:47.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:47.985]     }
[17:46:47.985]     ...future.result <- base::tryCatch({
[17:46:47.985]         base::withCallingHandlers({
[17:46:47.985]             ...future.value <- base::withVisible(base::local({
[17:46:47.985]                 ...future.makeSendCondition <- base::local({
[17:46:47.985]                   sendCondition <- NULL
[17:46:47.985]                   function(frame = 1L) {
[17:46:47.985]                     if (is.function(sendCondition)) 
[17:46:47.985]                       return(sendCondition)
[17:46:47.985]                     ns <- getNamespace("parallel")
[17:46:47.985]                     if (exists("sendData", mode = "function", 
[17:46:47.985]                       envir = ns)) {
[17:46:47.985]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:47.985]                         envir = ns)
[17:46:47.985]                       envir <- sys.frame(frame)
[17:46:47.985]                       master <- NULL
[17:46:47.985]                       while (!identical(envir, .GlobalEnv) && 
[17:46:47.985]                         !identical(envir, emptyenv())) {
[17:46:47.985]                         if (exists("master", mode = "list", envir = envir, 
[17:46:47.985]                           inherits = FALSE)) {
[17:46:47.985]                           master <- get("master", mode = "list", 
[17:46:47.985]                             envir = envir, inherits = FALSE)
[17:46:47.985]                           if (inherits(master, c("SOCKnode", 
[17:46:47.985]                             "SOCK0node"))) {
[17:46:47.985]                             sendCondition <<- function(cond) {
[17:46:47.985]                               data <- list(type = "VALUE", value = cond, 
[17:46:47.985]                                 success = TRUE)
[17:46:47.985]                               parallel_sendData(master, data)
[17:46:47.985]                             }
[17:46:47.985]                             return(sendCondition)
[17:46:47.985]                           }
[17:46:47.985]                         }
[17:46:47.985]                         frame <- frame + 1L
[17:46:47.985]                         envir <- sys.frame(frame)
[17:46:47.985]                       }
[17:46:47.985]                     }
[17:46:47.985]                     sendCondition <<- function(cond) NULL
[17:46:47.985]                   }
[17:46:47.985]                 })
[17:46:47.985]                 withCallingHandlers({
[17:46:47.985]                   NULL
[17:46:47.985]                 }, immediateCondition = function(cond) {
[17:46:47.985]                   sendCondition <- ...future.makeSendCondition()
[17:46:47.985]                   sendCondition(cond)
[17:46:47.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.985]                   {
[17:46:47.985]                     inherits <- base::inherits
[17:46:47.985]                     invokeRestart <- base::invokeRestart
[17:46:47.985]                     is.null <- base::is.null
[17:46:47.985]                     muffled <- FALSE
[17:46:47.985]                     if (inherits(cond, "message")) {
[17:46:47.985]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:47.985]                       if (muffled) 
[17:46:47.985]                         invokeRestart("muffleMessage")
[17:46:47.985]                     }
[17:46:47.985]                     else if (inherits(cond, "warning")) {
[17:46:47.985]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:47.985]                       if (muffled) 
[17:46:47.985]                         invokeRestart("muffleWarning")
[17:46:47.985]                     }
[17:46:47.985]                     else if (inherits(cond, "condition")) {
[17:46:47.985]                       if (!is.null(pattern)) {
[17:46:47.985]                         computeRestarts <- base::computeRestarts
[17:46:47.985]                         grepl <- base::grepl
[17:46:47.985]                         restarts <- computeRestarts(cond)
[17:46:47.985]                         for (restart in restarts) {
[17:46:47.985]                           name <- restart$name
[17:46:47.985]                           if (is.null(name)) 
[17:46:47.985]                             next
[17:46:47.985]                           if (!grepl(pattern, name)) 
[17:46:47.985]                             next
[17:46:47.985]                           invokeRestart(restart)
[17:46:47.985]                           muffled <- TRUE
[17:46:47.985]                           break
[17:46:47.985]                         }
[17:46:47.985]                       }
[17:46:47.985]                     }
[17:46:47.985]                     invisible(muffled)
[17:46:47.985]                   }
[17:46:47.985]                   muffleCondition(cond)
[17:46:47.985]                 })
[17:46:47.985]             }))
[17:46:47.985]             future::FutureResult(value = ...future.value$value, 
[17:46:47.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.985]                   ...future.rng), globalenv = if (FALSE) 
[17:46:47.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:47.985]                     ...future.globalenv.names))
[17:46:47.985]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:47.985]         }, condition = base::local({
[17:46:47.985]             c <- base::c
[17:46:47.985]             inherits <- base::inherits
[17:46:47.985]             invokeRestart <- base::invokeRestart
[17:46:47.985]             length <- base::length
[17:46:47.985]             list <- base::list
[17:46:47.985]             seq.int <- base::seq.int
[17:46:47.985]             signalCondition <- base::signalCondition
[17:46:47.985]             sys.calls <- base::sys.calls
[17:46:47.985]             `[[` <- base::`[[`
[17:46:47.985]             `+` <- base::`+`
[17:46:47.985]             `<<-` <- base::`<<-`
[17:46:47.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:47.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:47.985]                   3L)]
[17:46:47.985]             }
[17:46:47.985]             function(cond) {
[17:46:47.985]                 is_error <- inherits(cond, "error")
[17:46:47.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:47.985]                   NULL)
[17:46:47.985]                 if (is_error) {
[17:46:47.985]                   sessionInformation <- function() {
[17:46:47.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:47.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:47.985]                       search = base::search(), system = base::Sys.info())
[17:46:47.985]                   }
[17:46:47.985]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:47.985]                     cond$call), session = sessionInformation(), 
[17:46:47.985]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:47.985]                   signalCondition(cond)
[17:46:47.985]                 }
[17:46:47.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:47.985]                 "immediateCondition"))) {
[17:46:47.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:47.985]                   ...future.conditions[[length(...future.conditions) + 
[17:46:47.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:47.985]                   if (TRUE && !signal) {
[17:46:47.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.985]                     {
[17:46:47.985]                       inherits <- base::inherits
[17:46:47.985]                       invokeRestart <- base::invokeRestart
[17:46:47.985]                       is.null <- base::is.null
[17:46:47.985]                       muffled <- FALSE
[17:46:47.985]                       if (inherits(cond, "message")) {
[17:46:47.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.985]                         if (muffled) 
[17:46:47.985]                           invokeRestart("muffleMessage")
[17:46:47.985]                       }
[17:46:47.985]                       else if (inherits(cond, "warning")) {
[17:46:47.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.985]                         if (muffled) 
[17:46:47.985]                           invokeRestart("muffleWarning")
[17:46:47.985]                       }
[17:46:47.985]                       else if (inherits(cond, "condition")) {
[17:46:47.985]                         if (!is.null(pattern)) {
[17:46:47.985]                           computeRestarts <- base::computeRestarts
[17:46:47.985]                           grepl <- base::grepl
[17:46:47.985]                           restarts <- computeRestarts(cond)
[17:46:47.985]                           for (restart in restarts) {
[17:46:47.985]                             name <- restart$name
[17:46:47.985]                             if (is.null(name)) 
[17:46:47.985]                               next
[17:46:47.985]                             if (!grepl(pattern, name)) 
[17:46:47.985]                               next
[17:46:47.985]                             invokeRestart(restart)
[17:46:47.985]                             muffled <- TRUE
[17:46:47.985]                             break
[17:46:47.985]                           }
[17:46:47.985]                         }
[17:46:47.985]                       }
[17:46:47.985]                       invisible(muffled)
[17:46:47.985]                     }
[17:46:47.985]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.985]                   }
[17:46:47.985]                 }
[17:46:47.985]                 else {
[17:46:47.985]                   if (TRUE) {
[17:46:47.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:47.985]                     {
[17:46:47.985]                       inherits <- base::inherits
[17:46:47.985]                       invokeRestart <- base::invokeRestart
[17:46:47.985]                       is.null <- base::is.null
[17:46:47.985]                       muffled <- FALSE
[17:46:47.985]                       if (inherits(cond, "message")) {
[17:46:47.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:47.985]                         if (muffled) 
[17:46:47.985]                           invokeRestart("muffleMessage")
[17:46:47.985]                       }
[17:46:47.985]                       else if (inherits(cond, "warning")) {
[17:46:47.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:47.985]                         if (muffled) 
[17:46:47.985]                           invokeRestart("muffleWarning")
[17:46:47.985]                       }
[17:46:47.985]                       else if (inherits(cond, "condition")) {
[17:46:47.985]                         if (!is.null(pattern)) {
[17:46:47.985]                           computeRestarts <- base::computeRestarts
[17:46:47.985]                           grepl <- base::grepl
[17:46:47.985]                           restarts <- computeRestarts(cond)
[17:46:47.985]                           for (restart in restarts) {
[17:46:47.985]                             name <- restart$name
[17:46:47.985]                             if (is.null(name)) 
[17:46:47.985]                               next
[17:46:47.985]                             if (!grepl(pattern, name)) 
[17:46:47.985]                               next
[17:46:47.985]                             invokeRestart(restart)
[17:46:47.985]                             muffled <- TRUE
[17:46:47.985]                             break
[17:46:47.985]                           }
[17:46:47.985]                         }
[17:46:47.985]                       }
[17:46:47.985]                       invisible(muffled)
[17:46:47.985]                     }
[17:46:47.985]                     muffleCondition(cond, pattern = "^muffle")
[17:46:47.985]                   }
[17:46:47.985]                 }
[17:46:47.985]             }
[17:46:47.985]         }))
[17:46:47.985]     }, error = function(ex) {
[17:46:47.985]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:47.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:47.985]                 ...future.rng), started = ...future.startTime, 
[17:46:47.985]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:47.985]             version = "1.8"), class = "FutureResult")
[17:46:47.985]     }, finally = {
[17:46:47.985]         if (!identical(...future.workdir, getwd())) 
[17:46:47.985]             setwd(...future.workdir)
[17:46:47.985]         {
[17:46:47.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:47.985]                 ...future.oldOptions$nwarnings <- NULL
[17:46:47.985]             }
[17:46:47.985]             base::options(...future.oldOptions)
[17:46:47.985]             if (.Platform$OS.type == "windows") {
[17:46:47.985]                 old_names <- names(...future.oldEnvVars)
[17:46:47.985]                 envs <- base::Sys.getenv()
[17:46:47.985]                 names <- names(envs)
[17:46:47.985]                 common <- intersect(names, old_names)
[17:46:47.985]                 added <- setdiff(names, old_names)
[17:46:47.985]                 removed <- setdiff(old_names, names)
[17:46:47.985]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:47.985]                   envs[common]]
[17:46:47.985]                 NAMES <- toupper(changed)
[17:46:47.985]                 args <- list()
[17:46:47.985]                 for (kk in seq_along(NAMES)) {
[17:46:47.985]                   name <- changed[[kk]]
[17:46:47.985]                   NAME <- NAMES[[kk]]
[17:46:47.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.985]                     next
[17:46:47.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.985]                 }
[17:46:47.985]                 NAMES <- toupper(added)
[17:46:47.985]                 for (kk in seq_along(NAMES)) {
[17:46:47.985]                   name <- added[[kk]]
[17:46:47.985]                   NAME <- NAMES[[kk]]
[17:46:47.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.985]                     next
[17:46:47.985]                   args[[name]] <- ""
[17:46:47.985]                 }
[17:46:47.985]                 NAMES <- toupper(removed)
[17:46:47.985]                 for (kk in seq_along(NAMES)) {
[17:46:47.985]                   name <- removed[[kk]]
[17:46:47.985]                   NAME <- NAMES[[kk]]
[17:46:47.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:47.985]                     next
[17:46:47.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:47.985]                 }
[17:46:47.985]                 if (length(args) > 0) 
[17:46:47.985]                   base::do.call(base::Sys.setenv, args = args)
[17:46:47.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:47.985]             }
[17:46:47.985]             else {
[17:46:47.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:47.985]             }
[17:46:47.985]             {
[17:46:47.985]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:47.985]                   0L) {
[17:46:47.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:47.985]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:47.985]                   base::options(opts)
[17:46:47.985]                 }
[17:46:47.985]                 {
[17:46:47.985]                   {
[17:46:47.985]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:47.985]                     NULL
[17:46:47.985]                   }
[17:46:47.985]                   options(future.plan = NULL)
[17:46:47.985]                   if (is.na(NA_character_)) 
[17:46:47.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:47.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:47.985]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:47.985]                     .init = FALSE)
[17:46:47.985]                 }
[17:46:47.985]             }
[17:46:47.985]         }
[17:46:47.985]     })
[17:46:47.985]     if (TRUE) {
[17:46:47.985]         base::sink(type = "output", split = FALSE)
[17:46:47.985]         if (TRUE) {
[17:46:47.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:47.985]         }
[17:46:47.985]         else {
[17:46:47.985]             ...future.result["stdout"] <- base::list(NULL)
[17:46:47.985]         }
[17:46:47.985]         base::close(...future.stdout)
[17:46:47.985]         ...future.stdout <- NULL
[17:46:47.985]     }
[17:46:47.985]     ...future.result$conditions <- ...future.conditions
[17:46:47.985]     ...future.result$finished <- base::Sys.time()
[17:46:47.985]     ...future.result
[17:46:47.985] }
[17:46:47.988] MultisessionFuture started
[17:46:47.988] - Launch lazy future ... done
[17:46:47.988] run() for ‘MultisessionFuture’ ... done
[17:46:47.988] getGlobalsAndPackages() ...
[17:46:47.988] Searching for globals...
[17:46:47.989] - globals found: [1] ‘{’
[17:46:47.989] Searching for globals ... DONE
[17:46:47.989] Resolving globals: FALSE
[17:46:47.989] 
[17:46:47.990] 
[17:46:47.990] getGlobalsAndPackages() ... DONE
[17:46:47.990] run() for ‘Future’ ...
[17:46:47.990] - state: ‘created’
[17:46:47.990] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.003] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:48.004]   - Field: ‘node’
[17:46:48.004]   - Field: ‘label’
[17:46:48.004]   - Field: ‘local’
[17:46:48.004]   - Field: ‘owner’
[17:46:48.004]   - Field: ‘envir’
[17:46:48.004]   - Field: ‘workers’
[17:46:48.004]   - Field: ‘packages’
[17:46:48.004]   - Field: ‘gc’
[17:46:48.004]   - Field: ‘conditions’
[17:46:48.004]   - Field: ‘persistent’
[17:46:48.004]   - Field: ‘expr’
[17:46:48.005]   - Field: ‘uuid’
[17:46:48.005]   - Field: ‘seed’
[17:46:48.005]   - Field: ‘version’
[17:46:48.005]   - Field: ‘result’
[17:46:48.005]   - Field: ‘asynchronous’
[17:46:48.005]   - Field: ‘calls’
[17:46:48.005]   - Field: ‘globals’
[17:46:48.005]   - Field: ‘stdout’
[17:46:48.005]   - Field: ‘earlySignal’
[17:46:48.005]   - Field: ‘lazy’
[17:46:48.005]   - Field: ‘state’
[17:46:48.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:48.006] - Launch lazy future ...
[17:46:48.006] Packages needed by the future expression (n = 0): <none>
[17:46:48.006] Packages needed by future strategies (n = 0): <none>
[17:46:48.006] {
[17:46:48.006]     {
[17:46:48.006]         {
[17:46:48.006]             ...future.startTime <- base::Sys.time()
[17:46:48.006]             {
[17:46:48.006]                 {
[17:46:48.006]                   {
[17:46:48.006]                     {
[17:46:48.006]                       base::local({
[17:46:48.006]                         has_future <- base::requireNamespace("future", 
[17:46:48.006]                           quietly = TRUE)
[17:46:48.006]                         if (has_future) {
[17:46:48.006]                           ns <- base::getNamespace("future")
[17:46:48.006]                           version <- ns[[".package"]][["version"]]
[17:46:48.006]                           if (is.null(version)) 
[17:46:48.006]                             version <- utils::packageVersion("future")
[17:46:48.006]                         }
[17:46:48.006]                         else {
[17:46:48.006]                           version <- NULL
[17:46:48.006]                         }
[17:46:48.006]                         if (!has_future || version < "1.8.0") {
[17:46:48.006]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.006]                             "", base::R.version$version.string), 
[17:46:48.006]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.006]                               "release", "version")], collapse = " "), 
[17:46:48.006]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.006]                             info)
[17:46:48.006]                           info <- base::paste(info, collapse = "; ")
[17:46:48.006]                           if (!has_future) {
[17:46:48.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.006]                               info)
[17:46:48.006]                           }
[17:46:48.006]                           else {
[17:46:48.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.006]                               info, version)
[17:46:48.006]                           }
[17:46:48.006]                           base::stop(msg)
[17:46:48.006]                         }
[17:46:48.006]                       })
[17:46:48.006]                     }
[17:46:48.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.006]                     base::options(mc.cores = 1L)
[17:46:48.006]                   }
[17:46:48.006]                   ...future.strategy.old <- future::plan("list")
[17:46:48.006]                   options(future.plan = NULL)
[17:46:48.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.006]                 }
[17:46:48.006]                 ...future.workdir <- getwd()
[17:46:48.006]             }
[17:46:48.006]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.006]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.006]         }
[17:46:48.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.006]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.006]             base::names(...future.oldOptions))
[17:46:48.006]     }
[17:46:48.006]     if (FALSE) {
[17:46:48.006]     }
[17:46:48.006]     else {
[17:46:48.006]         if (TRUE) {
[17:46:48.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.006]                 open = "w")
[17:46:48.006]         }
[17:46:48.006]         else {
[17:46:48.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.006]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.006]         }
[17:46:48.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.006]             base::sink(type = "output", split = FALSE)
[17:46:48.006]             base::close(...future.stdout)
[17:46:48.006]         }, add = TRUE)
[17:46:48.006]     }
[17:46:48.006]     ...future.frame <- base::sys.nframe()
[17:46:48.006]     ...future.conditions <- base::list()
[17:46:48.006]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.006]     if (FALSE) {
[17:46:48.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.006]     }
[17:46:48.006]     ...future.result <- base::tryCatch({
[17:46:48.006]         base::withCallingHandlers({
[17:46:48.006]             ...future.value <- base::withVisible(base::local({
[17:46:48.006]                 ...future.makeSendCondition <- base::local({
[17:46:48.006]                   sendCondition <- NULL
[17:46:48.006]                   function(frame = 1L) {
[17:46:48.006]                     if (is.function(sendCondition)) 
[17:46:48.006]                       return(sendCondition)
[17:46:48.006]                     ns <- getNamespace("parallel")
[17:46:48.006]                     if (exists("sendData", mode = "function", 
[17:46:48.006]                       envir = ns)) {
[17:46:48.006]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:48.006]                         envir = ns)
[17:46:48.006]                       envir <- sys.frame(frame)
[17:46:48.006]                       master <- NULL
[17:46:48.006]                       while (!identical(envir, .GlobalEnv) && 
[17:46:48.006]                         !identical(envir, emptyenv())) {
[17:46:48.006]                         if (exists("master", mode = "list", envir = envir, 
[17:46:48.006]                           inherits = FALSE)) {
[17:46:48.006]                           master <- get("master", mode = "list", 
[17:46:48.006]                             envir = envir, inherits = FALSE)
[17:46:48.006]                           if (inherits(master, c("SOCKnode", 
[17:46:48.006]                             "SOCK0node"))) {
[17:46:48.006]                             sendCondition <<- function(cond) {
[17:46:48.006]                               data <- list(type = "VALUE", value = cond, 
[17:46:48.006]                                 success = TRUE)
[17:46:48.006]                               parallel_sendData(master, data)
[17:46:48.006]                             }
[17:46:48.006]                             return(sendCondition)
[17:46:48.006]                           }
[17:46:48.006]                         }
[17:46:48.006]                         frame <- frame + 1L
[17:46:48.006]                         envir <- sys.frame(frame)
[17:46:48.006]                       }
[17:46:48.006]                     }
[17:46:48.006]                     sendCondition <<- function(cond) NULL
[17:46:48.006]                   }
[17:46:48.006]                 })
[17:46:48.006]                 withCallingHandlers({
[17:46:48.006]                   {
[17:46:48.006]                     4
[17:46:48.006]                   }
[17:46:48.006]                 }, immediateCondition = function(cond) {
[17:46:48.006]                   sendCondition <- ...future.makeSendCondition()
[17:46:48.006]                   sendCondition(cond)
[17:46:48.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.006]                   {
[17:46:48.006]                     inherits <- base::inherits
[17:46:48.006]                     invokeRestart <- base::invokeRestart
[17:46:48.006]                     is.null <- base::is.null
[17:46:48.006]                     muffled <- FALSE
[17:46:48.006]                     if (inherits(cond, "message")) {
[17:46:48.006]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.006]                       if (muffled) 
[17:46:48.006]                         invokeRestart("muffleMessage")
[17:46:48.006]                     }
[17:46:48.006]                     else if (inherits(cond, "warning")) {
[17:46:48.006]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.006]                       if (muffled) 
[17:46:48.006]                         invokeRestart("muffleWarning")
[17:46:48.006]                     }
[17:46:48.006]                     else if (inherits(cond, "condition")) {
[17:46:48.006]                       if (!is.null(pattern)) {
[17:46:48.006]                         computeRestarts <- base::computeRestarts
[17:46:48.006]                         grepl <- base::grepl
[17:46:48.006]                         restarts <- computeRestarts(cond)
[17:46:48.006]                         for (restart in restarts) {
[17:46:48.006]                           name <- restart$name
[17:46:48.006]                           if (is.null(name)) 
[17:46:48.006]                             next
[17:46:48.006]                           if (!grepl(pattern, name)) 
[17:46:48.006]                             next
[17:46:48.006]                           invokeRestart(restart)
[17:46:48.006]                           muffled <- TRUE
[17:46:48.006]                           break
[17:46:48.006]                         }
[17:46:48.006]                       }
[17:46:48.006]                     }
[17:46:48.006]                     invisible(muffled)
[17:46:48.006]                   }
[17:46:48.006]                   muffleCondition(cond)
[17:46:48.006]                 })
[17:46:48.006]             }))
[17:46:48.006]             future::FutureResult(value = ...future.value$value, 
[17:46:48.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.006]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.006]                     ...future.globalenv.names))
[17:46:48.006]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.006]         }, condition = base::local({
[17:46:48.006]             c <- base::c
[17:46:48.006]             inherits <- base::inherits
[17:46:48.006]             invokeRestart <- base::invokeRestart
[17:46:48.006]             length <- base::length
[17:46:48.006]             list <- base::list
[17:46:48.006]             seq.int <- base::seq.int
[17:46:48.006]             signalCondition <- base::signalCondition
[17:46:48.006]             sys.calls <- base::sys.calls
[17:46:48.006]             `[[` <- base::`[[`
[17:46:48.006]             `+` <- base::`+`
[17:46:48.006]             `<<-` <- base::`<<-`
[17:46:48.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.006]                   3L)]
[17:46:48.006]             }
[17:46:48.006]             function(cond) {
[17:46:48.006]                 is_error <- inherits(cond, "error")
[17:46:48.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.006]                   NULL)
[17:46:48.006]                 if (is_error) {
[17:46:48.006]                   sessionInformation <- function() {
[17:46:48.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.006]                       search = base::search(), system = base::Sys.info())
[17:46:48.006]                   }
[17:46:48.006]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.006]                     cond$call), session = sessionInformation(), 
[17:46:48.006]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.006]                   signalCondition(cond)
[17:46:48.006]                 }
[17:46:48.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.006]                 "immediateCondition"))) {
[17:46:48.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.006]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.006]                   if (TRUE && !signal) {
[17:46:48.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.006]                     {
[17:46:48.006]                       inherits <- base::inherits
[17:46:48.006]                       invokeRestart <- base::invokeRestart
[17:46:48.006]                       is.null <- base::is.null
[17:46:48.006]                       muffled <- FALSE
[17:46:48.006]                       if (inherits(cond, "message")) {
[17:46:48.006]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.006]                         if (muffled) 
[17:46:48.006]                           invokeRestart("muffleMessage")
[17:46:48.006]                       }
[17:46:48.006]                       else if (inherits(cond, "warning")) {
[17:46:48.006]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.006]                         if (muffled) 
[17:46:48.006]                           invokeRestart("muffleWarning")
[17:46:48.006]                       }
[17:46:48.006]                       else if (inherits(cond, "condition")) {
[17:46:48.006]                         if (!is.null(pattern)) {
[17:46:48.006]                           computeRestarts <- base::computeRestarts
[17:46:48.006]                           grepl <- base::grepl
[17:46:48.006]                           restarts <- computeRestarts(cond)
[17:46:48.006]                           for (restart in restarts) {
[17:46:48.006]                             name <- restart$name
[17:46:48.006]                             if (is.null(name)) 
[17:46:48.006]                               next
[17:46:48.006]                             if (!grepl(pattern, name)) 
[17:46:48.006]                               next
[17:46:48.006]                             invokeRestart(restart)
[17:46:48.006]                             muffled <- TRUE
[17:46:48.006]                             break
[17:46:48.006]                           }
[17:46:48.006]                         }
[17:46:48.006]                       }
[17:46:48.006]                       invisible(muffled)
[17:46:48.006]                     }
[17:46:48.006]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.006]                   }
[17:46:48.006]                 }
[17:46:48.006]                 else {
[17:46:48.006]                   if (TRUE) {
[17:46:48.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.006]                     {
[17:46:48.006]                       inherits <- base::inherits
[17:46:48.006]                       invokeRestart <- base::invokeRestart
[17:46:48.006]                       is.null <- base::is.null
[17:46:48.006]                       muffled <- FALSE
[17:46:48.006]                       if (inherits(cond, "message")) {
[17:46:48.006]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.006]                         if (muffled) 
[17:46:48.006]                           invokeRestart("muffleMessage")
[17:46:48.006]                       }
[17:46:48.006]                       else if (inherits(cond, "warning")) {
[17:46:48.006]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.006]                         if (muffled) 
[17:46:48.006]                           invokeRestart("muffleWarning")
[17:46:48.006]                       }
[17:46:48.006]                       else if (inherits(cond, "condition")) {
[17:46:48.006]                         if (!is.null(pattern)) {
[17:46:48.006]                           computeRestarts <- base::computeRestarts
[17:46:48.006]                           grepl <- base::grepl
[17:46:48.006]                           restarts <- computeRestarts(cond)
[17:46:48.006]                           for (restart in restarts) {
[17:46:48.006]                             name <- restart$name
[17:46:48.006]                             if (is.null(name)) 
[17:46:48.006]                               next
[17:46:48.006]                             if (!grepl(pattern, name)) 
[17:46:48.006]                               next
[17:46:48.006]                             invokeRestart(restart)
[17:46:48.006]                             muffled <- TRUE
[17:46:48.006]                             break
[17:46:48.006]                           }
[17:46:48.006]                         }
[17:46:48.006]                       }
[17:46:48.006]                       invisible(muffled)
[17:46:48.006]                     }
[17:46:48.006]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.006]                   }
[17:46:48.006]                 }
[17:46:48.006]             }
[17:46:48.006]         }))
[17:46:48.006]     }, error = function(ex) {
[17:46:48.006]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.006]                 ...future.rng), started = ...future.startTime, 
[17:46:48.006]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.006]             version = "1.8"), class = "FutureResult")
[17:46:48.006]     }, finally = {
[17:46:48.006]         if (!identical(...future.workdir, getwd())) 
[17:46:48.006]             setwd(...future.workdir)
[17:46:48.006]         {
[17:46:48.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.006]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.006]             }
[17:46:48.006]             base::options(...future.oldOptions)
[17:46:48.006]             if (.Platform$OS.type == "windows") {
[17:46:48.006]                 old_names <- names(...future.oldEnvVars)
[17:46:48.006]                 envs <- base::Sys.getenv()
[17:46:48.006]                 names <- names(envs)
[17:46:48.006]                 common <- intersect(names, old_names)
[17:46:48.006]                 added <- setdiff(names, old_names)
[17:46:48.006]                 removed <- setdiff(old_names, names)
[17:46:48.006]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.006]                   envs[common]]
[17:46:48.006]                 NAMES <- toupper(changed)
[17:46:48.006]                 args <- list()
[17:46:48.006]                 for (kk in seq_along(NAMES)) {
[17:46:48.006]                   name <- changed[[kk]]
[17:46:48.006]                   NAME <- NAMES[[kk]]
[17:46:48.006]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.006]                     next
[17:46:48.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.006]                 }
[17:46:48.006]                 NAMES <- toupper(added)
[17:46:48.006]                 for (kk in seq_along(NAMES)) {
[17:46:48.006]                   name <- added[[kk]]
[17:46:48.006]                   NAME <- NAMES[[kk]]
[17:46:48.006]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.006]                     next
[17:46:48.006]                   args[[name]] <- ""
[17:46:48.006]                 }
[17:46:48.006]                 NAMES <- toupper(removed)
[17:46:48.006]                 for (kk in seq_along(NAMES)) {
[17:46:48.006]                   name <- removed[[kk]]
[17:46:48.006]                   NAME <- NAMES[[kk]]
[17:46:48.006]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.006]                     next
[17:46:48.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.006]                 }
[17:46:48.006]                 if (length(args) > 0) 
[17:46:48.006]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.006]             }
[17:46:48.006]             else {
[17:46:48.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.006]             }
[17:46:48.006]             {
[17:46:48.006]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.006]                   0L) {
[17:46:48.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.006]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.006]                   base::options(opts)
[17:46:48.006]                 }
[17:46:48.006]                 {
[17:46:48.006]                   {
[17:46:48.006]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.006]                     NULL
[17:46:48.006]                   }
[17:46:48.006]                   options(future.plan = NULL)
[17:46:48.006]                   if (is.na(NA_character_)) 
[17:46:48.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.006]                     .init = FALSE)
[17:46:48.006]                 }
[17:46:48.006]             }
[17:46:48.006]         }
[17:46:48.006]     })
[17:46:48.006]     if (TRUE) {
[17:46:48.006]         base::sink(type = "output", split = FALSE)
[17:46:48.006]         if (TRUE) {
[17:46:48.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.006]         }
[17:46:48.006]         else {
[17:46:48.006]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.006]         }
[17:46:48.006]         base::close(...future.stdout)
[17:46:48.006]         ...future.stdout <- NULL
[17:46:48.006]     }
[17:46:48.006]     ...future.result$conditions <- ...future.conditions
[17:46:48.006]     ...future.result$finished <- base::Sys.time()
[17:46:48.006]     ...future.result
[17:46:48.006] }
[17:46:48.008] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:48.019] receiveMessageFromWorker() for ClusterFuture ...
[17:46:48.019] - Validating connection of MultisessionFuture
[17:46:48.020] - received message: FutureResult
[17:46:48.020] - Received FutureResult
[17:46:48.020] - Erased future from FutureRegistry
[17:46:48.020] result() for ClusterFuture ...
[17:46:48.020] - result already collected: FutureResult
[17:46:48.020] result() for ClusterFuture ... done
[17:46:48.020] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:48.020] result() for ClusterFuture ...
[17:46:48.020] - result already collected: FutureResult
[17:46:48.020] result() for ClusterFuture ... done
[17:46:48.020] result() for ClusterFuture ...
[17:46:48.021] - result already collected: FutureResult
[17:46:48.021] result() for ClusterFuture ... done
[17:46:48.022] MultisessionFuture started
[17:46:48.022] - Launch lazy future ... done
[17:46:48.022] run() for ‘MultisessionFuture’ ... done
<environment: 0x5617898086f0> 
<environment: 0x561787658768> 
[17:46:48.024] receiveMessageFromWorker() for ClusterFuture ...
[17:46:48.024] - Validating connection of MultisessionFuture
[17:46:48.025] - received message: FutureResult
[17:46:48.025] - Received FutureResult
[17:46:48.025] - Erased future from FutureRegistry
[17:46:48.025] result() for ClusterFuture ...
[17:46:48.025] - result already collected: FutureResult
[17:46:48.025] result() for ClusterFuture ... done
[17:46:48.025] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:48.026] receiveMessageFromWorker() for ClusterFuture ...
[17:46:48.026] - Validating connection of MultisessionFuture
[17:46:48.026] - received message: FutureResult
[17:46:48.026] - Received FutureResult
[17:46:48.026] - Erased future from FutureRegistry
[17:46:48.026] result() for ClusterFuture ...
[17:46:48.026] - result already collected: FutureResult
[17:46:48.026] result() for ClusterFuture ... done
[17:46:48.026] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:46:48.027] resolve() on environment ...
[17:46:48.028]  recursive: 0
[17:46:48.028]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:46:48.028] signalConditionsASAP(numeric, pos=1) ...
[17:46:48.028] - nx: 4
[17:46:48.028] - relay: TRUE
[17:46:48.028] - stdout: TRUE
[17:46:48.029] - signal: TRUE
[17:46:48.029] - resignal: FALSE
[17:46:48.029] - force: TRUE
[17:46:48.029] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:48.029] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:48.029]  - until=2
[17:46:48.029]  - relaying element #2
[17:46:48.029] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:48.029] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:48.029] signalConditionsASAP(NULL, pos=1) ... done
[17:46:48.029]  length: 3 (resolved future 1)
[17:46:48.030] Future #2
[17:46:48.030] result() for ClusterFuture ...
[17:46:48.030] - result already collected: FutureResult
[17:46:48.030] result() for ClusterFuture ... done
[17:46:48.030] result() for ClusterFuture ...
[17:46:48.030] - result already collected: FutureResult
[17:46:48.030] result() for ClusterFuture ... done
[17:46:48.030] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:48.030] - nx: 4
[17:46:48.030] - relay: TRUE
[17:46:48.030] - stdout: TRUE
[17:46:48.030] - signal: TRUE
[17:46:48.031] - resignal: FALSE
[17:46:48.031] - force: TRUE
[17:46:48.031] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:46:48.031] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:46:48.031]  - until=2
[17:46:48.031]  - relaying element #2
[17:46:48.031] result() for ClusterFuture ...
[17:46:48.031] - result already collected: FutureResult
[17:46:48.031] result() for ClusterFuture ... done
[17:46:48.031] result() for ClusterFuture ...
[17:46:48.031] - result already collected: FutureResult
[17:46:48.032] result() for ClusterFuture ... done
[17:46:48.032] result() for ClusterFuture ...
[17:46:48.032] - result already collected: FutureResult
[17:46:48.032] result() for ClusterFuture ... done
[17:46:48.032] result() for ClusterFuture ...
[17:46:48.032] - result already collected: FutureResult
[17:46:48.032] result() for ClusterFuture ... done
[17:46:48.032] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:48.032] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:48.032] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:48.032]  length: 2 (resolved future 2)
[17:46:48.033] Future #3
[17:46:48.033] result() for ClusterFuture ...
[17:46:48.033] - result already collected: FutureResult
[17:46:48.033] result() for ClusterFuture ... done
[17:46:48.033] result() for ClusterFuture ...
[17:46:48.033] - result already collected: FutureResult
[17:46:48.033] result() for ClusterFuture ... done
[17:46:48.033] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:48.033] - nx: 4
[17:46:48.033] - relay: TRUE
[17:46:48.033] - stdout: TRUE
[17:46:48.034] - signal: TRUE
[17:46:48.034] - resignal: FALSE
[17:46:48.034] - force: TRUE
[17:46:48.034] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:46:48.034] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:46:48.034]  - until=3
[17:46:48.034]  - relaying element #3
[17:46:48.034] result() for ClusterFuture ...
[17:46:48.034] - result already collected: FutureResult
[17:46:48.034] result() for ClusterFuture ... done
[17:46:48.034] result() for ClusterFuture ...
[17:46:48.034] - result already collected: FutureResult
[17:46:48.035] result() for ClusterFuture ... done
[17:46:48.035] result() for ClusterFuture ...
[17:46:48.035] - result already collected: FutureResult
[17:46:48.035] result() for ClusterFuture ... done
[17:46:48.035] result() for ClusterFuture ...
[17:46:48.035] - result already collected: FutureResult
[17:46:48.035] result() for ClusterFuture ... done
[17:46:48.035] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:48.035] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:48.035] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:48.035]  length: 1 (resolved future 3)
[17:46:48.036] Future #4
[17:46:48.036] result() for ClusterFuture ...
[17:46:48.036] - result already collected: FutureResult
[17:46:48.036] result() for ClusterFuture ... done
[17:46:48.036] result() for ClusterFuture ...
[17:46:48.036] - result already collected: FutureResult
[17:46:48.036] result() for ClusterFuture ... done
[17:46:48.036] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:48.036] - nx: 4
[17:46:48.036] - relay: TRUE
[17:46:48.036] - stdout: TRUE
[17:46:48.037] - signal: TRUE
[17:46:48.037] - resignal: FALSE
[17:46:48.037] - force: TRUE
[17:46:48.037] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:46:48.037] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:46:48.037]  - until=4
[17:46:48.037]  - relaying element #4
[17:46:48.037] result() for ClusterFuture ...
[17:46:48.037] - result already collected: FutureResult
[17:46:48.037] result() for ClusterFuture ... done
[17:46:48.037] result() for ClusterFuture ...
[17:46:48.037] - result already collected: FutureResult
[17:46:48.038] result() for ClusterFuture ... done
[17:46:48.038] result() for ClusterFuture ...
[17:46:48.038] - result already collected: FutureResult
[17:46:48.038] result() for ClusterFuture ... done
[17:46:48.038] result() for ClusterFuture ...
[17:46:48.038] - result already collected: FutureResult
[17:46:48.038] result() for ClusterFuture ... done
[17:46:48.038] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:48.038] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:48.038] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:48.038]  length: 0 (resolved future 4)
[17:46:48.039] Relaying remaining futures
[17:46:48.039] signalConditionsASAP(NULL, pos=0) ...
[17:46:48.039] - nx: 4
[17:46:48.039] - relay: TRUE
[17:46:48.039] - stdout: TRUE
[17:46:48.039] - signal: TRUE
[17:46:48.039] - resignal: FALSE
[17:46:48.039] - force: TRUE
[17:46:48.039] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:48.039] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:46:48.039] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:46:48.040] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:46:48.040] signalConditionsASAP(NULL, pos=0) ... done
[17:46:48.040] resolve() on environment ... DONE
[17:46:48.040] result() for ClusterFuture ...
[17:46:48.040] - result already collected: FutureResult
[17:46:48.040] result() for ClusterFuture ... done
[17:46:48.040] result() for ClusterFuture ...
[17:46:48.040] - result already collected: FutureResult
[17:46:48.040] result() for ClusterFuture ... done
[17:46:48.040] result() for ClusterFuture ...
[17:46:48.040] - result already collected: FutureResult
[17:46:48.040] result() for ClusterFuture ... done
[17:46:48.041] result() for ClusterFuture ...
[17:46:48.041] - result already collected: FutureResult
[17:46:48.041] result() for ClusterFuture ... done
[17:46:48.041] result() for ClusterFuture ...
[17:46:48.041] - result already collected: FutureResult
[17:46:48.041] result() for ClusterFuture ... done
[17:46:48.041] result() for ClusterFuture ...
[17:46:48.041] - result already collected: FutureResult
[17:46:48.041] result() for ClusterFuture ... done
<environment: 0x5617871b48c0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[17:46:48.042] plan(): Setting new future strategy stack:
[17:46:48.042] List of future strategies:
[17:46:48.042] 1. multicore:
[17:46:48.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.042]    - tweaked: FALSE
[17:46:48.042]    - call: plan(strategy)
[17:46:48.046] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:46:48.047] getGlobalsAndPackages() ...
[17:46:48.047] Searching for globals...
[17:46:48.047] 
[17:46:48.047] Searching for globals ... DONE
[17:46:48.047] - globals: [0] <none>
[17:46:48.048] getGlobalsAndPackages() ... DONE
[17:46:48.048] run() for ‘Future’ ...
[17:46:48.048] - state: ‘created’
[17:46:48.048] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.051] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.052] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.052]   - Field: ‘label’
[17:46:48.052]   - Field: ‘local’
[17:46:48.052]   - Field: ‘owner’
[17:46:48.052]   - Field: ‘envir’
[17:46:48.052]   - Field: ‘workers’
[17:46:48.052]   - Field: ‘packages’
[17:46:48.052]   - Field: ‘gc’
[17:46:48.052]   - Field: ‘job’
[17:46:48.053]   - Field: ‘conditions’
[17:46:48.053]   - Field: ‘expr’
[17:46:48.053]   - Field: ‘uuid’
[17:46:48.053]   - Field: ‘seed’
[17:46:48.053]   - Field: ‘version’
[17:46:48.053]   - Field: ‘result’
[17:46:48.053]   - Field: ‘asynchronous’
[17:46:48.053]   - Field: ‘calls’
[17:46:48.053]   - Field: ‘globals’
[17:46:48.053]   - Field: ‘stdout’
[17:46:48.053]   - Field: ‘earlySignal’
[17:46:48.054]   - Field: ‘lazy’
[17:46:48.054]   - Field: ‘state’
[17:46:48.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.054] - Launch lazy future ...
[17:46:48.054] Packages needed by the future expression (n = 0): <none>
[17:46:48.054] Packages needed by future strategies (n = 0): <none>
[17:46:48.055] {
[17:46:48.055]     {
[17:46:48.055]         {
[17:46:48.055]             ...future.startTime <- base::Sys.time()
[17:46:48.055]             {
[17:46:48.055]                 {
[17:46:48.055]                   {
[17:46:48.055]                     {
[17:46:48.055]                       base::local({
[17:46:48.055]                         has_future <- base::requireNamespace("future", 
[17:46:48.055]                           quietly = TRUE)
[17:46:48.055]                         if (has_future) {
[17:46:48.055]                           ns <- base::getNamespace("future")
[17:46:48.055]                           version <- ns[[".package"]][["version"]]
[17:46:48.055]                           if (is.null(version)) 
[17:46:48.055]                             version <- utils::packageVersion("future")
[17:46:48.055]                         }
[17:46:48.055]                         else {
[17:46:48.055]                           version <- NULL
[17:46:48.055]                         }
[17:46:48.055]                         if (!has_future || version < "1.8.0") {
[17:46:48.055]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.055]                             "", base::R.version$version.string), 
[17:46:48.055]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.055]                               "release", "version")], collapse = " "), 
[17:46:48.055]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.055]                             info)
[17:46:48.055]                           info <- base::paste(info, collapse = "; ")
[17:46:48.055]                           if (!has_future) {
[17:46:48.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.055]                               info)
[17:46:48.055]                           }
[17:46:48.055]                           else {
[17:46:48.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.055]                               info, version)
[17:46:48.055]                           }
[17:46:48.055]                           base::stop(msg)
[17:46:48.055]                         }
[17:46:48.055]                       })
[17:46:48.055]                     }
[17:46:48.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.055]                     base::options(mc.cores = 1L)
[17:46:48.055]                   }
[17:46:48.055]                   ...future.strategy.old <- future::plan("list")
[17:46:48.055]                   options(future.plan = NULL)
[17:46:48.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.055]                 }
[17:46:48.055]                 ...future.workdir <- getwd()
[17:46:48.055]             }
[17:46:48.055]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.055]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.055]         }
[17:46:48.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.055]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.055]             base::names(...future.oldOptions))
[17:46:48.055]     }
[17:46:48.055]     if (FALSE) {
[17:46:48.055]     }
[17:46:48.055]     else {
[17:46:48.055]         if (TRUE) {
[17:46:48.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.055]                 open = "w")
[17:46:48.055]         }
[17:46:48.055]         else {
[17:46:48.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.055]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.055]         }
[17:46:48.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.055]             base::sink(type = "output", split = FALSE)
[17:46:48.055]             base::close(...future.stdout)
[17:46:48.055]         }, add = TRUE)
[17:46:48.055]     }
[17:46:48.055]     ...future.frame <- base::sys.nframe()
[17:46:48.055]     ...future.conditions <- base::list()
[17:46:48.055]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.055]     if (FALSE) {
[17:46:48.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.055]     }
[17:46:48.055]     ...future.result <- base::tryCatch({
[17:46:48.055]         base::withCallingHandlers({
[17:46:48.055]             ...future.value <- base::withVisible(base::local({
[17:46:48.055]                 withCallingHandlers({
[17:46:48.055]                   2
[17:46:48.055]                 }, immediateCondition = function(cond) {
[17:46:48.055]                   save_rds <- function (object, pathname, ...) 
[17:46:48.055]                   {
[17:46:48.055]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.055]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.055]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.055]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.055]                         fi_tmp[["mtime"]])
[17:46:48.055]                     }
[17:46:48.055]                     tryCatch({
[17:46:48.055]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.055]                     }, error = function(ex) {
[17:46:48.055]                       msg <- conditionMessage(ex)
[17:46:48.055]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.055]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.055]                         fi_tmp[["mtime"]], msg)
[17:46:48.055]                       ex$message <- msg
[17:46:48.055]                       stop(ex)
[17:46:48.055]                     })
[17:46:48.055]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.055]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.055]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.055]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.055]                       fi <- file.info(pathname)
[17:46:48.055]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.055]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.055]                         fi[["size"]], fi[["mtime"]])
[17:46:48.055]                       stop(msg)
[17:46:48.055]                     }
[17:46:48.055]                     invisible(pathname)
[17:46:48.055]                   }
[17:46:48.055]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.055]                     rootPath = tempdir()) 
[17:46:48.055]                   {
[17:46:48.055]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.055]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.055]                       tmpdir = path, fileext = ".rds")
[17:46:48.055]                     save_rds(obj, file)
[17:46:48.055]                   }
[17:46:48.055]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.055]                   {
[17:46:48.055]                     inherits <- base::inherits
[17:46:48.055]                     invokeRestart <- base::invokeRestart
[17:46:48.055]                     is.null <- base::is.null
[17:46:48.055]                     muffled <- FALSE
[17:46:48.055]                     if (inherits(cond, "message")) {
[17:46:48.055]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.055]                       if (muffled) 
[17:46:48.055]                         invokeRestart("muffleMessage")
[17:46:48.055]                     }
[17:46:48.055]                     else if (inherits(cond, "warning")) {
[17:46:48.055]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.055]                       if (muffled) 
[17:46:48.055]                         invokeRestart("muffleWarning")
[17:46:48.055]                     }
[17:46:48.055]                     else if (inherits(cond, "condition")) {
[17:46:48.055]                       if (!is.null(pattern)) {
[17:46:48.055]                         computeRestarts <- base::computeRestarts
[17:46:48.055]                         grepl <- base::grepl
[17:46:48.055]                         restarts <- computeRestarts(cond)
[17:46:48.055]                         for (restart in restarts) {
[17:46:48.055]                           name <- restart$name
[17:46:48.055]                           if (is.null(name)) 
[17:46:48.055]                             next
[17:46:48.055]                           if (!grepl(pattern, name)) 
[17:46:48.055]                             next
[17:46:48.055]                           invokeRestart(restart)
[17:46:48.055]                           muffled <- TRUE
[17:46:48.055]                           break
[17:46:48.055]                         }
[17:46:48.055]                       }
[17:46:48.055]                     }
[17:46:48.055]                     invisible(muffled)
[17:46:48.055]                   }
[17:46:48.055]                   muffleCondition(cond)
[17:46:48.055]                 })
[17:46:48.055]             }))
[17:46:48.055]             future::FutureResult(value = ...future.value$value, 
[17:46:48.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.055]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.055]                     ...future.globalenv.names))
[17:46:48.055]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.055]         }, condition = base::local({
[17:46:48.055]             c <- base::c
[17:46:48.055]             inherits <- base::inherits
[17:46:48.055]             invokeRestart <- base::invokeRestart
[17:46:48.055]             length <- base::length
[17:46:48.055]             list <- base::list
[17:46:48.055]             seq.int <- base::seq.int
[17:46:48.055]             signalCondition <- base::signalCondition
[17:46:48.055]             sys.calls <- base::sys.calls
[17:46:48.055]             `[[` <- base::`[[`
[17:46:48.055]             `+` <- base::`+`
[17:46:48.055]             `<<-` <- base::`<<-`
[17:46:48.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.055]                   3L)]
[17:46:48.055]             }
[17:46:48.055]             function(cond) {
[17:46:48.055]                 is_error <- inherits(cond, "error")
[17:46:48.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.055]                   NULL)
[17:46:48.055]                 if (is_error) {
[17:46:48.055]                   sessionInformation <- function() {
[17:46:48.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.055]                       search = base::search(), system = base::Sys.info())
[17:46:48.055]                   }
[17:46:48.055]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.055]                     cond$call), session = sessionInformation(), 
[17:46:48.055]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.055]                   signalCondition(cond)
[17:46:48.055]                 }
[17:46:48.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.055]                 "immediateCondition"))) {
[17:46:48.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.055]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.055]                   if (TRUE && !signal) {
[17:46:48.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.055]                     {
[17:46:48.055]                       inherits <- base::inherits
[17:46:48.055]                       invokeRestart <- base::invokeRestart
[17:46:48.055]                       is.null <- base::is.null
[17:46:48.055]                       muffled <- FALSE
[17:46:48.055]                       if (inherits(cond, "message")) {
[17:46:48.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.055]                         if (muffled) 
[17:46:48.055]                           invokeRestart("muffleMessage")
[17:46:48.055]                       }
[17:46:48.055]                       else if (inherits(cond, "warning")) {
[17:46:48.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.055]                         if (muffled) 
[17:46:48.055]                           invokeRestart("muffleWarning")
[17:46:48.055]                       }
[17:46:48.055]                       else if (inherits(cond, "condition")) {
[17:46:48.055]                         if (!is.null(pattern)) {
[17:46:48.055]                           computeRestarts <- base::computeRestarts
[17:46:48.055]                           grepl <- base::grepl
[17:46:48.055]                           restarts <- computeRestarts(cond)
[17:46:48.055]                           for (restart in restarts) {
[17:46:48.055]                             name <- restart$name
[17:46:48.055]                             if (is.null(name)) 
[17:46:48.055]                               next
[17:46:48.055]                             if (!grepl(pattern, name)) 
[17:46:48.055]                               next
[17:46:48.055]                             invokeRestart(restart)
[17:46:48.055]                             muffled <- TRUE
[17:46:48.055]                             break
[17:46:48.055]                           }
[17:46:48.055]                         }
[17:46:48.055]                       }
[17:46:48.055]                       invisible(muffled)
[17:46:48.055]                     }
[17:46:48.055]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.055]                   }
[17:46:48.055]                 }
[17:46:48.055]                 else {
[17:46:48.055]                   if (TRUE) {
[17:46:48.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.055]                     {
[17:46:48.055]                       inherits <- base::inherits
[17:46:48.055]                       invokeRestart <- base::invokeRestart
[17:46:48.055]                       is.null <- base::is.null
[17:46:48.055]                       muffled <- FALSE
[17:46:48.055]                       if (inherits(cond, "message")) {
[17:46:48.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.055]                         if (muffled) 
[17:46:48.055]                           invokeRestart("muffleMessage")
[17:46:48.055]                       }
[17:46:48.055]                       else if (inherits(cond, "warning")) {
[17:46:48.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.055]                         if (muffled) 
[17:46:48.055]                           invokeRestart("muffleWarning")
[17:46:48.055]                       }
[17:46:48.055]                       else if (inherits(cond, "condition")) {
[17:46:48.055]                         if (!is.null(pattern)) {
[17:46:48.055]                           computeRestarts <- base::computeRestarts
[17:46:48.055]                           grepl <- base::grepl
[17:46:48.055]                           restarts <- computeRestarts(cond)
[17:46:48.055]                           for (restart in restarts) {
[17:46:48.055]                             name <- restart$name
[17:46:48.055]                             if (is.null(name)) 
[17:46:48.055]                               next
[17:46:48.055]                             if (!grepl(pattern, name)) 
[17:46:48.055]                               next
[17:46:48.055]                             invokeRestart(restart)
[17:46:48.055]                             muffled <- TRUE
[17:46:48.055]                             break
[17:46:48.055]                           }
[17:46:48.055]                         }
[17:46:48.055]                       }
[17:46:48.055]                       invisible(muffled)
[17:46:48.055]                     }
[17:46:48.055]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.055]                   }
[17:46:48.055]                 }
[17:46:48.055]             }
[17:46:48.055]         }))
[17:46:48.055]     }, error = function(ex) {
[17:46:48.055]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.055]                 ...future.rng), started = ...future.startTime, 
[17:46:48.055]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.055]             version = "1.8"), class = "FutureResult")
[17:46:48.055]     }, finally = {
[17:46:48.055]         if (!identical(...future.workdir, getwd())) 
[17:46:48.055]             setwd(...future.workdir)
[17:46:48.055]         {
[17:46:48.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.055]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.055]             }
[17:46:48.055]             base::options(...future.oldOptions)
[17:46:48.055]             if (.Platform$OS.type == "windows") {
[17:46:48.055]                 old_names <- names(...future.oldEnvVars)
[17:46:48.055]                 envs <- base::Sys.getenv()
[17:46:48.055]                 names <- names(envs)
[17:46:48.055]                 common <- intersect(names, old_names)
[17:46:48.055]                 added <- setdiff(names, old_names)
[17:46:48.055]                 removed <- setdiff(old_names, names)
[17:46:48.055]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.055]                   envs[common]]
[17:46:48.055]                 NAMES <- toupper(changed)
[17:46:48.055]                 args <- list()
[17:46:48.055]                 for (kk in seq_along(NAMES)) {
[17:46:48.055]                   name <- changed[[kk]]
[17:46:48.055]                   NAME <- NAMES[[kk]]
[17:46:48.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.055]                     next
[17:46:48.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.055]                 }
[17:46:48.055]                 NAMES <- toupper(added)
[17:46:48.055]                 for (kk in seq_along(NAMES)) {
[17:46:48.055]                   name <- added[[kk]]
[17:46:48.055]                   NAME <- NAMES[[kk]]
[17:46:48.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.055]                     next
[17:46:48.055]                   args[[name]] <- ""
[17:46:48.055]                 }
[17:46:48.055]                 NAMES <- toupper(removed)
[17:46:48.055]                 for (kk in seq_along(NAMES)) {
[17:46:48.055]                   name <- removed[[kk]]
[17:46:48.055]                   NAME <- NAMES[[kk]]
[17:46:48.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.055]                     next
[17:46:48.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.055]                 }
[17:46:48.055]                 if (length(args) > 0) 
[17:46:48.055]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.055]             }
[17:46:48.055]             else {
[17:46:48.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.055]             }
[17:46:48.055]             {
[17:46:48.055]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.055]                   0L) {
[17:46:48.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.055]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.055]                   base::options(opts)
[17:46:48.055]                 }
[17:46:48.055]                 {
[17:46:48.055]                   {
[17:46:48.055]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.055]                     NULL
[17:46:48.055]                   }
[17:46:48.055]                   options(future.plan = NULL)
[17:46:48.055]                   if (is.na(NA_character_)) 
[17:46:48.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.055]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.055]                     .init = FALSE)
[17:46:48.055]                 }
[17:46:48.055]             }
[17:46:48.055]         }
[17:46:48.055]     })
[17:46:48.055]     if (TRUE) {
[17:46:48.055]         base::sink(type = "output", split = FALSE)
[17:46:48.055]         if (TRUE) {
[17:46:48.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.055]         }
[17:46:48.055]         else {
[17:46:48.055]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.055]         }
[17:46:48.055]         base::close(...future.stdout)
[17:46:48.055]         ...future.stdout <- NULL
[17:46:48.055]     }
[17:46:48.055]     ...future.result$conditions <- ...future.conditions
[17:46:48.055]     ...future.result$finished <- base::Sys.time()
[17:46:48.055]     ...future.result
[17:46:48.055] }
[17:46:48.057] requestCore(): workers = 2
[17:46:48.060] MulticoreFuture started
[17:46:48.060] - Launch lazy future ... done
[17:46:48.060] run() for ‘MulticoreFuture’ ... done
[17:46:48.061] getGlobalsAndPackages() ...
[17:46:48.061] Searching for globals...
[17:46:48.061] plan(): Setting new future strategy stack:
[17:46:48.062] 
[17:46:48.062] Searching for globals ... DONE
[17:46:48.062] - globals: [0] <none>
[17:46:48.061] List of future strategies:
[17:46:48.061] 1. sequential:
[17:46:48.061]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.061]    - tweaked: FALSE
[17:46:48.061]    - call: NULL
[17:46:48.062] getGlobalsAndPackages() ... DONE
[17:46:48.062] plan(): nbrOfWorkers() = 1
[17:46:48.063] run() for ‘Future’ ...
[17:46:48.063] - state: ‘created’
[17:46:48.063] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.064] plan(): Setting new future strategy stack:
[17:46:48.064] List of future strategies:
[17:46:48.064] 1. multicore:
[17:46:48.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.064]    - tweaked: FALSE
[17:46:48.064]    - call: plan(strategy)
[17:46:48.069] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.069]   - Field: ‘label’
[17:46:48.069] plan(): nbrOfWorkers() = 2
[17:46:48.069]   - Field: ‘local’
[17:46:48.069]   - Field: ‘owner’
[17:46:48.070]   - Field: ‘envir’
[17:46:48.070]   - Field: ‘workers’
[17:46:48.070]   - Field: ‘packages’
[17:46:48.070]   - Field: ‘gc’
[17:46:48.070]   - Field: ‘job’
[17:46:48.070]   - Field: ‘conditions’
[17:46:48.070]   - Field: ‘expr’
[17:46:48.071]   - Field: ‘uuid’
[17:46:48.071]   - Field: ‘seed’
[17:46:48.071]   - Field: ‘version’
[17:46:48.071]   - Field: ‘result’
[17:46:48.071]   - Field: ‘asynchronous’
[17:46:48.071]   - Field: ‘calls’
[17:46:48.071]   - Field: ‘globals’
[17:46:48.072]   - Field: ‘stdout’
[17:46:48.072]   - Field: ‘earlySignal’
[17:46:48.072]   - Field: ‘lazy’
[17:46:48.072]   - Field: ‘state’
[17:46:48.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.072] - Launch lazy future ...
[17:46:48.073] Packages needed by the future expression (n = 0): <none>
[17:46:48.073] Packages needed by future strategies (n = 0): <none>
[17:46:48.074] {
[17:46:48.074]     {
[17:46:48.074]         {
[17:46:48.074]             ...future.startTime <- base::Sys.time()
[17:46:48.074]             {
[17:46:48.074]                 {
[17:46:48.074]                   {
[17:46:48.074]                     {
[17:46:48.074]                       base::local({
[17:46:48.074]                         has_future <- base::requireNamespace("future", 
[17:46:48.074]                           quietly = TRUE)
[17:46:48.074]                         if (has_future) {
[17:46:48.074]                           ns <- base::getNamespace("future")
[17:46:48.074]                           version <- ns[[".package"]][["version"]]
[17:46:48.074]                           if (is.null(version)) 
[17:46:48.074]                             version <- utils::packageVersion("future")
[17:46:48.074]                         }
[17:46:48.074]                         else {
[17:46:48.074]                           version <- NULL
[17:46:48.074]                         }
[17:46:48.074]                         if (!has_future || version < "1.8.0") {
[17:46:48.074]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.074]                             "", base::R.version$version.string), 
[17:46:48.074]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.074]                               "release", "version")], collapse = " "), 
[17:46:48.074]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.074]                             info)
[17:46:48.074]                           info <- base::paste(info, collapse = "; ")
[17:46:48.074]                           if (!has_future) {
[17:46:48.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.074]                               info)
[17:46:48.074]                           }
[17:46:48.074]                           else {
[17:46:48.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.074]                               info, version)
[17:46:48.074]                           }
[17:46:48.074]                           base::stop(msg)
[17:46:48.074]                         }
[17:46:48.074]                       })
[17:46:48.074]                     }
[17:46:48.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.074]                     base::options(mc.cores = 1L)
[17:46:48.074]                   }
[17:46:48.074]                   ...future.strategy.old <- future::plan("list")
[17:46:48.074]                   options(future.plan = NULL)
[17:46:48.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.074]                 }
[17:46:48.074]                 ...future.workdir <- getwd()
[17:46:48.074]             }
[17:46:48.074]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.074]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.074]         }
[17:46:48.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.074]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.074]             base::names(...future.oldOptions))
[17:46:48.074]     }
[17:46:48.074]     if (FALSE) {
[17:46:48.074]     }
[17:46:48.074]     else {
[17:46:48.074]         if (TRUE) {
[17:46:48.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.074]                 open = "w")
[17:46:48.074]         }
[17:46:48.074]         else {
[17:46:48.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.074]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.074]         }
[17:46:48.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.074]             base::sink(type = "output", split = FALSE)
[17:46:48.074]             base::close(...future.stdout)
[17:46:48.074]         }, add = TRUE)
[17:46:48.074]     }
[17:46:48.074]     ...future.frame <- base::sys.nframe()
[17:46:48.074]     ...future.conditions <- base::list()
[17:46:48.074]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.074]     if (FALSE) {
[17:46:48.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.074]     }
[17:46:48.074]     ...future.result <- base::tryCatch({
[17:46:48.074]         base::withCallingHandlers({
[17:46:48.074]             ...future.value <- base::withVisible(base::local({
[17:46:48.074]                 withCallingHandlers({
[17:46:48.074]                   NULL
[17:46:48.074]                 }, immediateCondition = function(cond) {
[17:46:48.074]                   save_rds <- function (object, pathname, ...) 
[17:46:48.074]                   {
[17:46:48.074]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.074]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.074]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.074]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.074]                         fi_tmp[["mtime"]])
[17:46:48.074]                     }
[17:46:48.074]                     tryCatch({
[17:46:48.074]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.074]                     }, error = function(ex) {
[17:46:48.074]                       msg <- conditionMessage(ex)
[17:46:48.074]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.074]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.074]                         fi_tmp[["mtime"]], msg)
[17:46:48.074]                       ex$message <- msg
[17:46:48.074]                       stop(ex)
[17:46:48.074]                     })
[17:46:48.074]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.074]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.074]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.074]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.074]                       fi <- file.info(pathname)
[17:46:48.074]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.074]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.074]                         fi[["size"]], fi[["mtime"]])
[17:46:48.074]                       stop(msg)
[17:46:48.074]                     }
[17:46:48.074]                     invisible(pathname)
[17:46:48.074]                   }
[17:46:48.074]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.074]                     rootPath = tempdir()) 
[17:46:48.074]                   {
[17:46:48.074]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.074]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.074]                       tmpdir = path, fileext = ".rds")
[17:46:48.074]                     save_rds(obj, file)
[17:46:48.074]                   }
[17:46:48.074]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.074]                   {
[17:46:48.074]                     inherits <- base::inherits
[17:46:48.074]                     invokeRestart <- base::invokeRestart
[17:46:48.074]                     is.null <- base::is.null
[17:46:48.074]                     muffled <- FALSE
[17:46:48.074]                     if (inherits(cond, "message")) {
[17:46:48.074]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.074]                       if (muffled) 
[17:46:48.074]                         invokeRestart("muffleMessage")
[17:46:48.074]                     }
[17:46:48.074]                     else if (inherits(cond, "warning")) {
[17:46:48.074]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.074]                       if (muffled) 
[17:46:48.074]                         invokeRestart("muffleWarning")
[17:46:48.074]                     }
[17:46:48.074]                     else if (inherits(cond, "condition")) {
[17:46:48.074]                       if (!is.null(pattern)) {
[17:46:48.074]                         computeRestarts <- base::computeRestarts
[17:46:48.074]                         grepl <- base::grepl
[17:46:48.074]                         restarts <- computeRestarts(cond)
[17:46:48.074]                         for (restart in restarts) {
[17:46:48.074]                           name <- restart$name
[17:46:48.074]                           if (is.null(name)) 
[17:46:48.074]                             next
[17:46:48.074]                           if (!grepl(pattern, name)) 
[17:46:48.074]                             next
[17:46:48.074]                           invokeRestart(restart)
[17:46:48.074]                           muffled <- TRUE
[17:46:48.074]                           break
[17:46:48.074]                         }
[17:46:48.074]                       }
[17:46:48.074]                     }
[17:46:48.074]                     invisible(muffled)
[17:46:48.074]                   }
[17:46:48.074]                   muffleCondition(cond)
[17:46:48.074]                 })
[17:46:48.074]             }))
[17:46:48.074]             future::FutureResult(value = ...future.value$value, 
[17:46:48.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.074]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.074]                     ...future.globalenv.names))
[17:46:48.074]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.074]         }, condition = base::local({
[17:46:48.074]             c <- base::c
[17:46:48.074]             inherits <- base::inherits
[17:46:48.074]             invokeRestart <- base::invokeRestart
[17:46:48.074]             length <- base::length
[17:46:48.074]             list <- base::list
[17:46:48.074]             seq.int <- base::seq.int
[17:46:48.074]             signalCondition <- base::signalCondition
[17:46:48.074]             sys.calls <- base::sys.calls
[17:46:48.074]             `[[` <- base::`[[`
[17:46:48.074]             `+` <- base::`+`
[17:46:48.074]             `<<-` <- base::`<<-`
[17:46:48.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.074]                   3L)]
[17:46:48.074]             }
[17:46:48.074]             function(cond) {
[17:46:48.074]                 is_error <- inherits(cond, "error")
[17:46:48.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.074]                   NULL)
[17:46:48.074]                 if (is_error) {
[17:46:48.074]                   sessionInformation <- function() {
[17:46:48.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.074]                       search = base::search(), system = base::Sys.info())
[17:46:48.074]                   }
[17:46:48.074]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.074]                     cond$call), session = sessionInformation(), 
[17:46:48.074]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.074]                   signalCondition(cond)
[17:46:48.074]                 }
[17:46:48.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.074]                 "immediateCondition"))) {
[17:46:48.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.074]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.074]                   if (TRUE && !signal) {
[17:46:48.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.074]                     {
[17:46:48.074]                       inherits <- base::inherits
[17:46:48.074]                       invokeRestart <- base::invokeRestart
[17:46:48.074]                       is.null <- base::is.null
[17:46:48.074]                       muffled <- FALSE
[17:46:48.074]                       if (inherits(cond, "message")) {
[17:46:48.074]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.074]                         if (muffled) 
[17:46:48.074]                           invokeRestart("muffleMessage")
[17:46:48.074]                       }
[17:46:48.074]                       else if (inherits(cond, "warning")) {
[17:46:48.074]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.074]                         if (muffled) 
[17:46:48.074]                           invokeRestart("muffleWarning")
[17:46:48.074]                       }
[17:46:48.074]                       else if (inherits(cond, "condition")) {
[17:46:48.074]                         if (!is.null(pattern)) {
[17:46:48.074]                           computeRestarts <- base::computeRestarts
[17:46:48.074]                           grepl <- base::grepl
[17:46:48.074]                           restarts <- computeRestarts(cond)
[17:46:48.074]                           for (restart in restarts) {
[17:46:48.074]                             name <- restart$name
[17:46:48.074]                             if (is.null(name)) 
[17:46:48.074]                               next
[17:46:48.074]                             if (!grepl(pattern, name)) 
[17:46:48.074]                               next
[17:46:48.074]                             invokeRestart(restart)
[17:46:48.074]                             muffled <- TRUE
[17:46:48.074]                             break
[17:46:48.074]                           }
[17:46:48.074]                         }
[17:46:48.074]                       }
[17:46:48.074]                       invisible(muffled)
[17:46:48.074]                     }
[17:46:48.074]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.074]                   }
[17:46:48.074]                 }
[17:46:48.074]                 else {
[17:46:48.074]                   if (TRUE) {
[17:46:48.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.074]                     {
[17:46:48.074]                       inherits <- base::inherits
[17:46:48.074]                       invokeRestart <- base::invokeRestart
[17:46:48.074]                       is.null <- base::is.null
[17:46:48.074]                       muffled <- FALSE
[17:46:48.074]                       if (inherits(cond, "message")) {
[17:46:48.074]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.074]                         if (muffled) 
[17:46:48.074]                           invokeRestart("muffleMessage")
[17:46:48.074]                       }
[17:46:48.074]                       else if (inherits(cond, "warning")) {
[17:46:48.074]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.074]                         if (muffled) 
[17:46:48.074]                           invokeRestart("muffleWarning")
[17:46:48.074]                       }
[17:46:48.074]                       else if (inherits(cond, "condition")) {
[17:46:48.074]                         if (!is.null(pattern)) {
[17:46:48.074]                           computeRestarts <- base::computeRestarts
[17:46:48.074]                           grepl <- base::grepl
[17:46:48.074]                           restarts <- computeRestarts(cond)
[17:46:48.074]                           for (restart in restarts) {
[17:46:48.074]                             name <- restart$name
[17:46:48.074]                             if (is.null(name)) 
[17:46:48.074]                               next
[17:46:48.074]                             if (!grepl(pattern, name)) 
[17:46:48.074]                               next
[17:46:48.074]                             invokeRestart(restart)
[17:46:48.074]                             muffled <- TRUE
[17:46:48.074]                             break
[17:46:48.074]                           }
[17:46:48.074]                         }
[17:46:48.074]                       }
[17:46:48.074]                       invisible(muffled)
[17:46:48.074]                     }
[17:46:48.074]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.074]                   }
[17:46:48.074]                 }
[17:46:48.074]             }
[17:46:48.074]         }))
[17:46:48.074]     }, error = function(ex) {
[17:46:48.074]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.074]                 ...future.rng), started = ...future.startTime, 
[17:46:48.074]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.074]             version = "1.8"), class = "FutureResult")
[17:46:48.074]     }, finally = {
[17:46:48.074]         if (!identical(...future.workdir, getwd())) 
[17:46:48.074]             setwd(...future.workdir)
[17:46:48.074]         {
[17:46:48.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.074]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.074]             }
[17:46:48.074]             base::options(...future.oldOptions)
[17:46:48.074]             if (.Platform$OS.type == "windows") {
[17:46:48.074]                 old_names <- names(...future.oldEnvVars)
[17:46:48.074]                 envs <- base::Sys.getenv()
[17:46:48.074]                 names <- names(envs)
[17:46:48.074]                 common <- intersect(names, old_names)
[17:46:48.074]                 added <- setdiff(names, old_names)
[17:46:48.074]                 removed <- setdiff(old_names, names)
[17:46:48.074]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.074]                   envs[common]]
[17:46:48.074]                 NAMES <- toupper(changed)
[17:46:48.074]                 args <- list()
[17:46:48.074]                 for (kk in seq_along(NAMES)) {
[17:46:48.074]                   name <- changed[[kk]]
[17:46:48.074]                   NAME <- NAMES[[kk]]
[17:46:48.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.074]                     next
[17:46:48.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.074]                 }
[17:46:48.074]                 NAMES <- toupper(added)
[17:46:48.074]                 for (kk in seq_along(NAMES)) {
[17:46:48.074]                   name <- added[[kk]]
[17:46:48.074]                   NAME <- NAMES[[kk]]
[17:46:48.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.074]                     next
[17:46:48.074]                   args[[name]] <- ""
[17:46:48.074]                 }
[17:46:48.074]                 NAMES <- toupper(removed)
[17:46:48.074]                 for (kk in seq_along(NAMES)) {
[17:46:48.074]                   name <- removed[[kk]]
[17:46:48.074]                   NAME <- NAMES[[kk]]
[17:46:48.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.074]                     next
[17:46:48.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.074]                 }
[17:46:48.074]                 if (length(args) > 0) 
[17:46:48.074]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.074]             }
[17:46:48.074]             else {
[17:46:48.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.074]             }
[17:46:48.074]             {
[17:46:48.074]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.074]                   0L) {
[17:46:48.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.074]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.074]                   base::options(opts)
[17:46:48.074]                 }
[17:46:48.074]                 {
[17:46:48.074]                   {
[17:46:48.074]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.074]                     NULL
[17:46:48.074]                   }
[17:46:48.074]                   options(future.plan = NULL)
[17:46:48.074]                   if (is.na(NA_character_)) 
[17:46:48.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.074]                     .init = FALSE)
[17:46:48.074]                 }
[17:46:48.074]             }
[17:46:48.074]         }
[17:46:48.074]     })
[17:46:48.074]     if (TRUE) {
[17:46:48.074]         base::sink(type = "output", split = FALSE)
[17:46:48.074]         if (TRUE) {
[17:46:48.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.074]         }
[17:46:48.074]         else {
[17:46:48.074]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.074]         }
[17:46:48.074]         base::close(...future.stdout)
[17:46:48.074]         ...future.stdout <- NULL
[17:46:48.074]     }
[17:46:48.074]     ...future.result$conditions <- ...future.conditions
[17:46:48.074]     ...future.result$finished <- base::Sys.time()
[17:46:48.074]     ...future.result
[17:46:48.074] }
[17:46:48.077] requestCore(): workers = 2
[17:46:48.080] MulticoreFuture started
[17:46:48.081] - Launch lazy future ... done
[17:46:48.081] run() for ‘MulticoreFuture’ ... done
[17:46:48.081] plan(): Setting new future strategy stack:
[17:46:48.082] getGlobalsAndPackages() ...
[17:46:48.082] Searching for globals...
[17:46:48.082] List of future strategies:
[17:46:48.082] 1. sequential:
[17:46:48.082]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.082]    - tweaked: FALSE
[17:46:48.082]    - call: NULL
[17:46:48.083] plan(): nbrOfWorkers() = 1
[17:46:48.083] - globals found: [1] ‘{’
[17:46:48.084] Searching for globals ... DONE
[17:46:48.084] Resolving globals: FALSE
[17:46:48.084] 
[17:46:48.084] 
[17:46:48.085] getGlobalsAndPackages() ... DONE
[17:46:48.085] plan(): Setting new future strategy stack:
[17:46:48.085] run() for ‘Future’ ...
[17:46:48.085] - state: ‘created’
[17:46:48.085] List of future strategies:
[17:46:48.085] 1. multicore:
[17:46:48.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.085]    - tweaked: FALSE
[17:46:48.085]    - call: plan(strategy)
[17:46:48.085] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.091] plan(): nbrOfWorkers() = 2
[17:46:48.091] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.092]   - Field: ‘label’
[17:46:48.092]   - Field: ‘local’
[17:46:48.092]   - Field: ‘owner’
[17:46:48.092]   - Field: ‘envir’
[17:46:48.092]   - Field: ‘workers’
[17:46:48.092]   - Field: ‘packages’
[17:46:48.093]   - Field: ‘gc’
[17:46:48.093]   - Field: ‘job’
[17:46:48.093]   - Field: ‘conditions’
[17:46:48.093]   - Field: ‘expr’
[17:46:48.093]   - Field: ‘uuid’
[17:46:48.093]   - Field: ‘seed’
[17:46:48.093]   - Field: ‘version’
[17:46:48.094]   - Field: ‘result’
[17:46:48.094]   - Field: ‘asynchronous’
[17:46:48.094]   - Field: ‘calls’
[17:46:48.094]   - Field: ‘globals’
[17:46:48.094]   - Field: ‘stdout’
[17:46:48.094]   - Field: ‘earlySignal’
[17:46:48.094]   - Field: ‘lazy’
[17:46:48.094]   - Field: ‘state’
[17:46:48.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.095] - Launch lazy future ...
[17:46:48.095] Packages needed by the future expression (n = 0): <none>
[17:46:48.095] Packages needed by future strategies (n = 0): <none>
[17:46:48.096] {
[17:46:48.096]     {
[17:46:48.096]         {
[17:46:48.096]             ...future.startTime <- base::Sys.time()
[17:46:48.096]             {
[17:46:48.096]                 {
[17:46:48.096]                   {
[17:46:48.096]                     {
[17:46:48.096]                       base::local({
[17:46:48.096]                         has_future <- base::requireNamespace("future", 
[17:46:48.096]                           quietly = TRUE)
[17:46:48.096]                         if (has_future) {
[17:46:48.096]                           ns <- base::getNamespace("future")
[17:46:48.096]                           version <- ns[[".package"]][["version"]]
[17:46:48.096]                           if (is.null(version)) 
[17:46:48.096]                             version <- utils::packageVersion("future")
[17:46:48.096]                         }
[17:46:48.096]                         else {
[17:46:48.096]                           version <- NULL
[17:46:48.096]                         }
[17:46:48.096]                         if (!has_future || version < "1.8.0") {
[17:46:48.096]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.096]                             "", base::R.version$version.string), 
[17:46:48.096]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.096]                               "release", "version")], collapse = " "), 
[17:46:48.096]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.096]                             info)
[17:46:48.096]                           info <- base::paste(info, collapse = "; ")
[17:46:48.096]                           if (!has_future) {
[17:46:48.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.096]                               info)
[17:46:48.096]                           }
[17:46:48.096]                           else {
[17:46:48.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.096]                               info, version)
[17:46:48.096]                           }
[17:46:48.096]                           base::stop(msg)
[17:46:48.096]                         }
[17:46:48.096]                       })
[17:46:48.096]                     }
[17:46:48.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.096]                     base::options(mc.cores = 1L)
[17:46:48.096]                   }
[17:46:48.096]                   ...future.strategy.old <- future::plan("list")
[17:46:48.096]                   options(future.plan = NULL)
[17:46:48.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.096]                 }
[17:46:48.096]                 ...future.workdir <- getwd()
[17:46:48.096]             }
[17:46:48.096]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.096]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.096]         }
[17:46:48.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.096]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.096]             base::names(...future.oldOptions))
[17:46:48.096]     }
[17:46:48.096]     if (FALSE) {
[17:46:48.096]     }
[17:46:48.096]     else {
[17:46:48.096]         if (TRUE) {
[17:46:48.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.096]                 open = "w")
[17:46:48.096]         }
[17:46:48.096]         else {
[17:46:48.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.096]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.096]         }
[17:46:48.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.096]             base::sink(type = "output", split = FALSE)
[17:46:48.096]             base::close(...future.stdout)
[17:46:48.096]         }, add = TRUE)
[17:46:48.096]     }
[17:46:48.096]     ...future.frame <- base::sys.nframe()
[17:46:48.096]     ...future.conditions <- base::list()
[17:46:48.096]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.096]     if (FALSE) {
[17:46:48.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.096]     }
[17:46:48.096]     ...future.result <- base::tryCatch({
[17:46:48.096]         base::withCallingHandlers({
[17:46:48.096]             ...future.value <- base::withVisible(base::local({
[17:46:48.096]                 withCallingHandlers({
[17:46:48.096]                   {
[17:46:48.096]                     4
[17:46:48.096]                   }
[17:46:48.096]                 }, immediateCondition = function(cond) {
[17:46:48.096]                   save_rds <- function (object, pathname, ...) 
[17:46:48.096]                   {
[17:46:48.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.096]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.096]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.096]                         fi_tmp[["mtime"]])
[17:46:48.096]                     }
[17:46:48.096]                     tryCatch({
[17:46:48.096]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.096]                     }, error = function(ex) {
[17:46:48.096]                       msg <- conditionMessage(ex)
[17:46:48.096]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.096]                         fi_tmp[["mtime"]], msg)
[17:46:48.096]                       ex$message <- msg
[17:46:48.096]                       stop(ex)
[17:46:48.096]                     })
[17:46:48.096]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.096]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.096]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.096]                       fi <- file.info(pathname)
[17:46:48.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.096]                         fi[["size"]], fi[["mtime"]])
[17:46:48.096]                       stop(msg)
[17:46:48.096]                     }
[17:46:48.096]                     invisible(pathname)
[17:46:48.096]                   }
[17:46:48.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.096]                     rootPath = tempdir()) 
[17:46:48.096]                   {
[17:46:48.096]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.096]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.096]                       tmpdir = path, fileext = ".rds")
[17:46:48.096]                     save_rds(obj, file)
[17:46:48.096]                   }
[17:46:48.096]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.096]                   {
[17:46:48.096]                     inherits <- base::inherits
[17:46:48.096]                     invokeRestart <- base::invokeRestart
[17:46:48.096]                     is.null <- base::is.null
[17:46:48.096]                     muffled <- FALSE
[17:46:48.096]                     if (inherits(cond, "message")) {
[17:46:48.096]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.096]                       if (muffled) 
[17:46:48.096]                         invokeRestart("muffleMessage")
[17:46:48.096]                     }
[17:46:48.096]                     else if (inherits(cond, "warning")) {
[17:46:48.096]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.096]                       if (muffled) 
[17:46:48.096]                         invokeRestart("muffleWarning")
[17:46:48.096]                     }
[17:46:48.096]                     else if (inherits(cond, "condition")) {
[17:46:48.096]                       if (!is.null(pattern)) {
[17:46:48.096]                         computeRestarts <- base::computeRestarts
[17:46:48.096]                         grepl <- base::grepl
[17:46:48.096]                         restarts <- computeRestarts(cond)
[17:46:48.096]                         for (restart in restarts) {
[17:46:48.096]                           name <- restart$name
[17:46:48.096]                           if (is.null(name)) 
[17:46:48.096]                             next
[17:46:48.096]                           if (!grepl(pattern, name)) 
[17:46:48.096]                             next
[17:46:48.096]                           invokeRestart(restart)
[17:46:48.096]                           muffled <- TRUE
[17:46:48.096]                           break
[17:46:48.096]                         }
[17:46:48.096]                       }
[17:46:48.096]                     }
[17:46:48.096]                     invisible(muffled)
[17:46:48.096]                   }
[17:46:48.096]                   muffleCondition(cond)
[17:46:48.096]                 })
[17:46:48.096]             }))
[17:46:48.096]             future::FutureResult(value = ...future.value$value, 
[17:46:48.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.096]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.096]                     ...future.globalenv.names))
[17:46:48.096]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.096]         }, condition = base::local({
[17:46:48.096]             c <- base::c
[17:46:48.096]             inherits <- base::inherits
[17:46:48.096]             invokeRestart <- base::invokeRestart
[17:46:48.096]             length <- base::length
[17:46:48.096]             list <- base::list
[17:46:48.096]             seq.int <- base::seq.int
[17:46:48.096]             signalCondition <- base::signalCondition
[17:46:48.096]             sys.calls <- base::sys.calls
[17:46:48.096]             `[[` <- base::`[[`
[17:46:48.096]             `+` <- base::`+`
[17:46:48.096]             `<<-` <- base::`<<-`
[17:46:48.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.096]                   3L)]
[17:46:48.096]             }
[17:46:48.096]             function(cond) {
[17:46:48.096]                 is_error <- inherits(cond, "error")
[17:46:48.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.096]                   NULL)
[17:46:48.096]                 if (is_error) {
[17:46:48.096]                   sessionInformation <- function() {
[17:46:48.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.096]                       search = base::search(), system = base::Sys.info())
[17:46:48.096]                   }
[17:46:48.096]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.096]                     cond$call), session = sessionInformation(), 
[17:46:48.096]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.096]                   signalCondition(cond)
[17:46:48.096]                 }
[17:46:48.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.096]                 "immediateCondition"))) {
[17:46:48.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.096]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.096]                   if (TRUE && !signal) {
[17:46:48.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.096]                     {
[17:46:48.096]                       inherits <- base::inherits
[17:46:48.096]                       invokeRestart <- base::invokeRestart
[17:46:48.096]                       is.null <- base::is.null
[17:46:48.096]                       muffled <- FALSE
[17:46:48.096]                       if (inherits(cond, "message")) {
[17:46:48.096]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.096]                         if (muffled) 
[17:46:48.096]                           invokeRestart("muffleMessage")
[17:46:48.096]                       }
[17:46:48.096]                       else if (inherits(cond, "warning")) {
[17:46:48.096]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.096]                         if (muffled) 
[17:46:48.096]                           invokeRestart("muffleWarning")
[17:46:48.096]                       }
[17:46:48.096]                       else if (inherits(cond, "condition")) {
[17:46:48.096]                         if (!is.null(pattern)) {
[17:46:48.096]                           computeRestarts <- base::computeRestarts
[17:46:48.096]                           grepl <- base::grepl
[17:46:48.096]                           restarts <- computeRestarts(cond)
[17:46:48.096]                           for (restart in restarts) {
[17:46:48.096]                             name <- restart$name
[17:46:48.096]                             if (is.null(name)) 
[17:46:48.096]                               next
[17:46:48.096]                             if (!grepl(pattern, name)) 
[17:46:48.096]                               next
[17:46:48.096]                             invokeRestart(restart)
[17:46:48.096]                             muffled <- TRUE
[17:46:48.096]                             break
[17:46:48.096]                           }
[17:46:48.096]                         }
[17:46:48.096]                       }
[17:46:48.096]                       invisible(muffled)
[17:46:48.096]                     }
[17:46:48.096]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.096]                   }
[17:46:48.096]                 }
[17:46:48.096]                 else {
[17:46:48.096]                   if (TRUE) {
[17:46:48.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.096]                     {
[17:46:48.096]                       inherits <- base::inherits
[17:46:48.096]                       invokeRestart <- base::invokeRestart
[17:46:48.096]                       is.null <- base::is.null
[17:46:48.096]                       muffled <- FALSE
[17:46:48.096]                       if (inherits(cond, "message")) {
[17:46:48.096]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.096]                         if (muffled) 
[17:46:48.096]                           invokeRestart("muffleMessage")
[17:46:48.096]                       }
[17:46:48.096]                       else if (inherits(cond, "warning")) {
[17:46:48.096]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.096]                         if (muffled) 
[17:46:48.096]                           invokeRestart("muffleWarning")
[17:46:48.096]                       }
[17:46:48.096]                       else if (inherits(cond, "condition")) {
[17:46:48.096]                         if (!is.null(pattern)) {
[17:46:48.096]                           computeRestarts <- base::computeRestarts
[17:46:48.096]                           grepl <- base::grepl
[17:46:48.096]                           restarts <- computeRestarts(cond)
[17:46:48.096]                           for (restart in restarts) {
[17:46:48.096]                             name <- restart$name
[17:46:48.096]                             if (is.null(name)) 
[17:46:48.096]                               next
[17:46:48.096]                             if (!grepl(pattern, name)) 
[17:46:48.096]                               next
[17:46:48.096]                             invokeRestart(restart)
[17:46:48.096]                             muffled <- TRUE
[17:46:48.096]                             break
[17:46:48.096]                           }
[17:46:48.096]                         }
[17:46:48.096]                       }
[17:46:48.096]                       invisible(muffled)
[17:46:48.096]                     }
[17:46:48.096]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.096]                   }
[17:46:48.096]                 }
[17:46:48.096]             }
[17:46:48.096]         }))
[17:46:48.096]     }, error = function(ex) {
[17:46:48.096]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.096]                 ...future.rng), started = ...future.startTime, 
[17:46:48.096]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.096]             version = "1.8"), class = "FutureResult")
[17:46:48.096]     }, finally = {
[17:46:48.096]         if (!identical(...future.workdir, getwd())) 
[17:46:48.096]             setwd(...future.workdir)
[17:46:48.096]         {
[17:46:48.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.096]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.096]             }
[17:46:48.096]             base::options(...future.oldOptions)
[17:46:48.096]             if (.Platform$OS.type == "windows") {
[17:46:48.096]                 old_names <- names(...future.oldEnvVars)
[17:46:48.096]                 envs <- base::Sys.getenv()
[17:46:48.096]                 names <- names(envs)
[17:46:48.096]                 common <- intersect(names, old_names)
[17:46:48.096]                 added <- setdiff(names, old_names)
[17:46:48.096]                 removed <- setdiff(old_names, names)
[17:46:48.096]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.096]                   envs[common]]
[17:46:48.096]                 NAMES <- toupper(changed)
[17:46:48.096]                 args <- list()
[17:46:48.096]                 for (kk in seq_along(NAMES)) {
[17:46:48.096]                   name <- changed[[kk]]
[17:46:48.096]                   NAME <- NAMES[[kk]]
[17:46:48.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.096]                     next
[17:46:48.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.096]                 }
[17:46:48.096]                 NAMES <- toupper(added)
[17:46:48.096]                 for (kk in seq_along(NAMES)) {
[17:46:48.096]                   name <- added[[kk]]
[17:46:48.096]                   NAME <- NAMES[[kk]]
[17:46:48.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.096]                     next
[17:46:48.096]                   args[[name]] <- ""
[17:46:48.096]                 }
[17:46:48.096]                 NAMES <- toupper(removed)
[17:46:48.096]                 for (kk in seq_along(NAMES)) {
[17:46:48.096]                   name <- removed[[kk]]
[17:46:48.096]                   NAME <- NAMES[[kk]]
[17:46:48.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.096]                     next
[17:46:48.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.096]                 }
[17:46:48.096]                 if (length(args) > 0) 
[17:46:48.096]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.096]             }
[17:46:48.096]             else {
[17:46:48.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.096]             }
[17:46:48.096]             {
[17:46:48.096]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.096]                   0L) {
[17:46:48.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.096]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.096]                   base::options(opts)
[17:46:48.096]                 }
[17:46:48.096]                 {
[17:46:48.096]                   {
[17:46:48.096]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.096]                     NULL
[17:46:48.096]                   }
[17:46:48.096]                   options(future.plan = NULL)
[17:46:48.096]                   if (is.na(NA_character_)) 
[17:46:48.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.096]                     .init = FALSE)
[17:46:48.096]                 }
[17:46:48.096]             }
[17:46:48.096]         }
[17:46:48.096]     })
[17:46:48.096]     if (TRUE) {
[17:46:48.096]         base::sink(type = "output", split = FALSE)
[17:46:48.096]         if (TRUE) {
[17:46:48.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.096]         }
[17:46:48.096]         else {
[17:46:48.096]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.096]         }
[17:46:48.096]         base::close(...future.stdout)
[17:46:48.096]         ...future.stdout <- NULL
[17:46:48.096]     }
[17:46:48.096]     ...future.result$conditions <- ...future.conditions
[17:46:48.096]     ...future.result$finished <- base::Sys.time()
[17:46:48.096]     ...future.result
[17:46:48.096] }
[17:46:48.100] requestCore(): workers = 2
[17:46:48.100] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:48.111] result() for MulticoreFuture ...
[17:46:48.112] result() for MulticoreFuture ...
[17:46:48.112] result() for MulticoreFuture ... done
[17:46:48.112] result() for MulticoreFuture ... done
[17:46:48.112] result() for MulticoreFuture ...
[17:46:48.112] result() for MulticoreFuture ... done
[17:46:48.116] MulticoreFuture started
[17:46:48.116] - Launch lazy future ... done
[17:46:48.117] run() for ‘MulticoreFuture’ ... done
[17:46:48.117] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x561788ddaef8> 
[17:46:48.117] List of future strategies:
[17:46:48.117] 1. sequential:
[17:46:48.117]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.117]    - tweaked: FALSE
[17:46:48.117]    - call: NULL
[17:46:48.118] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5617899c1640> 
[17:46:48.120] plan(): Setting new future strategy stack:
[17:46:48.121] List of future strategies:
[17:46:48.121] 1. multicore:
[17:46:48.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.121]    - tweaked: FALSE
[17:46:48.121]    - call: plan(strategy)
[17:46:48.126] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:48.129] resolve() on list environment ...
[17:46:48.129]  recursive: 0
[17:46:48.131]  length: 6
[17:46:48.131]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:48.131] signalConditionsASAP(numeric, pos=1) ...
[17:46:48.131] - nx: 6
[17:46:48.131] - relay: TRUE
[17:46:48.132] - stdout: TRUE
[17:46:48.132] - signal: TRUE
[17:46:48.132] - resignal: FALSE
[17:46:48.132] - force: TRUE
[17:46:48.132] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.132] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.132]  - until=2
[17:46:48.132]  - relaying element #2
[17:46:48.133] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.133] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.133] signalConditionsASAP(NULL, pos=1) ... done
[17:46:48.133]  length: 5 (resolved future 1)
[17:46:48.133] Future #2
[17:46:48.133] result() for MulticoreFuture ...
[17:46:48.133] result() for MulticoreFuture ... done
[17:46:48.134] result() for MulticoreFuture ...
[17:46:48.134] result() for MulticoreFuture ... done
[17:46:48.134] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:48.134] - nx: 6
[17:46:48.134] - relay: TRUE
[17:46:48.134] - stdout: TRUE
[17:46:48.134] - signal: TRUE
[17:46:48.134] - resignal: FALSE
[17:46:48.142] - force: TRUE
[17:46:48.142] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.143] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.143]  - until=2
[17:46:48.144]  - relaying element #2
[17:46:48.144] result() for MulticoreFuture ...
[17:46:48.145] result() for MulticoreFuture ... done
[17:46:48.145] result() for MulticoreFuture ...
[17:46:48.145] result() for MulticoreFuture ... done
[17:46:48.146] result() for MulticoreFuture ...
[17:46:48.146] result() for MulticoreFuture ... done
[17:46:48.146] result() for MulticoreFuture ...
[17:46:48.146] result() for MulticoreFuture ... done
[17:46:48.146] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.146] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.146] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:48.147]  length: 4 (resolved future 2)
[17:46:48.147] Future #3
[17:46:48.147] result() for MulticoreFuture ...
[17:46:48.148] result() for MulticoreFuture ...
[17:46:48.148] result() for MulticoreFuture ... done
[17:46:48.149] result() for MulticoreFuture ... done
[17:46:48.149] result() for MulticoreFuture ...
[17:46:48.149] result() for MulticoreFuture ... done
[17:46:48.149] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:48.149] - nx: 6
[17:46:48.149] - relay: TRUE
[17:46:48.150] - stdout: TRUE
[17:46:48.150] - signal: TRUE
[17:46:48.150] - resignal: FALSE
[17:46:48.150] - force: TRUE
[17:46:48.150] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.150] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.151]  - until=3
[17:46:48.151]  - relaying element #3
[17:46:48.151] result() for MulticoreFuture ...
[17:46:48.151] result() for MulticoreFuture ... done
[17:46:48.151] result() for MulticoreFuture ...
[17:46:48.152] result() for MulticoreFuture ... done
[17:46:48.152] result() for MulticoreFuture ...
[17:46:48.152] result() for MulticoreFuture ... done
[17:46:48.152] result() for MulticoreFuture ...
[17:46:48.152] result() for MulticoreFuture ... done
[17:46:48.153] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.153] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.153] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:48.153]  length: 3 (resolved future 3)
[17:46:48.154] Future #4
[17:46:48.154] result() for MulticoreFuture ...
[17:46:48.154] result() for MulticoreFuture ...
[17:46:48.154] result() for MulticoreFuture ... done
[17:46:48.155] result() for MulticoreFuture ... done
[17:46:48.155] result() for MulticoreFuture ...
[17:46:48.155] result() for MulticoreFuture ... done
[17:46:48.155] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:48.155] - nx: 6
[17:46:48.155] - relay: TRUE
[17:46:48.155] - stdout: TRUE
[17:46:48.156] - signal: TRUE
[17:46:48.156] - resignal: FALSE
[17:46:48.156] - force: TRUE
[17:46:48.156] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.156] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.156]  - until=4
[17:46:48.156]  - relaying element #4
[17:46:48.156] result() for MulticoreFuture ...
[17:46:48.156] result() for MulticoreFuture ... done
[17:46:48.157] result() for MulticoreFuture ...
[17:46:48.157] result() for MulticoreFuture ... done
[17:46:48.157] result() for MulticoreFuture ...
[17:46:48.157] result() for MulticoreFuture ... done
[17:46:48.157] result() for MulticoreFuture ...
[17:46:48.157] result() for MulticoreFuture ... done
[17:46:48.157] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.157] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.157] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:48.158]  length: 2 (resolved future 4)
[17:46:48.158] signalConditionsASAP(NULL, pos=5) ...
[17:46:48.158] - nx: 6
[17:46:48.158] - relay: TRUE
[17:46:48.158] - stdout: TRUE
[17:46:48.158] - signal: TRUE
[17:46:48.158] - resignal: FALSE
[17:46:48.158] - force: TRUE
[17:46:48.158] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.158] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.159]  - until=6
[17:46:48.159]  - relaying element #6
[17:46:48.159] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.159] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.159] signalConditionsASAP(NULL, pos=5) ... done
[17:46:48.159]  length: 1 (resolved future 5)
[17:46:48.159] signalConditionsASAP(numeric, pos=6) ...
[17:46:48.159] - nx: 6
[17:46:48.159] - relay: TRUE
[17:46:48.160] - stdout: TRUE
[17:46:48.160] - signal: TRUE
[17:46:48.160] - resignal: FALSE
[17:46:48.160] - force: TRUE
[17:46:48.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.160] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.160]  - until=6
[17:46:48.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.160] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.160] signalConditionsASAP(numeric, pos=6) ... done
[17:46:48.161]  length: 0 (resolved future 6)
[17:46:48.161] Relaying remaining futures
[17:46:48.161] signalConditionsASAP(NULL, pos=0) ...
[17:46:48.161] - nx: 6
[17:46:48.161] - relay: TRUE
[17:46:48.161] - stdout: TRUE
[17:46:48.161] - signal: TRUE
[17:46:48.161] - resignal: FALSE
[17:46:48.161] - force: TRUE
[17:46:48.161] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.162] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:48.162] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.162] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.162] signalConditionsASAP(NULL, pos=0) ... done
[17:46:48.162] resolve() on list environment ... DONE
[17:46:48.162] result() for MulticoreFuture ...
[17:46:48.162] result() for MulticoreFuture ... done
[17:46:48.162] result() for MulticoreFuture ...
[17:46:48.163] result() for MulticoreFuture ... done
[17:46:48.163] result() for MulticoreFuture ...
[17:46:48.163] result() for MulticoreFuture ... done
[17:46:48.163] result() for MulticoreFuture ...
[17:46:48.163] result() for MulticoreFuture ... done
[17:46:48.163] result() for MulticoreFuture ...
[17:46:48.163] result() for MulticoreFuture ... done
[17:46:48.163] result() for MulticoreFuture ...
[17:46:48.164] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x561789b12940> 
Dimensions: c(1, 6)
[17:46:48.164] getGlobalsAndPackages() ...
[17:46:48.164] Searching for globals...
[17:46:48.165] 
[17:46:48.165] Searching for globals ... DONE
[17:46:48.165] - globals: [0] <none>
[17:46:48.165] getGlobalsAndPackages() ... DONE
[17:46:48.165] run() for ‘Future’ ...
[17:46:48.166] - state: ‘created’
[17:46:48.166] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.170] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.170]   - Field: ‘label’
[17:46:48.170]   - Field: ‘local’
[17:46:48.170]   - Field: ‘owner’
[17:46:48.170]   - Field: ‘envir’
[17:46:48.171]   - Field: ‘workers’
[17:46:48.171]   - Field: ‘packages’
[17:46:48.171]   - Field: ‘gc’
[17:46:48.171]   - Field: ‘job’
[17:46:48.171]   - Field: ‘conditions’
[17:46:48.171]   - Field: ‘expr’
[17:46:48.171]   - Field: ‘uuid’
[17:46:48.171]   - Field: ‘seed’
[17:46:48.171]   - Field: ‘version’
[17:46:48.172]   - Field: ‘result’
[17:46:48.172]   - Field: ‘asynchronous’
[17:46:48.172]   - Field: ‘calls’
[17:46:48.172]   - Field: ‘globals’
[17:46:48.172]   - Field: ‘stdout’
[17:46:48.172]   - Field: ‘earlySignal’
[17:46:48.172]   - Field: ‘lazy’
[17:46:48.172]   - Field: ‘state’
[17:46:48.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.172] - Launch lazy future ...
[17:46:48.173] Packages needed by the future expression (n = 0): <none>
[17:46:48.173] Packages needed by future strategies (n = 0): <none>
[17:46:48.173] {
[17:46:48.173]     {
[17:46:48.173]         {
[17:46:48.173]             ...future.startTime <- base::Sys.time()
[17:46:48.173]             {
[17:46:48.173]                 {
[17:46:48.173]                   {
[17:46:48.173]                     {
[17:46:48.173]                       base::local({
[17:46:48.173]                         has_future <- base::requireNamespace("future", 
[17:46:48.173]                           quietly = TRUE)
[17:46:48.173]                         if (has_future) {
[17:46:48.173]                           ns <- base::getNamespace("future")
[17:46:48.173]                           version <- ns[[".package"]][["version"]]
[17:46:48.173]                           if (is.null(version)) 
[17:46:48.173]                             version <- utils::packageVersion("future")
[17:46:48.173]                         }
[17:46:48.173]                         else {
[17:46:48.173]                           version <- NULL
[17:46:48.173]                         }
[17:46:48.173]                         if (!has_future || version < "1.8.0") {
[17:46:48.173]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.173]                             "", base::R.version$version.string), 
[17:46:48.173]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.173]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.173]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.173]                               "release", "version")], collapse = " "), 
[17:46:48.173]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.173]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.173]                             info)
[17:46:48.173]                           info <- base::paste(info, collapse = "; ")
[17:46:48.173]                           if (!has_future) {
[17:46:48.173]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.173]                               info)
[17:46:48.173]                           }
[17:46:48.173]                           else {
[17:46:48.173]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.173]                               info, version)
[17:46:48.173]                           }
[17:46:48.173]                           base::stop(msg)
[17:46:48.173]                         }
[17:46:48.173]                       })
[17:46:48.173]                     }
[17:46:48.173]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.173]                     base::options(mc.cores = 1L)
[17:46:48.173]                   }
[17:46:48.173]                   ...future.strategy.old <- future::plan("list")
[17:46:48.173]                   options(future.plan = NULL)
[17:46:48.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.173]                 }
[17:46:48.173]                 ...future.workdir <- getwd()
[17:46:48.173]             }
[17:46:48.173]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.173]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.173]         }
[17:46:48.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.173]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.173]             base::names(...future.oldOptions))
[17:46:48.173]     }
[17:46:48.173]     if (FALSE) {
[17:46:48.173]     }
[17:46:48.173]     else {
[17:46:48.173]         if (TRUE) {
[17:46:48.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.173]                 open = "w")
[17:46:48.173]         }
[17:46:48.173]         else {
[17:46:48.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.173]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.173]         }
[17:46:48.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.173]             base::sink(type = "output", split = FALSE)
[17:46:48.173]             base::close(...future.stdout)
[17:46:48.173]         }, add = TRUE)
[17:46:48.173]     }
[17:46:48.173]     ...future.frame <- base::sys.nframe()
[17:46:48.173]     ...future.conditions <- base::list()
[17:46:48.173]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.173]     if (FALSE) {
[17:46:48.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.173]     }
[17:46:48.173]     ...future.result <- base::tryCatch({
[17:46:48.173]         base::withCallingHandlers({
[17:46:48.173]             ...future.value <- base::withVisible(base::local({
[17:46:48.173]                 withCallingHandlers({
[17:46:48.173]                   2
[17:46:48.173]                 }, immediateCondition = function(cond) {
[17:46:48.173]                   save_rds <- function (object, pathname, ...) 
[17:46:48.173]                   {
[17:46:48.173]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.173]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.173]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.173]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.173]                         fi_tmp[["mtime"]])
[17:46:48.173]                     }
[17:46:48.173]                     tryCatch({
[17:46:48.173]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.173]                     }, error = function(ex) {
[17:46:48.173]                       msg <- conditionMessage(ex)
[17:46:48.173]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.173]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.173]                         fi_tmp[["mtime"]], msg)
[17:46:48.173]                       ex$message <- msg
[17:46:48.173]                       stop(ex)
[17:46:48.173]                     })
[17:46:48.173]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.173]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.173]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.173]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.173]                       fi <- file.info(pathname)
[17:46:48.173]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.173]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.173]                         fi[["size"]], fi[["mtime"]])
[17:46:48.173]                       stop(msg)
[17:46:48.173]                     }
[17:46:48.173]                     invisible(pathname)
[17:46:48.173]                   }
[17:46:48.173]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.173]                     rootPath = tempdir()) 
[17:46:48.173]                   {
[17:46:48.173]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.173]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.173]                       tmpdir = path, fileext = ".rds")
[17:46:48.173]                     save_rds(obj, file)
[17:46:48.173]                   }
[17:46:48.173]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.173]                   {
[17:46:48.173]                     inherits <- base::inherits
[17:46:48.173]                     invokeRestart <- base::invokeRestart
[17:46:48.173]                     is.null <- base::is.null
[17:46:48.173]                     muffled <- FALSE
[17:46:48.173]                     if (inherits(cond, "message")) {
[17:46:48.173]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.173]                       if (muffled) 
[17:46:48.173]                         invokeRestart("muffleMessage")
[17:46:48.173]                     }
[17:46:48.173]                     else if (inherits(cond, "warning")) {
[17:46:48.173]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.173]                       if (muffled) 
[17:46:48.173]                         invokeRestart("muffleWarning")
[17:46:48.173]                     }
[17:46:48.173]                     else if (inherits(cond, "condition")) {
[17:46:48.173]                       if (!is.null(pattern)) {
[17:46:48.173]                         computeRestarts <- base::computeRestarts
[17:46:48.173]                         grepl <- base::grepl
[17:46:48.173]                         restarts <- computeRestarts(cond)
[17:46:48.173]                         for (restart in restarts) {
[17:46:48.173]                           name <- restart$name
[17:46:48.173]                           if (is.null(name)) 
[17:46:48.173]                             next
[17:46:48.173]                           if (!grepl(pattern, name)) 
[17:46:48.173]                             next
[17:46:48.173]                           invokeRestart(restart)
[17:46:48.173]                           muffled <- TRUE
[17:46:48.173]                           break
[17:46:48.173]                         }
[17:46:48.173]                       }
[17:46:48.173]                     }
[17:46:48.173]                     invisible(muffled)
[17:46:48.173]                   }
[17:46:48.173]                   muffleCondition(cond)
[17:46:48.173]                 })
[17:46:48.173]             }))
[17:46:48.173]             future::FutureResult(value = ...future.value$value, 
[17:46:48.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.173]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.173]                     ...future.globalenv.names))
[17:46:48.173]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.173]         }, condition = base::local({
[17:46:48.173]             c <- base::c
[17:46:48.173]             inherits <- base::inherits
[17:46:48.173]             invokeRestart <- base::invokeRestart
[17:46:48.173]             length <- base::length
[17:46:48.173]             list <- base::list
[17:46:48.173]             seq.int <- base::seq.int
[17:46:48.173]             signalCondition <- base::signalCondition
[17:46:48.173]             sys.calls <- base::sys.calls
[17:46:48.173]             `[[` <- base::`[[`
[17:46:48.173]             `+` <- base::`+`
[17:46:48.173]             `<<-` <- base::`<<-`
[17:46:48.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.173]                   3L)]
[17:46:48.173]             }
[17:46:48.173]             function(cond) {
[17:46:48.173]                 is_error <- inherits(cond, "error")
[17:46:48.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.173]                   NULL)
[17:46:48.173]                 if (is_error) {
[17:46:48.173]                   sessionInformation <- function() {
[17:46:48.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.173]                       search = base::search(), system = base::Sys.info())
[17:46:48.173]                   }
[17:46:48.173]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.173]                     cond$call), session = sessionInformation(), 
[17:46:48.173]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.173]                   signalCondition(cond)
[17:46:48.173]                 }
[17:46:48.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.173]                 "immediateCondition"))) {
[17:46:48.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.173]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.173]                   if (TRUE && !signal) {
[17:46:48.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.173]                     {
[17:46:48.173]                       inherits <- base::inherits
[17:46:48.173]                       invokeRestart <- base::invokeRestart
[17:46:48.173]                       is.null <- base::is.null
[17:46:48.173]                       muffled <- FALSE
[17:46:48.173]                       if (inherits(cond, "message")) {
[17:46:48.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.173]                         if (muffled) 
[17:46:48.173]                           invokeRestart("muffleMessage")
[17:46:48.173]                       }
[17:46:48.173]                       else if (inherits(cond, "warning")) {
[17:46:48.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.173]                         if (muffled) 
[17:46:48.173]                           invokeRestart("muffleWarning")
[17:46:48.173]                       }
[17:46:48.173]                       else if (inherits(cond, "condition")) {
[17:46:48.173]                         if (!is.null(pattern)) {
[17:46:48.173]                           computeRestarts <- base::computeRestarts
[17:46:48.173]                           grepl <- base::grepl
[17:46:48.173]                           restarts <- computeRestarts(cond)
[17:46:48.173]                           for (restart in restarts) {
[17:46:48.173]                             name <- restart$name
[17:46:48.173]                             if (is.null(name)) 
[17:46:48.173]                               next
[17:46:48.173]                             if (!grepl(pattern, name)) 
[17:46:48.173]                               next
[17:46:48.173]                             invokeRestart(restart)
[17:46:48.173]                             muffled <- TRUE
[17:46:48.173]                             break
[17:46:48.173]                           }
[17:46:48.173]                         }
[17:46:48.173]                       }
[17:46:48.173]                       invisible(muffled)
[17:46:48.173]                     }
[17:46:48.173]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.173]                   }
[17:46:48.173]                 }
[17:46:48.173]                 else {
[17:46:48.173]                   if (TRUE) {
[17:46:48.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.173]                     {
[17:46:48.173]                       inherits <- base::inherits
[17:46:48.173]                       invokeRestart <- base::invokeRestart
[17:46:48.173]                       is.null <- base::is.null
[17:46:48.173]                       muffled <- FALSE
[17:46:48.173]                       if (inherits(cond, "message")) {
[17:46:48.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.173]                         if (muffled) 
[17:46:48.173]                           invokeRestart("muffleMessage")
[17:46:48.173]                       }
[17:46:48.173]                       else if (inherits(cond, "warning")) {
[17:46:48.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.173]                         if (muffled) 
[17:46:48.173]                           invokeRestart("muffleWarning")
[17:46:48.173]                       }
[17:46:48.173]                       else if (inherits(cond, "condition")) {
[17:46:48.173]                         if (!is.null(pattern)) {
[17:46:48.173]                           computeRestarts <- base::computeRestarts
[17:46:48.173]                           grepl <- base::grepl
[17:46:48.173]                           restarts <- computeRestarts(cond)
[17:46:48.173]                           for (restart in restarts) {
[17:46:48.173]                             name <- restart$name
[17:46:48.173]                             if (is.null(name)) 
[17:46:48.173]                               next
[17:46:48.173]                             if (!grepl(pattern, name)) 
[17:46:48.173]                               next
[17:46:48.173]                             invokeRestart(restart)
[17:46:48.173]                             muffled <- TRUE
[17:46:48.173]                             break
[17:46:48.173]                           }
[17:46:48.173]                         }
[17:46:48.173]                       }
[17:46:48.173]                       invisible(muffled)
[17:46:48.173]                     }
[17:46:48.173]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.173]                   }
[17:46:48.173]                 }
[17:46:48.173]             }
[17:46:48.173]         }))
[17:46:48.173]     }, error = function(ex) {
[17:46:48.173]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.173]                 ...future.rng), started = ...future.startTime, 
[17:46:48.173]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.173]             version = "1.8"), class = "FutureResult")
[17:46:48.173]     }, finally = {
[17:46:48.173]         if (!identical(...future.workdir, getwd())) 
[17:46:48.173]             setwd(...future.workdir)
[17:46:48.173]         {
[17:46:48.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.173]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.173]             }
[17:46:48.173]             base::options(...future.oldOptions)
[17:46:48.173]             if (.Platform$OS.type == "windows") {
[17:46:48.173]                 old_names <- names(...future.oldEnvVars)
[17:46:48.173]                 envs <- base::Sys.getenv()
[17:46:48.173]                 names <- names(envs)
[17:46:48.173]                 common <- intersect(names, old_names)
[17:46:48.173]                 added <- setdiff(names, old_names)
[17:46:48.173]                 removed <- setdiff(old_names, names)
[17:46:48.173]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.173]                   envs[common]]
[17:46:48.173]                 NAMES <- toupper(changed)
[17:46:48.173]                 args <- list()
[17:46:48.173]                 for (kk in seq_along(NAMES)) {
[17:46:48.173]                   name <- changed[[kk]]
[17:46:48.173]                   NAME <- NAMES[[kk]]
[17:46:48.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.173]                     next
[17:46:48.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.173]                 }
[17:46:48.173]                 NAMES <- toupper(added)
[17:46:48.173]                 for (kk in seq_along(NAMES)) {
[17:46:48.173]                   name <- added[[kk]]
[17:46:48.173]                   NAME <- NAMES[[kk]]
[17:46:48.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.173]                     next
[17:46:48.173]                   args[[name]] <- ""
[17:46:48.173]                 }
[17:46:48.173]                 NAMES <- toupper(removed)
[17:46:48.173]                 for (kk in seq_along(NAMES)) {
[17:46:48.173]                   name <- removed[[kk]]
[17:46:48.173]                   NAME <- NAMES[[kk]]
[17:46:48.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.173]                     next
[17:46:48.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.173]                 }
[17:46:48.173]                 if (length(args) > 0) 
[17:46:48.173]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.173]             }
[17:46:48.173]             else {
[17:46:48.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.173]             }
[17:46:48.173]             {
[17:46:48.173]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.173]                   0L) {
[17:46:48.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.173]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.173]                   base::options(opts)
[17:46:48.173]                 }
[17:46:48.173]                 {
[17:46:48.173]                   {
[17:46:48.173]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.173]                     NULL
[17:46:48.173]                   }
[17:46:48.173]                   options(future.plan = NULL)
[17:46:48.173]                   if (is.na(NA_character_)) 
[17:46:48.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.173]                     .init = FALSE)
[17:46:48.173]                 }
[17:46:48.173]             }
[17:46:48.173]         }
[17:46:48.173]     })
[17:46:48.173]     if (TRUE) {
[17:46:48.173]         base::sink(type = "output", split = FALSE)
[17:46:48.173]         if (TRUE) {
[17:46:48.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.173]         }
[17:46:48.173]         else {
[17:46:48.173]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.173]         }
[17:46:48.173]         base::close(...future.stdout)
[17:46:48.173]         ...future.stdout <- NULL
[17:46:48.173]     }
[17:46:48.173]     ...future.result$conditions <- ...future.conditions
[17:46:48.173]     ...future.result$finished <- base::Sys.time()
[17:46:48.173]     ...future.result
[17:46:48.173] }
[17:46:48.176] requestCore(): workers = 2
[17:46:48.178] MulticoreFuture started
[17:46:48.178] - Launch lazy future ... done
[17:46:48.178] run() for ‘MulticoreFuture’ ... done
[17:46:48.179] getGlobalsAndPackages() ...
[17:46:48.179] Searching for globals...
[17:46:48.179] plan(): Setting new future strategy stack:
[17:46:48.179] List of future strategies:
[17:46:48.179] 1. sequential:
[17:46:48.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.179]    - tweaked: FALSE
[17:46:48.179]    - call: NULL
[17:46:48.180] 
[17:46:48.180] Searching for globals ... DONE
[17:46:48.180] plan(): nbrOfWorkers() = 1
[17:46:48.180] - globals: [0] <none>
[17:46:48.180] getGlobalsAndPackages() ... DONE
[17:46:48.181] run() for ‘Future’ ...
[17:46:48.181] - state: ‘created’
[17:46:48.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.182] plan(): Setting new future strategy stack:
[17:46:48.182] List of future strategies:
[17:46:48.182] 1. multicore:
[17:46:48.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.182]    - tweaked: FALSE
[17:46:48.182]    - call: plan(strategy)
[17:46:48.187] plan(): nbrOfWorkers() = 2
[17:46:48.187] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.188]   - Field: ‘label’
[17:46:48.188]   - Field: ‘local’
[17:46:48.188]   - Field: ‘owner’
[17:46:48.189]   - Field: ‘envir’
[17:46:48.189]   - Field: ‘workers’
[17:46:48.189]   - Field: ‘packages’
[17:46:48.189]   - Field: ‘gc’
[17:46:48.189]   - Field: ‘job’
[17:46:48.189]   - Field: ‘conditions’
[17:46:48.190]   - Field: ‘expr’
[17:46:48.190]   - Field: ‘uuid’
[17:46:48.190]   - Field: ‘seed’
[17:46:48.190]   - Field: ‘version’
[17:46:48.190]   - Field: ‘result’
[17:46:48.191]   - Field: ‘asynchronous’
[17:46:48.191]   - Field: ‘calls’
[17:46:48.191]   - Field: ‘globals’
[17:46:48.191]   - Field: ‘stdout’
[17:46:48.191]   - Field: ‘earlySignal’
[17:46:48.191]   - Field: ‘lazy’
[17:46:48.192]   - Field: ‘state’
[17:46:48.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.192] - Launch lazy future ...
[17:46:48.192] Packages needed by the future expression (n = 0): <none>
[17:46:48.193] Packages needed by future strategies (n = 0): <none>
[17:46:48.193] {
[17:46:48.193]     {
[17:46:48.193]         {
[17:46:48.193]             ...future.startTime <- base::Sys.time()
[17:46:48.193]             {
[17:46:48.193]                 {
[17:46:48.193]                   {
[17:46:48.193]                     {
[17:46:48.193]                       base::local({
[17:46:48.193]                         has_future <- base::requireNamespace("future", 
[17:46:48.193]                           quietly = TRUE)
[17:46:48.193]                         if (has_future) {
[17:46:48.193]                           ns <- base::getNamespace("future")
[17:46:48.193]                           version <- ns[[".package"]][["version"]]
[17:46:48.193]                           if (is.null(version)) 
[17:46:48.193]                             version <- utils::packageVersion("future")
[17:46:48.193]                         }
[17:46:48.193]                         else {
[17:46:48.193]                           version <- NULL
[17:46:48.193]                         }
[17:46:48.193]                         if (!has_future || version < "1.8.0") {
[17:46:48.193]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.193]                             "", base::R.version$version.string), 
[17:46:48.193]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.193]                               "release", "version")], collapse = " "), 
[17:46:48.193]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.193]                             info)
[17:46:48.193]                           info <- base::paste(info, collapse = "; ")
[17:46:48.193]                           if (!has_future) {
[17:46:48.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.193]                               info)
[17:46:48.193]                           }
[17:46:48.193]                           else {
[17:46:48.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.193]                               info, version)
[17:46:48.193]                           }
[17:46:48.193]                           base::stop(msg)
[17:46:48.193]                         }
[17:46:48.193]                       })
[17:46:48.193]                     }
[17:46:48.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.193]                     base::options(mc.cores = 1L)
[17:46:48.193]                   }
[17:46:48.193]                   ...future.strategy.old <- future::plan("list")
[17:46:48.193]                   options(future.plan = NULL)
[17:46:48.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.193]                 }
[17:46:48.193]                 ...future.workdir <- getwd()
[17:46:48.193]             }
[17:46:48.193]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.193]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.193]         }
[17:46:48.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.193]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.193]             base::names(...future.oldOptions))
[17:46:48.193]     }
[17:46:48.193]     if (FALSE) {
[17:46:48.193]     }
[17:46:48.193]     else {
[17:46:48.193]         if (TRUE) {
[17:46:48.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.193]                 open = "w")
[17:46:48.193]         }
[17:46:48.193]         else {
[17:46:48.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.193]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.193]         }
[17:46:48.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.193]             base::sink(type = "output", split = FALSE)
[17:46:48.193]             base::close(...future.stdout)
[17:46:48.193]         }, add = TRUE)
[17:46:48.193]     }
[17:46:48.193]     ...future.frame <- base::sys.nframe()
[17:46:48.193]     ...future.conditions <- base::list()
[17:46:48.193]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.193]     if (FALSE) {
[17:46:48.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.193]     }
[17:46:48.193]     ...future.result <- base::tryCatch({
[17:46:48.193]         base::withCallingHandlers({
[17:46:48.193]             ...future.value <- base::withVisible(base::local({
[17:46:48.193]                 withCallingHandlers({
[17:46:48.193]                   NULL
[17:46:48.193]                 }, immediateCondition = function(cond) {
[17:46:48.193]                   save_rds <- function (object, pathname, ...) 
[17:46:48.193]                   {
[17:46:48.193]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.193]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.193]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.193]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.193]                         fi_tmp[["mtime"]])
[17:46:48.193]                     }
[17:46:48.193]                     tryCatch({
[17:46:48.193]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.193]                     }, error = function(ex) {
[17:46:48.193]                       msg <- conditionMessage(ex)
[17:46:48.193]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.193]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.193]                         fi_tmp[["mtime"]], msg)
[17:46:48.193]                       ex$message <- msg
[17:46:48.193]                       stop(ex)
[17:46:48.193]                     })
[17:46:48.193]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.193]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.193]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.193]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.193]                       fi <- file.info(pathname)
[17:46:48.193]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.193]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.193]                         fi[["size"]], fi[["mtime"]])
[17:46:48.193]                       stop(msg)
[17:46:48.193]                     }
[17:46:48.193]                     invisible(pathname)
[17:46:48.193]                   }
[17:46:48.193]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.193]                     rootPath = tempdir()) 
[17:46:48.193]                   {
[17:46:48.193]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.193]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.193]                       tmpdir = path, fileext = ".rds")
[17:46:48.193]                     save_rds(obj, file)
[17:46:48.193]                   }
[17:46:48.193]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.193]                   {
[17:46:48.193]                     inherits <- base::inherits
[17:46:48.193]                     invokeRestart <- base::invokeRestart
[17:46:48.193]                     is.null <- base::is.null
[17:46:48.193]                     muffled <- FALSE
[17:46:48.193]                     if (inherits(cond, "message")) {
[17:46:48.193]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.193]                       if (muffled) 
[17:46:48.193]                         invokeRestart("muffleMessage")
[17:46:48.193]                     }
[17:46:48.193]                     else if (inherits(cond, "warning")) {
[17:46:48.193]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.193]                       if (muffled) 
[17:46:48.193]                         invokeRestart("muffleWarning")
[17:46:48.193]                     }
[17:46:48.193]                     else if (inherits(cond, "condition")) {
[17:46:48.193]                       if (!is.null(pattern)) {
[17:46:48.193]                         computeRestarts <- base::computeRestarts
[17:46:48.193]                         grepl <- base::grepl
[17:46:48.193]                         restarts <- computeRestarts(cond)
[17:46:48.193]                         for (restart in restarts) {
[17:46:48.193]                           name <- restart$name
[17:46:48.193]                           if (is.null(name)) 
[17:46:48.193]                             next
[17:46:48.193]                           if (!grepl(pattern, name)) 
[17:46:48.193]                             next
[17:46:48.193]                           invokeRestart(restart)
[17:46:48.193]                           muffled <- TRUE
[17:46:48.193]                           break
[17:46:48.193]                         }
[17:46:48.193]                       }
[17:46:48.193]                     }
[17:46:48.193]                     invisible(muffled)
[17:46:48.193]                   }
[17:46:48.193]                   muffleCondition(cond)
[17:46:48.193]                 })
[17:46:48.193]             }))
[17:46:48.193]             future::FutureResult(value = ...future.value$value, 
[17:46:48.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.193]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.193]                     ...future.globalenv.names))
[17:46:48.193]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.193]         }, condition = base::local({
[17:46:48.193]             c <- base::c
[17:46:48.193]             inherits <- base::inherits
[17:46:48.193]             invokeRestart <- base::invokeRestart
[17:46:48.193]             length <- base::length
[17:46:48.193]             list <- base::list
[17:46:48.193]             seq.int <- base::seq.int
[17:46:48.193]             signalCondition <- base::signalCondition
[17:46:48.193]             sys.calls <- base::sys.calls
[17:46:48.193]             `[[` <- base::`[[`
[17:46:48.193]             `+` <- base::`+`
[17:46:48.193]             `<<-` <- base::`<<-`
[17:46:48.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.193]                   3L)]
[17:46:48.193]             }
[17:46:48.193]             function(cond) {
[17:46:48.193]                 is_error <- inherits(cond, "error")
[17:46:48.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.193]                   NULL)
[17:46:48.193]                 if (is_error) {
[17:46:48.193]                   sessionInformation <- function() {
[17:46:48.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.193]                       search = base::search(), system = base::Sys.info())
[17:46:48.193]                   }
[17:46:48.193]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.193]                     cond$call), session = sessionInformation(), 
[17:46:48.193]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.193]                   signalCondition(cond)
[17:46:48.193]                 }
[17:46:48.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.193]                 "immediateCondition"))) {
[17:46:48.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.193]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.193]                   if (TRUE && !signal) {
[17:46:48.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.193]                     {
[17:46:48.193]                       inherits <- base::inherits
[17:46:48.193]                       invokeRestart <- base::invokeRestart
[17:46:48.193]                       is.null <- base::is.null
[17:46:48.193]                       muffled <- FALSE
[17:46:48.193]                       if (inherits(cond, "message")) {
[17:46:48.193]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.193]                         if (muffled) 
[17:46:48.193]                           invokeRestart("muffleMessage")
[17:46:48.193]                       }
[17:46:48.193]                       else if (inherits(cond, "warning")) {
[17:46:48.193]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.193]                         if (muffled) 
[17:46:48.193]                           invokeRestart("muffleWarning")
[17:46:48.193]                       }
[17:46:48.193]                       else if (inherits(cond, "condition")) {
[17:46:48.193]                         if (!is.null(pattern)) {
[17:46:48.193]                           computeRestarts <- base::computeRestarts
[17:46:48.193]                           grepl <- base::grepl
[17:46:48.193]                           restarts <- computeRestarts(cond)
[17:46:48.193]                           for (restart in restarts) {
[17:46:48.193]                             name <- restart$name
[17:46:48.193]                             if (is.null(name)) 
[17:46:48.193]                               next
[17:46:48.193]                             if (!grepl(pattern, name)) 
[17:46:48.193]                               next
[17:46:48.193]                             invokeRestart(restart)
[17:46:48.193]                             muffled <- TRUE
[17:46:48.193]                             break
[17:46:48.193]                           }
[17:46:48.193]                         }
[17:46:48.193]                       }
[17:46:48.193]                       invisible(muffled)
[17:46:48.193]                     }
[17:46:48.193]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.193]                   }
[17:46:48.193]                 }
[17:46:48.193]                 else {
[17:46:48.193]                   if (TRUE) {
[17:46:48.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.193]                     {
[17:46:48.193]                       inherits <- base::inherits
[17:46:48.193]                       invokeRestart <- base::invokeRestart
[17:46:48.193]                       is.null <- base::is.null
[17:46:48.193]                       muffled <- FALSE
[17:46:48.193]                       if (inherits(cond, "message")) {
[17:46:48.193]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.193]                         if (muffled) 
[17:46:48.193]                           invokeRestart("muffleMessage")
[17:46:48.193]                       }
[17:46:48.193]                       else if (inherits(cond, "warning")) {
[17:46:48.193]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.193]                         if (muffled) 
[17:46:48.193]                           invokeRestart("muffleWarning")
[17:46:48.193]                       }
[17:46:48.193]                       else if (inherits(cond, "condition")) {
[17:46:48.193]                         if (!is.null(pattern)) {
[17:46:48.193]                           computeRestarts <- base::computeRestarts
[17:46:48.193]                           grepl <- base::grepl
[17:46:48.193]                           restarts <- computeRestarts(cond)
[17:46:48.193]                           for (restart in restarts) {
[17:46:48.193]                             name <- restart$name
[17:46:48.193]                             if (is.null(name)) 
[17:46:48.193]                               next
[17:46:48.193]                             if (!grepl(pattern, name)) 
[17:46:48.193]                               next
[17:46:48.193]                             invokeRestart(restart)
[17:46:48.193]                             muffled <- TRUE
[17:46:48.193]                             break
[17:46:48.193]                           }
[17:46:48.193]                         }
[17:46:48.193]                       }
[17:46:48.193]                       invisible(muffled)
[17:46:48.193]                     }
[17:46:48.193]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.193]                   }
[17:46:48.193]                 }
[17:46:48.193]             }
[17:46:48.193]         }))
[17:46:48.193]     }, error = function(ex) {
[17:46:48.193]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.193]                 ...future.rng), started = ...future.startTime, 
[17:46:48.193]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.193]             version = "1.8"), class = "FutureResult")
[17:46:48.193]     }, finally = {
[17:46:48.193]         if (!identical(...future.workdir, getwd())) 
[17:46:48.193]             setwd(...future.workdir)
[17:46:48.193]         {
[17:46:48.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.193]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.193]             }
[17:46:48.193]             base::options(...future.oldOptions)
[17:46:48.193]             if (.Platform$OS.type == "windows") {
[17:46:48.193]                 old_names <- names(...future.oldEnvVars)
[17:46:48.193]                 envs <- base::Sys.getenv()
[17:46:48.193]                 names <- names(envs)
[17:46:48.193]                 common <- intersect(names, old_names)
[17:46:48.193]                 added <- setdiff(names, old_names)
[17:46:48.193]                 removed <- setdiff(old_names, names)
[17:46:48.193]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.193]                   envs[common]]
[17:46:48.193]                 NAMES <- toupper(changed)
[17:46:48.193]                 args <- list()
[17:46:48.193]                 for (kk in seq_along(NAMES)) {
[17:46:48.193]                   name <- changed[[kk]]
[17:46:48.193]                   NAME <- NAMES[[kk]]
[17:46:48.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.193]                     next
[17:46:48.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.193]                 }
[17:46:48.193]                 NAMES <- toupper(added)
[17:46:48.193]                 for (kk in seq_along(NAMES)) {
[17:46:48.193]                   name <- added[[kk]]
[17:46:48.193]                   NAME <- NAMES[[kk]]
[17:46:48.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.193]                     next
[17:46:48.193]                   args[[name]] <- ""
[17:46:48.193]                 }
[17:46:48.193]                 NAMES <- toupper(removed)
[17:46:48.193]                 for (kk in seq_along(NAMES)) {
[17:46:48.193]                   name <- removed[[kk]]
[17:46:48.193]                   NAME <- NAMES[[kk]]
[17:46:48.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.193]                     next
[17:46:48.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.193]                 }
[17:46:48.193]                 if (length(args) > 0) 
[17:46:48.193]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.193]             }
[17:46:48.193]             else {
[17:46:48.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.193]             }
[17:46:48.193]             {
[17:46:48.193]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.193]                   0L) {
[17:46:48.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.193]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.193]                   base::options(opts)
[17:46:48.193]                 }
[17:46:48.193]                 {
[17:46:48.193]                   {
[17:46:48.193]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.193]                     NULL
[17:46:48.193]                   }
[17:46:48.193]                   options(future.plan = NULL)
[17:46:48.193]                   if (is.na(NA_character_)) 
[17:46:48.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.193]                     .init = FALSE)
[17:46:48.193]                 }
[17:46:48.193]             }
[17:46:48.193]         }
[17:46:48.193]     })
[17:46:48.193]     if (TRUE) {
[17:46:48.193]         base::sink(type = "output", split = FALSE)
[17:46:48.193]         if (TRUE) {
[17:46:48.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.193]         }
[17:46:48.193]         else {
[17:46:48.193]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.193]         }
[17:46:48.193]         base::close(...future.stdout)
[17:46:48.193]         ...future.stdout <- NULL
[17:46:48.193]     }
[17:46:48.193]     ...future.result$conditions <- ...future.conditions
[17:46:48.193]     ...future.result$finished <- base::Sys.time()
[17:46:48.193]     ...future.result
[17:46:48.193] }
[17:46:48.197] requestCore(): workers = 2
[17:46:48.200] MulticoreFuture started
[17:46:48.200] - Launch lazy future ... done
[17:46:48.200] run() for ‘MulticoreFuture’ ... done
[17:46:48.201] plan(): Setting new future strategy stack:
[17:46:48.202] getGlobalsAndPackages() ...
[17:46:48.202] Searching for globals...
[17:46:48.201] List of future strategies:
[17:46:48.201] 1. sequential:
[17:46:48.201]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.201]    - tweaked: FALSE
[17:46:48.201]    - call: NULL
[17:46:48.202] plan(): nbrOfWorkers() = 1
[17:46:48.203] - globals found: [1] ‘{’
[17:46:48.203] Searching for globals ... DONE
[17:46:48.204] Resolving globals: FALSE
[17:46:48.204] 
[17:46:48.204] 
[17:46:48.204] getGlobalsAndPackages() ... DONE
[17:46:48.204] plan(): Setting new future strategy stack:
[17:46:48.205] run() for ‘Future’ ...
[17:46:48.205] List of future strategies:
[17:46:48.205] 1. multicore:
[17:46:48.205]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.205]    - tweaked: FALSE
[17:46:48.205]    - call: plan(strategy)
[17:46:48.205] - state: ‘created’
[17:46:48.205] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.210] plan(): nbrOfWorkers() = 2
[17:46:48.210] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.211] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.211]   - Field: ‘label’
[17:46:48.211]   - Field: ‘local’
[17:46:48.211]   - Field: ‘owner’
[17:46:48.211]   - Field: ‘envir’
[17:46:48.212]   - Field: ‘workers’
[17:46:48.212]   - Field: ‘packages’
[17:46:48.212]   - Field: ‘gc’
[17:46:48.212]   - Field: ‘job’
[17:46:48.212]   - Field: ‘conditions’
[17:46:48.212]   - Field: ‘expr’
[17:46:48.212]   - Field: ‘uuid’
[17:46:48.213]   - Field: ‘seed’
[17:46:48.213]   - Field: ‘version’
[17:46:48.213]   - Field: ‘result’
[17:46:48.213]   - Field: ‘asynchronous’
[17:46:48.213]   - Field: ‘calls’
[17:46:48.213]   - Field: ‘globals’
[17:46:48.213]   - Field: ‘stdout’
[17:46:48.213]   - Field: ‘earlySignal’
[17:46:48.214]   - Field: ‘lazy’
[17:46:48.214]   - Field: ‘state’
[17:46:48.214] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.214] - Launch lazy future ...
[17:46:48.214] Packages needed by the future expression (n = 0): <none>
[17:46:48.215] Packages needed by future strategies (n = 0): <none>
[17:46:48.215] {
[17:46:48.215]     {
[17:46:48.215]         {
[17:46:48.215]             ...future.startTime <- base::Sys.time()
[17:46:48.215]             {
[17:46:48.215]                 {
[17:46:48.215]                   {
[17:46:48.215]                     {
[17:46:48.215]                       base::local({
[17:46:48.215]                         has_future <- base::requireNamespace("future", 
[17:46:48.215]                           quietly = TRUE)
[17:46:48.215]                         if (has_future) {
[17:46:48.215]                           ns <- base::getNamespace("future")
[17:46:48.215]                           version <- ns[[".package"]][["version"]]
[17:46:48.215]                           if (is.null(version)) 
[17:46:48.215]                             version <- utils::packageVersion("future")
[17:46:48.215]                         }
[17:46:48.215]                         else {
[17:46:48.215]                           version <- NULL
[17:46:48.215]                         }
[17:46:48.215]                         if (!has_future || version < "1.8.0") {
[17:46:48.215]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.215]                             "", base::R.version$version.string), 
[17:46:48.215]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.215]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.215]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.215]                               "release", "version")], collapse = " "), 
[17:46:48.215]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.215]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.215]                             info)
[17:46:48.215]                           info <- base::paste(info, collapse = "; ")
[17:46:48.215]                           if (!has_future) {
[17:46:48.215]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.215]                               info)
[17:46:48.215]                           }
[17:46:48.215]                           else {
[17:46:48.215]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.215]                               info, version)
[17:46:48.215]                           }
[17:46:48.215]                           base::stop(msg)
[17:46:48.215]                         }
[17:46:48.215]                       })
[17:46:48.215]                     }
[17:46:48.215]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.215]                     base::options(mc.cores = 1L)
[17:46:48.215]                   }
[17:46:48.215]                   ...future.strategy.old <- future::plan("list")
[17:46:48.215]                   options(future.plan = NULL)
[17:46:48.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.215]                 }
[17:46:48.215]                 ...future.workdir <- getwd()
[17:46:48.215]             }
[17:46:48.215]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.215]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.215]         }
[17:46:48.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.215]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.215]             base::names(...future.oldOptions))
[17:46:48.215]     }
[17:46:48.215]     if (FALSE) {
[17:46:48.215]     }
[17:46:48.215]     else {
[17:46:48.215]         if (TRUE) {
[17:46:48.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.215]                 open = "w")
[17:46:48.215]         }
[17:46:48.215]         else {
[17:46:48.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.215]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.215]         }
[17:46:48.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.215]             base::sink(type = "output", split = FALSE)
[17:46:48.215]             base::close(...future.stdout)
[17:46:48.215]         }, add = TRUE)
[17:46:48.215]     }
[17:46:48.215]     ...future.frame <- base::sys.nframe()
[17:46:48.215]     ...future.conditions <- base::list()
[17:46:48.215]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.215]     if (FALSE) {
[17:46:48.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.215]     }
[17:46:48.215]     ...future.result <- base::tryCatch({
[17:46:48.215]         base::withCallingHandlers({
[17:46:48.215]             ...future.value <- base::withVisible(base::local({
[17:46:48.215]                 withCallingHandlers({
[17:46:48.215]                   {
[17:46:48.215]                     4
[17:46:48.215]                   }
[17:46:48.215]                 }, immediateCondition = function(cond) {
[17:46:48.215]                   save_rds <- function (object, pathname, ...) 
[17:46:48.215]                   {
[17:46:48.215]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.215]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.215]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.215]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.215]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.215]                         fi_tmp[["mtime"]])
[17:46:48.215]                     }
[17:46:48.215]                     tryCatch({
[17:46:48.215]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.215]                     }, error = function(ex) {
[17:46:48.215]                       msg <- conditionMessage(ex)
[17:46:48.215]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.215]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.215]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.215]                         fi_tmp[["mtime"]], msg)
[17:46:48.215]                       ex$message <- msg
[17:46:48.215]                       stop(ex)
[17:46:48.215]                     })
[17:46:48.215]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.215]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.215]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.215]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.215]                       fi <- file.info(pathname)
[17:46:48.215]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.215]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.215]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.215]                         fi[["size"]], fi[["mtime"]])
[17:46:48.215]                       stop(msg)
[17:46:48.215]                     }
[17:46:48.215]                     invisible(pathname)
[17:46:48.215]                   }
[17:46:48.215]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.215]                     rootPath = tempdir()) 
[17:46:48.215]                   {
[17:46:48.215]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.215]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.215]                       tmpdir = path, fileext = ".rds")
[17:46:48.215]                     save_rds(obj, file)
[17:46:48.215]                   }
[17:46:48.215]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.215]                   {
[17:46:48.215]                     inherits <- base::inherits
[17:46:48.215]                     invokeRestart <- base::invokeRestart
[17:46:48.215]                     is.null <- base::is.null
[17:46:48.215]                     muffled <- FALSE
[17:46:48.215]                     if (inherits(cond, "message")) {
[17:46:48.215]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.215]                       if (muffled) 
[17:46:48.215]                         invokeRestart("muffleMessage")
[17:46:48.215]                     }
[17:46:48.215]                     else if (inherits(cond, "warning")) {
[17:46:48.215]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.215]                       if (muffled) 
[17:46:48.215]                         invokeRestart("muffleWarning")
[17:46:48.215]                     }
[17:46:48.215]                     else if (inherits(cond, "condition")) {
[17:46:48.215]                       if (!is.null(pattern)) {
[17:46:48.215]                         computeRestarts <- base::computeRestarts
[17:46:48.215]                         grepl <- base::grepl
[17:46:48.215]                         restarts <- computeRestarts(cond)
[17:46:48.215]                         for (restart in restarts) {
[17:46:48.215]                           name <- restart$name
[17:46:48.215]                           if (is.null(name)) 
[17:46:48.215]                             next
[17:46:48.215]                           if (!grepl(pattern, name)) 
[17:46:48.215]                             next
[17:46:48.215]                           invokeRestart(restart)
[17:46:48.215]                           muffled <- TRUE
[17:46:48.215]                           break
[17:46:48.215]                         }
[17:46:48.215]                       }
[17:46:48.215]                     }
[17:46:48.215]                     invisible(muffled)
[17:46:48.215]                   }
[17:46:48.215]                   muffleCondition(cond)
[17:46:48.215]                 })
[17:46:48.215]             }))
[17:46:48.215]             future::FutureResult(value = ...future.value$value, 
[17:46:48.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.215]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.215]                     ...future.globalenv.names))
[17:46:48.215]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.215]         }, condition = base::local({
[17:46:48.215]             c <- base::c
[17:46:48.215]             inherits <- base::inherits
[17:46:48.215]             invokeRestart <- base::invokeRestart
[17:46:48.215]             length <- base::length
[17:46:48.215]             list <- base::list
[17:46:48.215]             seq.int <- base::seq.int
[17:46:48.215]             signalCondition <- base::signalCondition
[17:46:48.215]             sys.calls <- base::sys.calls
[17:46:48.215]             `[[` <- base::`[[`
[17:46:48.215]             `+` <- base::`+`
[17:46:48.215]             `<<-` <- base::`<<-`
[17:46:48.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.215]                   3L)]
[17:46:48.215]             }
[17:46:48.215]             function(cond) {
[17:46:48.215]                 is_error <- inherits(cond, "error")
[17:46:48.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.215]                   NULL)
[17:46:48.215]                 if (is_error) {
[17:46:48.215]                   sessionInformation <- function() {
[17:46:48.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.215]                       search = base::search(), system = base::Sys.info())
[17:46:48.215]                   }
[17:46:48.215]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.215]                     cond$call), session = sessionInformation(), 
[17:46:48.215]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.215]                   signalCondition(cond)
[17:46:48.215]                 }
[17:46:48.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.215]                 "immediateCondition"))) {
[17:46:48.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.215]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.215]                   if (TRUE && !signal) {
[17:46:48.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.215]                     {
[17:46:48.215]                       inherits <- base::inherits
[17:46:48.215]                       invokeRestart <- base::invokeRestart
[17:46:48.215]                       is.null <- base::is.null
[17:46:48.215]                       muffled <- FALSE
[17:46:48.215]                       if (inherits(cond, "message")) {
[17:46:48.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.215]                         if (muffled) 
[17:46:48.215]                           invokeRestart("muffleMessage")
[17:46:48.215]                       }
[17:46:48.215]                       else if (inherits(cond, "warning")) {
[17:46:48.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.215]                         if (muffled) 
[17:46:48.215]                           invokeRestart("muffleWarning")
[17:46:48.215]                       }
[17:46:48.215]                       else if (inherits(cond, "condition")) {
[17:46:48.215]                         if (!is.null(pattern)) {
[17:46:48.215]                           computeRestarts <- base::computeRestarts
[17:46:48.215]                           grepl <- base::grepl
[17:46:48.215]                           restarts <- computeRestarts(cond)
[17:46:48.215]                           for (restart in restarts) {
[17:46:48.215]                             name <- restart$name
[17:46:48.215]                             if (is.null(name)) 
[17:46:48.215]                               next
[17:46:48.215]                             if (!grepl(pattern, name)) 
[17:46:48.215]                               next
[17:46:48.215]                             invokeRestart(restart)
[17:46:48.215]                             muffled <- TRUE
[17:46:48.215]                             break
[17:46:48.215]                           }
[17:46:48.215]                         }
[17:46:48.215]                       }
[17:46:48.215]                       invisible(muffled)
[17:46:48.215]                     }
[17:46:48.215]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.215]                   }
[17:46:48.215]                 }
[17:46:48.215]                 else {
[17:46:48.215]                   if (TRUE) {
[17:46:48.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.215]                     {
[17:46:48.215]                       inherits <- base::inherits
[17:46:48.215]                       invokeRestart <- base::invokeRestart
[17:46:48.215]                       is.null <- base::is.null
[17:46:48.215]                       muffled <- FALSE
[17:46:48.215]                       if (inherits(cond, "message")) {
[17:46:48.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.215]                         if (muffled) 
[17:46:48.215]                           invokeRestart("muffleMessage")
[17:46:48.215]                       }
[17:46:48.215]                       else if (inherits(cond, "warning")) {
[17:46:48.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.215]                         if (muffled) 
[17:46:48.215]                           invokeRestart("muffleWarning")
[17:46:48.215]                       }
[17:46:48.215]                       else if (inherits(cond, "condition")) {
[17:46:48.215]                         if (!is.null(pattern)) {
[17:46:48.215]                           computeRestarts <- base::computeRestarts
[17:46:48.215]                           grepl <- base::grepl
[17:46:48.215]                           restarts <- computeRestarts(cond)
[17:46:48.215]                           for (restart in restarts) {
[17:46:48.215]                             name <- restart$name
[17:46:48.215]                             if (is.null(name)) 
[17:46:48.215]                               next
[17:46:48.215]                             if (!grepl(pattern, name)) 
[17:46:48.215]                               next
[17:46:48.215]                             invokeRestart(restart)
[17:46:48.215]                             muffled <- TRUE
[17:46:48.215]                             break
[17:46:48.215]                           }
[17:46:48.215]                         }
[17:46:48.215]                       }
[17:46:48.215]                       invisible(muffled)
[17:46:48.215]                     }
[17:46:48.215]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.215]                   }
[17:46:48.215]                 }
[17:46:48.215]             }
[17:46:48.215]         }))
[17:46:48.215]     }, error = function(ex) {
[17:46:48.215]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.215]                 ...future.rng), started = ...future.startTime, 
[17:46:48.215]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.215]             version = "1.8"), class = "FutureResult")
[17:46:48.215]     }, finally = {
[17:46:48.215]         if (!identical(...future.workdir, getwd())) 
[17:46:48.215]             setwd(...future.workdir)
[17:46:48.215]         {
[17:46:48.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.215]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.215]             }
[17:46:48.215]             base::options(...future.oldOptions)
[17:46:48.215]             if (.Platform$OS.type == "windows") {
[17:46:48.215]                 old_names <- names(...future.oldEnvVars)
[17:46:48.215]                 envs <- base::Sys.getenv()
[17:46:48.215]                 names <- names(envs)
[17:46:48.215]                 common <- intersect(names, old_names)
[17:46:48.215]                 added <- setdiff(names, old_names)
[17:46:48.215]                 removed <- setdiff(old_names, names)
[17:46:48.215]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.215]                   envs[common]]
[17:46:48.215]                 NAMES <- toupper(changed)
[17:46:48.215]                 args <- list()
[17:46:48.215]                 for (kk in seq_along(NAMES)) {
[17:46:48.215]                   name <- changed[[kk]]
[17:46:48.215]                   NAME <- NAMES[[kk]]
[17:46:48.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.215]                     next
[17:46:48.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.215]                 }
[17:46:48.215]                 NAMES <- toupper(added)
[17:46:48.215]                 for (kk in seq_along(NAMES)) {
[17:46:48.215]                   name <- added[[kk]]
[17:46:48.215]                   NAME <- NAMES[[kk]]
[17:46:48.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.215]                     next
[17:46:48.215]                   args[[name]] <- ""
[17:46:48.215]                 }
[17:46:48.215]                 NAMES <- toupper(removed)
[17:46:48.215]                 for (kk in seq_along(NAMES)) {
[17:46:48.215]                   name <- removed[[kk]]
[17:46:48.215]                   NAME <- NAMES[[kk]]
[17:46:48.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.215]                     next
[17:46:48.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.215]                 }
[17:46:48.215]                 if (length(args) > 0) 
[17:46:48.215]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.215]             }
[17:46:48.215]             else {
[17:46:48.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.215]             }
[17:46:48.215]             {
[17:46:48.215]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.215]                   0L) {
[17:46:48.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.215]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.215]                   base::options(opts)
[17:46:48.215]                 }
[17:46:48.215]                 {
[17:46:48.215]                   {
[17:46:48.215]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.215]                     NULL
[17:46:48.215]                   }
[17:46:48.215]                   options(future.plan = NULL)
[17:46:48.215]                   if (is.na(NA_character_)) 
[17:46:48.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.215]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.215]                     .init = FALSE)
[17:46:48.215]                 }
[17:46:48.215]             }
[17:46:48.215]         }
[17:46:48.215]     })
[17:46:48.215]     if (TRUE) {
[17:46:48.215]         base::sink(type = "output", split = FALSE)
[17:46:48.215]         if (TRUE) {
[17:46:48.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.215]         }
[17:46:48.215]         else {
[17:46:48.215]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.215]         }
[17:46:48.215]         base::close(...future.stdout)
[17:46:48.215]         ...future.stdout <- NULL
[17:46:48.215]     }
[17:46:48.215]     ...future.result$conditions <- ...future.conditions
[17:46:48.215]     ...future.result$finished <- base::Sys.time()
[17:46:48.215]     ...future.result
[17:46:48.215] }
[17:46:48.219] requestCore(): workers = 2
[17:46:48.219] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:48.230] result() for MulticoreFuture ...
[17:46:48.231] result() for MulticoreFuture ...
[17:46:48.231] result() for MulticoreFuture ... done
[17:46:48.231] result() for MulticoreFuture ... done
[17:46:48.232] result() for MulticoreFuture ...
[17:46:48.232] result() for MulticoreFuture ... done
[17:46:48.234] MulticoreFuture started
[17:46:48.235] - Launch lazy future ... done
[17:46:48.235] run() for ‘MulticoreFuture’ ... done
[17:46:48.236] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x561787895e18> 
[17:46:48.236] List of future strategies:
[17:46:48.236] 1. sequential:
[17:46:48.236]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.236]    - tweaked: FALSE
[17:46:48.236]    - call: NULL
[17:46:48.237] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x561788de6e88> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=[17:46:48.240] plan(): Setting new future strategy stack:
List of 2
  ..$ :[17:46:48.240] List of future strategies:
[17:46:48.240] 1. multicore:
[17:46:48.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.240]    - tweaked: FALSE
[17:46:48.240]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:46:48.246] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:48.250] resolve() on list environment ...
[17:46:48.250]  recursive: 0
[17:46:48.251]  length: 6
[17:46:48.251]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:48.252] signalConditionsASAP(numeric, pos=1) ...
[17:46:48.252] - nx: 6
[17:46:48.252] - relay: TRUE
[17:46:48.252] - stdout: TRUE
[17:46:48.252] - signal: TRUE
[17:46:48.252] - resignal: FALSE
[17:46:48.252] - force: TRUE
[17:46:48.253] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.253] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.253]  - until=2
[17:46:48.253]  - relaying element #2
[17:46:48.253] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.253] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.253] signalConditionsASAP(NULL, pos=1) ... done
[17:46:48.253]  length: 5 (resolved future 1)
[17:46:48.254] Future #2
[17:46:48.254] result() for MulticoreFuture ...
[17:46:48.254] result() for MulticoreFuture ... done
[17:46:48.254] result() for MulticoreFuture ...
[17:46:48.254] result() for MulticoreFuture ... done
[17:46:48.254] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:48.254] - nx: 6
[17:46:48.255] - relay: TRUE
[17:46:48.255] - stdout: TRUE
[17:46:48.255] - signal: TRUE
[17:46:48.255] - resignal: FALSE
[17:46:48.255] - force: TRUE
[17:46:48.255] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.255] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.255]  - until=2
[17:46:48.256]  - relaying element #2
[17:46:48.256] result() for MulticoreFuture ...
[17:46:48.256] result() for MulticoreFuture ... done
[17:46:48.256] result() for MulticoreFuture ...
[17:46:48.256] result() for MulticoreFuture ... done
[17:46:48.256] result() for MulticoreFuture ...
[17:46:48.256] result() for MulticoreFuture ... done
[17:46:48.257] result() for MulticoreFuture ...
[17:46:48.257] result() for MulticoreFuture ... done
[17:46:48.257] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.257] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.257] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:48.257]  length: 4 (resolved future 2)
[17:46:48.257] Future #3
[17:46:48.258] result() for MulticoreFuture ...
[17:46:48.258] result() for MulticoreFuture ...
[17:46:48.259] result() for MulticoreFuture ... done
[17:46:48.259] result() for MulticoreFuture ... done
[17:46:48.259] result() for MulticoreFuture ...
[17:46:48.259] result() for MulticoreFuture ... done
[17:46:48.259] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:48.259] - nx: 6
[17:46:48.259] - relay: TRUE
[17:46:48.260] - stdout: TRUE
[17:46:48.260] - signal: TRUE
[17:46:48.260] - resignal: FALSE
[17:46:48.260] - force: TRUE
[17:46:48.260] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.260] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.260]  - until=3
[17:46:48.260]  - relaying element #3
[17:46:48.260] result() for MulticoreFuture ...
[17:46:48.261] result() for MulticoreFuture ... done
[17:46:48.261] result() for MulticoreFuture ...
[17:46:48.261] result() for MulticoreFuture ... done
[17:46:48.261] result() for MulticoreFuture ...
[17:46:48.261] result() for MulticoreFuture ... done
[17:46:48.261] result() for MulticoreFuture ...
[17:46:48.261] result() for MulticoreFuture ... done
[17:46:48.262] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.262] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.262] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:48.262]  length: 3 (resolved future 3)
[17:46:48.262] Future #4
[17:46:48.262] result() for MulticoreFuture ...
[17:46:48.263] result() for MulticoreFuture ...
[17:46:48.263] result() for MulticoreFuture ... done
[17:46:48.264] result() for MulticoreFuture ... done
[17:46:48.264] result() for MulticoreFuture ...
[17:46:48.264] result() for MulticoreFuture ... done
[17:46:48.264] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:48.264] - nx: 6
[17:46:48.265] - relay: TRUE
[17:46:48.265] - stdout: TRUE
[17:46:48.265] - signal: TRUE
[17:46:48.265] - resignal: FALSE
[17:46:48.265] - force: TRUE
[17:46:48.265] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.265] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.266]  - until=4
[17:46:48.266]  - relaying element #4
[17:46:48.266] result() for MulticoreFuture ...
[17:46:48.266] result() for MulticoreFuture ... done
[17:46:48.266] result() for MulticoreFuture ...
[17:46:48.266] result() for MulticoreFuture ... done
[17:46:48.267] result() for MulticoreFuture ...
[17:46:48.267] result() for MulticoreFuture ... done
[17:46:48.267] result() for MulticoreFuture ...
[17:46:48.267] result() for MulticoreFuture ... done
[17:46:48.267] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.267] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.267] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:48.268]  length: 2 (resolved future 4)
[17:46:48.268] signalConditionsASAP(NULL, pos=5) ...
[17:46:48.268] - nx: 6
[17:46:48.268] - relay: TRUE
[17:46:48.268] - stdout: TRUE
[17:46:48.268] - signal: TRUE
[17:46:48.268] - resignal: FALSE
[17:46:48.268] - force: TRUE
[17:46:48.268] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.268] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.269]  - until=6
[17:46:48.269]  - relaying element #6
[17:46:48.269] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.269] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.269] signalConditionsASAP(NULL, pos=5) ... done
[17:46:48.269]  length: 1 (resolved future 5)
[17:46:48.269] signalConditionsASAP(numeric, pos=6) ...
[17:46:48.269] - nx: 6
[17:46:48.269] - relay: TRUE
[17:46:48.269] - stdout: TRUE
[17:46:48.270] - signal: TRUE
[17:46:48.270] - resignal: FALSE
[17:46:48.270] - force: TRUE
[17:46:48.270] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.270] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.270]  - until=6
[17:46:48.270] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.270] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.270] signalConditionsASAP(numeric, pos=6) ... done
[17:46:48.270]  length: 0 (resolved future 6)
[17:46:48.271] Relaying remaining futures
[17:46:48.271] signalConditionsASAP(NULL, pos=0) ...
[17:46:48.271] - nx: 6
[17:46:48.271] - relay: TRUE
[17:46:48.271] - stdout: TRUE
[17:46:48.271] - signal: TRUE
[17:46:48.271] - resignal: FALSE
[17:46:48.271] - force: TRUE
[17:46:48.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.271] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:48.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.272] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.272] signalConditionsASAP(NULL, pos=0) ... done
[17:46:48.272] resolve() on list environment ... DONE
[17:46:48.272] result() for MulticoreFuture ...
[17:46:48.272] result() for MulticoreFuture ... done
[17:46:48.272] result() for MulticoreFuture ...
[17:46:48.272] result() for MulticoreFuture ... done
[17:46:48.273] result() for MulticoreFuture ...
[17:46:48.273] result() for MulticoreFuture ... done
[17:46:48.273] result() for MulticoreFuture ...
[17:46:48.273] result() for MulticoreFuture ... done
[17:46:48.273] result() for MulticoreFuture ...
[17:46:48.273] result() for MulticoreFuture ... done
[17:46:48.273] result() for MulticoreFuture ...
[17:46:48.273] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x561789124f48> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:46:48.275] getGlobalsAndPackages() ...
[17:46:48.276] Searching for globals...
[17:46:48.276] 
[17:46:48.276] Searching for globals ... DONE
[17:46:48.276] - globals: [0] <none>
[17:46:48.276] getGlobalsAndPackages() ... DONE
[17:46:48.277] run() for ‘Future’ ...
[17:46:48.277] - state: ‘created’
[17:46:48.277] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.282] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.282]   - Field: ‘label’
[17:46:48.282]   - Field: ‘local’
[17:46:48.282]   - Field: ‘owner’
[17:46:48.282]   - Field: ‘envir’
[17:46:48.282]   - Field: ‘workers’
[17:46:48.283]   - Field: ‘packages’
[17:46:48.283]   - Field: ‘gc’
[17:46:48.283]   - Field: ‘job’
[17:46:48.283]   - Field: ‘conditions’
[17:46:48.283]   - Field: ‘expr’
[17:46:48.283]   - Field: ‘uuid’
[17:46:48.283]   - Field: ‘seed’
[17:46:48.283]   - Field: ‘version’
[17:46:48.283]   - Field: ‘result’
[17:46:48.284]   - Field: ‘asynchronous’
[17:46:48.284]   - Field: ‘calls’
[17:46:48.284]   - Field: ‘globals’
[17:46:48.284]   - Field: ‘stdout’
[17:46:48.284]   - Field: ‘earlySignal’
[17:46:48.284]   - Field: ‘lazy’
[17:46:48.284]   - Field: ‘state’
[17:46:48.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.288] - Launch lazy future ...
[17:46:48.289] Packages needed by the future expression (n = 0): <none>
[17:46:48.289] Packages needed by future strategies (n = 0): <none>
[17:46:48.290] {
[17:46:48.290]     {
[17:46:48.290]         {
[17:46:48.290]             ...future.startTime <- base::Sys.time()
[17:46:48.290]             {
[17:46:48.290]                 {
[17:46:48.290]                   {
[17:46:48.290]                     {
[17:46:48.290]                       base::local({
[17:46:48.290]                         has_future <- base::requireNamespace("future", 
[17:46:48.290]                           quietly = TRUE)
[17:46:48.290]                         if (has_future) {
[17:46:48.290]                           ns <- base::getNamespace("future")
[17:46:48.290]                           version <- ns[[".package"]][["version"]]
[17:46:48.290]                           if (is.null(version)) 
[17:46:48.290]                             version <- utils::packageVersion("future")
[17:46:48.290]                         }
[17:46:48.290]                         else {
[17:46:48.290]                           version <- NULL
[17:46:48.290]                         }
[17:46:48.290]                         if (!has_future || version < "1.8.0") {
[17:46:48.290]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.290]                             "", base::R.version$version.string), 
[17:46:48.290]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.290]                               "release", "version")], collapse = " "), 
[17:46:48.290]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.290]                             info)
[17:46:48.290]                           info <- base::paste(info, collapse = "; ")
[17:46:48.290]                           if (!has_future) {
[17:46:48.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.290]                               info)
[17:46:48.290]                           }
[17:46:48.290]                           else {
[17:46:48.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.290]                               info, version)
[17:46:48.290]                           }
[17:46:48.290]                           base::stop(msg)
[17:46:48.290]                         }
[17:46:48.290]                       })
[17:46:48.290]                     }
[17:46:48.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.290]                     base::options(mc.cores = 1L)
[17:46:48.290]                   }
[17:46:48.290]                   ...future.strategy.old <- future::plan("list")
[17:46:48.290]                   options(future.plan = NULL)
[17:46:48.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.290]                 }
[17:46:48.290]                 ...future.workdir <- getwd()
[17:46:48.290]             }
[17:46:48.290]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.290]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.290]         }
[17:46:48.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.290]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.290]             base::names(...future.oldOptions))
[17:46:48.290]     }
[17:46:48.290]     if (FALSE) {
[17:46:48.290]     }
[17:46:48.290]     else {
[17:46:48.290]         if (TRUE) {
[17:46:48.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.290]                 open = "w")
[17:46:48.290]         }
[17:46:48.290]         else {
[17:46:48.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.290]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.290]         }
[17:46:48.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.290]             base::sink(type = "output", split = FALSE)
[17:46:48.290]             base::close(...future.stdout)
[17:46:48.290]         }, add = TRUE)
[17:46:48.290]     }
[17:46:48.290]     ...future.frame <- base::sys.nframe()
[17:46:48.290]     ...future.conditions <- base::list()
[17:46:48.290]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.290]     if (FALSE) {
[17:46:48.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.290]     }
[17:46:48.290]     ...future.result <- base::tryCatch({
[17:46:48.290]         base::withCallingHandlers({
[17:46:48.290]             ...future.value <- base::withVisible(base::local({
[17:46:48.290]                 withCallingHandlers({
[17:46:48.290]                   2
[17:46:48.290]                 }, immediateCondition = function(cond) {
[17:46:48.290]                   save_rds <- function (object, pathname, ...) 
[17:46:48.290]                   {
[17:46:48.290]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.290]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.290]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.290]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.290]                         fi_tmp[["mtime"]])
[17:46:48.290]                     }
[17:46:48.290]                     tryCatch({
[17:46:48.290]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.290]                     }, error = function(ex) {
[17:46:48.290]                       msg <- conditionMessage(ex)
[17:46:48.290]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.290]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.290]                         fi_tmp[["mtime"]], msg)
[17:46:48.290]                       ex$message <- msg
[17:46:48.290]                       stop(ex)
[17:46:48.290]                     })
[17:46:48.290]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.290]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.290]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.290]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.290]                       fi <- file.info(pathname)
[17:46:48.290]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.290]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.290]                         fi[["size"]], fi[["mtime"]])
[17:46:48.290]                       stop(msg)
[17:46:48.290]                     }
[17:46:48.290]                     invisible(pathname)
[17:46:48.290]                   }
[17:46:48.290]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.290]                     rootPath = tempdir()) 
[17:46:48.290]                   {
[17:46:48.290]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.290]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.290]                       tmpdir = path, fileext = ".rds")
[17:46:48.290]                     save_rds(obj, file)
[17:46:48.290]                   }
[17:46:48.290]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.290]                   {
[17:46:48.290]                     inherits <- base::inherits
[17:46:48.290]                     invokeRestart <- base::invokeRestart
[17:46:48.290]                     is.null <- base::is.null
[17:46:48.290]                     muffled <- FALSE
[17:46:48.290]                     if (inherits(cond, "message")) {
[17:46:48.290]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.290]                       if (muffled) 
[17:46:48.290]                         invokeRestart("muffleMessage")
[17:46:48.290]                     }
[17:46:48.290]                     else if (inherits(cond, "warning")) {
[17:46:48.290]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.290]                       if (muffled) 
[17:46:48.290]                         invokeRestart("muffleWarning")
[17:46:48.290]                     }
[17:46:48.290]                     else if (inherits(cond, "condition")) {
[17:46:48.290]                       if (!is.null(pattern)) {
[17:46:48.290]                         computeRestarts <- base::computeRestarts
[17:46:48.290]                         grepl <- base::grepl
[17:46:48.290]                         restarts <- computeRestarts(cond)
[17:46:48.290]                         for (restart in restarts) {
[17:46:48.290]                           name <- restart$name
[17:46:48.290]                           if (is.null(name)) 
[17:46:48.290]                             next
[17:46:48.290]                           if (!grepl(pattern, name)) 
[17:46:48.290]                             next
[17:46:48.290]                           invokeRestart(restart)
[17:46:48.290]                           muffled <- TRUE
[17:46:48.290]                           break
[17:46:48.290]                         }
[17:46:48.290]                       }
[17:46:48.290]                     }
[17:46:48.290]                     invisible(muffled)
[17:46:48.290]                   }
[17:46:48.290]                   muffleCondition(cond)
[17:46:48.290]                 })
[17:46:48.290]             }))
[17:46:48.290]             future::FutureResult(value = ...future.value$value, 
[17:46:48.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.290]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.290]                     ...future.globalenv.names))
[17:46:48.290]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.290]         }, condition = base::local({
[17:46:48.290]             c <- base::c
[17:46:48.290]             inherits <- base::inherits
[17:46:48.290]             invokeRestart <- base::invokeRestart
[17:46:48.290]             length <- base::length
[17:46:48.290]             list <- base::list
[17:46:48.290]             seq.int <- base::seq.int
[17:46:48.290]             signalCondition <- base::signalCondition
[17:46:48.290]             sys.calls <- base::sys.calls
[17:46:48.290]             `[[` <- base::`[[`
[17:46:48.290]             `+` <- base::`+`
[17:46:48.290]             `<<-` <- base::`<<-`
[17:46:48.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.290]                   3L)]
[17:46:48.290]             }
[17:46:48.290]             function(cond) {
[17:46:48.290]                 is_error <- inherits(cond, "error")
[17:46:48.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.290]                   NULL)
[17:46:48.290]                 if (is_error) {
[17:46:48.290]                   sessionInformation <- function() {
[17:46:48.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.290]                       search = base::search(), system = base::Sys.info())
[17:46:48.290]                   }
[17:46:48.290]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.290]                     cond$call), session = sessionInformation(), 
[17:46:48.290]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.290]                   signalCondition(cond)
[17:46:48.290]                 }
[17:46:48.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.290]                 "immediateCondition"))) {
[17:46:48.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.290]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.290]                   if (TRUE && !signal) {
[17:46:48.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.290]                     {
[17:46:48.290]                       inherits <- base::inherits
[17:46:48.290]                       invokeRestart <- base::invokeRestart
[17:46:48.290]                       is.null <- base::is.null
[17:46:48.290]                       muffled <- FALSE
[17:46:48.290]                       if (inherits(cond, "message")) {
[17:46:48.290]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.290]                         if (muffled) 
[17:46:48.290]                           invokeRestart("muffleMessage")
[17:46:48.290]                       }
[17:46:48.290]                       else if (inherits(cond, "warning")) {
[17:46:48.290]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.290]                         if (muffled) 
[17:46:48.290]                           invokeRestart("muffleWarning")
[17:46:48.290]                       }
[17:46:48.290]                       else if (inherits(cond, "condition")) {
[17:46:48.290]                         if (!is.null(pattern)) {
[17:46:48.290]                           computeRestarts <- base::computeRestarts
[17:46:48.290]                           grepl <- base::grepl
[17:46:48.290]                           restarts <- computeRestarts(cond)
[17:46:48.290]                           for (restart in restarts) {
[17:46:48.290]                             name <- restart$name
[17:46:48.290]                             if (is.null(name)) 
[17:46:48.290]                               next
[17:46:48.290]                             if (!grepl(pattern, name)) 
[17:46:48.290]                               next
[17:46:48.290]                             invokeRestart(restart)
[17:46:48.290]                             muffled <- TRUE
[17:46:48.290]                             break
[17:46:48.290]                           }
[17:46:48.290]                         }
[17:46:48.290]                       }
[17:46:48.290]                       invisible(muffled)
[17:46:48.290]                     }
[17:46:48.290]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.290]                   }
[17:46:48.290]                 }
[17:46:48.290]                 else {
[17:46:48.290]                   if (TRUE) {
[17:46:48.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.290]                     {
[17:46:48.290]                       inherits <- base::inherits
[17:46:48.290]                       invokeRestart <- base::invokeRestart
[17:46:48.290]                       is.null <- base::is.null
[17:46:48.290]                       muffled <- FALSE
[17:46:48.290]                       if (inherits(cond, "message")) {
[17:46:48.290]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.290]                         if (muffled) 
[17:46:48.290]                           invokeRestart("muffleMessage")
[17:46:48.290]                       }
[17:46:48.290]                       else if (inherits(cond, "warning")) {
[17:46:48.290]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.290]                         if (muffled) 
[17:46:48.290]                           invokeRestart("muffleWarning")
[17:46:48.290]                       }
[17:46:48.290]                       else if (inherits(cond, "condition")) {
[17:46:48.290]                         if (!is.null(pattern)) {
[17:46:48.290]                           computeRestarts <- base::computeRestarts
[17:46:48.290]                           grepl <- base::grepl
[17:46:48.290]                           restarts <- computeRestarts(cond)
[17:46:48.290]                           for (restart in restarts) {
[17:46:48.290]                             name <- restart$name
[17:46:48.290]                             if (is.null(name)) 
[17:46:48.290]                               next
[17:46:48.290]                             if (!grepl(pattern, name)) 
[17:46:48.290]                               next
[17:46:48.290]                             invokeRestart(restart)
[17:46:48.290]                             muffled <- TRUE
[17:46:48.290]                             break
[17:46:48.290]                           }
[17:46:48.290]                         }
[17:46:48.290]                       }
[17:46:48.290]                       invisible(muffled)
[17:46:48.290]                     }
[17:46:48.290]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.290]                   }
[17:46:48.290]                 }
[17:46:48.290]             }
[17:46:48.290]         }))
[17:46:48.290]     }, error = function(ex) {
[17:46:48.290]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.290]                 ...future.rng), started = ...future.startTime, 
[17:46:48.290]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.290]             version = "1.8"), class = "FutureResult")
[17:46:48.290]     }, finally = {
[17:46:48.290]         if (!identical(...future.workdir, getwd())) 
[17:46:48.290]             setwd(...future.workdir)
[17:46:48.290]         {
[17:46:48.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.290]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.290]             }
[17:46:48.290]             base::options(...future.oldOptions)
[17:46:48.290]             if (.Platform$OS.type == "windows") {
[17:46:48.290]                 old_names <- names(...future.oldEnvVars)
[17:46:48.290]                 envs <- base::Sys.getenv()
[17:46:48.290]                 names <- names(envs)
[17:46:48.290]                 common <- intersect(names, old_names)
[17:46:48.290]                 added <- setdiff(names, old_names)
[17:46:48.290]                 removed <- setdiff(old_names, names)
[17:46:48.290]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.290]                   envs[common]]
[17:46:48.290]                 NAMES <- toupper(changed)
[17:46:48.290]                 args <- list()
[17:46:48.290]                 for (kk in seq_along(NAMES)) {
[17:46:48.290]                   name <- changed[[kk]]
[17:46:48.290]                   NAME <- NAMES[[kk]]
[17:46:48.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.290]                     next
[17:46:48.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.290]                 }
[17:46:48.290]                 NAMES <- toupper(added)
[17:46:48.290]                 for (kk in seq_along(NAMES)) {
[17:46:48.290]                   name <- added[[kk]]
[17:46:48.290]                   NAME <- NAMES[[kk]]
[17:46:48.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.290]                     next
[17:46:48.290]                   args[[name]] <- ""
[17:46:48.290]                 }
[17:46:48.290]                 NAMES <- toupper(removed)
[17:46:48.290]                 for (kk in seq_along(NAMES)) {
[17:46:48.290]                   name <- removed[[kk]]
[17:46:48.290]                   NAME <- NAMES[[kk]]
[17:46:48.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.290]                     next
[17:46:48.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.290]                 }
[17:46:48.290]                 if (length(args) > 0) 
[17:46:48.290]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.290]             }
[17:46:48.290]             else {
[17:46:48.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.290]             }
[17:46:48.290]             {
[17:46:48.290]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.290]                   0L) {
[17:46:48.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.290]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.290]                   base::options(opts)
[17:46:48.290]                 }
[17:46:48.290]                 {
[17:46:48.290]                   {
[17:46:48.290]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.290]                     NULL
[17:46:48.290]                   }
[17:46:48.290]                   options(future.plan = NULL)
[17:46:48.290]                   if (is.na(NA_character_)) 
[17:46:48.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.290]                     .init = FALSE)
[17:46:48.290]                 }
[17:46:48.290]             }
[17:46:48.290]         }
[17:46:48.290]     })
[17:46:48.290]     if (TRUE) {
[17:46:48.290]         base::sink(type = "output", split = FALSE)
[17:46:48.290]         if (TRUE) {
[17:46:48.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.290]         }
[17:46:48.290]         else {
[17:46:48.290]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.290]         }
[17:46:48.290]         base::close(...future.stdout)
[17:46:48.290]         ...future.stdout <- NULL
[17:46:48.290]     }
[17:46:48.290]     ...future.result$conditions <- ...future.conditions
[17:46:48.290]     ...future.result$finished <- base::Sys.time()
[17:46:48.290]     ...future.result
[17:46:48.290] }
[17:46:48.293] requestCore(): workers = 2
[17:46:48.295] MulticoreFuture started
[17:46:48.296] - Launch lazy future ... done
[17:46:48.296] run() for ‘MulticoreFuture’ ... done
[17:46:48.296] getGlobalsAndPackages() ...
[17:46:48.296] plan(): Setting new future strategy stack:
[17:46:48.297] Searching for globals...
[17:46:48.297] 
[17:46:48.297] List of future strategies:
[17:46:48.297] 1. sequential:
[17:46:48.297]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.297]    - tweaked: FALSE
[17:46:48.297]    - call: NULL
[17:46:48.298] Searching for globals ... DONE
[17:46:48.298] plan(): nbrOfWorkers() = 1
[17:46:48.298] - globals: [0] <none>
[17:46:48.298] getGlobalsAndPackages() ... DONE
[17:46:48.299] run() for ‘Future’ ...
[17:46:48.299] - state: ‘created’
[17:46:48.299] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.300] plan(): Setting new future strategy stack:
[17:46:48.300] List of future strategies:
[17:46:48.300] 1. multicore:
[17:46:48.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.300]    - tweaked: FALSE
[17:46:48.300]    - call: plan(strategy)
[17:46:48.305] plan(): nbrOfWorkers() = 2
[17:46:48.305] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.306]   - Field: ‘label’
[17:46:48.306]   - Field: ‘local’
[17:46:48.306]   - Field: ‘owner’
[17:46:48.306]   - Field: ‘envir’
[17:46:48.306]   - Field: ‘workers’
[17:46:48.306]   - Field: ‘packages’
[17:46:48.307]   - Field: ‘gc’
[17:46:48.307]   - Field: ‘job’
[17:46:48.307]   - Field: ‘conditions’
[17:46:48.307]   - Field: ‘expr’
[17:46:48.307]   - Field: ‘uuid’
[17:46:48.307]   - Field: ‘seed’
[17:46:48.308]   - Field: ‘version’
[17:46:48.308]   - Field: ‘result’
[17:46:48.308]   - Field: ‘asynchronous’
[17:46:48.308]   - Field: ‘calls’
[17:46:48.308]   - Field: ‘globals’
[17:46:48.308]   - Field: ‘stdout’
[17:46:48.308]   - Field: ‘earlySignal’
[17:46:48.309]   - Field: ‘lazy’
[17:46:48.309]   - Field: ‘state’
[17:46:48.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.309] - Launch lazy future ...
[17:46:48.309] Packages needed by the future expression (n = 0): <none>
[17:46:48.310] Packages needed by future strategies (n = 0): <none>
[17:46:48.310] {
[17:46:48.310]     {
[17:46:48.310]         {
[17:46:48.310]             ...future.startTime <- base::Sys.time()
[17:46:48.310]             {
[17:46:48.310]                 {
[17:46:48.310]                   {
[17:46:48.310]                     {
[17:46:48.310]                       base::local({
[17:46:48.310]                         has_future <- base::requireNamespace("future", 
[17:46:48.310]                           quietly = TRUE)
[17:46:48.310]                         if (has_future) {
[17:46:48.310]                           ns <- base::getNamespace("future")
[17:46:48.310]                           version <- ns[[".package"]][["version"]]
[17:46:48.310]                           if (is.null(version)) 
[17:46:48.310]                             version <- utils::packageVersion("future")
[17:46:48.310]                         }
[17:46:48.310]                         else {
[17:46:48.310]                           version <- NULL
[17:46:48.310]                         }
[17:46:48.310]                         if (!has_future || version < "1.8.0") {
[17:46:48.310]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.310]                             "", base::R.version$version.string), 
[17:46:48.310]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.310]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.310]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.310]                               "release", "version")], collapse = " "), 
[17:46:48.310]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.310]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.310]                             info)
[17:46:48.310]                           info <- base::paste(info, collapse = "; ")
[17:46:48.310]                           if (!has_future) {
[17:46:48.310]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.310]                               info)
[17:46:48.310]                           }
[17:46:48.310]                           else {
[17:46:48.310]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.310]                               info, version)
[17:46:48.310]                           }
[17:46:48.310]                           base::stop(msg)
[17:46:48.310]                         }
[17:46:48.310]                       })
[17:46:48.310]                     }
[17:46:48.310]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.310]                     base::options(mc.cores = 1L)
[17:46:48.310]                   }
[17:46:48.310]                   ...future.strategy.old <- future::plan("list")
[17:46:48.310]                   options(future.plan = NULL)
[17:46:48.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.310]                 }
[17:46:48.310]                 ...future.workdir <- getwd()
[17:46:48.310]             }
[17:46:48.310]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.310]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.310]         }
[17:46:48.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.310]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.310]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.310]             base::names(...future.oldOptions))
[17:46:48.310]     }
[17:46:48.310]     if (FALSE) {
[17:46:48.310]     }
[17:46:48.310]     else {
[17:46:48.310]         if (TRUE) {
[17:46:48.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.310]                 open = "w")
[17:46:48.310]         }
[17:46:48.310]         else {
[17:46:48.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.310]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.310]         }
[17:46:48.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.310]             base::sink(type = "output", split = FALSE)
[17:46:48.310]             base::close(...future.stdout)
[17:46:48.310]         }, add = TRUE)
[17:46:48.310]     }
[17:46:48.310]     ...future.frame <- base::sys.nframe()
[17:46:48.310]     ...future.conditions <- base::list()
[17:46:48.310]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.310]     if (FALSE) {
[17:46:48.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.310]     }
[17:46:48.310]     ...future.result <- base::tryCatch({
[17:46:48.310]         base::withCallingHandlers({
[17:46:48.310]             ...future.value <- base::withVisible(base::local({
[17:46:48.310]                 withCallingHandlers({
[17:46:48.310]                   NULL
[17:46:48.310]                 }, immediateCondition = function(cond) {
[17:46:48.310]                   save_rds <- function (object, pathname, ...) 
[17:46:48.310]                   {
[17:46:48.310]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.310]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.310]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.310]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.310]                         fi_tmp[["mtime"]])
[17:46:48.310]                     }
[17:46:48.310]                     tryCatch({
[17:46:48.310]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.310]                     }, error = function(ex) {
[17:46:48.310]                       msg <- conditionMessage(ex)
[17:46:48.310]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.310]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.310]                         fi_tmp[["mtime"]], msg)
[17:46:48.310]                       ex$message <- msg
[17:46:48.310]                       stop(ex)
[17:46:48.310]                     })
[17:46:48.310]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.310]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.310]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.310]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.310]                       fi <- file.info(pathname)
[17:46:48.310]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.310]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.310]                         fi[["size"]], fi[["mtime"]])
[17:46:48.310]                       stop(msg)
[17:46:48.310]                     }
[17:46:48.310]                     invisible(pathname)
[17:46:48.310]                   }
[17:46:48.310]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.310]                     rootPath = tempdir()) 
[17:46:48.310]                   {
[17:46:48.310]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.310]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.310]                       tmpdir = path, fileext = ".rds")
[17:46:48.310]                     save_rds(obj, file)
[17:46:48.310]                   }
[17:46:48.310]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.310]                   {
[17:46:48.310]                     inherits <- base::inherits
[17:46:48.310]                     invokeRestart <- base::invokeRestart
[17:46:48.310]                     is.null <- base::is.null
[17:46:48.310]                     muffled <- FALSE
[17:46:48.310]                     if (inherits(cond, "message")) {
[17:46:48.310]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.310]                       if (muffled) 
[17:46:48.310]                         invokeRestart("muffleMessage")
[17:46:48.310]                     }
[17:46:48.310]                     else if (inherits(cond, "warning")) {
[17:46:48.310]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.310]                       if (muffled) 
[17:46:48.310]                         invokeRestart("muffleWarning")
[17:46:48.310]                     }
[17:46:48.310]                     else if (inherits(cond, "condition")) {
[17:46:48.310]                       if (!is.null(pattern)) {
[17:46:48.310]                         computeRestarts <- base::computeRestarts
[17:46:48.310]                         grepl <- base::grepl
[17:46:48.310]                         restarts <- computeRestarts(cond)
[17:46:48.310]                         for (restart in restarts) {
[17:46:48.310]                           name <- restart$name
[17:46:48.310]                           if (is.null(name)) 
[17:46:48.310]                             next
[17:46:48.310]                           if (!grepl(pattern, name)) 
[17:46:48.310]                             next
[17:46:48.310]                           invokeRestart(restart)
[17:46:48.310]                           muffled <- TRUE
[17:46:48.310]                           break
[17:46:48.310]                         }
[17:46:48.310]                       }
[17:46:48.310]                     }
[17:46:48.310]                     invisible(muffled)
[17:46:48.310]                   }
[17:46:48.310]                   muffleCondition(cond)
[17:46:48.310]                 })
[17:46:48.310]             }))
[17:46:48.310]             future::FutureResult(value = ...future.value$value, 
[17:46:48.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.310]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.310]                     ...future.globalenv.names))
[17:46:48.310]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.310]         }, condition = base::local({
[17:46:48.310]             c <- base::c
[17:46:48.310]             inherits <- base::inherits
[17:46:48.310]             invokeRestart <- base::invokeRestart
[17:46:48.310]             length <- base::length
[17:46:48.310]             list <- base::list
[17:46:48.310]             seq.int <- base::seq.int
[17:46:48.310]             signalCondition <- base::signalCondition
[17:46:48.310]             sys.calls <- base::sys.calls
[17:46:48.310]             `[[` <- base::`[[`
[17:46:48.310]             `+` <- base::`+`
[17:46:48.310]             `<<-` <- base::`<<-`
[17:46:48.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.310]                   3L)]
[17:46:48.310]             }
[17:46:48.310]             function(cond) {
[17:46:48.310]                 is_error <- inherits(cond, "error")
[17:46:48.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.310]                   NULL)
[17:46:48.310]                 if (is_error) {
[17:46:48.310]                   sessionInformation <- function() {
[17:46:48.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.310]                       search = base::search(), system = base::Sys.info())
[17:46:48.310]                   }
[17:46:48.310]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.310]                     cond$call), session = sessionInformation(), 
[17:46:48.310]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.310]                   signalCondition(cond)
[17:46:48.310]                 }
[17:46:48.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.310]                 "immediateCondition"))) {
[17:46:48.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.310]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.310]                   if (TRUE && !signal) {
[17:46:48.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.310]                     {
[17:46:48.310]                       inherits <- base::inherits
[17:46:48.310]                       invokeRestart <- base::invokeRestart
[17:46:48.310]                       is.null <- base::is.null
[17:46:48.310]                       muffled <- FALSE
[17:46:48.310]                       if (inherits(cond, "message")) {
[17:46:48.310]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.310]                         if (muffled) 
[17:46:48.310]                           invokeRestart("muffleMessage")
[17:46:48.310]                       }
[17:46:48.310]                       else if (inherits(cond, "warning")) {
[17:46:48.310]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.310]                         if (muffled) 
[17:46:48.310]                           invokeRestart("muffleWarning")
[17:46:48.310]                       }
[17:46:48.310]                       else if (inherits(cond, "condition")) {
[17:46:48.310]                         if (!is.null(pattern)) {
[17:46:48.310]                           computeRestarts <- base::computeRestarts
[17:46:48.310]                           grepl <- base::grepl
[17:46:48.310]                           restarts <- computeRestarts(cond)
[17:46:48.310]                           for (restart in restarts) {
[17:46:48.310]                             name <- restart$name
[17:46:48.310]                             if (is.null(name)) 
[17:46:48.310]                               next
[17:46:48.310]                             if (!grepl(pattern, name)) 
[17:46:48.310]                               next
[17:46:48.310]                             invokeRestart(restart)
[17:46:48.310]                             muffled <- TRUE
[17:46:48.310]                             break
[17:46:48.310]                           }
[17:46:48.310]                         }
[17:46:48.310]                       }
[17:46:48.310]                       invisible(muffled)
[17:46:48.310]                     }
[17:46:48.310]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.310]                   }
[17:46:48.310]                 }
[17:46:48.310]                 else {
[17:46:48.310]                   if (TRUE) {
[17:46:48.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.310]                     {
[17:46:48.310]                       inherits <- base::inherits
[17:46:48.310]                       invokeRestart <- base::invokeRestart
[17:46:48.310]                       is.null <- base::is.null
[17:46:48.310]                       muffled <- FALSE
[17:46:48.310]                       if (inherits(cond, "message")) {
[17:46:48.310]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.310]                         if (muffled) 
[17:46:48.310]                           invokeRestart("muffleMessage")
[17:46:48.310]                       }
[17:46:48.310]                       else if (inherits(cond, "warning")) {
[17:46:48.310]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.310]                         if (muffled) 
[17:46:48.310]                           invokeRestart("muffleWarning")
[17:46:48.310]                       }
[17:46:48.310]                       else if (inherits(cond, "condition")) {
[17:46:48.310]                         if (!is.null(pattern)) {
[17:46:48.310]                           computeRestarts <- base::computeRestarts
[17:46:48.310]                           grepl <- base::grepl
[17:46:48.310]                           restarts <- computeRestarts(cond)
[17:46:48.310]                           for (restart in restarts) {
[17:46:48.310]                             name <- restart$name
[17:46:48.310]                             if (is.null(name)) 
[17:46:48.310]                               next
[17:46:48.310]                             if (!grepl(pattern, name)) 
[17:46:48.310]                               next
[17:46:48.310]                             invokeRestart(restart)
[17:46:48.310]                             muffled <- TRUE
[17:46:48.310]                             break
[17:46:48.310]                           }
[17:46:48.310]                         }
[17:46:48.310]                       }
[17:46:48.310]                       invisible(muffled)
[17:46:48.310]                     }
[17:46:48.310]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.310]                   }
[17:46:48.310]                 }
[17:46:48.310]             }
[17:46:48.310]         }))
[17:46:48.310]     }, error = function(ex) {
[17:46:48.310]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.310]                 ...future.rng), started = ...future.startTime, 
[17:46:48.310]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.310]             version = "1.8"), class = "FutureResult")
[17:46:48.310]     }, finally = {
[17:46:48.310]         if (!identical(...future.workdir, getwd())) 
[17:46:48.310]             setwd(...future.workdir)
[17:46:48.310]         {
[17:46:48.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.310]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.310]             }
[17:46:48.310]             base::options(...future.oldOptions)
[17:46:48.310]             if (.Platform$OS.type == "windows") {
[17:46:48.310]                 old_names <- names(...future.oldEnvVars)
[17:46:48.310]                 envs <- base::Sys.getenv()
[17:46:48.310]                 names <- names(envs)
[17:46:48.310]                 common <- intersect(names, old_names)
[17:46:48.310]                 added <- setdiff(names, old_names)
[17:46:48.310]                 removed <- setdiff(old_names, names)
[17:46:48.310]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.310]                   envs[common]]
[17:46:48.310]                 NAMES <- toupper(changed)
[17:46:48.310]                 args <- list()
[17:46:48.310]                 for (kk in seq_along(NAMES)) {
[17:46:48.310]                   name <- changed[[kk]]
[17:46:48.310]                   NAME <- NAMES[[kk]]
[17:46:48.310]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.310]                     next
[17:46:48.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.310]                 }
[17:46:48.310]                 NAMES <- toupper(added)
[17:46:48.310]                 for (kk in seq_along(NAMES)) {
[17:46:48.310]                   name <- added[[kk]]
[17:46:48.310]                   NAME <- NAMES[[kk]]
[17:46:48.310]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.310]                     next
[17:46:48.310]                   args[[name]] <- ""
[17:46:48.310]                 }
[17:46:48.310]                 NAMES <- toupper(removed)
[17:46:48.310]                 for (kk in seq_along(NAMES)) {
[17:46:48.310]                   name <- removed[[kk]]
[17:46:48.310]                   NAME <- NAMES[[kk]]
[17:46:48.310]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.310]                     next
[17:46:48.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.310]                 }
[17:46:48.310]                 if (length(args) > 0) 
[17:46:48.310]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.310]             }
[17:46:48.310]             else {
[17:46:48.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.310]             }
[17:46:48.310]             {
[17:46:48.310]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.310]                   0L) {
[17:46:48.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.310]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.310]                   base::options(opts)
[17:46:48.310]                 }
[17:46:48.310]                 {
[17:46:48.310]                   {
[17:46:48.310]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.310]                     NULL
[17:46:48.310]                   }
[17:46:48.310]                   options(future.plan = NULL)
[17:46:48.310]                   if (is.na(NA_character_)) 
[17:46:48.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.310]                     .init = FALSE)
[17:46:48.310]                 }
[17:46:48.310]             }
[17:46:48.310]         }
[17:46:48.310]     })
[17:46:48.310]     if (TRUE) {
[17:46:48.310]         base::sink(type = "output", split = FALSE)
[17:46:48.310]         if (TRUE) {
[17:46:48.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.310]         }
[17:46:48.310]         else {
[17:46:48.310]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.310]         }
[17:46:48.310]         base::close(...future.stdout)
[17:46:48.310]         ...future.stdout <- NULL
[17:46:48.310]     }
[17:46:48.310]     ...future.result$conditions <- ...future.conditions
[17:46:48.310]     ...future.result$finished <- base::Sys.time()
[17:46:48.310]     ...future.result
[17:46:48.310] }
[17:46:48.314] requestCore(): workers = 2
[17:46:48.317] MulticoreFuture started
[17:46:48.317] - Launch lazy future ... done
[17:46:48.318] run() for ‘MulticoreFuture’ ... done
[17:46:48.318] plan(): Setting new future strategy stack:
[17:46:48.319] getGlobalsAndPackages() ...
[17:46:48.319] Searching for globals...
[17:46:48.319] List of future strategies:
[17:46:48.319] 1. sequential:
[17:46:48.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.319]    - tweaked: FALSE
[17:46:48.319]    - call: NULL
[17:46:48.320] plan(): nbrOfWorkers() = 1
[17:46:48.320] - globals found: [1] ‘{’
[17:46:48.320] Searching for globals ... DONE
[17:46:48.321] Resolving globals: FALSE
[17:46:48.321] 
[17:46:48.321] 
[17:46:48.321] getGlobalsAndPackages() ... DONE
[17:46:48.322] plan(): Setting new future strategy stack:
[17:46:48.322] run() for ‘Future’ ...
[17:46:48.322] - state: ‘created’
[17:46:48.322] List of future strategies:
[17:46:48.322] 1. multicore:
[17:46:48.322]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.322]    - tweaked: FALSE
[17:46:48.322]    - call: plan(strategy)
[17:46:48.322] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.327] plan(): nbrOfWorkers() = 2
[17:46:48.327] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.328]   - Field: ‘label’
[17:46:48.328]   - Field: ‘local’
[17:46:48.328]   - Field: ‘owner’
[17:46:48.328]   - Field: ‘envir’
[17:46:48.328]   - Field: ‘workers’
[17:46:48.329]   - Field: ‘packages’
[17:46:48.329]   - Field: ‘gc’
[17:46:48.329]   - Field: ‘job’
[17:46:48.329]   - Field: ‘conditions’
[17:46:48.329]   - Field: ‘expr’
[17:46:48.329]   - Field: ‘uuid’
[17:46:48.329]   - Field: ‘seed’
[17:46:48.330]   - Field: ‘version’
[17:46:48.330]   - Field: ‘result’
[17:46:48.330]   - Field: ‘asynchronous’
[17:46:48.330]   - Field: ‘calls’
[17:46:48.330]   - Field: ‘globals’
[17:46:48.330]   - Field: ‘stdout’
[17:46:48.330]   - Field: ‘earlySignal’
[17:46:48.331]   - Field: ‘lazy’
[17:46:48.331]   - Field: ‘state’
[17:46:48.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.331] - Launch lazy future ...
[17:46:48.331] Packages needed by the future expression (n = 0): <none>
[17:46:48.332] Packages needed by future strategies (n = 0): <none>
[17:46:48.332] {
[17:46:48.332]     {
[17:46:48.332]         {
[17:46:48.332]             ...future.startTime <- base::Sys.time()
[17:46:48.332]             {
[17:46:48.332]                 {
[17:46:48.332]                   {
[17:46:48.332]                     {
[17:46:48.332]                       base::local({
[17:46:48.332]                         has_future <- base::requireNamespace("future", 
[17:46:48.332]                           quietly = TRUE)
[17:46:48.332]                         if (has_future) {
[17:46:48.332]                           ns <- base::getNamespace("future")
[17:46:48.332]                           version <- ns[[".package"]][["version"]]
[17:46:48.332]                           if (is.null(version)) 
[17:46:48.332]                             version <- utils::packageVersion("future")
[17:46:48.332]                         }
[17:46:48.332]                         else {
[17:46:48.332]                           version <- NULL
[17:46:48.332]                         }
[17:46:48.332]                         if (!has_future || version < "1.8.0") {
[17:46:48.332]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.332]                             "", base::R.version$version.string), 
[17:46:48.332]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.332]                               "release", "version")], collapse = " "), 
[17:46:48.332]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.332]                             info)
[17:46:48.332]                           info <- base::paste(info, collapse = "; ")
[17:46:48.332]                           if (!has_future) {
[17:46:48.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.332]                               info)
[17:46:48.332]                           }
[17:46:48.332]                           else {
[17:46:48.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.332]                               info, version)
[17:46:48.332]                           }
[17:46:48.332]                           base::stop(msg)
[17:46:48.332]                         }
[17:46:48.332]                       })
[17:46:48.332]                     }
[17:46:48.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.332]                     base::options(mc.cores = 1L)
[17:46:48.332]                   }
[17:46:48.332]                   ...future.strategy.old <- future::plan("list")
[17:46:48.332]                   options(future.plan = NULL)
[17:46:48.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.332]                 }
[17:46:48.332]                 ...future.workdir <- getwd()
[17:46:48.332]             }
[17:46:48.332]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.332]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.332]         }
[17:46:48.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.332]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.332]             base::names(...future.oldOptions))
[17:46:48.332]     }
[17:46:48.332]     if (FALSE) {
[17:46:48.332]     }
[17:46:48.332]     else {
[17:46:48.332]         if (TRUE) {
[17:46:48.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.332]                 open = "w")
[17:46:48.332]         }
[17:46:48.332]         else {
[17:46:48.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.332]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.332]         }
[17:46:48.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.332]             base::sink(type = "output", split = FALSE)
[17:46:48.332]             base::close(...future.stdout)
[17:46:48.332]         }, add = TRUE)
[17:46:48.332]     }
[17:46:48.332]     ...future.frame <- base::sys.nframe()
[17:46:48.332]     ...future.conditions <- base::list()
[17:46:48.332]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.332]     if (FALSE) {
[17:46:48.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.332]     }
[17:46:48.332]     ...future.result <- base::tryCatch({
[17:46:48.332]         base::withCallingHandlers({
[17:46:48.332]             ...future.value <- base::withVisible(base::local({
[17:46:48.332]                 withCallingHandlers({
[17:46:48.332]                   {
[17:46:48.332]                     4
[17:46:48.332]                   }
[17:46:48.332]                 }, immediateCondition = function(cond) {
[17:46:48.332]                   save_rds <- function (object, pathname, ...) 
[17:46:48.332]                   {
[17:46:48.332]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.332]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.332]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.332]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.332]                         fi_tmp[["mtime"]])
[17:46:48.332]                     }
[17:46:48.332]                     tryCatch({
[17:46:48.332]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.332]                     }, error = function(ex) {
[17:46:48.332]                       msg <- conditionMessage(ex)
[17:46:48.332]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.332]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.332]                         fi_tmp[["mtime"]], msg)
[17:46:48.332]                       ex$message <- msg
[17:46:48.332]                       stop(ex)
[17:46:48.332]                     })
[17:46:48.332]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.332]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.332]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.332]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.332]                       fi <- file.info(pathname)
[17:46:48.332]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.332]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.332]                         fi[["size"]], fi[["mtime"]])
[17:46:48.332]                       stop(msg)
[17:46:48.332]                     }
[17:46:48.332]                     invisible(pathname)
[17:46:48.332]                   }
[17:46:48.332]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.332]                     rootPath = tempdir()) 
[17:46:48.332]                   {
[17:46:48.332]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.332]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.332]                       tmpdir = path, fileext = ".rds")
[17:46:48.332]                     save_rds(obj, file)
[17:46:48.332]                   }
[17:46:48.332]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.332]                   {
[17:46:48.332]                     inherits <- base::inherits
[17:46:48.332]                     invokeRestart <- base::invokeRestart
[17:46:48.332]                     is.null <- base::is.null
[17:46:48.332]                     muffled <- FALSE
[17:46:48.332]                     if (inherits(cond, "message")) {
[17:46:48.332]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.332]                       if (muffled) 
[17:46:48.332]                         invokeRestart("muffleMessage")
[17:46:48.332]                     }
[17:46:48.332]                     else if (inherits(cond, "warning")) {
[17:46:48.332]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.332]                       if (muffled) 
[17:46:48.332]                         invokeRestart("muffleWarning")
[17:46:48.332]                     }
[17:46:48.332]                     else if (inherits(cond, "condition")) {
[17:46:48.332]                       if (!is.null(pattern)) {
[17:46:48.332]                         computeRestarts <- base::computeRestarts
[17:46:48.332]                         grepl <- base::grepl
[17:46:48.332]                         restarts <- computeRestarts(cond)
[17:46:48.332]                         for (restart in restarts) {
[17:46:48.332]                           name <- restart$name
[17:46:48.332]                           if (is.null(name)) 
[17:46:48.332]                             next
[17:46:48.332]                           if (!grepl(pattern, name)) 
[17:46:48.332]                             next
[17:46:48.332]                           invokeRestart(restart)
[17:46:48.332]                           muffled <- TRUE
[17:46:48.332]                           break
[17:46:48.332]                         }
[17:46:48.332]                       }
[17:46:48.332]                     }
[17:46:48.332]                     invisible(muffled)
[17:46:48.332]                   }
[17:46:48.332]                   muffleCondition(cond)
[17:46:48.332]                 })
[17:46:48.332]             }))
[17:46:48.332]             future::FutureResult(value = ...future.value$value, 
[17:46:48.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.332]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.332]                     ...future.globalenv.names))
[17:46:48.332]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.332]         }, condition = base::local({
[17:46:48.332]             c <- base::c
[17:46:48.332]             inherits <- base::inherits
[17:46:48.332]             invokeRestart <- base::invokeRestart
[17:46:48.332]             length <- base::length
[17:46:48.332]             list <- base::list
[17:46:48.332]             seq.int <- base::seq.int
[17:46:48.332]             signalCondition <- base::signalCondition
[17:46:48.332]             sys.calls <- base::sys.calls
[17:46:48.332]             `[[` <- base::`[[`
[17:46:48.332]             `+` <- base::`+`
[17:46:48.332]             `<<-` <- base::`<<-`
[17:46:48.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.332]                   3L)]
[17:46:48.332]             }
[17:46:48.332]             function(cond) {
[17:46:48.332]                 is_error <- inherits(cond, "error")
[17:46:48.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.332]                   NULL)
[17:46:48.332]                 if (is_error) {
[17:46:48.332]                   sessionInformation <- function() {
[17:46:48.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.332]                       search = base::search(), system = base::Sys.info())
[17:46:48.332]                   }
[17:46:48.332]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.332]                     cond$call), session = sessionInformation(), 
[17:46:48.332]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.332]                   signalCondition(cond)
[17:46:48.332]                 }
[17:46:48.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.332]                 "immediateCondition"))) {
[17:46:48.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.332]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.332]                   if (TRUE && !signal) {
[17:46:48.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.332]                     {
[17:46:48.332]                       inherits <- base::inherits
[17:46:48.332]                       invokeRestart <- base::invokeRestart
[17:46:48.332]                       is.null <- base::is.null
[17:46:48.332]                       muffled <- FALSE
[17:46:48.332]                       if (inherits(cond, "message")) {
[17:46:48.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.332]                         if (muffled) 
[17:46:48.332]                           invokeRestart("muffleMessage")
[17:46:48.332]                       }
[17:46:48.332]                       else if (inherits(cond, "warning")) {
[17:46:48.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.332]                         if (muffled) 
[17:46:48.332]                           invokeRestart("muffleWarning")
[17:46:48.332]                       }
[17:46:48.332]                       else if (inherits(cond, "condition")) {
[17:46:48.332]                         if (!is.null(pattern)) {
[17:46:48.332]                           computeRestarts <- base::computeRestarts
[17:46:48.332]                           grepl <- base::grepl
[17:46:48.332]                           restarts <- computeRestarts(cond)
[17:46:48.332]                           for (restart in restarts) {
[17:46:48.332]                             name <- restart$name
[17:46:48.332]                             if (is.null(name)) 
[17:46:48.332]                               next
[17:46:48.332]                             if (!grepl(pattern, name)) 
[17:46:48.332]                               next
[17:46:48.332]                             invokeRestart(restart)
[17:46:48.332]                             muffled <- TRUE
[17:46:48.332]                             break
[17:46:48.332]                           }
[17:46:48.332]                         }
[17:46:48.332]                       }
[17:46:48.332]                       invisible(muffled)
[17:46:48.332]                     }
[17:46:48.332]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.332]                   }
[17:46:48.332]                 }
[17:46:48.332]                 else {
[17:46:48.332]                   if (TRUE) {
[17:46:48.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.332]                     {
[17:46:48.332]                       inherits <- base::inherits
[17:46:48.332]                       invokeRestart <- base::invokeRestart
[17:46:48.332]                       is.null <- base::is.null
[17:46:48.332]                       muffled <- FALSE
[17:46:48.332]                       if (inherits(cond, "message")) {
[17:46:48.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.332]                         if (muffled) 
[17:46:48.332]                           invokeRestart("muffleMessage")
[17:46:48.332]                       }
[17:46:48.332]                       else if (inherits(cond, "warning")) {
[17:46:48.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.332]                         if (muffled) 
[17:46:48.332]                           invokeRestart("muffleWarning")
[17:46:48.332]                       }
[17:46:48.332]                       else if (inherits(cond, "condition")) {
[17:46:48.332]                         if (!is.null(pattern)) {
[17:46:48.332]                           computeRestarts <- base::computeRestarts
[17:46:48.332]                           grepl <- base::grepl
[17:46:48.332]                           restarts <- computeRestarts(cond)
[17:46:48.332]                           for (restart in restarts) {
[17:46:48.332]                             name <- restart$name
[17:46:48.332]                             if (is.null(name)) 
[17:46:48.332]                               next
[17:46:48.332]                             if (!grepl(pattern, name)) 
[17:46:48.332]                               next
[17:46:48.332]                             invokeRestart(restart)
[17:46:48.332]                             muffled <- TRUE
[17:46:48.332]                             break
[17:46:48.332]                           }
[17:46:48.332]                         }
[17:46:48.332]                       }
[17:46:48.332]                       invisible(muffled)
[17:46:48.332]                     }
[17:46:48.332]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.332]                   }
[17:46:48.332]                 }
[17:46:48.332]             }
[17:46:48.332]         }))
[17:46:48.332]     }, error = function(ex) {
[17:46:48.332]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.332]                 ...future.rng), started = ...future.startTime, 
[17:46:48.332]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.332]             version = "1.8"), class = "FutureResult")
[17:46:48.332]     }, finally = {
[17:46:48.332]         if (!identical(...future.workdir, getwd())) 
[17:46:48.332]             setwd(...future.workdir)
[17:46:48.332]         {
[17:46:48.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.332]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.332]             }
[17:46:48.332]             base::options(...future.oldOptions)
[17:46:48.332]             if (.Platform$OS.type == "windows") {
[17:46:48.332]                 old_names <- names(...future.oldEnvVars)
[17:46:48.332]                 envs <- base::Sys.getenv()
[17:46:48.332]                 names <- names(envs)
[17:46:48.332]                 common <- intersect(names, old_names)
[17:46:48.332]                 added <- setdiff(names, old_names)
[17:46:48.332]                 removed <- setdiff(old_names, names)
[17:46:48.332]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.332]                   envs[common]]
[17:46:48.332]                 NAMES <- toupper(changed)
[17:46:48.332]                 args <- list()
[17:46:48.332]                 for (kk in seq_along(NAMES)) {
[17:46:48.332]                   name <- changed[[kk]]
[17:46:48.332]                   NAME <- NAMES[[kk]]
[17:46:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.332]                     next
[17:46:48.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.332]                 }
[17:46:48.332]                 NAMES <- toupper(added)
[17:46:48.332]                 for (kk in seq_along(NAMES)) {
[17:46:48.332]                   name <- added[[kk]]
[17:46:48.332]                   NAME <- NAMES[[kk]]
[17:46:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.332]                     next
[17:46:48.332]                   args[[name]] <- ""
[17:46:48.332]                 }
[17:46:48.332]                 NAMES <- toupper(removed)
[17:46:48.332]                 for (kk in seq_along(NAMES)) {
[17:46:48.332]                   name <- removed[[kk]]
[17:46:48.332]                   NAME <- NAMES[[kk]]
[17:46:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.332]                     next
[17:46:48.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.332]                 }
[17:46:48.332]                 if (length(args) > 0) 
[17:46:48.332]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.332]             }
[17:46:48.332]             else {
[17:46:48.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.332]             }
[17:46:48.332]             {
[17:46:48.332]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.332]                   0L) {
[17:46:48.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.332]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.332]                   base::options(opts)
[17:46:48.332]                 }
[17:46:48.332]                 {
[17:46:48.332]                   {
[17:46:48.332]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.332]                     NULL
[17:46:48.332]                   }
[17:46:48.332]                   options(future.plan = NULL)
[17:46:48.332]                   if (is.na(NA_character_)) 
[17:46:48.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.332]                     .init = FALSE)
[17:46:48.332]                 }
[17:46:48.332]             }
[17:46:48.332]         }
[17:46:48.332]     })
[17:46:48.332]     if (TRUE) {
[17:46:48.332]         base::sink(type = "output", split = FALSE)
[17:46:48.332]         if (TRUE) {
[17:46:48.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.332]         }
[17:46:48.332]         else {
[17:46:48.332]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.332]         }
[17:46:48.332]         base::close(...future.stdout)
[17:46:48.332]         ...future.stdout <- NULL
[17:46:48.332]     }
[17:46:48.332]     ...future.result$conditions <- ...future.conditions
[17:46:48.332]     ...future.result$finished <- base::Sys.time()
[17:46:48.332]     ...future.result
[17:46:48.332] }
[17:46:48.336] requestCore(): workers = 2
[17:46:48.337] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:48.347] result() for MulticoreFuture ...
[17:46:48.348] result() for MulticoreFuture ...
[17:46:48.349] result() for MulticoreFuture ... done
[17:46:48.349] result() for MulticoreFuture ... done
[17:46:48.349] result() for MulticoreFuture ...
[17:46:48.349] result() for MulticoreFuture ... done
[17:46:48.353] MulticoreFuture started
[17:46:48.353] - Launch lazy future ... done
[17:46:48.353] run() for ‘MulticoreFuture’ ... done
[17:46:48.353] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x561789b05938> 
[17:46:48.354] List of future strategies:
[17:46:48.354] 1. sequential:
[17:46:48.354]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.354]    - tweaked: FALSE
[17:46:48.354]    - call: NULL
[17:46:48.355] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5617874f4310> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=[17:46:48.357] plan(): Setting new future strategy stack:
List of 2
  ..$ :[17:46:48.357] List of future strategies:
[17:46:48.357] 1. multicore:
[17:46:48.357]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.357]    - tweaked: FALSE
[17:46:48.357]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:46:48.362] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:48.366] resolve() on list environment ...
[17:46:48.367]  recursive: 0
[17:46:48.369]  length: 6
[17:46:48.369]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:48.369] signalConditionsASAP(numeric, pos=1) ...
[17:46:48.369] - nx: 6
[17:46:48.369] - relay: TRUE
[17:46:48.369] - stdout: TRUE
[17:46:48.370] - signal: TRUE
[17:46:48.370] - resignal: FALSE
[17:46:48.370] - force: TRUE
[17:46:48.370] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.370] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.370]  - until=2
[17:46:48.370]  - relaying element #2
[17:46:48.371] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.371] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.371] signalConditionsASAP(NULL, pos=1) ... done
[17:46:48.371]  length: 5 (resolved future 1)
[17:46:48.371] Future #2
[17:46:48.371] result() for MulticoreFuture ...
[17:46:48.372] result() for MulticoreFuture ... done
[17:46:48.372] result() for MulticoreFuture ...
[17:46:48.372] result() for MulticoreFuture ... done
[17:46:48.372] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:48.372] - nx: 6
[17:46:48.372] - relay: TRUE
[17:46:48.373] - stdout: TRUE
[17:46:48.373] - signal: TRUE
[17:46:48.373] - resignal: FALSE
[17:46:48.373] - force: TRUE
[17:46:48.373] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.373] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.373]  - until=2
[17:46:48.374]  - relaying element #2
[17:46:48.374] result() for MulticoreFuture ...
[17:46:48.374] result() for MulticoreFuture ... done
[17:46:48.374] result() for MulticoreFuture ...
[17:46:48.374] result() for MulticoreFuture ... done
[17:46:48.374] result() for MulticoreFuture ...
[17:46:48.374] result() for MulticoreFuture ... done
[17:46:48.375] result() for MulticoreFuture ...
[17:46:48.375] result() for MulticoreFuture ... done
[17:46:48.375] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.375] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.375] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:48.375]  length: 4 (resolved future 2)
[17:46:48.376] Future #3
[17:46:48.376] result() for MulticoreFuture ...
[17:46:48.377] result() for MulticoreFuture ...
[17:46:48.377] result() for MulticoreFuture ... done
[17:46:48.377] result() for MulticoreFuture ... done
[17:46:48.377] result() for MulticoreFuture ...
[17:46:48.377] result() for MulticoreFuture ... done
[17:46:48.377] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:48.377] - nx: 6
[17:46:48.378] - relay: TRUE
[17:46:48.378] - stdout: TRUE
[17:46:48.378] - signal: TRUE
[17:46:48.378] - resignal: FALSE
[17:46:48.378] - force: TRUE
[17:46:48.378] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.378] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.378]  - until=3
[17:46:48.379]  - relaying element #3
[17:46:48.379] result() for MulticoreFuture ...
[17:46:48.379] result() for MulticoreFuture ... done
[17:46:48.379] result() for MulticoreFuture ...
[17:46:48.379] result() for MulticoreFuture ... done
[17:46:48.379] result() for MulticoreFuture ...
[17:46:48.379] result() for MulticoreFuture ... done
[17:46:48.380] result() for MulticoreFuture ...
[17:46:48.380] result() for MulticoreFuture ... done
[17:46:48.380] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.380] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.380] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:48.380]  length: 3 (resolved future 3)
[17:46:48.381] Future #4
[17:46:48.381] result() for MulticoreFuture ...
[17:46:48.381] result() for MulticoreFuture ...
[17:46:48.381] result() for MulticoreFuture ... done
[17:46:48.382] result() for MulticoreFuture ... done
[17:46:48.382] result() for MulticoreFuture ...
[17:46:48.382] result() for MulticoreFuture ... done
[17:46:48.382] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:48.382] - nx: 6
[17:46:48.382] - relay: TRUE
[17:46:48.382] - stdout: TRUE
[17:46:48.383] - signal: TRUE
[17:46:48.383] - resignal: FALSE
[17:46:48.383] - force: TRUE
[17:46:48.383] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.383] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.383]  - until=4
[17:46:48.383]  - relaying element #4
[17:46:48.383] result() for MulticoreFuture ...
[17:46:48.384] result() for MulticoreFuture ... done
[17:46:48.384] result() for MulticoreFuture ...
[17:46:48.384] result() for MulticoreFuture ... done
[17:46:48.384] result() for MulticoreFuture ...
[17:46:48.384] result() for MulticoreFuture ... done
[17:46:48.384] result() for MulticoreFuture ...
[17:46:48.384] result() for MulticoreFuture ... done
[17:46:48.384] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.384] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.385] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:48.385]  length: 2 (resolved future 4)
[17:46:48.385] signalConditionsASAP(NULL, pos=5) ...
[17:46:48.385] - nx: 6
[17:46:48.385] - relay: TRUE
[17:46:48.385] - stdout: TRUE
[17:46:48.385] - signal: TRUE
[17:46:48.385] - resignal: FALSE
[17:46:48.385] - force: TRUE
[17:46:48.386] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.386] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.386]  - until=6
[17:46:48.386]  - relaying element #6
[17:46:48.386] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.386] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.386] signalConditionsASAP(NULL, pos=5) ... done
[17:46:48.386]  length: 1 (resolved future 5)
[17:46:48.386] signalConditionsASAP(numeric, pos=6) ...
[17:46:48.386] - nx: 6
[17:46:48.387] - relay: TRUE
[17:46:48.387] - stdout: TRUE
[17:46:48.387] - signal: TRUE
[17:46:48.387] - resignal: FALSE
[17:46:48.387] - force: TRUE
[17:46:48.387] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.387] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.387]  - until=6
[17:46:48.387] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.388] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.388] signalConditionsASAP(numeric, pos=6) ... done
[17:46:48.388]  length: 0 (resolved future 6)
[17:46:48.388] Relaying remaining futures
[17:46:48.388] signalConditionsASAP(NULL, pos=0) ...
[17:46:48.388] - nx: 6
[17:46:48.388] - relay: TRUE
[17:46:48.388] - stdout: TRUE
[17:46:48.388] - signal: TRUE
[17:46:48.388] - resignal: FALSE
[17:46:48.388] - force: TRUE
[17:46:48.389] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.389] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:48.389] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.389] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.389] signalConditionsASAP(NULL, pos=0) ... done
[17:46:48.389] resolve() on list environment ... DONE
[17:46:48.389] result() for MulticoreFuture ...
[17:46:48.389] result() for MulticoreFuture ... done
[17:46:48.390] result() for MulticoreFuture ...
[17:46:48.390] result() for MulticoreFuture ... done
[17:46:48.390] result() for MulticoreFuture ...
[17:46:48.390] result() for MulticoreFuture ... done
[17:46:48.390] result() for MulticoreFuture ...
[17:46:48.390] result() for MulticoreFuture ... done
[17:46:48.390] result() for MulticoreFuture ...
[17:46:48.390] result() for MulticoreFuture ... done
[17:46:48.391] result() for MulticoreFuture ...
[17:46:48.391] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5617862d81a0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:46:48.393] getGlobalsAndPackages() ...
[17:46:48.393] Searching for globals...
[17:46:48.393] 
[17:46:48.393] Searching for globals ... DONE
[17:46:48.394] - globals: [0] <none>
[17:46:48.394] getGlobalsAndPackages() ... DONE
[17:46:48.394] run() for ‘Future’ ...
[17:46:48.394] - state: ‘created’
[17:46:48.394] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.399] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.399]   - Field: ‘label’
[17:46:48.399]   - Field: ‘local’
[17:46:48.399]   - Field: ‘owner’
[17:46:48.399]   - Field: ‘envir’
[17:46:48.400]   - Field: ‘workers’
[17:46:48.400]   - Field: ‘packages’
[17:46:48.400]   - Field: ‘gc’
[17:46:48.400]   - Field: ‘job’
[17:46:48.400]   - Field: ‘conditions’
[17:46:48.400]   - Field: ‘expr’
[17:46:48.400]   - Field: ‘uuid’
[17:46:48.400]   - Field: ‘seed’
[17:46:48.400]   - Field: ‘version’
[17:46:48.401]   - Field: ‘result’
[17:46:48.401]   - Field: ‘asynchronous’
[17:46:48.401]   - Field: ‘calls’
[17:46:48.401]   - Field: ‘globals’
[17:46:48.401]   - Field: ‘stdout’
[17:46:48.401]   - Field: ‘earlySignal’
[17:46:48.401]   - Field: ‘lazy’
[17:46:48.401]   - Field: ‘state’
[17:46:48.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.401] - Launch lazy future ...
[17:46:48.402] Packages needed by the future expression (n = 0): <none>
[17:46:48.402] Packages needed by future strategies (n = 0): <none>
[17:46:48.402] {
[17:46:48.402]     {
[17:46:48.402]         {
[17:46:48.402]             ...future.startTime <- base::Sys.time()
[17:46:48.402]             {
[17:46:48.402]                 {
[17:46:48.402]                   {
[17:46:48.402]                     {
[17:46:48.402]                       base::local({
[17:46:48.402]                         has_future <- base::requireNamespace("future", 
[17:46:48.402]                           quietly = TRUE)
[17:46:48.402]                         if (has_future) {
[17:46:48.402]                           ns <- base::getNamespace("future")
[17:46:48.402]                           version <- ns[[".package"]][["version"]]
[17:46:48.402]                           if (is.null(version)) 
[17:46:48.402]                             version <- utils::packageVersion("future")
[17:46:48.402]                         }
[17:46:48.402]                         else {
[17:46:48.402]                           version <- NULL
[17:46:48.402]                         }
[17:46:48.402]                         if (!has_future || version < "1.8.0") {
[17:46:48.402]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.402]                             "", base::R.version$version.string), 
[17:46:48.402]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.402]                               "release", "version")], collapse = " "), 
[17:46:48.402]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.402]                             info)
[17:46:48.402]                           info <- base::paste(info, collapse = "; ")
[17:46:48.402]                           if (!has_future) {
[17:46:48.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.402]                               info)
[17:46:48.402]                           }
[17:46:48.402]                           else {
[17:46:48.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.402]                               info, version)
[17:46:48.402]                           }
[17:46:48.402]                           base::stop(msg)
[17:46:48.402]                         }
[17:46:48.402]                       })
[17:46:48.402]                     }
[17:46:48.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.402]                     base::options(mc.cores = 1L)
[17:46:48.402]                   }
[17:46:48.402]                   ...future.strategy.old <- future::plan("list")
[17:46:48.402]                   options(future.plan = NULL)
[17:46:48.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.402]                 }
[17:46:48.402]                 ...future.workdir <- getwd()
[17:46:48.402]             }
[17:46:48.402]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.402]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.402]         }
[17:46:48.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.402]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.402]             base::names(...future.oldOptions))
[17:46:48.402]     }
[17:46:48.402]     if (FALSE) {
[17:46:48.402]     }
[17:46:48.402]     else {
[17:46:48.402]         if (TRUE) {
[17:46:48.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.402]                 open = "w")
[17:46:48.402]         }
[17:46:48.402]         else {
[17:46:48.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.402]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.402]         }
[17:46:48.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.402]             base::sink(type = "output", split = FALSE)
[17:46:48.402]             base::close(...future.stdout)
[17:46:48.402]         }, add = TRUE)
[17:46:48.402]     }
[17:46:48.402]     ...future.frame <- base::sys.nframe()
[17:46:48.402]     ...future.conditions <- base::list()
[17:46:48.402]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.402]     if (FALSE) {
[17:46:48.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.402]     }
[17:46:48.402]     ...future.result <- base::tryCatch({
[17:46:48.402]         base::withCallingHandlers({
[17:46:48.402]             ...future.value <- base::withVisible(base::local({
[17:46:48.402]                 withCallingHandlers({
[17:46:48.402]                   2
[17:46:48.402]                 }, immediateCondition = function(cond) {
[17:46:48.402]                   save_rds <- function (object, pathname, ...) 
[17:46:48.402]                   {
[17:46:48.402]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.402]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.402]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.402]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.402]                         fi_tmp[["mtime"]])
[17:46:48.402]                     }
[17:46:48.402]                     tryCatch({
[17:46:48.402]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.402]                     }, error = function(ex) {
[17:46:48.402]                       msg <- conditionMessage(ex)
[17:46:48.402]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.402]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.402]                         fi_tmp[["mtime"]], msg)
[17:46:48.402]                       ex$message <- msg
[17:46:48.402]                       stop(ex)
[17:46:48.402]                     })
[17:46:48.402]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.402]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.402]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.402]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.402]                       fi <- file.info(pathname)
[17:46:48.402]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.402]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.402]                         fi[["size"]], fi[["mtime"]])
[17:46:48.402]                       stop(msg)
[17:46:48.402]                     }
[17:46:48.402]                     invisible(pathname)
[17:46:48.402]                   }
[17:46:48.402]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.402]                     rootPath = tempdir()) 
[17:46:48.402]                   {
[17:46:48.402]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.402]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.402]                       tmpdir = path, fileext = ".rds")
[17:46:48.402]                     save_rds(obj, file)
[17:46:48.402]                   }
[17:46:48.402]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.402]                   {
[17:46:48.402]                     inherits <- base::inherits
[17:46:48.402]                     invokeRestart <- base::invokeRestart
[17:46:48.402]                     is.null <- base::is.null
[17:46:48.402]                     muffled <- FALSE
[17:46:48.402]                     if (inherits(cond, "message")) {
[17:46:48.402]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.402]                       if (muffled) 
[17:46:48.402]                         invokeRestart("muffleMessage")
[17:46:48.402]                     }
[17:46:48.402]                     else if (inherits(cond, "warning")) {
[17:46:48.402]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.402]                       if (muffled) 
[17:46:48.402]                         invokeRestart("muffleWarning")
[17:46:48.402]                     }
[17:46:48.402]                     else if (inherits(cond, "condition")) {
[17:46:48.402]                       if (!is.null(pattern)) {
[17:46:48.402]                         computeRestarts <- base::computeRestarts
[17:46:48.402]                         grepl <- base::grepl
[17:46:48.402]                         restarts <- computeRestarts(cond)
[17:46:48.402]                         for (restart in restarts) {
[17:46:48.402]                           name <- restart$name
[17:46:48.402]                           if (is.null(name)) 
[17:46:48.402]                             next
[17:46:48.402]                           if (!grepl(pattern, name)) 
[17:46:48.402]                             next
[17:46:48.402]                           invokeRestart(restart)
[17:46:48.402]                           muffled <- TRUE
[17:46:48.402]                           break
[17:46:48.402]                         }
[17:46:48.402]                       }
[17:46:48.402]                     }
[17:46:48.402]                     invisible(muffled)
[17:46:48.402]                   }
[17:46:48.402]                   muffleCondition(cond)
[17:46:48.402]                 })
[17:46:48.402]             }))
[17:46:48.402]             future::FutureResult(value = ...future.value$value, 
[17:46:48.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.402]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.402]                     ...future.globalenv.names))
[17:46:48.402]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.402]         }, condition = base::local({
[17:46:48.402]             c <- base::c
[17:46:48.402]             inherits <- base::inherits
[17:46:48.402]             invokeRestart <- base::invokeRestart
[17:46:48.402]             length <- base::length
[17:46:48.402]             list <- base::list
[17:46:48.402]             seq.int <- base::seq.int
[17:46:48.402]             signalCondition <- base::signalCondition
[17:46:48.402]             sys.calls <- base::sys.calls
[17:46:48.402]             `[[` <- base::`[[`
[17:46:48.402]             `+` <- base::`+`
[17:46:48.402]             `<<-` <- base::`<<-`
[17:46:48.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.402]                   3L)]
[17:46:48.402]             }
[17:46:48.402]             function(cond) {
[17:46:48.402]                 is_error <- inherits(cond, "error")
[17:46:48.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.402]                   NULL)
[17:46:48.402]                 if (is_error) {
[17:46:48.402]                   sessionInformation <- function() {
[17:46:48.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.402]                       search = base::search(), system = base::Sys.info())
[17:46:48.402]                   }
[17:46:48.402]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.402]                     cond$call), session = sessionInformation(), 
[17:46:48.402]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.402]                   signalCondition(cond)
[17:46:48.402]                 }
[17:46:48.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.402]                 "immediateCondition"))) {
[17:46:48.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.402]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.402]                   if (TRUE && !signal) {
[17:46:48.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.402]                     {
[17:46:48.402]                       inherits <- base::inherits
[17:46:48.402]                       invokeRestart <- base::invokeRestart
[17:46:48.402]                       is.null <- base::is.null
[17:46:48.402]                       muffled <- FALSE
[17:46:48.402]                       if (inherits(cond, "message")) {
[17:46:48.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.402]                         if (muffled) 
[17:46:48.402]                           invokeRestart("muffleMessage")
[17:46:48.402]                       }
[17:46:48.402]                       else if (inherits(cond, "warning")) {
[17:46:48.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.402]                         if (muffled) 
[17:46:48.402]                           invokeRestart("muffleWarning")
[17:46:48.402]                       }
[17:46:48.402]                       else if (inherits(cond, "condition")) {
[17:46:48.402]                         if (!is.null(pattern)) {
[17:46:48.402]                           computeRestarts <- base::computeRestarts
[17:46:48.402]                           grepl <- base::grepl
[17:46:48.402]                           restarts <- computeRestarts(cond)
[17:46:48.402]                           for (restart in restarts) {
[17:46:48.402]                             name <- restart$name
[17:46:48.402]                             if (is.null(name)) 
[17:46:48.402]                               next
[17:46:48.402]                             if (!grepl(pattern, name)) 
[17:46:48.402]                               next
[17:46:48.402]                             invokeRestart(restart)
[17:46:48.402]                             muffled <- TRUE
[17:46:48.402]                             break
[17:46:48.402]                           }
[17:46:48.402]                         }
[17:46:48.402]                       }
[17:46:48.402]                       invisible(muffled)
[17:46:48.402]                     }
[17:46:48.402]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.402]                   }
[17:46:48.402]                 }
[17:46:48.402]                 else {
[17:46:48.402]                   if (TRUE) {
[17:46:48.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.402]                     {
[17:46:48.402]                       inherits <- base::inherits
[17:46:48.402]                       invokeRestart <- base::invokeRestart
[17:46:48.402]                       is.null <- base::is.null
[17:46:48.402]                       muffled <- FALSE
[17:46:48.402]                       if (inherits(cond, "message")) {
[17:46:48.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.402]                         if (muffled) 
[17:46:48.402]                           invokeRestart("muffleMessage")
[17:46:48.402]                       }
[17:46:48.402]                       else if (inherits(cond, "warning")) {
[17:46:48.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.402]                         if (muffled) 
[17:46:48.402]                           invokeRestart("muffleWarning")
[17:46:48.402]                       }
[17:46:48.402]                       else if (inherits(cond, "condition")) {
[17:46:48.402]                         if (!is.null(pattern)) {
[17:46:48.402]                           computeRestarts <- base::computeRestarts
[17:46:48.402]                           grepl <- base::grepl
[17:46:48.402]                           restarts <- computeRestarts(cond)
[17:46:48.402]                           for (restart in restarts) {
[17:46:48.402]                             name <- restart$name
[17:46:48.402]                             if (is.null(name)) 
[17:46:48.402]                               next
[17:46:48.402]                             if (!grepl(pattern, name)) 
[17:46:48.402]                               next
[17:46:48.402]                             invokeRestart(restart)
[17:46:48.402]                             muffled <- TRUE
[17:46:48.402]                             break
[17:46:48.402]                           }
[17:46:48.402]                         }
[17:46:48.402]                       }
[17:46:48.402]                       invisible(muffled)
[17:46:48.402]                     }
[17:46:48.402]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.402]                   }
[17:46:48.402]                 }
[17:46:48.402]             }
[17:46:48.402]         }))
[17:46:48.402]     }, error = function(ex) {
[17:46:48.402]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.402]                 ...future.rng), started = ...future.startTime, 
[17:46:48.402]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.402]             version = "1.8"), class = "FutureResult")
[17:46:48.402]     }, finally = {
[17:46:48.402]         if (!identical(...future.workdir, getwd())) 
[17:46:48.402]             setwd(...future.workdir)
[17:46:48.402]         {
[17:46:48.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.402]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.402]             }
[17:46:48.402]             base::options(...future.oldOptions)
[17:46:48.402]             if (.Platform$OS.type == "windows") {
[17:46:48.402]                 old_names <- names(...future.oldEnvVars)
[17:46:48.402]                 envs <- base::Sys.getenv()
[17:46:48.402]                 names <- names(envs)
[17:46:48.402]                 common <- intersect(names, old_names)
[17:46:48.402]                 added <- setdiff(names, old_names)
[17:46:48.402]                 removed <- setdiff(old_names, names)
[17:46:48.402]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.402]                   envs[common]]
[17:46:48.402]                 NAMES <- toupper(changed)
[17:46:48.402]                 args <- list()
[17:46:48.402]                 for (kk in seq_along(NAMES)) {
[17:46:48.402]                   name <- changed[[kk]]
[17:46:48.402]                   NAME <- NAMES[[kk]]
[17:46:48.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.402]                     next
[17:46:48.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.402]                 }
[17:46:48.402]                 NAMES <- toupper(added)
[17:46:48.402]                 for (kk in seq_along(NAMES)) {
[17:46:48.402]                   name <- added[[kk]]
[17:46:48.402]                   NAME <- NAMES[[kk]]
[17:46:48.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.402]                     next
[17:46:48.402]                   args[[name]] <- ""
[17:46:48.402]                 }
[17:46:48.402]                 NAMES <- toupper(removed)
[17:46:48.402]                 for (kk in seq_along(NAMES)) {
[17:46:48.402]                   name <- removed[[kk]]
[17:46:48.402]                   NAME <- NAMES[[kk]]
[17:46:48.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.402]                     next
[17:46:48.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.402]                 }
[17:46:48.402]                 if (length(args) > 0) 
[17:46:48.402]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.402]             }
[17:46:48.402]             else {
[17:46:48.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.402]             }
[17:46:48.402]             {
[17:46:48.402]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.402]                   0L) {
[17:46:48.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.402]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.402]                   base::options(opts)
[17:46:48.402]                 }
[17:46:48.402]                 {
[17:46:48.402]                   {
[17:46:48.402]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.402]                     NULL
[17:46:48.402]                   }
[17:46:48.402]                   options(future.plan = NULL)
[17:46:48.402]                   if (is.na(NA_character_)) 
[17:46:48.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.402]                     .init = FALSE)
[17:46:48.402]                 }
[17:46:48.402]             }
[17:46:48.402]         }
[17:46:48.402]     })
[17:46:48.402]     if (TRUE) {
[17:46:48.402]         base::sink(type = "output", split = FALSE)
[17:46:48.402]         if (TRUE) {
[17:46:48.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.402]         }
[17:46:48.402]         else {
[17:46:48.402]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.402]         }
[17:46:48.402]         base::close(...future.stdout)
[17:46:48.402]         ...future.stdout <- NULL
[17:46:48.402]     }
[17:46:48.402]     ...future.result$conditions <- ...future.conditions
[17:46:48.402]     ...future.result$finished <- base::Sys.time()
[17:46:48.402]     ...future.result
[17:46:48.402] }
[17:46:48.405] requestCore(): workers = 2
[17:46:48.408] MulticoreFuture started
[17:46:48.408] - Launch lazy future ... done
[17:46:48.408] run() for ‘MulticoreFuture’ ... done
[17:46:48.409] getGlobalsAndPackages() ...
[17:46:48.409] Searching for globals...
[17:46:48.409] plan(): Setting new future strategy stack:
[17:46:48.410] 
[17:46:48.410] Searching for globals ... DONE
[17:46:48.409] List of future strategies:
[17:46:48.409] 1. sequential:
[17:46:48.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.409]    - tweaked: FALSE
[17:46:48.409]    - call: NULL
[17:46:48.410] - globals: [0] <none>
[17:46:48.410] getGlobalsAndPackages() ... DONE
[17:46:48.410] plan(): nbrOfWorkers() = 1
[17:46:48.411] run() for ‘Future’ ...
[17:46:48.411] - state: ‘created’
[17:46:48.411] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.412] plan(): Setting new future strategy stack:
[17:46:48.412] List of future strategies:
[17:46:48.412] 1. multicore:
[17:46:48.412]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.412]    - tweaked: FALSE
[17:46:48.412]    - call: plan(strategy)
[17:46:48.417] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.417]   - Field: ‘label’
[17:46:48.417]   - Field: ‘local’
[17:46:48.417]   - Field: ‘owner’
[17:46:48.417] plan(): nbrOfWorkers() = 2
[17:46:48.417]   - Field: ‘envir’
[17:46:48.418]   - Field: ‘workers’
[17:46:48.418]   - Field: ‘packages’
[17:46:48.418]   - Field: ‘gc’
[17:46:48.418]   - Field: ‘job’
[17:46:48.418]   - Field: ‘conditions’
[17:46:48.418]   - Field: ‘expr’
[17:46:48.418]   - Field: ‘uuid’
[17:46:48.418]   - Field: ‘seed’
[17:46:48.419]   - Field: ‘version’
[17:46:48.419]   - Field: ‘result’
[17:46:48.419]   - Field: ‘asynchronous’
[17:46:48.419]   - Field: ‘calls’
[17:46:48.419]   - Field: ‘globals’
[17:46:48.419]   - Field: ‘stdout’
[17:46:48.419]   - Field: ‘earlySignal’
[17:46:48.420]   - Field: ‘lazy’
[17:46:48.420]   - Field: ‘state’
[17:46:48.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.420] - Launch lazy future ...
[17:46:48.421] Packages needed by the future expression (n = 0): <none>
[17:46:48.421] Packages needed by future strategies (n = 0): <none>
[17:46:48.421] {
[17:46:48.421]     {
[17:46:48.421]         {
[17:46:48.421]             ...future.startTime <- base::Sys.time()
[17:46:48.421]             {
[17:46:48.421]                 {
[17:46:48.421]                   {
[17:46:48.421]                     {
[17:46:48.421]                       base::local({
[17:46:48.421]                         has_future <- base::requireNamespace("future", 
[17:46:48.421]                           quietly = TRUE)
[17:46:48.421]                         if (has_future) {
[17:46:48.421]                           ns <- base::getNamespace("future")
[17:46:48.421]                           version <- ns[[".package"]][["version"]]
[17:46:48.421]                           if (is.null(version)) 
[17:46:48.421]                             version <- utils::packageVersion("future")
[17:46:48.421]                         }
[17:46:48.421]                         else {
[17:46:48.421]                           version <- NULL
[17:46:48.421]                         }
[17:46:48.421]                         if (!has_future || version < "1.8.0") {
[17:46:48.421]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.421]                             "", base::R.version$version.string), 
[17:46:48.421]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.421]                               "release", "version")], collapse = " "), 
[17:46:48.421]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.421]                             info)
[17:46:48.421]                           info <- base::paste(info, collapse = "; ")
[17:46:48.421]                           if (!has_future) {
[17:46:48.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.421]                               info)
[17:46:48.421]                           }
[17:46:48.421]                           else {
[17:46:48.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.421]                               info, version)
[17:46:48.421]                           }
[17:46:48.421]                           base::stop(msg)
[17:46:48.421]                         }
[17:46:48.421]                       })
[17:46:48.421]                     }
[17:46:48.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.421]                     base::options(mc.cores = 1L)
[17:46:48.421]                   }
[17:46:48.421]                   ...future.strategy.old <- future::plan("list")
[17:46:48.421]                   options(future.plan = NULL)
[17:46:48.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.421]                 }
[17:46:48.421]                 ...future.workdir <- getwd()
[17:46:48.421]             }
[17:46:48.421]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.421]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.421]         }
[17:46:48.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.421]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.421]             base::names(...future.oldOptions))
[17:46:48.421]     }
[17:46:48.421]     if (FALSE) {
[17:46:48.421]     }
[17:46:48.421]     else {
[17:46:48.421]         if (TRUE) {
[17:46:48.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.421]                 open = "w")
[17:46:48.421]         }
[17:46:48.421]         else {
[17:46:48.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.421]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.421]         }
[17:46:48.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.421]             base::sink(type = "output", split = FALSE)
[17:46:48.421]             base::close(...future.stdout)
[17:46:48.421]         }, add = TRUE)
[17:46:48.421]     }
[17:46:48.421]     ...future.frame <- base::sys.nframe()
[17:46:48.421]     ...future.conditions <- base::list()
[17:46:48.421]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.421]     if (FALSE) {
[17:46:48.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.421]     }
[17:46:48.421]     ...future.result <- base::tryCatch({
[17:46:48.421]         base::withCallingHandlers({
[17:46:48.421]             ...future.value <- base::withVisible(base::local({
[17:46:48.421]                 withCallingHandlers({
[17:46:48.421]                   NULL
[17:46:48.421]                 }, immediateCondition = function(cond) {
[17:46:48.421]                   save_rds <- function (object, pathname, ...) 
[17:46:48.421]                   {
[17:46:48.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.421]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.421]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.421]                         fi_tmp[["mtime"]])
[17:46:48.421]                     }
[17:46:48.421]                     tryCatch({
[17:46:48.421]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.421]                     }, error = function(ex) {
[17:46:48.421]                       msg <- conditionMessage(ex)
[17:46:48.421]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.421]                         fi_tmp[["mtime"]], msg)
[17:46:48.421]                       ex$message <- msg
[17:46:48.421]                       stop(ex)
[17:46:48.421]                     })
[17:46:48.421]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.421]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.421]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.421]                       fi <- file.info(pathname)
[17:46:48.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.421]                         fi[["size"]], fi[["mtime"]])
[17:46:48.421]                       stop(msg)
[17:46:48.421]                     }
[17:46:48.421]                     invisible(pathname)
[17:46:48.421]                   }
[17:46:48.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.421]                     rootPath = tempdir()) 
[17:46:48.421]                   {
[17:46:48.421]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.421]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.421]                       tmpdir = path, fileext = ".rds")
[17:46:48.421]                     save_rds(obj, file)
[17:46:48.421]                   }
[17:46:48.421]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.421]                   {
[17:46:48.421]                     inherits <- base::inherits
[17:46:48.421]                     invokeRestart <- base::invokeRestart
[17:46:48.421]                     is.null <- base::is.null
[17:46:48.421]                     muffled <- FALSE
[17:46:48.421]                     if (inherits(cond, "message")) {
[17:46:48.421]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.421]                       if (muffled) 
[17:46:48.421]                         invokeRestart("muffleMessage")
[17:46:48.421]                     }
[17:46:48.421]                     else if (inherits(cond, "warning")) {
[17:46:48.421]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.421]                       if (muffled) 
[17:46:48.421]                         invokeRestart("muffleWarning")
[17:46:48.421]                     }
[17:46:48.421]                     else if (inherits(cond, "condition")) {
[17:46:48.421]                       if (!is.null(pattern)) {
[17:46:48.421]                         computeRestarts <- base::computeRestarts
[17:46:48.421]                         grepl <- base::grepl
[17:46:48.421]                         restarts <- computeRestarts(cond)
[17:46:48.421]                         for (restart in restarts) {
[17:46:48.421]                           name <- restart$name
[17:46:48.421]                           if (is.null(name)) 
[17:46:48.421]                             next
[17:46:48.421]                           if (!grepl(pattern, name)) 
[17:46:48.421]                             next
[17:46:48.421]                           invokeRestart(restart)
[17:46:48.421]                           muffled <- TRUE
[17:46:48.421]                           break
[17:46:48.421]                         }
[17:46:48.421]                       }
[17:46:48.421]                     }
[17:46:48.421]                     invisible(muffled)
[17:46:48.421]                   }
[17:46:48.421]                   muffleCondition(cond)
[17:46:48.421]                 })
[17:46:48.421]             }))
[17:46:48.421]             future::FutureResult(value = ...future.value$value, 
[17:46:48.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.421]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.421]                     ...future.globalenv.names))
[17:46:48.421]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.421]         }, condition = base::local({
[17:46:48.421]             c <- base::c
[17:46:48.421]             inherits <- base::inherits
[17:46:48.421]             invokeRestart <- base::invokeRestart
[17:46:48.421]             length <- base::length
[17:46:48.421]             list <- base::list
[17:46:48.421]             seq.int <- base::seq.int
[17:46:48.421]             signalCondition <- base::signalCondition
[17:46:48.421]             sys.calls <- base::sys.calls
[17:46:48.421]             `[[` <- base::`[[`
[17:46:48.421]             `+` <- base::`+`
[17:46:48.421]             `<<-` <- base::`<<-`
[17:46:48.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.421]                   3L)]
[17:46:48.421]             }
[17:46:48.421]             function(cond) {
[17:46:48.421]                 is_error <- inherits(cond, "error")
[17:46:48.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.421]                   NULL)
[17:46:48.421]                 if (is_error) {
[17:46:48.421]                   sessionInformation <- function() {
[17:46:48.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.421]                       search = base::search(), system = base::Sys.info())
[17:46:48.421]                   }
[17:46:48.421]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.421]                     cond$call), session = sessionInformation(), 
[17:46:48.421]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.421]                   signalCondition(cond)
[17:46:48.421]                 }
[17:46:48.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.421]                 "immediateCondition"))) {
[17:46:48.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.421]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.421]                   if (TRUE && !signal) {
[17:46:48.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.421]                     {
[17:46:48.421]                       inherits <- base::inherits
[17:46:48.421]                       invokeRestart <- base::invokeRestart
[17:46:48.421]                       is.null <- base::is.null
[17:46:48.421]                       muffled <- FALSE
[17:46:48.421]                       if (inherits(cond, "message")) {
[17:46:48.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.421]                         if (muffled) 
[17:46:48.421]                           invokeRestart("muffleMessage")
[17:46:48.421]                       }
[17:46:48.421]                       else if (inherits(cond, "warning")) {
[17:46:48.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.421]                         if (muffled) 
[17:46:48.421]                           invokeRestart("muffleWarning")
[17:46:48.421]                       }
[17:46:48.421]                       else if (inherits(cond, "condition")) {
[17:46:48.421]                         if (!is.null(pattern)) {
[17:46:48.421]                           computeRestarts <- base::computeRestarts
[17:46:48.421]                           grepl <- base::grepl
[17:46:48.421]                           restarts <- computeRestarts(cond)
[17:46:48.421]                           for (restart in restarts) {
[17:46:48.421]                             name <- restart$name
[17:46:48.421]                             if (is.null(name)) 
[17:46:48.421]                               next
[17:46:48.421]                             if (!grepl(pattern, name)) 
[17:46:48.421]                               next
[17:46:48.421]                             invokeRestart(restart)
[17:46:48.421]                             muffled <- TRUE
[17:46:48.421]                             break
[17:46:48.421]                           }
[17:46:48.421]                         }
[17:46:48.421]                       }
[17:46:48.421]                       invisible(muffled)
[17:46:48.421]                     }
[17:46:48.421]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.421]                   }
[17:46:48.421]                 }
[17:46:48.421]                 else {
[17:46:48.421]                   if (TRUE) {
[17:46:48.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.421]                     {
[17:46:48.421]                       inherits <- base::inherits
[17:46:48.421]                       invokeRestart <- base::invokeRestart
[17:46:48.421]                       is.null <- base::is.null
[17:46:48.421]                       muffled <- FALSE
[17:46:48.421]                       if (inherits(cond, "message")) {
[17:46:48.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.421]                         if (muffled) 
[17:46:48.421]                           invokeRestart("muffleMessage")
[17:46:48.421]                       }
[17:46:48.421]                       else if (inherits(cond, "warning")) {
[17:46:48.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.421]                         if (muffled) 
[17:46:48.421]                           invokeRestart("muffleWarning")
[17:46:48.421]                       }
[17:46:48.421]                       else if (inherits(cond, "condition")) {
[17:46:48.421]                         if (!is.null(pattern)) {
[17:46:48.421]                           computeRestarts <- base::computeRestarts
[17:46:48.421]                           grepl <- base::grepl
[17:46:48.421]                           restarts <- computeRestarts(cond)
[17:46:48.421]                           for (restart in restarts) {
[17:46:48.421]                             name <- restart$name
[17:46:48.421]                             if (is.null(name)) 
[17:46:48.421]                               next
[17:46:48.421]                             if (!grepl(pattern, name)) 
[17:46:48.421]                               next
[17:46:48.421]                             invokeRestart(restart)
[17:46:48.421]                             muffled <- TRUE
[17:46:48.421]                             break
[17:46:48.421]                           }
[17:46:48.421]                         }
[17:46:48.421]                       }
[17:46:48.421]                       invisible(muffled)
[17:46:48.421]                     }
[17:46:48.421]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.421]                   }
[17:46:48.421]                 }
[17:46:48.421]             }
[17:46:48.421]         }))
[17:46:48.421]     }, error = function(ex) {
[17:46:48.421]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.421]                 ...future.rng), started = ...future.startTime, 
[17:46:48.421]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.421]             version = "1.8"), class = "FutureResult")
[17:46:48.421]     }, finally = {
[17:46:48.421]         if (!identical(...future.workdir, getwd())) 
[17:46:48.421]             setwd(...future.workdir)
[17:46:48.421]         {
[17:46:48.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.421]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.421]             }
[17:46:48.421]             base::options(...future.oldOptions)
[17:46:48.421]             if (.Platform$OS.type == "windows") {
[17:46:48.421]                 old_names <- names(...future.oldEnvVars)
[17:46:48.421]                 envs <- base::Sys.getenv()
[17:46:48.421]                 names <- names(envs)
[17:46:48.421]                 common <- intersect(names, old_names)
[17:46:48.421]                 added <- setdiff(names, old_names)
[17:46:48.421]                 removed <- setdiff(old_names, names)
[17:46:48.421]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.421]                   envs[common]]
[17:46:48.421]                 NAMES <- toupper(changed)
[17:46:48.421]                 args <- list()
[17:46:48.421]                 for (kk in seq_along(NAMES)) {
[17:46:48.421]                   name <- changed[[kk]]
[17:46:48.421]                   NAME <- NAMES[[kk]]
[17:46:48.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.421]                     next
[17:46:48.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.421]                 }
[17:46:48.421]                 NAMES <- toupper(added)
[17:46:48.421]                 for (kk in seq_along(NAMES)) {
[17:46:48.421]                   name <- added[[kk]]
[17:46:48.421]                   NAME <- NAMES[[kk]]
[17:46:48.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.421]                     next
[17:46:48.421]                   args[[name]] <- ""
[17:46:48.421]                 }
[17:46:48.421]                 NAMES <- toupper(removed)
[17:46:48.421]                 for (kk in seq_along(NAMES)) {
[17:46:48.421]                   name <- removed[[kk]]
[17:46:48.421]                   NAME <- NAMES[[kk]]
[17:46:48.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.421]                     next
[17:46:48.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.421]                 }
[17:46:48.421]                 if (length(args) > 0) 
[17:46:48.421]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.421]             }
[17:46:48.421]             else {
[17:46:48.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.421]             }
[17:46:48.421]             {
[17:46:48.421]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.421]                   0L) {
[17:46:48.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.421]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.421]                   base::options(opts)
[17:46:48.421]                 }
[17:46:48.421]                 {
[17:46:48.421]                   {
[17:46:48.421]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.421]                     NULL
[17:46:48.421]                   }
[17:46:48.421]                   options(future.plan = NULL)
[17:46:48.421]                   if (is.na(NA_character_)) 
[17:46:48.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.421]                     .init = FALSE)
[17:46:48.421]                 }
[17:46:48.421]             }
[17:46:48.421]         }
[17:46:48.421]     })
[17:46:48.421]     if (TRUE) {
[17:46:48.421]         base::sink(type = "output", split = FALSE)
[17:46:48.421]         if (TRUE) {
[17:46:48.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.421]         }
[17:46:48.421]         else {
[17:46:48.421]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.421]         }
[17:46:48.421]         base::close(...future.stdout)
[17:46:48.421]         ...future.stdout <- NULL
[17:46:48.421]     }
[17:46:48.421]     ...future.result$conditions <- ...future.conditions
[17:46:48.421]     ...future.result$finished <- base::Sys.time()
[17:46:48.421]     ...future.result
[17:46:48.421] }
[17:46:48.425] requestCore(): workers = 2
[17:46:48.428] MulticoreFuture started
[17:46:48.428] - Launch lazy future ... done
[17:46:48.428] run() for ‘MulticoreFuture’ ... done
[17:46:48.429] plan(): Setting new future strategy stack:
[17:46:48.429] getGlobalsAndPackages() ...
[17:46:48.429] Searching for globals...
[17:46:48.429] List of future strategies:
[17:46:48.429] 1. sequential:
[17:46:48.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.429]    - tweaked: FALSE
[17:46:48.429]    - call: NULL
[17:46:48.430] plan(): nbrOfWorkers() = 1
[17:46:48.431] - globals found: [1] ‘{’
[17:46:48.431] Searching for globals ... DONE
[17:46:48.431] Resolving globals: FALSE
[17:46:48.432] 
[17:46:48.432] 
[17:46:48.432] getGlobalsAndPackages() ... DONE
[17:46:48.432] plan(): Setting new future strategy stack:
[17:46:48.432] run() for ‘Future’ ...
[17:46:48.432] - state: ‘created’
[17:46:48.432] List of future strategies:
[17:46:48.432] 1. multicore:
[17:46:48.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.432]    - tweaked: FALSE
[17:46:48.432]    - call: plan(strategy)
[17:46:48.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.437] plan(): nbrOfWorkers() = 2
[17:46:48.437] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.438]   - Field: ‘label’
[17:46:48.438]   - Field: ‘local’
[17:46:48.438]   - Field: ‘owner’
[17:46:48.438]   - Field: ‘envir’
[17:46:48.438]   - Field: ‘workers’
[17:46:48.438]   - Field: ‘packages’
[17:46:48.439]   - Field: ‘gc’
[17:46:48.439]   - Field: ‘job’
[17:46:48.439]   - Field: ‘conditions’
[17:46:48.439]   - Field: ‘expr’
[17:46:48.439]   - Field: ‘uuid’
[17:46:48.439]   - Field: ‘seed’
[17:46:48.439]   - Field: ‘version’
[17:46:48.440]   - Field: ‘result’
[17:46:48.440]   - Field: ‘asynchronous’
[17:46:48.440]   - Field: ‘calls’
[17:46:48.440]   - Field: ‘globals’
[17:46:48.440]   - Field: ‘stdout’
[17:46:48.440]   - Field: ‘earlySignal’
[17:46:48.440]   - Field: ‘lazy’
[17:46:48.440]   - Field: ‘state’
[17:46:48.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.441] - Launch lazy future ...
[17:46:48.441] Packages needed by the future expression (n = 0): <none>
[17:46:48.441] Packages needed by future strategies (n = 0): <none>
[17:46:48.442] {
[17:46:48.442]     {
[17:46:48.442]         {
[17:46:48.442]             ...future.startTime <- base::Sys.time()
[17:46:48.442]             {
[17:46:48.442]                 {
[17:46:48.442]                   {
[17:46:48.442]                     {
[17:46:48.442]                       base::local({
[17:46:48.442]                         has_future <- base::requireNamespace("future", 
[17:46:48.442]                           quietly = TRUE)
[17:46:48.442]                         if (has_future) {
[17:46:48.442]                           ns <- base::getNamespace("future")
[17:46:48.442]                           version <- ns[[".package"]][["version"]]
[17:46:48.442]                           if (is.null(version)) 
[17:46:48.442]                             version <- utils::packageVersion("future")
[17:46:48.442]                         }
[17:46:48.442]                         else {
[17:46:48.442]                           version <- NULL
[17:46:48.442]                         }
[17:46:48.442]                         if (!has_future || version < "1.8.0") {
[17:46:48.442]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.442]                             "", base::R.version$version.string), 
[17:46:48.442]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.442]                               "release", "version")], collapse = " "), 
[17:46:48.442]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.442]                             info)
[17:46:48.442]                           info <- base::paste(info, collapse = "; ")
[17:46:48.442]                           if (!has_future) {
[17:46:48.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.442]                               info)
[17:46:48.442]                           }
[17:46:48.442]                           else {
[17:46:48.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.442]                               info, version)
[17:46:48.442]                           }
[17:46:48.442]                           base::stop(msg)
[17:46:48.442]                         }
[17:46:48.442]                       })
[17:46:48.442]                     }
[17:46:48.442]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.442]                     base::options(mc.cores = 1L)
[17:46:48.442]                   }
[17:46:48.442]                   ...future.strategy.old <- future::plan("list")
[17:46:48.442]                   options(future.plan = NULL)
[17:46:48.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.442]                 }
[17:46:48.442]                 ...future.workdir <- getwd()
[17:46:48.442]             }
[17:46:48.442]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.442]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.442]         }
[17:46:48.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.442]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.442]             base::names(...future.oldOptions))
[17:46:48.442]     }
[17:46:48.442]     if (FALSE) {
[17:46:48.442]     }
[17:46:48.442]     else {
[17:46:48.442]         if (TRUE) {
[17:46:48.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.442]                 open = "w")
[17:46:48.442]         }
[17:46:48.442]         else {
[17:46:48.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.442]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.442]         }
[17:46:48.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.442]             base::sink(type = "output", split = FALSE)
[17:46:48.442]             base::close(...future.stdout)
[17:46:48.442]         }, add = TRUE)
[17:46:48.442]     }
[17:46:48.442]     ...future.frame <- base::sys.nframe()
[17:46:48.442]     ...future.conditions <- base::list()
[17:46:48.442]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.442]     if (FALSE) {
[17:46:48.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.442]     }
[17:46:48.442]     ...future.result <- base::tryCatch({
[17:46:48.442]         base::withCallingHandlers({
[17:46:48.442]             ...future.value <- base::withVisible(base::local({
[17:46:48.442]                 withCallingHandlers({
[17:46:48.442]                   {
[17:46:48.442]                     4
[17:46:48.442]                   }
[17:46:48.442]                 }, immediateCondition = function(cond) {
[17:46:48.442]                   save_rds <- function (object, pathname, ...) 
[17:46:48.442]                   {
[17:46:48.442]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.442]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.442]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.442]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.442]                         fi_tmp[["mtime"]])
[17:46:48.442]                     }
[17:46:48.442]                     tryCatch({
[17:46:48.442]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.442]                     }, error = function(ex) {
[17:46:48.442]                       msg <- conditionMessage(ex)
[17:46:48.442]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.442]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.442]                         fi_tmp[["mtime"]], msg)
[17:46:48.442]                       ex$message <- msg
[17:46:48.442]                       stop(ex)
[17:46:48.442]                     })
[17:46:48.442]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.442]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.442]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.442]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.442]                       fi <- file.info(pathname)
[17:46:48.442]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.442]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.442]                         fi[["size"]], fi[["mtime"]])
[17:46:48.442]                       stop(msg)
[17:46:48.442]                     }
[17:46:48.442]                     invisible(pathname)
[17:46:48.442]                   }
[17:46:48.442]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.442]                     rootPath = tempdir()) 
[17:46:48.442]                   {
[17:46:48.442]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.442]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.442]                       tmpdir = path, fileext = ".rds")
[17:46:48.442]                     save_rds(obj, file)
[17:46:48.442]                   }
[17:46:48.442]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.442]                   {
[17:46:48.442]                     inherits <- base::inherits
[17:46:48.442]                     invokeRestart <- base::invokeRestart
[17:46:48.442]                     is.null <- base::is.null
[17:46:48.442]                     muffled <- FALSE
[17:46:48.442]                     if (inherits(cond, "message")) {
[17:46:48.442]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.442]                       if (muffled) 
[17:46:48.442]                         invokeRestart("muffleMessage")
[17:46:48.442]                     }
[17:46:48.442]                     else if (inherits(cond, "warning")) {
[17:46:48.442]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.442]                       if (muffled) 
[17:46:48.442]                         invokeRestart("muffleWarning")
[17:46:48.442]                     }
[17:46:48.442]                     else if (inherits(cond, "condition")) {
[17:46:48.442]                       if (!is.null(pattern)) {
[17:46:48.442]                         computeRestarts <- base::computeRestarts
[17:46:48.442]                         grepl <- base::grepl
[17:46:48.442]                         restarts <- computeRestarts(cond)
[17:46:48.442]                         for (restart in restarts) {
[17:46:48.442]                           name <- restart$name
[17:46:48.442]                           if (is.null(name)) 
[17:46:48.442]                             next
[17:46:48.442]                           if (!grepl(pattern, name)) 
[17:46:48.442]                             next
[17:46:48.442]                           invokeRestart(restart)
[17:46:48.442]                           muffled <- TRUE
[17:46:48.442]                           break
[17:46:48.442]                         }
[17:46:48.442]                       }
[17:46:48.442]                     }
[17:46:48.442]                     invisible(muffled)
[17:46:48.442]                   }
[17:46:48.442]                   muffleCondition(cond)
[17:46:48.442]                 })
[17:46:48.442]             }))
[17:46:48.442]             future::FutureResult(value = ...future.value$value, 
[17:46:48.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.442]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.442]                     ...future.globalenv.names))
[17:46:48.442]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.442]         }, condition = base::local({
[17:46:48.442]             c <- base::c
[17:46:48.442]             inherits <- base::inherits
[17:46:48.442]             invokeRestart <- base::invokeRestart
[17:46:48.442]             length <- base::length
[17:46:48.442]             list <- base::list
[17:46:48.442]             seq.int <- base::seq.int
[17:46:48.442]             signalCondition <- base::signalCondition
[17:46:48.442]             sys.calls <- base::sys.calls
[17:46:48.442]             `[[` <- base::`[[`
[17:46:48.442]             `+` <- base::`+`
[17:46:48.442]             `<<-` <- base::`<<-`
[17:46:48.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.442]                   3L)]
[17:46:48.442]             }
[17:46:48.442]             function(cond) {
[17:46:48.442]                 is_error <- inherits(cond, "error")
[17:46:48.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.442]                   NULL)
[17:46:48.442]                 if (is_error) {
[17:46:48.442]                   sessionInformation <- function() {
[17:46:48.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.442]                       search = base::search(), system = base::Sys.info())
[17:46:48.442]                   }
[17:46:48.442]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.442]                     cond$call), session = sessionInformation(), 
[17:46:48.442]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.442]                   signalCondition(cond)
[17:46:48.442]                 }
[17:46:48.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.442]                 "immediateCondition"))) {
[17:46:48.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.442]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.442]                   if (TRUE && !signal) {
[17:46:48.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.442]                     {
[17:46:48.442]                       inherits <- base::inherits
[17:46:48.442]                       invokeRestart <- base::invokeRestart
[17:46:48.442]                       is.null <- base::is.null
[17:46:48.442]                       muffled <- FALSE
[17:46:48.442]                       if (inherits(cond, "message")) {
[17:46:48.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.442]                         if (muffled) 
[17:46:48.442]                           invokeRestart("muffleMessage")
[17:46:48.442]                       }
[17:46:48.442]                       else if (inherits(cond, "warning")) {
[17:46:48.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.442]                         if (muffled) 
[17:46:48.442]                           invokeRestart("muffleWarning")
[17:46:48.442]                       }
[17:46:48.442]                       else if (inherits(cond, "condition")) {
[17:46:48.442]                         if (!is.null(pattern)) {
[17:46:48.442]                           computeRestarts <- base::computeRestarts
[17:46:48.442]                           grepl <- base::grepl
[17:46:48.442]                           restarts <- computeRestarts(cond)
[17:46:48.442]                           for (restart in restarts) {
[17:46:48.442]                             name <- restart$name
[17:46:48.442]                             if (is.null(name)) 
[17:46:48.442]                               next
[17:46:48.442]                             if (!grepl(pattern, name)) 
[17:46:48.442]                               next
[17:46:48.442]                             invokeRestart(restart)
[17:46:48.442]                             muffled <- TRUE
[17:46:48.442]                             break
[17:46:48.442]                           }
[17:46:48.442]                         }
[17:46:48.442]                       }
[17:46:48.442]                       invisible(muffled)
[17:46:48.442]                     }
[17:46:48.442]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.442]                   }
[17:46:48.442]                 }
[17:46:48.442]                 else {
[17:46:48.442]                   if (TRUE) {
[17:46:48.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.442]                     {
[17:46:48.442]                       inherits <- base::inherits
[17:46:48.442]                       invokeRestart <- base::invokeRestart
[17:46:48.442]                       is.null <- base::is.null
[17:46:48.442]                       muffled <- FALSE
[17:46:48.442]                       if (inherits(cond, "message")) {
[17:46:48.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.442]                         if (muffled) 
[17:46:48.442]                           invokeRestart("muffleMessage")
[17:46:48.442]                       }
[17:46:48.442]                       else if (inherits(cond, "warning")) {
[17:46:48.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.442]                         if (muffled) 
[17:46:48.442]                           invokeRestart("muffleWarning")
[17:46:48.442]                       }
[17:46:48.442]                       else if (inherits(cond, "condition")) {
[17:46:48.442]                         if (!is.null(pattern)) {
[17:46:48.442]                           computeRestarts <- base::computeRestarts
[17:46:48.442]                           grepl <- base::grepl
[17:46:48.442]                           restarts <- computeRestarts(cond)
[17:46:48.442]                           for (restart in restarts) {
[17:46:48.442]                             name <- restart$name
[17:46:48.442]                             if (is.null(name)) 
[17:46:48.442]                               next
[17:46:48.442]                             if (!grepl(pattern, name)) 
[17:46:48.442]                               next
[17:46:48.442]                             invokeRestart(restart)
[17:46:48.442]                             muffled <- TRUE
[17:46:48.442]                             break
[17:46:48.442]                           }
[17:46:48.442]                         }
[17:46:48.442]                       }
[17:46:48.442]                       invisible(muffled)
[17:46:48.442]                     }
[17:46:48.442]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.442]                   }
[17:46:48.442]                 }
[17:46:48.442]             }
[17:46:48.442]         }))
[17:46:48.442]     }, error = function(ex) {
[17:46:48.442]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.442]                 ...future.rng), started = ...future.startTime, 
[17:46:48.442]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.442]             version = "1.8"), class = "FutureResult")
[17:46:48.442]     }, finally = {
[17:46:48.442]         if (!identical(...future.workdir, getwd())) 
[17:46:48.442]             setwd(...future.workdir)
[17:46:48.442]         {
[17:46:48.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.442]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.442]             }
[17:46:48.442]             base::options(...future.oldOptions)
[17:46:48.442]             if (.Platform$OS.type == "windows") {
[17:46:48.442]                 old_names <- names(...future.oldEnvVars)
[17:46:48.442]                 envs <- base::Sys.getenv()
[17:46:48.442]                 names <- names(envs)
[17:46:48.442]                 common <- intersect(names, old_names)
[17:46:48.442]                 added <- setdiff(names, old_names)
[17:46:48.442]                 removed <- setdiff(old_names, names)
[17:46:48.442]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.442]                   envs[common]]
[17:46:48.442]                 NAMES <- toupper(changed)
[17:46:48.442]                 args <- list()
[17:46:48.442]                 for (kk in seq_along(NAMES)) {
[17:46:48.442]                   name <- changed[[kk]]
[17:46:48.442]                   NAME <- NAMES[[kk]]
[17:46:48.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.442]                     next
[17:46:48.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.442]                 }
[17:46:48.442]                 NAMES <- toupper(added)
[17:46:48.442]                 for (kk in seq_along(NAMES)) {
[17:46:48.442]                   name <- added[[kk]]
[17:46:48.442]                   NAME <- NAMES[[kk]]
[17:46:48.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.442]                     next
[17:46:48.442]                   args[[name]] <- ""
[17:46:48.442]                 }
[17:46:48.442]                 NAMES <- toupper(removed)
[17:46:48.442]                 for (kk in seq_along(NAMES)) {
[17:46:48.442]                   name <- removed[[kk]]
[17:46:48.442]                   NAME <- NAMES[[kk]]
[17:46:48.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.442]                     next
[17:46:48.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.442]                 }
[17:46:48.442]                 if (length(args) > 0) 
[17:46:48.442]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.442]             }
[17:46:48.442]             else {
[17:46:48.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.442]             }
[17:46:48.442]             {
[17:46:48.442]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.442]                   0L) {
[17:46:48.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.442]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.442]                   base::options(opts)
[17:46:48.442]                 }
[17:46:48.442]                 {
[17:46:48.442]                   {
[17:46:48.442]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.442]                     NULL
[17:46:48.442]                   }
[17:46:48.442]                   options(future.plan = NULL)
[17:46:48.442]                   if (is.na(NA_character_)) 
[17:46:48.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.442]                     .init = FALSE)
[17:46:48.442]                 }
[17:46:48.442]             }
[17:46:48.442]         }
[17:46:48.442]     })
[17:46:48.442]     if (TRUE) {
[17:46:48.442]         base::sink(type = "output", split = FALSE)
[17:46:48.442]         if (TRUE) {
[17:46:48.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.442]         }
[17:46:48.442]         else {
[17:46:48.442]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.442]         }
[17:46:48.442]         base::close(...future.stdout)
[17:46:48.442]         ...future.stdout <- NULL
[17:46:48.442]     }
[17:46:48.442]     ...future.result$conditions <- ...future.conditions
[17:46:48.442]     ...future.result$finished <- base::Sys.time()
[17:46:48.442]     ...future.result
[17:46:48.442] }
[17:46:48.445] requestCore(): workers = 2
[17:46:48.446] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:48.456] result() for MulticoreFuture ...
[17:46:48.457] result() for MulticoreFuture ...
[17:46:48.458] result() for MulticoreFuture ... done
[17:46:48.458] result() for MulticoreFuture ... done
[17:46:48.458] result() for MulticoreFuture ...
[17:46:48.458] result() for MulticoreFuture ... done
[17:46:48.461] MulticoreFuture started
[17:46:48.461] - Launch lazy future ... done
[17:46:48.461] run() for ‘MulticoreFuture’ ... done
[17:46:48.462] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x561789196c50> 
[17:46:48.462] List of future strategies:
[17:46:48.462] 1. sequential:
[17:46:48.462]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.462]    - tweaked: FALSE
[17:46:48.462]    - call: NULL
[17:46:48.464] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x561789c938f0> 
 - attr(*, "dim.")=[17:46:48.466] plan(): Setting new future strategy stack:
[17:46:48.467] List of future strategies:
[17:46:48.467] 1. multicore:
[17:46:48.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.467]    - tweaked: FALSE
[17:46:48.467]    - call: plan(strategy)
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:48.486] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:48.490] resolve() on list environment ...
[17:46:48.490]  recursive: 0
[17:46:48.492]  length: 6
[17:46:48.492]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:48.492] signalConditionsASAP(numeric, pos=1) ...
[17:46:48.492] - nx: 6
[17:46:48.492] - relay: TRUE
[17:46:48.492] - stdout: TRUE
[17:46:48.492] - signal: TRUE
[17:46:48.493] - resignal: FALSE
[17:46:48.493] - force: TRUE
[17:46:48.493] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.493] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.493]  - until=2
[17:46:48.493]  - relaying element #2
[17:46:48.493] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.493] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.494] signalConditionsASAP(NULL, pos=1) ... done
[17:46:48.494]  length: 5 (resolved future 1)
[17:46:48.494] Future #2
[17:46:48.494] result() for MulticoreFuture ...
[17:46:48.494] result() for MulticoreFuture ... done
[17:46:48.494] result() for MulticoreFuture ...
[17:46:48.494] result() for MulticoreFuture ... done
[17:46:48.495] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:48.495] - nx: 6
[17:46:48.495] - relay: TRUE
[17:46:48.495] - stdout: TRUE
[17:46:48.495] - signal: TRUE
[17:46:48.495] - resignal: FALSE
[17:46:48.495] - force: TRUE
[17:46:48.495] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.496] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.496]  - until=2
[17:46:48.496]  - relaying element #2
[17:46:48.496] result() for MulticoreFuture ...
[17:46:48.496] result() for MulticoreFuture ... done
[17:46:48.496] result() for MulticoreFuture ...
[17:46:48.496] result() for MulticoreFuture ... done
[17:46:48.497] result() for MulticoreFuture ...
[17:46:48.497] result() for MulticoreFuture ... done
[17:46:48.497] result() for MulticoreFuture ...
[17:46:48.497] result() for MulticoreFuture ... done
[17:46:48.497] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.497] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.497] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:48.497]  length: 4 (resolved future 2)
[17:46:48.498] Future #3
[17:46:48.498] result() for MulticoreFuture ...
[17:46:48.499] result() for MulticoreFuture ...
[17:46:48.499] result() for MulticoreFuture ... done
[17:46:48.499] result() for MulticoreFuture ... done
[17:46:48.499] result() for MulticoreFuture ...
[17:46:48.499] result() for MulticoreFuture ... done
[17:46:48.499] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:48.499] - nx: 6
[17:46:48.500] - relay: TRUE
[17:46:48.500] - stdout: TRUE
[17:46:48.500] - signal: TRUE
[17:46:48.500] - resignal: FALSE
[17:46:48.500] - force: TRUE
[17:46:48.500] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.500] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.500]  - until=3
[17:46:48.501]  - relaying element #3
[17:46:48.501] result() for MulticoreFuture ...
[17:46:48.501] result() for MulticoreFuture ... done
[17:46:48.501] result() for MulticoreFuture ...
[17:46:48.501] result() for MulticoreFuture ... done
[17:46:48.501] result() for MulticoreFuture ...
[17:46:48.501] result() for MulticoreFuture ... done
[17:46:48.501] result() for MulticoreFuture ...
[17:46:48.502] result() for MulticoreFuture ... done
[17:46:48.502] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.502] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.502] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:48.502]  length: 3 (resolved future 3)
[17:46:48.502] Future #4
[17:46:48.503] result() for MulticoreFuture ...
[17:46:48.503] result() for MulticoreFuture ...
[17:46:48.503] result() for MulticoreFuture ... done
[17:46:48.504] result() for MulticoreFuture ... done
[17:46:48.504] result() for MulticoreFuture ...
[17:46:48.504] result() for MulticoreFuture ... done
[17:46:48.504] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:48.504] - nx: 6
[17:46:48.504] - relay: TRUE
[17:46:48.505] - stdout: TRUE
[17:46:48.505] - signal: TRUE
[17:46:48.505] - resignal: FALSE
[17:46:48.505] - force: TRUE
[17:46:48.505] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.505] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.505]  - until=4
[17:46:48.506]  - relaying element #4
[17:46:48.506] result() for MulticoreFuture ...
[17:46:48.506] result() for MulticoreFuture ... done
[17:46:48.506] result() for MulticoreFuture ...
[17:46:48.506] result() for MulticoreFuture ... done
[17:46:48.506] result() for MulticoreFuture ...
[17:46:48.506] result() for MulticoreFuture ... done
[17:46:48.507] result() for MulticoreFuture ...
[17:46:48.507] result() for MulticoreFuture ... done
[17:46:48.507] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.507] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.507] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:48.507]  length: 2 (resolved future 4)
[17:46:48.508] signalConditionsASAP(NULL, pos=5) ...
[17:46:48.508] - nx: 6
[17:46:48.508] - relay: TRUE
[17:46:48.508] - stdout: TRUE
[17:46:48.508] - signal: TRUE
[17:46:48.508] - resignal: FALSE
[17:46:48.508] - force: TRUE
[17:46:48.508] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.509] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.509]  - until=6
[17:46:48.509]  - relaying element #6
[17:46:48.509] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.509] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.509] signalConditionsASAP(NULL, pos=5) ... done
[17:46:48.509]  length: 1 (resolved future 5)
[17:46:48.509] signalConditionsASAP(numeric, pos=6) ...
[17:46:48.509] - nx: 6
[17:46:48.509] - relay: TRUE
[17:46:48.510] - stdout: TRUE
[17:46:48.510] - signal: TRUE
[17:46:48.510] - resignal: FALSE
[17:46:48.510] - force: TRUE
[17:46:48.510] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.510] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.510]  - until=6
[17:46:48.510] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.510] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.510] signalConditionsASAP(numeric, pos=6) ... done
[17:46:48.511]  length: 0 (resolved future 6)
[17:46:48.511] Relaying remaining futures
[17:46:48.511] signalConditionsASAP(NULL, pos=0) ...
[17:46:48.511] - nx: 6
[17:46:48.511] - relay: TRUE
[17:46:48.511] - stdout: TRUE
[17:46:48.511] - signal: TRUE
[17:46:48.511] - resignal: FALSE
[17:46:48.511] - force: TRUE
[17:46:48.511] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.512] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:48.512] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.512] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.512] signalConditionsASAP(NULL, pos=0) ... done
[17:46:48.512] resolve() on list environment ... DONE
[17:46:48.512] result() for MulticoreFuture ...
[17:46:48.512] result() for MulticoreFuture ... done
[17:46:48.512] result() for MulticoreFuture ...
[17:46:48.513] result() for MulticoreFuture ... done
[17:46:48.513] result() for MulticoreFuture ...
[17:46:48.513] result() for MulticoreFuture ... done
[17:46:48.513] result() for MulticoreFuture ...
[17:46:48.513] result() for MulticoreFuture ... done
[17:46:48.513] result() for MulticoreFuture ...
[17:46:48.513] result() for MulticoreFuture ... done
[17:46:48.514] result() for MulticoreFuture ...
[17:46:48.514] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5617881e7e20> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:46:48.516] getGlobalsAndPackages() ...
[17:46:48.516] Searching for globals...
[17:46:48.517] 
[17:46:48.517] Searching for globals ... DONE
[17:46:48.517] - globals: [0] <none>
[17:46:48.517] getGlobalsAndPackages() ... DONE
[17:46:48.517] run() for ‘Future’ ...
[17:46:48.518] - state: ‘created’
[17:46:48.518] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.522] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.522] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.522]   - Field: ‘label’
[17:46:48.522]   - Field: ‘local’
[17:46:48.522]   - Field: ‘owner’
[17:46:48.522]   - Field: ‘envir’
[17:46:48.523]   - Field: ‘workers’
[17:46:48.523]   - Field: ‘packages’
[17:46:48.523]   - Field: ‘gc’
[17:46:48.523]   - Field: ‘job’
[17:46:48.523]   - Field: ‘conditions’
[17:46:48.523]   - Field: ‘expr’
[17:46:48.523]   - Field: ‘uuid’
[17:46:48.523]   - Field: ‘seed’
[17:46:48.523]   - Field: ‘version’
[17:46:48.524]   - Field: ‘result’
[17:46:48.524]   - Field: ‘asynchronous’
[17:46:48.524]   - Field: ‘calls’
[17:46:48.524]   - Field: ‘globals’
[17:46:48.524]   - Field: ‘stdout’
[17:46:48.524]   - Field: ‘earlySignal’
[17:46:48.524]   - Field: ‘lazy’
[17:46:48.524]   - Field: ‘state’
[17:46:48.524] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.525] - Launch lazy future ...
[17:46:48.525] Packages needed by the future expression (n = 0): <none>
[17:46:48.525] Packages needed by future strategies (n = 0): <none>
[17:46:48.526] {
[17:46:48.526]     {
[17:46:48.526]         {
[17:46:48.526]             ...future.startTime <- base::Sys.time()
[17:46:48.526]             {
[17:46:48.526]                 {
[17:46:48.526]                   {
[17:46:48.526]                     {
[17:46:48.526]                       base::local({
[17:46:48.526]                         has_future <- base::requireNamespace("future", 
[17:46:48.526]                           quietly = TRUE)
[17:46:48.526]                         if (has_future) {
[17:46:48.526]                           ns <- base::getNamespace("future")
[17:46:48.526]                           version <- ns[[".package"]][["version"]]
[17:46:48.526]                           if (is.null(version)) 
[17:46:48.526]                             version <- utils::packageVersion("future")
[17:46:48.526]                         }
[17:46:48.526]                         else {
[17:46:48.526]                           version <- NULL
[17:46:48.526]                         }
[17:46:48.526]                         if (!has_future || version < "1.8.0") {
[17:46:48.526]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.526]                             "", base::R.version$version.string), 
[17:46:48.526]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.526]                               "release", "version")], collapse = " "), 
[17:46:48.526]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.526]                             info)
[17:46:48.526]                           info <- base::paste(info, collapse = "; ")
[17:46:48.526]                           if (!has_future) {
[17:46:48.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.526]                               info)
[17:46:48.526]                           }
[17:46:48.526]                           else {
[17:46:48.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.526]                               info, version)
[17:46:48.526]                           }
[17:46:48.526]                           base::stop(msg)
[17:46:48.526]                         }
[17:46:48.526]                       })
[17:46:48.526]                     }
[17:46:48.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.526]                     base::options(mc.cores = 1L)
[17:46:48.526]                   }
[17:46:48.526]                   ...future.strategy.old <- future::plan("list")
[17:46:48.526]                   options(future.plan = NULL)
[17:46:48.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.526]                 }
[17:46:48.526]                 ...future.workdir <- getwd()
[17:46:48.526]             }
[17:46:48.526]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.526]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.526]         }
[17:46:48.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.526]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.526]             base::names(...future.oldOptions))
[17:46:48.526]     }
[17:46:48.526]     if (FALSE) {
[17:46:48.526]     }
[17:46:48.526]     else {
[17:46:48.526]         if (TRUE) {
[17:46:48.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.526]                 open = "w")
[17:46:48.526]         }
[17:46:48.526]         else {
[17:46:48.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.526]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.526]         }
[17:46:48.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.526]             base::sink(type = "output", split = FALSE)
[17:46:48.526]             base::close(...future.stdout)
[17:46:48.526]         }, add = TRUE)
[17:46:48.526]     }
[17:46:48.526]     ...future.frame <- base::sys.nframe()
[17:46:48.526]     ...future.conditions <- base::list()
[17:46:48.526]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.526]     if (FALSE) {
[17:46:48.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.526]     }
[17:46:48.526]     ...future.result <- base::tryCatch({
[17:46:48.526]         base::withCallingHandlers({
[17:46:48.526]             ...future.value <- base::withVisible(base::local({
[17:46:48.526]                 withCallingHandlers({
[17:46:48.526]                   2
[17:46:48.526]                 }, immediateCondition = function(cond) {
[17:46:48.526]                   save_rds <- function (object, pathname, ...) 
[17:46:48.526]                   {
[17:46:48.526]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.526]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.526]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.526]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.526]                         fi_tmp[["mtime"]])
[17:46:48.526]                     }
[17:46:48.526]                     tryCatch({
[17:46:48.526]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.526]                     }, error = function(ex) {
[17:46:48.526]                       msg <- conditionMessage(ex)
[17:46:48.526]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.526]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.526]                         fi_tmp[["mtime"]], msg)
[17:46:48.526]                       ex$message <- msg
[17:46:48.526]                       stop(ex)
[17:46:48.526]                     })
[17:46:48.526]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.526]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.526]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.526]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.526]                       fi <- file.info(pathname)
[17:46:48.526]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.526]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.526]                         fi[["size"]], fi[["mtime"]])
[17:46:48.526]                       stop(msg)
[17:46:48.526]                     }
[17:46:48.526]                     invisible(pathname)
[17:46:48.526]                   }
[17:46:48.526]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.526]                     rootPath = tempdir()) 
[17:46:48.526]                   {
[17:46:48.526]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.526]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.526]                       tmpdir = path, fileext = ".rds")
[17:46:48.526]                     save_rds(obj, file)
[17:46:48.526]                   }
[17:46:48.526]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.526]                   {
[17:46:48.526]                     inherits <- base::inherits
[17:46:48.526]                     invokeRestart <- base::invokeRestart
[17:46:48.526]                     is.null <- base::is.null
[17:46:48.526]                     muffled <- FALSE
[17:46:48.526]                     if (inherits(cond, "message")) {
[17:46:48.526]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.526]                       if (muffled) 
[17:46:48.526]                         invokeRestart("muffleMessage")
[17:46:48.526]                     }
[17:46:48.526]                     else if (inherits(cond, "warning")) {
[17:46:48.526]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.526]                       if (muffled) 
[17:46:48.526]                         invokeRestart("muffleWarning")
[17:46:48.526]                     }
[17:46:48.526]                     else if (inherits(cond, "condition")) {
[17:46:48.526]                       if (!is.null(pattern)) {
[17:46:48.526]                         computeRestarts <- base::computeRestarts
[17:46:48.526]                         grepl <- base::grepl
[17:46:48.526]                         restarts <- computeRestarts(cond)
[17:46:48.526]                         for (restart in restarts) {
[17:46:48.526]                           name <- restart$name
[17:46:48.526]                           if (is.null(name)) 
[17:46:48.526]                             next
[17:46:48.526]                           if (!grepl(pattern, name)) 
[17:46:48.526]                             next
[17:46:48.526]                           invokeRestart(restart)
[17:46:48.526]                           muffled <- TRUE
[17:46:48.526]                           break
[17:46:48.526]                         }
[17:46:48.526]                       }
[17:46:48.526]                     }
[17:46:48.526]                     invisible(muffled)
[17:46:48.526]                   }
[17:46:48.526]                   muffleCondition(cond)
[17:46:48.526]                 })
[17:46:48.526]             }))
[17:46:48.526]             future::FutureResult(value = ...future.value$value, 
[17:46:48.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.526]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.526]                     ...future.globalenv.names))
[17:46:48.526]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.526]         }, condition = base::local({
[17:46:48.526]             c <- base::c
[17:46:48.526]             inherits <- base::inherits
[17:46:48.526]             invokeRestart <- base::invokeRestart
[17:46:48.526]             length <- base::length
[17:46:48.526]             list <- base::list
[17:46:48.526]             seq.int <- base::seq.int
[17:46:48.526]             signalCondition <- base::signalCondition
[17:46:48.526]             sys.calls <- base::sys.calls
[17:46:48.526]             `[[` <- base::`[[`
[17:46:48.526]             `+` <- base::`+`
[17:46:48.526]             `<<-` <- base::`<<-`
[17:46:48.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.526]                   3L)]
[17:46:48.526]             }
[17:46:48.526]             function(cond) {
[17:46:48.526]                 is_error <- inherits(cond, "error")
[17:46:48.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.526]                   NULL)
[17:46:48.526]                 if (is_error) {
[17:46:48.526]                   sessionInformation <- function() {
[17:46:48.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.526]                       search = base::search(), system = base::Sys.info())
[17:46:48.526]                   }
[17:46:48.526]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.526]                     cond$call), session = sessionInformation(), 
[17:46:48.526]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.526]                   signalCondition(cond)
[17:46:48.526]                 }
[17:46:48.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.526]                 "immediateCondition"))) {
[17:46:48.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.526]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.526]                   if (TRUE && !signal) {
[17:46:48.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.526]                     {
[17:46:48.526]                       inherits <- base::inherits
[17:46:48.526]                       invokeRestart <- base::invokeRestart
[17:46:48.526]                       is.null <- base::is.null
[17:46:48.526]                       muffled <- FALSE
[17:46:48.526]                       if (inherits(cond, "message")) {
[17:46:48.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.526]                         if (muffled) 
[17:46:48.526]                           invokeRestart("muffleMessage")
[17:46:48.526]                       }
[17:46:48.526]                       else if (inherits(cond, "warning")) {
[17:46:48.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.526]                         if (muffled) 
[17:46:48.526]                           invokeRestart("muffleWarning")
[17:46:48.526]                       }
[17:46:48.526]                       else if (inherits(cond, "condition")) {
[17:46:48.526]                         if (!is.null(pattern)) {
[17:46:48.526]                           computeRestarts <- base::computeRestarts
[17:46:48.526]                           grepl <- base::grepl
[17:46:48.526]                           restarts <- computeRestarts(cond)
[17:46:48.526]                           for (restart in restarts) {
[17:46:48.526]                             name <- restart$name
[17:46:48.526]                             if (is.null(name)) 
[17:46:48.526]                               next
[17:46:48.526]                             if (!grepl(pattern, name)) 
[17:46:48.526]                               next
[17:46:48.526]                             invokeRestart(restart)
[17:46:48.526]                             muffled <- TRUE
[17:46:48.526]                             break
[17:46:48.526]                           }
[17:46:48.526]                         }
[17:46:48.526]                       }
[17:46:48.526]                       invisible(muffled)
[17:46:48.526]                     }
[17:46:48.526]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.526]                   }
[17:46:48.526]                 }
[17:46:48.526]                 else {
[17:46:48.526]                   if (TRUE) {
[17:46:48.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.526]                     {
[17:46:48.526]                       inherits <- base::inherits
[17:46:48.526]                       invokeRestart <- base::invokeRestart
[17:46:48.526]                       is.null <- base::is.null
[17:46:48.526]                       muffled <- FALSE
[17:46:48.526]                       if (inherits(cond, "message")) {
[17:46:48.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.526]                         if (muffled) 
[17:46:48.526]                           invokeRestart("muffleMessage")
[17:46:48.526]                       }
[17:46:48.526]                       else if (inherits(cond, "warning")) {
[17:46:48.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.526]                         if (muffled) 
[17:46:48.526]                           invokeRestart("muffleWarning")
[17:46:48.526]                       }
[17:46:48.526]                       else if (inherits(cond, "condition")) {
[17:46:48.526]                         if (!is.null(pattern)) {
[17:46:48.526]                           computeRestarts <- base::computeRestarts
[17:46:48.526]                           grepl <- base::grepl
[17:46:48.526]                           restarts <- computeRestarts(cond)
[17:46:48.526]                           for (restart in restarts) {
[17:46:48.526]                             name <- restart$name
[17:46:48.526]                             if (is.null(name)) 
[17:46:48.526]                               next
[17:46:48.526]                             if (!grepl(pattern, name)) 
[17:46:48.526]                               next
[17:46:48.526]                             invokeRestart(restart)
[17:46:48.526]                             muffled <- TRUE
[17:46:48.526]                             break
[17:46:48.526]                           }
[17:46:48.526]                         }
[17:46:48.526]                       }
[17:46:48.526]                       invisible(muffled)
[17:46:48.526]                     }
[17:46:48.526]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.526]                   }
[17:46:48.526]                 }
[17:46:48.526]             }
[17:46:48.526]         }))
[17:46:48.526]     }, error = function(ex) {
[17:46:48.526]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.526]                 ...future.rng), started = ...future.startTime, 
[17:46:48.526]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.526]             version = "1.8"), class = "FutureResult")
[17:46:48.526]     }, finally = {
[17:46:48.526]         if (!identical(...future.workdir, getwd())) 
[17:46:48.526]             setwd(...future.workdir)
[17:46:48.526]         {
[17:46:48.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.526]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.526]             }
[17:46:48.526]             base::options(...future.oldOptions)
[17:46:48.526]             if (.Platform$OS.type == "windows") {
[17:46:48.526]                 old_names <- names(...future.oldEnvVars)
[17:46:48.526]                 envs <- base::Sys.getenv()
[17:46:48.526]                 names <- names(envs)
[17:46:48.526]                 common <- intersect(names, old_names)
[17:46:48.526]                 added <- setdiff(names, old_names)
[17:46:48.526]                 removed <- setdiff(old_names, names)
[17:46:48.526]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.526]                   envs[common]]
[17:46:48.526]                 NAMES <- toupper(changed)
[17:46:48.526]                 args <- list()
[17:46:48.526]                 for (kk in seq_along(NAMES)) {
[17:46:48.526]                   name <- changed[[kk]]
[17:46:48.526]                   NAME <- NAMES[[kk]]
[17:46:48.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.526]                     next
[17:46:48.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.526]                 }
[17:46:48.526]                 NAMES <- toupper(added)
[17:46:48.526]                 for (kk in seq_along(NAMES)) {
[17:46:48.526]                   name <- added[[kk]]
[17:46:48.526]                   NAME <- NAMES[[kk]]
[17:46:48.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.526]                     next
[17:46:48.526]                   args[[name]] <- ""
[17:46:48.526]                 }
[17:46:48.526]                 NAMES <- toupper(removed)
[17:46:48.526]                 for (kk in seq_along(NAMES)) {
[17:46:48.526]                   name <- removed[[kk]]
[17:46:48.526]                   NAME <- NAMES[[kk]]
[17:46:48.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.526]                     next
[17:46:48.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.526]                 }
[17:46:48.526]                 if (length(args) > 0) 
[17:46:48.526]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.526]             }
[17:46:48.526]             else {
[17:46:48.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.526]             }
[17:46:48.526]             {
[17:46:48.526]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.526]                   0L) {
[17:46:48.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.526]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.526]                   base::options(opts)
[17:46:48.526]                 }
[17:46:48.526]                 {
[17:46:48.526]                   {
[17:46:48.526]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.526]                     NULL
[17:46:48.526]                   }
[17:46:48.526]                   options(future.plan = NULL)
[17:46:48.526]                   if (is.na(NA_character_)) 
[17:46:48.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.526]                     .init = FALSE)
[17:46:48.526]                 }
[17:46:48.526]             }
[17:46:48.526]         }
[17:46:48.526]     })
[17:46:48.526]     if (TRUE) {
[17:46:48.526]         base::sink(type = "output", split = FALSE)
[17:46:48.526]         if (TRUE) {
[17:46:48.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.526]         }
[17:46:48.526]         else {
[17:46:48.526]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.526]         }
[17:46:48.526]         base::close(...future.stdout)
[17:46:48.526]         ...future.stdout <- NULL
[17:46:48.526]     }
[17:46:48.526]     ...future.result$conditions <- ...future.conditions
[17:46:48.526]     ...future.result$finished <- base::Sys.time()
[17:46:48.526]     ...future.result
[17:46:48.526] }
[17:46:48.528] requestCore(): workers = 2
[17:46:48.530] MulticoreFuture started
[17:46:48.530] - Launch lazy future ... done
[17:46:48.531] run() for ‘MulticoreFuture’ ... done
[17:46:48.531] getGlobalsAndPackages() ...
[17:46:48.531] Searching for globals...
[17:46:48.531] plan(): Setting new future strategy stack:
[17:46:48.532] 
[17:46:48.532] Searching for globals ... DONE
[17:46:48.532] List of future strategies:
[17:46:48.532] 1. sequential:
[17:46:48.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.532]    - tweaked: FALSE
[17:46:48.532]    - call: NULL
[17:46:48.532] - globals: [0] <none>
[17:46:48.532] getGlobalsAndPackages() ... DONE
[17:46:48.533] plan(): nbrOfWorkers() = 1
[17:46:48.533] run() for ‘Future’ ...
[17:46:48.533] - state: ‘created’
[17:46:48.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.534] plan(): Setting new future strategy stack:
[17:46:48.535] List of future strategies:
[17:46:48.535] 1. multicore:
[17:46:48.535]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.535]    - tweaked: FALSE
[17:46:48.535]    - call: plan(strategy)
[17:46:48.539] plan(): nbrOfWorkers() = 2
[17:46:48.539] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.539] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.539]   - Field: ‘label’
[17:46:48.540]   - Field: ‘local’
[17:46:48.540]   - Field: ‘owner’
[17:46:48.540]   - Field: ‘envir’
[17:46:48.540]   - Field: ‘workers’
[17:46:48.540]   - Field: ‘packages’
[17:46:48.540]   - Field: ‘gc’
[17:46:48.541]   - Field: ‘job’
[17:46:48.541]   - Field: ‘conditions’
[17:46:48.541]   - Field: ‘expr’
[17:46:48.541]   - Field: ‘uuid’
[17:46:48.541]   - Field: ‘seed’
[17:46:48.541]   - Field: ‘version’
[17:46:48.541]   - Field: ‘result’
[17:46:48.542]   - Field: ‘asynchronous’
[17:46:48.542]   - Field: ‘calls’
[17:46:48.542]   - Field: ‘globals’
[17:46:48.542]   - Field: ‘stdout’
[17:46:48.542]   - Field: ‘earlySignal’
[17:46:48.542]   - Field: ‘lazy’
[17:46:48.542]   - Field: ‘state’
[17:46:48.543] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.543] - Launch lazy future ...
[17:46:48.543] Packages needed by the future expression (n = 0): <none>
[17:46:48.543] Packages needed by future strategies (n = 0): <none>
[17:46:48.544] {
[17:46:48.544]     {
[17:46:48.544]         {
[17:46:48.544]             ...future.startTime <- base::Sys.time()
[17:46:48.544]             {
[17:46:48.544]                 {
[17:46:48.544]                   {
[17:46:48.544]                     {
[17:46:48.544]                       base::local({
[17:46:48.544]                         has_future <- base::requireNamespace("future", 
[17:46:48.544]                           quietly = TRUE)
[17:46:48.544]                         if (has_future) {
[17:46:48.544]                           ns <- base::getNamespace("future")
[17:46:48.544]                           version <- ns[[".package"]][["version"]]
[17:46:48.544]                           if (is.null(version)) 
[17:46:48.544]                             version <- utils::packageVersion("future")
[17:46:48.544]                         }
[17:46:48.544]                         else {
[17:46:48.544]                           version <- NULL
[17:46:48.544]                         }
[17:46:48.544]                         if (!has_future || version < "1.8.0") {
[17:46:48.544]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.544]                             "", base::R.version$version.string), 
[17:46:48.544]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.544]                               "release", "version")], collapse = " "), 
[17:46:48.544]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.544]                             info)
[17:46:48.544]                           info <- base::paste(info, collapse = "; ")
[17:46:48.544]                           if (!has_future) {
[17:46:48.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.544]                               info)
[17:46:48.544]                           }
[17:46:48.544]                           else {
[17:46:48.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.544]                               info, version)
[17:46:48.544]                           }
[17:46:48.544]                           base::stop(msg)
[17:46:48.544]                         }
[17:46:48.544]                       })
[17:46:48.544]                     }
[17:46:48.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.544]                     base::options(mc.cores = 1L)
[17:46:48.544]                   }
[17:46:48.544]                   ...future.strategy.old <- future::plan("list")
[17:46:48.544]                   options(future.plan = NULL)
[17:46:48.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.544]                 }
[17:46:48.544]                 ...future.workdir <- getwd()
[17:46:48.544]             }
[17:46:48.544]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.544]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.544]         }
[17:46:48.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.544]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.544]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.544]             base::names(...future.oldOptions))
[17:46:48.544]     }
[17:46:48.544]     if (FALSE) {
[17:46:48.544]     }
[17:46:48.544]     else {
[17:46:48.544]         if (TRUE) {
[17:46:48.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.544]                 open = "w")
[17:46:48.544]         }
[17:46:48.544]         else {
[17:46:48.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.544]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.544]         }
[17:46:48.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.544]             base::sink(type = "output", split = FALSE)
[17:46:48.544]             base::close(...future.stdout)
[17:46:48.544]         }, add = TRUE)
[17:46:48.544]     }
[17:46:48.544]     ...future.frame <- base::sys.nframe()
[17:46:48.544]     ...future.conditions <- base::list()
[17:46:48.544]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.544]     if (FALSE) {
[17:46:48.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.544]     }
[17:46:48.544]     ...future.result <- base::tryCatch({
[17:46:48.544]         base::withCallingHandlers({
[17:46:48.544]             ...future.value <- base::withVisible(base::local({
[17:46:48.544]                 withCallingHandlers({
[17:46:48.544]                   NULL
[17:46:48.544]                 }, immediateCondition = function(cond) {
[17:46:48.544]                   save_rds <- function (object, pathname, ...) 
[17:46:48.544]                   {
[17:46:48.544]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.544]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.544]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.544]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.544]                         fi_tmp[["mtime"]])
[17:46:48.544]                     }
[17:46:48.544]                     tryCatch({
[17:46:48.544]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.544]                     }, error = function(ex) {
[17:46:48.544]                       msg <- conditionMessage(ex)
[17:46:48.544]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.544]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.544]                         fi_tmp[["mtime"]], msg)
[17:46:48.544]                       ex$message <- msg
[17:46:48.544]                       stop(ex)
[17:46:48.544]                     })
[17:46:48.544]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.544]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.544]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.544]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.544]                       fi <- file.info(pathname)
[17:46:48.544]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.544]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.544]                         fi[["size"]], fi[["mtime"]])
[17:46:48.544]                       stop(msg)
[17:46:48.544]                     }
[17:46:48.544]                     invisible(pathname)
[17:46:48.544]                   }
[17:46:48.544]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.544]                     rootPath = tempdir()) 
[17:46:48.544]                   {
[17:46:48.544]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.544]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.544]                       tmpdir = path, fileext = ".rds")
[17:46:48.544]                     save_rds(obj, file)
[17:46:48.544]                   }
[17:46:48.544]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.544]                   {
[17:46:48.544]                     inherits <- base::inherits
[17:46:48.544]                     invokeRestart <- base::invokeRestart
[17:46:48.544]                     is.null <- base::is.null
[17:46:48.544]                     muffled <- FALSE
[17:46:48.544]                     if (inherits(cond, "message")) {
[17:46:48.544]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.544]                       if (muffled) 
[17:46:48.544]                         invokeRestart("muffleMessage")
[17:46:48.544]                     }
[17:46:48.544]                     else if (inherits(cond, "warning")) {
[17:46:48.544]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.544]                       if (muffled) 
[17:46:48.544]                         invokeRestart("muffleWarning")
[17:46:48.544]                     }
[17:46:48.544]                     else if (inherits(cond, "condition")) {
[17:46:48.544]                       if (!is.null(pattern)) {
[17:46:48.544]                         computeRestarts <- base::computeRestarts
[17:46:48.544]                         grepl <- base::grepl
[17:46:48.544]                         restarts <- computeRestarts(cond)
[17:46:48.544]                         for (restart in restarts) {
[17:46:48.544]                           name <- restart$name
[17:46:48.544]                           if (is.null(name)) 
[17:46:48.544]                             next
[17:46:48.544]                           if (!grepl(pattern, name)) 
[17:46:48.544]                             next
[17:46:48.544]                           invokeRestart(restart)
[17:46:48.544]                           muffled <- TRUE
[17:46:48.544]                           break
[17:46:48.544]                         }
[17:46:48.544]                       }
[17:46:48.544]                     }
[17:46:48.544]                     invisible(muffled)
[17:46:48.544]                   }
[17:46:48.544]                   muffleCondition(cond)
[17:46:48.544]                 })
[17:46:48.544]             }))
[17:46:48.544]             future::FutureResult(value = ...future.value$value, 
[17:46:48.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.544]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.544]                     ...future.globalenv.names))
[17:46:48.544]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.544]         }, condition = base::local({
[17:46:48.544]             c <- base::c
[17:46:48.544]             inherits <- base::inherits
[17:46:48.544]             invokeRestart <- base::invokeRestart
[17:46:48.544]             length <- base::length
[17:46:48.544]             list <- base::list
[17:46:48.544]             seq.int <- base::seq.int
[17:46:48.544]             signalCondition <- base::signalCondition
[17:46:48.544]             sys.calls <- base::sys.calls
[17:46:48.544]             `[[` <- base::`[[`
[17:46:48.544]             `+` <- base::`+`
[17:46:48.544]             `<<-` <- base::`<<-`
[17:46:48.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.544]                   3L)]
[17:46:48.544]             }
[17:46:48.544]             function(cond) {
[17:46:48.544]                 is_error <- inherits(cond, "error")
[17:46:48.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.544]                   NULL)
[17:46:48.544]                 if (is_error) {
[17:46:48.544]                   sessionInformation <- function() {
[17:46:48.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.544]                       search = base::search(), system = base::Sys.info())
[17:46:48.544]                   }
[17:46:48.544]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.544]                     cond$call), session = sessionInformation(), 
[17:46:48.544]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.544]                   signalCondition(cond)
[17:46:48.544]                 }
[17:46:48.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.544]                 "immediateCondition"))) {
[17:46:48.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.544]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.544]                   if (TRUE && !signal) {
[17:46:48.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.544]                     {
[17:46:48.544]                       inherits <- base::inherits
[17:46:48.544]                       invokeRestart <- base::invokeRestart
[17:46:48.544]                       is.null <- base::is.null
[17:46:48.544]                       muffled <- FALSE
[17:46:48.544]                       if (inherits(cond, "message")) {
[17:46:48.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.544]                         if (muffled) 
[17:46:48.544]                           invokeRestart("muffleMessage")
[17:46:48.544]                       }
[17:46:48.544]                       else if (inherits(cond, "warning")) {
[17:46:48.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.544]                         if (muffled) 
[17:46:48.544]                           invokeRestart("muffleWarning")
[17:46:48.544]                       }
[17:46:48.544]                       else if (inherits(cond, "condition")) {
[17:46:48.544]                         if (!is.null(pattern)) {
[17:46:48.544]                           computeRestarts <- base::computeRestarts
[17:46:48.544]                           grepl <- base::grepl
[17:46:48.544]                           restarts <- computeRestarts(cond)
[17:46:48.544]                           for (restart in restarts) {
[17:46:48.544]                             name <- restart$name
[17:46:48.544]                             if (is.null(name)) 
[17:46:48.544]                               next
[17:46:48.544]                             if (!grepl(pattern, name)) 
[17:46:48.544]                               next
[17:46:48.544]                             invokeRestart(restart)
[17:46:48.544]                             muffled <- TRUE
[17:46:48.544]                             break
[17:46:48.544]                           }
[17:46:48.544]                         }
[17:46:48.544]                       }
[17:46:48.544]                       invisible(muffled)
[17:46:48.544]                     }
[17:46:48.544]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.544]                   }
[17:46:48.544]                 }
[17:46:48.544]                 else {
[17:46:48.544]                   if (TRUE) {
[17:46:48.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.544]                     {
[17:46:48.544]                       inherits <- base::inherits
[17:46:48.544]                       invokeRestart <- base::invokeRestart
[17:46:48.544]                       is.null <- base::is.null
[17:46:48.544]                       muffled <- FALSE
[17:46:48.544]                       if (inherits(cond, "message")) {
[17:46:48.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.544]                         if (muffled) 
[17:46:48.544]                           invokeRestart("muffleMessage")
[17:46:48.544]                       }
[17:46:48.544]                       else if (inherits(cond, "warning")) {
[17:46:48.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.544]                         if (muffled) 
[17:46:48.544]                           invokeRestart("muffleWarning")
[17:46:48.544]                       }
[17:46:48.544]                       else if (inherits(cond, "condition")) {
[17:46:48.544]                         if (!is.null(pattern)) {
[17:46:48.544]                           computeRestarts <- base::computeRestarts
[17:46:48.544]                           grepl <- base::grepl
[17:46:48.544]                           restarts <- computeRestarts(cond)
[17:46:48.544]                           for (restart in restarts) {
[17:46:48.544]                             name <- restart$name
[17:46:48.544]                             if (is.null(name)) 
[17:46:48.544]                               next
[17:46:48.544]                             if (!grepl(pattern, name)) 
[17:46:48.544]                               next
[17:46:48.544]                             invokeRestart(restart)
[17:46:48.544]                             muffled <- TRUE
[17:46:48.544]                             break
[17:46:48.544]                           }
[17:46:48.544]                         }
[17:46:48.544]                       }
[17:46:48.544]                       invisible(muffled)
[17:46:48.544]                     }
[17:46:48.544]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.544]                   }
[17:46:48.544]                 }
[17:46:48.544]             }
[17:46:48.544]         }))
[17:46:48.544]     }, error = function(ex) {
[17:46:48.544]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.544]                 ...future.rng), started = ...future.startTime, 
[17:46:48.544]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.544]             version = "1.8"), class = "FutureResult")
[17:46:48.544]     }, finally = {
[17:46:48.544]         if (!identical(...future.workdir, getwd())) 
[17:46:48.544]             setwd(...future.workdir)
[17:46:48.544]         {
[17:46:48.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.544]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.544]             }
[17:46:48.544]             base::options(...future.oldOptions)
[17:46:48.544]             if (.Platform$OS.type == "windows") {
[17:46:48.544]                 old_names <- names(...future.oldEnvVars)
[17:46:48.544]                 envs <- base::Sys.getenv()
[17:46:48.544]                 names <- names(envs)
[17:46:48.544]                 common <- intersect(names, old_names)
[17:46:48.544]                 added <- setdiff(names, old_names)
[17:46:48.544]                 removed <- setdiff(old_names, names)
[17:46:48.544]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.544]                   envs[common]]
[17:46:48.544]                 NAMES <- toupper(changed)
[17:46:48.544]                 args <- list()
[17:46:48.544]                 for (kk in seq_along(NAMES)) {
[17:46:48.544]                   name <- changed[[kk]]
[17:46:48.544]                   NAME <- NAMES[[kk]]
[17:46:48.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.544]                     next
[17:46:48.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.544]                 }
[17:46:48.544]                 NAMES <- toupper(added)
[17:46:48.544]                 for (kk in seq_along(NAMES)) {
[17:46:48.544]                   name <- added[[kk]]
[17:46:48.544]                   NAME <- NAMES[[kk]]
[17:46:48.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.544]                     next
[17:46:48.544]                   args[[name]] <- ""
[17:46:48.544]                 }
[17:46:48.544]                 NAMES <- toupper(removed)
[17:46:48.544]                 for (kk in seq_along(NAMES)) {
[17:46:48.544]                   name <- removed[[kk]]
[17:46:48.544]                   NAME <- NAMES[[kk]]
[17:46:48.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.544]                     next
[17:46:48.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.544]                 }
[17:46:48.544]                 if (length(args) > 0) 
[17:46:48.544]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.544]             }
[17:46:48.544]             else {
[17:46:48.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.544]             }
[17:46:48.544]             {
[17:46:48.544]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.544]                   0L) {
[17:46:48.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.544]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.544]                   base::options(opts)
[17:46:48.544]                 }
[17:46:48.544]                 {
[17:46:48.544]                   {
[17:46:48.544]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.544]                     NULL
[17:46:48.544]                   }
[17:46:48.544]                   options(future.plan = NULL)
[17:46:48.544]                   if (is.na(NA_character_)) 
[17:46:48.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.544]                     .init = FALSE)
[17:46:48.544]                 }
[17:46:48.544]             }
[17:46:48.544]         }
[17:46:48.544]     })
[17:46:48.544]     if (TRUE) {
[17:46:48.544]         base::sink(type = "output", split = FALSE)
[17:46:48.544]         if (TRUE) {
[17:46:48.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.544]         }
[17:46:48.544]         else {
[17:46:48.544]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.544]         }
[17:46:48.544]         base::close(...future.stdout)
[17:46:48.544]         ...future.stdout <- NULL
[17:46:48.544]     }
[17:46:48.544]     ...future.result$conditions <- ...future.conditions
[17:46:48.544]     ...future.result$finished <- base::Sys.time()
[17:46:48.544]     ...future.result
[17:46:48.544] }
[17:46:48.548] requestCore(): workers = 2
[17:46:48.551] MulticoreFuture started
[17:46:48.551] - Launch lazy future ... done
[17:46:48.551] run() for ‘MulticoreFuture’ ... done
[17:46:48.552] plan(): Setting new future strategy stack:
[17:46:48.552] getGlobalsAndPackages() ...
[17:46:48.552] Searching for globals...
[17:46:48.552] List of future strategies:
[17:46:48.552] 1. sequential:
[17:46:48.552]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.552]    - tweaked: FALSE
[17:46:48.552]    - call: NULL
[17:46:48.553] plan(): nbrOfWorkers() = 1
[17:46:48.554] - globals found: [1] ‘{’
[17:46:48.554] Searching for globals ... DONE
[17:46:48.554] Resolving globals: FALSE
[17:46:48.555] 
[17:46:48.555] 
[17:46:48.555] getGlobalsAndPackages() ... DONE
[17:46:48.555] plan(): Setting new future strategy stack:
[17:46:48.555] run() for ‘Future’ ...
[17:46:48.556] - state: ‘created’
[17:46:48.555] List of future strategies:
[17:46:48.555] 1. multicore:
[17:46:48.555]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.555]    - tweaked: FALSE
[17:46:48.555]    - call: plan(strategy)
[17:46:48.556] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:48.561] plan(): nbrOfWorkers() = 2
[17:46:48.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:48.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:48.561]   - Field: ‘label’
[17:46:48.561]   - Field: ‘local’
[17:46:48.561]   - Field: ‘owner’
[17:46:48.562]   - Field: ‘envir’
[17:46:48.562]   - Field: ‘workers’
[17:46:48.562]   - Field: ‘packages’
[17:46:48.562]   - Field: ‘gc’
[17:46:48.562]   - Field: ‘job’
[17:46:48.562]   - Field: ‘conditions’
[17:46:48.562]   - Field: ‘expr’
[17:46:48.562]   - Field: ‘uuid’
[17:46:48.563]   - Field: ‘seed’
[17:46:48.563]   - Field: ‘version’
[17:46:48.563]   - Field: ‘result’
[17:46:48.563]   - Field: ‘asynchronous’
[17:46:48.563]   - Field: ‘calls’
[17:46:48.563]   - Field: ‘globals’
[17:46:48.563]   - Field: ‘stdout’
[17:46:48.564]   - Field: ‘earlySignal’
[17:46:48.564]   - Field: ‘lazy’
[17:46:48.564]   - Field: ‘state’
[17:46:48.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:48.564] - Launch lazy future ...
[17:46:48.565] Packages needed by the future expression (n = 0): <none>
[17:46:48.565] Packages needed by future strategies (n = 0): <none>
[17:46:48.565] {
[17:46:48.565]     {
[17:46:48.565]         {
[17:46:48.565]             ...future.startTime <- base::Sys.time()
[17:46:48.565]             {
[17:46:48.565]                 {
[17:46:48.565]                   {
[17:46:48.565]                     {
[17:46:48.565]                       base::local({
[17:46:48.565]                         has_future <- base::requireNamespace("future", 
[17:46:48.565]                           quietly = TRUE)
[17:46:48.565]                         if (has_future) {
[17:46:48.565]                           ns <- base::getNamespace("future")
[17:46:48.565]                           version <- ns[[".package"]][["version"]]
[17:46:48.565]                           if (is.null(version)) 
[17:46:48.565]                             version <- utils::packageVersion("future")
[17:46:48.565]                         }
[17:46:48.565]                         else {
[17:46:48.565]                           version <- NULL
[17:46:48.565]                         }
[17:46:48.565]                         if (!has_future || version < "1.8.0") {
[17:46:48.565]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.565]                             "", base::R.version$version.string), 
[17:46:48.565]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.565]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.565]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.565]                               "release", "version")], collapse = " "), 
[17:46:48.565]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.565]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.565]                             info)
[17:46:48.565]                           info <- base::paste(info, collapse = "; ")
[17:46:48.565]                           if (!has_future) {
[17:46:48.565]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.565]                               info)
[17:46:48.565]                           }
[17:46:48.565]                           else {
[17:46:48.565]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.565]                               info, version)
[17:46:48.565]                           }
[17:46:48.565]                           base::stop(msg)
[17:46:48.565]                         }
[17:46:48.565]                       })
[17:46:48.565]                     }
[17:46:48.565]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.565]                     base::options(mc.cores = 1L)
[17:46:48.565]                   }
[17:46:48.565]                   ...future.strategy.old <- future::plan("list")
[17:46:48.565]                   options(future.plan = NULL)
[17:46:48.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.565]                 }
[17:46:48.565]                 ...future.workdir <- getwd()
[17:46:48.565]             }
[17:46:48.565]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.565]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.565]         }
[17:46:48.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.565]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.565]             base::names(...future.oldOptions))
[17:46:48.565]     }
[17:46:48.565]     if (FALSE) {
[17:46:48.565]     }
[17:46:48.565]     else {
[17:46:48.565]         if (TRUE) {
[17:46:48.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.565]                 open = "w")
[17:46:48.565]         }
[17:46:48.565]         else {
[17:46:48.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.565]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.565]         }
[17:46:48.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.565]             base::sink(type = "output", split = FALSE)
[17:46:48.565]             base::close(...future.stdout)
[17:46:48.565]         }, add = TRUE)
[17:46:48.565]     }
[17:46:48.565]     ...future.frame <- base::sys.nframe()
[17:46:48.565]     ...future.conditions <- base::list()
[17:46:48.565]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.565]     if (FALSE) {
[17:46:48.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.565]     }
[17:46:48.565]     ...future.result <- base::tryCatch({
[17:46:48.565]         base::withCallingHandlers({
[17:46:48.565]             ...future.value <- base::withVisible(base::local({
[17:46:48.565]                 withCallingHandlers({
[17:46:48.565]                   {
[17:46:48.565]                     4
[17:46:48.565]                   }
[17:46:48.565]                 }, immediateCondition = function(cond) {
[17:46:48.565]                   save_rds <- function (object, pathname, ...) 
[17:46:48.565]                   {
[17:46:48.565]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:48.565]                     if (file_test("-f", pathname_tmp)) {
[17:46:48.565]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.565]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:48.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.565]                         fi_tmp[["mtime"]])
[17:46:48.565]                     }
[17:46:48.565]                     tryCatch({
[17:46:48.565]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:48.565]                     }, error = function(ex) {
[17:46:48.565]                       msg <- conditionMessage(ex)
[17:46:48.565]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.565]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:48.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.565]                         fi_tmp[["mtime"]], msg)
[17:46:48.565]                       ex$message <- msg
[17:46:48.565]                       stop(ex)
[17:46:48.565]                     })
[17:46:48.565]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:48.565]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:48.565]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:48.565]                       fi_tmp <- file.info(pathname_tmp)
[17:46:48.565]                       fi <- file.info(pathname)
[17:46:48.565]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:48.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:48.565]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:48.565]                         fi[["size"]], fi[["mtime"]])
[17:46:48.565]                       stop(msg)
[17:46:48.565]                     }
[17:46:48.565]                     invisible(pathname)
[17:46:48.565]                   }
[17:46:48.565]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:48.565]                     rootPath = tempdir()) 
[17:46:48.565]                   {
[17:46:48.565]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:48.565]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:48.565]                       tmpdir = path, fileext = ".rds")
[17:46:48.565]                     save_rds(obj, file)
[17:46:48.565]                   }
[17:46:48.565]                   saveImmediateCondition(cond, path = "/tmp/RtmpPcSNBB/.future/immediateConditions")
[17:46:48.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.565]                   {
[17:46:48.565]                     inherits <- base::inherits
[17:46:48.565]                     invokeRestart <- base::invokeRestart
[17:46:48.565]                     is.null <- base::is.null
[17:46:48.565]                     muffled <- FALSE
[17:46:48.565]                     if (inherits(cond, "message")) {
[17:46:48.565]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.565]                       if (muffled) 
[17:46:48.565]                         invokeRestart("muffleMessage")
[17:46:48.565]                     }
[17:46:48.565]                     else if (inherits(cond, "warning")) {
[17:46:48.565]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.565]                       if (muffled) 
[17:46:48.565]                         invokeRestart("muffleWarning")
[17:46:48.565]                     }
[17:46:48.565]                     else if (inherits(cond, "condition")) {
[17:46:48.565]                       if (!is.null(pattern)) {
[17:46:48.565]                         computeRestarts <- base::computeRestarts
[17:46:48.565]                         grepl <- base::grepl
[17:46:48.565]                         restarts <- computeRestarts(cond)
[17:46:48.565]                         for (restart in restarts) {
[17:46:48.565]                           name <- restart$name
[17:46:48.565]                           if (is.null(name)) 
[17:46:48.565]                             next
[17:46:48.565]                           if (!grepl(pattern, name)) 
[17:46:48.565]                             next
[17:46:48.565]                           invokeRestart(restart)
[17:46:48.565]                           muffled <- TRUE
[17:46:48.565]                           break
[17:46:48.565]                         }
[17:46:48.565]                       }
[17:46:48.565]                     }
[17:46:48.565]                     invisible(muffled)
[17:46:48.565]                   }
[17:46:48.565]                   muffleCondition(cond)
[17:46:48.565]                 })
[17:46:48.565]             }))
[17:46:48.565]             future::FutureResult(value = ...future.value$value, 
[17:46:48.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.565]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.565]                     ...future.globalenv.names))
[17:46:48.565]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.565]         }, condition = base::local({
[17:46:48.565]             c <- base::c
[17:46:48.565]             inherits <- base::inherits
[17:46:48.565]             invokeRestart <- base::invokeRestart
[17:46:48.565]             length <- base::length
[17:46:48.565]             list <- base::list
[17:46:48.565]             seq.int <- base::seq.int
[17:46:48.565]             signalCondition <- base::signalCondition
[17:46:48.565]             sys.calls <- base::sys.calls
[17:46:48.565]             `[[` <- base::`[[`
[17:46:48.565]             `+` <- base::`+`
[17:46:48.565]             `<<-` <- base::`<<-`
[17:46:48.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.565]                   3L)]
[17:46:48.565]             }
[17:46:48.565]             function(cond) {
[17:46:48.565]                 is_error <- inherits(cond, "error")
[17:46:48.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.565]                   NULL)
[17:46:48.565]                 if (is_error) {
[17:46:48.565]                   sessionInformation <- function() {
[17:46:48.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.565]                       search = base::search(), system = base::Sys.info())
[17:46:48.565]                   }
[17:46:48.565]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.565]                     cond$call), session = sessionInformation(), 
[17:46:48.565]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.565]                   signalCondition(cond)
[17:46:48.565]                 }
[17:46:48.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.565]                 "immediateCondition"))) {
[17:46:48.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.565]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.565]                   if (TRUE && !signal) {
[17:46:48.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.565]                     {
[17:46:48.565]                       inherits <- base::inherits
[17:46:48.565]                       invokeRestart <- base::invokeRestart
[17:46:48.565]                       is.null <- base::is.null
[17:46:48.565]                       muffled <- FALSE
[17:46:48.565]                       if (inherits(cond, "message")) {
[17:46:48.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.565]                         if (muffled) 
[17:46:48.565]                           invokeRestart("muffleMessage")
[17:46:48.565]                       }
[17:46:48.565]                       else if (inherits(cond, "warning")) {
[17:46:48.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.565]                         if (muffled) 
[17:46:48.565]                           invokeRestart("muffleWarning")
[17:46:48.565]                       }
[17:46:48.565]                       else if (inherits(cond, "condition")) {
[17:46:48.565]                         if (!is.null(pattern)) {
[17:46:48.565]                           computeRestarts <- base::computeRestarts
[17:46:48.565]                           grepl <- base::grepl
[17:46:48.565]                           restarts <- computeRestarts(cond)
[17:46:48.565]                           for (restart in restarts) {
[17:46:48.565]                             name <- restart$name
[17:46:48.565]                             if (is.null(name)) 
[17:46:48.565]                               next
[17:46:48.565]                             if (!grepl(pattern, name)) 
[17:46:48.565]                               next
[17:46:48.565]                             invokeRestart(restart)
[17:46:48.565]                             muffled <- TRUE
[17:46:48.565]                             break
[17:46:48.565]                           }
[17:46:48.565]                         }
[17:46:48.565]                       }
[17:46:48.565]                       invisible(muffled)
[17:46:48.565]                     }
[17:46:48.565]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.565]                   }
[17:46:48.565]                 }
[17:46:48.565]                 else {
[17:46:48.565]                   if (TRUE) {
[17:46:48.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.565]                     {
[17:46:48.565]                       inherits <- base::inherits
[17:46:48.565]                       invokeRestart <- base::invokeRestart
[17:46:48.565]                       is.null <- base::is.null
[17:46:48.565]                       muffled <- FALSE
[17:46:48.565]                       if (inherits(cond, "message")) {
[17:46:48.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.565]                         if (muffled) 
[17:46:48.565]                           invokeRestart("muffleMessage")
[17:46:48.565]                       }
[17:46:48.565]                       else if (inherits(cond, "warning")) {
[17:46:48.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.565]                         if (muffled) 
[17:46:48.565]                           invokeRestart("muffleWarning")
[17:46:48.565]                       }
[17:46:48.565]                       else if (inherits(cond, "condition")) {
[17:46:48.565]                         if (!is.null(pattern)) {
[17:46:48.565]                           computeRestarts <- base::computeRestarts
[17:46:48.565]                           grepl <- base::grepl
[17:46:48.565]                           restarts <- computeRestarts(cond)
[17:46:48.565]                           for (restart in restarts) {
[17:46:48.565]                             name <- restart$name
[17:46:48.565]                             if (is.null(name)) 
[17:46:48.565]                               next
[17:46:48.565]                             if (!grepl(pattern, name)) 
[17:46:48.565]                               next
[17:46:48.565]                             invokeRestart(restart)
[17:46:48.565]                             muffled <- TRUE
[17:46:48.565]                             break
[17:46:48.565]                           }
[17:46:48.565]                         }
[17:46:48.565]                       }
[17:46:48.565]                       invisible(muffled)
[17:46:48.565]                     }
[17:46:48.565]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.565]                   }
[17:46:48.565]                 }
[17:46:48.565]             }
[17:46:48.565]         }))
[17:46:48.565]     }, error = function(ex) {
[17:46:48.565]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.565]                 ...future.rng), started = ...future.startTime, 
[17:46:48.565]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.565]             version = "1.8"), class = "FutureResult")
[17:46:48.565]     }, finally = {
[17:46:48.565]         if (!identical(...future.workdir, getwd())) 
[17:46:48.565]             setwd(...future.workdir)
[17:46:48.565]         {
[17:46:48.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.565]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.565]             }
[17:46:48.565]             base::options(...future.oldOptions)
[17:46:48.565]             if (.Platform$OS.type == "windows") {
[17:46:48.565]                 old_names <- names(...future.oldEnvVars)
[17:46:48.565]                 envs <- base::Sys.getenv()
[17:46:48.565]                 names <- names(envs)
[17:46:48.565]                 common <- intersect(names, old_names)
[17:46:48.565]                 added <- setdiff(names, old_names)
[17:46:48.565]                 removed <- setdiff(old_names, names)
[17:46:48.565]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.565]                   envs[common]]
[17:46:48.565]                 NAMES <- toupper(changed)
[17:46:48.565]                 args <- list()
[17:46:48.565]                 for (kk in seq_along(NAMES)) {
[17:46:48.565]                   name <- changed[[kk]]
[17:46:48.565]                   NAME <- NAMES[[kk]]
[17:46:48.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.565]                     next
[17:46:48.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.565]                 }
[17:46:48.565]                 NAMES <- toupper(added)
[17:46:48.565]                 for (kk in seq_along(NAMES)) {
[17:46:48.565]                   name <- added[[kk]]
[17:46:48.565]                   NAME <- NAMES[[kk]]
[17:46:48.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.565]                     next
[17:46:48.565]                   args[[name]] <- ""
[17:46:48.565]                 }
[17:46:48.565]                 NAMES <- toupper(removed)
[17:46:48.565]                 for (kk in seq_along(NAMES)) {
[17:46:48.565]                   name <- removed[[kk]]
[17:46:48.565]                   NAME <- NAMES[[kk]]
[17:46:48.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.565]                     next
[17:46:48.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.565]                 }
[17:46:48.565]                 if (length(args) > 0) 
[17:46:48.565]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.565]             }
[17:46:48.565]             else {
[17:46:48.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.565]             }
[17:46:48.565]             {
[17:46:48.565]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.565]                   0L) {
[17:46:48.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.565]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.565]                   base::options(opts)
[17:46:48.565]                 }
[17:46:48.565]                 {
[17:46:48.565]                   {
[17:46:48.565]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.565]                     NULL
[17:46:48.565]                   }
[17:46:48.565]                   options(future.plan = NULL)
[17:46:48.565]                   if (is.na(NA_character_)) 
[17:46:48.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.565]                     .init = FALSE)
[17:46:48.565]                 }
[17:46:48.565]             }
[17:46:48.565]         }
[17:46:48.565]     })
[17:46:48.565]     if (TRUE) {
[17:46:48.565]         base::sink(type = "output", split = FALSE)
[17:46:48.565]         if (TRUE) {
[17:46:48.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.565]         }
[17:46:48.565]         else {
[17:46:48.565]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.565]         }
[17:46:48.565]         base::close(...future.stdout)
[17:46:48.565]         ...future.stdout <- NULL
[17:46:48.565]     }
[17:46:48.565]     ...future.result$conditions <- ...future.conditions
[17:46:48.565]     ...future.result$finished <- base::Sys.time()
[17:46:48.565]     ...future.result
[17:46:48.565] }
[17:46:48.569] requestCore(): workers = 2
[17:46:48.569] Poll #1 (0): usedCores() = 2, workers = 2
[17:46:48.580] result() for MulticoreFuture ...
[17:46:48.581] result() for MulticoreFuture ...
[17:46:48.581] result() for MulticoreFuture ... done
[17:46:48.581] result() for MulticoreFuture ... done
[17:46:48.582] result() for MulticoreFuture ...
[17:46:48.582] result() for MulticoreFuture ... done
[17:46:48.584] MulticoreFuture started
[17:46:48.585] - Launch lazy future ... done
[17:46:48.585] run() for ‘MulticoreFuture’ ... done
[17:46:48.586] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5617856db678> 
[17:46:48.586] List of future strategies:
[17:46:48.586] 1. sequential:
[17:46:48.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:48.586]    - tweaked: FALSE
[17:46:48.586]    - call: NULL
[17:46:48.587] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x56178944a008> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[17:46:48.590] plan(): Setting new future strategy stack:
List of 4
  ..$ :[17:46:48.590] List of future strategies:
[17:46:48.590] 1. multicore:
[17:46:48.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:48.590]    - tweaked: FALSE
[17:46:48.590]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:48.596] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:48.601] resolve() on list environment ...
[17:46:48.601]  recursive: 0
[17:46:48.602]  length: 6
[17:46:48.602]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:48.602] signalConditionsASAP(numeric, pos=1) ...
[17:46:48.603] - nx: 6
[17:46:48.603] - relay: TRUE
[17:46:48.603] - stdout: TRUE
[17:46:48.603] - signal: TRUE
[17:46:48.603] - resignal: FALSE
[17:46:48.603] - force: TRUE
[17:46:48.603] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.604] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.604]  - until=2
[17:46:48.604]  - relaying element #2
[17:46:48.604] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.604] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.604] signalConditionsASAP(NULL, pos=1) ... done
[17:46:48.604]  length: 5 (resolved future 1)
[17:46:48.604] Future #2
[17:46:48.605] result() for MulticoreFuture ...
[17:46:48.605] result() for MulticoreFuture ... done
[17:46:48.605] result() for MulticoreFuture ...
[17:46:48.605] result() for MulticoreFuture ... done
[17:46:48.605] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:46:48.605] - nx: 6
[17:46:48.605] - relay: TRUE
[17:46:48.606] - stdout: TRUE
[17:46:48.606] - signal: TRUE
[17:46:48.606] - resignal: FALSE
[17:46:48.606] - force: TRUE
[17:46:48.606] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.606] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:48.606]  - until=2
[17:46:48.606]  - relaying element #2
[17:46:48.607] result() for MulticoreFuture ...
[17:46:48.607] result() for MulticoreFuture ... done
[17:46:48.607] result() for MulticoreFuture ...
[17:46:48.607] result() for MulticoreFuture ... done
[17:46:48.607] result() for MulticoreFuture ...
[17:46:48.607] result() for MulticoreFuture ... done
[17:46:48.607] result() for MulticoreFuture ...
[17:46:48.607] result() for MulticoreFuture ... done
[17:46:48.608] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.608] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.608] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:46:48.608]  length: 4 (resolved future 2)
[17:46:48.608] Future #3
[17:46:48.609] result() for MulticoreFuture ...
[17:46:48.609] result() for MulticoreFuture ...
[17:46:48.610] result() for MulticoreFuture ... done
[17:46:48.610] result() for MulticoreFuture ... done
[17:46:48.610] result() for MulticoreFuture ...
[17:46:48.610] result() for MulticoreFuture ... done
[17:46:48.610] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:46:48.610] - nx: 6
[17:46:48.610] - relay: TRUE
[17:46:48.610] - stdout: TRUE
[17:46:48.611] - signal: TRUE
[17:46:48.611] - resignal: FALSE
[17:46:48.611] - force: TRUE
[17:46:48.611] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.611] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:48.611]  - until=3
[17:46:48.611]  - relaying element #3
[17:46:48.611] result() for MulticoreFuture ...
[17:46:48.612] result() for MulticoreFuture ... done
[17:46:48.612] result() for MulticoreFuture ...
[17:46:48.612] result() for MulticoreFuture ... done
[17:46:48.612] result() for MulticoreFuture ...
[17:46:48.612] result() for MulticoreFuture ... done
[17:46:48.612] result() for MulticoreFuture ...
[17:46:48.612] result() for MulticoreFuture ... done
[17:46:48.612] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.613] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.613] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:46:48.613]  length: 3 (resolved future 3)
[17:46:48.613] Future #4
[17:46:48.613] result() for MulticoreFuture ...
[17:46:48.614] result() for MulticoreFuture ...
[17:46:48.614] result() for MulticoreFuture ... done
[17:46:48.614] result() for MulticoreFuture ... done
[17:46:48.615] result() for MulticoreFuture ...
[17:46:48.615] result() for MulticoreFuture ... done
[17:46:48.615] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:46:48.615] - nx: 6
[17:46:48.615] - relay: TRUE
[17:46:48.615] - stdout: TRUE
[17:46:48.616] - signal: TRUE
[17:46:48.616] - resignal: FALSE
[17:46:48.616] - force: TRUE
[17:46:48.616] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.616] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:48.616]  - until=4
[17:46:48.617]  - relaying element #4
[17:46:48.617] result() for MulticoreFuture ...
[17:46:48.617] result() for MulticoreFuture ... done
[17:46:48.621] result() for MulticoreFuture ...
[17:46:48.621] result() for MulticoreFuture ... done
[17:46:48.622] result() for MulticoreFuture ...
[17:46:48.622] result() for MulticoreFuture ... done
[17:46:48.622] result() for MulticoreFuture ...
[17:46:48.622] result() for MulticoreFuture ... done
[17:46:48.623] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.623] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.623] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:46:48.623]  length: 2 (resolved future 4)
[17:46:48.623] signalConditionsASAP(NULL, pos=5) ...
[17:46:48.623] - nx: 6
[17:46:48.623] - relay: TRUE
[17:46:48.624] - stdout: TRUE
[17:46:48.624] - signal: TRUE
[17:46:48.624] - resignal: FALSE
[17:46:48.624] - force: TRUE
[17:46:48.624] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.624] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.624]  - until=6
[17:46:48.624]  - relaying element #6
[17:46:48.624] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.625] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.625] signalConditionsASAP(NULL, pos=5) ... done
[17:46:48.625]  length: 1 (resolved future 5)
[17:46:48.625] signalConditionsASAP(numeric, pos=6) ...
[17:46:48.625] - nx: 6
[17:46:48.625] - relay: TRUE
[17:46:48.625] - stdout: TRUE
[17:46:48.625] - signal: TRUE
[17:46:48.625] - resignal: FALSE
[17:46:48.625] - force: TRUE
[17:46:48.626] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:48.626] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.626]  - until=6
[17:46:48.626] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.626] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.626] signalConditionsASAP(numeric, pos=6) ... done
[17:46:48.626]  length: 0 (resolved future 6)
[17:46:48.626] Relaying remaining futures
[17:46:48.626] signalConditionsASAP(NULL, pos=0) ...
[17:46:48.626] - nx: 6
[17:46:48.627] - relay: TRUE
[17:46:48.627] - stdout: TRUE
[17:46:48.627] - signal: TRUE
[17:46:48.627] - resignal: FALSE
[17:46:48.627] - force: TRUE
[17:46:48.627] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.627] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:48.627] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:48.627] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:48.628] signalConditionsASAP(NULL, pos=0) ... done
[17:46:48.628] resolve() on list environment ... DONE
[17:46:48.628] result() for MulticoreFuture ...
[17:46:48.628] result() for MulticoreFuture ... done
[17:46:48.628] result() for MulticoreFuture ...
[17:46:48.628] result() for MulticoreFuture ... done
[17:46:48.628] result() for MulticoreFuture ...
[17:46:48.628] result() for MulticoreFuture ... done
[17:46:48.628] result() for MulticoreFuture ...
[17:46:48.629] result() for MulticoreFuture ... done
[17:46:48.629] result() for MulticoreFuture ...
[17:46:48.629] result() for MulticoreFuture ... done
[17:46:48.629] result() for MulticoreFuture ...
[17:46:48.629] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5617897c99f8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:46:48.632] plan(): Setting new future strategy stack:
[17:46:48.632] List of future strategies:
[17:46:48.632] 1. multisession:
[17:46:48.632]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:48.632]    - tweaked: FALSE
[17:46:48.632]    - call: plan(strategy)
[17:46:48.632] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:46:48.632] multisession:
[17:46:48.632] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:48.632] - tweaked: FALSE
[17:46:48.632] - call: plan(strategy)
[17:46:48.636] getGlobalsAndPackages() ...
[17:46:48.637] Not searching for globals
[17:46:48.637] - globals: [0] <none>
[17:46:48.637] getGlobalsAndPackages() ... DONE
[17:46:48.637] [local output] makeClusterPSOCK() ...
[17:46:48.641] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:46:48.641] [local output] Base port: 11723
[17:46:48.641] [local output] Getting setup options for 2 cluster nodes ...
[17:46:48.641] [local output]  - Node 1 of 2 ...
[17:46:48.642] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:48.642] [local output] Rscript port: 11723

[17:46:48.643] [local output]  - Node 2 of 2 ...
[17:46:48.643] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:48.644] [local output] Rscript port: 11723

[17:46:48.644] [local output] Getting setup options for 2 cluster nodes ... done
[17:46:48.644] [local output]  - Parallel setup requested for some PSOCK nodes
[17:46:48.645] [local output] Setting up PSOCK nodes in parallel
[17:46:48.645] List of 36
[17:46:48.645]  $ worker          : chr "localhost"
[17:46:48.645]   ..- attr(*, "localhost")= logi TRUE
[17:46:48.645]  $ master          : chr "localhost"
[17:46:48.645]  $ port            : int 11723
[17:46:48.645]  $ connectTimeout  : num 120
[17:46:48.645]  $ timeout         : num 2592000
[17:46:48.645]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:46:48.645]  $ homogeneous     : logi TRUE
[17:46:48.645]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:46:48.645]  $ rscript_envs    : NULL
[17:46:48.645]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:48.645]  $ rscript_startup : NULL
[17:46:48.645]  $ rscript_sh      : chr "sh"
[17:46:48.645]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:48.645]  $ methods         : logi TRUE
[17:46:48.645]  $ socketOptions   : chr "no-delay"
[17:46:48.645]  $ useXDR          : logi FALSE
[17:46:48.645]  $ outfile         : chr "/dev/null"
[17:46:48.645]  $ renice          : int NA
[17:46:48.645]  $ rshcmd          : NULL
[17:46:48.645]  $ user            : chr(0) 
[17:46:48.645]  $ revtunnel       : logi FALSE
[17:46:48.645]  $ rshlogfile      : NULL
[17:46:48.645]  $ rshopts         : chr(0) 
[17:46:48.645]  $ rank            : int 1
[17:46:48.645]  $ manual          : logi FALSE
[17:46:48.645]  $ dryrun          : logi FALSE
[17:46:48.645]  $ quiet           : logi FALSE
[17:46:48.645]  $ setup_strategy  : chr "parallel"
[17:46:48.645]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:48.645]  $ pidfile         : chr "/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a4748780132.pid"
[17:46:48.645]  $ rshcmd_label    : NULL
[17:46:48.645]  $ rsh_call        : NULL
[17:46:48.645]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:48.645]  $ localMachine    : logi TRUE
[17:46:48.645]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:46:48.645]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:46:48.645]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:46:48.645]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:46:48.645]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:46:48.645]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:46:48.645]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:46:48.645]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:46:48.645]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:46:48.645]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:46:48.645]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:46:48.645]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:46:48.645]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:46:48.645]  $ arguments       :List of 28
[17:46:48.645]   ..$ worker          : chr "localhost"
[17:46:48.645]   ..$ master          : NULL
[17:46:48.645]   ..$ port            : int 11723
[17:46:48.645]   ..$ connectTimeout  : num 120
[17:46:48.645]   ..$ timeout         : num 2592000
[17:46:48.645]   ..$ rscript         : NULL
[17:46:48.645]   ..$ homogeneous     : NULL
[17:46:48.645]   ..$ rscript_args    : NULL
[17:46:48.645]   ..$ rscript_envs    : NULL
[17:46:48.645]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:48.645]   ..$ rscript_startup : NULL
[17:46:48.645]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:46:48.645]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:48.645]   ..$ methods         : logi TRUE
[17:46:48.645]   ..$ socketOptions   : chr "no-delay"
[17:46:48.645]   ..$ useXDR          : logi FALSE
[17:46:48.645]   ..$ outfile         : chr "/dev/null"
[17:46:48.645]   ..$ renice          : int NA
[17:46:48.645]   ..$ rshcmd          : NULL
[17:46:48.645]   ..$ user            : NULL
[17:46:48.645]   ..$ revtunnel       : logi NA
[17:46:48.645]   ..$ rshlogfile      : NULL
[17:46:48.645]   ..$ rshopts         : NULL
[17:46:48.645]   ..$ rank            : int 1
[17:46:48.645]   ..$ manual          : logi FALSE
[17:46:48.645]   ..$ dryrun          : logi FALSE
[17:46:48.645]   ..$ quiet           : logi FALSE
[17:46:48.645]   ..$ setup_strategy  : chr "parallel"
[17:46:48.645]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:46:48.664] [local output] System call to launch all workers:
[17:46:48.664] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPcSNBB/worker.rank=1.parallelly.parent=42100.a4748780132.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11723 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:46:48.664] [local output] Starting PSOCK main server
[17:46:48.665] [local output] Workers launched
[17:46:48.666] [local output] Waiting for workers to connect back
[17:46:48.666]  - [local output] 0 workers out of 2 ready
[17:46:48.904]  - [local output] 0 workers out of 2 ready
[17:46:48.905]  - [local output] 1 workers out of 2 ready
[17:46:48.911]  - [local output] 1 workers out of 2 ready
[17:46:48.912]  - [local output] 2 workers out of 2 ready
[17:46:48.912] [local output] Launching of workers completed
[17:46:48.912] [local output] Collecting session information from workers
[17:46:48.913] [local output]  - Worker #1 of 2
[17:46:48.913] [local output]  - Worker #2 of 2
[17:46:48.913] [local output] makeClusterPSOCK() ... done
[17:46:48.924] Packages needed by the future expression (n = 0): <none>
[17:46:48.924] Packages needed by future strategies (n = 0): <none>
[17:46:48.925] {
[17:46:48.925]     {
[17:46:48.925]         {
[17:46:48.925]             ...future.startTime <- base::Sys.time()
[17:46:48.925]             {
[17:46:48.925]                 {
[17:46:48.925]                   {
[17:46:48.925]                     {
[17:46:48.925]                       base::local({
[17:46:48.925]                         has_future <- base::requireNamespace("future", 
[17:46:48.925]                           quietly = TRUE)
[17:46:48.925]                         if (has_future) {
[17:46:48.925]                           ns <- base::getNamespace("future")
[17:46:48.925]                           version <- ns[[".package"]][["version"]]
[17:46:48.925]                           if (is.null(version)) 
[17:46:48.925]                             version <- utils::packageVersion("future")
[17:46:48.925]                         }
[17:46:48.925]                         else {
[17:46:48.925]                           version <- NULL
[17:46:48.925]                         }
[17:46:48.925]                         if (!has_future || version < "1.8.0") {
[17:46:48.925]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:48.925]                             "", base::R.version$version.string), 
[17:46:48.925]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:48.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:48.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:48.925]                               "release", "version")], collapse = " "), 
[17:46:48.925]                             hostname = base::Sys.info()[["nodename"]])
[17:46:48.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:48.925]                             info)
[17:46:48.925]                           info <- base::paste(info, collapse = "; ")
[17:46:48.925]                           if (!has_future) {
[17:46:48.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:48.925]                               info)
[17:46:48.925]                           }
[17:46:48.925]                           else {
[17:46:48.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:48.925]                               info, version)
[17:46:48.925]                           }
[17:46:48.925]                           base::stop(msg)
[17:46:48.925]                         }
[17:46:48.925]                       })
[17:46:48.925]                     }
[17:46:48.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:48.925]                     base::options(mc.cores = 1L)
[17:46:48.925]                   }
[17:46:48.925]                   ...future.strategy.old <- future::plan("list")
[17:46:48.925]                   options(future.plan = NULL)
[17:46:48.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:48.925]                 }
[17:46:48.925]                 ...future.workdir <- getwd()
[17:46:48.925]             }
[17:46:48.925]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:48.925]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:48.925]         }
[17:46:48.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:48.925]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:48.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:48.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:48.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:48.925]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:48.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:48.925]             base::names(...future.oldOptions))
[17:46:48.925]     }
[17:46:48.925]     if (FALSE) {
[17:46:48.925]     }
[17:46:48.925]     else {
[17:46:48.925]         if (TRUE) {
[17:46:48.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:48.925]                 open = "w")
[17:46:48.925]         }
[17:46:48.925]         else {
[17:46:48.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:48.925]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:48.925]         }
[17:46:48.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:48.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:48.925]             base::sink(type = "output", split = FALSE)
[17:46:48.925]             base::close(...future.stdout)
[17:46:48.925]         }, add = TRUE)
[17:46:48.925]     }
[17:46:48.925]     ...future.frame <- base::sys.nframe()
[17:46:48.925]     ...future.conditions <- base::list()
[17:46:48.925]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:48.925]     if (FALSE) {
[17:46:48.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:48.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:48.925]     }
[17:46:48.925]     ...future.result <- base::tryCatch({
[17:46:48.925]         base::withCallingHandlers({
[17:46:48.925]             ...future.value <- base::withVisible(base::local({
[17:46:48.925]                 ...future.makeSendCondition <- base::local({
[17:46:48.925]                   sendCondition <- NULL
[17:46:48.925]                   function(frame = 1L) {
[17:46:48.925]                     if (is.function(sendCondition)) 
[17:46:48.925]                       return(sendCondition)
[17:46:48.925]                     ns <- getNamespace("parallel")
[17:46:48.925]                     if (exists("sendData", mode = "function", 
[17:46:48.925]                       envir = ns)) {
[17:46:48.925]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:48.925]                         envir = ns)
[17:46:48.925]                       envir <- sys.frame(frame)
[17:46:48.925]                       master <- NULL
[17:46:48.925]                       while (!identical(envir, .GlobalEnv) && 
[17:46:48.925]                         !identical(envir, emptyenv())) {
[17:46:48.925]                         if (exists("master", mode = "list", envir = envir, 
[17:46:48.925]                           inherits = FALSE)) {
[17:46:48.925]                           master <- get("master", mode = "list", 
[17:46:48.925]                             envir = envir, inherits = FALSE)
[17:46:48.925]                           if (inherits(master, c("SOCKnode", 
[17:46:48.925]                             "SOCK0node"))) {
[17:46:48.925]                             sendCondition <<- function(cond) {
[17:46:48.925]                               data <- list(type = "VALUE", value = cond, 
[17:46:48.925]                                 success = TRUE)
[17:46:48.925]                               parallel_sendData(master, data)
[17:46:48.925]                             }
[17:46:48.925]                             return(sendCondition)
[17:46:48.925]                           }
[17:46:48.925]                         }
[17:46:48.925]                         frame <- frame + 1L
[17:46:48.925]                         envir <- sys.frame(frame)
[17:46:48.925]                       }
[17:46:48.925]                     }
[17:46:48.925]                     sendCondition <<- function(cond) NULL
[17:46:48.925]                   }
[17:46:48.925]                 })
[17:46:48.925]                 withCallingHandlers({
[17:46:48.925]                   NA
[17:46:48.925]                 }, immediateCondition = function(cond) {
[17:46:48.925]                   sendCondition <- ...future.makeSendCondition()
[17:46:48.925]                   sendCondition(cond)
[17:46:48.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.925]                   {
[17:46:48.925]                     inherits <- base::inherits
[17:46:48.925]                     invokeRestart <- base::invokeRestart
[17:46:48.925]                     is.null <- base::is.null
[17:46:48.925]                     muffled <- FALSE
[17:46:48.925]                     if (inherits(cond, "message")) {
[17:46:48.925]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:48.925]                       if (muffled) 
[17:46:48.925]                         invokeRestart("muffleMessage")
[17:46:48.925]                     }
[17:46:48.925]                     else if (inherits(cond, "warning")) {
[17:46:48.925]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:48.925]                       if (muffled) 
[17:46:48.925]                         invokeRestart("muffleWarning")
[17:46:48.925]                     }
[17:46:48.925]                     else if (inherits(cond, "condition")) {
[17:46:48.925]                       if (!is.null(pattern)) {
[17:46:48.925]                         computeRestarts <- base::computeRestarts
[17:46:48.925]                         grepl <- base::grepl
[17:46:48.925]                         restarts <- computeRestarts(cond)
[17:46:48.925]                         for (restart in restarts) {
[17:46:48.925]                           name <- restart$name
[17:46:48.925]                           if (is.null(name)) 
[17:46:48.925]                             next
[17:46:48.925]                           if (!grepl(pattern, name)) 
[17:46:48.925]                             next
[17:46:48.925]                           invokeRestart(restart)
[17:46:48.925]                           muffled <- TRUE
[17:46:48.925]                           break
[17:46:48.925]                         }
[17:46:48.925]                       }
[17:46:48.925]                     }
[17:46:48.925]                     invisible(muffled)
[17:46:48.925]                   }
[17:46:48.925]                   muffleCondition(cond)
[17:46:48.925]                 })
[17:46:48.925]             }))
[17:46:48.925]             future::FutureResult(value = ...future.value$value, 
[17:46:48.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.925]                   ...future.rng), globalenv = if (FALSE) 
[17:46:48.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:48.925]                     ...future.globalenv.names))
[17:46:48.925]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:48.925]         }, condition = base::local({
[17:46:48.925]             c <- base::c
[17:46:48.925]             inherits <- base::inherits
[17:46:48.925]             invokeRestart <- base::invokeRestart
[17:46:48.925]             length <- base::length
[17:46:48.925]             list <- base::list
[17:46:48.925]             seq.int <- base::seq.int
[17:46:48.925]             signalCondition <- base::signalCondition
[17:46:48.925]             sys.calls <- base::sys.calls
[17:46:48.925]             `[[` <- base::`[[`
[17:46:48.925]             `+` <- base::`+`
[17:46:48.925]             `<<-` <- base::`<<-`
[17:46:48.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:48.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:48.925]                   3L)]
[17:46:48.925]             }
[17:46:48.925]             function(cond) {
[17:46:48.925]                 is_error <- inherits(cond, "error")
[17:46:48.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:48.925]                   NULL)
[17:46:48.925]                 if (is_error) {
[17:46:48.925]                   sessionInformation <- function() {
[17:46:48.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:48.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:48.925]                       search = base::search(), system = base::Sys.info())
[17:46:48.925]                   }
[17:46:48.925]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:48.925]                     cond$call), session = sessionInformation(), 
[17:46:48.925]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:48.925]                   signalCondition(cond)
[17:46:48.925]                 }
[17:46:48.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:48.925]                 "immediateCondition"))) {
[17:46:48.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:48.925]                   ...future.conditions[[length(...future.conditions) + 
[17:46:48.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:48.925]                   if (TRUE && !signal) {
[17:46:48.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.925]                     {
[17:46:48.925]                       inherits <- base::inherits
[17:46:48.925]                       invokeRestart <- base::invokeRestart
[17:46:48.925]                       is.null <- base::is.null
[17:46:48.925]                       muffled <- FALSE
[17:46:48.925]                       if (inherits(cond, "message")) {
[17:46:48.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.925]                         if (muffled) 
[17:46:48.925]                           invokeRestart("muffleMessage")
[17:46:48.925]                       }
[17:46:48.925]                       else if (inherits(cond, "warning")) {
[17:46:48.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.925]                         if (muffled) 
[17:46:48.925]                           invokeRestart("muffleWarning")
[17:46:48.925]                       }
[17:46:48.925]                       else if (inherits(cond, "condition")) {
[17:46:48.925]                         if (!is.null(pattern)) {
[17:46:48.925]                           computeRestarts <- base::computeRestarts
[17:46:48.925]                           grepl <- base::grepl
[17:46:48.925]                           restarts <- computeRestarts(cond)
[17:46:48.925]                           for (restart in restarts) {
[17:46:48.925]                             name <- restart$name
[17:46:48.925]                             if (is.null(name)) 
[17:46:48.925]                               next
[17:46:48.925]                             if (!grepl(pattern, name)) 
[17:46:48.925]                               next
[17:46:48.925]                             invokeRestart(restart)
[17:46:48.925]                             muffled <- TRUE
[17:46:48.925]                             break
[17:46:48.925]                           }
[17:46:48.925]                         }
[17:46:48.925]                       }
[17:46:48.925]                       invisible(muffled)
[17:46:48.925]                     }
[17:46:48.925]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.925]                   }
[17:46:48.925]                 }
[17:46:48.925]                 else {
[17:46:48.925]                   if (TRUE) {
[17:46:48.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:48.925]                     {
[17:46:48.925]                       inherits <- base::inherits
[17:46:48.925]                       invokeRestart <- base::invokeRestart
[17:46:48.925]                       is.null <- base::is.null
[17:46:48.925]                       muffled <- FALSE
[17:46:48.925]                       if (inherits(cond, "message")) {
[17:46:48.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:48.925]                         if (muffled) 
[17:46:48.925]                           invokeRestart("muffleMessage")
[17:46:48.925]                       }
[17:46:48.925]                       else if (inherits(cond, "warning")) {
[17:46:48.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:48.925]                         if (muffled) 
[17:46:48.925]                           invokeRestart("muffleWarning")
[17:46:48.925]                       }
[17:46:48.925]                       else if (inherits(cond, "condition")) {
[17:46:48.925]                         if (!is.null(pattern)) {
[17:46:48.925]                           computeRestarts <- base::computeRestarts
[17:46:48.925]                           grepl <- base::grepl
[17:46:48.925]                           restarts <- computeRestarts(cond)
[17:46:48.925]                           for (restart in restarts) {
[17:46:48.925]                             name <- restart$name
[17:46:48.925]                             if (is.null(name)) 
[17:46:48.925]                               next
[17:46:48.925]                             if (!grepl(pattern, name)) 
[17:46:48.925]                               next
[17:46:48.925]                             invokeRestart(restart)
[17:46:48.925]                             muffled <- TRUE
[17:46:48.925]                             break
[17:46:48.925]                           }
[17:46:48.925]                         }
[17:46:48.925]                       }
[17:46:48.925]                       invisible(muffled)
[17:46:48.925]                     }
[17:46:48.925]                     muffleCondition(cond, pattern = "^muffle")
[17:46:48.925]                   }
[17:46:48.925]                 }
[17:46:48.925]             }
[17:46:48.925]         }))
[17:46:48.925]     }, error = function(ex) {
[17:46:48.925]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:48.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:48.925]                 ...future.rng), started = ...future.startTime, 
[17:46:48.925]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:48.925]             version = "1.8"), class = "FutureResult")
[17:46:48.925]     }, finally = {
[17:46:48.925]         if (!identical(...future.workdir, getwd())) 
[17:46:48.925]             setwd(...future.workdir)
[17:46:48.925]         {
[17:46:48.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:48.925]                 ...future.oldOptions$nwarnings <- NULL
[17:46:48.925]             }
[17:46:48.925]             base::options(...future.oldOptions)
[17:46:48.925]             if (.Platform$OS.type == "windows") {
[17:46:48.925]                 old_names <- names(...future.oldEnvVars)
[17:46:48.925]                 envs <- base::Sys.getenv()
[17:46:48.925]                 names <- names(envs)
[17:46:48.925]                 common <- intersect(names, old_names)
[17:46:48.925]                 added <- setdiff(names, old_names)
[17:46:48.925]                 removed <- setdiff(old_names, names)
[17:46:48.925]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:48.925]                   envs[common]]
[17:46:48.925]                 NAMES <- toupper(changed)
[17:46:48.925]                 args <- list()
[17:46:48.925]                 for (kk in seq_along(NAMES)) {
[17:46:48.925]                   name <- changed[[kk]]
[17:46:48.925]                   NAME <- NAMES[[kk]]
[17:46:48.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.925]                     next
[17:46:48.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.925]                 }
[17:46:48.925]                 NAMES <- toupper(added)
[17:46:48.925]                 for (kk in seq_along(NAMES)) {
[17:46:48.925]                   name <- added[[kk]]
[17:46:48.925]                   NAME <- NAMES[[kk]]
[17:46:48.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.925]                     next
[17:46:48.925]                   args[[name]] <- ""
[17:46:48.925]                 }
[17:46:48.925]                 NAMES <- toupper(removed)
[17:46:48.925]                 for (kk in seq_along(NAMES)) {
[17:46:48.925]                   name <- removed[[kk]]
[17:46:48.925]                   NAME <- NAMES[[kk]]
[17:46:48.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:48.925]                     next
[17:46:48.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:48.925]                 }
[17:46:48.925]                 if (length(args) > 0) 
[17:46:48.925]                   base::do.call(base::Sys.setenv, args = args)
[17:46:48.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:48.925]             }
[17:46:48.925]             else {
[17:46:48.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:48.925]             }
[17:46:48.925]             {
[17:46:48.925]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:48.925]                   0L) {
[17:46:48.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:48.925]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:48.925]                   base::options(opts)
[17:46:48.925]                 }
[17:46:48.925]                 {
[17:46:48.925]                   {
[17:46:48.925]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:48.925]                     NULL
[17:46:48.925]                   }
[17:46:48.925]                   options(future.plan = NULL)
[17:46:48.925]                   if (is.na(NA_character_)) 
[17:46:48.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:48.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:48.925]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:48.925]                     .init = FALSE)
[17:46:48.925]                 }
[17:46:48.925]             }
[17:46:48.925]         }
[17:46:48.925]     })
[17:46:48.925]     if (TRUE) {
[17:46:48.925]         base::sink(type = "output", split = FALSE)
[17:46:48.925]         if (TRUE) {
[17:46:48.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:48.925]         }
[17:46:48.925]         else {
[17:46:48.925]             ...future.result["stdout"] <- base::list(NULL)
[17:46:48.925]         }
[17:46:48.925]         base::close(...future.stdout)
[17:46:48.925]         ...future.stdout <- NULL
[17:46:48.925]     }
[17:46:48.925]     ...future.result$conditions <- ...future.conditions
[17:46:48.925]     ...future.result$finished <- base::Sys.time()
[17:46:48.925]     ...future.result
[17:46:48.925] }
[17:46:48.976] MultisessionFuture started
[17:46:48.976] result() for ClusterFuture ...
[17:46:48.976] receiveMessageFromWorker() for ClusterFuture ...
[17:46:48.977] - Validating connection of MultisessionFuture
[17:46:49.009] - received message: FutureResult
[17:46:49.009] - Received FutureResult
[17:46:49.009] - Erased future from FutureRegistry
[17:46:49.009] result() for ClusterFuture ...
[17:46:49.009] - result already collected: FutureResult
[17:46:49.009] result() for ClusterFuture ... done
[17:46:49.010] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.010] result() for ClusterFuture ... done
[17:46:49.010] result() for ClusterFuture ...
[17:46:49.010] - result already collected: FutureResult
[17:46:49.010] result() for ClusterFuture ... done
[17:46:49.010] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:46:49.014] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:46:49.014] getGlobalsAndPackages() ...
[17:46:49.015] Searching for globals...
[17:46:49.015] 
[17:46:49.015] Searching for globals ... DONE
[17:46:49.015] - globals: [0] <none>
[17:46:49.016] getGlobalsAndPackages() ... DONE
[17:46:49.016] run() for ‘Future’ ...
[17:46:49.016] - state: ‘created’
[17:46:49.016] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.030] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.030]   - Field: ‘node’
[17:46:49.030]   - Field: ‘label’
[17:46:49.030]   - Field: ‘local’
[17:46:49.030]   - Field: ‘owner’
[17:46:49.030]   - Field: ‘envir’
[17:46:49.031]   - Field: ‘workers’
[17:46:49.031]   - Field: ‘packages’
[17:46:49.031]   - Field: ‘gc’
[17:46:49.031]   - Field: ‘conditions’
[17:46:49.031]   - Field: ‘persistent’
[17:46:49.031]   - Field: ‘expr’
[17:46:49.031]   - Field: ‘uuid’
[17:46:49.031]   - Field: ‘seed’
[17:46:49.031]   - Field: ‘version’
[17:46:49.031]   - Field: ‘result’
[17:46:49.032]   - Field: ‘asynchronous’
[17:46:49.032]   - Field: ‘calls’
[17:46:49.032]   - Field: ‘globals’
[17:46:49.032]   - Field: ‘stdout’
[17:46:49.032]   - Field: ‘earlySignal’
[17:46:49.032]   - Field: ‘lazy’
[17:46:49.032]   - Field: ‘state’
[17:46:49.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.032] - Launch lazy future ...
[17:46:49.033] Packages needed by the future expression (n = 0): <none>
[17:46:49.033] Packages needed by future strategies (n = 0): <none>
[17:46:49.033] {
[17:46:49.033]     {
[17:46:49.033]         {
[17:46:49.033]             ...future.startTime <- base::Sys.time()
[17:46:49.033]             {
[17:46:49.033]                 {
[17:46:49.033]                   {
[17:46:49.033]                     {
[17:46:49.033]                       base::local({
[17:46:49.033]                         has_future <- base::requireNamespace("future", 
[17:46:49.033]                           quietly = TRUE)
[17:46:49.033]                         if (has_future) {
[17:46:49.033]                           ns <- base::getNamespace("future")
[17:46:49.033]                           version <- ns[[".package"]][["version"]]
[17:46:49.033]                           if (is.null(version)) 
[17:46:49.033]                             version <- utils::packageVersion("future")
[17:46:49.033]                         }
[17:46:49.033]                         else {
[17:46:49.033]                           version <- NULL
[17:46:49.033]                         }
[17:46:49.033]                         if (!has_future || version < "1.8.0") {
[17:46:49.033]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.033]                             "", base::R.version$version.string), 
[17:46:49.033]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.033]                               "release", "version")], collapse = " "), 
[17:46:49.033]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.033]                             info)
[17:46:49.033]                           info <- base::paste(info, collapse = "; ")
[17:46:49.033]                           if (!has_future) {
[17:46:49.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.033]                               info)
[17:46:49.033]                           }
[17:46:49.033]                           else {
[17:46:49.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.033]                               info, version)
[17:46:49.033]                           }
[17:46:49.033]                           base::stop(msg)
[17:46:49.033]                         }
[17:46:49.033]                       })
[17:46:49.033]                     }
[17:46:49.033]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.033]                     base::options(mc.cores = 1L)
[17:46:49.033]                   }
[17:46:49.033]                   ...future.strategy.old <- future::plan("list")
[17:46:49.033]                   options(future.plan = NULL)
[17:46:49.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.033]                 }
[17:46:49.033]                 ...future.workdir <- getwd()
[17:46:49.033]             }
[17:46:49.033]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.033]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.033]         }
[17:46:49.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.033]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.033]             base::names(...future.oldOptions))
[17:46:49.033]     }
[17:46:49.033]     if (FALSE) {
[17:46:49.033]     }
[17:46:49.033]     else {
[17:46:49.033]         if (TRUE) {
[17:46:49.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.033]                 open = "w")
[17:46:49.033]         }
[17:46:49.033]         else {
[17:46:49.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.033]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.033]         }
[17:46:49.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.033]             base::sink(type = "output", split = FALSE)
[17:46:49.033]             base::close(...future.stdout)
[17:46:49.033]         }, add = TRUE)
[17:46:49.033]     }
[17:46:49.033]     ...future.frame <- base::sys.nframe()
[17:46:49.033]     ...future.conditions <- base::list()
[17:46:49.033]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.033]     if (FALSE) {
[17:46:49.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.033]     }
[17:46:49.033]     ...future.result <- base::tryCatch({
[17:46:49.033]         base::withCallingHandlers({
[17:46:49.033]             ...future.value <- base::withVisible(base::local({
[17:46:49.033]                 ...future.makeSendCondition <- base::local({
[17:46:49.033]                   sendCondition <- NULL
[17:46:49.033]                   function(frame = 1L) {
[17:46:49.033]                     if (is.function(sendCondition)) 
[17:46:49.033]                       return(sendCondition)
[17:46:49.033]                     ns <- getNamespace("parallel")
[17:46:49.033]                     if (exists("sendData", mode = "function", 
[17:46:49.033]                       envir = ns)) {
[17:46:49.033]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.033]                         envir = ns)
[17:46:49.033]                       envir <- sys.frame(frame)
[17:46:49.033]                       master <- NULL
[17:46:49.033]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.033]                         !identical(envir, emptyenv())) {
[17:46:49.033]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.033]                           inherits = FALSE)) {
[17:46:49.033]                           master <- get("master", mode = "list", 
[17:46:49.033]                             envir = envir, inherits = FALSE)
[17:46:49.033]                           if (inherits(master, c("SOCKnode", 
[17:46:49.033]                             "SOCK0node"))) {
[17:46:49.033]                             sendCondition <<- function(cond) {
[17:46:49.033]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.033]                                 success = TRUE)
[17:46:49.033]                               parallel_sendData(master, data)
[17:46:49.033]                             }
[17:46:49.033]                             return(sendCondition)
[17:46:49.033]                           }
[17:46:49.033]                         }
[17:46:49.033]                         frame <- frame + 1L
[17:46:49.033]                         envir <- sys.frame(frame)
[17:46:49.033]                       }
[17:46:49.033]                     }
[17:46:49.033]                     sendCondition <<- function(cond) NULL
[17:46:49.033]                   }
[17:46:49.033]                 })
[17:46:49.033]                 withCallingHandlers({
[17:46:49.033]                   2
[17:46:49.033]                 }, immediateCondition = function(cond) {
[17:46:49.033]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.033]                   sendCondition(cond)
[17:46:49.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.033]                   {
[17:46:49.033]                     inherits <- base::inherits
[17:46:49.033]                     invokeRestart <- base::invokeRestart
[17:46:49.033]                     is.null <- base::is.null
[17:46:49.033]                     muffled <- FALSE
[17:46:49.033]                     if (inherits(cond, "message")) {
[17:46:49.033]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.033]                       if (muffled) 
[17:46:49.033]                         invokeRestart("muffleMessage")
[17:46:49.033]                     }
[17:46:49.033]                     else if (inherits(cond, "warning")) {
[17:46:49.033]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.033]                       if (muffled) 
[17:46:49.033]                         invokeRestart("muffleWarning")
[17:46:49.033]                     }
[17:46:49.033]                     else if (inherits(cond, "condition")) {
[17:46:49.033]                       if (!is.null(pattern)) {
[17:46:49.033]                         computeRestarts <- base::computeRestarts
[17:46:49.033]                         grepl <- base::grepl
[17:46:49.033]                         restarts <- computeRestarts(cond)
[17:46:49.033]                         for (restart in restarts) {
[17:46:49.033]                           name <- restart$name
[17:46:49.033]                           if (is.null(name)) 
[17:46:49.033]                             next
[17:46:49.033]                           if (!grepl(pattern, name)) 
[17:46:49.033]                             next
[17:46:49.033]                           invokeRestart(restart)
[17:46:49.033]                           muffled <- TRUE
[17:46:49.033]                           break
[17:46:49.033]                         }
[17:46:49.033]                       }
[17:46:49.033]                     }
[17:46:49.033]                     invisible(muffled)
[17:46:49.033]                   }
[17:46:49.033]                   muffleCondition(cond)
[17:46:49.033]                 })
[17:46:49.033]             }))
[17:46:49.033]             future::FutureResult(value = ...future.value$value, 
[17:46:49.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.033]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.033]                     ...future.globalenv.names))
[17:46:49.033]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.033]         }, condition = base::local({
[17:46:49.033]             c <- base::c
[17:46:49.033]             inherits <- base::inherits
[17:46:49.033]             invokeRestart <- base::invokeRestart
[17:46:49.033]             length <- base::length
[17:46:49.033]             list <- base::list
[17:46:49.033]             seq.int <- base::seq.int
[17:46:49.033]             signalCondition <- base::signalCondition
[17:46:49.033]             sys.calls <- base::sys.calls
[17:46:49.033]             `[[` <- base::`[[`
[17:46:49.033]             `+` <- base::`+`
[17:46:49.033]             `<<-` <- base::`<<-`
[17:46:49.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.033]                   3L)]
[17:46:49.033]             }
[17:46:49.033]             function(cond) {
[17:46:49.033]                 is_error <- inherits(cond, "error")
[17:46:49.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.033]                   NULL)
[17:46:49.033]                 if (is_error) {
[17:46:49.033]                   sessionInformation <- function() {
[17:46:49.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.033]                       search = base::search(), system = base::Sys.info())
[17:46:49.033]                   }
[17:46:49.033]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.033]                     cond$call), session = sessionInformation(), 
[17:46:49.033]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.033]                   signalCondition(cond)
[17:46:49.033]                 }
[17:46:49.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.033]                 "immediateCondition"))) {
[17:46:49.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.033]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.033]                   if (TRUE && !signal) {
[17:46:49.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.033]                     {
[17:46:49.033]                       inherits <- base::inherits
[17:46:49.033]                       invokeRestart <- base::invokeRestart
[17:46:49.033]                       is.null <- base::is.null
[17:46:49.033]                       muffled <- FALSE
[17:46:49.033]                       if (inherits(cond, "message")) {
[17:46:49.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.033]                         if (muffled) 
[17:46:49.033]                           invokeRestart("muffleMessage")
[17:46:49.033]                       }
[17:46:49.033]                       else if (inherits(cond, "warning")) {
[17:46:49.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.033]                         if (muffled) 
[17:46:49.033]                           invokeRestart("muffleWarning")
[17:46:49.033]                       }
[17:46:49.033]                       else if (inherits(cond, "condition")) {
[17:46:49.033]                         if (!is.null(pattern)) {
[17:46:49.033]                           computeRestarts <- base::computeRestarts
[17:46:49.033]                           grepl <- base::grepl
[17:46:49.033]                           restarts <- computeRestarts(cond)
[17:46:49.033]                           for (restart in restarts) {
[17:46:49.033]                             name <- restart$name
[17:46:49.033]                             if (is.null(name)) 
[17:46:49.033]                               next
[17:46:49.033]                             if (!grepl(pattern, name)) 
[17:46:49.033]                               next
[17:46:49.033]                             invokeRestart(restart)
[17:46:49.033]                             muffled <- TRUE
[17:46:49.033]                             break
[17:46:49.033]                           }
[17:46:49.033]                         }
[17:46:49.033]                       }
[17:46:49.033]                       invisible(muffled)
[17:46:49.033]                     }
[17:46:49.033]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.033]                   }
[17:46:49.033]                 }
[17:46:49.033]                 else {
[17:46:49.033]                   if (TRUE) {
[17:46:49.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.033]                     {
[17:46:49.033]                       inherits <- base::inherits
[17:46:49.033]                       invokeRestart <- base::invokeRestart
[17:46:49.033]                       is.null <- base::is.null
[17:46:49.033]                       muffled <- FALSE
[17:46:49.033]                       if (inherits(cond, "message")) {
[17:46:49.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.033]                         if (muffled) 
[17:46:49.033]                           invokeRestart("muffleMessage")
[17:46:49.033]                       }
[17:46:49.033]                       else if (inherits(cond, "warning")) {
[17:46:49.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.033]                         if (muffled) 
[17:46:49.033]                           invokeRestart("muffleWarning")
[17:46:49.033]                       }
[17:46:49.033]                       else if (inherits(cond, "condition")) {
[17:46:49.033]                         if (!is.null(pattern)) {
[17:46:49.033]                           computeRestarts <- base::computeRestarts
[17:46:49.033]                           grepl <- base::grepl
[17:46:49.033]                           restarts <- computeRestarts(cond)
[17:46:49.033]                           for (restart in restarts) {
[17:46:49.033]                             name <- restart$name
[17:46:49.033]                             if (is.null(name)) 
[17:46:49.033]                               next
[17:46:49.033]                             if (!grepl(pattern, name)) 
[17:46:49.033]                               next
[17:46:49.033]                             invokeRestart(restart)
[17:46:49.033]                             muffled <- TRUE
[17:46:49.033]                             break
[17:46:49.033]                           }
[17:46:49.033]                         }
[17:46:49.033]                       }
[17:46:49.033]                       invisible(muffled)
[17:46:49.033]                     }
[17:46:49.033]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.033]                   }
[17:46:49.033]                 }
[17:46:49.033]             }
[17:46:49.033]         }))
[17:46:49.033]     }, error = function(ex) {
[17:46:49.033]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.033]                 ...future.rng), started = ...future.startTime, 
[17:46:49.033]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.033]             version = "1.8"), class = "FutureResult")
[17:46:49.033]     }, finally = {
[17:46:49.033]         if (!identical(...future.workdir, getwd())) 
[17:46:49.033]             setwd(...future.workdir)
[17:46:49.033]         {
[17:46:49.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.033]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.033]             }
[17:46:49.033]             base::options(...future.oldOptions)
[17:46:49.033]             if (.Platform$OS.type == "windows") {
[17:46:49.033]                 old_names <- names(...future.oldEnvVars)
[17:46:49.033]                 envs <- base::Sys.getenv()
[17:46:49.033]                 names <- names(envs)
[17:46:49.033]                 common <- intersect(names, old_names)
[17:46:49.033]                 added <- setdiff(names, old_names)
[17:46:49.033]                 removed <- setdiff(old_names, names)
[17:46:49.033]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.033]                   envs[common]]
[17:46:49.033]                 NAMES <- toupper(changed)
[17:46:49.033]                 args <- list()
[17:46:49.033]                 for (kk in seq_along(NAMES)) {
[17:46:49.033]                   name <- changed[[kk]]
[17:46:49.033]                   NAME <- NAMES[[kk]]
[17:46:49.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.033]                     next
[17:46:49.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.033]                 }
[17:46:49.033]                 NAMES <- toupper(added)
[17:46:49.033]                 for (kk in seq_along(NAMES)) {
[17:46:49.033]                   name <- added[[kk]]
[17:46:49.033]                   NAME <- NAMES[[kk]]
[17:46:49.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.033]                     next
[17:46:49.033]                   args[[name]] <- ""
[17:46:49.033]                 }
[17:46:49.033]                 NAMES <- toupper(removed)
[17:46:49.033]                 for (kk in seq_along(NAMES)) {
[17:46:49.033]                   name <- removed[[kk]]
[17:46:49.033]                   NAME <- NAMES[[kk]]
[17:46:49.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.033]                     next
[17:46:49.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.033]                 }
[17:46:49.033]                 if (length(args) > 0) 
[17:46:49.033]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.033]             }
[17:46:49.033]             else {
[17:46:49.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.033]             }
[17:46:49.033]             {
[17:46:49.033]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.033]                   0L) {
[17:46:49.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.033]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.033]                   base::options(opts)
[17:46:49.033]                 }
[17:46:49.033]                 {
[17:46:49.033]                   {
[17:46:49.033]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.033]                     NULL
[17:46:49.033]                   }
[17:46:49.033]                   options(future.plan = NULL)
[17:46:49.033]                   if (is.na(NA_character_)) 
[17:46:49.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.033]                     .init = FALSE)
[17:46:49.033]                 }
[17:46:49.033]             }
[17:46:49.033]         }
[17:46:49.033]     })
[17:46:49.033]     if (TRUE) {
[17:46:49.033]         base::sink(type = "output", split = FALSE)
[17:46:49.033]         if (TRUE) {
[17:46:49.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.033]         }
[17:46:49.033]         else {
[17:46:49.033]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.033]         }
[17:46:49.033]         base::close(...future.stdout)
[17:46:49.033]         ...future.stdout <- NULL
[17:46:49.033]     }
[17:46:49.033]     ...future.result$conditions <- ...future.conditions
[17:46:49.033]     ...future.result$finished <- base::Sys.time()
[17:46:49.033]     ...future.result
[17:46:49.033] }
[17:46:49.036] MultisessionFuture started
[17:46:49.036] - Launch lazy future ... done
[17:46:49.037] run() for ‘MultisessionFuture’ ... done
[17:46:49.037] getGlobalsAndPackages() ...
[17:46:49.037] Searching for globals...
[17:46:49.037] 
[17:46:49.038] Searching for globals ... DONE
[17:46:49.038] - globals: [0] <none>
[17:46:49.038] getGlobalsAndPackages() ... DONE
[17:46:49.038] run() for ‘Future’ ...
[17:46:49.038] - state: ‘created’
[17:46:49.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.052]   - Field: ‘node’
[17:46:49.052]   - Field: ‘label’
[17:46:49.053]   - Field: ‘local’
[17:46:49.053]   - Field: ‘owner’
[17:46:49.053]   - Field: ‘envir’
[17:46:49.053]   - Field: ‘workers’
[17:46:49.053]   - Field: ‘packages’
[17:46:49.053]   - Field: ‘gc’
[17:46:49.053]   - Field: ‘conditions’
[17:46:49.053]   - Field: ‘persistent’
[17:46:49.053]   - Field: ‘expr’
[17:46:49.053]   - Field: ‘uuid’
[17:46:49.054]   - Field: ‘seed’
[17:46:49.054]   - Field: ‘version’
[17:46:49.054]   - Field: ‘result’
[17:46:49.054]   - Field: ‘asynchronous’
[17:46:49.054]   - Field: ‘calls’
[17:46:49.054]   - Field: ‘globals’
[17:46:49.054]   - Field: ‘stdout’
[17:46:49.054]   - Field: ‘earlySignal’
[17:46:49.054]   - Field: ‘lazy’
[17:46:49.054]   - Field: ‘state’
[17:46:49.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.054] - Launch lazy future ...
[17:46:49.055] Packages needed by the future expression (n = 0): <none>
[17:46:49.055] Packages needed by future strategies (n = 0): <none>
[17:46:49.055] {
[17:46:49.055]     {
[17:46:49.055]         {
[17:46:49.055]             ...future.startTime <- base::Sys.time()
[17:46:49.055]             {
[17:46:49.055]                 {
[17:46:49.055]                   {
[17:46:49.055]                     {
[17:46:49.055]                       base::local({
[17:46:49.055]                         has_future <- base::requireNamespace("future", 
[17:46:49.055]                           quietly = TRUE)
[17:46:49.055]                         if (has_future) {
[17:46:49.055]                           ns <- base::getNamespace("future")
[17:46:49.055]                           version <- ns[[".package"]][["version"]]
[17:46:49.055]                           if (is.null(version)) 
[17:46:49.055]                             version <- utils::packageVersion("future")
[17:46:49.055]                         }
[17:46:49.055]                         else {
[17:46:49.055]                           version <- NULL
[17:46:49.055]                         }
[17:46:49.055]                         if (!has_future || version < "1.8.0") {
[17:46:49.055]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.055]                             "", base::R.version$version.string), 
[17:46:49.055]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.055]                               "release", "version")], collapse = " "), 
[17:46:49.055]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.055]                             info)
[17:46:49.055]                           info <- base::paste(info, collapse = "; ")
[17:46:49.055]                           if (!has_future) {
[17:46:49.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.055]                               info)
[17:46:49.055]                           }
[17:46:49.055]                           else {
[17:46:49.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.055]                               info, version)
[17:46:49.055]                           }
[17:46:49.055]                           base::stop(msg)
[17:46:49.055]                         }
[17:46:49.055]                       })
[17:46:49.055]                     }
[17:46:49.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.055]                     base::options(mc.cores = 1L)
[17:46:49.055]                   }
[17:46:49.055]                   ...future.strategy.old <- future::plan("list")
[17:46:49.055]                   options(future.plan = NULL)
[17:46:49.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.055]                 }
[17:46:49.055]                 ...future.workdir <- getwd()
[17:46:49.055]             }
[17:46:49.055]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.055]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.055]         }
[17:46:49.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.055]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.055]             base::names(...future.oldOptions))
[17:46:49.055]     }
[17:46:49.055]     if (FALSE) {
[17:46:49.055]     }
[17:46:49.055]     else {
[17:46:49.055]         if (TRUE) {
[17:46:49.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.055]                 open = "w")
[17:46:49.055]         }
[17:46:49.055]         else {
[17:46:49.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.055]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.055]         }
[17:46:49.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.055]             base::sink(type = "output", split = FALSE)
[17:46:49.055]             base::close(...future.stdout)
[17:46:49.055]         }, add = TRUE)
[17:46:49.055]     }
[17:46:49.055]     ...future.frame <- base::sys.nframe()
[17:46:49.055]     ...future.conditions <- base::list()
[17:46:49.055]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.055]     if (FALSE) {
[17:46:49.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.055]     }
[17:46:49.055]     ...future.result <- base::tryCatch({
[17:46:49.055]         base::withCallingHandlers({
[17:46:49.055]             ...future.value <- base::withVisible(base::local({
[17:46:49.055]                 ...future.makeSendCondition <- base::local({
[17:46:49.055]                   sendCondition <- NULL
[17:46:49.055]                   function(frame = 1L) {
[17:46:49.055]                     if (is.function(sendCondition)) 
[17:46:49.055]                       return(sendCondition)
[17:46:49.055]                     ns <- getNamespace("parallel")
[17:46:49.055]                     if (exists("sendData", mode = "function", 
[17:46:49.055]                       envir = ns)) {
[17:46:49.055]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.055]                         envir = ns)
[17:46:49.055]                       envir <- sys.frame(frame)
[17:46:49.055]                       master <- NULL
[17:46:49.055]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.055]                         !identical(envir, emptyenv())) {
[17:46:49.055]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.055]                           inherits = FALSE)) {
[17:46:49.055]                           master <- get("master", mode = "list", 
[17:46:49.055]                             envir = envir, inherits = FALSE)
[17:46:49.055]                           if (inherits(master, c("SOCKnode", 
[17:46:49.055]                             "SOCK0node"))) {
[17:46:49.055]                             sendCondition <<- function(cond) {
[17:46:49.055]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.055]                                 success = TRUE)
[17:46:49.055]                               parallel_sendData(master, data)
[17:46:49.055]                             }
[17:46:49.055]                             return(sendCondition)
[17:46:49.055]                           }
[17:46:49.055]                         }
[17:46:49.055]                         frame <- frame + 1L
[17:46:49.055]                         envir <- sys.frame(frame)
[17:46:49.055]                       }
[17:46:49.055]                     }
[17:46:49.055]                     sendCondition <<- function(cond) NULL
[17:46:49.055]                   }
[17:46:49.055]                 })
[17:46:49.055]                 withCallingHandlers({
[17:46:49.055]                   NULL
[17:46:49.055]                 }, immediateCondition = function(cond) {
[17:46:49.055]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.055]                   sendCondition(cond)
[17:46:49.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.055]                   {
[17:46:49.055]                     inherits <- base::inherits
[17:46:49.055]                     invokeRestart <- base::invokeRestart
[17:46:49.055]                     is.null <- base::is.null
[17:46:49.055]                     muffled <- FALSE
[17:46:49.055]                     if (inherits(cond, "message")) {
[17:46:49.055]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.055]                       if (muffled) 
[17:46:49.055]                         invokeRestart("muffleMessage")
[17:46:49.055]                     }
[17:46:49.055]                     else if (inherits(cond, "warning")) {
[17:46:49.055]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.055]                       if (muffled) 
[17:46:49.055]                         invokeRestart("muffleWarning")
[17:46:49.055]                     }
[17:46:49.055]                     else if (inherits(cond, "condition")) {
[17:46:49.055]                       if (!is.null(pattern)) {
[17:46:49.055]                         computeRestarts <- base::computeRestarts
[17:46:49.055]                         grepl <- base::grepl
[17:46:49.055]                         restarts <- computeRestarts(cond)
[17:46:49.055]                         for (restart in restarts) {
[17:46:49.055]                           name <- restart$name
[17:46:49.055]                           if (is.null(name)) 
[17:46:49.055]                             next
[17:46:49.055]                           if (!grepl(pattern, name)) 
[17:46:49.055]                             next
[17:46:49.055]                           invokeRestart(restart)
[17:46:49.055]                           muffled <- TRUE
[17:46:49.055]                           break
[17:46:49.055]                         }
[17:46:49.055]                       }
[17:46:49.055]                     }
[17:46:49.055]                     invisible(muffled)
[17:46:49.055]                   }
[17:46:49.055]                   muffleCondition(cond)
[17:46:49.055]                 })
[17:46:49.055]             }))
[17:46:49.055]             future::FutureResult(value = ...future.value$value, 
[17:46:49.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.055]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.055]                     ...future.globalenv.names))
[17:46:49.055]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.055]         }, condition = base::local({
[17:46:49.055]             c <- base::c
[17:46:49.055]             inherits <- base::inherits
[17:46:49.055]             invokeRestart <- base::invokeRestart
[17:46:49.055]             length <- base::length
[17:46:49.055]             list <- base::list
[17:46:49.055]             seq.int <- base::seq.int
[17:46:49.055]             signalCondition <- base::signalCondition
[17:46:49.055]             sys.calls <- base::sys.calls
[17:46:49.055]             `[[` <- base::`[[`
[17:46:49.055]             `+` <- base::`+`
[17:46:49.055]             `<<-` <- base::`<<-`
[17:46:49.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.055]                   3L)]
[17:46:49.055]             }
[17:46:49.055]             function(cond) {
[17:46:49.055]                 is_error <- inherits(cond, "error")
[17:46:49.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.055]                   NULL)
[17:46:49.055]                 if (is_error) {
[17:46:49.055]                   sessionInformation <- function() {
[17:46:49.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.055]                       search = base::search(), system = base::Sys.info())
[17:46:49.055]                   }
[17:46:49.055]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.055]                     cond$call), session = sessionInformation(), 
[17:46:49.055]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.055]                   signalCondition(cond)
[17:46:49.055]                 }
[17:46:49.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.055]                 "immediateCondition"))) {
[17:46:49.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.055]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.055]                   if (TRUE && !signal) {
[17:46:49.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.055]                     {
[17:46:49.055]                       inherits <- base::inherits
[17:46:49.055]                       invokeRestart <- base::invokeRestart
[17:46:49.055]                       is.null <- base::is.null
[17:46:49.055]                       muffled <- FALSE
[17:46:49.055]                       if (inherits(cond, "message")) {
[17:46:49.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.055]                         if (muffled) 
[17:46:49.055]                           invokeRestart("muffleMessage")
[17:46:49.055]                       }
[17:46:49.055]                       else if (inherits(cond, "warning")) {
[17:46:49.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.055]                         if (muffled) 
[17:46:49.055]                           invokeRestart("muffleWarning")
[17:46:49.055]                       }
[17:46:49.055]                       else if (inherits(cond, "condition")) {
[17:46:49.055]                         if (!is.null(pattern)) {
[17:46:49.055]                           computeRestarts <- base::computeRestarts
[17:46:49.055]                           grepl <- base::grepl
[17:46:49.055]                           restarts <- computeRestarts(cond)
[17:46:49.055]                           for (restart in restarts) {
[17:46:49.055]                             name <- restart$name
[17:46:49.055]                             if (is.null(name)) 
[17:46:49.055]                               next
[17:46:49.055]                             if (!grepl(pattern, name)) 
[17:46:49.055]                               next
[17:46:49.055]                             invokeRestart(restart)
[17:46:49.055]                             muffled <- TRUE
[17:46:49.055]                             break
[17:46:49.055]                           }
[17:46:49.055]                         }
[17:46:49.055]                       }
[17:46:49.055]                       invisible(muffled)
[17:46:49.055]                     }
[17:46:49.055]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.055]                   }
[17:46:49.055]                 }
[17:46:49.055]                 else {
[17:46:49.055]                   if (TRUE) {
[17:46:49.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.055]                     {
[17:46:49.055]                       inherits <- base::inherits
[17:46:49.055]                       invokeRestart <- base::invokeRestart
[17:46:49.055]                       is.null <- base::is.null
[17:46:49.055]                       muffled <- FALSE
[17:46:49.055]                       if (inherits(cond, "message")) {
[17:46:49.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.055]                         if (muffled) 
[17:46:49.055]                           invokeRestart("muffleMessage")
[17:46:49.055]                       }
[17:46:49.055]                       else if (inherits(cond, "warning")) {
[17:46:49.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.055]                         if (muffled) 
[17:46:49.055]                           invokeRestart("muffleWarning")
[17:46:49.055]                       }
[17:46:49.055]                       else if (inherits(cond, "condition")) {
[17:46:49.055]                         if (!is.null(pattern)) {
[17:46:49.055]                           computeRestarts <- base::computeRestarts
[17:46:49.055]                           grepl <- base::grepl
[17:46:49.055]                           restarts <- computeRestarts(cond)
[17:46:49.055]                           for (restart in restarts) {
[17:46:49.055]                             name <- restart$name
[17:46:49.055]                             if (is.null(name)) 
[17:46:49.055]                               next
[17:46:49.055]                             if (!grepl(pattern, name)) 
[17:46:49.055]                               next
[17:46:49.055]                             invokeRestart(restart)
[17:46:49.055]                             muffled <- TRUE
[17:46:49.055]                             break
[17:46:49.055]                           }
[17:46:49.055]                         }
[17:46:49.055]                       }
[17:46:49.055]                       invisible(muffled)
[17:46:49.055]                     }
[17:46:49.055]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.055]                   }
[17:46:49.055]                 }
[17:46:49.055]             }
[17:46:49.055]         }))
[17:46:49.055]     }, error = function(ex) {
[17:46:49.055]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.055]                 ...future.rng), started = ...future.startTime, 
[17:46:49.055]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.055]             version = "1.8"), class = "FutureResult")
[17:46:49.055]     }, finally = {
[17:46:49.055]         if (!identical(...future.workdir, getwd())) 
[17:46:49.055]             setwd(...future.workdir)
[17:46:49.055]         {
[17:46:49.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.055]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.055]             }
[17:46:49.055]             base::options(...future.oldOptions)
[17:46:49.055]             if (.Platform$OS.type == "windows") {
[17:46:49.055]                 old_names <- names(...future.oldEnvVars)
[17:46:49.055]                 envs <- base::Sys.getenv()
[17:46:49.055]                 names <- names(envs)
[17:46:49.055]                 common <- intersect(names, old_names)
[17:46:49.055]                 added <- setdiff(names, old_names)
[17:46:49.055]                 removed <- setdiff(old_names, names)
[17:46:49.055]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.055]                   envs[common]]
[17:46:49.055]                 NAMES <- toupper(changed)
[17:46:49.055]                 args <- list()
[17:46:49.055]                 for (kk in seq_along(NAMES)) {
[17:46:49.055]                   name <- changed[[kk]]
[17:46:49.055]                   NAME <- NAMES[[kk]]
[17:46:49.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.055]                     next
[17:46:49.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.055]                 }
[17:46:49.055]                 NAMES <- toupper(added)
[17:46:49.055]                 for (kk in seq_along(NAMES)) {
[17:46:49.055]                   name <- added[[kk]]
[17:46:49.055]                   NAME <- NAMES[[kk]]
[17:46:49.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.055]                     next
[17:46:49.055]                   args[[name]] <- ""
[17:46:49.055]                 }
[17:46:49.055]                 NAMES <- toupper(removed)
[17:46:49.055]                 for (kk in seq_along(NAMES)) {
[17:46:49.055]                   name <- removed[[kk]]
[17:46:49.055]                   NAME <- NAMES[[kk]]
[17:46:49.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.055]                     next
[17:46:49.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.055]                 }
[17:46:49.055]                 if (length(args) > 0) 
[17:46:49.055]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.055]             }
[17:46:49.055]             else {
[17:46:49.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.055]             }
[17:46:49.055]             {
[17:46:49.055]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.055]                   0L) {
[17:46:49.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.055]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.055]                   base::options(opts)
[17:46:49.055]                 }
[17:46:49.055]                 {
[17:46:49.055]                   {
[17:46:49.055]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.055]                     NULL
[17:46:49.055]                   }
[17:46:49.055]                   options(future.plan = NULL)
[17:46:49.055]                   if (is.na(NA_character_)) 
[17:46:49.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.055]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.055]                     .init = FALSE)
[17:46:49.055]                 }
[17:46:49.055]             }
[17:46:49.055]         }
[17:46:49.055]     })
[17:46:49.055]     if (TRUE) {
[17:46:49.055]         base::sink(type = "output", split = FALSE)
[17:46:49.055]         if (TRUE) {
[17:46:49.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.055]         }
[17:46:49.055]         else {
[17:46:49.055]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.055]         }
[17:46:49.055]         base::close(...future.stdout)
[17:46:49.055]         ...future.stdout <- NULL
[17:46:49.055]     }
[17:46:49.055]     ...future.result$conditions <- ...future.conditions
[17:46:49.055]     ...future.result$finished <- base::Sys.time()
[17:46:49.055]     ...future.result
[17:46:49.055] }
[17:46:49.107] MultisessionFuture started
[17:46:49.108] - Launch lazy future ... done
[17:46:49.108] run() for ‘MultisessionFuture’ ... done
[17:46:49.108] getGlobalsAndPackages() ...
[17:46:49.108] Searching for globals...
[17:46:49.109] - globals found: [1] ‘{’
[17:46:49.109] Searching for globals ... DONE
[17:46:49.109] Resolving globals: FALSE
[17:46:49.110] 
[17:46:49.110] 
[17:46:49.110] getGlobalsAndPackages() ... DONE
[17:46:49.110] run() for ‘Future’ ...
[17:46:49.110] - state: ‘created’
[17:46:49.110] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.125] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.125] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.125]   - Field: ‘node’
[17:46:49.125]   - Field: ‘label’
[17:46:49.125]   - Field: ‘local’
[17:46:49.125]   - Field: ‘owner’
[17:46:49.125]   - Field: ‘envir’
[17:46:49.125]   - Field: ‘workers’
[17:46:49.126]   - Field: ‘packages’
[17:46:49.126]   - Field: ‘gc’
[17:46:49.126]   - Field: ‘conditions’
[17:46:49.126]   - Field: ‘persistent’
[17:46:49.126]   - Field: ‘expr’
[17:46:49.126]   - Field: ‘uuid’
[17:46:49.126]   - Field: ‘seed’
[17:46:49.126]   - Field: ‘version’
[17:46:49.126]   - Field: ‘result’
[17:46:49.126]   - Field: ‘asynchronous’
[17:46:49.126]   - Field: ‘calls’
[17:46:49.127]   - Field: ‘globals’
[17:46:49.127]   - Field: ‘stdout’
[17:46:49.127]   - Field: ‘earlySignal’
[17:46:49.127]   - Field: ‘lazy’
[17:46:49.127]   - Field: ‘state’
[17:46:49.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.127] - Launch lazy future ...
[17:46:49.127] Packages needed by the future expression (n = 0): <none>
[17:46:49.128] Packages needed by future strategies (n = 0): <none>
[17:46:49.131] {
[17:46:49.131]     {
[17:46:49.131]         {
[17:46:49.131]             ...future.startTime <- base::Sys.time()
[17:46:49.131]             {
[17:46:49.131]                 {
[17:46:49.131]                   {
[17:46:49.131]                     {
[17:46:49.131]                       base::local({
[17:46:49.131]                         has_future <- base::requireNamespace("future", 
[17:46:49.131]                           quietly = TRUE)
[17:46:49.131]                         if (has_future) {
[17:46:49.131]                           ns <- base::getNamespace("future")
[17:46:49.131]                           version <- ns[[".package"]][["version"]]
[17:46:49.131]                           if (is.null(version)) 
[17:46:49.131]                             version <- utils::packageVersion("future")
[17:46:49.131]                         }
[17:46:49.131]                         else {
[17:46:49.131]                           version <- NULL
[17:46:49.131]                         }
[17:46:49.131]                         if (!has_future || version < "1.8.0") {
[17:46:49.131]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.131]                             "", base::R.version$version.string), 
[17:46:49.131]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.131]                               "release", "version")], collapse = " "), 
[17:46:49.131]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.131]                             info)
[17:46:49.131]                           info <- base::paste(info, collapse = "; ")
[17:46:49.131]                           if (!has_future) {
[17:46:49.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.131]                               info)
[17:46:49.131]                           }
[17:46:49.131]                           else {
[17:46:49.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.131]                               info, version)
[17:46:49.131]                           }
[17:46:49.131]                           base::stop(msg)
[17:46:49.131]                         }
[17:46:49.131]                       })
[17:46:49.131]                     }
[17:46:49.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.131]                     base::options(mc.cores = 1L)
[17:46:49.131]                   }
[17:46:49.131]                   ...future.strategy.old <- future::plan("list")
[17:46:49.131]                   options(future.plan = NULL)
[17:46:49.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.131]                 }
[17:46:49.131]                 ...future.workdir <- getwd()
[17:46:49.131]             }
[17:46:49.131]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.131]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.131]         }
[17:46:49.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.131]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.131]             base::names(...future.oldOptions))
[17:46:49.131]     }
[17:46:49.131]     if (FALSE) {
[17:46:49.131]     }
[17:46:49.131]     else {
[17:46:49.131]         if (TRUE) {
[17:46:49.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.131]                 open = "w")
[17:46:49.131]         }
[17:46:49.131]         else {
[17:46:49.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.131]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.131]         }
[17:46:49.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.131]             base::sink(type = "output", split = FALSE)
[17:46:49.131]             base::close(...future.stdout)
[17:46:49.131]         }, add = TRUE)
[17:46:49.131]     }
[17:46:49.131]     ...future.frame <- base::sys.nframe()
[17:46:49.131]     ...future.conditions <- base::list()
[17:46:49.131]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.131]     if (FALSE) {
[17:46:49.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.131]     }
[17:46:49.131]     ...future.result <- base::tryCatch({
[17:46:49.131]         base::withCallingHandlers({
[17:46:49.131]             ...future.value <- base::withVisible(base::local({
[17:46:49.131]                 ...future.makeSendCondition <- base::local({
[17:46:49.131]                   sendCondition <- NULL
[17:46:49.131]                   function(frame = 1L) {
[17:46:49.131]                     if (is.function(sendCondition)) 
[17:46:49.131]                       return(sendCondition)
[17:46:49.131]                     ns <- getNamespace("parallel")
[17:46:49.131]                     if (exists("sendData", mode = "function", 
[17:46:49.131]                       envir = ns)) {
[17:46:49.131]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.131]                         envir = ns)
[17:46:49.131]                       envir <- sys.frame(frame)
[17:46:49.131]                       master <- NULL
[17:46:49.131]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.131]                         !identical(envir, emptyenv())) {
[17:46:49.131]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.131]                           inherits = FALSE)) {
[17:46:49.131]                           master <- get("master", mode = "list", 
[17:46:49.131]                             envir = envir, inherits = FALSE)
[17:46:49.131]                           if (inherits(master, c("SOCKnode", 
[17:46:49.131]                             "SOCK0node"))) {
[17:46:49.131]                             sendCondition <<- function(cond) {
[17:46:49.131]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.131]                                 success = TRUE)
[17:46:49.131]                               parallel_sendData(master, data)
[17:46:49.131]                             }
[17:46:49.131]                             return(sendCondition)
[17:46:49.131]                           }
[17:46:49.131]                         }
[17:46:49.131]                         frame <- frame + 1L
[17:46:49.131]                         envir <- sys.frame(frame)
[17:46:49.131]                       }
[17:46:49.131]                     }
[17:46:49.131]                     sendCondition <<- function(cond) NULL
[17:46:49.131]                   }
[17:46:49.131]                 })
[17:46:49.131]                 withCallingHandlers({
[17:46:49.131]                   {
[17:46:49.131]                     4
[17:46:49.131]                   }
[17:46:49.131]                 }, immediateCondition = function(cond) {
[17:46:49.131]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.131]                   sendCondition(cond)
[17:46:49.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.131]                   {
[17:46:49.131]                     inherits <- base::inherits
[17:46:49.131]                     invokeRestart <- base::invokeRestart
[17:46:49.131]                     is.null <- base::is.null
[17:46:49.131]                     muffled <- FALSE
[17:46:49.131]                     if (inherits(cond, "message")) {
[17:46:49.131]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.131]                       if (muffled) 
[17:46:49.131]                         invokeRestart("muffleMessage")
[17:46:49.131]                     }
[17:46:49.131]                     else if (inherits(cond, "warning")) {
[17:46:49.131]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.131]                       if (muffled) 
[17:46:49.131]                         invokeRestart("muffleWarning")
[17:46:49.131]                     }
[17:46:49.131]                     else if (inherits(cond, "condition")) {
[17:46:49.131]                       if (!is.null(pattern)) {
[17:46:49.131]                         computeRestarts <- base::computeRestarts
[17:46:49.131]                         grepl <- base::grepl
[17:46:49.131]                         restarts <- computeRestarts(cond)
[17:46:49.131]                         for (restart in restarts) {
[17:46:49.131]                           name <- restart$name
[17:46:49.131]                           if (is.null(name)) 
[17:46:49.131]                             next
[17:46:49.131]                           if (!grepl(pattern, name)) 
[17:46:49.131]                             next
[17:46:49.131]                           invokeRestart(restart)
[17:46:49.131]                           muffled <- TRUE
[17:46:49.131]                           break
[17:46:49.131]                         }
[17:46:49.131]                       }
[17:46:49.131]                     }
[17:46:49.131]                     invisible(muffled)
[17:46:49.131]                   }
[17:46:49.131]                   muffleCondition(cond)
[17:46:49.131]                 })
[17:46:49.131]             }))
[17:46:49.131]             future::FutureResult(value = ...future.value$value, 
[17:46:49.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.131]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.131]                     ...future.globalenv.names))
[17:46:49.131]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.131]         }, condition = base::local({
[17:46:49.131]             c <- base::c
[17:46:49.131]             inherits <- base::inherits
[17:46:49.131]             invokeRestart <- base::invokeRestart
[17:46:49.131]             length <- base::length
[17:46:49.131]             list <- base::list
[17:46:49.131]             seq.int <- base::seq.int
[17:46:49.131]             signalCondition <- base::signalCondition
[17:46:49.131]             sys.calls <- base::sys.calls
[17:46:49.131]             `[[` <- base::`[[`
[17:46:49.131]             `+` <- base::`+`
[17:46:49.131]             `<<-` <- base::`<<-`
[17:46:49.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.131]                   3L)]
[17:46:49.131]             }
[17:46:49.131]             function(cond) {
[17:46:49.131]                 is_error <- inherits(cond, "error")
[17:46:49.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.131]                   NULL)
[17:46:49.131]                 if (is_error) {
[17:46:49.131]                   sessionInformation <- function() {
[17:46:49.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.131]                       search = base::search(), system = base::Sys.info())
[17:46:49.131]                   }
[17:46:49.131]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.131]                     cond$call), session = sessionInformation(), 
[17:46:49.131]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.131]                   signalCondition(cond)
[17:46:49.131]                 }
[17:46:49.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.131]                 "immediateCondition"))) {
[17:46:49.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.131]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.131]                   if (TRUE && !signal) {
[17:46:49.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.131]                     {
[17:46:49.131]                       inherits <- base::inherits
[17:46:49.131]                       invokeRestart <- base::invokeRestart
[17:46:49.131]                       is.null <- base::is.null
[17:46:49.131]                       muffled <- FALSE
[17:46:49.131]                       if (inherits(cond, "message")) {
[17:46:49.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.131]                         if (muffled) 
[17:46:49.131]                           invokeRestart("muffleMessage")
[17:46:49.131]                       }
[17:46:49.131]                       else if (inherits(cond, "warning")) {
[17:46:49.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.131]                         if (muffled) 
[17:46:49.131]                           invokeRestart("muffleWarning")
[17:46:49.131]                       }
[17:46:49.131]                       else if (inherits(cond, "condition")) {
[17:46:49.131]                         if (!is.null(pattern)) {
[17:46:49.131]                           computeRestarts <- base::computeRestarts
[17:46:49.131]                           grepl <- base::grepl
[17:46:49.131]                           restarts <- computeRestarts(cond)
[17:46:49.131]                           for (restart in restarts) {
[17:46:49.131]                             name <- restart$name
[17:46:49.131]                             if (is.null(name)) 
[17:46:49.131]                               next
[17:46:49.131]                             if (!grepl(pattern, name)) 
[17:46:49.131]                               next
[17:46:49.131]                             invokeRestart(restart)
[17:46:49.131]                             muffled <- TRUE
[17:46:49.131]                             break
[17:46:49.131]                           }
[17:46:49.131]                         }
[17:46:49.131]                       }
[17:46:49.131]                       invisible(muffled)
[17:46:49.131]                     }
[17:46:49.131]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.131]                   }
[17:46:49.131]                 }
[17:46:49.131]                 else {
[17:46:49.131]                   if (TRUE) {
[17:46:49.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.131]                     {
[17:46:49.131]                       inherits <- base::inherits
[17:46:49.131]                       invokeRestart <- base::invokeRestart
[17:46:49.131]                       is.null <- base::is.null
[17:46:49.131]                       muffled <- FALSE
[17:46:49.131]                       if (inherits(cond, "message")) {
[17:46:49.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.131]                         if (muffled) 
[17:46:49.131]                           invokeRestart("muffleMessage")
[17:46:49.131]                       }
[17:46:49.131]                       else if (inherits(cond, "warning")) {
[17:46:49.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.131]                         if (muffled) 
[17:46:49.131]                           invokeRestart("muffleWarning")
[17:46:49.131]                       }
[17:46:49.131]                       else if (inherits(cond, "condition")) {
[17:46:49.131]                         if (!is.null(pattern)) {
[17:46:49.131]                           computeRestarts <- base::computeRestarts
[17:46:49.131]                           grepl <- base::grepl
[17:46:49.131]                           restarts <- computeRestarts(cond)
[17:46:49.131]                           for (restart in restarts) {
[17:46:49.131]                             name <- restart$name
[17:46:49.131]                             if (is.null(name)) 
[17:46:49.131]                               next
[17:46:49.131]                             if (!grepl(pattern, name)) 
[17:46:49.131]                               next
[17:46:49.131]                             invokeRestart(restart)
[17:46:49.131]                             muffled <- TRUE
[17:46:49.131]                             break
[17:46:49.131]                           }
[17:46:49.131]                         }
[17:46:49.131]                       }
[17:46:49.131]                       invisible(muffled)
[17:46:49.131]                     }
[17:46:49.131]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.131]                   }
[17:46:49.131]                 }
[17:46:49.131]             }
[17:46:49.131]         }))
[17:46:49.131]     }, error = function(ex) {
[17:46:49.131]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.131]                 ...future.rng), started = ...future.startTime, 
[17:46:49.131]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.131]             version = "1.8"), class = "FutureResult")
[17:46:49.131]     }, finally = {
[17:46:49.131]         if (!identical(...future.workdir, getwd())) 
[17:46:49.131]             setwd(...future.workdir)
[17:46:49.131]         {
[17:46:49.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.131]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.131]             }
[17:46:49.131]             base::options(...future.oldOptions)
[17:46:49.131]             if (.Platform$OS.type == "windows") {
[17:46:49.131]                 old_names <- names(...future.oldEnvVars)
[17:46:49.131]                 envs <- base::Sys.getenv()
[17:46:49.131]                 names <- names(envs)
[17:46:49.131]                 common <- intersect(names, old_names)
[17:46:49.131]                 added <- setdiff(names, old_names)
[17:46:49.131]                 removed <- setdiff(old_names, names)
[17:46:49.131]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.131]                   envs[common]]
[17:46:49.131]                 NAMES <- toupper(changed)
[17:46:49.131]                 args <- list()
[17:46:49.131]                 for (kk in seq_along(NAMES)) {
[17:46:49.131]                   name <- changed[[kk]]
[17:46:49.131]                   NAME <- NAMES[[kk]]
[17:46:49.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.131]                     next
[17:46:49.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.131]                 }
[17:46:49.131]                 NAMES <- toupper(added)
[17:46:49.131]                 for (kk in seq_along(NAMES)) {
[17:46:49.131]                   name <- added[[kk]]
[17:46:49.131]                   NAME <- NAMES[[kk]]
[17:46:49.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.131]                     next
[17:46:49.131]                   args[[name]] <- ""
[17:46:49.131]                 }
[17:46:49.131]                 NAMES <- toupper(removed)
[17:46:49.131]                 for (kk in seq_along(NAMES)) {
[17:46:49.131]                   name <- removed[[kk]]
[17:46:49.131]                   NAME <- NAMES[[kk]]
[17:46:49.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.131]                     next
[17:46:49.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.131]                 }
[17:46:49.131]                 if (length(args) > 0) 
[17:46:49.131]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.131]             }
[17:46:49.131]             else {
[17:46:49.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.131]             }
[17:46:49.131]             {
[17:46:49.131]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.131]                   0L) {
[17:46:49.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.131]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.131]                   base::options(opts)
[17:46:49.131]                 }
[17:46:49.131]                 {
[17:46:49.131]                   {
[17:46:49.131]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.131]                     NULL
[17:46:49.131]                   }
[17:46:49.131]                   options(future.plan = NULL)
[17:46:49.131]                   if (is.na(NA_character_)) 
[17:46:49.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.131]                     .init = FALSE)
[17:46:49.131]                 }
[17:46:49.131]             }
[17:46:49.131]         }
[17:46:49.131]     })
[17:46:49.131]     if (TRUE) {
[17:46:49.131]         base::sink(type = "output", split = FALSE)
[17:46:49.131]         if (TRUE) {
[17:46:49.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.131]         }
[17:46:49.131]         else {
[17:46:49.131]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.131]         }
[17:46:49.131]         base::close(...future.stdout)
[17:46:49.131]         ...future.stdout <- NULL
[17:46:49.131]     }
[17:46:49.131]     ...future.result$conditions <- ...future.conditions
[17:46:49.131]     ...future.result$finished <- base::Sys.time()
[17:46:49.131]     ...future.result
[17:46:49.131] }
[17:46:49.133] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:49.144] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.144] - Validating connection of MultisessionFuture
[17:46:49.144] - received message: FutureResult
[17:46:49.145] - Received FutureResult
[17:46:49.145] - Erased future from FutureRegistry
[17:46:49.145] result() for ClusterFuture ...
[17:46:49.145] - result already collected: FutureResult
[17:46:49.145] result() for ClusterFuture ... done
[17:46:49.145] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.145] result() for ClusterFuture ...
[17:46:49.145] - result already collected: FutureResult
[17:46:49.145] result() for ClusterFuture ... done
[17:46:49.145] result() for ClusterFuture ...
[17:46:49.146] - result already collected: FutureResult
[17:46:49.146] result() for ClusterFuture ... done
[17:46:49.147] MultisessionFuture started
[17:46:49.147] - Launch lazy future ... done
[17:46:49.147] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x561789189480> 
Classes 'listenv', 'environment' <environment: 0x5617882d1bb0> 
[17:46:49.150] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.150] - Validating connection of MultisessionFuture
[17:46:49.150] - received message: FutureResult
[17:46:49.150] - Received FutureResult
[17:46:49.150] - Erased future from FutureRegistry
[17:46:49.150] result() for ClusterFuture ...
[17:46:49.150] - result already collected: FutureResult
[17:46:49.150] result() for ClusterFuture ... done
[17:46:49.150] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.152] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.152] - Validating connection of MultisessionFuture
[17:46:49.152] - received message: FutureResult
[17:46:49.152] - Received FutureResult
[17:46:49.152] - Erased future from FutureRegistry
[17:46:49.153] result() for ClusterFuture ...
[17:46:49.153] - result already collected: FutureResult
[17:46:49.153] result() for ClusterFuture ... done
[17:46:49.153] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:49.154] resolve() on list environment ...
[17:46:49.154]  recursive: 0
[17:46:49.155]  length: 6
[17:46:49.155]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:49.156] signalConditionsASAP(numeric, pos=1) ...
[17:46:49.156] - nx: 6
[17:46:49.156] - relay: TRUE
[17:46:49.156] - stdout: TRUE
[17:46:49.156] - signal: TRUE
[17:46:49.156] - resignal: FALSE
[17:46:49.156] - force: TRUE
[17:46:49.156] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.156] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.156]  - until=2
[17:46:49.156]  - relaying element #2
[17:46:49.156] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.157] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.157] signalConditionsASAP(NULL, pos=1) ... done
[17:46:49.157]  length: 5 (resolved future 1)
[17:46:49.157] Future #2
[17:46:49.157] result() for ClusterFuture ...
[17:46:49.157] - result already collected: FutureResult
[17:46:49.157] result() for ClusterFuture ... done
[17:46:49.157] result() for ClusterFuture ...
[17:46:49.157] - result already collected: FutureResult
[17:46:49.157] result() for ClusterFuture ... done
[17:46:49.158] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:49.158] - nx: 6
[17:46:49.158] - relay: TRUE
[17:46:49.158] - stdout: TRUE
[17:46:49.158] - signal: TRUE
[17:46:49.158] - resignal: FALSE
[17:46:49.158] - force: TRUE
[17:46:49.158] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.158] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.158]  - until=2
[17:46:49.158]  - relaying element #2
[17:46:49.158] result() for ClusterFuture ...
[17:46:49.159] - result already collected: FutureResult
[17:46:49.159] result() for ClusterFuture ... done
[17:46:49.159] result() for ClusterFuture ...
[17:46:49.159] - result already collected: FutureResult
[17:46:49.159] result() for ClusterFuture ... done
[17:46:49.159] result() for ClusterFuture ...
[17:46:49.159] - result already collected: FutureResult
[17:46:49.159] result() for ClusterFuture ... done
[17:46:49.159] result() for ClusterFuture ...
[17:46:49.159] - result already collected: FutureResult
[17:46:49.159] result() for ClusterFuture ... done
[17:46:49.159] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.160] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.160] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:49.160]  length: 4 (resolved future 2)
[17:46:49.160] Future #3
[17:46:49.160] result() for ClusterFuture ...
[17:46:49.160] - result already collected: FutureResult
[17:46:49.160] result() for ClusterFuture ... done
[17:46:49.160] result() for ClusterFuture ...
[17:46:49.160] - result already collected: FutureResult
[17:46:49.160] result() for ClusterFuture ... done
[17:46:49.161] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:49.161] - nx: 6
[17:46:49.161] - relay: TRUE
[17:46:49.161] - stdout: TRUE
[17:46:49.161] - signal: TRUE
[17:46:49.161] - resignal: FALSE
[17:46:49.161] - force: TRUE
[17:46:49.161] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.161] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.161]  - until=3
[17:46:49.161]  - relaying element #3
[17:46:49.161] result() for ClusterFuture ...
[17:46:49.162] - result already collected: FutureResult
[17:46:49.162] result() for ClusterFuture ... done
[17:46:49.162] result() for ClusterFuture ...
[17:46:49.162] - result already collected: FutureResult
[17:46:49.162] result() for ClusterFuture ... done
[17:46:49.162] result() for ClusterFuture ...
[17:46:49.162] - result already collected: FutureResult
[17:46:49.162] result() for ClusterFuture ... done
[17:46:49.162] result() for ClusterFuture ...
[17:46:49.162] - result already collected: FutureResult
[17:46:49.162] result() for ClusterFuture ... done
[17:46:49.162] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.163] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.163] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:49.163]  length: 3 (resolved future 3)
[17:46:49.163] Future #4
[17:46:49.163] result() for ClusterFuture ...
[17:46:49.163] - result already collected: FutureResult
[17:46:49.163] result() for ClusterFuture ... done
[17:46:49.163] result() for ClusterFuture ...
[17:46:49.163] - result already collected: FutureResult
[17:46:49.163] result() for ClusterFuture ... done
[17:46:49.164] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:49.164] - nx: 6
[17:46:49.164] - relay: TRUE
[17:46:49.164] - stdout: TRUE
[17:46:49.164] - signal: TRUE
[17:46:49.164] - resignal: FALSE
[17:46:49.164] - force: TRUE
[17:46:49.164] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.164] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.164]  - until=4
[17:46:49.164]  - relaying element #4
[17:46:49.165] result() for ClusterFuture ...
[17:46:49.165] - result already collected: FutureResult
[17:46:49.165] result() for ClusterFuture ... done
[17:46:49.165] result() for ClusterFuture ...
[17:46:49.165] - result already collected: FutureResult
[17:46:49.165] result() for ClusterFuture ... done
[17:46:49.165] result() for ClusterFuture ...
[17:46:49.165] - result already collected: FutureResult
[17:46:49.165] result() for ClusterFuture ... done
[17:46:49.165] result() for ClusterFuture ...
[17:46:49.165] - result already collected: FutureResult
[17:46:49.165] result() for ClusterFuture ... done
[17:46:49.166] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.166] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.166] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:49.166]  length: 2 (resolved future 4)
[17:46:49.166] signalConditionsASAP(NULL, pos=5) ...
[17:46:49.166] - nx: 6
[17:46:49.166] - relay: TRUE
[17:46:49.166] - stdout: TRUE
[17:46:49.166] - signal: TRUE
[17:46:49.166] - resignal: FALSE
[17:46:49.166] - force: TRUE
[17:46:49.167] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.167] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.167]  - until=6
[17:46:49.167]  - relaying element #6
[17:46:49.167] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.167] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.167] signalConditionsASAP(NULL, pos=5) ... done
[17:46:49.167]  length: 1 (resolved future 5)
[17:46:49.167] signalConditionsASAP(numeric, pos=6) ...
[17:46:49.167] - nx: 6
[17:46:49.167] - relay: TRUE
[17:46:49.168] - stdout: TRUE
[17:46:49.168] - signal: TRUE
[17:46:49.168] - resignal: FALSE
[17:46:49.168] - force: TRUE
[17:46:49.168] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.168] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.168]  - until=6
[17:46:49.168] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.168] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.168] signalConditionsASAP(numeric, pos=6) ... done
[17:46:49.168]  length: 0 (resolved future 6)
[17:46:49.169] Relaying remaining futures
[17:46:49.169] signalConditionsASAP(NULL, pos=0) ...
[17:46:49.169] - nx: 6
[17:46:49.169] - relay: TRUE
[17:46:49.169] - stdout: TRUE
[17:46:49.169] - signal: TRUE
[17:46:49.169] - resignal: FALSE
[17:46:49.169] - force: TRUE
[17:46:49.169] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.169] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:49.169] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.169] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.170] signalConditionsASAP(NULL, pos=0) ... done
[17:46:49.170] resolve() on list environment ... DONE
[17:46:49.170] result() for ClusterFuture ...
[17:46:49.170] - result already collected: FutureResult
[17:46:49.170] result() for ClusterFuture ... done
[17:46:49.170] result() for ClusterFuture ...
[17:46:49.170] - result already collected: FutureResult
[17:46:49.170] result() for ClusterFuture ... done
[17:46:49.170] result() for ClusterFuture ...
[17:46:49.170] - result already collected: FutureResult
[17:46:49.171] result() for ClusterFuture ... done
[17:46:49.171] result() for ClusterFuture ...
[17:46:49.171] - result already collected: FutureResult
[17:46:49.171] result() for ClusterFuture ... done
[17:46:49.171] result() for ClusterFuture ...
[17:46:49.171] - result already collected: FutureResult
[17:46:49.171] result() for ClusterFuture ... done
[17:46:49.171] result() for ClusterFuture ...
[17:46:49.171] - result already collected: FutureResult
[17:46:49.171] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x561787bf4900> 
Dimensions: c(1, 6)
[17:46:49.172] getGlobalsAndPackages() ...
[17:46:49.172] Searching for globals...
[17:46:49.172] 
[17:46:49.172] Searching for globals ... DONE
[17:46:49.173] - globals: [0] <none>
[17:46:49.173] getGlobalsAndPackages() ... DONE
[17:46:49.173] run() for ‘Future’ ...
[17:46:49.173] - state: ‘created’
[17:46:49.173] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.187]   - Field: ‘node’
[17:46:49.187]   - Field: ‘label’
[17:46:49.188]   - Field: ‘local’
[17:46:49.188]   - Field: ‘owner’
[17:46:49.188]   - Field: ‘envir’
[17:46:49.188]   - Field: ‘workers’
[17:46:49.188]   - Field: ‘packages’
[17:46:49.188]   - Field: ‘gc’
[17:46:49.188]   - Field: ‘conditions’
[17:46:49.188]   - Field: ‘persistent’
[17:46:49.188]   - Field: ‘expr’
[17:46:49.188]   - Field: ‘uuid’
[17:46:49.188]   - Field: ‘seed’
[17:46:49.189]   - Field: ‘version’
[17:46:49.189]   - Field: ‘result’
[17:46:49.189]   - Field: ‘asynchronous’
[17:46:49.189]   - Field: ‘calls’
[17:46:49.189]   - Field: ‘globals’
[17:46:49.189]   - Field: ‘stdout’
[17:46:49.189]   - Field: ‘earlySignal’
[17:46:49.189]   - Field: ‘lazy’
[17:46:49.189]   - Field: ‘state’
[17:46:49.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.189] - Launch lazy future ...
[17:46:49.190] Packages needed by the future expression (n = 0): <none>
[17:46:49.190] Packages needed by future strategies (n = 0): <none>
[17:46:49.190] {
[17:46:49.190]     {
[17:46:49.190]         {
[17:46:49.190]             ...future.startTime <- base::Sys.time()
[17:46:49.190]             {
[17:46:49.190]                 {
[17:46:49.190]                   {
[17:46:49.190]                     {
[17:46:49.190]                       base::local({
[17:46:49.190]                         has_future <- base::requireNamespace("future", 
[17:46:49.190]                           quietly = TRUE)
[17:46:49.190]                         if (has_future) {
[17:46:49.190]                           ns <- base::getNamespace("future")
[17:46:49.190]                           version <- ns[[".package"]][["version"]]
[17:46:49.190]                           if (is.null(version)) 
[17:46:49.190]                             version <- utils::packageVersion("future")
[17:46:49.190]                         }
[17:46:49.190]                         else {
[17:46:49.190]                           version <- NULL
[17:46:49.190]                         }
[17:46:49.190]                         if (!has_future || version < "1.8.0") {
[17:46:49.190]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.190]                             "", base::R.version$version.string), 
[17:46:49.190]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.190]                               "release", "version")], collapse = " "), 
[17:46:49.190]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.190]                             info)
[17:46:49.190]                           info <- base::paste(info, collapse = "; ")
[17:46:49.190]                           if (!has_future) {
[17:46:49.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.190]                               info)
[17:46:49.190]                           }
[17:46:49.190]                           else {
[17:46:49.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.190]                               info, version)
[17:46:49.190]                           }
[17:46:49.190]                           base::stop(msg)
[17:46:49.190]                         }
[17:46:49.190]                       })
[17:46:49.190]                     }
[17:46:49.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.190]                     base::options(mc.cores = 1L)
[17:46:49.190]                   }
[17:46:49.190]                   ...future.strategy.old <- future::plan("list")
[17:46:49.190]                   options(future.plan = NULL)
[17:46:49.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.190]                 }
[17:46:49.190]                 ...future.workdir <- getwd()
[17:46:49.190]             }
[17:46:49.190]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.190]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.190]         }
[17:46:49.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.190]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.190]             base::names(...future.oldOptions))
[17:46:49.190]     }
[17:46:49.190]     if (FALSE) {
[17:46:49.190]     }
[17:46:49.190]     else {
[17:46:49.190]         if (TRUE) {
[17:46:49.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.190]                 open = "w")
[17:46:49.190]         }
[17:46:49.190]         else {
[17:46:49.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.190]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.190]         }
[17:46:49.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.190]             base::sink(type = "output", split = FALSE)
[17:46:49.190]             base::close(...future.stdout)
[17:46:49.190]         }, add = TRUE)
[17:46:49.190]     }
[17:46:49.190]     ...future.frame <- base::sys.nframe()
[17:46:49.190]     ...future.conditions <- base::list()
[17:46:49.190]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.190]     if (FALSE) {
[17:46:49.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.190]     }
[17:46:49.190]     ...future.result <- base::tryCatch({
[17:46:49.190]         base::withCallingHandlers({
[17:46:49.190]             ...future.value <- base::withVisible(base::local({
[17:46:49.190]                 ...future.makeSendCondition <- base::local({
[17:46:49.190]                   sendCondition <- NULL
[17:46:49.190]                   function(frame = 1L) {
[17:46:49.190]                     if (is.function(sendCondition)) 
[17:46:49.190]                       return(sendCondition)
[17:46:49.190]                     ns <- getNamespace("parallel")
[17:46:49.190]                     if (exists("sendData", mode = "function", 
[17:46:49.190]                       envir = ns)) {
[17:46:49.190]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.190]                         envir = ns)
[17:46:49.190]                       envir <- sys.frame(frame)
[17:46:49.190]                       master <- NULL
[17:46:49.190]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.190]                         !identical(envir, emptyenv())) {
[17:46:49.190]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.190]                           inherits = FALSE)) {
[17:46:49.190]                           master <- get("master", mode = "list", 
[17:46:49.190]                             envir = envir, inherits = FALSE)
[17:46:49.190]                           if (inherits(master, c("SOCKnode", 
[17:46:49.190]                             "SOCK0node"))) {
[17:46:49.190]                             sendCondition <<- function(cond) {
[17:46:49.190]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.190]                                 success = TRUE)
[17:46:49.190]                               parallel_sendData(master, data)
[17:46:49.190]                             }
[17:46:49.190]                             return(sendCondition)
[17:46:49.190]                           }
[17:46:49.190]                         }
[17:46:49.190]                         frame <- frame + 1L
[17:46:49.190]                         envir <- sys.frame(frame)
[17:46:49.190]                       }
[17:46:49.190]                     }
[17:46:49.190]                     sendCondition <<- function(cond) NULL
[17:46:49.190]                   }
[17:46:49.190]                 })
[17:46:49.190]                 withCallingHandlers({
[17:46:49.190]                   2
[17:46:49.190]                 }, immediateCondition = function(cond) {
[17:46:49.190]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.190]                   sendCondition(cond)
[17:46:49.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.190]                   {
[17:46:49.190]                     inherits <- base::inherits
[17:46:49.190]                     invokeRestart <- base::invokeRestart
[17:46:49.190]                     is.null <- base::is.null
[17:46:49.190]                     muffled <- FALSE
[17:46:49.190]                     if (inherits(cond, "message")) {
[17:46:49.190]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.190]                       if (muffled) 
[17:46:49.190]                         invokeRestart("muffleMessage")
[17:46:49.190]                     }
[17:46:49.190]                     else if (inherits(cond, "warning")) {
[17:46:49.190]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.190]                       if (muffled) 
[17:46:49.190]                         invokeRestart("muffleWarning")
[17:46:49.190]                     }
[17:46:49.190]                     else if (inherits(cond, "condition")) {
[17:46:49.190]                       if (!is.null(pattern)) {
[17:46:49.190]                         computeRestarts <- base::computeRestarts
[17:46:49.190]                         grepl <- base::grepl
[17:46:49.190]                         restarts <- computeRestarts(cond)
[17:46:49.190]                         for (restart in restarts) {
[17:46:49.190]                           name <- restart$name
[17:46:49.190]                           if (is.null(name)) 
[17:46:49.190]                             next
[17:46:49.190]                           if (!grepl(pattern, name)) 
[17:46:49.190]                             next
[17:46:49.190]                           invokeRestart(restart)
[17:46:49.190]                           muffled <- TRUE
[17:46:49.190]                           break
[17:46:49.190]                         }
[17:46:49.190]                       }
[17:46:49.190]                     }
[17:46:49.190]                     invisible(muffled)
[17:46:49.190]                   }
[17:46:49.190]                   muffleCondition(cond)
[17:46:49.190]                 })
[17:46:49.190]             }))
[17:46:49.190]             future::FutureResult(value = ...future.value$value, 
[17:46:49.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.190]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.190]                     ...future.globalenv.names))
[17:46:49.190]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.190]         }, condition = base::local({
[17:46:49.190]             c <- base::c
[17:46:49.190]             inherits <- base::inherits
[17:46:49.190]             invokeRestart <- base::invokeRestart
[17:46:49.190]             length <- base::length
[17:46:49.190]             list <- base::list
[17:46:49.190]             seq.int <- base::seq.int
[17:46:49.190]             signalCondition <- base::signalCondition
[17:46:49.190]             sys.calls <- base::sys.calls
[17:46:49.190]             `[[` <- base::`[[`
[17:46:49.190]             `+` <- base::`+`
[17:46:49.190]             `<<-` <- base::`<<-`
[17:46:49.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.190]                   3L)]
[17:46:49.190]             }
[17:46:49.190]             function(cond) {
[17:46:49.190]                 is_error <- inherits(cond, "error")
[17:46:49.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.190]                   NULL)
[17:46:49.190]                 if (is_error) {
[17:46:49.190]                   sessionInformation <- function() {
[17:46:49.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.190]                       search = base::search(), system = base::Sys.info())
[17:46:49.190]                   }
[17:46:49.190]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.190]                     cond$call), session = sessionInformation(), 
[17:46:49.190]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.190]                   signalCondition(cond)
[17:46:49.190]                 }
[17:46:49.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.190]                 "immediateCondition"))) {
[17:46:49.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.190]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.190]                   if (TRUE && !signal) {
[17:46:49.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.190]                     {
[17:46:49.190]                       inherits <- base::inherits
[17:46:49.190]                       invokeRestart <- base::invokeRestart
[17:46:49.190]                       is.null <- base::is.null
[17:46:49.190]                       muffled <- FALSE
[17:46:49.190]                       if (inherits(cond, "message")) {
[17:46:49.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.190]                         if (muffled) 
[17:46:49.190]                           invokeRestart("muffleMessage")
[17:46:49.190]                       }
[17:46:49.190]                       else if (inherits(cond, "warning")) {
[17:46:49.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.190]                         if (muffled) 
[17:46:49.190]                           invokeRestart("muffleWarning")
[17:46:49.190]                       }
[17:46:49.190]                       else if (inherits(cond, "condition")) {
[17:46:49.190]                         if (!is.null(pattern)) {
[17:46:49.190]                           computeRestarts <- base::computeRestarts
[17:46:49.190]                           grepl <- base::grepl
[17:46:49.190]                           restarts <- computeRestarts(cond)
[17:46:49.190]                           for (restart in restarts) {
[17:46:49.190]                             name <- restart$name
[17:46:49.190]                             if (is.null(name)) 
[17:46:49.190]                               next
[17:46:49.190]                             if (!grepl(pattern, name)) 
[17:46:49.190]                               next
[17:46:49.190]                             invokeRestart(restart)
[17:46:49.190]                             muffled <- TRUE
[17:46:49.190]                             break
[17:46:49.190]                           }
[17:46:49.190]                         }
[17:46:49.190]                       }
[17:46:49.190]                       invisible(muffled)
[17:46:49.190]                     }
[17:46:49.190]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.190]                   }
[17:46:49.190]                 }
[17:46:49.190]                 else {
[17:46:49.190]                   if (TRUE) {
[17:46:49.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.190]                     {
[17:46:49.190]                       inherits <- base::inherits
[17:46:49.190]                       invokeRestart <- base::invokeRestart
[17:46:49.190]                       is.null <- base::is.null
[17:46:49.190]                       muffled <- FALSE
[17:46:49.190]                       if (inherits(cond, "message")) {
[17:46:49.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.190]                         if (muffled) 
[17:46:49.190]                           invokeRestart("muffleMessage")
[17:46:49.190]                       }
[17:46:49.190]                       else if (inherits(cond, "warning")) {
[17:46:49.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.190]                         if (muffled) 
[17:46:49.190]                           invokeRestart("muffleWarning")
[17:46:49.190]                       }
[17:46:49.190]                       else if (inherits(cond, "condition")) {
[17:46:49.190]                         if (!is.null(pattern)) {
[17:46:49.190]                           computeRestarts <- base::computeRestarts
[17:46:49.190]                           grepl <- base::grepl
[17:46:49.190]                           restarts <- computeRestarts(cond)
[17:46:49.190]                           for (restart in restarts) {
[17:46:49.190]                             name <- restart$name
[17:46:49.190]                             if (is.null(name)) 
[17:46:49.190]                               next
[17:46:49.190]                             if (!grepl(pattern, name)) 
[17:46:49.190]                               next
[17:46:49.190]                             invokeRestart(restart)
[17:46:49.190]                             muffled <- TRUE
[17:46:49.190]                             break
[17:46:49.190]                           }
[17:46:49.190]                         }
[17:46:49.190]                       }
[17:46:49.190]                       invisible(muffled)
[17:46:49.190]                     }
[17:46:49.190]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.190]                   }
[17:46:49.190]                 }
[17:46:49.190]             }
[17:46:49.190]         }))
[17:46:49.190]     }, error = function(ex) {
[17:46:49.190]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.190]                 ...future.rng), started = ...future.startTime, 
[17:46:49.190]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.190]             version = "1.8"), class = "FutureResult")
[17:46:49.190]     }, finally = {
[17:46:49.190]         if (!identical(...future.workdir, getwd())) 
[17:46:49.190]             setwd(...future.workdir)
[17:46:49.190]         {
[17:46:49.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.190]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.190]             }
[17:46:49.190]             base::options(...future.oldOptions)
[17:46:49.190]             if (.Platform$OS.type == "windows") {
[17:46:49.190]                 old_names <- names(...future.oldEnvVars)
[17:46:49.190]                 envs <- base::Sys.getenv()
[17:46:49.190]                 names <- names(envs)
[17:46:49.190]                 common <- intersect(names, old_names)
[17:46:49.190]                 added <- setdiff(names, old_names)
[17:46:49.190]                 removed <- setdiff(old_names, names)
[17:46:49.190]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.190]                   envs[common]]
[17:46:49.190]                 NAMES <- toupper(changed)
[17:46:49.190]                 args <- list()
[17:46:49.190]                 for (kk in seq_along(NAMES)) {
[17:46:49.190]                   name <- changed[[kk]]
[17:46:49.190]                   NAME <- NAMES[[kk]]
[17:46:49.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.190]                     next
[17:46:49.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.190]                 }
[17:46:49.190]                 NAMES <- toupper(added)
[17:46:49.190]                 for (kk in seq_along(NAMES)) {
[17:46:49.190]                   name <- added[[kk]]
[17:46:49.190]                   NAME <- NAMES[[kk]]
[17:46:49.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.190]                     next
[17:46:49.190]                   args[[name]] <- ""
[17:46:49.190]                 }
[17:46:49.190]                 NAMES <- toupper(removed)
[17:46:49.190]                 for (kk in seq_along(NAMES)) {
[17:46:49.190]                   name <- removed[[kk]]
[17:46:49.190]                   NAME <- NAMES[[kk]]
[17:46:49.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.190]                     next
[17:46:49.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.190]                 }
[17:46:49.190]                 if (length(args) > 0) 
[17:46:49.190]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.190]             }
[17:46:49.190]             else {
[17:46:49.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.190]             }
[17:46:49.190]             {
[17:46:49.190]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.190]                   0L) {
[17:46:49.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.190]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.190]                   base::options(opts)
[17:46:49.190]                 }
[17:46:49.190]                 {
[17:46:49.190]                   {
[17:46:49.190]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.190]                     NULL
[17:46:49.190]                   }
[17:46:49.190]                   options(future.plan = NULL)
[17:46:49.190]                   if (is.na(NA_character_)) 
[17:46:49.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.190]                     .init = FALSE)
[17:46:49.190]                 }
[17:46:49.190]             }
[17:46:49.190]         }
[17:46:49.190]     })
[17:46:49.190]     if (TRUE) {
[17:46:49.190]         base::sink(type = "output", split = FALSE)
[17:46:49.190]         if (TRUE) {
[17:46:49.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.190]         }
[17:46:49.190]         else {
[17:46:49.190]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.190]         }
[17:46:49.190]         base::close(...future.stdout)
[17:46:49.190]         ...future.stdout <- NULL
[17:46:49.190]     }
[17:46:49.190]     ...future.result$conditions <- ...future.conditions
[17:46:49.190]     ...future.result$finished <- base::Sys.time()
[17:46:49.190]     ...future.result
[17:46:49.190] }
[17:46:49.193] MultisessionFuture started
[17:46:49.193] - Launch lazy future ... done
[17:46:49.193] run() for ‘MultisessionFuture’ ... done
[17:46:49.194] getGlobalsAndPackages() ...
[17:46:49.194] Searching for globals...
[17:46:49.194] 
[17:46:49.194] Searching for globals ... DONE
[17:46:49.194] - globals: [0] <none>
[17:46:49.194] getGlobalsAndPackages() ... DONE
[17:46:49.195] run() for ‘Future’ ...
[17:46:49.195] - state: ‘created’
[17:46:49.195] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.208]   - Field: ‘node’
[17:46:49.209]   - Field: ‘label’
[17:46:49.209]   - Field: ‘local’
[17:46:49.209]   - Field: ‘owner’
[17:46:49.209]   - Field: ‘envir’
[17:46:49.209]   - Field: ‘workers’
[17:46:49.209]   - Field: ‘packages’
[17:46:49.209]   - Field: ‘gc’
[17:46:49.209]   - Field: ‘conditions’
[17:46:49.209]   - Field: ‘persistent’
[17:46:49.209]   - Field: ‘expr’
[17:46:49.209]   - Field: ‘uuid’
[17:46:49.210]   - Field: ‘seed’
[17:46:49.210]   - Field: ‘version’
[17:46:49.210]   - Field: ‘result’
[17:46:49.210]   - Field: ‘asynchronous’
[17:46:49.210]   - Field: ‘calls’
[17:46:49.210]   - Field: ‘globals’
[17:46:49.210]   - Field: ‘stdout’
[17:46:49.210]   - Field: ‘earlySignal’
[17:46:49.210]   - Field: ‘lazy’
[17:46:49.210]   - Field: ‘state’
[17:46:49.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.211] - Launch lazy future ...
[17:46:49.211] Packages needed by the future expression (n = 0): <none>
[17:46:49.211] Packages needed by future strategies (n = 0): <none>
[17:46:49.211] {
[17:46:49.211]     {
[17:46:49.211]         {
[17:46:49.211]             ...future.startTime <- base::Sys.time()
[17:46:49.211]             {
[17:46:49.211]                 {
[17:46:49.211]                   {
[17:46:49.211]                     {
[17:46:49.211]                       base::local({
[17:46:49.211]                         has_future <- base::requireNamespace("future", 
[17:46:49.211]                           quietly = TRUE)
[17:46:49.211]                         if (has_future) {
[17:46:49.211]                           ns <- base::getNamespace("future")
[17:46:49.211]                           version <- ns[[".package"]][["version"]]
[17:46:49.211]                           if (is.null(version)) 
[17:46:49.211]                             version <- utils::packageVersion("future")
[17:46:49.211]                         }
[17:46:49.211]                         else {
[17:46:49.211]                           version <- NULL
[17:46:49.211]                         }
[17:46:49.211]                         if (!has_future || version < "1.8.0") {
[17:46:49.211]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.211]                             "", base::R.version$version.string), 
[17:46:49.211]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.211]                               "release", "version")], collapse = " "), 
[17:46:49.211]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.211]                             info)
[17:46:49.211]                           info <- base::paste(info, collapse = "; ")
[17:46:49.211]                           if (!has_future) {
[17:46:49.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.211]                               info)
[17:46:49.211]                           }
[17:46:49.211]                           else {
[17:46:49.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.211]                               info, version)
[17:46:49.211]                           }
[17:46:49.211]                           base::stop(msg)
[17:46:49.211]                         }
[17:46:49.211]                       })
[17:46:49.211]                     }
[17:46:49.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.211]                     base::options(mc.cores = 1L)
[17:46:49.211]                   }
[17:46:49.211]                   ...future.strategy.old <- future::plan("list")
[17:46:49.211]                   options(future.plan = NULL)
[17:46:49.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.211]                 }
[17:46:49.211]                 ...future.workdir <- getwd()
[17:46:49.211]             }
[17:46:49.211]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.211]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.211]         }
[17:46:49.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.211]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.211]             base::names(...future.oldOptions))
[17:46:49.211]     }
[17:46:49.211]     if (FALSE) {
[17:46:49.211]     }
[17:46:49.211]     else {
[17:46:49.211]         if (TRUE) {
[17:46:49.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.211]                 open = "w")
[17:46:49.211]         }
[17:46:49.211]         else {
[17:46:49.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.211]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.211]         }
[17:46:49.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.211]             base::sink(type = "output", split = FALSE)
[17:46:49.211]             base::close(...future.stdout)
[17:46:49.211]         }, add = TRUE)
[17:46:49.211]     }
[17:46:49.211]     ...future.frame <- base::sys.nframe()
[17:46:49.211]     ...future.conditions <- base::list()
[17:46:49.211]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.211]     if (FALSE) {
[17:46:49.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.211]     }
[17:46:49.211]     ...future.result <- base::tryCatch({
[17:46:49.211]         base::withCallingHandlers({
[17:46:49.211]             ...future.value <- base::withVisible(base::local({
[17:46:49.211]                 ...future.makeSendCondition <- base::local({
[17:46:49.211]                   sendCondition <- NULL
[17:46:49.211]                   function(frame = 1L) {
[17:46:49.211]                     if (is.function(sendCondition)) 
[17:46:49.211]                       return(sendCondition)
[17:46:49.211]                     ns <- getNamespace("parallel")
[17:46:49.211]                     if (exists("sendData", mode = "function", 
[17:46:49.211]                       envir = ns)) {
[17:46:49.211]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.211]                         envir = ns)
[17:46:49.211]                       envir <- sys.frame(frame)
[17:46:49.211]                       master <- NULL
[17:46:49.211]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.211]                         !identical(envir, emptyenv())) {
[17:46:49.211]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.211]                           inherits = FALSE)) {
[17:46:49.211]                           master <- get("master", mode = "list", 
[17:46:49.211]                             envir = envir, inherits = FALSE)
[17:46:49.211]                           if (inherits(master, c("SOCKnode", 
[17:46:49.211]                             "SOCK0node"))) {
[17:46:49.211]                             sendCondition <<- function(cond) {
[17:46:49.211]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.211]                                 success = TRUE)
[17:46:49.211]                               parallel_sendData(master, data)
[17:46:49.211]                             }
[17:46:49.211]                             return(sendCondition)
[17:46:49.211]                           }
[17:46:49.211]                         }
[17:46:49.211]                         frame <- frame + 1L
[17:46:49.211]                         envir <- sys.frame(frame)
[17:46:49.211]                       }
[17:46:49.211]                     }
[17:46:49.211]                     sendCondition <<- function(cond) NULL
[17:46:49.211]                   }
[17:46:49.211]                 })
[17:46:49.211]                 withCallingHandlers({
[17:46:49.211]                   NULL
[17:46:49.211]                 }, immediateCondition = function(cond) {
[17:46:49.211]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.211]                   sendCondition(cond)
[17:46:49.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.211]                   {
[17:46:49.211]                     inherits <- base::inherits
[17:46:49.211]                     invokeRestart <- base::invokeRestart
[17:46:49.211]                     is.null <- base::is.null
[17:46:49.211]                     muffled <- FALSE
[17:46:49.211]                     if (inherits(cond, "message")) {
[17:46:49.211]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.211]                       if (muffled) 
[17:46:49.211]                         invokeRestart("muffleMessage")
[17:46:49.211]                     }
[17:46:49.211]                     else if (inherits(cond, "warning")) {
[17:46:49.211]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.211]                       if (muffled) 
[17:46:49.211]                         invokeRestart("muffleWarning")
[17:46:49.211]                     }
[17:46:49.211]                     else if (inherits(cond, "condition")) {
[17:46:49.211]                       if (!is.null(pattern)) {
[17:46:49.211]                         computeRestarts <- base::computeRestarts
[17:46:49.211]                         grepl <- base::grepl
[17:46:49.211]                         restarts <- computeRestarts(cond)
[17:46:49.211]                         for (restart in restarts) {
[17:46:49.211]                           name <- restart$name
[17:46:49.211]                           if (is.null(name)) 
[17:46:49.211]                             next
[17:46:49.211]                           if (!grepl(pattern, name)) 
[17:46:49.211]                             next
[17:46:49.211]                           invokeRestart(restart)
[17:46:49.211]                           muffled <- TRUE
[17:46:49.211]                           break
[17:46:49.211]                         }
[17:46:49.211]                       }
[17:46:49.211]                     }
[17:46:49.211]                     invisible(muffled)
[17:46:49.211]                   }
[17:46:49.211]                   muffleCondition(cond)
[17:46:49.211]                 })
[17:46:49.211]             }))
[17:46:49.211]             future::FutureResult(value = ...future.value$value, 
[17:46:49.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.211]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.211]                     ...future.globalenv.names))
[17:46:49.211]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.211]         }, condition = base::local({
[17:46:49.211]             c <- base::c
[17:46:49.211]             inherits <- base::inherits
[17:46:49.211]             invokeRestart <- base::invokeRestart
[17:46:49.211]             length <- base::length
[17:46:49.211]             list <- base::list
[17:46:49.211]             seq.int <- base::seq.int
[17:46:49.211]             signalCondition <- base::signalCondition
[17:46:49.211]             sys.calls <- base::sys.calls
[17:46:49.211]             `[[` <- base::`[[`
[17:46:49.211]             `+` <- base::`+`
[17:46:49.211]             `<<-` <- base::`<<-`
[17:46:49.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.211]                   3L)]
[17:46:49.211]             }
[17:46:49.211]             function(cond) {
[17:46:49.211]                 is_error <- inherits(cond, "error")
[17:46:49.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.211]                   NULL)
[17:46:49.211]                 if (is_error) {
[17:46:49.211]                   sessionInformation <- function() {
[17:46:49.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.211]                       search = base::search(), system = base::Sys.info())
[17:46:49.211]                   }
[17:46:49.211]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.211]                     cond$call), session = sessionInformation(), 
[17:46:49.211]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.211]                   signalCondition(cond)
[17:46:49.211]                 }
[17:46:49.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.211]                 "immediateCondition"))) {
[17:46:49.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.211]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.211]                   if (TRUE && !signal) {
[17:46:49.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.211]                     {
[17:46:49.211]                       inherits <- base::inherits
[17:46:49.211]                       invokeRestart <- base::invokeRestart
[17:46:49.211]                       is.null <- base::is.null
[17:46:49.211]                       muffled <- FALSE
[17:46:49.211]                       if (inherits(cond, "message")) {
[17:46:49.211]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.211]                         if (muffled) 
[17:46:49.211]                           invokeRestart("muffleMessage")
[17:46:49.211]                       }
[17:46:49.211]                       else if (inherits(cond, "warning")) {
[17:46:49.211]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.211]                         if (muffled) 
[17:46:49.211]                           invokeRestart("muffleWarning")
[17:46:49.211]                       }
[17:46:49.211]                       else if (inherits(cond, "condition")) {
[17:46:49.211]                         if (!is.null(pattern)) {
[17:46:49.211]                           computeRestarts <- base::computeRestarts
[17:46:49.211]                           grepl <- base::grepl
[17:46:49.211]                           restarts <- computeRestarts(cond)
[17:46:49.211]                           for (restart in restarts) {
[17:46:49.211]                             name <- restart$name
[17:46:49.211]                             if (is.null(name)) 
[17:46:49.211]                               next
[17:46:49.211]                             if (!grepl(pattern, name)) 
[17:46:49.211]                               next
[17:46:49.211]                             invokeRestart(restart)
[17:46:49.211]                             muffled <- TRUE
[17:46:49.211]                             break
[17:46:49.211]                           }
[17:46:49.211]                         }
[17:46:49.211]                       }
[17:46:49.211]                       invisible(muffled)
[17:46:49.211]                     }
[17:46:49.211]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.211]                   }
[17:46:49.211]                 }
[17:46:49.211]                 else {
[17:46:49.211]                   if (TRUE) {
[17:46:49.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.211]                     {
[17:46:49.211]                       inherits <- base::inherits
[17:46:49.211]                       invokeRestart <- base::invokeRestart
[17:46:49.211]                       is.null <- base::is.null
[17:46:49.211]                       muffled <- FALSE
[17:46:49.211]                       if (inherits(cond, "message")) {
[17:46:49.211]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.211]                         if (muffled) 
[17:46:49.211]                           invokeRestart("muffleMessage")
[17:46:49.211]                       }
[17:46:49.211]                       else if (inherits(cond, "warning")) {
[17:46:49.211]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.211]                         if (muffled) 
[17:46:49.211]                           invokeRestart("muffleWarning")
[17:46:49.211]                       }
[17:46:49.211]                       else if (inherits(cond, "condition")) {
[17:46:49.211]                         if (!is.null(pattern)) {
[17:46:49.211]                           computeRestarts <- base::computeRestarts
[17:46:49.211]                           grepl <- base::grepl
[17:46:49.211]                           restarts <- computeRestarts(cond)
[17:46:49.211]                           for (restart in restarts) {
[17:46:49.211]                             name <- restart$name
[17:46:49.211]                             if (is.null(name)) 
[17:46:49.211]                               next
[17:46:49.211]                             if (!grepl(pattern, name)) 
[17:46:49.211]                               next
[17:46:49.211]                             invokeRestart(restart)
[17:46:49.211]                             muffled <- TRUE
[17:46:49.211]                             break
[17:46:49.211]                           }
[17:46:49.211]                         }
[17:46:49.211]                       }
[17:46:49.211]                       invisible(muffled)
[17:46:49.211]                     }
[17:46:49.211]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.211]                   }
[17:46:49.211]                 }
[17:46:49.211]             }
[17:46:49.211]         }))
[17:46:49.211]     }, error = function(ex) {
[17:46:49.211]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.211]                 ...future.rng), started = ...future.startTime, 
[17:46:49.211]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.211]             version = "1.8"), class = "FutureResult")
[17:46:49.211]     }, finally = {
[17:46:49.211]         if (!identical(...future.workdir, getwd())) 
[17:46:49.211]             setwd(...future.workdir)
[17:46:49.211]         {
[17:46:49.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.211]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.211]             }
[17:46:49.211]             base::options(...future.oldOptions)
[17:46:49.211]             if (.Platform$OS.type == "windows") {
[17:46:49.211]                 old_names <- names(...future.oldEnvVars)
[17:46:49.211]                 envs <- base::Sys.getenv()
[17:46:49.211]                 names <- names(envs)
[17:46:49.211]                 common <- intersect(names, old_names)
[17:46:49.211]                 added <- setdiff(names, old_names)
[17:46:49.211]                 removed <- setdiff(old_names, names)
[17:46:49.211]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.211]                   envs[common]]
[17:46:49.211]                 NAMES <- toupper(changed)
[17:46:49.211]                 args <- list()
[17:46:49.211]                 for (kk in seq_along(NAMES)) {
[17:46:49.211]                   name <- changed[[kk]]
[17:46:49.211]                   NAME <- NAMES[[kk]]
[17:46:49.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.211]                     next
[17:46:49.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.211]                 }
[17:46:49.211]                 NAMES <- toupper(added)
[17:46:49.211]                 for (kk in seq_along(NAMES)) {
[17:46:49.211]                   name <- added[[kk]]
[17:46:49.211]                   NAME <- NAMES[[kk]]
[17:46:49.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.211]                     next
[17:46:49.211]                   args[[name]] <- ""
[17:46:49.211]                 }
[17:46:49.211]                 NAMES <- toupper(removed)
[17:46:49.211]                 for (kk in seq_along(NAMES)) {
[17:46:49.211]                   name <- removed[[kk]]
[17:46:49.211]                   NAME <- NAMES[[kk]]
[17:46:49.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.211]                     next
[17:46:49.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.211]                 }
[17:46:49.211]                 if (length(args) > 0) 
[17:46:49.211]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.211]             }
[17:46:49.211]             else {
[17:46:49.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.211]             }
[17:46:49.211]             {
[17:46:49.211]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.211]                   0L) {
[17:46:49.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.211]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.211]                   base::options(opts)
[17:46:49.211]                 }
[17:46:49.211]                 {
[17:46:49.211]                   {
[17:46:49.211]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.211]                     NULL
[17:46:49.211]                   }
[17:46:49.211]                   options(future.plan = NULL)
[17:46:49.211]                   if (is.na(NA_character_)) 
[17:46:49.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.211]                     .init = FALSE)
[17:46:49.211]                 }
[17:46:49.211]             }
[17:46:49.211]         }
[17:46:49.211]     })
[17:46:49.211]     if (TRUE) {
[17:46:49.211]         base::sink(type = "output", split = FALSE)
[17:46:49.211]         if (TRUE) {
[17:46:49.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.211]         }
[17:46:49.211]         else {
[17:46:49.211]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.211]         }
[17:46:49.211]         base::close(...future.stdout)
[17:46:49.211]         ...future.stdout <- NULL
[17:46:49.211]     }
[17:46:49.211]     ...future.result$conditions <- ...future.conditions
[17:46:49.211]     ...future.result$finished <- base::Sys.time()
[17:46:49.211]     ...future.result
[17:46:49.211] }
[17:46:49.214] MultisessionFuture started
[17:46:49.214] - Launch lazy future ... done
[17:46:49.215] run() for ‘MultisessionFuture’ ... done
[17:46:49.215] getGlobalsAndPackages() ...
[17:46:49.215] Searching for globals...
[17:46:49.216] - globals found: [1] ‘{’
[17:46:49.216] Searching for globals ... DONE
[17:46:49.216] Resolving globals: FALSE
[17:46:49.216] 
[17:46:49.216] 
[17:46:49.216] getGlobalsAndPackages() ... DONE
[17:46:49.217] run() for ‘Future’ ...
[17:46:49.217] - state: ‘created’
[17:46:49.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.231]   - Field: ‘node’
[17:46:49.231]   - Field: ‘label’
[17:46:49.231]   - Field: ‘local’
[17:46:49.231]   - Field: ‘owner’
[17:46:49.231]   - Field: ‘envir’
[17:46:49.231]   - Field: ‘workers’
[17:46:49.231]   - Field: ‘packages’
[17:46:49.231]   - Field: ‘gc’
[17:46:49.232]   - Field: ‘conditions’
[17:46:49.232]   - Field: ‘persistent’
[17:46:49.232]   - Field: ‘expr’
[17:46:49.232]   - Field: ‘uuid’
[17:46:49.232]   - Field: ‘seed’
[17:46:49.232]   - Field: ‘version’
[17:46:49.232]   - Field: ‘result’
[17:46:49.232]   - Field: ‘asynchronous’
[17:46:49.232]   - Field: ‘calls’
[17:46:49.232]   - Field: ‘globals’
[17:46:49.232]   - Field: ‘stdout’
[17:46:49.233]   - Field: ‘earlySignal’
[17:46:49.233]   - Field: ‘lazy’
[17:46:49.233]   - Field: ‘state’
[17:46:49.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.233] - Launch lazy future ...
[17:46:49.233] Packages needed by the future expression (n = 0): <none>
[17:46:49.233] Packages needed by future strategies (n = 0): <none>
[17:46:49.234] {
[17:46:49.234]     {
[17:46:49.234]         {
[17:46:49.234]             ...future.startTime <- base::Sys.time()
[17:46:49.234]             {
[17:46:49.234]                 {
[17:46:49.234]                   {
[17:46:49.234]                     {
[17:46:49.234]                       base::local({
[17:46:49.234]                         has_future <- base::requireNamespace("future", 
[17:46:49.234]                           quietly = TRUE)
[17:46:49.234]                         if (has_future) {
[17:46:49.234]                           ns <- base::getNamespace("future")
[17:46:49.234]                           version <- ns[[".package"]][["version"]]
[17:46:49.234]                           if (is.null(version)) 
[17:46:49.234]                             version <- utils::packageVersion("future")
[17:46:49.234]                         }
[17:46:49.234]                         else {
[17:46:49.234]                           version <- NULL
[17:46:49.234]                         }
[17:46:49.234]                         if (!has_future || version < "1.8.0") {
[17:46:49.234]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.234]                             "", base::R.version$version.string), 
[17:46:49.234]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.234]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.234]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.234]                               "release", "version")], collapse = " "), 
[17:46:49.234]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.234]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.234]                             info)
[17:46:49.234]                           info <- base::paste(info, collapse = "; ")
[17:46:49.234]                           if (!has_future) {
[17:46:49.234]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.234]                               info)
[17:46:49.234]                           }
[17:46:49.234]                           else {
[17:46:49.234]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.234]                               info, version)
[17:46:49.234]                           }
[17:46:49.234]                           base::stop(msg)
[17:46:49.234]                         }
[17:46:49.234]                       })
[17:46:49.234]                     }
[17:46:49.234]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.234]                     base::options(mc.cores = 1L)
[17:46:49.234]                   }
[17:46:49.234]                   ...future.strategy.old <- future::plan("list")
[17:46:49.234]                   options(future.plan = NULL)
[17:46:49.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.234]                 }
[17:46:49.234]                 ...future.workdir <- getwd()
[17:46:49.234]             }
[17:46:49.234]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.234]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.234]         }
[17:46:49.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.234]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.234]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.234]             base::names(...future.oldOptions))
[17:46:49.234]     }
[17:46:49.234]     if (FALSE) {
[17:46:49.234]     }
[17:46:49.234]     else {
[17:46:49.234]         if (TRUE) {
[17:46:49.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.234]                 open = "w")
[17:46:49.234]         }
[17:46:49.234]         else {
[17:46:49.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.234]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.234]         }
[17:46:49.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.234]             base::sink(type = "output", split = FALSE)
[17:46:49.234]             base::close(...future.stdout)
[17:46:49.234]         }, add = TRUE)
[17:46:49.234]     }
[17:46:49.234]     ...future.frame <- base::sys.nframe()
[17:46:49.234]     ...future.conditions <- base::list()
[17:46:49.234]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.234]     if (FALSE) {
[17:46:49.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.234]     }
[17:46:49.234]     ...future.result <- base::tryCatch({
[17:46:49.234]         base::withCallingHandlers({
[17:46:49.234]             ...future.value <- base::withVisible(base::local({
[17:46:49.234]                 ...future.makeSendCondition <- base::local({
[17:46:49.234]                   sendCondition <- NULL
[17:46:49.234]                   function(frame = 1L) {
[17:46:49.234]                     if (is.function(sendCondition)) 
[17:46:49.234]                       return(sendCondition)
[17:46:49.234]                     ns <- getNamespace("parallel")
[17:46:49.234]                     if (exists("sendData", mode = "function", 
[17:46:49.234]                       envir = ns)) {
[17:46:49.234]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.234]                         envir = ns)
[17:46:49.234]                       envir <- sys.frame(frame)
[17:46:49.234]                       master <- NULL
[17:46:49.234]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.234]                         !identical(envir, emptyenv())) {
[17:46:49.234]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.234]                           inherits = FALSE)) {
[17:46:49.234]                           master <- get("master", mode = "list", 
[17:46:49.234]                             envir = envir, inherits = FALSE)
[17:46:49.234]                           if (inherits(master, c("SOCKnode", 
[17:46:49.234]                             "SOCK0node"))) {
[17:46:49.234]                             sendCondition <<- function(cond) {
[17:46:49.234]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.234]                                 success = TRUE)
[17:46:49.234]                               parallel_sendData(master, data)
[17:46:49.234]                             }
[17:46:49.234]                             return(sendCondition)
[17:46:49.234]                           }
[17:46:49.234]                         }
[17:46:49.234]                         frame <- frame + 1L
[17:46:49.234]                         envir <- sys.frame(frame)
[17:46:49.234]                       }
[17:46:49.234]                     }
[17:46:49.234]                     sendCondition <<- function(cond) NULL
[17:46:49.234]                   }
[17:46:49.234]                 })
[17:46:49.234]                 withCallingHandlers({
[17:46:49.234]                   {
[17:46:49.234]                     4
[17:46:49.234]                   }
[17:46:49.234]                 }, immediateCondition = function(cond) {
[17:46:49.234]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.234]                   sendCondition(cond)
[17:46:49.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.234]                   {
[17:46:49.234]                     inherits <- base::inherits
[17:46:49.234]                     invokeRestart <- base::invokeRestart
[17:46:49.234]                     is.null <- base::is.null
[17:46:49.234]                     muffled <- FALSE
[17:46:49.234]                     if (inherits(cond, "message")) {
[17:46:49.234]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.234]                       if (muffled) 
[17:46:49.234]                         invokeRestart("muffleMessage")
[17:46:49.234]                     }
[17:46:49.234]                     else if (inherits(cond, "warning")) {
[17:46:49.234]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.234]                       if (muffled) 
[17:46:49.234]                         invokeRestart("muffleWarning")
[17:46:49.234]                     }
[17:46:49.234]                     else if (inherits(cond, "condition")) {
[17:46:49.234]                       if (!is.null(pattern)) {
[17:46:49.234]                         computeRestarts <- base::computeRestarts
[17:46:49.234]                         grepl <- base::grepl
[17:46:49.234]                         restarts <- computeRestarts(cond)
[17:46:49.234]                         for (restart in restarts) {
[17:46:49.234]                           name <- restart$name
[17:46:49.234]                           if (is.null(name)) 
[17:46:49.234]                             next
[17:46:49.234]                           if (!grepl(pattern, name)) 
[17:46:49.234]                             next
[17:46:49.234]                           invokeRestart(restart)
[17:46:49.234]                           muffled <- TRUE
[17:46:49.234]                           break
[17:46:49.234]                         }
[17:46:49.234]                       }
[17:46:49.234]                     }
[17:46:49.234]                     invisible(muffled)
[17:46:49.234]                   }
[17:46:49.234]                   muffleCondition(cond)
[17:46:49.234]                 })
[17:46:49.234]             }))
[17:46:49.234]             future::FutureResult(value = ...future.value$value, 
[17:46:49.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.234]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.234]                     ...future.globalenv.names))
[17:46:49.234]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.234]         }, condition = base::local({
[17:46:49.234]             c <- base::c
[17:46:49.234]             inherits <- base::inherits
[17:46:49.234]             invokeRestart <- base::invokeRestart
[17:46:49.234]             length <- base::length
[17:46:49.234]             list <- base::list
[17:46:49.234]             seq.int <- base::seq.int
[17:46:49.234]             signalCondition <- base::signalCondition
[17:46:49.234]             sys.calls <- base::sys.calls
[17:46:49.234]             `[[` <- base::`[[`
[17:46:49.234]             `+` <- base::`+`
[17:46:49.234]             `<<-` <- base::`<<-`
[17:46:49.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.234]                   3L)]
[17:46:49.234]             }
[17:46:49.234]             function(cond) {
[17:46:49.234]                 is_error <- inherits(cond, "error")
[17:46:49.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.234]                   NULL)
[17:46:49.234]                 if (is_error) {
[17:46:49.234]                   sessionInformation <- function() {
[17:46:49.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.234]                       search = base::search(), system = base::Sys.info())
[17:46:49.234]                   }
[17:46:49.234]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.234]                     cond$call), session = sessionInformation(), 
[17:46:49.234]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.234]                   signalCondition(cond)
[17:46:49.234]                 }
[17:46:49.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.234]                 "immediateCondition"))) {
[17:46:49.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.234]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.234]                   if (TRUE && !signal) {
[17:46:49.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.234]                     {
[17:46:49.234]                       inherits <- base::inherits
[17:46:49.234]                       invokeRestart <- base::invokeRestart
[17:46:49.234]                       is.null <- base::is.null
[17:46:49.234]                       muffled <- FALSE
[17:46:49.234]                       if (inherits(cond, "message")) {
[17:46:49.234]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.234]                         if (muffled) 
[17:46:49.234]                           invokeRestart("muffleMessage")
[17:46:49.234]                       }
[17:46:49.234]                       else if (inherits(cond, "warning")) {
[17:46:49.234]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.234]                         if (muffled) 
[17:46:49.234]                           invokeRestart("muffleWarning")
[17:46:49.234]                       }
[17:46:49.234]                       else if (inherits(cond, "condition")) {
[17:46:49.234]                         if (!is.null(pattern)) {
[17:46:49.234]                           computeRestarts <- base::computeRestarts
[17:46:49.234]                           grepl <- base::grepl
[17:46:49.234]                           restarts <- computeRestarts(cond)
[17:46:49.234]                           for (restart in restarts) {
[17:46:49.234]                             name <- restart$name
[17:46:49.234]                             if (is.null(name)) 
[17:46:49.234]                               next
[17:46:49.234]                             if (!grepl(pattern, name)) 
[17:46:49.234]                               next
[17:46:49.234]                             invokeRestart(restart)
[17:46:49.234]                             muffled <- TRUE
[17:46:49.234]                             break
[17:46:49.234]                           }
[17:46:49.234]                         }
[17:46:49.234]                       }
[17:46:49.234]                       invisible(muffled)
[17:46:49.234]                     }
[17:46:49.234]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.234]                   }
[17:46:49.234]                 }
[17:46:49.234]                 else {
[17:46:49.234]                   if (TRUE) {
[17:46:49.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.234]                     {
[17:46:49.234]                       inherits <- base::inherits
[17:46:49.234]                       invokeRestart <- base::invokeRestart
[17:46:49.234]                       is.null <- base::is.null
[17:46:49.234]                       muffled <- FALSE
[17:46:49.234]                       if (inherits(cond, "message")) {
[17:46:49.234]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.234]                         if (muffled) 
[17:46:49.234]                           invokeRestart("muffleMessage")
[17:46:49.234]                       }
[17:46:49.234]                       else if (inherits(cond, "warning")) {
[17:46:49.234]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.234]                         if (muffled) 
[17:46:49.234]                           invokeRestart("muffleWarning")
[17:46:49.234]                       }
[17:46:49.234]                       else if (inherits(cond, "condition")) {
[17:46:49.234]                         if (!is.null(pattern)) {
[17:46:49.234]                           computeRestarts <- base::computeRestarts
[17:46:49.234]                           grepl <- base::grepl
[17:46:49.234]                           restarts <- computeRestarts(cond)
[17:46:49.234]                           for (restart in restarts) {
[17:46:49.234]                             name <- restart$name
[17:46:49.234]                             if (is.null(name)) 
[17:46:49.234]                               next
[17:46:49.234]                             if (!grepl(pattern, name)) 
[17:46:49.234]                               next
[17:46:49.234]                             invokeRestart(restart)
[17:46:49.234]                             muffled <- TRUE
[17:46:49.234]                             break
[17:46:49.234]                           }
[17:46:49.234]                         }
[17:46:49.234]                       }
[17:46:49.234]                       invisible(muffled)
[17:46:49.234]                     }
[17:46:49.234]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.234]                   }
[17:46:49.234]                 }
[17:46:49.234]             }
[17:46:49.234]         }))
[17:46:49.234]     }, error = function(ex) {
[17:46:49.234]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.234]                 ...future.rng), started = ...future.startTime, 
[17:46:49.234]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.234]             version = "1.8"), class = "FutureResult")
[17:46:49.234]     }, finally = {
[17:46:49.234]         if (!identical(...future.workdir, getwd())) 
[17:46:49.234]             setwd(...future.workdir)
[17:46:49.234]         {
[17:46:49.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.234]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.234]             }
[17:46:49.234]             base::options(...future.oldOptions)
[17:46:49.234]             if (.Platform$OS.type == "windows") {
[17:46:49.234]                 old_names <- names(...future.oldEnvVars)
[17:46:49.234]                 envs <- base::Sys.getenv()
[17:46:49.234]                 names <- names(envs)
[17:46:49.234]                 common <- intersect(names, old_names)
[17:46:49.234]                 added <- setdiff(names, old_names)
[17:46:49.234]                 removed <- setdiff(old_names, names)
[17:46:49.234]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.234]                   envs[common]]
[17:46:49.234]                 NAMES <- toupper(changed)
[17:46:49.234]                 args <- list()
[17:46:49.234]                 for (kk in seq_along(NAMES)) {
[17:46:49.234]                   name <- changed[[kk]]
[17:46:49.234]                   NAME <- NAMES[[kk]]
[17:46:49.234]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.234]                     next
[17:46:49.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.234]                 }
[17:46:49.234]                 NAMES <- toupper(added)
[17:46:49.234]                 for (kk in seq_along(NAMES)) {
[17:46:49.234]                   name <- added[[kk]]
[17:46:49.234]                   NAME <- NAMES[[kk]]
[17:46:49.234]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.234]                     next
[17:46:49.234]                   args[[name]] <- ""
[17:46:49.234]                 }
[17:46:49.234]                 NAMES <- toupper(removed)
[17:46:49.234]                 for (kk in seq_along(NAMES)) {
[17:46:49.234]                   name <- removed[[kk]]
[17:46:49.234]                   NAME <- NAMES[[kk]]
[17:46:49.234]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.234]                     next
[17:46:49.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.234]                 }
[17:46:49.234]                 if (length(args) > 0) 
[17:46:49.234]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.234]             }
[17:46:49.234]             else {
[17:46:49.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.234]             }
[17:46:49.234]             {
[17:46:49.234]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.234]                   0L) {
[17:46:49.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.234]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.234]                   base::options(opts)
[17:46:49.234]                 }
[17:46:49.234]                 {
[17:46:49.234]                   {
[17:46:49.234]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.234]                     NULL
[17:46:49.234]                   }
[17:46:49.234]                   options(future.plan = NULL)
[17:46:49.234]                   if (is.na(NA_character_)) 
[17:46:49.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.234]                     .init = FALSE)
[17:46:49.234]                 }
[17:46:49.234]             }
[17:46:49.234]         }
[17:46:49.234]     })
[17:46:49.234]     if (TRUE) {
[17:46:49.234]         base::sink(type = "output", split = FALSE)
[17:46:49.234]         if (TRUE) {
[17:46:49.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.234]         }
[17:46:49.234]         else {
[17:46:49.234]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.234]         }
[17:46:49.234]         base::close(...future.stdout)
[17:46:49.234]         ...future.stdout <- NULL
[17:46:49.234]     }
[17:46:49.234]     ...future.result$conditions <- ...future.conditions
[17:46:49.234]     ...future.result$finished <- base::Sys.time()
[17:46:49.234]     ...future.result
[17:46:49.234] }
[17:46:49.236] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:49.247] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.247] - Validating connection of MultisessionFuture
[17:46:49.247] - received message: FutureResult
[17:46:49.247] - Received FutureResult
[17:46:49.247] - Erased future from FutureRegistry
[17:46:49.247] result() for ClusterFuture ...
[17:46:49.247] - result already collected: FutureResult
[17:46:49.247] result() for ClusterFuture ... done
[17:46:49.248] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.248] result() for ClusterFuture ...
[17:46:49.248] - result already collected: FutureResult
[17:46:49.248] result() for ClusterFuture ... done
[17:46:49.248] result() for ClusterFuture ...
[17:46:49.248] - result already collected: FutureResult
[17:46:49.248] result() for ClusterFuture ... done
[17:46:49.249] MultisessionFuture started
[17:46:49.249] - Launch lazy future ... done
[17:46:49.249] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5617885ab2f8> 
Classes 'listenv', 'environment' <environment: 0x5617898b0918> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:46:49.253] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.253] - Validating connection of MultisessionFuture
[17:46:49.253] - received message: FutureResult
[17:46:49.254] - Received FutureResult
[17:46:49.254] - Erased future from FutureRegistry
[17:46:49.254] result() for ClusterFuture ...
[17:46:49.254] - result already collected: FutureResult
[17:46:49.254] result() for ClusterFuture ... done
[17:46:49.254] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.254] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.255] - Validating connection of MultisessionFuture
[17:46:49.255] - received message: FutureResult
[17:46:49.255] - Received FutureResult
[17:46:49.255] - Erased future from FutureRegistry
[17:46:49.255] result() for ClusterFuture ...
[17:46:49.255] - result already collected: FutureResult
[17:46:49.255] result() for ClusterFuture ... done
[17:46:49.255] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:49.258] resolve() on list environment ...
[17:46:49.258]  recursive: 0
[17:46:49.262]  length: 6
[17:46:49.262]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:49.262] signalConditionsASAP(numeric, pos=1) ...
[17:46:49.262] - nx: 6
[17:46:49.262] - relay: TRUE
[17:46:49.262] - stdout: TRUE
[17:46:49.262] - signal: TRUE
[17:46:49.262] - resignal: FALSE
[17:46:49.262] - force: TRUE
[17:46:49.262] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.263] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.263]  - until=2
[17:46:49.263]  - relaying element #2
[17:46:49.263] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.263] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.263] signalConditionsASAP(NULL, pos=1) ... done
[17:46:49.263]  length: 5 (resolved future 1)
[17:46:49.263] Future #2
[17:46:49.263] result() for ClusterFuture ...
[17:46:49.263] - result already collected: FutureResult
[17:46:49.264] result() for ClusterFuture ... done
[17:46:49.264] result() for ClusterFuture ...
[17:46:49.264] - result already collected: FutureResult
[17:46:49.264] result() for ClusterFuture ... done
[17:46:49.264] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:49.264] - nx: 6
[17:46:49.264] - relay: TRUE
[17:46:49.264] - stdout: TRUE
[17:46:49.264] - signal: TRUE
[17:46:49.264] - resignal: FALSE
[17:46:49.264] - force: TRUE
[17:46:49.264] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.265] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.265]  - until=2
[17:46:49.265]  - relaying element #2
[17:46:49.265] result() for ClusterFuture ...
[17:46:49.265] - result already collected: FutureResult
[17:46:49.265] result() for ClusterFuture ... done
[17:46:49.265] result() for ClusterFuture ...
[17:46:49.265] - result already collected: FutureResult
[17:46:49.265] result() for ClusterFuture ... done
[17:46:49.265] result() for ClusterFuture ...
[17:46:49.265] - result already collected: FutureResult
[17:46:49.265] result() for ClusterFuture ... done
[17:46:49.266] result() for ClusterFuture ...
[17:46:49.266] - result already collected: FutureResult
[17:46:49.266] result() for ClusterFuture ... done
[17:46:49.266] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.266] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.266] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:49.266]  length: 4 (resolved future 2)
[17:46:49.266] Future #3
[17:46:49.266] result() for ClusterFuture ...
[17:46:49.266] - result already collected: FutureResult
[17:46:49.266] result() for ClusterFuture ... done
[17:46:49.267] result() for ClusterFuture ...
[17:46:49.267] - result already collected: FutureResult
[17:46:49.267] result() for ClusterFuture ... done
[17:46:49.267] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:49.267] - nx: 6
[17:46:49.267] - relay: TRUE
[17:46:49.267] - stdout: TRUE
[17:46:49.267] - signal: TRUE
[17:46:49.267] - resignal: FALSE
[17:46:49.267] - force: TRUE
[17:46:49.267] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.267] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.268]  - until=3
[17:46:49.268]  - relaying element #3
[17:46:49.268] result() for ClusterFuture ...
[17:46:49.268] - result already collected: FutureResult
[17:46:49.268] result() for ClusterFuture ... done
[17:46:49.268] result() for ClusterFuture ...
[17:46:49.268] - result already collected: FutureResult
[17:46:49.268] result() for ClusterFuture ... done
[17:46:49.268] result() for ClusterFuture ...
[17:46:49.268] - result already collected: FutureResult
[17:46:49.268] result() for ClusterFuture ... done
[17:46:49.268] result() for ClusterFuture ...
[17:46:49.269] - result already collected: FutureResult
[17:46:49.269] result() for ClusterFuture ... done
[17:46:49.269] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.269] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.269] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:49.269]  length: 3 (resolved future 3)
[17:46:49.269] Future #4
[17:46:49.269] result() for ClusterFuture ...
[17:46:49.269] - result already collected: FutureResult
[17:46:49.269] result() for ClusterFuture ... done
[17:46:49.269] result() for ClusterFuture ...
[17:46:49.270] - result already collected: FutureResult
[17:46:49.270] result() for ClusterFuture ... done
[17:46:49.270] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:49.270] - nx: 6
[17:46:49.270] - relay: TRUE
[17:46:49.270] - stdout: TRUE
[17:46:49.270] - signal: TRUE
[17:46:49.270] - resignal: FALSE
[17:46:49.270] - force: TRUE
[17:46:49.270] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.270] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.270]  - until=4
[17:46:49.271]  - relaying element #4
[17:46:49.271] result() for ClusterFuture ...
[17:46:49.271] - result already collected: FutureResult
[17:46:49.271] result() for ClusterFuture ... done
[17:46:49.271] result() for ClusterFuture ...
[17:46:49.271] - result already collected: FutureResult
[17:46:49.271] result() for ClusterFuture ... done
[17:46:49.271] result() for ClusterFuture ...
[17:46:49.271] - result already collected: FutureResult
[17:46:49.271] result() for ClusterFuture ... done
[17:46:49.271] result() for ClusterFuture ...
[17:46:49.271] - result already collected: FutureResult
[17:46:49.272] result() for ClusterFuture ... done
[17:46:49.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.272] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.272] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:49.272]  length: 2 (resolved future 4)
[17:46:49.272] signalConditionsASAP(NULL, pos=5) ...
[17:46:49.272] - nx: 6
[17:46:49.272] - relay: TRUE
[17:46:49.272] - stdout: TRUE
[17:46:49.272] - signal: TRUE
[17:46:49.272] - resignal: FALSE
[17:46:49.272] - force: TRUE
[17:46:49.273] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.273] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.273]  - until=6
[17:46:49.273]  - relaying element #6
[17:46:49.273] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.273] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.273] signalConditionsASAP(NULL, pos=5) ... done
[17:46:49.273]  length: 1 (resolved future 5)
[17:46:49.273] signalConditionsASAP(numeric, pos=6) ...
[17:46:49.273] - nx: 6
[17:46:49.273] - relay: TRUE
[17:46:49.274] - stdout: TRUE
[17:46:49.274] - signal: TRUE
[17:46:49.274] - resignal: FALSE
[17:46:49.274] - force: TRUE
[17:46:49.274] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.274] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.274]  - until=6
[17:46:49.274] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.274] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.274] signalConditionsASAP(numeric, pos=6) ... done
[17:46:49.274]  length: 0 (resolved future 6)
[17:46:49.274] Relaying remaining futures
[17:46:49.275] signalConditionsASAP(NULL, pos=0) ...
[17:46:49.275] - nx: 6
[17:46:49.275] - relay: TRUE
[17:46:49.275] - stdout: TRUE
[17:46:49.275] - signal: TRUE
[17:46:49.275] - resignal: FALSE
[17:46:49.275] - force: TRUE
[17:46:49.275] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.275] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:49.275] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.275] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.276] signalConditionsASAP(NULL, pos=0) ... done
[17:46:49.276] resolve() on list environment ... DONE
[17:46:49.276] result() for ClusterFuture ...
[17:46:49.276] - result already collected: FutureResult
[17:46:49.276] result() for ClusterFuture ... done
[17:46:49.276] result() for ClusterFuture ...
[17:46:49.276] - result already collected: FutureResult
[17:46:49.276] result() for ClusterFuture ... done
[17:46:49.276] result() for ClusterFuture ...
[17:46:49.276] - result already collected: FutureResult
[17:46:49.276] result() for ClusterFuture ... done
[17:46:49.276] result() for ClusterFuture ...
[17:46:49.277] - result already collected: FutureResult
[17:46:49.277] result() for ClusterFuture ... done
[17:46:49.277] result() for ClusterFuture ...
[17:46:49.277] - result already collected: FutureResult
[17:46:49.277] result() for ClusterFuture ... done
[17:46:49.277] result() for ClusterFuture ...
[17:46:49.277] - result already collected: FutureResult
[17:46:49.277] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x561789bf67e8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:46:49.279] getGlobalsAndPackages() ...
[17:46:49.279] Searching for globals...
[17:46:49.279] 
[17:46:49.279] Searching for globals ... DONE
[17:46:49.280] - globals: [0] <none>
[17:46:49.280] getGlobalsAndPackages() ... DONE
[17:46:49.280] run() for ‘Future’ ...
[17:46:49.280] - state: ‘created’
[17:46:49.280] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.296] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.296] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.296]   - Field: ‘node’
[17:46:49.296]   - Field: ‘label’
[17:46:49.296]   - Field: ‘local’
[17:46:49.296]   - Field: ‘owner’
[17:46:49.296]   - Field: ‘envir’
[17:46:49.297]   - Field: ‘workers’
[17:46:49.297]   - Field: ‘packages’
[17:46:49.297]   - Field: ‘gc’
[17:46:49.297]   - Field: ‘conditions’
[17:46:49.297]   - Field: ‘persistent’
[17:46:49.297]   - Field: ‘expr’
[17:46:49.297]   - Field: ‘uuid’
[17:46:49.297]   - Field: ‘seed’
[17:46:49.297]   - Field: ‘version’
[17:46:49.297]   - Field: ‘result’
[17:46:49.297]   - Field: ‘asynchronous’
[17:46:49.298]   - Field: ‘calls’
[17:46:49.298]   - Field: ‘globals’
[17:46:49.298]   - Field: ‘stdout’
[17:46:49.298]   - Field: ‘earlySignal’
[17:46:49.298]   - Field: ‘lazy’
[17:46:49.298]   - Field: ‘state’
[17:46:49.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.298] - Launch lazy future ...
[17:46:49.298] Packages needed by the future expression (n = 0): <none>
[17:46:49.299] Packages needed by future strategies (n = 0): <none>
[17:46:49.299] {
[17:46:49.299]     {
[17:46:49.299]         {
[17:46:49.299]             ...future.startTime <- base::Sys.time()
[17:46:49.299]             {
[17:46:49.299]                 {
[17:46:49.299]                   {
[17:46:49.299]                     {
[17:46:49.299]                       base::local({
[17:46:49.299]                         has_future <- base::requireNamespace("future", 
[17:46:49.299]                           quietly = TRUE)
[17:46:49.299]                         if (has_future) {
[17:46:49.299]                           ns <- base::getNamespace("future")
[17:46:49.299]                           version <- ns[[".package"]][["version"]]
[17:46:49.299]                           if (is.null(version)) 
[17:46:49.299]                             version <- utils::packageVersion("future")
[17:46:49.299]                         }
[17:46:49.299]                         else {
[17:46:49.299]                           version <- NULL
[17:46:49.299]                         }
[17:46:49.299]                         if (!has_future || version < "1.8.0") {
[17:46:49.299]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.299]                             "", base::R.version$version.string), 
[17:46:49.299]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.299]                               "release", "version")], collapse = " "), 
[17:46:49.299]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.299]                             info)
[17:46:49.299]                           info <- base::paste(info, collapse = "; ")
[17:46:49.299]                           if (!has_future) {
[17:46:49.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.299]                               info)
[17:46:49.299]                           }
[17:46:49.299]                           else {
[17:46:49.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.299]                               info, version)
[17:46:49.299]                           }
[17:46:49.299]                           base::stop(msg)
[17:46:49.299]                         }
[17:46:49.299]                       })
[17:46:49.299]                     }
[17:46:49.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.299]                     base::options(mc.cores = 1L)
[17:46:49.299]                   }
[17:46:49.299]                   ...future.strategy.old <- future::plan("list")
[17:46:49.299]                   options(future.plan = NULL)
[17:46:49.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.299]                 }
[17:46:49.299]                 ...future.workdir <- getwd()
[17:46:49.299]             }
[17:46:49.299]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.299]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.299]         }
[17:46:49.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.299]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.299]             base::names(...future.oldOptions))
[17:46:49.299]     }
[17:46:49.299]     if (FALSE) {
[17:46:49.299]     }
[17:46:49.299]     else {
[17:46:49.299]         if (TRUE) {
[17:46:49.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.299]                 open = "w")
[17:46:49.299]         }
[17:46:49.299]         else {
[17:46:49.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.299]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.299]         }
[17:46:49.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.299]             base::sink(type = "output", split = FALSE)
[17:46:49.299]             base::close(...future.stdout)
[17:46:49.299]         }, add = TRUE)
[17:46:49.299]     }
[17:46:49.299]     ...future.frame <- base::sys.nframe()
[17:46:49.299]     ...future.conditions <- base::list()
[17:46:49.299]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.299]     if (FALSE) {
[17:46:49.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.299]     }
[17:46:49.299]     ...future.result <- base::tryCatch({
[17:46:49.299]         base::withCallingHandlers({
[17:46:49.299]             ...future.value <- base::withVisible(base::local({
[17:46:49.299]                 ...future.makeSendCondition <- base::local({
[17:46:49.299]                   sendCondition <- NULL
[17:46:49.299]                   function(frame = 1L) {
[17:46:49.299]                     if (is.function(sendCondition)) 
[17:46:49.299]                       return(sendCondition)
[17:46:49.299]                     ns <- getNamespace("parallel")
[17:46:49.299]                     if (exists("sendData", mode = "function", 
[17:46:49.299]                       envir = ns)) {
[17:46:49.299]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.299]                         envir = ns)
[17:46:49.299]                       envir <- sys.frame(frame)
[17:46:49.299]                       master <- NULL
[17:46:49.299]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.299]                         !identical(envir, emptyenv())) {
[17:46:49.299]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.299]                           inherits = FALSE)) {
[17:46:49.299]                           master <- get("master", mode = "list", 
[17:46:49.299]                             envir = envir, inherits = FALSE)
[17:46:49.299]                           if (inherits(master, c("SOCKnode", 
[17:46:49.299]                             "SOCK0node"))) {
[17:46:49.299]                             sendCondition <<- function(cond) {
[17:46:49.299]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.299]                                 success = TRUE)
[17:46:49.299]                               parallel_sendData(master, data)
[17:46:49.299]                             }
[17:46:49.299]                             return(sendCondition)
[17:46:49.299]                           }
[17:46:49.299]                         }
[17:46:49.299]                         frame <- frame + 1L
[17:46:49.299]                         envir <- sys.frame(frame)
[17:46:49.299]                       }
[17:46:49.299]                     }
[17:46:49.299]                     sendCondition <<- function(cond) NULL
[17:46:49.299]                   }
[17:46:49.299]                 })
[17:46:49.299]                 withCallingHandlers({
[17:46:49.299]                   2
[17:46:49.299]                 }, immediateCondition = function(cond) {
[17:46:49.299]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.299]                   sendCondition(cond)
[17:46:49.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.299]                   {
[17:46:49.299]                     inherits <- base::inherits
[17:46:49.299]                     invokeRestart <- base::invokeRestart
[17:46:49.299]                     is.null <- base::is.null
[17:46:49.299]                     muffled <- FALSE
[17:46:49.299]                     if (inherits(cond, "message")) {
[17:46:49.299]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.299]                       if (muffled) 
[17:46:49.299]                         invokeRestart("muffleMessage")
[17:46:49.299]                     }
[17:46:49.299]                     else if (inherits(cond, "warning")) {
[17:46:49.299]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.299]                       if (muffled) 
[17:46:49.299]                         invokeRestart("muffleWarning")
[17:46:49.299]                     }
[17:46:49.299]                     else if (inherits(cond, "condition")) {
[17:46:49.299]                       if (!is.null(pattern)) {
[17:46:49.299]                         computeRestarts <- base::computeRestarts
[17:46:49.299]                         grepl <- base::grepl
[17:46:49.299]                         restarts <- computeRestarts(cond)
[17:46:49.299]                         for (restart in restarts) {
[17:46:49.299]                           name <- restart$name
[17:46:49.299]                           if (is.null(name)) 
[17:46:49.299]                             next
[17:46:49.299]                           if (!grepl(pattern, name)) 
[17:46:49.299]                             next
[17:46:49.299]                           invokeRestart(restart)
[17:46:49.299]                           muffled <- TRUE
[17:46:49.299]                           break
[17:46:49.299]                         }
[17:46:49.299]                       }
[17:46:49.299]                     }
[17:46:49.299]                     invisible(muffled)
[17:46:49.299]                   }
[17:46:49.299]                   muffleCondition(cond)
[17:46:49.299]                 })
[17:46:49.299]             }))
[17:46:49.299]             future::FutureResult(value = ...future.value$value, 
[17:46:49.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.299]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.299]                     ...future.globalenv.names))
[17:46:49.299]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.299]         }, condition = base::local({
[17:46:49.299]             c <- base::c
[17:46:49.299]             inherits <- base::inherits
[17:46:49.299]             invokeRestart <- base::invokeRestart
[17:46:49.299]             length <- base::length
[17:46:49.299]             list <- base::list
[17:46:49.299]             seq.int <- base::seq.int
[17:46:49.299]             signalCondition <- base::signalCondition
[17:46:49.299]             sys.calls <- base::sys.calls
[17:46:49.299]             `[[` <- base::`[[`
[17:46:49.299]             `+` <- base::`+`
[17:46:49.299]             `<<-` <- base::`<<-`
[17:46:49.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.299]                   3L)]
[17:46:49.299]             }
[17:46:49.299]             function(cond) {
[17:46:49.299]                 is_error <- inherits(cond, "error")
[17:46:49.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.299]                   NULL)
[17:46:49.299]                 if (is_error) {
[17:46:49.299]                   sessionInformation <- function() {
[17:46:49.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.299]                       search = base::search(), system = base::Sys.info())
[17:46:49.299]                   }
[17:46:49.299]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.299]                     cond$call), session = sessionInformation(), 
[17:46:49.299]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.299]                   signalCondition(cond)
[17:46:49.299]                 }
[17:46:49.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.299]                 "immediateCondition"))) {
[17:46:49.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.299]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.299]                   if (TRUE && !signal) {
[17:46:49.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.299]                     {
[17:46:49.299]                       inherits <- base::inherits
[17:46:49.299]                       invokeRestart <- base::invokeRestart
[17:46:49.299]                       is.null <- base::is.null
[17:46:49.299]                       muffled <- FALSE
[17:46:49.299]                       if (inherits(cond, "message")) {
[17:46:49.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.299]                         if (muffled) 
[17:46:49.299]                           invokeRestart("muffleMessage")
[17:46:49.299]                       }
[17:46:49.299]                       else if (inherits(cond, "warning")) {
[17:46:49.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.299]                         if (muffled) 
[17:46:49.299]                           invokeRestart("muffleWarning")
[17:46:49.299]                       }
[17:46:49.299]                       else if (inherits(cond, "condition")) {
[17:46:49.299]                         if (!is.null(pattern)) {
[17:46:49.299]                           computeRestarts <- base::computeRestarts
[17:46:49.299]                           grepl <- base::grepl
[17:46:49.299]                           restarts <- computeRestarts(cond)
[17:46:49.299]                           for (restart in restarts) {
[17:46:49.299]                             name <- restart$name
[17:46:49.299]                             if (is.null(name)) 
[17:46:49.299]                               next
[17:46:49.299]                             if (!grepl(pattern, name)) 
[17:46:49.299]                               next
[17:46:49.299]                             invokeRestart(restart)
[17:46:49.299]                             muffled <- TRUE
[17:46:49.299]                             break
[17:46:49.299]                           }
[17:46:49.299]                         }
[17:46:49.299]                       }
[17:46:49.299]                       invisible(muffled)
[17:46:49.299]                     }
[17:46:49.299]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.299]                   }
[17:46:49.299]                 }
[17:46:49.299]                 else {
[17:46:49.299]                   if (TRUE) {
[17:46:49.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.299]                     {
[17:46:49.299]                       inherits <- base::inherits
[17:46:49.299]                       invokeRestart <- base::invokeRestart
[17:46:49.299]                       is.null <- base::is.null
[17:46:49.299]                       muffled <- FALSE
[17:46:49.299]                       if (inherits(cond, "message")) {
[17:46:49.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.299]                         if (muffled) 
[17:46:49.299]                           invokeRestart("muffleMessage")
[17:46:49.299]                       }
[17:46:49.299]                       else if (inherits(cond, "warning")) {
[17:46:49.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.299]                         if (muffled) 
[17:46:49.299]                           invokeRestart("muffleWarning")
[17:46:49.299]                       }
[17:46:49.299]                       else if (inherits(cond, "condition")) {
[17:46:49.299]                         if (!is.null(pattern)) {
[17:46:49.299]                           computeRestarts <- base::computeRestarts
[17:46:49.299]                           grepl <- base::grepl
[17:46:49.299]                           restarts <- computeRestarts(cond)
[17:46:49.299]                           for (restart in restarts) {
[17:46:49.299]                             name <- restart$name
[17:46:49.299]                             if (is.null(name)) 
[17:46:49.299]                               next
[17:46:49.299]                             if (!grepl(pattern, name)) 
[17:46:49.299]                               next
[17:46:49.299]                             invokeRestart(restart)
[17:46:49.299]                             muffled <- TRUE
[17:46:49.299]                             break
[17:46:49.299]                           }
[17:46:49.299]                         }
[17:46:49.299]                       }
[17:46:49.299]                       invisible(muffled)
[17:46:49.299]                     }
[17:46:49.299]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.299]                   }
[17:46:49.299]                 }
[17:46:49.299]             }
[17:46:49.299]         }))
[17:46:49.299]     }, error = function(ex) {
[17:46:49.299]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.299]                 ...future.rng), started = ...future.startTime, 
[17:46:49.299]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.299]             version = "1.8"), class = "FutureResult")
[17:46:49.299]     }, finally = {
[17:46:49.299]         if (!identical(...future.workdir, getwd())) 
[17:46:49.299]             setwd(...future.workdir)
[17:46:49.299]         {
[17:46:49.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.299]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.299]             }
[17:46:49.299]             base::options(...future.oldOptions)
[17:46:49.299]             if (.Platform$OS.type == "windows") {
[17:46:49.299]                 old_names <- names(...future.oldEnvVars)
[17:46:49.299]                 envs <- base::Sys.getenv()
[17:46:49.299]                 names <- names(envs)
[17:46:49.299]                 common <- intersect(names, old_names)
[17:46:49.299]                 added <- setdiff(names, old_names)
[17:46:49.299]                 removed <- setdiff(old_names, names)
[17:46:49.299]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.299]                   envs[common]]
[17:46:49.299]                 NAMES <- toupper(changed)
[17:46:49.299]                 args <- list()
[17:46:49.299]                 for (kk in seq_along(NAMES)) {
[17:46:49.299]                   name <- changed[[kk]]
[17:46:49.299]                   NAME <- NAMES[[kk]]
[17:46:49.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.299]                     next
[17:46:49.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.299]                 }
[17:46:49.299]                 NAMES <- toupper(added)
[17:46:49.299]                 for (kk in seq_along(NAMES)) {
[17:46:49.299]                   name <- added[[kk]]
[17:46:49.299]                   NAME <- NAMES[[kk]]
[17:46:49.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.299]                     next
[17:46:49.299]                   args[[name]] <- ""
[17:46:49.299]                 }
[17:46:49.299]                 NAMES <- toupper(removed)
[17:46:49.299]                 for (kk in seq_along(NAMES)) {
[17:46:49.299]                   name <- removed[[kk]]
[17:46:49.299]                   NAME <- NAMES[[kk]]
[17:46:49.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.299]                     next
[17:46:49.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.299]                 }
[17:46:49.299]                 if (length(args) > 0) 
[17:46:49.299]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.299]             }
[17:46:49.299]             else {
[17:46:49.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.299]             }
[17:46:49.299]             {
[17:46:49.299]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.299]                   0L) {
[17:46:49.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.299]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.299]                   base::options(opts)
[17:46:49.299]                 }
[17:46:49.299]                 {
[17:46:49.299]                   {
[17:46:49.299]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.299]                     NULL
[17:46:49.299]                   }
[17:46:49.299]                   options(future.plan = NULL)
[17:46:49.299]                   if (is.na(NA_character_)) 
[17:46:49.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.299]                     .init = FALSE)
[17:46:49.299]                 }
[17:46:49.299]             }
[17:46:49.299]         }
[17:46:49.299]     })
[17:46:49.299]     if (TRUE) {
[17:46:49.299]         base::sink(type = "output", split = FALSE)
[17:46:49.299]         if (TRUE) {
[17:46:49.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.299]         }
[17:46:49.299]         else {
[17:46:49.299]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.299]         }
[17:46:49.299]         base::close(...future.stdout)
[17:46:49.299]         ...future.stdout <- NULL
[17:46:49.299]     }
[17:46:49.299]     ...future.result$conditions <- ...future.conditions
[17:46:49.299]     ...future.result$finished <- base::Sys.time()
[17:46:49.299]     ...future.result
[17:46:49.299] }
[17:46:49.302] MultisessionFuture started
[17:46:49.302] - Launch lazy future ... done
[17:46:49.302] run() for ‘MultisessionFuture’ ... done
[17:46:49.302] getGlobalsAndPackages() ...
[17:46:49.302] Searching for globals...
[17:46:49.303] 
[17:46:49.303] Searching for globals ... DONE
[17:46:49.303] - globals: [0] <none>
[17:46:49.303] getGlobalsAndPackages() ... DONE
[17:46:49.303] run() for ‘Future’ ...
[17:46:49.303] - state: ‘created’
[17:46:49.303] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.317] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.317]   - Field: ‘node’
[17:46:49.317]   - Field: ‘label’
[17:46:49.317]   - Field: ‘local’
[17:46:49.317]   - Field: ‘owner’
[17:46:49.318]   - Field: ‘envir’
[17:46:49.318]   - Field: ‘workers’
[17:46:49.318]   - Field: ‘packages’
[17:46:49.318]   - Field: ‘gc’
[17:46:49.318]   - Field: ‘conditions’
[17:46:49.318]   - Field: ‘persistent’
[17:46:49.318]   - Field: ‘expr’
[17:46:49.318]   - Field: ‘uuid’
[17:46:49.318]   - Field: ‘seed’
[17:46:49.318]   - Field: ‘version’
[17:46:49.318]   - Field: ‘result’
[17:46:49.318]   - Field: ‘asynchronous’
[17:46:49.319]   - Field: ‘calls’
[17:46:49.319]   - Field: ‘globals’
[17:46:49.319]   - Field: ‘stdout’
[17:46:49.319]   - Field: ‘earlySignal’
[17:46:49.319]   - Field: ‘lazy’
[17:46:49.319]   - Field: ‘state’
[17:46:49.319] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.319] - Launch lazy future ...
[17:46:49.319] Packages needed by the future expression (n = 0): <none>
[17:46:49.320] Packages needed by future strategies (n = 0): <none>
[17:46:49.320] {
[17:46:49.320]     {
[17:46:49.320]         {
[17:46:49.320]             ...future.startTime <- base::Sys.time()
[17:46:49.320]             {
[17:46:49.320]                 {
[17:46:49.320]                   {
[17:46:49.320]                     {
[17:46:49.320]                       base::local({
[17:46:49.320]                         has_future <- base::requireNamespace("future", 
[17:46:49.320]                           quietly = TRUE)
[17:46:49.320]                         if (has_future) {
[17:46:49.320]                           ns <- base::getNamespace("future")
[17:46:49.320]                           version <- ns[[".package"]][["version"]]
[17:46:49.320]                           if (is.null(version)) 
[17:46:49.320]                             version <- utils::packageVersion("future")
[17:46:49.320]                         }
[17:46:49.320]                         else {
[17:46:49.320]                           version <- NULL
[17:46:49.320]                         }
[17:46:49.320]                         if (!has_future || version < "1.8.0") {
[17:46:49.320]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.320]                             "", base::R.version$version.string), 
[17:46:49.320]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.320]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.320]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.320]                               "release", "version")], collapse = " "), 
[17:46:49.320]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.320]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.320]                             info)
[17:46:49.320]                           info <- base::paste(info, collapse = "; ")
[17:46:49.320]                           if (!has_future) {
[17:46:49.320]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.320]                               info)
[17:46:49.320]                           }
[17:46:49.320]                           else {
[17:46:49.320]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.320]                               info, version)
[17:46:49.320]                           }
[17:46:49.320]                           base::stop(msg)
[17:46:49.320]                         }
[17:46:49.320]                       })
[17:46:49.320]                     }
[17:46:49.320]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.320]                     base::options(mc.cores = 1L)
[17:46:49.320]                   }
[17:46:49.320]                   ...future.strategy.old <- future::plan("list")
[17:46:49.320]                   options(future.plan = NULL)
[17:46:49.320]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.320]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.320]                 }
[17:46:49.320]                 ...future.workdir <- getwd()
[17:46:49.320]             }
[17:46:49.320]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.320]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.320]         }
[17:46:49.320]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.320]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.320]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.320]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.320]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.320]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.320]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.320]             base::names(...future.oldOptions))
[17:46:49.320]     }
[17:46:49.320]     if (FALSE) {
[17:46:49.320]     }
[17:46:49.320]     else {
[17:46:49.320]         if (TRUE) {
[17:46:49.320]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.320]                 open = "w")
[17:46:49.320]         }
[17:46:49.320]         else {
[17:46:49.320]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.320]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.320]         }
[17:46:49.320]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.320]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.320]             base::sink(type = "output", split = FALSE)
[17:46:49.320]             base::close(...future.stdout)
[17:46:49.320]         }, add = TRUE)
[17:46:49.320]     }
[17:46:49.320]     ...future.frame <- base::sys.nframe()
[17:46:49.320]     ...future.conditions <- base::list()
[17:46:49.320]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.320]     if (FALSE) {
[17:46:49.320]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.320]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.320]     }
[17:46:49.320]     ...future.result <- base::tryCatch({
[17:46:49.320]         base::withCallingHandlers({
[17:46:49.320]             ...future.value <- base::withVisible(base::local({
[17:46:49.320]                 ...future.makeSendCondition <- base::local({
[17:46:49.320]                   sendCondition <- NULL
[17:46:49.320]                   function(frame = 1L) {
[17:46:49.320]                     if (is.function(sendCondition)) 
[17:46:49.320]                       return(sendCondition)
[17:46:49.320]                     ns <- getNamespace("parallel")
[17:46:49.320]                     if (exists("sendData", mode = "function", 
[17:46:49.320]                       envir = ns)) {
[17:46:49.320]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.320]                         envir = ns)
[17:46:49.320]                       envir <- sys.frame(frame)
[17:46:49.320]                       master <- NULL
[17:46:49.320]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.320]                         !identical(envir, emptyenv())) {
[17:46:49.320]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.320]                           inherits = FALSE)) {
[17:46:49.320]                           master <- get("master", mode = "list", 
[17:46:49.320]                             envir = envir, inherits = FALSE)
[17:46:49.320]                           if (inherits(master, c("SOCKnode", 
[17:46:49.320]                             "SOCK0node"))) {
[17:46:49.320]                             sendCondition <<- function(cond) {
[17:46:49.320]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.320]                                 success = TRUE)
[17:46:49.320]                               parallel_sendData(master, data)
[17:46:49.320]                             }
[17:46:49.320]                             return(sendCondition)
[17:46:49.320]                           }
[17:46:49.320]                         }
[17:46:49.320]                         frame <- frame + 1L
[17:46:49.320]                         envir <- sys.frame(frame)
[17:46:49.320]                       }
[17:46:49.320]                     }
[17:46:49.320]                     sendCondition <<- function(cond) NULL
[17:46:49.320]                   }
[17:46:49.320]                 })
[17:46:49.320]                 withCallingHandlers({
[17:46:49.320]                   NULL
[17:46:49.320]                 }, immediateCondition = function(cond) {
[17:46:49.320]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.320]                   sendCondition(cond)
[17:46:49.320]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.320]                   {
[17:46:49.320]                     inherits <- base::inherits
[17:46:49.320]                     invokeRestart <- base::invokeRestart
[17:46:49.320]                     is.null <- base::is.null
[17:46:49.320]                     muffled <- FALSE
[17:46:49.320]                     if (inherits(cond, "message")) {
[17:46:49.320]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.320]                       if (muffled) 
[17:46:49.320]                         invokeRestart("muffleMessage")
[17:46:49.320]                     }
[17:46:49.320]                     else if (inherits(cond, "warning")) {
[17:46:49.320]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.320]                       if (muffled) 
[17:46:49.320]                         invokeRestart("muffleWarning")
[17:46:49.320]                     }
[17:46:49.320]                     else if (inherits(cond, "condition")) {
[17:46:49.320]                       if (!is.null(pattern)) {
[17:46:49.320]                         computeRestarts <- base::computeRestarts
[17:46:49.320]                         grepl <- base::grepl
[17:46:49.320]                         restarts <- computeRestarts(cond)
[17:46:49.320]                         for (restart in restarts) {
[17:46:49.320]                           name <- restart$name
[17:46:49.320]                           if (is.null(name)) 
[17:46:49.320]                             next
[17:46:49.320]                           if (!grepl(pattern, name)) 
[17:46:49.320]                             next
[17:46:49.320]                           invokeRestart(restart)
[17:46:49.320]                           muffled <- TRUE
[17:46:49.320]                           break
[17:46:49.320]                         }
[17:46:49.320]                       }
[17:46:49.320]                     }
[17:46:49.320]                     invisible(muffled)
[17:46:49.320]                   }
[17:46:49.320]                   muffleCondition(cond)
[17:46:49.320]                 })
[17:46:49.320]             }))
[17:46:49.320]             future::FutureResult(value = ...future.value$value, 
[17:46:49.320]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.320]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.320]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.320]                     ...future.globalenv.names))
[17:46:49.320]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.320]         }, condition = base::local({
[17:46:49.320]             c <- base::c
[17:46:49.320]             inherits <- base::inherits
[17:46:49.320]             invokeRestart <- base::invokeRestart
[17:46:49.320]             length <- base::length
[17:46:49.320]             list <- base::list
[17:46:49.320]             seq.int <- base::seq.int
[17:46:49.320]             signalCondition <- base::signalCondition
[17:46:49.320]             sys.calls <- base::sys.calls
[17:46:49.320]             `[[` <- base::`[[`
[17:46:49.320]             `+` <- base::`+`
[17:46:49.320]             `<<-` <- base::`<<-`
[17:46:49.320]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.320]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.320]                   3L)]
[17:46:49.320]             }
[17:46:49.320]             function(cond) {
[17:46:49.320]                 is_error <- inherits(cond, "error")
[17:46:49.320]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.320]                   NULL)
[17:46:49.320]                 if (is_error) {
[17:46:49.320]                   sessionInformation <- function() {
[17:46:49.320]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.320]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.320]                       search = base::search(), system = base::Sys.info())
[17:46:49.320]                   }
[17:46:49.320]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.320]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.320]                     cond$call), session = sessionInformation(), 
[17:46:49.320]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.320]                   signalCondition(cond)
[17:46:49.320]                 }
[17:46:49.320]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.320]                 "immediateCondition"))) {
[17:46:49.320]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.320]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.320]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.320]                   if (TRUE && !signal) {
[17:46:49.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.320]                     {
[17:46:49.320]                       inherits <- base::inherits
[17:46:49.320]                       invokeRestart <- base::invokeRestart
[17:46:49.320]                       is.null <- base::is.null
[17:46:49.320]                       muffled <- FALSE
[17:46:49.320]                       if (inherits(cond, "message")) {
[17:46:49.320]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.320]                         if (muffled) 
[17:46:49.320]                           invokeRestart("muffleMessage")
[17:46:49.320]                       }
[17:46:49.320]                       else if (inherits(cond, "warning")) {
[17:46:49.320]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.320]                         if (muffled) 
[17:46:49.320]                           invokeRestart("muffleWarning")
[17:46:49.320]                       }
[17:46:49.320]                       else if (inherits(cond, "condition")) {
[17:46:49.320]                         if (!is.null(pattern)) {
[17:46:49.320]                           computeRestarts <- base::computeRestarts
[17:46:49.320]                           grepl <- base::grepl
[17:46:49.320]                           restarts <- computeRestarts(cond)
[17:46:49.320]                           for (restart in restarts) {
[17:46:49.320]                             name <- restart$name
[17:46:49.320]                             if (is.null(name)) 
[17:46:49.320]                               next
[17:46:49.320]                             if (!grepl(pattern, name)) 
[17:46:49.320]                               next
[17:46:49.320]                             invokeRestart(restart)
[17:46:49.320]                             muffled <- TRUE
[17:46:49.320]                             break
[17:46:49.320]                           }
[17:46:49.320]                         }
[17:46:49.320]                       }
[17:46:49.320]                       invisible(muffled)
[17:46:49.320]                     }
[17:46:49.320]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.320]                   }
[17:46:49.320]                 }
[17:46:49.320]                 else {
[17:46:49.320]                   if (TRUE) {
[17:46:49.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.320]                     {
[17:46:49.320]                       inherits <- base::inherits
[17:46:49.320]                       invokeRestart <- base::invokeRestart
[17:46:49.320]                       is.null <- base::is.null
[17:46:49.320]                       muffled <- FALSE
[17:46:49.320]                       if (inherits(cond, "message")) {
[17:46:49.320]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.320]                         if (muffled) 
[17:46:49.320]                           invokeRestart("muffleMessage")
[17:46:49.320]                       }
[17:46:49.320]                       else if (inherits(cond, "warning")) {
[17:46:49.320]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.320]                         if (muffled) 
[17:46:49.320]                           invokeRestart("muffleWarning")
[17:46:49.320]                       }
[17:46:49.320]                       else if (inherits(cond, "condition")) {
[17:46:49.320]                         if (!is.null(pattern)) {
[17:46:49.320]                           computeRestarts <- base::computeRestarts
[17:46:49.320]                           grepl <- base::grepl
[17:46:49.320]                           restarts <- computeRestarts(cond)
[17:46:49.320]                           for (restart in restarts) {
[17:46:49.320]                             name <- restart$name
[17:46:49.320]                             if (is.null(name)) 
[17:46:49.320]                               next
[17:46:49.320]                             if (!grepl(pattern, name)) 
[17:46:49.320]                               next
[17:46:49.320]                             invokeRestart(restart)
[17:46:49.320]                             muffled <- TRUE
[17:46:49.320]                             break
[17:46:49.320]                           }
[17:46:49.320]                         }
[17:46:49.320]                       }
[17:46:49.320]                       invisible(muffled)
[17:46:49.320]                     }
[17:46:49.320]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.320]                   }
[17:46:49.320]                 }
[17:46:49.320]             }
[17:46:49.320]         }))
[17:46:49.320]     }, error = function(ex) {
[17:46:49.320]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.320]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.320]                 ...future.rng), started = ...future.startTime, 
[17:46:49.320]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.320]             version = "1.8"), class = "FutureResult")
[17:46:49.320]     }, finally = {
[17:46:49.320]         if (!identical(...future.workdir, getwd())) 
[17:46:49.320]             setwd(...future.workdir)
[17:46:49.320]         {
[17:46:49.320]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.320]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.320]             }
[17:46:49.320]             base::options(...future.oldOptions)
[17:46:49.320]             if (.Platform$OS.type == "windows") {
[17:46:49.320]                 old_names <- names(...future.oldEnvVars)
[17:46:49.320]                 envs <- base::Sys.getenv()
[17:46:49.320]                 names <- names(envs)
[17:46:49.320]                 common <- intersect(names, old_names)
[17:46:49.320]                 added <- setdiff(names, old_names)
[17:46:49.320]                 removed <- setdiff(old_names, names)
[17:46:49.320]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.320]                   envs[common]]
[17:46:49.320]                 NAMES <- toupper(changed)
[17:46:49.320]                 args <- list()
[17:46:49.320]                 for (kk in seq_along(NAMES)) {
[17:46:49.320]                   name <- changed[[kk]]
[17:46:49.320]                   NAME <- NAMES[[kk]]
[17:46:49.320]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.320]                     next
[17:46:49.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.320]                 }
[17:46:49.320]                 NAMES <- toupper(added)
[17:46:49.320]                 for (kk in seq_along(NAMES)) {
[17:46:49.320]                   name <- added[[kk]]
[17:46:49.320]                   NAME <- NAMES[[kk]]
[17:46:49.320]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.320]                     next
[17:46:49.320]                   args[[name]] <- ""
[17:46:49.320]                 }
[17:46:49.320]                 NAMES <- toupper(removed)
[17:46:49.320]                 for (kk in seq_along(NAMES)) {
[17:46:49.320]                   name <- removed[[kk]]
[17:46:49.320]                   NAME <- NAMES[[kk]]
[17:46:49.320]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.320]                     next
[17:46:49.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.320]                 }
[17:46:49.320]                 if (length(args) > 0) 
[17:46:49.320]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.320]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.320]             }
[17:46:49.320]             else {
[17:46:49.320]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.320]             }
[17:46:49.320]             {
[17:46:49.320]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.320]                   0L) {
[17:46:49.320]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.320]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.320]                   base::options(opts)
[17:46:49.320]                 }
[17:46:49.320]                 {
[17:46:49.320]                   {
[17:46:49.320]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.320]                     NULL
[17:46:49.320]                   }
[17:46:49.320]                   options(future.plan = NULL)
[17:46:49.320]                   if (is.na(NA_character_)) 
[17:46:49.320]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.320]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.320]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.320]                     .init = FALSE)
[17:46:49.320]                 }
[17:46:49.320]             }
[17:46:49.320]         }
[17:46:49.320]     })
[17:46:49.320]     if (TRUE) {
[17:46:49.320]         base::sink(type = "output", split = FALSE)
[17:46:49.320]         if (TRUE) {
[17:46:49.320]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.320]         }
[17:46:49.320]         else {
[17:46:49.320]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.320]         }
[17:46:49.320]         base::close(...future.stdout)
[17:46:49.320]         ...future.stdout <- NULL
[17:46:49.320]     }
[17:46:49.320]     ...future.result$conditions <- ...future.conditions
[17:46:49.320]     ...future.result$finished <- base::Sys.time()
[17:46:49.320]     ...future.result
[17:46:49.320] }
[17:46:49.323] MultisessionFuture started
[17:46:49.323] - Launch lazy future ... done
[17:46:49.323] run() for ‘MultisessionFuture’ ... done
[17:46:49.323] getGlobalsAndPackages() ...
[17:46:49.324] Searching for globals...
[17:46:49.324] - globals found: [1] ‘{’
[17:46:49.324] Searching for globals ... DONE
[17:46:49.324] Resolving globals: FALSE
[17:46:49.325] 
[17:46:49.325] 
[17:46:49.325] getGlobalsAndPackages() ... DONE
[17:46:49.325] run() for ‘Future’ ...
[17:46:49.325] - state: ‘created’
[17:46:49.325] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.339] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.339]   - Field: ‘node’
[17:46:49.339]   - Field: ‘label’
[17:46:49.339]   - Field: ‘local’
[17:46:49.339]   - Field: ‘owner’
[17:46:49.340]   - Field: ‘envir’
[17:46:49.340]   - Field: ‘workers’
[17:46:49.340]   - Field: ‘packages’
[17:46:49.340]   - Field: ‘gc’
[17:46:49.340]   - Field: ‘conditions’
[17:46:49.340]   - Field: ‘persistent’
[17:46:49.340]   - Field: ‘expr’
[17:46:49.340]   - Field: ‘uuid’
[17:46:49.340]   - Field: ‘seed’
[17:46:49.340]   - Field: ‘version’
[17:46:49.340]   - Field: ‘result’
[17:46:49.341]   - Field: ‘asynchronous’
[17:46:49.341]   - Field: ‘calls’
[17:46:49.341]   - Field: ‘globals’
[17:46:49.341]   - Field: ‘stdout’
[17:46:49.341]   - Field: ‘earlySignal’
[17:46:49.341]   - Field: ‘lazy’
[17:46:49.341]   - Field: ‘state’
[17:46:49.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.341] - Launch lazy future ...
[17:46:49.342] Packages needed by the future expression (n = 0): <none>
[17:46:49.342] Packages needed by future strategies (n = 0): <none>
[17:46:49.342] {
[17:46:49.342]     {
[17:46:49.342]         {
[17:46:49.342]             ...future.startTime <- base::Sys.time()
[17:46:49.342]             {
[17:46:49.342]                 {
[17:46:49.342]                   {
[17:46:49.342]                     {
[17:46:49.342]                       base::local({
[17:46:49.342]                         has_future <- base::requireNamespace("future", 
[17:46:49.342]                           quietly = TRUE)
[17:46:49.342]                         if (has_future) {
[17:46:49.342]                           ns <- base::getNamespace("future")
[17:46:49.342]                           version <- ns[[".package"]][["version"]]
[17:46:49.342]                           if (is.null(version)) 
[17:46:49.342]                             version <- utils::packageVersion("future")
[17:46:49.342]                         }
[17:46:49.342]                         else {
[17:46:49.342]                           version <- NULL
[17:46:49.342]                         }
[17:46:49.342]                         if (!has_future || version < "1.8.0") {
[17:46:49.342]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.342]                             "", base::R.version$version.string), 
[17:46:49.342]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.342]                               "release", "version")], collapse = " "), 
[17:46:49.342]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.342]                             info)
[17:46:49.342]                           info <- base::paste(info, collapse = "; ")
[17:46:49.342]                           if (!has_future) {
[17:46:49.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.342]                               info)
[17:46:49.342]                           }
[17:46:49.342]                           else {
[17:46:49.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.342]                               info, version)
[17:46:49.342]                           }
[17:46:49.342]                           base::stop(msg)
[17:46:49.342]                         }
[17:46:49.342]                       })
[17:46:49.342]                     }
[17:46:49.342]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.342]                     base::options(mc.cores = 1L)
[17:46:49.342]                   }
[17:46:49.342]                   ...future.strategy.old <- future::plan("list")
[17:46:49.342]                   options(future.plan = NULL)
[17:46:49.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.342]                 }
[17:46:49.342]                 ...future.workdir <- getwd()
[17:46:49.342]             }
[17:46:49.342]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.342]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.342]         }
[17:46:49.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.342]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.342]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.342]             base::names(...future.oldOptions))
[17:46:49.342]     }
[17:46:49.342]     if (FALSE) {
[17:46:49.342]     }
[17:46:49.342]     else {
[17:46:49.342]         if (TRUE) {
[17:46:49.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.342]                 open = "w")
[17:46:49.342]         }
[17:46:49.342]         else {
[17:46:49.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.342]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.342]         }
[17:46:49.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.342]             base::sink(type = "output", split = FALSE)
[17:46:49.342]             base::close(...future.stdout)
[17:46:49.342]         }, add = TRUE)
[17:46:49.342]     }
[17:46:49.342]     ...future.frame <- base::sys.nframe()
[17:46:49.342]     ...future.conditions <- base::list()
[17:46:49.342]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.342]     if (FALSE) {
[17:46:49.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.342]     }
[17:46:49.342]     ...future.result <- base::tryCatch({
[17:46:49.342]         base::withCallingHandlers({
[17:46:49.342]             ...future.value <- base::withVisible(base::local({
[17:46:49.342]                 ...future.makeSendCondition <- base::local({
[17:46:49.342]                   sendCondition <- NULL
[17:46:49.342]                   function(frame = 1L) {
[17:46:49.342]                     if (is.function(sendCondition)) 
[17:46:49.342]                       return(sendCondition)
[17:46:49.342]                     ns <- getNamespace("parallel")
[17:46:49.342]                     if (exists("sendData", mode = "function", 
[17:46:49.342]                       envir = ns)) {
[17:46:49.342]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.342]                         envir = ns)
[17:46:49.342]                       envir <- sys.frame(frame)
[17:46:49.342]                       master <- NULL
[17:46:49.342]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.342]                         !identical(envir, emptyenv())) {
[17:46:49.342]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.342]                           inherits = FALSE)) {
[17:46:49.342]                           master <- get("master", mode = "list", 
[17:46:49.342]                             envir = envir, inherits = FALSE)
[17:46:49.342]                           if (inherits(master, c("SOCKnode", 
[17:46:49.342]                             "SOCK0node"))) {
[17:46:49.342]                             sendCondition <<- function(cond) {
[17:46:49.342]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.342]                                 success = TRUE)
[17:46:49.342]                               parallel_sendData(master, data)
[17:46:49.342]                             }
[17:46:49.342]                             return(sendCondition)
[17:46:49.342]                           }
[17:46:49.342]                         }
[17:46:49.342]                         frame <- frame + 1L
[17:46:49.342]                         envir <- sys.frame(frame)
[17:46:49.342]                       }
[17:46:49.342]                     }
[17:46:49.342]                     sendCondition <<- function(cond) NULL
[17:46:49.342]                   }
[17:46:49.342]                 })
[17:46:49.342]                 withCallingHandlers({
[17:46:49.342]                   {
[17:46:49.342]                     4
[17:46:49.342]                   }
[17:46:49.342]                 }, immediateCondition = function(cond) {
[17:46:49.342]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.342]                   sendCondition(cond)
[17:46:49.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.342]                   {
[17:46:49.342]                     inherits <- base::inherits
[17:46:49.342]                     invokeRestart <- base::invokeRestart
[17:46:49.342]                     is.null <- base::is.null
[17:46:49.342]                     muffled <- FALSE
[17:46:49.342]                     if (inherits(cond, "message")) {
[17:46:49.342]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.342]                       if (muffled) 
[17:46:49.342]                         invokeRestart("muffleMessage")
[17:46:49.342]                     }
[17:46:49.342]                     else if (inherits(cond, "warning")) {
[17:46:49.342]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.342]                       if (muffled) 
[17:46:49.342]                         invokeRestart("muffleWarning")
[17:46:49.342]                     }
[17:46:49.342]                     else if (inherits(cond, "condition")) {
[17:46:49.342]                       if (!is.null(pattern)) {
[17:46:49.342]                         computeRestarts <- base::computeRestarts
[17:46:49.342]                         grepl <- base::grepl
[17:46:49.342]                         restarts <- computeRestarts(cond)
[17:46:49.342]                         for (restart in restarts) {
[17:46:49.342]                           name <- restart$name
[17:46:49.342]                           if (is.null(name)) 
[17:46:49.342]                             next
[17:46:49.342]                           if (!grepl(pattern, name)) 
[17:46:49.342]                             next
[17:46:49.342]                           invokeRestart(restart)
[17:46:49.342]                           muffled <- TRUE
[17:46:49.342]                           break
[17:46:49.342]                         }
[17:46:49.342]                       }
[17:46:49.342]                     }
[17:46:49.342]                     invisible(muffled)
[17:46:49.342]                   }
[17:46:49.342]                   muffleCondition(cond)
[17:46:49.342]                 })
[17:46:49.342]             }))
[17:46:49.342]             future::FutureResult(value = ...future.value$value, 
[17:46:49.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.342]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.342]                     ...future.globalenv.names))
[17:46:49.342]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.342]         }, condition = base::local({
[17:46:49.342]             c <- base::c
[17:46:49.342]             inherits <- base::inherits
[17:46:49.342]             invokeRestart <- base::invokeRestart
[17:46:49.342]             length <- base::length
[17:46:49.342]             list <- base::list
[17:46:49.342]             seq.int <- base::seq.int
[17:46:49.342]             signalCondition <- base::signalCondition
[17:46:49.342]             sys.calls <- base::sys.calls
[17:46:49.342]             `[[` <- base::`[[`
[17:46:49.342]             `+` <- base::`+`
[17:46:49.342]             `<<-` <- base::`<<-`
[17:46:49.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.342]                   3L)]
[17:46:49.342]             }
[17:46:49.342]             function(cond) {
[17:46:49.342]                 is_error <- inherits(cond, "error")
[17:46:49.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.342]                   NULL)
[17:46:49.342]                 if (is_error) {
[17:46:49.342]                   sessionInformation <- function() {
[17:46:49.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.342]                       search = base::search(), system = base::Sys.info())
[17:46:49.342]                   }
[17:46:49.342]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.342]                     cond$call), session = sessionInformation(), 
[17:46:49.342]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.342]                   signalCondition(cond)
[17:46:49.342]                 }
[17:46:49.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.342]                 "immediateCondition"))) {
[17:46:49.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.342]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.342]                   if (TRUE && !signal) {
[17:46:49.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.342]                     {
[17:46:49.342]                       inherits <- base::inherits
[17:46:49.342]                       invokeRestart <- base::invokeRestart
[17:46:49.342]                       is.null <- base::is.null
[17:46:49.342]                       muffled <- FALSE
[17:46:49.342]                       if (inherits(cond, "message")) {
[17:46:49.342]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.342]                         if (muffled) 
[17:46:49.342]                           invokeRestart("muffleMessage")
[17:46:49.342]                       }
[17:46:49.342]                       else if (inherits(cond, "warning")) {
[17:46:49.342]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.342]                         if (muffled) 
[17:46:49.342]                           invokeRestart("muffleWarning")
[17:46:49.342]                       }
[17:46:49.342]                       else if (inherits(cond, "condition")) {
[17:46:49.342]                         if (!is.null(pattern)) {
[17:46:49.342]                           computeRestarts <- base::computeRestarts
[17:46:49.342]                           grepl <- base::grepl
[17:46:49.342]                           restarts <- computeRestarts(cond)
[17:46:49.342]                           for (restart in restarts) {
[17:46:49.342]                             name <- restart$name
[17:46:49.342]                             if (is.null(name)) 
[17:46:49.342]                               next
[17:46:49.342]                             if (!grepl(pattern, name)) 
[17:46:49.342]                               next
[17:46:49.342]                             invokeRestart(restart)
[17:46:49.342]                             muffled <- TRUE
[17:46:49.342]                             break
[17:46:49.342]                           }
[17:46:49.342]                         }
[17:46:49.342]                       }
[17:46:49.342]                       invisible(muffled)
[17:46:49.342]                     }
[17:46:49.342]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.342]                   }
[17:46:49.342]                 }
[17:46:49.342]                 else {
[17:46:49.342]                   if (TRUE) {
[17:46:49.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.342]                     {
[17:46:49.342]                       inherits <- base::inherits
[17:46:49.342]                       invokeRestart <- base::invokeRestart
[17:46:49.342]                       is.null <- base::is.null
[17:46:49.342]                       muffled <- FALSE
[17:46:49.342]                       if (inherits(cond, "message")) {
[17:46:49.342]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.342]                         if (muffled) 
[17:46:49.342]                           invokeRestart("muffleMessage")
[17:46:49.342]                       }
[17:46:49.342]                       else if (inherits(cond, "warning")) {
[17:46:49.342]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.342]                         if (muffled) 
[17:46:49.342]                           invokeRestart("muffleWarning")
[17:46:49.342]                       }
[17:46:49.342]                       else if (inherits(cond, "condition")) {
[17:46:49.342]                         if (!is.null(pattern)) {
[17:46:49.342]                           computeRestarts <- base::computeRestarts
[17:46:49.342]                           grepl <- base::grepl
[17:46:49.342]                           restarts <- computeRestarts(cond)
[17:46:49.342]                           for (restart in restarts) {
[17:46:49.342]                             name <- restart$name
[17:46:49.342]                             if (is.null(name)) 
[17:46:49.342]                               next
[17:46:49.342]                             if (!grepl(pattern, name)) 
[17:46:49.342]                               next
[17:46:49.342]                             invokeRestart(restart)
[17:46:49.342]                             muffled <- TRUE
[17:46:49.342]                             break
[17:46:49.342]                           }
[17:46:49.342]                         }
[17:46:49.342]                       }
[17:46:49.342]                       invisible(muffled)
[17:46:49.342]                     }
[17:46:49.342]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.342]                   }
[17:46:49.342]                 }
[17:46:49.342]             }
[17:46:49.342]         }))
[17:46:49.342]     }, error = function(ex) {
[17:46:49.342]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.342]                 ...future.rng), started = ...future.startTime, 
[17:46:49.342]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.342]             version = "1.8"), class = "FutureResult")
[17:46:49.342]     }, finally = {
[17:46:49.342]         if (!identical(...future.workdir, getwd())) 
[17:46:49.342]             setwd(...future.workdir)
[17:46:49.342]         {
[17:46:49.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.342]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.342]             }
[17:46:49.342]             base::options(...future.oldOptions)
[17:46:49.342]             if (.Platform$OS.type == "windows") {
[17:46:49.342]                 old_names <- names(...future.oldEnvVars)
[17:46:49.342]                 envs <- base::Sys.getenv()
[17:46:49.342]                 names <- names(envs)
[17:46:49.342]                 common <- intersect(names, old_names)
[17:46:49.342]                 added <- setdiff(names, old_names)
[17:46:49.342]                 removed <- setdiff(old_names, names)
[17:46:49.342]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.342]                   envs[common]]
[17:46:49.342]                 NAMES <- toupper(changed)
[17:46:49.342]                 args <- list()
[17:46:49.342]                 for (kk in seq_along(NAMES)) {
[17:46:49.342]                   name <- changed[[kk]]
[17:46:49.342]                   NAME <- NAMES[[kk]]
[17:46:49.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.342]                     next
[17:46:49.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.342]                 }
[17:46:49.342]                 NAMES <- toupper(added)
[17:46:49.342]                 for (kk in seq_along(NAMES)) {
[17:46:49.342]                   name <- added[[kk]]
[17:46:49.342]                   NAME <- NAMES[[kk]]
[17:46:49.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.342]                     next
[17:46:49.342]                   args[[name]] <- ""
[17:46:49.342]                 }
[17:46:49.342]                 NAMES <- toupper(removed)
[17:46:49.342]                 for (kk in seq_along(NAMES)) {
[17:46:49.342]                   name <- removed[[kk]]
[17:46:49.342]                   NAME <- NAMES[[kk]]
[17:46:49.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.342]                     next
[17:46:49.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.342]                 }
[17:46:49.342]                 if (length(args) > 0) 
[17:46:49.342]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.342]             }
[17:46:49.342]             else {
[17:46:49.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.342]             }
[17:46:49.342]             {
[17:46:49.342]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.342]                   0L) {
[17:46:49.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.342]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.342]                   base::options(opts)
[17:46:49.342]                 }
[17:46:49.342]                 {
[17:46:49.342]                   {
[17:46:49.342]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.342]                     NULL
[17:46:49.342]                   }
[17:46:49.342]                   options(future.plan = NULL)
[17:46:49.342]                   if (is.na(NA_character_)) 
[17:46:49.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.342]                     .init = FALSE)
[17:46:49.342]                 }
[17:46:49.342]             }
[17:46:49.342]         }
[17:46:49.342]     })
[17:46:49.342]     if (TRUE) {
[17:46:49.342]         base::sink(type = "output", split = FALSE)
[17:46:49.342]         if (TRUE) {
[17:46:49.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.342]         }
[17:46:49.342]         else {
[17:46:49.342]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.342]         }
[17:46:49.342]         base::close(...future.stdout)
[17:46:49.342]         ...future.stdout <- NULL
[17:46:49.342]     }
[17:46:49.342]     ...future.result$conditions <- ...future.conditions
[17:46:49.342]     ...future.result$finished <- base::Sys.time()
[17:46:49.342]     ...future.result
[17:46:49.342] }
[17:46:49.344] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:49.355] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.355] - Validating connection of MultisessionFuture
[17:46:49.355] - received message: FutureResult
[17:46:49.355] - Received FutureResult
[17:46:49.355] - Erased future from FutureRegistry
[17:46:49.356] result() for ClusterFuture ...
[17:46:49.356] - result already collected: FutureResult
[17:46:49.356] result() for ClusterFuture ... done
[17:46:49.356] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.356] result() for ClusterFuture ...
[17:46:49.356] - result already collected: FutureResult
[17:46:49.356] result() for ClusterFuture ... done
[17:46:49.356] result() for ClusterFuture ...
[17:46:49.356] - result already collected: FutureResult
[17:46:49.356] result() for ClusterFuture ... done
[17:46:49.357] MultisessionFuture started
[17:46:49.357] - Launch lazy future ... done
[17:46:49.357] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5617862f1540> 
Classes 'listenv', 'environment' <environment: 0x5617894150a8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:46:49.361] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.362] - Validating connection of MultisessionFuture
[17:46:49.362] - received message: FutureResult
[17:46:49.362] - Received FutureResult
[17:46:49.362] - Erased future from FutureRegistry
[17:46:49.362] result() for ClusterFuture ...
[17:46:49.362] - result already collected: FutureResult
[17:46:49.362] result() for ClusterFuture ... done
[17:46:49.362] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.363] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.363] - Validating connection of MultisessionFuture
[17:46:49.363] - received message: FutureResult
[17:46:49.363] - Received FutureResult
[17:46:49.363] - Erased future from FutureRegistry
[17:46:49.363] result() for ClusterFuture ...
[17:46:49.363] - result already collected: FutureResult
[17:46:49.363] result() for ClusterFuture ... done
[17:46:49.364] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:49.366] resolve() on list environment ...
[17:46:49.366]  recursive: 0
[17:46:49.367]  length: 6
[17:46:49.367]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:49.367] signalConditionsASAP(numeric, pos=1) ...
[17:46:49.367] - nx: 6
[17:46:49.367] - relay: TRUE
[17:46:49.367] - stdout: TRUE
[17:46:49.367] - signal: TRUE
[17:46:49.367] - resignal: FALSE
[17:46:49.368] - force: TRUE
[17:46:49.368] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.368] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.368]  - until=2
[17:46:49.368]  - relaying element #2
[17:46:49.368] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.368] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.368] signalConditionsASAP(NULL, pos=1) ... done
[17:46:49.368]  length: 5 (resolved future 1)
[17:46:49.368] Future #2
[17:46:49.368] result() for ClusterFuture ...
[17:46:49.369] - result already collected: FutureResult
[17:46:49.369] result() for ClusterFuture ... done
[17:46:49.369] result() for ClusterFuture ...
[17:46:49.369] - result already collected: FutureResult
[17:46:49.369] result() for ClusterFuture ... done
[17:46:49.369] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:49.369] - nx: 6
[17:46:49.369] - relay: TRUE
[17:46:49.369] - stdout: TRUE
[17:46:49.369] - signal: TRUE
[17:46:49.369] - resignal: FALSE
[17:46:49.370] - force: TRUE
[17:46:49.370] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.370] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.370]  - until=2
[17:46:49.370]  - relaying element #2
[17:46:49.370] result() for ClusterFuture ...
[17:46:49.370] - result already collected: FutureResult
[17:46:49.370] result() for ClusterFuture ... done
[17:46:49.370] result() for ClusterFuture ...
[17:46:49.370] - result already collected: FutureResult
[17:46:49.370] result() for ClusterFuture ... done
[17:46:49.371] result() for ClusterFuture ...
[17:46:49.371] - result already collected: FutureResult
[17:46:49.371] result() for ClusterFuture ... done
[17:46:49.371] result() for ClusterFuture ...
[17:46:49.371] - result already collected: FutureResult
[17:46:49.371] result() for ClusterFuture ... done
[17:46:49.371] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.371] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.371] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:49.371]  length: 4 (resolved future 2)
[17:46:49.371] Future #3
[17:46:49.372] result() for ClusterFuture ...
[17:46:49.372] - result already collected: FutureResult
[17:46:49.372] result() for ClusterFuture ... done
[17:46:49.372] result() for ClusterFuture ...
[17:46:49.372] - result already collected: FutureResult
[17:46:49.372] result() for ClusterFuture ... done
[17:46:49.372] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:49.372] - nx: 6
[17:46:49.372] - relay: TRUE
[17:46:49.372] - stdout: TRUE
[17:46:49.372] - signal: TRUE
[17:46:49.372] - resignal: FALSE
[17:46:49.373] - force: TRUE
[17:46:49.373] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.373] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.373]  - until=3
[17:46:49.373]  - relaying element #3
[17:46:49.373] result() for ClusterFuture ...
[17:46:49.373] - result already collected: FutureResult
[17:46:49.373] result() for ClusterFuture ... done
[17:46:49.373] result() for ClusterFuture ...
[17:46:49.373] - result already collected: FutureResult
[17:46:49.373] result() for ClusterFuture ... done
[17:46:49.374] result() for ClusterFuture ...
[17:46:49.374] - result already collected: FutureResult
[17:46:49.374] result() for ClusterFuture ... done
[17:46:49.374] result() for ClusterFuture ...
[17:46:49.374] - result already collected: FutureResult
[17:46:49.374] result() for ClusterFuture ... done
[17:46:49.374] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.374] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.377] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:49.377]  length: 3 (resolved future 3)
[17:46:49.377] Future #4
[17:46:49.377] result() for ClusterFuture ...
[17:46:49.378] - result already collected: FutureResult
[17:46:49.378] result() for ClusterFuture ... done
[17:46:49.378] result() for ClusterFuture ...
[17:46:49.378] - result already collected: FutureResult
[17:46:49.378] result() for ClusterFuture ... done
[17:46:49.378] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:49.378] - nx: 6
[17:46:49.378] - relay: TRUE
[17:46:49.378] - stdout: TRUE
[17:46:49.378] - signal: TRUE
[17:46:49.379] - resignal: FALSE
[17:46:49.379] - force: TRUE
[17:46:49.379] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.379] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.379]  - until=4
[17:46:49.379]  - relaying element #4
[17:46:49.379] result() for ClusterFuture ...
[17:46:49.379] - result already collected: FutureResult
[17:46:49.379] result() for ClusterFuture ... done
[17:46:49.379] result() for ClusterFuture ...
[17:46:49.379] - result already collected: FutureResult
[17:46:49.379] result() for ClusterFuture ... done
[17:46:49.380] result() for ClusterFuture ...
[17:46:49.380] - result already collected: FutureResult
[17:46:49.380] result() for ClusterFuture ... done
[17:46:49.380] result() for ClusterFuture ...
[17:46:49.380] - result already collected: FutureResult
[17:46:49.380] result() for ClusterFuture ... done
[17:46:49.380] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.380] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.380] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:49.380]  length: 2 (resolved future 4)
[17:46:49.380] signalConditionsASAP(NULL, pos=5) ...
[17:46:49.381] - nx: 6
[17:46:49.381] - relay: TRUE
[17:46:49.381] - stdout: TRUE
[17:46:49.381] - signal: TRUE
[17:46:49.381] - resignal: FALSE
[17:46:49.381] - force: TRUE
[17:46:49.381] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.381] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.381]  - until=6
[17:46:49.381]  - relaying element #6
[17:46:49.381] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.381] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.382] signalConditionsASAP(NULL, pos=5) ... done
[17:46:49.382]  length: 1 (resolved future 5)
[17:46:49.382] signalConditionsASAP(numeric, pos=6) ...
[17:46:49.382] - nx: 6
[17:46:49.382] - relay: TRUE
[17:46:49.382] - stdout: TRUE
[17:46:49.382] - signal: TRUE
[17:46:49.382] - resignal: FALSE
[17:46:49.382] - force: TRUE
[17:46:49.382] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.382] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.382]  - until=6
[17:46:49.383] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.383] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.383] signalConditionsASAP(numeric, pos=6) ... done
[17:46:49.383]  length: 0 (resolved future 6)
[17:46:49.383] Relaying remaining futures
[17:46:49.383] signalConditionsASAP(NULL, pos=0) ...
[17:46:49.383] - nx: 6
[17:46:49.383] - relay: TRUE
[17:46:49.383] - stdout: TRUE
[17:46:49.383] - signal: TRUE
[17:46:49.383] - resignal: FALSE
[17:46:49.384] - force: TRUE
[17:46:49.384] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.384] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:49.384] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.384] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.384] signalConditionsASAP(NULL, pos=0) ... done
[17:46:49.384] resolve() on list environment ... DONE
[17:46:49.384] result() for ClusterFuture ...
[17:46:49.384] - result already collected: FutureResult
[17:46:49.384] result() for ClusterFuture ... done
[17:46:49.384] result() for ClusterFuture ...
[17:46:49.385] - result already collected: FutureResult
[17:46:49.385] result() for ClusterFuture ... done
[17:46:49.385] result() for ClusterFuture ...
[17:46:49.385] - result already collected: FutureResult
[17:46:49.385] result() for ClusterFuture ... done
[17:46:49.385] result() for ClusterFuture ...
[17:46:49.385] - result already collected: FutureResult
[17:46:49.385] result() for ClusterFuture ... done
[17:46:49.385] result() for ClusterFuture ...
[17:46:49.385] - result already collected: FutureResult
[17:46:49.386] result() for ClusterFuture ... done
[17:46:49.386] result() for ClusterFuture ...
[17:46:49.386] - result already collected: FutureResult
[17:46:49.386] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x561789812418> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:46:49.387] getGlobalsAndPackages() ...
[17:46:49.388] Searching for globals...
[17:46:49.388] 
[17:46:49.388] Searching for globals ... DONE
[17:46:49.388] - globals: [0] <none>
[17:46:49.388] getGlobalsAndPackages() ... DONE
[17:46:49.388] run() for ‘Future’ ...
[17:46:49.389] - state: ‘created’
[17:46:49.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.403] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.403]   - Field: ‘node’
[17:46:49.403]   - Field: ‘label’
[17:46:49.403]   - Field: ‘local’
[17:46:49.403]   - Field: ‘owner’
[17:46:49.403]   - Field: ‘envir’
[17:46:49.403]   - Field: ‘workers’
[17:46:49.404]   - Field: ‘packages’
[17:46:49.404]   - Field: ‘gc’
[17:46:49.404]   - Field: ‘conditions’
[17:46:49.404]   - Field: ‘persistent’
[17:46:49.404]   - Field: ‘expr’
[17:46:49.404]   - Field: ‘uuid’
[17:46:49.404]   - Field: ‘seed’
[17:46:49.404]   - Field: ‘version’
[17:46:49.404]   - Field: ‘result’
[17:46:49.404]   - Field: ‘asynchronous’
[17:46:49.405]   - Field: ‘calls’
[17:46:49.405]   - Field: ‘globals’
[17:46:49.405]   - Field: ‘stdout’
[17:46:49.405]   - Field: ‘earlySignal’
[17:46:49.405]   - Field: ‘lazy’
[17:46:49.405]   - Field: ‘state’
[17:46:49.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.405] - Launch lazy future ...
[17:46:49.405] Packages needed by the future expression (n = 0): <none>
[17:46:49.406] Packages needed by future strategies (n = 0): <none>
[17:46:49.406] {
[17:46:49.406]     {
[17:46:49.406]         {
[17:46:49.406]             ...future.startTime <- base::Sys.time()
[17:46:49.406]             {
[17:46:49.406]                 {
[17:46:49.406]                   {
[17:46:49.406]                     {
[17:46:49.406]                       base::local({
[17:46:49.406]                         has_future <- base::requireNamespace("future", 
[17:46:49.406]                           quietly = TRUE)
[17:46:49.406]                         if (has_future) {
[17:46:49.406]                           ns <- base::getNamespace("future")
[17:46:49.406]                           version <- ns[[".package"]][["version"]]
[17:46:49.406]                           if (is.null(version)) 
[17:46:49.406]                             version <- utils::packageVersion("future")
[17:46:49.406]                         }
[17:46:49.406]                         else {
[17:46:49.406]                           version <- NULL
[17:46:49.406]                         }
[17:46:49.406]                         if (!has_future || version < "1.8.0") {
[17:46:49.406]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.406]                             "", base::R.version$version.string), 
[17:46:49.406]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.406]                               "release", "version")], collapse = " "), 
[17:46:49.406]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.406]                             info)
[17:46:49.406]                           info <- base::paste(info, collapse = "; ")
[17:46:49.406]                           if (!has_future) {
[17:46:49.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.406]                               info)
[17:46:49.406]                           }
[17:46:49.406]                           else {
[17:46:49.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.406]                               info, version)
[17:46:49.406]                           }
[17:46:49.406]                           base::stop(msg)
[17:46:49.406]                         }
[17:46:49.406]                       })
[17:46:49.406]                     }
[17:46:49.406]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.406]                     base::options(mc.cores = 1L)
[17:46:49.406]                   }
[17:46:49.406]                   ...future.strategy.old <- future::plan("list")
[17:46:49.406]                   options(future.plan = NULL)
[17:46:49.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.406]                 }
[17:46:49.406]                 ...future.workdir <- getwd()
[17:46:49.406]             }
[17:46:49.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.406]         }
[17:46:49.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.406]             base::names(...future.oldOptions))
[17:46:49.406]     }
[17:46:49.406]     if (FALSE) {
[17:46:49.406]     }
[17:46:49.406]     else {
[17:46:49.406]         if (TRUE) {
[17:46:49.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.406]                 open = "w")
[17:46:49.406]         }
[17:46:49.406]         else {
[17:46:49.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.406]         }
[17:46:49.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.406]             base::sink(type = "output", split = FALSE)
[17:46:49.406]             base::close(...future.stdout)
[17:46:49.406]         }, add = TRUE)
[17:46:49.406]     }
[17:46:49.406]     ...future.frame <- base::sys.nframe()
[17:46:49.406]     ...future.conditions <- base::list()
[17:46:49.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.406]     if (FALSE) {
[17:46:49.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.406]     }
[17:46:49.406]     ...future.result <- base::tryCatch({
[17:46:49.406]         base::withCallingHandlers({
[17:46:49.406]             ...future.value <- base::withVisible(base::local({
[17:46:49.406]                 ...future.makeSendCondition <- base::local({
[17:46:49.406]                   sendCondition <- NULL
[17:46:49.406]                   function(frame = 1L) {
[17:46:49.406]                     if (is.function(sendCondition)) 
[17:46:49.406]                       return(sendCondition)
[17:46:49.406]                     ns <- getNamespace("parallel")
[17:46:49.406]                     if (exists("sendData", mode = "function", 
[17:46:49.406]                       envir = ns)) {
[17:46:49.406]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.406]                         envir = ns)
[17:46:49.406]                       envir <- sys.frame(frame)
[17:46:49.406]                       master <- NULL
[17:46:49.406]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.406]                         !identical(envir, emptyenv())) {
[17:46:49.406]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.406]                           inherits = FALSE)) {
[17:46:49.406]                           master <- get("master", mode = "list", 
[17:46:49.406]                             envir = envir, inherits = FALSE)
[17:46:49.406]                           if (inherits(master, c("SOCKnode", 
[17:46:49.406]                             "SOCK0node"))) {
[17:46:49.406]                             sendCondition <<- function(cond) {
[17:46:49.406]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.406]                                 success = TRUE)
[17:46:49.406]                               parallel_sendData(master, data)
[17:46:49.406]                             }
[17:46:49.406]                             return(sendCondition)
[17:46:49.406]                           }
[17:46:49.406]                         }
[17:46:49.406]                         frame <- frame + 1L
[17:46:49.406]                         envir <- sys.frame(frame)
[17:46:49.406]                       }
[17:46:49.406]                     }
[17:46:49.406]                     sendCondition <<- function(cond) NULL
[17:46:49.406]                   }
[17:46:49.406]                 })
[17:46:49.406]                 withCallingHandlers({
[17:46:49.406]                   2
[17:46:49.406]                 }, immediateCondition = function(cond) {
[17:46:49.406]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.406]                   sendCondition(cond)
[17:46:49.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.406]                   {
[17:46:49.406]                     inherits <- base::inherits
[17:46:49.406]                     invokeRestart <- base::invokeRestart
[17:46:49.406]                     is.null <- base::is.null
[17:46:49.406]                     muffled <- FALSE
[17:46:49.406]                     if (inherits(cond, "message")) {
[17:46:49.406]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.406]                       if (muffled) 
[17:46:49.406]                         invokeRestart("muffleMessage")
[17:46:49.406]                     }
[17:46:49.406]                     else if (inherits(cond, "warning")) {
[17:46:49.406]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.406]                       if (muffled) 
[17:46:49.406]                         invokeRestart("muffleWarning")
[17:46:49.406]                     }
[17:46:49.406]                     else if (inherits(cond, "condition")) {
[17:46:49.406]                       if (!is.null(pattern)) {
[17:46:49.406]                         computeRestarts <- base::computeRestarts
[17:46:49.406]                         grepl <- base::grepl
[17:46:49.406]                         restarts <- computeRestarts(cond)
[17:46:49.406]                         for (restart in restarts) {
[17:46:49.406]                           name <- restart$name
[17:46:49.406]                           if (is.null(name)) 
[17:46:49.406]                             next
[17:46:49.406]                           if (!grepl(pattern, name)) 
[17:46:49.406]                             next
[17:46:49.406]                           invokeRestart(restart)
[17:46:49.406]                           muffled <- TRUE
[17:46:49.406]                           break
[17:46:49.406]                         }
[17:46:49.406]                       }
[17:46:49.406]                     }
[17:46:49.406]                     invisible(muffled)
[17:46:49.406]                   }
[17:46:49.406]                   muffleCondition(cond)
[17:46:49.406]                 })
[17:46:49.406]             }))
[17:46:49.406]             future::FutureResult(value = ...future.value$value, 
[17:46:49.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.406]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.406]                     ...future.globalenv.names))
[17:46:49.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.406]         }, condition = base::local({
[17:46:49.406]             c <- base::c
[17:46:49.406]             inherits <- base::inherits
[17:46:49.406]             invokeRestart <- base::invokeRestart
[17:46:49.406]             length <- base::length
[17:46:49.406]             list <- base::list
[17:46:49.406]             seq.int <- base::seq.int
[17:46:49.406]             signalCondition <- base::signalCondition
[17:46:49.406]             sys.calls <- base::sys.calls
[17:46:49.406]             `[[` <- base::`[[`
[17:46:49.406]             `+` <- base::`+`
[17:46:49.406]             `<<-` <- base::`<<-`
[17:46:49.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.406]                   3L)]
[17:46:49.406]             }
[17:46:49.406]             function(cond) {
[17:46:49.406]                 is_error <- inherits(cond, "error")
[17:46:49.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.406]                   NULL)
[17:46:49.406]                 if (is_error) {
[17:46:49.406]                   sessionInformation <- function() {
[17:46:49.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.406]                       search = base::search(), system = base::Sys.info())
[17:46:49.406]                   }
[17:46:49.406]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.406]                     cond$call), session = sessionInformation(), 
[17:46:49.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.406]                   signalCondition(cond)
[17:46:49.406]                 }
[17:46:49.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.406]                 "immediateCondition"))) {
[17:46:49.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.406]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.406]                   if (TRUE && !signal) {
[17:46:49.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.406]                     {
[17:46:49.406]                       inherits <- base::inherits
[17:46:49.406]                       invokeRestart <- base::invokeRestart
[17:46:49.406]                       is.null <- base::is.null
[17:46:49.406]                       muffled <- FALSE
[17:46:49.406]                       if (inherits(cond, "message")) {
[17:46:49.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.406]                         if (muffled) 
[17:46:49.406]                           invokeRestart("muffleMessage")
[17:46:49.406]                       }
[17:46:49.406]                       else if (inherits(cond, "warning")) {
[17:46:49.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.406]                         if (muffled) 
[17:46:49.406]                           invokeRestart("muffleWarning")
[17:46:49.406]                       }
[17:46:49.406]                       else if (inherits(cond, "condition")) {
[17:46:49.406]                         if (!is.null(pattern)) {
[17:46:49.406]                           computeRestarts <- base::computeRestarts
[17:46:49.406]                           grepl <- base::grepl
[17:46:49.406]                           restarts <- computeRestarts(cond)
[17:46:49.406]                           for (restart in restarts) {
[17:46:49.406]                             name <- restart$name
[17:46:49.406]                             if (is.null(name)) 
[17:46:49.406]                               next
[17:46:49.406]                             if (!grepl(pattern, name)) 
[17:46:49.406]                               next
[17:46:49.406]                             invokeRestart(restart)
[17:46:49.406]                             muffled <- TRUE
[17:46:49.406]                             break
[17:46:49.406]                           }
[17:46:49.406]                         }
[17:46:49.406]                       }
[17:46:49.406]                       invisible(muffled)
[17:46:49.406]                     }
[17:46:49.406]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.406]                   }
[17:46:49.406]                 }
[17:46:49.406]                 else {
[17:46:49.406]                   if (TRUE) {
[17:46:49.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.406]                     {
[17:46:49.406]                       inherits <- base::inherits
[17:46:49.406]                       invokeRestart <- base::invokeRestart
[17:46:49.406]                       is.null <- base::is.null
[17:46:49.406]                       muffled <- FALSE
[17:46:49.406]                       if (inherits(cond, "message")) {
[17:46:49.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.406]                         if (muffled) 
[17:46:49.406]                           invokeRestart("muffleMessage")
[17:46:49.406]                       }
[17:46:49.406]                       else if (inherits(cond, "warning")) {
[17:46:49.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.406]                         if (muffled) 
[17:46:49.406]                           invokeRestart("muffleWarning")
[17:46:49.406]                       }
[17:46:49.406]                       else if (inherits(cond, "condition")) {
[17:46:49.406]                         if (!is.null(pattern)) {
[17:46:49.406]                           computeRestarts <- base::computeRestarts
[17:46:49.406]                           grepl <- base::grepl
[17:46:49.406]                           restarts <- computeRestarts(cond)
[17:46:49.406]                           for (restart in restarts) {
[17:46:49.406]                             name <- restart$name
[17:46:49.406]                             if (is.null(name)) 
[17:46:49.406]                               next
[17:46:49.406]                             if (!grepl(pattern, name)) 
[17:46:49.406]                               next
[17:46:49.406]                             invokeRestart(restart)
[17:46:49.406]                             muffled <- TRUE
[17:46:49.406]                             break
[17:46:49.406]                           }
[17:46:49.406]                         }
[17:46:49.406]                       }
[17:46:49.406]                       invisible(muffled)
[17:46:49.406]                     }
[17:46:49.406]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.406]                   }
[17:46:49.406]                 }
[17:46:49.406]             }
[17:46:49.406]         }))
[17:46:49.406]     }, error = function(ex) {
[17:46:49.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.406]                 ...future.rng), started = ...future.startTime, 
[17:46:49.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.406]             version = "1.8"), class = "FutureResult")
[17:46:49.406]     }, finally = {
[17:46:49.406]         if (!identical(...future.workdir, getwd())) 
[17:46:49.406]             setwd(...future.workdir)
[17:46:49.406]         {
[17:46:49.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.406]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.406]             }
[17:46:49.406]             base::options(...future.oldOptions)
[17:46:49.406]             if (.Platform$OS.type == "windows") {
[17:46:49.406]                 old_names <- names(...future.oldEnvVars)
[17:46:49.406]                 envs <- base::Sys.getenv()
[17:46:49.406]                 names <- names(envs)
[17:46:49.406]                 common <- intersect(names, old_names)
[17:46:49.406]                 added <- setdiff(names, old_names)
[17:46:49.406]                 removed <- setdiff(old_names, names)
[17:46:49.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.406]                   envs[common]]
[17:46:49.406]                 NAMES <- toupper(changed)
[17:46:49.406]                 args <- list()
[17:46:49.406]                 for (kk in seq_along(NAMES)) {
[17:46:49.406]                   name <- changed[[kk]]
[17:46:49.406]                   NAME <- NAMES[[kk]]
[17:46:49.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.406]                     next
[17:46:49.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.406]                 }
[17:46:49.406]                 NAMES <- toupper(added)
[17:46:49.406]                 for (kk in seq_along(NAMES)) {
[17:46:49.406]                   name <- added[[kk]]
[17:46:49.406]                   NAME <- NAMES[[kk]]
[17:46:49.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.406]                     next
[17:46:49.406]                   args[[name]] <- ""
[17:46:49.406]                 }
[17:46:49.406]                 NAMES <- toupper(removed)
[17:46:49.406]                 for (kk in seq_along(NAMES)) {
[17:46:49.406]                   name <- removed[[kk]]
[17:46:49.406]                   NAME <- NAMES[[kk]]
[17:46:49.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.406]                     next
[17:46:49.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.406]                 }
[17:46:49.406]                 if (length(args) > 0) 
[17:46:49.406]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.406]             }
[17:46:49.406]             else {
[17:46:49.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.406]             }
[17:46:49.406]             {
[17:46:49.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.406]                   0L) {
[17:46:49.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.406]                   base::options(opts)
[17:46:49.406]                 }
[17:46:49.406]                 {
[17:46:49.406]                   {
[17:46:49.406]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.406]                     NULL
[17:46:49.406]                   }
[17:46:49.406]                   options(future.plan = NULL)
[17:46:49.406]                   if (is.na(NA_character_)) 
[17:46:49.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.406]                     .init = FALSE)
[17:46:49.406]                 }
[17:46:49.406]             }
[17:46:49.406]         }
[17:46:49.406]     })
[17:46:49.406]     if (TRUE) {
[17:46:49.406]         base::sink(type = "output", split = FALSE)
[17:46:49.406]         if (TRUE) {
[17:46:49.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.406]         }
[17:46:49.406]         else {
[17:46:49.406]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.406]         }
[17:46:49.406]         base::close(...future.stdout)
[17:46:49.406]         ...future.stdout <- NULL
[17:46:49.406]     }
[17:46:49.406]     ...future.result$conditions <- ...future.conditions
[17:46:49.406]     ...future.result$finished <- base::Sys.time()
[17:46:49.406]     ...future.result
[17:46:49.406] }
[17:46:49.409] MultisessionFuture started
[17:46:49.409] - Launch lazy future ... done
[17:46:49.409] run() for ‘MultisessionFuture’ ... done
[17:46:49.409] getGlobalsAndPackages() ...
[17:46:49.409] Searching for globals...
[17:46:49.410] 
[17:46:49.410] Searching for globals ... DONE
[17:46:49.410] - globals: [0] <none>
[17:46:49.410] getGlobalsAndPackages() ... DONE
[17:46:49.410] run() for ‘Future’ ...
[17:46:49.410] - state: ‘created’
[17:46:49.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.426]   - Field: ‘node’
[17:46:49.426]   - Field: ‘label’
[17:46:49.426]   - Field: ‘local’
[17:46:49.426]   - Field: ‘owner’
[17:46:49.426]   - Field: ‘envir’
[17:46:49.426]   - Field: ‘workers’
[17:46:49.426]   - Field: ‘packages’
[17:46:49.427]   - Field: ‘gc’
[17:46:49.427]   - Field: ‘conditions’
[17:46:49.427]   - Field: ‘persistent’
[17:46:49.427]   - Field: ‘expr’
[17:46:49.427]   - Field: ‘uuid’
[17:46:49.427]   - Field: ‘seed’
[17:46:49.427]   - Field: ‘version’
[17:46:49.427]   - Field: ‘result’
[17:46:49.427]   - Field: ‘asynchronous’
[17:46:49.427]   - Field: ‘calls’
[17:46:49.428]   - Field: ‘globals’
[17:46:49.428]   - Field: ‘stdout’
[17:46:49.428]   - Field: ‘earlySignal’
[17:46:49.428]   - Field: ‘lazy’
[17:46:49.428]   - Field: ‘state’
[17:46:49.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.428] - Launch lazy future ...
[17:46:49.428] Packages needed by the future expression (n = 0): <none>
[17:46:49.428] Packages needed by future strategies (n = 0): <none>
[17:46:49.429] {
[17:46:49.429]     {
[17:46:49.429]         {
[17:46:49.429]             ...future.startTime <- base::Sys.time()
[17:46:49.429]             {
[17:46:49.429]                 {
[17:46:49.429]                   {
[17:46:49.429]                     {
[17:46:49.429]                       base::local({
[17:46:49.429]                         has_future <- base::requireNamespace("future", 
[17:46:49.429]                           quietly = TRUE)
[17:46:49.429]                         if (has_future) {
[17:46:49.429]                           ns <- base::getNamespace("future")
[17:46:49.429]                           version <- ns[[".package"]][["version"]]
[17:46:49.429]                           if (is.null(version)) 
[17:46:49.429]                             version <- utils::packageVersion("future")
[17:46:49.429]                         }
[17:46:49.429]                         else {
[17:46:49.429]                           version <- NULL
[17:46:49.429]                         }
[17:46:49.429]                         if (!has_future || version < "1.8.0") {
[17:46:49.429]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.429]                             "", base::R.version$version.string), 
[17:46:49.429]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.429]                               "release", "version")], collapse = " "), 
[17:46:49.429]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.429]                             info)
[17:46:49.429]                           info <- base::paste(info, collapse = "; ")
[17:46:49.429]                           if (!has_future) {
[17:46:49.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.429]                               info)
[17:46:49.429]                           }
[17:46:49.429]                           else {
[17:46:49.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.429]                               info, version)
[17:46:49.429]                           }
[17:46:49.429]                           base::stop(msg)
[17:46:49.429]                         }
[17:46:49.429]                       })
[17:46:49.429]                     }
[17:46:49.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.429]                     base::options(mc.cores = 1L)
[17:46:49.429]                   }
[17:46:49.429]                   ...future.strategy.old <- future::plan("list")
[17:46:49.429]                   options(future.plan = NULL)
[17:46:49.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.429]                 }
[17:46:49.429]                 ...future.workdir <- getwd()
[17:46:49.429]             }
[17:46:49.429]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.429]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.429]         }
[17:46:49.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.429]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.429]             base::names(...future.oldOptions))
[17:46:49.429]     }
[17:46:49.429]     if (FALSE) {
[17:46:49.429]     }
[17:46:49.429]     else {
[17:46:49.429]         if (TRUE) {
[17:46:49.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.429]                 open = "w")
[17:46:49.429]         }
[17:46:49.429]         else {
[17:46:49.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.429]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.429]         }
[17:46:49.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.429]             base::sink(type = "output", split = FALSE)
[17:46:49.429]             base::close(...future.stdout)
[17:46:49.429]         }, add = TRUE)
[17:46:49.429]     }
[17:46:49.429]     ...future.frame <- base::sys.nframe()
[17:46:49.429]     ...future.conditions <- base::list()
[17:46:49.429]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.429]     if (FALSE) {
[17:46:49.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.429]     }
[17:46:49.429]     ...future.result <- base::tryCatch({
[17:46:49.429]         base::withCallingHandlers({
[17:46:49.429]             ...future.value <- base::withVisible(base::local({
[17:46:49.429]                 ...future.makeSendCondition <- base::local({
[17:46:49.429]                   sendCondition <- NULL
[17:46:49.429]                   function(frame = 1L) {
[17:46:49.429]                     if (is.function(sendCondition)) 
[17:46:49.429]                       return(sendCondition)
[17:46:49.429]                     ns <- getNamespace("parallel")
[17:46:49.429]                     if (exists("sendData", mode = "function", 
[17:46:49.429]                       envir = ns)) {
[17:46:49.429]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.429]                         envir = ns)
[17:46:49.429]                       envir <- sys.frame(frame)
[17:46:49.429]                       master <- NULL
[17:46:49.429]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.429]                         !identical(envir, emptyenv())) {
[17:46:49.429]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.429]                           inherits = FALSE)) {
[17:46:49.429]                           master <- get("master", mode = "list", 
[17:46:49.429]                             envir = envir, inherits = FALSE)
[17:46:49.429]                           if (inherits(master, c("SOCKnode", 
[17:46:49.429]                             "SOCK0node"))) {
[17:46:49.429]                             sendCondition <<- function(cond) {
[17:46:49.429]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.429]                                 success = TRUE)
[17:46:49.429]                               parallel_sendData(master, data)
[17:46:49.429]                             }
[17:46:49.429]                             return(sendCondition)
[17:46:49.429]                           }
[17:46:49.429]                         }
[17:46:49.429]                         frame <- frame + 1L
[17:46:49.429]                         envir <- sys.frame(frame)
[17:46:49.429]                       }
[17:46:49.429]                     }
[17:46:49.429]                     sendCondition <<- function(cond) NULL
[17:46:49.429]                   }
[17:46:49.429]                 })
[17:46:49.429]                 withCallingHandlers({
[17:46:49.429]                   NULL
[17:46:49.429]                 }, immediateCondition = function(cond) {
[17:46:49.429]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.429]                   sendCondition(cond)
[17:46:49.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.429]                   {
[17:46:49.429]                     inherits <- base::inherits
[17:46:49.429]                     invokeRestart <- base::invokeRestart
[17:46:49.429]                     is.null <- base::is.null
[17:46:49.429]                     muffled <- FALSE
[17:46:49.429]                     if (inherits(cond, "message")) {
[17:46:49.429]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.429]                       if (muffled) 
[17:46:49.429]                         invokeRestart("muffleMessage")
[17:46:49.429]                     }
[17:46:49.429]                     else if (inherits(cond, "warning")) {
[17:46:49.429]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.429]                       if (muffled) 
[17:46:49.429]                         invokeRestart("muffleWarning")
[17:46:49.429]                     }
[17:46:49.429]                     else if (inherits(cond, "condition")) {
[17:46:49.429]                       if (!is.null(pattern)) {
[17:46:49.429]                         computeRestarts <- base::computeRestarts
[17:46:49.429]                         grepl <- base::grepl
[17:46:49.429]                         restarts <- computeRestarts(cond)
[17:46:49.429]                         for (restart in restarts) {
[17:46:49.429]                           name <- restart$name
[17:46:49.429]                           if (is.null(name)) 
[17:46:49.429]                             next
[17:46:49.429]                           if (!grepl(pattern, name)) 
[17:46:49.429]                             next
[17:46:49.429]                           invokeRestart(restart)
[17:46:49.429]                           muffled <- TRUE
[17:46:49.429]                           break
[17:46:49.429]                         }
[17:46:49.429]                       }
[17:46:49.429]                     }
[17:46:49.429]                     invisible(muffled)
[17:46:49.429]                   }
[17:46:49.429]                   muffleCondition(cond)
[17:46:49.429]                 })
[17:46:49.429]             }))
[17:46:49.429]             future::FutureResult(value = ...future.value$value, 
[17:46:49.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.429]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.429]                     ...future.globalenv.names))
[17:46:49.429]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.429]         }, condition = base::local({
[17:46:49.429]             c <- base::c
[17:46:49.429]             inherits <- base::inherits
[17:46:49.429]             invokeRestart <- base::invokeRestart
[17:46:49.429]             length <- base::length
[17:46:49.429]             list <- base::list
[17:46:49.429]             seq.int <- base::seq.int
[17:46:49.429]             signalCondition <- base::signalCondition
[17:46:49.429]             sys.calls <- base::sys.calls
[17:46:49.429]             `[[` <- base::`[[`
[17:46:49.429]             `+` <- base::`+`
[17:46:49.429]             `<<-` <- base::`<<-`
[17:46:49.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.429]                   3L)]
[17:46:49.429]             }
[17:46:49.429]             function(cond) {
[17:46:49.429]                 is_error <- inherits(cond, "error")
[17:46:49.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.429]                   NULL)
[17:46:49.429]                 if (is_error) {
[17:46:49.429]                   sessionInformation <- function() {
[17:46:49.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.429]                       search = base::search(), system = base::Sys.info())
[17:46:49.429]                   }
[17:46:49.429]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.429]                     cond$call), session = sessionInformation(), 
[17:46:49.429]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.429]                   signalCondition(cond)
[17:46:49.429]                 }
[17:46:49.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.429]                 "immediateCondition"))) {
[17:46:49.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.429]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.429]                   if (TRUE && !signal) {
[17:46:49.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.429]                     {
[17:46:49.429]                       inherits <- base::inherits
[17:46:49.429]                       invokeRestart <- base::invokeRestart
[17:46:49.429]                       is.null <- base::is.null
[17:46:49.429]                       muffled <- FALSE
[17:46:49.429]                       if (inherits(cond, "message")) {
[17:46:49.429]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.429]                         if (muffled) 
[17:46:49.429]                           invokeRestart("muffleMessage")
[17:46:49.429]                       }
[17:46:49.429]                       else if (inherits(cond, "warning")) {
[17:46:49.429]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.429]                         if (muffled) 
[17:46:49.429]                           invokeRestart("muffleWarning")
[17:46:49.429]                       }
[17:46:49.429]                       else if (inherits(cond, "condition")) {
[17:46:49.429]                         if (!is.null(pattern)) {
[17:46:49.429]                           computeRestarts <- base::computeRestarts
[17:46:49.429]                           grepl <- base::grepl
[17:46:49.429]                           restarts <- computeRestarts(cond)
[17:46:49.429]                           for (restart in restarts) {
[17:46:49.429]                             name <- restart$name
[17:46:49.429]                             if (is.null(name)) 
[17:46:49.429]                               next
[17:46:49.429]                             if (!grepl(pattern, name)) 
[17:46:49.429]                               next
[17:46:49.429]                             invokeRestart(restart)
[17:46:49.429]                             muffled <- TRUE
[17:46:49.429]                             break
[17:46:49.429]                           }
[17:46:49.429]                         }
[17:46:49.429]                       }
[17:46:49.429]                       invisible(muffled)
[17:46:49.429]                     }
[17:46:49.429]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.429]                   }
[17:46:49.429]                 }
[17:46:49.429]                 else {
[17:46:49.429]                   if (TRUE) {
[17:46:49.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.429]                     {
[17:46:49.429]                       inherits <- base::inherits
[17:46:49.429]                       invokeRestart <- base::invokeRestart
[17:46:49.429]                       is.null <- base::is.null
[17:46:49.429]                       muffled <- FALSE
[17:46:49.429]                       if (inherits(cond, "message")) {
[17:46:49.429]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.429]                         if (muffled) 
[17:46:49.429]                           invokeRestart("muffleMessage")
[17:46:49.429]                       }
[17:46:49.429]                       else if (inherits(cond, "warning")) {
[17:46:49.429]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.429]                         if (muffled) 
[17:46:49.429]                           invokeRestart("muffleWarning")
[17:46:49.429]                       }
[17:46:49.429]                       else if (inherits(cond, "condition")) {
[17:46:49.429]                         if (!is.null(pattern)) {
[17:46:49.429]                           computeRestarts <- base::computeRestarts
[17:46:49.429]                           grepl <- base::grepl
[17:46:49.429]                           restarts <- computeRestarts(cond)
[17:46:49.429]                           for (restart in restarts) {
[17:46:49.429]                             name <- restart$name
[17:46:49.429]                             if (is.null(name)) 
[17:46:49.429]                               next
[17:46:49.429]                             if (!grepl(pattern, name)) 
[17:46:49.429]                               next
[17:46:49.429]                             invokeRestart(restart)
[17:46:49.429]                             muffled <- TRUE
[17:46:49.429]                             break
[17:46:49.429]                           }
[17:46:49.429]                         }
[17:46:49.429]                       }
[17:46:49.429]                       invisible(muffled)
[17:46:49.429]                     }
[17:46:49.429]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.429]                   }
[17:46:49.429]                 }
[17:46:49.429]             }
[17:46:49.429]         }))
[17:46:49.429]     }, error = function(ex) {
[17:46:49.429]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.429]                 ...future.rng), started = ...future.startTime, 
[17:46:49.429]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.429]             version = "1.8"), class = "FutureResult")
[17:46:49.429]     }, finally = {
[17:46:49.429]         if (!identical(...future.workdir, getwd())) 
[17:46:49.429]             setwd(...future.workdir)
[17:46:49.429]         {
[17:46:49.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.429]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.429]             }
[17:46:49.429]             base::options(...future.oldOptions)
[17:46:49.429]             if (.Platform$OS.type == "windows") {
[17:46:49.429]                 old_names <- names(...future.oldEnvVars)
[17:46:49.429]                 envs <- base::Sys.getenv()
[17:46:49.429]                 names <- names(envs)
[17:46:49.429]                 common <- intersect(names, old_names)
[17:46:49.429]                 added <- setdiff(names, old_names)
[17:46:49.429]                 removed <- setdiff(old_names, names)
[17:46:49.429]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.429]                   envs[common]]
[17:46:49.429]                 NAMES <- toupper(changed)
[17:46:49.429]                 args <- list()
[17:46:49.429]                 for (kk in seq_along(NAMES)) {
[17:46:49.429]                   name <- changed[[kk]]
[17:46:49.429]                   NAME <- NAMES[[kk]]
[17:46:49.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.429]                     next
[17:46:49.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.429]                 }
[17:46:49.429]                 NAMES <- toupper(added)
[17:46:49.429]                 for (kk in seq_along(NAMES)) {
[17:46:49.429]                   name <- added[[kk]]
[17:46:49.429]                   NAME <- NAMES[[kk]]
[17:46:49.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.429]                     next
[17:46:49.429]                   args[[name]] <- ""
[17:46:49.429]                 }
[17:46:49.429]                 NAMES <- toupper(removed)
[17:46:49.429]                 for (kk in seq_along(NAMES)) {
[17:46:49.429]                   name <- removed[[kk]]
[17:46:49.429]                   NAME <- NAMES[[kk]]
[17:46:49.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.429]                     next
[17:46:49.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.429]                 }
[17:46:49.429]                 if (length(args) > 0) 
[17:46:49.429]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.429]             }
[17:46:49.429]             else {
[17:46:49.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.429]             }
[17:46:49.429]             {
[17:46:49.429]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.429]                   0L) {
[17:46:49.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.429]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.429]                   base::options(opts)
[17:46:49.429]                 }
[17:46:49.429]                 {
[17:46:49.429]                   {
[17:46:49.429]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.429]                     NULL
[17:46:49.429]                   }
[17:46:49.429]                   options(future.plan = NULL)
[17:46:49.429]                   if (is.na(NA_character_)) 
[17:46:49.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.429]                     .init = FALSE)
[17:46:49.429]                 }
[17:46:49.429]             }
[17:46:49.429]         }
[17:46:49.429]     })
[17:46:49.429]     if (TRUE) {
[17:46:49.429]         base::sink(type = "output", split = FALSE)
[17:46:49.429]         if (TRUE) {
[17:46:49.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.429]         }
[17:46:49.429]         else {
[17:46:49.429]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.429]         }
[17:46:49.429]         base::close(...future.stdout)
[17:46:49.429]         ...future.stdout <- NULL
[17:46:49.429]     }
[17:46:49.429]     ...future.result$conditions <- ...future.conditions
[17:46:49.429]     ...future.result$finished <- base::Sys.time()
[17:46:49.429]     ...future.result
[17:46:49.429] }
[17:46:49.432] MultisessionFuture started
[17:46:49.432] - Launch lazy future ... done
[17:46:49.432] run() for ‘MultisessionFuture’ ... done
[17:46:49.433] getGlobalsAndPackages() ...
[17:46:49.433] Searching for globals...
[17:46:49.433] - globals found: [1] ‘{’
[17:46:49.433] Searching for globals ... DONE
[17:46:49.434] Resolving globals: FALSE
[17:46:49.434] 
[17:46:49.434] 
[17:46:49.434] getGlobalsAndPackages() ... DONE
[17:46:49.434] run() for ‘Future’ ...
[17:46:49.434] - state: ‘created’
[17:46:49.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.448] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.448]   - Field: ‘node’
[17:46:49.448]   - Field: ‘label’
[17:46:49.448]   - Field: ‘local’
[17:46:49.448]   - Field: ‘owner’
[17:46:49.449]   - Field: ‘envir’
[17:46:49.449]   - Field: ‘workers’
[17:46:49.449]   - Field: ‘packages’
[17:46:49.449]   - Field: ‘gc’
[17:46:49.449]   - Field: ‘conditions’
[17:46:49.449]   - Field: ‘persistent’
[17:46:49.449]   - Field: ‘expr’
[17:46:49.449]   - Field: ‘uuid’
[17:46:49.449]   - Field: ‘seed’
[17:46:49.449]   - Field: ‘version’
[17:46:49.449]   - Field: ‘result’
[17:46:49.450]   - Field: ‘asynchronous’
[17:46:49.450]   - Field: ‘calls’
[17:46:49.450]   - Field: ‘globals’
[17:46:49.450]   - Field: ‘stdout’
[17:46:49.450]   - Field: ‘earlySignal’
[17:46:49.450]   - Field: ‘lazy’
[17:46:49.450]   - Field: ‘state’
[17:46:49.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.450] - Launch lazy future ...
[17:46:49.451] Packages needed by the future expression (n = 0): <none>
[17:46:49.451] Packages needed by future strategies (n = 0): <none>
[17:46:49.451] {
[17:46:49.451]     {
[17:46:49.451]         {
[17:46:49.451]             ...future.startTime <- base::Sys.time()
[17:46:49.451]             {
[17:46:49.451]                 {
[17:46:49.451]                   {
[17:46:49.451]                     {
[17:46:49.451]                       base::local({
[17:46:49.451]                         has_future <- base::requireNamespace("future", 
[17:46:49.451]                           quietly = TRUE)
[17:46:49.451]                         if (has_future) {
[17:46:49.451]                           ns <- base::getNamespace("future")
[17:46:49.451]                           version <- ns[[".package"]][["version"]]
[17:46:49.451]                           if (is.null(version)) 
[17:46:49.451]                             version <- utils::packageVersion("future")
[17:46:49.451]                         }
[17:46:49.451]                         else {
[17:46:49.451]                           version <- NULL
[17:46:49.451]                         }
[17:46:49.451]                         if (!has_future || version < "1.8.0") {
[17:46:49.451]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.451]                             "", base::R.version$version.string), 
[17:46:49.451]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.451]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.451]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.451]                               "release", "version")], collapse = " "), 
[17:46:49.451]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.451]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.451]                             info)
[17:46:49.451]                           info <- base::paste(info, collapse = "; ")
[17:46:49.451]                           if (!has_future) {
[17:46:49.451]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.451]                               info)
[17:46:49.451]                           }
[17:46:49.451]                           else {
[17:46:49.451]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.451]                               info, version)
[17:46:49.451]                           }
[17:46:49.451]                           base::stop(msg)
[17:46:49.451]                         }
[17:46:49.451]                       })
[17:46:49.451]                     }
[17:46:49.451]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.451]                     base::options(mc.cores = 1L)
[17:46:49.451]                   }
[17:46:49.451]                   ...future.strategy.old <- future::plan("list")
[17:46:49.451]                   options(future.plan = NULL)
[17:46:49.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.451]                 }
[17:46:49.451]                 ...future.workdir <- getwd()
[17:46:49.451]             }
[17:46:49.451]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.451]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.451]         }
[17:46:49.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.451]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.451]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.451]             base::names(...future.oldOptions))
[17:46:49.451]     }
[17:46:49.451]     if (FALSE) {
[17:46:49.451]     }
[17:46:49.451]     else {
[17:46:49.451]         if (TRUE) {
[17:46:49.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.451]                 open = "w")
[17:46:49.451]         }
[17:46:49.451]         else {
[17:46:49.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.451]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.451]         }
[17:46:49.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.451]             base::sink(type = "output", split = FALSE)
[17:46:49.451]             base::close(...future.stdout)
[17:46:49.451]         }, add = TRUE)
[17:46:49.451]     }
[17:46:49.451]     ...future.frame <- base::sys.nframe()
[17:46:49.451]     ...future.conditions <- base::list()
[17:46:49.451]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.451]     if (FALSE) {
[17:46:49.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.451]     }
[17:46:49.451]     ...future.result <- base::tryCatch({
[17:46:49.451]         base::withCallingHandlers({
[17:46:49.451]             ...future.value <- base::withVisible(base::local({
[17:46:49.451]                 ...future.makeSendCondition <- base::local({
[17:46:49.451]                   sendCondition <- NULL
[17:46:49.451]                   function(frame = 1L) {
[17:46:49.451]                     if (is.function(sendCondition)) 
[17:46:49.451]                       return(sendCondition)
[17:46:49.451]                     ns <- getNamespace("parallel")
[17:46:49.451]                     if (exists("sendData", mode = "function", 
[17:46:49.451]                       envir = ns)) {
[17:46:49.451]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.451]                         envir = ns)
[17:46:49.451]                       envir <- sys.frame(frame)
[17:46:49.451]                       master <- NULL
[17:46:49.451]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.451]                         !identical(envir, emptyenv())) {
[17:46:49.451]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.451]                           inherits = FALSE)) {
[17:46:49.451]                           master <- get("master", mode = "list", 
[17:46:49.451]                             envir = envir, inherits = FALSE)
[17:46:49.451]                           if (inherits(master, c("SOCKnode", 
[17:46:49.451]                             "SOCK0node"))) {
[17:46:49.451]                             sendCondition <<- function(cond) {
[17:46:49.451]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.451]                                 success = TRUE)
[17:46:49.451]                               parallel_sendData(master, data)
[17:46:49.451]                             }
[17:46:49.451]                             return(sendCondition)
[17:46:49.451]                           }
[17:46:49.451]                         }
[17:46:49.451]                         frame <- frame + 1L
[17:46:49.451]                         envir <- sys.frame(frame)
[17:46:49.451]                       }
[17:46:49.451]                     }
[17:46:49.451]                     sendCondition <<- function(cond) NULL
[17:46:49.451]                   }
[17:46:49.451]                 })
[17:46:49.451]                 withCallingHandlers({
[17:46:49.451]                   {
[17:46:49.451]                     4
[17:46:49.451]                   }
[17:46:49.451]                 }, immediateCondition = function(cond) {
[17:46:49.451]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.451]                   sendCondition(cond)
[17:46:49.451]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.451]                   {
[17:46:49.451]                     inherits <- base::inherits
[17:46:49.451]                     invokeRestart <- base::invokeRestart
[17:46:49.451]                     is.null <- base::is.null
[17:46:49.451]                     muffled <- FALSE
[17:46:49.451]                     if (inherits(cond, "message")) {
[17:46:49.451]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.451]                       if (muffled) 
[17:46:49.451]                         invokeRestart("muffleMessage")
[17:46:49.451]                     }
[17:46:49.451]                     else if (inherits(cond, "warning")) {
[17:46:49.451]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.451]                       if (muffled) 
[17:46:49.451]                         invokeRestart("muffleWarning")
[17:46:49.451]                     }
[17:46:49.451]                     else if (inherits(cond, "condition")) {
[17:46:49.451]                       if (!is.null(pattern)) {
[17:46:49.451]                         computeRestarts <- base::computeRestarts
[17:46:49.451]                         grepl <- base::grepl
[17:46:49.451]                         restarts <- computeRestarts(cond)
[17:46:49.451]                         for (restart in restarts) {
[17:46:49.451]                           name <- restart$name
[17:46:49.451]                           if (is.null(name)) 
[17:46:49.451]                             next
[17:46:49.451]                           if (!grepl(pattern, name)) 
[17:46:49.451]                             next
[17:46:49.451]                           invokeRestart(restart)
[17:46:49.451]                           muffled <- TRUE
[17:46:49.451]                           break
[17:46:49.451]                         }
[17:46:49.451]                       }
[17:46:49.451]                     }
[17:46:49.451]                     invisible(muffled)
[17:46:49.451]                   }
[17:46:49.451]                   muffleCondition(cond)
[17:46:49.451]                 })
[17:46:49.451]             }))
[17:46:49.451]             future::FutureResult(value = ...future.value$value, 
[17:46:49.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.451]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.451]                     ...future.globalenv.names))
[17:46:49.451]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.451]         }, condition = base::local({
[17:46:49.451]             c <- base::c
[17:46:49.451]             inherits <- base::inherits
[17:46:49.451]             invokeRestart <- base::invokeRestart
[17:46:49.451]             length <- base::length
[17:46:49.451]             list <- base::list
[17:46:49.451]             seq.int <- base::seq.int
[17:46:49.451]             signalCondition <- base::signalCondition
[17:46:49.451]             sys.calls <- base::sys.calls
[17:46:49.451]             `[[` <- base::`[[`
[17:46:49.451]             `+` <- base::`+`
[17:46:49.451]             `<<-` <- base::`<<-`
[17:46:49.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.451]                   3L)]
[17:46:49.451]             }
[17:46:49.451]             function(cond) {
[17:46:49.451]                 is_error <- inherits(cond, "error")
[17:46:49.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.451]                   NULL)
[17:46:49.451]                 if (is_error) {
[17:46:49.451]                   sessionInformation <- function() {
[17:46:49.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.451]                       search = base::search(), system = base::Sys.info())
[17:46:49.451]                   }
[17:46:49.451]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.451]                     cond$call), session = sessionInformation(), 
[17:46:49.451]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.451]                   signalCondition(cond)
[17:46:49.451]                 }
[17:46:49.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.451]                 "immediateCondition"))) {
[17:46:49.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.451]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.451]                   if (TRUE && !signal) {
[17:46:49.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.451]                     {
[17:46:49.451]                       inherits <- base::inherits
[17:46:49.451]                       invokeRestart <- base::invokeRestart
[17:46:49.451]                       is.null <- base::is.null
[17:46:49.451]                       muffled <- FALSE
[17:46:49.451]                       if (inherits(cond, "message")) {
[17:46:49.451]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.451]                         if (muffled) 
[17:46:49.451]                           invokeRestart("muffleMessage")
[17:46:49.451]                       }
[17:46:49.451]                       else if (inherits(cond, "warning")) {
[17:46:49.451]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.451]                         if (muffled) 
[17:46:49.451]                           invokeRestart("muffleWarning")
[17:46:49.451]                       }
[17:46:49.451]                       else if (inherits(cond, "condition")) {
[17:46:49.451]                         if (!is.null(pattern)) {
[17:46:49.451]                           computeRestarts <- base::computeRestarts
[17:46:49.451]                           grepl <- base::grepl
[17:46:49.451]                           restarts <- computeRestarts(cond)
[17:46:49.451]                           for (restart in restarts) {
[17:46:49.451]                             name <- restart$name
[17:46:49.451]                             if (is.null(name)) 
[17:46:49.451]                               next
[17:46:49.451]                             if (!grepl(pattern, name)) 
[17:46:49.451]                               next
[17:46:49.451]                             invokeRestart(restart)
[17:46:49.451]                             muffled <- TRUE
[17:46:49.451]                             break
[17:46:49.451]                           }
[17:46:49.451]                         }
[17:46:49.451]                       }
[17:46:49.451]                       invisible(muffled)
[17:46:49.451]                     }
[17:46:49.451]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.451]                   }
[17:46:49.451]                 }
[17:46:49.451]                 else {
[17:46:49.451]                   if (TRUE) {
[17:46:49.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.451]                     {
[17:46:49.451]                       inherits <- base::inherits
[17:46:49.451]                       invokeRestart <- base::invokeRestart
[17:46:49.451]                       is.null <- base::is.null
[17:46:49.451]                       muffled <- FALSE
[17:46:49.451]                       if (inherits(cond, "message")) {
[17:46:49.451]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.451]                         if (muffled) 
[17:46:49.451]                           invokeRestart("muffleMessage")
[17:46:49.451]                       }
[17:46:49.451]                       else if (inherits(cond, "warning")) {
[17:46:49.451]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.451]                         if (muffled) 
[17:46:49.451]                           invokeRestart("muffleWarning")
[17:46:49.451]                       }
[17:46:49.451]                       else if (inherits(cond, "condition")) {
[17:46:49.451]                         if (!is.null(pattern)) {
[17:46:49.451]                           computeRestarts <- base::computeRestarts
[17:46:49.451]                           grepl <- base::grepl
[17:46:49.451]                           restarts <- computeRestarts(cond)
[17:46:49.451]                           for (restart in restarts) {
[17:46:49.451]                             name <- restart$name
[17:46:49.451]                             if (is.null(name)) 
[17:46:49.451]                               next
[17:46:49.451]                             if (!grepl(pattern, name)) 
[17:46:49.451]                               next
[17:46:49.451]                             invokeRestart(restart)
[17:46:49.451]                             muffled <- TRUE
[17:46:49.451]                             break
[17:46:49.451]                           }
[17:46:49.451]                         }
[17:46:49.451]                       }
[17:46:49.451]                       invisible(muffled)
[17:46:49.451]                     }
[17:46:49.451]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.451]                   }
[17:46:49.451]                 }
[17:46:49.451]             }
[17:46:49.451]         }))
[17:46:49.451]     }, error = function(ex) {
[17:46:49.451]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.451]                 ...future.rng), started = ...future.startTime, 
[17:46:49.451]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.451]             version = "1.8"), class = "FutureResult")
[17:46:49.451]     }, finally = {
[17:46:49.451]         if (!identical(...future.workdir, getwd())) 
[17:46:49.451]             setwd(...future.workdir)
[17:46:49.451]         {
[17:46:49.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.451]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.451]             }
[17:46:49.451]             base::options(...future.oldOptions)
[17:46:49.451]             if (.Platform$OS.type == "windows") {
[17:46:49.451]                 old_names <- names(...future.oldEnvVars)
[17:46:49.451]                 envs <- base::Sys.getenv()
[17:46:49.451]                 names <- names(envs)
[17:46:49.451]                 common <- intersect(names, old_names)
[17:46:49.451]                 added <- setdiff(names, old_names)
[17:46:49.451]                 removed <- setdiff(old_names, names)
[17:46:49.451]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.451]                   envs[common]]
[17:46:49.451]                 NAMES <- toupper(changed)
[17:46:49.451]                 args <- list()
[17:46:49.451]                 for (kk in seq_along(NAMES)) {
[17:46:49.451]                   name <- changed[[kk]]
[17:46:49.451]                   NAME <- NAMES[[kk]]
[17:46:49.451]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.451]                     next
[17:46:49.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.451]                 }
[17:46:49.451]                 NAMES <- toupper(added)
[17:46:49.451]                 for (kk in seq_along(NAMES)) {
[17:46:49.451]                   name <- added[[kk]]
[17:46:49.451]                   NAME <- NAMES[[kk]]
[17:46:49.451]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.451]                     next
[17:46:49.451]                   args[[name]] <- ""
[17:46:49.451]                 }
[17:46:49.451]                 NAMES <- toupper(removed)
[17:46:49.451]                 for (kk in seq_along(NAMES)) {
[17:46:49.451]                   name <- removed[[kk]]
[17:46:49.451]                   NAME <- NAMES[[kk]]
[17:46:49.451]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.451]                     next
[17:46:49.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.451]                 }
[17:46:49.451]                 if (length(args) > 0) 
[17:46:49.451]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.451]             }
[17:46:49.451]             else {
[17:46:49.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.451]             }
[17:46:49.451]             {
[17:46:49.451]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.451]                   0L) {
[17:46:49.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.451]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.451]                   base::options(opts)
[17:46:49.451]                 }
[17:46:49.451]                 {
[17:46:49.451]                   {
[17:46:49.451]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.451]                     NULL
[17:46:49.451]                   }
[17:46:49.451]                   options(future.plan = NULL)
[17:46:49.451]                   if (is.na(NA_character_)) 
[17:46:49.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.451]                     .init = FALSE)
[17:46:49.451]                 }
[17:46:49.451]             }
[17:46:49.451]         }
[17:46:49.451]     })
[17:46:49.451]     if (TRUE) {
[17:46:49.451]         base::sink(type = "output", split = FALSE)
[17:46:49.451]         if (TRUE) {
[17:46:49.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.451]         }
[17:46:49.451]         else {
[17:46:49.451]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.451]         }
[17:46:49.451]         base::close(...future.stdout)
[17:46:49.451]         ...future.stdout <- NULL
[17:46:49.451]     }
[17:46:49.451]     ...future.result$conditions <- ...future.conditions
[17:46:49.451]     ...future.result$finished <- base::Sys.time()
[17:46:49.451]     ...future.result
[17:46:49.451] }
[17:46:49.453] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:49.464] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.464] - Validating connection of MultisessionFuture
[17:46:49.464] - received message: FutureResult
[17:46:49.464] - Received FutureResult
[17:46:49.464] - Erased future from FutureRegistry
[17:46:49.465] result() for ClusterFuture ...
[17:46:49.465] - result already collected: FutureResult
[17:46:49.465] result() for ClusterFuture ... done
[17:46:49.465] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.465] result() for ClusterFuture ...
[17:46:49.465] - result already collected: FutureResult
[17:46:49.465] result() for ClusterFuture ... done
[17:46:49.465] result() for ClusterFuture ...
[17:46:49.465] - result already collected: FutureResult
[17:46:49.465] result() for ClusterFuture ... done
[17:46:49.466] MultisessionFuture started
[17:46:49.466] - Launch lazy future ... done
[17:46:49.467] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x561787ad1430> 
Classes 'listenv', 'environment' <environment: 0x561788f30b08> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:49.471] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.471] - Validating connection of MultisessionFuture
[17:46:49.471] - received message: FutureResult
[17:46:49.471] - Received FutureResult
[17:46:49.471] - Erased future from FutureRegistry
[17:46:49.471] result() for ClusterFuture ...
[17:46:49.471] - result already collected: FutureResult
[17:46:49.472] result() for ClusterFuture ... done
[17:46:49.472] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.472] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.472] - Validating connection of MultisessionFuture
[17:46:49.472] - received message: FutureResult
[17:46:49.472] - Received FutureResult
[17:46:49.473] - Erased future from FutureRegistry
[17:46:49.473] result() for ClusterFuture ...
[17:46:49.473] - result already collected: FutureResult
[17:46:49.473] result() for ClusterFuture ... done
[17:46:49.473] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:49.475] resolve() on list environment ...
[17:46:49.476]  recursive: 0
[17:46:49.476]  length: 6
[17:46:49.477]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:49.477] signalConditionsASAP(numeric, pos=1) ...
[17:46:49.477] - nx: 6
[17:46:49.477] - relay: TRUE
[17:46:49.477] - stdout: TRUE
[17:46:49.477] - signal: TRUE
[17:46:49.477] - resignal: FALSE
[17:46:49.477] - force: TRUE
[17:46:49.477] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.477] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.477]  - until=2
[17:46:49.477]  - relaying element #2
[17:46:49.478] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.478] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.478] signalConditionsASAP(NULL, pos=1) ... done
[17:46:49.478]  length: 5 (resolved future 1)
[17:46:49.478] Future #2
[17:46:49.478] result() for ClusterFuture ...
[17:46:49.478] - result already collected: FutureResult
[17:46:49.478] result() for ClusterFuture ... done
[17:46:49.478] result() for ClusterFuture ...
[17:46:49.478] - result already collected: FutureResult
[17:46:49.478] result() for ClusterFuture ... done
[17:46:49.479] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:49.479] - nx: 6
[17:46:49.479] - relay: TRUE
[17:46:49.479] - stdout: TRUE
[17:46:49.479] - signal: TRUE
[17:46:49.479] - resignal: FALSE
[17:46:49.479] - force: TRUE
[17:46:49.479] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.479] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.479]  - until=2
[17:46:49.479]  - relaying element #2
[17:46:49.480] result() for ClusterFuture ...
[17:46:49.480] - result already collected: FutureResult
[17:46:49.480] result() for ClusterFuture ... done
[17:46:49.480] result() for ClusterFuture ...
[17:46:49.480] - result already collected: FutureResult
[17:46:49.480] result() for ClusterFuture ... done
[17:46:49.480] result() for ClusterFuture ...
[17:46:49.480] - result already collected: FutureResult
[17:46:49.480] result() for ClusterFuture ... done
[17:46:49.480] result() for ClusterFuture ...
[17:46:49.480] - result already collected: FutureResult
[17:46:49.481] result() for ClusterFuture ... done
[17:46:49.481] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.481] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.481] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:49.481]  length: 4 (resolved future 2)
[17:46:49.481] Future #3
[17:46:49.481] result() for ClusterFuture ...
[17:46:49.481] - result already collected: FutureResult
[17:46:49.481] result() for ClusterFuture ... done
[17:46:49.481] result() for ClusterFuture ...
[17:46:49.481] - result already collected: FutureResult
[17:46:49.482] result() for ClusterFuture ... done
[17:46:49.482] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:49.482] - nx: 6
[17:46:49.482] - relay: TRUE
[17:46:49.482] - stdout: TRUE
[17:46:49.482] - signal: TRUE
[17:46:49.482] - resignal: FALSE
[17:46:49.482] - force: TRUE
[17:46:49.482] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.482] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.482]  - until=3
[17:46:49.482]  - relaying element #3
[17:46:49.483] result() for ClusterFuture ...
[17:46:49.483] - result already collected: FutureResult
[17:46:49.483] result() for ClusterFuture ... done
[17:46:49.483] result() for ClusterFuture ...
[17:46:49.483] - result already collected: FutureResult
[17:46:49.483] result() for ClusterFuture ... done
[17:46:49.483] result() for ClusterFuture ...
[17:46:49.483] - result already collected: FutureResult
[17:46:49.483] result() for ClusterFuture ... done
[17:46:49.483] result() for ClusterFuture ...
[17:46:49.483] - result already collected: FutureResult
[17:46:49.484] result() for ClusterFuture ... done
[17:46:49.484] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.484] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:49.484]  length: 3 (resolved future 3)
[17:46:49.484] Future #4
[17:46:49.484] result() for ClusterFuture ...
[17:46:49.484] - result already collected: FutureResult
[17:46:49.484] result() for ClusterFuture ... done
[17:46:49.484] result() for ClusterFuture ...
[17:46:49.484] - result already collected: FutureResult
[17:46:49.485] result() for ClusterFuture ... done
[17:46:49.485] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:49.485] - nx: 6
[17:46:49.485] - relay: TRUE
[17:46:49.485] - stdout: TRUE
[17:46:49.485] - signal: TRUE
[17:46:49.485] - resignal: FALSE
[17:46:49.485] - force: TRUE
[17:46:49.485] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.485]  - until=4
[17:46:49.485]  - relaying element #4
[17:46:49.486] result() for ClusterFuture ...
[17:46:49.486] - result already collected: FutureResult
[17:46:49.486] result() for ClusterFuture ... done
[17:46:49.486] result() for ClusterFuture ...
[17:46:49.486] - result already collected: FutureResult
[17:46:49.486] result() for ClusterFuture ... done
[17:46:49.486] result() for ClusterFuture ...
[17:46:49.486] - result already collected: FutureResult
[17:46:49.486] result() for ClusterFuture ... done
[17:46:49.486] result() for ClusterFuture ...
[17:46:49.486] - result already collected: FutureResult
[17:46:49.486] result() for ClusterFuture ... done
[17:46:49.487] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.487] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.487] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:49.487]  length: 2 (resolved future 4)
[17:46:49.487] signalConditionsASAP(NULL, pos=5) ...
[17:46:49.487] - nx: 6
[17:46:49.487] - relay: TRUE
[17:46:49.487] - stdout: TRUE
[17:46:49.487] - signal: TRUE
[17:46:49.487] - resignal: FALSE
[17:46:49.487] - force: TRUE
[17:46:49.488] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.488] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.488]  - until=6
[17:46:49.488]  - relaying element #6
[17:46:49.488] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.488] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.488] signalConditionsASAP(NULL, pos=5) ... done
[17:46:49.488]  length: 1 (resolved future 5)
[17:46:49.488] signalConditionsASAP(numeric, pos=6) ...
[17:46:49.488] - nx: 6
[17:46:49.488] - relay: TRUE
[17:46:49.489] - stdout: TRUE
[17:46:49.489] - signal: TRUE
[17:46:49.489] - resignal: FALSE
[17:46:49.489] - force: TRUE
[17:46:49.489] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.489] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.489]  - until=6
[17:46:49.489] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.489] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.489] signalConditionsASAP(numeric, pos=6) ... done
[17:46:49.489]  length: 0 (resolved future 6)
[17:46:49.489] Relaying remaining futures
[17:46:49.490] signalConditionsASAP(NULL, pos=0) ...
[17:46:49.490] - nx: 6
[17:46:49.490] - relay: TRUE
[17:46:49.490] - stdout: TRUE
[17:46:49.490] - signal: TRUE
[17:46:49.490] - resignal: FALSE
[17:46:49.490] - force: TRUE
[17:46:49.490] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.490] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:49.490] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.490] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.490] signalConditionsASAP(NULL, pos=0) ... done
[17:46:49.491] resolve() on list environment ... DONE
[17:46:49.491] result() for ClusterFuture ...
[17:46:49.494] - result already collected: FutureResult
[17:46:49.494] result() for ClusterFuture ... done
[17:46:49.494] result() for ClusterFuture ...
[17:46:49.494] - result already collected: FutureResult
[17:46:49.494] result() for ClusterFuture ... done
[17:46:49.494] result() for ClusterFuture ...
[17:46:49.494] - result already collected: FutureResult
[17:46:49.495] result() for ClusterFuture ... done
[17:46:49.495] result() for ClusterFuture ...
[17:46:49.495] - result already collected: FutureResult
[17:46:49.495] result() for ClusterFuture ... done
[17:46:49.495] result() for ClusterFuture ...
[17:46:49.495] - result already collected: FutureResult
[17:46:49.495] result() for ClusterFuture ... done
[17:46:49.495] result() for ClusterFuture ...
[17:46:49.495] - result already collected: FutureResult
[17:46:49.496] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5617893d1338> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:46:49.497] getGlobalsAndPackages() ...
[17:46:49.498] Searching for globals...
[17:46:49.498] 
[17:46:49.498] Searching for globals ... DONE
[17:46:49.498] - globals: [0] <none>
[17:46:49.498] getGlobalsAndPackages() ... DONE
[17:46:49.498] run() for ‘Future’ ...
[17:46:49.498] - state: ‘created’
[17:46:49.499] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.513] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.513]   - Field: ‘node’
[17:46:49.513]   - Field: ‘label’
[17:46:49.513]   - Field: ‘local’
[17:46:49.513]   - Field: ‘owner’
[17:46:49.513]   - Field: ‘envir’
[17:46:49.513]   - Field: ‘workers’
[17:46:49.513]   - Field: ‘packages’
[17:46:49.513]   - Field: ‘gc’
[17:46:49.514]   - Field: ‘conditions’
[17:46:49.514]   - Field: ‘persistent’
[17:46:49.514]   - Field: ‘expr’
[17:46:49.514]   - Field: ‘uuid’
[17:46:49.514]   - Field: ‘seed’
[17:46:49.514]   - Field: ‘version’
[17:46:49.514]   - Field: ‘result’
[17:46:49.514]   - Field: ‘asynchronous’
[17:46:49.514]   - Field: ‘calls’
[17:46:49.514]   - Field: ‘globals’
[17:46:49.514]   - Field: ‘stdout’
[17:46:49.515]   - Field: ‘earlySignal’
[17:46:49.515]   - Field: ‘lazy’
[17:46:49.515]   - Field: ‘state’
[17:46:49.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.515] - Launch lazy future ...
[17:46:49.515] Packages needed by the future expression (n = 0): <none>
[17:46:49.515] Packages needed by future strategies (n = 0): <none>
[17:46:49.516] {
[17:46:49.516]     {
[17:46:49.516]         {
[17:46:49.516]             ...future.startTime <- base::Sys.time()
[17:46:49.516]             {
[17:46:49.516]                 {
[17:46:49.516]                   {
[17:46:49.516]                     {
[17:46:49.516]                       base::local({
[17:46:49.516]                         has_future <- base::requireNamespace("future", 
[17:46:49.516]                           quietly = TRUE)
[17:46:49.516]                         if (has_future) {
[17:46:49.516]                           ns <- base::getNamespace("future")
[17:46:49.516]                           version <- ns[[".package"]][["version"]]
[17:46:49.516]                           if (is.null(version)) 
[17:46:49.516]                             version <- utils::packageVersion("future")
[17:46:49.516]                         }
[17:46:49.516]                         else {
[17:46:49.516]                           version <- NULL
[17:46:49.516]                         }
[17:46:49.516]                         if (!has_future || version < "1.8.0") {
[17:46:49.516]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.516]                             "", base::R.version$version.string), 
[17:46:49.516]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.516]                               "release", "version")], collapse = " "), 
[17:46:49.516]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.516]                             info)
[17:46:49.516]                           info <- base::paste(info, collapse = "; ")
[17:46:49.516]                           if (!has_future) {
[17:46:49.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.516]                               info)
[17:46:49.516]                           }
[17:46:49.516]                           else {
[17:46:49.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.516]                               info, version)
[17:46:49.516]                           }
[17:46:49.516]                           base::stop(msg)
[17:46:49.516]                         }
[17:46:49.516]                       })
[17:46:49.516]                     }
[17:46:49.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.516]                     base::options(mc.cores = 1L)
[17:46:49.516]                   }
[17:46:49.516]                   ...future.strategy.old <- future::plan("list")
[17:46:49.516]                   options(future.plan = NULL)
[17:46:49.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.516]                 }
[17:46:49.516]                 ...future.workdir <- getwd()
[17:46:49.516]             }
[17:46:49.516]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.516]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.516]         }
[17:46:49.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.516]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.516]             base::names(...future.oldOptions))
[17:46:49.516]     }
[17:46:49.516]     if (FALSE) {
[17:46:49.516]     }
[17:46:49.516]     else {
[17:46:49.516]         if (TRUE) {
[17:46:49.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.516]                 open = "w")
[17:46:49.516]         }
[17:46:49.516]         else {
[17:46:49.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.516]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.516]         }
[17:46:49.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.516]             base::sink(type = "output", split = FALSE)
[17:46:49.516]             base::close(...future.stdout)
[17:46:49.516]         }, add = TRUE)
[17:46:49.516]     }
[17:46:49.516]     ...future.frame <- base::sys.nframe()
[17:46:49.516]     ...future.conditions <- base::list()
[17:46:49.516]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.516]     if (FALSE) {
[17:46:49.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.516]     }
[17:46:49.516]     ...future.result <- base::tryCatch({
[17:46:49.516]         base::withCallingHandlers({
[17:46:49.516]             ...future.value <- base::withVisible(base::local({
[17:46:49.516]                 ...future.makeSendCondition <- base::local({
[17:46:49.516]                   sendCondition <- NULL
[17:46:49.516]                   function(frame = 1L) {
[17:46:49.516]                     if (is.function(sendCondition)) 
[17:46:49.516]                       return(sendCondition)
[17:46:49.516]                     ns <- getNamespace("parallel")
[17:46:49.516]                     if (exists("sendData", mode = "function", 
[17:46:49.516]                       envir = ns)) {
[17:46:49.516]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.516]                         envir = ns)
[17:46:49.516]                       envir <- sys.frame(frame)
[17:46:49.516]                       master <- NULL
[17:46:49.516]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.516]                         !identical(envir, emptyenv())) {
[17:46:49.516]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.516]                           inherits = FALSE)) {
[17:46:49.516]                           master <- get("master", mode = "list", 
[17:46:49.516]                             envir = envir, inherits = FALSE)
[17:46:49.516]                           if (inherits(master, c("SOCKnode", 
[17:46:49.516]                             "SOCK0node"))) {
[17:46:49.516]                             sendCondition <<- function(cond) {
[17:46:49.516]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.516]                                 success = TRUE)
[17:46:49.516]                               parallel_sendData(master, data)
[17:46:49.516]                             }
[17:46:49.516]                             return(sendCondition)
[17:46:49.516]                           }
[17:46:49.516]                         }
[17:46:49.516]                         frame <- frame + 1L
[17:46:49.516]                         envir <- sys.frame(frame)
[17:46:49.516]                       }
[17:46:49.516]                     }
[17:46:49.516]                     sendCondition <<- function(cond) NULL
[17:46:49.516]                   }
[17:46:49.516]                 })
[17:46:49.516]                 withCallingHandlers({
[17:46:49.516]                   2
[17:46:49.516]                 }, immediateCondition = function(cond) {
[17:46:49.516]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.516]                   sendCondition(cond)
[17:46:49.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.516]                   {
[17:46:49.516]                     inherits <- base::inherits
[17:46:49.516]                     invokeRestart <- base::invokeRestart
[17:46:49.516]                     is.null <- base::is.null
[17:46:49.516]                     muffled <- FALSE
[17:46:49.516]                     if (inherits(cond, "message")) {
[17:46:49.516]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.516]                       if (muffled) 
[17:46:49.516]                         invokeRestart("muffleMessage")
[17:46:49.516]                     }
[17:46:49.516]                     else if (inherits(cond, "warning")) {
[17:46:49.516]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.516]                       if (muffled) 
[17:46:49.516]                         invokeRestart("muffleWarning")
[17:46:49.516]                     }
[17:46:49.516]                     else if (inherits(cond, "condition")) {
[17:46:49.516]                       if (!is.null(pattern)) {
[17:46:49.516]                         computeRestarts <- base::computeRestarts
[17:46:49.516]                         grepl <- base::grepl
[17:46:49.516]                         restarts <- computeRestarts(cond)
[17:46:49.516]                         for (restart in restarts) {
[17:46:49.516]                           name <- restart$name
[17:46:49.516]                           if (is.null(name)) 
[17:46:49.516]                             next
[17:46:49.516]                           if (!grepl(pattern, name)) 
[17:46:49.516]                             next
[17:46:49.516]                           invokeRestart(restart)
[17:46:49.516]                           muffled <- TRUE
[17:46:49.516]                           break
[17:46:49.516]                         }
[17:46:49.516]                       }
[17:46:49.516]                     }
[17:46:49.516]                     invisible(muffled)
[17:46:49.516]                   }
[17:46:49.516]                   muffleCondition(cond)
[17:46:49.516]                 })
[17:46:49.516]             }))
[17:46:49.516]             future::FutureResult(value = ...future.value$value, 
[17:46:49.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.516]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.516]                     ...future.globalenv.names))
[17:46:49.516]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.516]         }, condition = base::local({
[17:46:49.516]             c <- base::c
[17:46:49.516]             inherits <- base::inherits
[17:46:49.516]             invokeRestart <- base::invokeRestart
[17:46:49.516]             length <- base::length
[17:46:49.516]             list <- base::list
[17:46:49.516]             seq.int <- base::seq.int
[17:46:49.516]             signalCondition <- base::signalCondition
[17:46:49.516]             sys.calls <- base::sys.calls
[17:46:49.516]             `[[` <- base::`[[`
[17:46:49.516]             `+` <- base::`+`
[17:46:49.516]             `<<-` <- base::`<<-`
[17:46:49.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.516]                   3L)]
[17:46:49.516]             }
[17:46:49.516]             function(cond) {
[17:46:49.516]                 is_error <- inherits(cond, "error")
[17:46:49.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.516]                   NULL)
[17:46:49.516]                 if (is_error) {
[17:46:49.516]                   sessionInformation <- function() {
[17:46:49.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.516]                       search = base::search(), system = base::Sys.info())
[17:46:49.516]                   }
[17:46:49.516]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.516]                     cond$call), session = sessionInformation(), 
[17:46:49.516]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.516]                   signalCondition(cond)
[17:46:49.516]                 }
[17:46:49.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.516]                 "immediateCondition"))) {
[17:46:49.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.516]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.516]                   if (TRUE && !signal) {
[17:46:49.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.516]                     {
[17:46:49.516]                       inherits <- base::inherits
[17:46:49.516]                       invokeRestart <- base::invokeRestart
[17:46:49.516]                       is.null <- base::is.null
[17:46:49.516]                       muffled <- FALSE
[17:46:49.516]                       if (inherits(cond, "message")) {
[17:46:49.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.516]                         if (muffled) 
[17:46:49.516]                           invokeRestart("muffleMessage")
[17:46:49.516]                       }
[17:46:49.516]                       else if (inherits(cond, "warning")) {
[17:46:49.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.516]                         if (muffled) 
[17:46:49.516]                           invokeRestart("muffleWarning")
[17:46:49.516]                       }
[17:46:49.516]                       else if (inherits(cond, "condition")) {
[17:46:49.516]                         if (!is.null(pattern)) {
[17:46:49.516]                           computeRestarts <- base::computeRestarts
[17:46:49.516]                           grepl <- base::grepl
[17:46:49.516]                           restarts <- computeRestarts(cond)
[17:46:49.516]                           for (restart in restarts) {
[17:46:49.516]                             name <- restart$name
[17:46:49.516]                             if (is.null(name)) 
[17:46:49.516]                               next
[17:46:49.516]                             if (!grepl(pattern, name)) 
[17:46:49.516]                               next
[17:46:49.516]                             invokeRestart(restart)
[17:46:49.516]                             muffled <- TRUE
[17:46:49.516]                             break
[17:46:49.516]                           }
[17:46:49.516]                         }
[17:46:49.516]                       }
[17:46:49.516]                       invisible(muffled)
[17:46:49.516]                     }
[17:46:49.516]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.516]                   }
[17:46:49.516]                 }
[17:46:49.516]                 else {
[17:46:49.516]                   if (TRUE) {
[17:46:49.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.516]                     {
[17:46:49.516]                       inherits <- base::inherits
[17:46:49.516]                       invokeRestart <- base::invokeRestart
[17:46:49.516]                       is.null <- base::is.null
[17:46:49.516]                       muffled <- FALSE
[17:46:49.516]                       if (inherits(cond, "message")) {
[17:46:49.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.516]                         if (muffled) 
[17:46:49.516]                           invokeRestart("muffleMessage")
[17:46:49.516]                       }
[17:46:49.516]                       else if (inherits(cond, "warning")) {
[17:46:49.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.516]                         if (muffled) 
[17:46:49.516]                           invokeRestart("muffleWarning")
[17:46:49.516]                       }
[17:46:49.516]                       else if (inherits(cond, "condition")) {
[17:46:49.516]                         if (!is.null(pattern)) {
[17:46:49.516]                           computeRestarts <- base::computeRestarts
[17:46:49.516]                           grepl <- base::grepl
[17:46:49.516]                           restarts <- computeRestarts(cond)
[17:46:49.516]                           for (restart in restarts) {
[17:46:49.516]                             name <- restart$name
[17:46:49.516]                             if (is.null(name)) 
[17:46:49.516]                               next
[17:46:49.516]                             if (!grepl(pattern, name)) 
[17:46:49.516]                               next
[17:46:49.516]                             invokeRestart(restart)
[17:46:49.516]                             muffled <- TRUE
[17:46:49.516]                             break
[17:46:49.516]                           }
[17:46:49.516]                         }
[17:46:49.516]                       }
[17:46:49.516]                       invisible(muffled)
[17:46:49.516]                     }
[17:46:49.516]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.516]                   }
[17:46:49.516]                 }
[17:46:49.516]             }
[17:46:49.516]         }))
[17:46:49.516]     }, error = function(ex) {
[17:46:49.516]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.516]                 ...future.rng), started = ...future.startTime, 
[17:46:49.516]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.516]             version = "1.8"), class = "FutureResult")
[17:46:49.516]     }, finally = {
[17:46:49.516]         if (!identical(...future.workdir, getwd())) 
[17:46:49.516]             setwd(...future.workdir)
[17:46:49.516]         {
[17:46:49.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.516]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.516]             }
[17:46:49.516]             base::options(...future.oldOptions)
[17:46:49.516]             if (.Platform$OS.type == "windows") {
[17:46:49.516]                 old_names <- names(...future.oldEnvVars)
[17:46:49.516]                 envs <- base::Sys.getenv()
[17:46:49.516]                 names <- names(envs)
[17:46:49.516]                 common <- intersect(names, old_names)
[17:46:49.516]                 added <- setdiff(names, old_names)
[17:46:49.516]                 removed <- setdiff(old_names, names)
[17:46:49.516]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.516]                   envs[common]]
[17:46:49.516]                 NAMES <- toupper(changed)
[17:46:49.516]                 args <- list()
[17:46:49.516]                 for (kk in seq_along(NAMES)) {
[17:46:49.516]                   name <- changed[[kk]]
[17:46:49.516]                   NAME <- NAMES[[kk]]
[17:46:49.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.516]                     next
[17:46:49.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.516]                 }
[17:46:49.516]                 NAMES <- toupper(added)
[17:46:49.516]                 for (kk in seq_along(NAMES)) {
[17:46:49.516]                   name <- added[[kk]]
[17:46:49.516]                   NAME <- NAMES[[kk]]
[17:46:49.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.516]                     next
[17:46:49.516]                   args[[name]] <- ""
[17:46:49.516]                 }
[17:46:49.516]                 NAMES <- toupper(removed)
[17:46:49.516]                 for (kk in seq_along(NAMES)) {
[17:46:49.516]                   name <- removed[[kk]]
[17:46:49.516]                   NAME <- NAMES[[kk]]
[17:46:49.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.516]                     next
[17:46:49.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.516]                 }
[17:46:49.516]                 if (length(args) > 0) 
[17:46:49.516]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.516]             }
[17:46:49.516]             else {
[17:46:49.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.516]             }
[17:46:49.516]             {
[17:46:49.516]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.516]                   0L) {
[17:46:49.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.516]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.516]                   base::options(opts)
[17:46:49.516]                 }
[17:46:49.516]                 {
[17:46:49.516]                   {
[17:46:49.516]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.516]                     NULL
[17:46:49.516]                   }
[17:46:49.516]                   options(future.plan = NULL)
[17:46:49.516]                   if (is.na(NA_character_)) 
[17:46:49.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.516]                     .init = FALSE)
[17:46:49.516]                 }
[17:46:49.516]             }
[17:46:49.516]         }
[17:46:49.516]     })
[17:46:49.516]     if (TRUE) {
[17:46:49.516]         base::sink(type = "output", split = FALSE)
[17:46:49.516]         if (TRUE) {
[17:46:49.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.516]         }
[17:46:49.516]         else {
[17:46:49.516]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.516]         }
[17:46:49.516]         base::close(...future.stdout)
[17:46:49.516]         ...future.stdout <- NULL
[17:46:49.516]     }
[17:46:49.516]     ...future.result$conditions <- ...future.conditions
[17:46:49.516]     ...future.result$finished <- base::Sys.time()
[17:46:49.516]     ...future.result
[17:46:49.516] }
[17:46:49.519] MultisessionFuture started
[17:46:49.519] - Launch lazy future ... done
[17:46:49.519] run() for ‘MultisessionFuture’ ... done
[17:46:49.519] getGlobalsAndPackages() ...
[17:46:49.519] Searching for globals...
[17:46:49.519] 
[17:46:49.520] Searching for globals ... DONE
[17:46:49.520] - globals: [0] <none>
[17:46:49.520] getGlobalsAndPackages() ... DONE
[17:46:49.520] run() for ‘Future’ ...
[17:46:49.520] - state: ‘created’
[17:46:49.520] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.534] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.534]   - Field: ‘node’
[17:46:49.534]   - Field: ‘label’
[17:46:49.535]   - Field: ‘local’
[17:46:49.535]   - Field: ‘owner’
[17:46:49.535]   - Field: ‘envir’
[17:46:49.535]   - Field: ‘workers’
[17:46:49.535]   - Field: ‘packages’
[17:46:49.535]   - Field: ‘gc’
[17:46:49.535]   - Field: ‘conditions’
[17:46:49.535]   - Field: ‘persistent’
[17:46:49.535]   - Field: ‘expr’
[17:46:49.535]   - Field: ‘uuid’
[17:46:49.536]   - Field: ‘seed’
[17:46:49.536]   - Field: ‘version’
[17:46:49.536]   - Field: ‘result’
[17:46:49.536]   - Field: ‘asynchronous’
[17:46:49.536]   - Field: ‘calls’
[17:46:49.536]   - Field: ‘globals’
[17:46:49.536]   - Field: ‘stdout’
[17:46:49.536]   - Field: ‘earlySignal’
[17:46:49.536]   - Field: ‘lazy’
[17:46:49.536]   - Field: ‘state’
[17:46:49.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.537] - Launch lazy future ...
[17:46:49.537] Packages needed by the future expression (n = 0): <none>
[17:46:49.537] Packages needed by future strategies (n = 0): <none>
[17:46:49.537] {
[17:46:49.537]     {
[17:46:49.537]         {
[17:46:49.537]             ...future.startTime <- base::Sys.time()
[17:46:49.537]             {
[17:46:49.537]                 {
[17:46:49.537]                   {
[17:46:49.537]                     {
[17:46:49.537]                       base::local({
[17:46:49.537]                         has_future <- base::requireNamespace("future", 
[17:46:49.537]                           quietly = TRUE)
[17:46:49.537]                         if (has_future) {
[17:46:49.537]                           ns <- base::getNamespace("future")
[17:46:49.537]                           version <- ns[[".package"]][["version"]]
[17:46:49.537]                           if (is.null(version)) 
[17:46:49.537]                             version <- utils::packageVersion("future")
[17:46:49.537]                         }
[17:46:49.537]                         else {
[17:46:49.537]                           version <- NULL
[17:46:49.537]                         }
[17:46:49.537]                         if (!has_future || version < "1.8.0") {
[17:46:49.537]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.537]                             "", base::R.version$version.string), 
[17:46:49.537]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.537]                               "release", "version")], collapse = " "), 
[17:46:49.537]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.537]                             info)
[17:46:49.537]                           info <- base::paste(info, collapse = "; ")
[17:46:49.537]                           if (!has_future) {
[17:46:49.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.537]                               info)
[17:46:49.537]                           }
[17:46:49.537]                           else {
[17:46:49.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.537]                               info, version)
[17:46:49.537]                           }
[17:46:49.537]                           base::stop(msg)
[17:46:49.537]                         }
[17:46:49.537]                       })
[17:46:49.537]                     }
[17:46:49.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.537]                     base::options(mc.cores = 1L)
[17:46:49.537]                   }
[17:46:49.537]                   ...future.strategy.old <- future::plan("list")
[17:46:49.537]                   options(future.plan = NULL)
[17:46:49.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.537]                 }
[17:46:49.537]                 ...future.workdir <- getwd()
[17:46:49.537]             }
[17:46:49.537]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.537]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.537]         }
[17:46:49.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.537]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.537]             base::names(...future.oldOptions))
[17:46:49.537]     }
[17:46:49.537]     if (FALSE) {
[17:46:49.537]     }
[17:46:49.537]     else {
[17:46:49.537]         if (TRUE) {
[17:46:49.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.537]                 open = "w")
[17:46:49.537]         }
[17:46:49.537]         else {
[17:46:49.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.537]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.537]         }
[17:46:49.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.537]             base::sink(type = "output", split = FALSE)
[17:46:49.537]             base::close(...future.stdout)
[17:46:49.537]         }, add = TRUE)
[17:46:49.537]     }
[17:46:49.537]     ...future.frame <- base::sys.nframe()
[17:46:49.537]     ...future.conditions <- base::list()
[17:46:49.537]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.537]     if (FALSE) {
[17:46:49.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.537]     }
[17:46:49.537]     ...future.result <- base::tryCatch({
[17:46:49.537]         base::withCallingHandlers({
[17:46:49.537]             ...future.value <- base::withVisible(base::local({
[17:46:49.537]                 ...future.makeSendCondition <- base::local({
[17:46:49.537]                   sendCondition <- NULL
[17:46:49.537]                   function(frame = 1L) {
[17:46:49.537]                     if (is.function(sendCondition)) 
[17:46:49.537]                       return(sendCondition)
[17:46:49.537]                     ns <- getNamespace("parallel")
[17:46:49.537]                     if (exists("sendData", mode = "function", 
[17:46:49.537]                       envir = ns)) {
[17:46:49.537]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.537]                         envir = ns)
[17:46:49.537]                       envir <- sys.frame(frame)
[17:46:49.537]                       master <- NULL
[17:46:49.537]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.537]                         !identical(envir, emptyenv())) {
[17:46:49.537]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.537]                           inherits = FALSE)) {
[17:46:49.537]                           master <- get("master", mode = "list", 
[17:46:49.537]                             envir = envir, inherits = FALSE)
[17:46:49.537]                           if (inherits(master, c("SOCKnode", 
[17:46:49.537]                             "SOCK0node"))) {
[17:46:49.537]                             sendCondition <<- function(cond) {
[17:46:49.537]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.537]                                 success = TRUE)
[17:46:49.537]                               parallel_sendData(master, data)
[17:46:49.537]                             }
[17:46:49.537]                             return(sendCondition)
[17:46:49.537]                           }
[17:46:49.537]                         }
[17:46:49.537]                         frame <- frame + 1L
[17:46:49.537]                         envir <- sys.frame(frame)
[17:46:49.537]                       }
[17:46:49.537]                     }
[17:46:49.537]                     sendCondition <<- function(cond) NULL
[17:46:49.537]                   }
[17:46:49.537]                 })
[17:46:49.537]                 withCallingHandlers({
[17:46:49.537]                   NULL
[17:46:49.537]                 }, immediateCondition = function(cond) {
[17:46:49.537]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.537]                   sendCondition(cond)
[17:46:49.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.537]                   {
[17:46:49.537]                     inherits <- base::inherits
[17:46:49.537]                     invokeRestart <- base::invokeRestart
[17:46:49.537]                     is.null <- base::is.null
[17:46:49.537]                     muffled <- FALSE
[17:46:49.537]                     if (inherits(cond, "message")) {
[17:46:49.537]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.537]                       if (muffled) 
[17:46:49.537]                         invokeRestart("muffleMessage")
[17:46:49.537]                     }
[17:46:49.537]                     else if (inherits(cond, "warning")) {
[17:46:49.537]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.537]                       if (muffled) 
[17:46:49.537]                         invokeRestart("muffleWarning")
[17:46:49.537]                     }
[17:46:49.537]                     else if (inherits(cond, "condition")) {
[17:46:49.537]                       if (!is.null(pattern)) {
[17:46:49.537]                         computeRestarts <- base::computeRestarts
[17:46:49.537]                         grepl <- base::grepl
[17:46:49.537]                         restarts <- computeRestarts(cond)
[17:46:49.537]                         for (restart in restarts) {
[17:46:49.537]                           name <- restart$name
[17:46:49.537]                           if (is.null(name)) 
[17:46:49.537]                             next
[17:46:49.537]                           if (!grepl(pattern, name)) 
[17:46:49.537]                             next
[17:46:49.537]                           invokeRestart(restart)
[17:46:49.537]                           muffled <- TRUE
[17:46:49.537]                           break
[17:46:49.537]                         }
[17:46:49.537]                       }
[17:46:49.537]                     }
[17:46:49.537]                     invisible(muffled)
[17:46:49.537]                   }
[17:46:49.537]                   muffleCondition(cond)
[17:46:49.537]                 })
[17:46:49.537]             }))
[17:46:49.537]             future::FutureResult(value = ...future.value$value, 
[17:46:49.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.537]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.537]                     ...future.globalenv.names))
[17:46:49.537]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.537]         }, condition = base::local({
[17:46:49.537]             c <- base::c
[17:46:49.537]             inherits <- base::inherits
[17:46:49.537]             invokeRestart <- base::invokeRestart
[17:46:49.537]             length <- base::length
[17:46:49.537]             list <- base::list
[17:46:49.537]             seq.int <- base::seq.int
[17:46:49.537]             signalCondition <- base::signalCondition
[17:46:49.537]             sys.calls <- base::sys.calls
[17:46:49.537]             `[[` <- base::`[[`
[17:46:49.537]             `+` <- base::`+`
[17:46:49.537]             `<<-` <- base::`<<-`
[17:46:49.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.537]                   3L)]
[17:46:49.537]             }
[17:46:49.537]             function(cond) {
[17:46:49.537]                 is_error <- inherits(cond, "error")
[17:46:49.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.537]                   NULL)
[17:46:49.537]                 if (is_error) {
[17:46:49.537]                   sessionInformation <- function() {
[17:46:49.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.537]                       search = base::search(), system = base::Sys.info())
[17:46:49.537]                   }
[17:46:49.537]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.537]                     cond$call), session = sessionInformation(), 
[17:46:49.537]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.537]                   signalCondition(cond)
[17:46:49.537]                 }
[17:46:49.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.537]                 "immediateCondition"))) {
[17:46:49.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.537]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.537]                   if (TRUE && !signal) {
[17:46:49.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.537]                     {
[17:46:49.537]                       inherits <- base::inherits
[17:46:49.537]                       invokeRestart <- base::invokeRestart
[17:46:49.537]                       is.null <- base::is.null
[17:46:49.537]                       muffled <- FALSE
[17:46:49.537]                       if (inherits(cond, "message")) {
[17:46:49.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.537]                         if (muffled) 
[17:46:49.537]                           invokeRestart("muffleMessage")
[17:46:49.537]                       }
[17:46:49.537]                       else if (inherits(cond, "warning")) {
[17:46:49.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.537]                         if (muffled) 
[17:46:49.537]                           invokeRestart("muffleWarning")
[17:46:49.537]                       }
[17:46:49.537]                       else if (inherits(cond, "condition")) {
[17:46:49.537]                         if (!is.null(pattern)) {
[17:46:49.537]                           computeRestarts <- base::computeRestarts
[17:46:49.537]                           grepl <- base::grepl
[17:46:49.537]                           restarts <- computeRestarts(cond)
[17:46:49.537]                           for (restart in restarts) {
[17:46:49.537]                             name <- restart$name
[17:46:49.537]                             if (is.null(name)) 
[17:46:49.537]                               next
[17:46:49.537]                             if (!grepl(pattern, name)) 
[17:46:49.537]                               next
[17:46:49.537]                             invokeRestart(restart)
[17:46:49.537]                             muffled <- TRUE
[17:46:49.537]                             break
[17:46:49.537]                           }
[17:46:49.537]                         }
[17:46:49.537]                       }
[17:46:49.537]                       invisible(muffled)
[17:46:49.537]                     }
[17:46:49.537]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.537]                   }
[17:46:49.537]                 }
[17:46:49.537]                 else {
[17:46:49.537]                   if (TRUE) {
[17:46:49.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.537]                     {
[17:46:49.537]                       inherits <- base::inherits
[17:46:49.537]                       invokeRestart <- base::invokeRestart
[17:46:49.537]                       is.null <- base::is.null
[17:46:49.537]                       muffled <- FALSE
[17:46:49.537]                       if (inherits(cond, "message")) {
[17:46:49.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.537]                         if (muffled) 
[17:46:49.537]                           invokeRestart("muffleMessage")
[17:46:49.537]                       }
[17:46:49.537]                       else if (inherits(cond, "warning")) {
[17:46:49.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.537]                         if (muffled) 
[17:46:49.537]                           invokeRestart("muffleWarning")
[17:46:49.537]                       }
[17:46:49.537]                       else if (inherits(cond, "condition")) {
[17:46:49.537]                         if (!is.null(pattern)) {
[17:46:49.537]                           computeRestarts <- base::computeRestarts
[17:46:49.537]                           grepl <- base::grepl
[17:46:49.537]                           restarts <- computeRestarts(cond)
[17:46:49.537]                           for (restart in restarts) {
[17:46:49.537]                             name <- restart$name
[17:46:49.537]                             if (is.null(name)) 
[17:46:49.537]                               next
[17:46:49.537]                             if (!grepl(pattern, name)) 
[17:46:49.537]                               next
[17:46:49.537]                             invokeRestart(restart)
[17:46:49.537]                             muffled <- TRUE
[17:46:49.537]                             break
[17:46:49.537]                           }
[17:46:49.537]                         }
[17:46:49.537]                       }
[17:46:49.537]                       invisible(muffled)
[17:46:49.537]                     }
[17:46:49.537]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.537]                   }
[17:46:49.537]                 }
[17:46:49.537]             }
[17:46:49.537]         }))
[17:46:49.537]     }, error = function(ex) {
[17:46:49.537]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.537]                 ...future.rng), started = ...future.startTime, 
[17:46:49.537]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.537]             version = "1.8"), class = "FutureResult")
[17:46:49.537]     }, finally = {
[17:46:49.537]         if (!identical(...future.workdir, getwd())) 
[17:46:49.537]             setwd(...future.workdir)
[17:46:49.537]         {
[17:46:49.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.537]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.537]             }
[17:46:49.537]             base::options(...future.oldOptions)
[17:46:49.537]             if (.Platform$OS.type == "windows") {
[17:46:49.537]                 old_names <- names(...future.oldEnvVars)
[17:46:49.537]                 envs <- base::Sys.getenv()
[17:46:49.537]                 names <- names(envs)
[17:46:49.537]                 common <- intersect(names, old_names)
[17:46:49.537]                 added <- setdiff(names, old_names)
[17:46:49.537]                 removed <- setdiff(old_names, names)
[17:46:49.537]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.537]                   envs[common]]
[17:46:49.537]                 NAMES <- toupper(changed)
[17:46:49.537]                 args <- list()
[17:46:49.537]                 for (kk in seq_along(NAMES)) {
[17:46:49.537]                   name <- changed[[kk]]
[17:46:49.537]                   NAME <- NAMES[[kk]]
[17:46:49.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.537]                     next
[17:46:49.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.537]                 }
[17:46:49.537]                 NAMES <- toupper(added)
[17:46:49.537]                 for (kk in seq_along(NAMES)) {
[17:46:49.537]                   name <- added[[kk]]
[17:46:49.537]                   NAME <- NAMES[[kk]]
[17:46:49.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.537]                     next
[17:46:49.537]                   args[[name]] <- ""
[17:46:49.537]                 }
[17:46:49.537]                 NAMES <- toupper(removed)
[17:46:49.537]                 for (kk in seq_along(NAMES)) {
[17:46:49.537]                   name <- removed[[kk]]
[17:46:49.537]                   NAME <- NAMES[[kk]]
[17:46:49.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.537]                     next
[17:46:49.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.537]                 }
[17:46:49.537]                 if (length(args) > 0) 
[17:46:49.537]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.537]             }
[17:46:49.537]             else {
[17:46:49.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.537]             }
[17:46:49.537]             {
[17:46:49.537]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.537]                   0L) {
[17:46:49.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.537]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.537]                   base::options(opts)
[17:46:49.537]                 }
[17:46:49.537]                 {
[17:46:49.537]                   {
[17:46:49.537]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.537]                     NULL
[17:46:49.537]                   }
[17:46:49.537]                   options(future.plan = NULL)
[17:46:49.537]                   if (is.na(NA_character_)) 
[17:46:49.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.537]                     .init = FALSE)
[17:46:49.537]                 }
[17:46:49.537]             }
[17:46:49.537]         }
[17:46:49.537]     })
[17:46:49.537]     if (TRUE) {
[17:46:49.537]         base::sink(type = "output", split = FALSE)
[17:46:49.537]         if (TRUE) {
[17:46:49.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.537]         }
[17:46:49.537]         else {
[17:46:49.537]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.537]         }
[17:46:49.537]         base::close(...future.stdout)
[17:46:49.537]         ...future.stdout <- NULL
[17:46:49.537]     }
[17:46:49.537]     ...future.result$conditions <- ...future.conditions
[17:46:49.537]     ...future.result$finished <- base::Sys.time()
[17:46:49.537]     ...future.result
[17:46:49.537] }
[17:46:49.540] MultisessionFuture started
[17:46:49.540] - Launch lazy future ... done
[17:46:49.540] run() for ‘MultisessionFuture’ ... done
[17:46:49.541] getGlobalsAndPackages() ...
[17:46:49.541] Searching for globals...
[17:46:49.542] - globals found: [1] ‘{’
[17:46:49.542] Searching for globals ... DONE
[17:46:49.542] Resolving globals: FALSE
[17:46:49.542] 
[17:46:49.542] 
[17:46:49.542] getGlobalsAndPackages() ... DONE
[17:46:49.542] run() for ‘Future’ ...
[17:46:49.543] - state: ‘created’
[17:46:49.543] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:49.558] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:49.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:49.558]   - Field: ‘node’
[17:46:49.558]   - Field: ‘label’
[17:46:49.558]   - Field: ‘local’
[17:46:49.559]   - Field: ‘owner’
[17:46:49.559]   - Field: ‘envir’
[17:46:49.559]   - Field: ‘workers’
[17:46:49.559]   - Field: ‘packages’
[17:46:49.559]   - Field: ‘gc’
[17:46:49.559]   - Field: ‘conditions’
[17:46:49.559]   - Field: ‘persistent’
[17:46:49.559]   - Field: ‘expr’
[17:46:49.559]   - Field: ‘uuid’
[17:46:49.559]   - Field: ‘seed’
[17:46:49.560]   - Field: ‘version’
[17:46:49.560]   - Field: ‘result’
[17:46:49.560]   - Field: ‘asynchronous’
[17:46:49.560]   - Field: ‘calls’
[17:46:49.560]   - Field: ‘globals’
[17:46:49.560]   - Field: ‘stdout’
[17:46:49.560]   - Field: ‘earlySignal’
[17:46:49.560]   - Field: ‘lazy’
[17:46:49.560]   - Field: ‘state’
[17:46:49.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:49.560] - Launch lazy future ...
[17:46:49.561] Packages needed by the future expression (n = 0): <none>
[17:46:49.561] Packages needed by future strategies (n = 0): <none>
[17:46:49.561] {
[17:46:49.561]     {
[17:46:49.561]         {
[17:46:49.561]             ...future.startTime <- base::Sys.time()
[17:46:49.561]             {
[17:46:49.561]                 {
[17:46:49.561]                   {
[17:46:49.561]                     {
[17:46:49.561]                       base::local({
[17:46:49.561]                         has_future <- base::requireNamespace("future", 
[17:46:49.561]                           quietly = TRUE)
[17:46:49.561]                         if (has_future) {
[17:46:49.561]                           ns <- base::getNamespace("future")
[17:46:49.561]                           version <- ns[[".package"]][["version"]]
[17:46:49.561]                           if (is.null(version)) 
[17:46:49.561]                             version <- utils::packageVersion("future")
[17:46:49.561]                         }
[17:46:49.561]                         else {
[17:46:49.561]                           version <- NULL
[17:46:49.561]                         }
[17:46:49.561]                         if (!has_future || version < "1.8.0") {
[17:46:49.561]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:49.561]                             "", base::R.version$version.string), 
[17:46:49.561]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:49.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:49.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:49.561]                               "release", "version")], collapse = " "), 
[17:46:49.561]                             hostname = base::Sys.info()[["nodename"]])
[17:46:49.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:49.561]                             info)
[17:46:49.561]                           info <- base::paste(info, collapse = "; ")
[17:46:49.561]                           if (!has_future) {
[17:46:49.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:49.561]                               info)
[17:46:49.561]                           }
[17:46:49.561]                           else {
[17:46:49.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:49.561]                               info, version)
[17:46:49.561]                           }
[17:46:49.561]                           base::stop(msg)
[17:46:49.561]                         }
[17:46:49.561]                       })
[17:46:49.561]                     }
[17:46:49.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:49.561]                     base::options(mc.cores = 1L)
[17:46:49.561]                   }
[17:46:49.561]                   ...future.strategy.old <- future::plan("list")
[17:46:49.561]                   options(future.plan = NULL)
[17:46:49.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:49.561]                 }
[17:46:49.561]                 ...future.workdir <- getwd()
[17:46:49.561]             }
[17:46:49.561]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:49.561]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:49.561]         }
[17:46:49.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:49.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:49.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:49.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:49.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:49.561]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:49.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:49.561]             base::names(...future.oldOptions))
[17:46:49.561]     }
[17:46:49.561]     if (FALSE) {
[17:46:49.561]     }
[17:46:49.561]     else {
[17:46:49.561]         if (TRUE) {
[17:46:49.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:49.561]                 open = "w")
[17:46:49.561]         }
[17:46:49.561]         else {
[17:46:49.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:49.561]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:49.561]         }
[17:46:49.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:49.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:49.561]             base::sink(type = "output", split = FALSE)
[17:46:49.561]             base::close(...future.stdout)
[17:46:49.561]         }, add = TRUE)
[17:46:49.561]     }
[17:46:49.561]     ...future.frame <- base::sys.nframe()
[17:46:49.561]     ...future.conditions <- base::list()
[17:46:49.561]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:49.561]     if (FALSE) {
[17:46:49.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:49.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:49.561]     }
[17:46:49.561]     ...future.result <- base::tryCatch({
[17:46:49.561]         base::withCallingHandlers({
[17:46:49.561]             ...future.value <- base::withVisible(base::local({
[17:46:49.561]                 ...future.makeSendCondition <- base::local({
[17:46:49.561]                   sendCondition <- NULL
[17:46:49.561]                   function(frame = 1L) {
[17:46:49.561]                     if (is.function(sendCondition)) 
[17:46:49.561]                       return(sendCondition)
[17:46:49.561]                     ns <- getNamespace("parallel")
[17:46:49.561]                     if (exists("sendData", mode = "function", 
[17:46:49.561]                       envir = ns)) {
[17:46:49.561]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:49.561]                         envir = ns)
[17:46:49.561]                       envir <- sys.frame(frame)
[17:46:49.561]                       master <- NULL
[17:46:49.561]                       while (!identical(envir, .GlobalEnv) && 
[17:46:49.561]                         !identical(envir, emptyenv())) {
[17:46:49.561]                         if (exists("master", mode = "list", envir = envir, 
[17:46:49.561]                           inherits = FALSE)) {
[17:46:49.561]                           master <- get("master", mode = "list", 
[17:46:49.561]                             envir = envir, inherits = FALSE)
[17:46:49.561]                           if (inherits(master, c("SOCKnode", 
[17:46:49.561]                             "SOCK0node"))) {
[17:46:49.561]                             sendCondition <<- function(cond) {
[17:46:49.561]                               data <- list(type = "VALUE", value = cond, 
[17:46:49.561]                                 success = TRUE)
[17:46:49.561]                               parallel_sendData(master, data)
[17:46:49.561]                             }
[17:46:49.561]                             return(sendCondition)
[17:46:49.561]                           }
[17:46:49.561]                         }
[17:46:49.561]                         frame <- frame + 1L
[17:46:49.561]                         envir <- sys.frame(frame)
[17:46:49.561]                       }
[17:46:49.561]                     }
[17:46:49.561]                     sendCondition <<- function(cond) NULL
[17:46:49.561]                   }
[17:46:49.561]                 })
[17:46:49.561]                 withCallingHandlers({
[17:46:49.561]                   {
[17:46:49.561]                     4
[17:46:49.561]                   }
[17:46:49.561]                 }, immediateCondition = function(cond) {
[17:46:49.561]                   sendCondition <- ...future.makeSendCondition()
[17:46:49.561]                   sendCondition(cond)
[17:46:49.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.561]                   {
[17:46:49.561]                     inherits <- base::inherits
[17:46:49.561]                     invokeRestart <- base::invokeRestart
[17:46:49.561]                     is.null <- base::is.null
[17:46:49.561]                     muffled <- FALSE
[17:46:49.561]                     if (inherits(cond, "message")) {
[17:46:49.561]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:49.561]                       if (muffled) 
[17:46:49.561]                         invokeRestart("muffleMessage")
[17:46:49.561]                     }
[17:46:49.561]                     else if (inherits(cond, "warning")) {
[17:46:49.561]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:49.561]                       if (muffled) 
[17:46:49.561]                         invokeRestart("muffleWarning")
[17:46:49.561]                     }
[17:46:49.561]                     else if (inherits(cond, "condition")) {
[17:46:49.561]                       if (!is.null(pattern)) {
[17:46:49.561]                         computeRestarts <- base::computeRestarts
[17:46:49.561]                         grepl <- base::grepl
[17:46:49.561]                         restarts <- computeRestarts(cond)
[17:46:49.561]                         for (restart in restarts) {
[17:46:49.561]                           name <- restart$name
[17:46:49.561]                           if (is.null(name)) 
[17:46:49.561]                             next
[17:46:49.561]                           if (!grepl(pattern, name)) 
[17:46:49.561]                             next
[17:46:49.561]                           invokeRestart(restart)
[17:46:49.561]                           muffled <- TRUE
[17:46:49.561]                           break
[17:46:49.561]                         }
[17:46:49.561]                       }
[17:46:49.561]                     }
[17:46:49.561]                     invisible(muffled)
[17:46:49.561]                   }
[17:46:49.561]                   muffleCondition(cond)
[17:46:49.561]                 })
[17:46:49.561]             }))
[17:46:49.561]             future::FutureResult(value = ...future.value$value, 
[17:46:49.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.561]                   ...future.rng), globalenv = if (FALSE) 
[17:46:49.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:49.561]                     ...future.globalenv.names))
[17:46:49.561]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:49.561]         }, condition = base::local({
[17:46:49.561]             c <- base::c
[17:46:49.561]             inherits <- base::inherits
[17:46:49.561]             invokeRestart <- base::invokeRestart
[17:46:49.561]             length <- base::length
[17:46:49.561]             list <- base::list
[17:46:49.561]             seq.int <- base::seq.int
[17:46:49.561]             signalCondition <- base::signalCondition
[17:46:49.561]             sys.calls <- base::sys.calls
[17:46:49.561]             `[[` <- base::`[[`
[17:46:49.561]             `+` <- base::`+`
[17:46:49.561]             `<<-` <- base::`<<-`
[17:46:49.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:49.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:49.561]                   3L)]
[17:46:49.561]             }
[17:46:49.561]             function(cond) {
[17:46:49.561]                 is_error <- inherits(cond, "error")
[17:46:49.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:49.561]                   NULL)
[17:46:49.561]                 if (is_error) {
[17:46:49.561]                   sessionInformation <- function() {
[17:46:49.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:49.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:49.561]                       search = base::search(), system = base::Sys.info())
[17:46:49.561]                   }
[17:46:49.561]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:49.561]                     cond$call), session = sessionInformation(), 
[17:46:49.561]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:49.561]                   signalCondition(cond)
[17:46:49.561]                 }
[17:46:49.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:49.561]                 "immediateCondition"))) {
[17:46:49.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:49.561]                   ...future.conditions[[length(...future.conditions) + 
[17:46:49.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:49.561]                   if (TRUE && !signal) {
[17:46:49.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.561]                     {
[17:46:49.561]                       inherits <- base::inherits
[17:46:49.561]                       invokeRestart <- base::invokeRestart
[17:46:49.561]                       is.null <- base::is.null
[17:46:49.561]                       muffled <- FALSE
[17:46:49.561]                       if (inherits(cond, "message")) {
[17:46:49.561]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.561]                         if (muffled) 
[17:46:49.561]                           invokeRestart("muffleMessage")
[17:46:49.561]                       }
[17:46:49.561]                       else if (inherits(cond, "warning")) {
[17:46:49.561]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.561]                         if (muffled) 
[17:46:49.561]                           invokeRestart("muffleWarning")
[17:46:49.561]                       }
[17:46:49.561]                       else if (inherits(cond, "condition")) {
[17:46:49.561]                         if (!is.null(pattern)) {
[17:46:49.561]                           computeRestarts <- base::computeRestarts
[17:46:49.561]                           grepl <- base::grepl
[17:46:49.561]                           restarts <- computeRestarts(cond)
[17:46:49.561]                           for (restart in restarts) {
[17:46:49.561]                             name <- restart$name
[17:46:49.561]                             if (is.null(name)) 
[17:46:49.561]                               next
[17:46:49.561]                             if (!grepl(pattern, name)) 
[17:46:49.561]                               next
[17:46:49.561]                             invokeRestart(restart)
[17:46:49.561]                             muffled <- TRUE
[17:46:49.561]                             break
[17:46:49.561]                           }
[17:46:49.561]                         }
[17:46:49.561]                       }
[17:46:49.561]                       invisible(muffled)
[17:46:49.561]                     }
[17:46:49.561]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.561]                   }
[17:46:49.561]                 }
[17:46:49.561]                 else {
[17:46:49.561]                   if (TRUE) {
[17:46:49.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:49.561]                     {
[17:46:49.561]                       inherits <- base::inherits
[17:46:49.561]                       invokeRestart <- base::invokeRestart
[17:46:49.561]                       is.null <- base::is.null
[17:46:49.561]                       muffled <- FALSE
[17:46:49.561]                       if (inherits(cond, "message")) {
[17:46:49.561]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:49.561]                         if (muffled) 
[17:46:49.561]                           invokeRestart("muffleMessage")
[17:46:49.561]                       }
[17:46:49.561]                       else if (inherits(cond, "warning")) {
[17:46:49.561]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:49.561]                         if (muffled) 
[17:46:49.561]                           invokeRestart("muffleWarning")
[17:46:49.561]                       }
[17:46:49.561]                       else if (inherits(cond, "condition")) {
[17:46:49.561]                         if (!is.null(pattern)) {
[17:46:49.561]                           computeRestarts <- base::computeRestarts
[17:46:49.561]                           grepl <- base::grepl
[17:46:49.561]                           restarts <- computeRestarts(cond)
[17:46:49.561]                           for (restart in restarts) {
[17:46:49.561]                             name <- restart$name
[17:46:49.561]                             if (is.null(name)) 
[17:46:49.561]                               next
[17:46:49.561]                             if (!grepl(pattern, name)) 
[17:46:49.561]                               next
[17:46:49.561]                             invokeRestart(restart)
[17:46:49.561]                             muffled <- TRUE
[17:46:49.561]                             break
[17:46:49.561]                           }
[17:46:49.561]                         }
[17:46:49.561]                       }
[17:46:49.561]                       invisible(muffled)
[17:46:49.561]                     }
[17:46:49.561]                     muffleCondition(cond, pattern = "^muffle")
[17:46:49.561]                   }
[17:46:49.561]                 }
[17:46:49.561]             }
[17:46:49.561]         }))
[17:46:49.561]     }, error = function(ex) {
[17:46:49.561]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:49.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:49.561]                 ...future.rng), started = ...future.startTime, 
[17:46:49.561]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:49.561]             version = "1.8"), class = "FutureResult")
[17:46:49.561]     }, finally = {
[17:46:49.561]         if (!identical(...future.workdir, getwd())) 
[17:46:49.561]             setwd(...future.workdir)
[17:46:49.561]         {
[17:46:49.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:49.561]                 ...future.oldOptions$nwarnings <- NULL
[17:46:49.561]             }
[17:46:49.561]             base::options(...future.oldOptions)
[17:46:49.561]             if (.Platform$OS.type == "windows") {
[17:46:49.561]                 old_names <- names(...future.oldEnvVars)
[17:46:49.561]                 envs <- base::Sys.getenv()
[17:46:49.561]                 names <- names(envs)
[17:46:49.561]                 common <- intersect(names, old_names)
[17:46:49.561]                 added <- setdiff(names, old_names)
[17:46:49.561]                 removed <- setdiff(old_names, names)
[17:46:49.561]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:49.561]                   envs[common]]
[17:46:49.561]                 NAMES <- toupper(changed)
[17:46:49.561]                 args <- list()
[17:46:49.561]                 for (kk in seq_along(NAMES)) {
[17:46:49.561]                   name <- changed[[kk]]
[17:46:49.561]                   NAME <- NAMES[[kk]]
[17:46:49.561]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.561]                     next
[17:46:49.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.561]                 }
[17:46:49.561]                 NAMES <- toupper(added)
[17:46:49.561]                 for (kk in seq_along(NAMES)) {
[17:46:49.561]                   name <- added[[kk]]
[17:46:49.561]                   NAME <- NAMES[[kk]]
[17:46:49.561]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.561]                     next
[17:46:49.561]                   args[[name]] <- ""
[17:46:49.561]                 }
[17:46:49.561]                 NAMES <- toupper(removed)
[17:46:49.561]                 for (kk in seq_along(NAMES)) {
[17:46:49.561]                   name <- removed[[kk]]
[17:46:49.561]                   NAME <- NAMES[[kk]]
[17:46:49.561]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:49.561]                     next
[17:46:49.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:49.561]                 }
[17:46:49.561]                 if (length(args) > 0) 
[17:46:49.561]                   base::do.call(base::Sys.setenv, args = args)
[17:46:49.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:49.561]             }
[17:46:49.561]             else {
[17:46:49.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:49.561]             }
[17:46:49.561]             {
[17:46:49.561]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:49.561]                   0L) {
[17:46:49.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:49.561]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:49.561]                   base::options(opts)
[17:46:49.561]                 }
[17:46:49.561]                 {
[17:46:49.561]                   {
[17:46:49.561]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:49.561]                     NULL
[17:46:49.561]                   }
[17:46:49.561]                   options(future.plan = NULL)
[17:46:49.561]                   if (is.na(NA_character_)) 
[17:46:49.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:49.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:49.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:49.561]                     .init = FALSE)
[17:46:49.561]                 }
[17:46:49.561]             }
[17:46:49.561]         }
[17:46:49.561]     })
[17:46:49.561]     if (TRUE) {
[17:46:49.561]         base::sink(type = "output", split = FALSE)
[17:46:49.561]         if (TRUE) {
[17:46:49.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:49.561]         }
[17:46:49.561]         else {
[17:46:49.561]             ...future.result["stdout"] <- base::list(NULL)
[17:46:49.561]         }
[17:46:49.561]         base::close(...future.stdout)
[17:46:49.561]         ...future.stdout <- NULL
[17:46:49.561]     }
[17:46:49.561]     ...future.result$conditions <- ...future.conditions
[17:46:49.561]     ...future.result$finished <- base::Sys.time()
[17:46:49.561]     ...future.result
[17:46:49.561] }
[17:46:49.563] Poll #1 (0): usedNodes() = 2, workers = 2
[17:46:49.574] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.574] - Validating connection of MultisessionFuture
[17:46:49.575] - received message: FutureResult
[17:46:49.575] - Received FutureResult
[17:46:49.575] - Erased future from FutureRegistry
[17:46:49.575] result() for ClusterFuture ...
[17:46:49.576] - result already collected: FutureResult
[17:46:49.576] result() for ClusterFuture ... done
[17:46:49.576] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.576] result() for ClusterFuture ...
[17:46:49.576] - result already collected: FutureResult
[17:46:49.576] result() for ClusterFuture ... done
[17:46:49.577] result() for ClusterFuture ...
[17:46:49.577] - result already collected: FutureResult
[17:46:49.577] result() for ClusterFuture ... done
[17:46:49.578] MultisessionFuture started
[17:46:49.579] - Launch lazy future ... done
[17:46:49.579] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5617882fbf40> 
Classes 'listenv', 'environment' <environment: 0x561788b205c0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:46:49.587] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.587] - Validating connection of MultisessionFuture
[17:46:49.587] - received message: FutureResult
[17:46:49.588] - Received FutureResult
[17:46:49.588] - Erased future from FutureRegistry
[17:46:49.588] result() for ClusterFuture ...
[17:46:49.588] - result already collected: FutureResult
[17:46:49.588] result() for ClusterFuture ... done
[17:46:49.589] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:49.589] receiveMessageFromWorker() for ClusterFuture ...
[17:46:49.590] - Validating connection of MultisessionFuture
[17:46:49.590] - received message: FutureResult
[17:46:49.590] - Received FutureResult
[17:46:49.590] - Erased future from FutureRegistry
[17:46:49.590] result() for ClusterFuture ...
[17:46:49.591] - result already collected: FutureResult
[17:46:49.591] result() for ClusterFuture ... done
[17:46:49.591] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:46:49.596] resolve() on list environment ...
[17:46:49.596]  recursive: 0
[17:46:49.598]  length: 6
[17:46:49.598]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:46:49.598] signalConditionsASAP(numeric, pos=1) ...
[17:46:49.599] - nx: 6
[17:46:49.599] - relay: TRUE
[17:46:49.599] - stdout: TRUE
[17:46:49.599] - signal: TRUE
[17:46:49.599] - resignal: FALSE
[17:46:49.599] - force: TRUE
[17:46:49.600] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.600] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.600]  - until=2
[17:46:49.600]  - relaying element #2
[17:46:49.600] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.600] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.601] signalConditionsASAP(NULL, pos=1) ... done
[17:46:49.601]  length: 5 (resolved future 1)
[17:46:49.601] Future #2
[17:46:49.601] result() for ClusterFuture ...
[17:46:49.601] - result already collected: FutureResult
[17:46:49.602] result() for ClusterFuture ... done
[17:46:49.602] result() for ClusterFuture ...
[17:46:49.602] - result already collected: FutureResult
[17:46:49.602] result() for ClusterFuture ... done
[17:46:49.602] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:46:49.602] - nx: 6
[17:46:49.603] - relay: TRUE
[17:46:49.603] - stdout: TRUE
[17:46:49.603] - signal: TRUE
[17:46:49.603] - resignal: FALSE
[17:46:49.603] - force: TRUE
[17:46:49.603] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.604] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:46:49.604]  - until=2
[17:46:49.604]  - relaying element #2
[17:46:49.604] result() for ClusterFuture ...
[17:46:49.604] - result already collected: FutureResult
[17:46:49.604] result() for ClusterFuture ... done
[17:46:49.605] result() for ClusterFuture ...
[17:46:49.605] - result already collected: FutureResult
[17:46:49.605] result() for ClusterFuture ... done
[17:46:49.605] result() for ClusterFuture ...
[17:46:49.605] - result already collected: FutureResult
[17:46:49.605] result() for ClusterFuture ... done
[17:46:49.605] result() for ClusterFuture ...
[17:46:49.606] - result already collected: FutureResult
[17:46:49.606] result() for ClusterFuture ... done
[17:46:49.606] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.606] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.606] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:46:49.606]  length: 4 (resolved future 2)
[17:46:49.606] Future #3
[17:46:49.606] result() for ClusterFuture ...
[17:46:49.606] - result already collected: FutureResult
[17:46:49.606] result() for ClusterFuture ... done
[17:46:49.607] result() for ClusterFuture ...
[17:46:49.607] - result already collected: FutureResult
[17:46:49.607] result() for ClusterFuture ... done
[17:46:49.607] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:46:49.607] - nx: 6
[17:46:49.607] - relay: TRUE
[17:46:49.607] - stdout: TRUE
[17:46:49.607] - signal: TRUE
[17:46:49.607] - resignal: FALSE
[17:46:49.607] - force: TRUE
[17:46:49.607] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.607] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:46:49.608]  - until=3
[17:46:49.608]  - relaying element #3
[17:46:49.608] result() for ClusterFuture ...
[17:46:49.608] - result already collected: FutureResult
[17:46:49.608] result() for ClusterFuture ... done
[17:46:49.608] result() for ClusterFuture ...
[17:46:49.608] - result already collected: FutureResult
[17:46:49.608] result() for ClusterFuture ... done
[17:46:49.608] result() for ClusterFuture ...
[17:46:49.608] - result already collected: FutureResult
[17:46:49.608] result() for ClusterFuture ... done
[17:46:49.609] result() for ClusterFuture ...
[17:46:49.609] - result already collected: FutureResult
[17:46:49.609] result() for ClusterFuture ... done
[17:46:49.609] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.609] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.609] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:46:49.609]  length: 3 (resolved future 3)
[17:46:49.609] Future #4
[17:46:49.609] result() for ClusterFuture ...
[17:46:49.609] - result already collected: FutureResult
[17:46:49.609] result() for ClusterFuture ... done
[17:46:49.610] result() for ClusterFuture ...
[17:46:49.610] - result already collected: FutureResult
[17:46:49.610] result() for ClusterFuture ... done
[17:46:49.610] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:46:49.610] - nx: 6
[17:46:49.610] - relay: TRUE
[17:46:49.610] - stdout: TRUE
[17:46:49.610] - signal: TRUE
[17:46:49.610] - resignal: FALSE
[17:46:49.610] - force: TRUE
[17:46:49.610] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.611] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:46:49.611]  - until=4
[17:46:49.611]  - relaying element #4
[17:46:49.611] result() for ClusterFuture ...
[17:46:49.611] - result already collected: FutureResult
[17:46:49.611] result() for ClusterFuture ... done
[17:46:49.611] result() for ClusterFuture ...
[17:46:49.611] - result already collected: FutureResult
[17:46:49.611] result() for ClusterFuture ... done
[17:46:49.611] result() for ClusterFuture ...
[17:46:49.611] - result already collected: FutureResult
[17:46:49.612] result() for ClusterFuture ... done
[17:46:49.612] result() for ClusterFuture ...
[17:46:49.612] - result already collected: FutureResult
[17:46:49.612] result() for ClusterFuture ... done
[17:46:49.612] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.612] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.612] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:46:49.612]  length: 2 (resolved future 4)
[17:46:49.612] signalConditionsASAP(NULL, pos=5) ...
[17:46:49.612] - nx: 6
[17:46:49.612] - relay: TRUE
[17:46:49.613] - stdout: TRUE
[17:46:49.613] - signal: TRUE
[17:46:49.613] - resignal: FALSE
[17:46:49.613] - force: TRUE
[17:46:49.613] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.613] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.613]  - until=6
[17:46:49.613]  - relaying element #6
[17:46:49.613] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.613] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.613] signalConditionsASAP(NULL, pos=5) ... done
[17:46:49.613]  length: 1 (resolved future 5)
[17:46:49.614] signalConditionsASAP(numeric, pos=6) ...
[17:46:49.614] - nx: 6
[17:46:49.614] - relay: TRUE
[17:46:49.614] - stdout: TRUE
[17:46:49.614] - signal: TRUE
[17:46:49.614] - resignal: FALSE
[17:46:49.614] - force: TRUE
[17:46:49.614] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:46:49.615] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.615]  - until=6
[17:46:49.615] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.615] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.615] signalConditionsASAP(numeric, pos=6) ... done
[17:46:49.615]  length: 0 (resolved future 6)
[17:46:49.615] Relaying remaining futures
[17:46:49.616] signalConditionsASAP(NULL, pos=0) ...
[17:46:49.616] - nx: 6
[17:46:49.616] - relay: TRUE
[17:46:49.616] - stdout: TRUE
[17:46:49.616] - signal: TRUE
[17:46:49.616] - resignal: FALSE
[17:46:49.616] - force: TRUE
[17:46:49.616] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:46:49.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:46:49.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:46:49.617] signalConditionsASAP(NULL, pos=0) ... done
[17:46:49.617] resolve() on list environment ... DONE
[17:46:49.617] result() for ClusterFuture ...
[17:46:49.618] - result already collected: FutureResult
[17:46:49.618] result() for ClusterFuture ... done
[17:46:49.618] result() for ClusterFuture ...
[17:46:49.618] - result already collected: FutureResult
[17:46:49.618] result() for ClusterFuture ... done
[17:46:49.618] result() for ClusterFuture ...
[17:46:49.618] - result already collected: FutureResult
[17:46:49.619] result() for ClusterFuture ... done
[17:46:49.619] result() for ClusterFuture ...
[17:46:49.619] - result already collected: FutureResult
[17:46:49.619] result() for ClusterFuture ... done
[17:46:49.619] result() for ClusterFuture ...
[17:46:49.619] - result already collected: FutureResult
[17:46:49.619] result() for ClusterFuture ... done
[17:46:49.620] result() for ClusterFuture ...
[17:46:49.620] - result already collected: FutureResult
[17:46:49.620] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x561788faa300> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[17:46:49.623] plan(): Setting new future strategy stack:
[17:46:49.623] List of future strategies:
[17:46:49.623] 1. FutureStrategy:
[17:46:49.623]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:49.623]    - tweaked: FALSE
[17:46:49.623]    - call: future::plan(oplan)
[17:46:49.624] plan(): nbrOfWorkers() = 1
> 
