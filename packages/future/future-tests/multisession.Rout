
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:05:15.916] plan(): Setting new future strategy stack:
[18:05:15.917] List of future strategies:
[18:05:15.917] 1. sequential:
[18:05:15.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:15.917]    - tweaked: FALSE
[18:05:15.917]    - call: future::plan("sequential")
[18:05:15.940] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** multisession() ...")
*** multisession() ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   ## No global variables
+   f <- multisession({
+     42L
+   })
+   print(f)
+   stopifnot(inherits(f, "ClusterFuture") || (inherits(f, "SequentialFuture") && f$lazy))
+ 
+   print(resolved(f))
+   y <- value(f)
+   print(y)
+   stopifnot(y == 42L)
+ 
+ 
+   ## A global variable
+   a <- 0
+   f <- multisession({
+     b <- 3
+     c <- 2
+     a * b * c
+   }, globals = TRUE)
+   print(f)
+ 
+ 
+   ## A multisession future is evaluated in a separate
+   ## R session process.  Changing the value of a global
+   ## variable should not affect the result of the
+   ## future.
+   a <- 7  ## Make sure globals are frozen
+   v <- value(f)
+   print(v)
+   stopifnot(v == 0)
+ 
+ 
+   message("*** multisession() with globals and blocking")
+   x <- listenv()
+   for (ii in 2:1) {
+     message(sprintf(" - Creating multisession future #%d ...", ii))
+     x[[ii]] <- multisession({ ii }, globals = TRUE)
+   }
+   message(sprintf(" - Resolving %d multisession futures", length(x)))
+   v <- sapply(x, FUN = value)
+   stopifnot(all(v == 1:2))
+ 
+ 
+   message("*** multisession() - workers inherit .libPaths()")
+ 
+   libs <- value(future(.libPaths()))
+   str(list(
+     main = .libPaths(),
+     workers = libs
+   ))
+   stopifnot(identical(libs, .libPaths()))
+ 
+   message("*** multisession() and errors")
+   f <- multisession({
+     stop("Whoops!")
+     1
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "simpleError"))
+ 
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Error is repeated
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Custom error class
+   f <- multisession({
+     stop(structure(list(message = "boom"),
+                    class = c("MyError", "error", "condition")))
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+ 
+   ## Make sure error is signaled
+   res <- tryCatch(value(f), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   ## Issue #200: Custom condition class attributes are lost
+   ## https://github.com/HenrikBengtsson/Wishlist-for-R/issues/57
+   ## stopifnot(inherits(res, "MyError"))    
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
[18:05:16.045] getGlobalsAndPackages() ...
[18:05:16.046] Searching for globals...
[18:05:16.052] - globals found: [1] ‘{’
[18:05:16.052] Searching for globals ... DONE
[18:05:16.052] Resolving globals: FALSE
[18:05:16.053] 
[18:05:16.053] 
[18:05:16.054] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:16.057] Packages needed by the future expression (n = 0): <none>
[18:05:16.057] Packages needed by future strategies (n = 0): <none>
[18:05:16.059] {
[18:05:16.059]     {
[18:05:16.059]         {
[18:05:16.059]             ...future.startTime <- base::Sys.time()
[18:05:16.059]             {
[18:05:16.059]                 {
[18:05:16.059]                   {
[18:05:16.059]                     base::local({
[18:05:16.059]                       has_future <- base::requireNamespace("future", 
[18:05:16.059]                         quietly = TRUE)
[18:05:16.059]                       if (has_future) {
[18:05:16.059]                         ns <- base::getNamespace("future")
[18:05:16.059]                         version <- ns[[".package"]][["version"]]
[18:05:16.059]                         if (is.null(version)) 
[18:05:16.059]                           version <- utils::packageVersion("future")
[18:05:16.059]                       }
[18:05:16.059]                       else {
[18:05:16.059]                         version <- NULL
[18:05:16.059]                       }
[18:05:16.059]                       if (!has_future || version < "1.8.0") {
[18:05:16.059]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:16.059]                           "", base::R.version$version.string), 
[18:05:16.059]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:16.059]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:16.059]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:16.059]                             "release", "version")], collapse = " "), 
[18:05:16.059]                           hostname = base::Sys.info()[["nodename"]])
[18:05:16.059]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:16.059]                           info)
[18:05:16.059]                         info <- base::paste(info, collapse = "; ")
[18:05:16.059]                         if (!has_future) {
[18:05:16.059]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:16.059]                             info)
[18:05:16.059]                         }
[18:05:16.059]                         else {
[18:05:16.059]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:16.059]                             info, version)
[18:05:16.059]                         }
[18:05:16.059]                         base::stop(msg)
[18:05:16.059]                       }
[18:05:16.059]                     })
[18:05:16.059]                   }
[18:05:16.059]                   ...future.strategy.old <- future::plan("list")
[18:05:16.059]                   options(future.plan = NULL)
[18:05:16.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:16.059]                 }
[18:05:16.059]                 ...future.workdir <- getwd()
[18:05:16.059]             }
[18:05:16.059]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:16.059]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:16.059]         }
[18:05:16.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:16.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:16.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:16.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:16.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:16.059]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:16.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:16.059]             base::names(...future.oldOptions))
[18:05:16.059]     }
[18:05:16.059]     if (FALSE) {
[18:05:16.059]     }
[18:05:16.059]     else {
[18:05:16.059]         if (TRUE) {
[18:05:16.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:16.059]                 open = "w")
[18:05:16.059]         }
[18:05:16.059]         else {
[18:05:16.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:16.059]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:16.059]         }
[18:05:16.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:16.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:16.059]             base::sink(type = "output", split = FALSE)
[18:05:16.059]             base::close(...future.stdout)
[18:05:16.059]         }, add = TRUE)
[18:05:16.059]     }
[18:05:16.059]     ...future.frame <- base::sys.nframe()
[18:05:16.059]     ...future.conditions <- base::list()
[18:05:16.059]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:16.059]     if (FALSE) {
[18:05:16.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:16.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:16.059]     }
[18:05:16.059]     ...future.result <- base::tryCatch({
[18:05:16.059]         base::withCallingHandlers({
[18:05:16.059]             ...future.value <- base::withVisible(base::local({
[18:05:16.059]                 42L
[18:05:16.059]             }))
[18:05:16.059]             future::FutureResult(value = ...future.value$value, 
[18:05:16.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.059]                   ...future.rng), globalenv = if (FALSE) 
[18:05:16.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:16.059]                     ...future.globalenv.names))
[18:05:16.059]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:16.059]         }, condition = base::local({
[18:05:16.059]             c <- base::c
[18:05:16.059]             inherits <- base::inherits
[18:05:16.059]             invokeRestart <- base::invokeRestart
[18:05:16.059]             length <- base::length
[18:05:16.059]             list <- base::list
[18:05:16.059]             seq.int <- base::seq.int
[18:05:16.059]             signalCondition <- base::signalCondition
[18:05:16.059]             sys.calls <- base::sys.calls
[18:05:16.059]             `[[` <- base::`[[`
[18:05:16.059]             `+` <- base::`+`
[18:05:16.059]             `<<-` <- base::`<<-`
[18:05:16.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:16.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:16.059]                   3L)]
[18:05:16.059]             }
[18:05:16.059]             function(cond) {
[18:05:16.059]                 is_error <- inherits(cond, "error")
[18:05:16.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:16.059]                   NULL)
[18:05:16.059]                 if (is_error) {
[18:05:16.059]                   sessionInformation <- function() {
[18:05:16.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:16.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:16.059]                       search = base::search(), system = base::Sys.info())
[18:05:16.059]                   }
[18:05:16.059]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:16.059]                     cond$call), session = sessionInformation(), 
[18:05:16.059]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:16.059]                   signalCondition(cond)
[18:05:16.059]                 }
[18:05:16.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:16.059]                 "immediateCondition"))) {
[18:05:16.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:16.059]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:16.059]                   if (TRUE && !signal) {
[18:05:16.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.059]                     {
[18:05:16.059]                       inherits <- base::inherits
[18:05:16.059]                       invokeRestart <- base::invokeRestart
[18:05:16.059]                       is.null <- base::is.null
[18:05:16.059]                       muffled <- FALSE
[18:05:16.059]                       if (inherits(cond, "message")) {
[18:05:16.059]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.059]                         if (muffled) 
[18:05:16.059]                           invokeRestart("muffleMessage")
[18:05:16.059]                       }
[18:05:16.059]                       else if (inherits(cond, "warning")) {
[18:05:16.059]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.059]                         if (muffled) 
[18:05:16.059]                           invokeRestart("muffleWarning")
[18:05:16.059]                       }
[18:05:16.059]                       else if (inherits(cond, "condition")) {
[18:05:16.059]                         if (!is.null(pattern)) {
[18:05:16.059]                           computeRestarts <- base::computeRestarts
[18:05:16.059]                           grepl <- base::grepl
[18:05:16.059]                           restarts <- computeRestarts(cond)
[18:05:16.059]                           for (restart in restarts) {
[18:05:16.059]                             name <- restart$name
[18:05:16.059]                             if (is.null(name)) 
[18:05:16.059]                               next
[18:05:16.059]                             if (!grepl(pattern, name)) 
[18:05:16.059]                               next
[18:05:16.059]                             invokeRestart(restart)
[18:05:16.059]                             muffled <- TRUE
[18:05:16.059]                             break
[18:05:16.059]                           }
[18:05:16.059]                         }
[18:05:16.059]                       }
[18:05:16.059]                       invisible(muffled)
[18:05:16.059]                     }
[18:05:16.059]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.059]                   }
[18:05:16.059]                 }
[18:05:16.059]                 else {
[18:05:16.059]                   if (TRUE) {
[18:05:16.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.059]                     {
[18:05:16.059]                       inherits <- base::inherits
[18:05:16.059]                       invokeRestart <- base::invokeRestart
[18:05:16.059]                       is.null <- base::is.null
[18:05:16.059]                       muffled <- FALSE
[18:05:16.059]                       if (inherits(cond, "message")) {
[18:05:16.059]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.059]                         if (muffled) 
[18:05:16.059]                           invokeRestart("muffleMessage")
[18:05:16.059]                       }
[18:05:16.059]                       else if (inherits(cond, "warning")) {
[18:05:16.059]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.059]                         if (muffled) 
[18:05:16.059]                           invokeRestart("muffleWarning")
[18:05:16.059]                       }
[18:05:16.059]                       else if (inherits(cond, "condition")) {
[18:05:16.059]                         if (!is.null(pattern)) {
[18:05:16.059]                           computeRestarts <- base::computeRestarts
[18:05:16.059]                           grepl <- base::grepl
[18:05:16.059]                           restarts <- computeRestarts(cond)
[18:05:16.059]                           for (restart in restarts) {
[18:05:16.059]                             name <- restart$name
[18:05:16.059]                             if (is.null(name)) 
[18:05:16.059]                               next
[18:05:16.059]                             if (!grepl(pattern, name)) 
[18:05:16.059]                               next
[18:05:16.059]                             invokeRestart(restart)
[18:05:16.059]                             muffled <- TRUE
[18:05:16.059]                             break
[18:05:16.059]                           }
[18:05:16.059]                         }
[18:05:16.059]                       }
[18:05:16.059]                       invisible(muffled)
[18:05:16.059]                     }
[18:05:16.059]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.059]                   }
[18:05:16.059]                 }
[18:05:16.059]             }
[18:05:16.059]         }))
[18:05:16.059]     }, error = function(ex) {
[18:05:16.059]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:16.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.059]                 ...future.rng), started = ...future.startTime, 
[18:05:16.059]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:16.059]             version = "1.8"), class = "FutureResult")
[18:05:16.059]     }, finally = {
[18:05:16.059]         if (!identical(...future.workdir, getwd())) 
[18:05:16.059]             setwd(...future.workdir)
[18:05:16.059]         {
[18:05:16.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:16.059]                 ...future.oldOptions$nwarnings <- NULL
[18:05:16.059]             }
[18:05:16.059]             base::options(...future.oldOptions)
[18:05:16.059]             if (.Platform$OS.type == "windows") {
[18:05:16.059]                 old_names <- names(...future.oldEnvVars)
[18:05:16.059]                 envs <- base::Sys.getenv()
[18:05:16.059]                 names <- names(envs)
[18:05:16.059]                 common <- intersect(names, old_names)
[18:05:16.059]                 added <- setdiff(names, old_names)
[18:05:16.059]                 removed <- setdiff(old_names, names)
[18:05:16.059]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:16.059]                   envs[common]]
[18:05:16.059]                 NAMES <- toupper(changed)
[18:05:16.059]                 args <- list()
[18:05:16.059]                 for (kk in seq_along(NAMES)) {
[18:05:16.059]                   name <- changed[[kk]]
[18:05:16.059]                   NAME <- NAMES[[kk]]
[18:05:16.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.059]                     next
[18:05:16.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.059]                 }
[18:05:16.059]                 NAMES <- toupper(added)
[18:05:16.059]                 for (kk in seq_along(NAMES)) {
[18:05:16.059]                   name <- added[[kk]]
[18:05:16.059]                   NAME <- NAMES[[kk]]
[18:05:16.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.059]                     next
[18:05:16.059]                   args[[name]] <- ""
[18:05:16.059]                 }
[18:05:16.059]                 NAMES <- toupper(removed)
[18:05:16.059]                 for (kk in seq_along(NAMES)) {
[18:05:16.059]                   name <- removed[[kk]]
[18:05:16.059]                   NAME <- NAMES[[kk]]
[18:05:16.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.059]                     next
[18:05:16.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.059]                 }
[18:05:16.059]                 if (length(args) > 0) 
[18:05:16.059]                   base::do.call(base::Sys.setenv, args = args)
[18:05:16.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:16.059]             }
[18:05:16.059]             else {
[18:05:16.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:16.059]             }
[18:05:16.059]             {
[18:05:16.059]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:16.059]                   0L) {
[18:05:16.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:16.059]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:16.059]                   base::options(opts)
[18:05:16.059]                 }
[18:05:16.059]                 {
[18:05:16.059]                   {
[18:05:16.059]                     NULL
[18:05:16.059]                     RNGkind("Mersenne-Twister")
[18:05:16.059]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:16.059]                       inherits = FALSE)
[18:05:16.059]                   }
[18:05:16.059]                   options(future.plan = NULL)
[18:05:16.059]                   if (is.na(NA_character_)) 
[18:05:16.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:16.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:16.059]                     .init = FALSE)
[18:05:16.059]                 }
[18:05:16.059]             }
[18:05:16.059]         }
[18:05:16.059]     })
[18:05:16.059]     if (TRUE) {
[18:05:16.059]         base::sink(type = "output", split = FALSE)
[18:05:16.059]         if (TRUE) {
[18:05:16.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:16.059]         }
[18:05:16.059]         else {
[18:05:16.059]             ...future.result["stdout"] <- base::list(NULL)
[18:05:16.059]         }
[18:05:16.059]         base::close(...future.stdout)
[18:05:16.059]         ...future.stdout <- NULL
[18:05:16.059]     }
[18:05:16.059]     ...future.result$conditions <- ...future.conditions
[18:05:16.059]     ...future.result$finished <- base::Sys.time()
[18:05:16.059]     ...future.result
[18:05:16.059] }
[18:05:16.063] plan(): Setting new future strategy stack:
[18:05:16.063] List of future strategies:
[18:05:16.063] 1. sequential:
[18:05:16.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.063]    - tweaked: FALSE
[18:05:16.063]    - call: NULL
[18:05:16.064] plan(): nbrOfWorkers() = 1
[18:05:16.067] plan(): Setting new future strategy stack:
[18:05:16.067] List of future strategies:
[18:05:16.067] 1. sequential:
[18:05:16.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.067]    - tweaked: FALSE
[18:05:16.067]    - call: future::plan("sequential")
[18:05:16.068] plan(): nbrOfWorkers() = 1
[18:05:16.069] SequentialFuture started (and completed)
[18:05:16.069] resolved() for ‘SequentialFuture’ ...
[18:05:16.070] - state: ‘finished’
[18:05:16.070] - run: TRUE
[18:05:16.070] - result: ‘FutureResult’
[18:05:16.070] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
[18:05:16.077] getGlobalsAndPackages() ...
[18:05:16.077] Searching for globals...
[18:05:16.087] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[18:05:16.088] Searching for globals ... DONE
[18:05:16.088] Resolving globals: FALSE
[18:05:16.089] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:16.090] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:05:16.091] - globals: [1] ‘a’
[18:05:16.091] 
[18:05:16.091] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:16.093] Packages needed by the future expression (n = 0): <none>
[18:05:16.093] Packages needed by future strategies (n = 0): <none>
[18:05:16.094] {
[18:05:16.094]     {
[18:05:16.094]         {
[18:05:16.094]             ...future.startTime <- base::Sys.time()
[18:05:16.094]             {
[18:05:16.094]                 {
[18:05:16.094]                   {
[18:05:16.094]                     base::local({
[18:05:16.094]                       has_future <- base::requireNamespace("future", 
[18:05:16.094]                         quietly = TRUE)
[18:05:16.094]                       if (has_future) {
[18:05:16.094]                         ns <- base::getNamespace("future")
[18:05:16.094]                         version <- ns[[".package"]][["version"]]
[18:05:16.094]                         if (is.null(version)) 
[18:05:16.094]                           version <- utils::packageVersion("future")
[18:05:16.094]                       }
[18:05:16.094]                       else {
[18:05:16.094]                         version <- NULL
[18:05:16.094]                       }
[18:05:16.094]                       if (!has_future || version < "1.8.0") {
[18:05:16.094]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:16.094]                           "", base::R.version$version.string), 
[18:05:16.094]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:16.094]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:16.094]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:16.094]                             "release", "version")], collapse = " "), 
[18:05:16.094]                           hostname = base::Sys.info()[["nodename"]])
[18:05:16.094]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:16.094]                           info)
[18:05:16.094]                         info <- base::paste(info, collapse = "; ")
[18:05:16.094]                         if (!has_future) {
[18:05:16.094]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:16.094]                             info)
[18:05:16.094]                         }
[18:05:16.094]                         else {
[18:05:16.094]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:16.094]                             info, version)
[18:05:16.094]                         }
[18:05:16.094]                         base::stop(msg)
[18:05:16.094]                       }
[18:05:16.094]                     })
[18:05:16.094]                   }
[18:05:16.094]                   ...future.strategy.old <- future::plan("list")
[18:05:16.094]                   options(future.plan = NULL)
[18:05:16.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:16.094]                 }
[18:05:16.094]                 ...future.workdir <- getwd()
[18:05:16.094]             }
[18:05:16.094]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:16.094]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:16.094]         }
[18:05:16.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:16.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:16.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:16.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:16.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:16.094]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:16.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:16.094]             base::names(...future.oldOptions))
[18:05:16.094]     }
[18:05:16.094]     if (FALSE) {
[18:05:16.094]     }
[18:05:16.094]     else {
[18:05:16.094]         if (TRUE) {
[18:05:16.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:16.094]                 open = "w")
[18:05:16.094]         }
[18:05:16.094]         else {
[18:05:16.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:16.094]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:16.094]         }
[18:05:16.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:16.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:16.094]             base::sink(type = "output", split = FALSE)
[18:05:16.094]             base::close(...future.stdout)
[18:05:16.094]         }, add = TRUE)
[18:05:16.094]     }
[18:05:16.094]     ...future.frame <- base::sys.nframe()
[18:05:16.094]     ...future.conditions <- base::list()
[18:05:16.094]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:16.094]     if (FALSE) {
[18:05:16.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:16.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:16.094]     }
[18:05:16.094]     ...future.result <- base::tryCatch({
[18:05:16.094]         base::withCallingHandlers({
[18:05:16.094]             ...future.value <- base::withVisible(base::local({
[18:05:16.094]                 b <- 3
[18:05:16.094]                 c <- 2
[18:05:16.094]                 a * b * c
[18:05:16.094]             }))
[18:05:16.094]             future::FutureResult(value = ...future.value$value, 
[18:05:16.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.094]                   ...future.rng), globalenv = if (FALSE) 
[18:05:16.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:16.094]                     ...future.globalenv.names))
[18:05:16.094]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:16.094]         }, condition = base::local({
[18:05:16.094]             c <- base::c
[18:05:16.094]             inherits <- base::inherits
[18:05:16.094]             invokeRestart <- base::invokeRestart
[18:05:16.094]             length <- base::length
[18:05:16.094]             list <- base::list
[18:05:16.094]             seq.int <- base::seq.int
[18:05:16.094]             signalCondition <- base::signalCondition
[18:05:16.094]             sys.calls <- base::sys.calls
[18:05:16.094]             `[[` <- base::`[[`
[18:05:16.094]             `+` <- base::`+`
[18:05:16.094]             `<<-` <- base::`<<-`
[18:05:16.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:16.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:16.094]                   3L)]
[18:05:16.094]             }
[18:05:16.094]             function(cond) {
[18:05:16.094]                 is_error <- inherits(cond, "error")
[18:05:16.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:16.094]                   NULL)
[18:05:16.094]                 if (is_error) {
[18:05:16.094]                   sessionInformation <- function() {
[18:05:16.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:16.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:16.094]                       search = base::search(), system = base::Sys.info())
[18:05:16.094]                   }
[18:05:16.094]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:16.094]                     cond$call), session = sessionInformation(), 
[18:05:16.094]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:16.094]                   signalCondition(cond)
[18:05:16.094]                 }
[18:05:16.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:16.094]                 "immediateCondition"))) {
[18:05:16.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:16.094]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:16.094]                   if (TRUE && !signal) {
[18:05:16.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.094]                     {
[18:05:16.094]                       inherits <- base::inherits
[18:05:16.094]                       invokeRestart <- base::invokeRestart
[18:05:16.094]                       is.null <- base::is.null
[18:05:16.094]                       muffled <- FALSE
[18:05:16.094]                       if (inherits(cond, "message")) {
[18:05:16.094]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.094]                         if (muffled) 
[18:05:16.094]                           invokeRestart("muffleMessage")
[18:05:16.094]                       }
[18:05:16.094]                       else if (inherits(cond, "warning")) {
[18:05:16.094]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.094]                         if (muffled) 
[18:05:16.094]                           invokeRestart("muffleWarning")
[18:05:16.094]                       }
[18:05:16.094]                       else if (inherits(cond, "condition")) {
[18:05:16.094]                         if (!is.null(pattern)) {
[18:05:16.094]                           computeRestarts <- base::computeRestarts
[18:05:16.094]                           grepl <- base::grepl
[18:05:16.094]                           restarts <- computeRestarts(cond)
[18:05:16.094]                           for (restart in restarts) {
[18:05:16.094]                             name <- restart$name
[18:05:16.094]                             if (is.null(name)) 
[18:05:16.094]                               next
[18:05:16.094]                             if (!grepl(pattern, name)) 
[18:05:16.094]                               next
[18:05:16.094]                             invokeRestart(restart)
[18:05:16.094]                             muffled <- TRUE
[18:05:16.094]                             break
[18:05:16.094]                           }
[18:05:16.094]                         }
[18:05:16.094]                       }
[18:05:16.094]                       invisible(muffled)
[18:05:16.094]                     }
[18:05:16.094]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.094]                   }
[18:05:16.094]                 }
[18:05:16.094]                 else {
[18:05:16.094]                   if (TRUE) {
[18:05:16.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.094]                     {
[18:05:16.094]                       inherits <- base::inherits
[18:05:16.094]                       invokeRestart <- base::invokeRestart
[18:05:16.094]                       is.null <- base::is.null
[18:05:16.094]                       muffled <- FALSE
[18:05:16.094]                       if (inherits(cond, "message")) {
[18:05:16.094]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.094]                         if (muffled) 
[18:05:16.094]                           invokeRestart("muffleMessage")
[18:05:16.094]                       }
[18:05:16.094]                       else if (inherits(cond, "warning")) {
[18:05:16.094]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.094]                         if (muffled) 
[18:05:16.094]                           invokeRestart("muffleWarning")
[18:05:16.094]                       }
[18:05:16.094]                       else if (inherits(cond, "condition")) {
[18:05:16.094]                         if (!is.null(pattern)) {
[18:05:16.094]                           computeRestarts <- base::computeRestarts
[18:05:16.094]                           grepl <- base::grepl
[18:05:16.094]                           restarts <- computeRestarts(cond)
[18:05:16.094]                           for (restart in restarts) {
[18:05:16.094]                             name <- restart$name
[18:05:16.094]                             if (is.null(name)) 
[18:05:16.094]                               next
[18:05:16.094]                             if (!grepl(pattern, name)) 
[18:05:16.094]                               next
[18:05:16.094]                             invokeRestart(restart)
[18:05:16.094]                             muffled <- TRUE
[18:05:16.094]                             break
[18:05:16.094]                           }
[18:05:16.094]                         }
[18:05:16.094]                       }
[18:05:16.094]                       invisible(muffled)
[18:05:16.094]                     }
[18:05:16.094]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.094]                   }
[18:05:16.094]                 }
[18:05:16.094]             }
[18:05:16.094]         }))
[18:05:16.094]     }, error = function(ex) {
[18:05:16.094]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:16.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.094]                 ...future.rng), started = ...future.startTime, 
[18:05:16.094]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:16.094]             version = "1.8"), class = "FutureResult")
[18:05:16.094]     }, finally = {
[18:05:16.094]         if (!identical(...future.workdir, getwd())) 
[18:05:16.094]             setwd(...future.workdir)
[18:05:16.094]         {
[18:05:16.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:16.094]                 ...future.oldOptions$nwarnings <- NULL
[18:05:16.094]             }
[18:05:16.094]             base::options(...future.oldOptions)
[18:05:16.094]             if (.Platform$OS.type == "windows") {
[18:05:16.094]                 old_names <- names(...future.oldEnvVars)
[18:05:16.094]                 envs <- base::Sys.getenv()
[18:05:16.094]                 names <- names(envs)
[18:05:16.094]                 common <- intersect(names, old_names)
[18:05:16.094]                 added <- setdiff(names, old_names)
[18:05:16.094]                 removed <- setdiff(old_names, names)
[18:05:16.094]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:16.094]                   envs[common]]
[18:05:16.094]                 NAMES <- toupper(changed)
[18:05:16.094]                 args <- list()
[18:05:16.094]                 for (kk in seq_along(NAMES)) {
[18:05:16.094]                   name <- changed[[kk]]
[18:05:16.094]                   NAME <- NAMES[[kk]]
[18:05:16.094]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.094]                     next
[18:05:16.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.094]                 }
[18:05:16.094]                 NAMES <- toupper(added)
[18:05:16.094]                 for (kk in seq_along(NAMES)) {
[18:05:16.094]                   name <- added[[kk]]
[18:05:16.094]                   NAME <- NAMES[[kk]]
[18:05:16.094]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.094]                     next
[18:05:16.094]                   args[[name]] <- ""
[18:05:16.094]                 }
[18:05:16.094]                 NAMES <- toupper(removed)
[18:05:16.094]                 for (kk in seq_along(NAMES)) {
[18:05:16.094]                   name <- removed[[kk]]
[18:05:16.094]                   NAME <- NAMES[[kk]]
[18:05:16.094]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.094]                     next
[18:05:16.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.094]                 }
[18:05:16.094]                 if (length(args) > 0) 
[18:05:16.094]                   base::do.call(base::Sys.setenv, args = args)
[18:05:16.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:16.094]             }
[18:05:16.094]             else {
[18:05:16.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:16.094]             }
[18:05:16.094]             {
[18:05:16.094]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:16.094]                   0L) {
[18:05:16.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:16.094]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:16.094]                   base::options(opts)
[18:05:16.094]                 }
[18:05:16.094]                 {
[18:05:16.094]                   {
[18:05:16.094]                     NULL
[18:05:16.094]                     RNGkind("Mersenne-Twister")
[18:05:16.094]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:16.094]                       inherits = FALSE)
[18:05:16.094]                   }
[18:05:16.094]                   options(future.plan = NULL)
[18:05:16.094]                   if (is.na(NA_character_)) 
[18:05:16.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:16.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:16.094]                     .init = FALSE)
[18:05:16.094]                 }
[18:05:16.094]             }
[18:05:16.094]         }
[18:05:16.094]     })
[18:05:16.094]     if (TRUE) {
[18:05:16.094]         base::sink(type = "output", split = FALSE)
[18:05:16.094]         if (TRUE) {
[18:05:16.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:16.094]         }
[18:05:16.094]         else {
[18:05:16.094]             ...future.result["stdout"] <- base::list(NULL)
[18:05:16.094]         }
[18:05:16.094]         base::close(...future.stdout)
[18:05:16.094]         ...future.stdout <- NULL
[18:05:16.094]     }
[18:05:16.094]     ...future.result$conditions <- ...future.conditions
[18:05:16.094]     ...future.result$finished <- base::Sys.time()
[18:05:16.094]     ...future.result
[18:05:16.094] }
[18:05:16.098] assign_globals() ...
[18:05:16.098] List of 1
[18:05:16.098]  $ a: num 0
[18:05:16.098]  - attr(*, "where")=List of 1
[18:05:16.098]   ..$ a:<environment: R_EmptyEnv> 
[18:05:16.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:16.098]  - attr(*, "resolved")= logi FALSE
[18:05:16.098]  - attr(*, "total_size")= num 56
[18:05:16.111] - copied ‘a’ to environment
[18:05:16.111] assign_globals() ... done
[18:05:16.112] plan(): Setting new future strategy stack:
[18:05:16.112] List of future strategies:
[18:05:16.112] 1. sequential:
[18:05:16.112]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.112]    - tweaked: FALSE
[18:05:16.112]    - call: NULL
[18:05:16.113] plan(): nbrOfWorkers() = 1
[18:05:16.114] plan(): Setting new future strategy stack:
[18:05:16.115] List of future strategies:
[18:05:16.115] 1. sequential:
[18:05:16.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.115]    - tweaked: FALSE
[18:05:16.115]    - call: future::plan("sequential")
[18:05:16.116] plan(): nbrOfWorkers() = 1
[18:05:16.116] SequentialFuture started (and completed)
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[18:05:16.122] getGlobalsAndPackages() ...
[18:05:16.123] Searching for globals...
[18:05:16.124] - globals found: [2] ‘{’, ‘ii’
[18:05:16.124] Searching for globals ... DONE
[18:05:16.125] Resolving globals: FALSE
[18:05:16.125] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:16.126] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:16.127] - globals: [1] ‘ii’
[18:05:16.127] 
[18:05:16.127] getGlobalsAndPackages() ... DONE
 - Creating multisession future #1 ...
[18:05:16.134] getGlobalsAndPackages() ...
[18:05:16.134] Searching for globals...
[18:05:16.135] - globals found: [2] ‘{’, ‘ii’
[18:05:16.136] Searching for globals ... DONE
[18:05:16.136] Resolving globals: FALSE
[18:05:16.137] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:16.137] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:16.138] - globals: [1] ‘ii’
[18:05:16.138] 
[18:05:16.138] getGlobalsAndPackages() ... DONE
 - Resolving 2 multisession futures
[18:05:16.139] Packages needed by the future expression (n = 0): <none>
[18:05:16.140] Packages needed by future strategies (n = 0): <none>
[18:05:16.141] {
[18:05:16.141]     {
[18:05:16.141]         {
[18:05:16.141]             ...future.startTime <- base::Sys.time()
[18:05:16.141]             {
[18:05:16.141]                 {
[18:05:16.141]                   {
[18:05:16.141]                     base::local({
[18:05:16.141]                       has_future <- base::requireNamespace("future", 
[18:05:16.141]                         quietly = TRUE)
[18:05:16.141]                       if (has_future) {
[18:05:16.141]                         ns <- base::getNamespace("future")
[18:05:16.141]                         version <- ns[[".package"]][["version"]]
[18:05:16.141]                         if (is.null(version)) 
[18:05:16.141]                           version <- utils::packageVersion("future")
[18:05:16.141]                       }
[18:05:16.141]                       else {
[18:05:16.141]                         version <- NULL
[18:05:16.141]                       }
[18:05:16.141]                       if (!has_future || version < "1.8.0") {
[18:05:16.141]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:16.141]                           "", base::R.version$version.string), 
[18:05:16.141]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:16.141]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:16.141]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:16.141]                             "release", "version")], collapse = " "), 
[18:05:16.141]                           hostname = base::Sys.info()[["nodename"]])
[18:05:16.141]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:16.141]                           info)
[18:05:16.141]                         info <- base::paste(info, collapse = "; ")
[18:05:16.141]                         if (!has_future) {
[18:05:16.141]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:16.141]                             info)
[18:05:16.141]                         }
[18:05:16.141]                         else {
[18:05:16.141]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:16.141]                             info, version)
[18:05:16.141]                         }
[18:05:16.141]                         base::stop(msg)
[18:05:16.141]                       }
[18:05:16.141]                     })
[18:05:16.141]                   }
[18:05:16.141]                   ...future.strategy.old <- future::plan("list")
[18:05:16.141]                   options(future.plan = NULL)
[18:05:16.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:16.141]                 }
[18:05:16.141]                 ...future.workdir <- getwd()
[18:05:16.141]             }
[18:05:16.141]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:16.141]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:16.141]         }
[18:05:16.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:16.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:16.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:16.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:16.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:16.141]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:16.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:16.141]             base::names(...future.oldOptions))
[18:05:16.141]     }
[18:05:16.141]     if (FALSE) {
[18:05:16.141]     }
[18:05:16.141]     else {
[18:05:16.141]         if (TRUE) {
[18:05:16.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:16.141]                 open = "w")
[18:05:16.141]         }
[18:05:16.141]         else {
[18:05:16.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:16.141]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:16.141]         }
[18:05:16.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:16.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:16.141]             base::sink(type = "output", split = FALSE)
[18:05:16.141]             base::close(...future.stdout)
[18:05:16.141]         }, add = TRUE)
[18:05:16.141]     }
[18:05:16.141]     ...future.frame <- base::sys.nframe()
[18:05:16.141]     ...future.conditions <- base::list()
[18:05:16.141]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:16.141]     if (FALSE) {
[18:05:16.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:16.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:16.141]     }
[18:05:16.141]     ...future.result <- base::tryCatch({
[18:05:16.141]         base::withCallingHandlers({
[18:05:16.141]             ...future.value <- base::withVisible(base::local({
[18:05:16.141]                 ii
[18:05:16.141]             }))
[18:05:16.141]             future::FutureResult(value = ...future.value$value, 
[18:05:16.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.141]                   ...future.rng), globalenv = if (FALSE) 
[18:05:16.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:16.141]                     ...future.globalenv.names))
[18:05:16.141]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:16.141]         }, condition = base::local({
[18:05:16.141]             c <- base::c
[18:05:16.141]             inherits <- base::inherits
[18:05:16.141]             invokeRestart <- base::invokeRestart
[18:05:16.141]             length <- base::length
[18:05:16.141]             list <- base::list
[18:05:16.141]             seq.int <- base::seq.int
[18:05:16.141]             signalCondition <- base::signalCondition
[18:05:16.141]             sys.calls <- base::sys.calls
[18:05:16.141]             `[[` <- base::`[[`
[18:05:16.141]             `+` <- base::`+`
[18:05:16.141]             `<<-` <- base::`<<-`
[18:05:16.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:16.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:16.141]                   3L)]
[18:05:16.141]             }
[18:05:16.141]             function(cond) {
[18:05:16.141]                 is_error <- inherits(cond, "error")
[18:05:16.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:16.141]                   NULL)
[18:05:16.141]                 if (is_error) {
[18:05:16.141]                   sessionInformation <- function() {
[18:05:16.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:16.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:16.141]                       search = base::search(), system = base::Sys.info())
[18:05:16.141]                   }
[18:05:16.141]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:16.141]                     cond$call), session = sessionInformation(), 
[18:05:16.141]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:16.141]                   signalCondition(cond)
[18:05:16.141]                 }
[18:05:16.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:16.141]                 "immediateCondition"))) {
[18:05:16.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:16.141]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:16.141]                   if (TRUE && !signal) {
[18:05:16.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.141]                     {
[18:05:16.141]                       inherits <- base::inherits
[18:05:16.141]                       invokeRestart <- base::invokeRestart
[18:05:16.141]                       is.null <- base::is.null
[18:05:16.141]                       muffled <- FALSE
[18:05:16.141]                       if (inherits(cond, "message")) {
[18:05:16.141]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.141]                         if (muffled) 
[18:05:16.141]                           invokeRestart("muffleMessage")
[18:05:16.141]                       }
[18:05:16.141]                       else if (inherits(cond, "warning")) {
[18:05:16.141]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.141]                         if (muffled) 
[18:05:16.141]                           invokeRestart("muffleWarning")
[18:05:16.141]                       }
[18:05:16.141]                       else if (inherits(cond, "condition")) {
[18:05:16.141]                         if (!is.null(pattern)) {
[18:05:16.141]                           computeRestarts <- base::computeRestarts
[18:05:16.141]                           grepl <- base::grepl
[18:05:16.141]                           restarts <- computeRestarts(cond)
[18:05:16.141]                           for (restart in restarts) {
[18:05:16.141]                             name <- restart$name
[18:05:16.141]                             if (is.null(name)) 
[18:05:16.141]                               next
[18:05:16.141]                             if (!grepl(pattern, name)) 
[18:05:16.141]                               next
[18:05:16.141]                             invokeRestart(restart)
[18:05:16.141]                             muffled <- TRUE
[18:05:16.141]                             break
[18:05:16.141]                           }
[18:05:16.141]                         }
[18:05:16.141]                       }
[18:05:16.141]                       invisible(muffled)
[18:05:16.141]                     }
[18:05:16.141]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.141]                   }
[18:05:16.141]                 }
[18:05:16.141]                 else {
[18:05:16.141]                   if (TRUE) {
[18:05:16.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.141]                     {
[18:05:16.141]                       inherits <- base::inherits
[18:05:16.141]                       invokeRestart <- base::invokeRestart
[18:05:16.141]                       is.null <- base::is.null
[18:05:16.141]                       muffled <- FALSE
[18:05:16.141]                       if (inherits(cond, "message")) {
[18:05:16.141]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.141]                         if (muffled) 
[18:05:16.141]                           invokeRestart("muffleMessage")
[18:05:16.141]                       }
[18:05:16.141]                       else if (inherits(cond, "warning")) {
[18:05:16.141]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.141]                         if (muffled) 
[18:05:16.141]                           invokeRestart("muffleWarning")
[18:05:16.141]                       }
[18:05:16.141]                       else if (inherits(cond, "condition")) {
[18:05:16.141]                         if (!is.null(pattern)) {
[18:05:16.141]                           computeRestarts <- base::computeRestarts
[18:05:16.141]                           grepl <- base::grepl
[18:05:16.141]                           restarts <- computeRestarts(cond)
[18:05:16.141]                           for (restart in restarts) {
[18:05:16.141]                             name <- restart$name
[18:05:16.141]                             if (is.null(name)) 
[18:05:16.141]                               next
[18:05:16.141]                             if (!grepl(pattern, name)) 
[18:05:16.141]                               next
[18:05:16.141]                             invokeRestart(restart)
[18:05:16.141]                             muffled <- TRUE
[18:05:16.141]                             break
[18:05:16.141]                           }
[18:05:16.141]                         }
[18:05:16.141]                       }
[18:05:16.141]                       invisible(muffled)
[18:05:16.141]                     }
[18:05:16.141]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.141]                   }
[18:05:16.141]                 }
[18:05:16.141]             }
[18:05:16.141]         }))
[18:05:16.141]     }, error = function(ex) {
[18:05:16.141]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:16.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.141]                 ...future.rng), started = ...future.startTime, 
[18:05:16.141]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:16.141]             version = "1.8"), class = "FutureResult")
[18:05:16.141]     }, finally = {
[18:05:16.141]         if (!identical(...future.workdir, getwd())) 
[18:05:16.141]             setwd(...future.workdir)
[18:05:16.141]         {
[18:05:16.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:16.141]                 ...future.oldOptions$nwarnings <- NULL
[18:05:16.141]             }
[18:05:16.141]             base::options(...future.oldOptions)
[18:05:16.141]             if (.Platform$OS.type == "windows") {
[18:05:16.141]                 old_names <- names(...future.oldEnvVars)
[18:05:16.141]                 envs <- base::Sys.getenv()
[18:05:16.141]                 names <- names(envs)
[18:05:16.141]                 common <- intersect(names, old_names)
[18:05:16.141]                 added <- setdiff(names, old_names)
[18:05:16.141]                 removed <- setdiff(old_names, names)
[18:05:16.141]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:16.141]                   envs[common]]
[18:05:16.141]                 NAMES <- toupper(changed)
[18:05:16.141]                 args <- list()
[18:05:16.141]                 for (kk in seq_along(NAMES)) {
[18:05:16.141]                   name <- changed[[kk]]
[18:05:16.141]                   NAME <- NAMES[[kk]]
[18:05:16.141]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.141]                     next
[18:05:16.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.141]                 }
[18:05:16.141]                 NAMES <- toupper(added)
[18:05:16.141]                 for (kk in seq_along(NAMES)) {
[18:05:16.141]                   name <- added[[kk]]
[18:05:16.141]                   NAME <- NAMES[[kk]]
[18:05:16.141]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.141]                     next
[18:05:16.141]                   args[[name]] <- ""
[18:05:16.141]                 }
[18:05:16.141]                 NAMES <- toupper(removed)
[18:05:16.141]                 for (kk in seq_along(NAMES)) {
[18:05:16.141]                   name <- removed[[kk]]
[18:05:16.141]                   NAME <- NAMES[[kk]]
[18:05:16.141]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.141]                     next
[18:05:16.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.141]                 }
[18:05:16.141]                 if (length(args) > 0) 
[18:05:16.141]                   base::do.call(base::Sys.setenv, args = args)
[18:05:16.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:16.141]             }
[18:05:16.141]             else {
[18:05:16.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:16.141]             }
[18:05:16.141]             {
[18:05:16.141]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:16.141]                   0L) {
[18:05:16.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:16.141]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:16.141]                   base::options(opts)
[18:05:16.141]                 }
[18:05:16.141]                 {
[18:05:16.141]                   {
[18:05:16.141]                     NULL
[18:05:16.141]                     RNGkind("Mersenne-Twister")
[18:05:16.141]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:16.141]                       inherits = FALSE)
[18:05:16.141]                   }
[18:05:16.141]                   options(future.plan = NULL)
[18:05:16.141]                   if (is.na(NA_character_)) 
[18:05:16.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:16.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:16.141]                     .init = FALSE)
[18:05:16.141]                 }
[18:05:16.141]             }
[18:05:16.141]         }
[18:05:16.141]     })
[18:05:16.141]     if (TRUE) {
[18:05:16.141]         base::sink(type = "output", split = FALSE)
[18:05:16.141]         if (TRUE) {
[18:05:16.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:16.141]         }
[18:05:16.141]         else {
[18:05:16.141]             ...future.result["stdout"] <- base::list(NULL)
[18:05:16.141]         }
[18:05:16.141]         base::close(...future.stdout)
[18:05:16.141]         ...future.stdout <- NULL
[18:05:16.141]     }
[18:05:16.141]     ...future.result$conditions <- ...future.conditions
[18:05:16.141]     ...future.result$finished <- base::Sys.time()
[18:05:16.141]     ...future.result
[18:05:16.141] }
[18:05:16.144] assign_globals() ...
[18:05:16.144] List of 1
[18:05:16.144]  $ ii: int 1
[18:05:16.144]  - attr(*, "where")=List of 1
[18:05:16.144]   ..$ ii:<environment: R_EmptyEnv> 
[18:05:16.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:16.144]  - attr(*, "resolved")= logi FALSE
[18:05:16.144]  - attr(*, "total_size")= num 56
[18:05:16.149] - copied ‘ii’ to environment
[18:05:16.149] assign_globals() ... done
[18:05:16.150] plan(): Setting new future strategy stack:
[18:05:16.150] List of future strategies:
[18:05:16.150] 1. sequential:
[18:05:16.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.150]    - tweaked: FALSE
[18:05:16.150]    - call: NULL
[18:05:16.151] plan(): nbrOfWorkers() = 1
[18:05:16.153] plan(): Setting new future strategy stack:
[18:05:16.153] List of future strategies:
[18:05:16.153] 1. sequential:
[18:05:16.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.153]    - tweaked: FALSE
[18:05:16.153]    - call: future::plan("sequential")
[18:05:16.154] plan(): nbrOfWorkers() = 1
[18:05:16.154] SequentialFuture started (and completed)
[18:05:16.155] Packages needed by the future expression (n = 0): <none>
[18:05:16.155] Packages needed by future strategies (n = 0): <none>
[18:05:16.156] {
[18:05:16.156]     {
[18:05:16.156]         {
[18:05:16.156]             ...future.startTime <- base::Sys.time()
[18:05:16.156]             {
[18:05:16.156]                 {
[18:05:16.156]                   {
[18:05:16.156]                     base::local({
[18:05:16.156]                       has_future <- base::requireNamespace("future", 
[18:05:16.156]                         quietly = TRUE)
[18:05:16.156]                       if (has_future) {
[18:05:16.156]                         ns <- base::getNamespace("future")
[18:05:16.156]                         version <- ns[[".package"]][["version"]]
[18:05:16.156]                         if (is.null(version)) 
[18:05:16.156]                           version <- utils::packageVersion("future")
[18:05:16.156]                       }
[18:05:16.156]                       else {
[18:05:16.156]                         version <- NULL
[18:05:16.156]                       }
[18:05:16.156]                       if (!has_future || version < "1.8.0") {
[18:05:16.156]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:16.156]                           "", base::R.version$version.string), 
[18:05:16.156]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:16.156]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:16.156]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:16.156]                             "release", "version")], collapse = " "), 
[18:05:16.156]                           hostname = base::Sys.info()[["nodename"]])
[18:05:16.156]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:16.156]                           info)
[18:05:16.156]                         info <- base::paste(info, collapse = "; ")
[18:05:16.156]                         if (!has_future) {
[18:05:16.156]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:16.156]                             info)
[18:05:16.156]                         }
[18:05:16.156]                         else {
[18:05:16.156]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:16.156]                             info, version)
[18:05:16.156]                         }
[18:05:16.156]                         base::stop(msg)
[18:05:16.156]                       }
[18:05:16.156]                     })
[18:05:16.156]                   }
[18:05:16.156]                   ...future.strategy.old <- future::plan("list")
[18:05:16.156]                   options(future.plan = NULL)
[18:05:16.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:16.156]                 }
[18:05:16.156]                 ...future.workdir <- getwd()
[18:05:16.156]             }
[18:05:16.156]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:16.156]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:16.156]         }
[18:05:16.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:16.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:16.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:16.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:16.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:16.156]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:16.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:16.156]             base::names(...future.oldOptions))
[18:05:16.156]     }
[18:05:16.156]     if (FALSE) {
[18:05:16.156]     }
[18:05:16.156]     else {
[18:05:16.156]         if (TRUE) {
[18:05:16.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:16.156]                 open = "w")
[18:05:16.156]         }
[18:05:16.156]         else {
[18:05:16.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:16.156]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:16.156]         }
[18:05:16.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:16.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:16.156]             base::sink(type = "output", split = FALSE)
[18:05:16.156]             base::close(...future.stdout)
[18:05:16.156]         }, add = TRUE)
[18:05:16.156]     }
[18:05:16.156]     ...future.frame <- base::sys.nframe()
[18:05:16.156]     ...future.conditions <- base::list()
[18:05:16.156]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:16.156]     if (FALSE) {
[18:05:16.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:16.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:16.156]     }
[18:05:16.156]     ...future.result <- base::tryCatch({
[18:05:16.156]         base::withCallingHandlers({
[18:05:16.156]             ...future.value <- base::withVisible(base::local({
[18:05:16.156]                 ii
[18:05:16.156]             }))
[18:05:16.156]             future::FutureResult(value = ...future.value$value, 
[18:05:16.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.156]                   ...future.rng), globalenv = if (FALSE) 
[18:05:16.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:16.156]                     ...future.globalenv.names))
[18:05:16.156]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:16.156]         }, condition = base::local({
[18:05:16.156]             c <- base::c
[18:05:16.156]             inherits <- base::inherits
[18:05:16.156]             invokeRestart <- base::invokeRestart
[18:05:16.156]             length <- base::length
[18:05:16.156]             list <- base::list
[18:05:16.156]             seq.int <- base::seq.int
[18:05:16.156]             signalCondition <- base::signalCondition
[18:05:16.156]             sys.calls <- base::sys.calls
[18:05:16.156]             `[[` <- base::`[[`
[18:05:16.156]             `+` <- base::`+`
[18:05:16.156]             `<<-` <- base::`<<-`
[18:05:16.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:16.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:16.156]                   3L)]
[18:05:16.156]             }
[18:05:16.156]             function(cond) {
[18:05:16.156]                 is_error <- inherits(cond, "error")
[18:05:16.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:16.156]                   NULL)
[18:05:16.156]                 if (is_error) {
[18:05:16.156]                   sessionInformation <- function() {
[18:05:16.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:16.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:16.156]                       search = base::search(), system = base::Sys.info())
[18:05:16.156]                   }
[18:05:16.156]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:16.156]                     cond$call), session = sessionInformation(), 
[18:05:16.156]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:16.156]                   signalCondition(cond)
[18:05:16.156]                 }
[18:05:16.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:16.156]                 "immediateCondition"))) {
[18:05:16.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:16.156]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:16.156]                   if (TRUE && !signal) {
[18:05:16.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.156]                     {
[18:05:16.156]                       inherits <- base::inherits
[18:05:16.156]                       invokeRestart <- base::invokeRestart
[18:05:16.156]                       is.null <- base::is.null
[18:05:16.156]                       muffled <- FALSE
[18:05:16.156]                       if (inherits(cond, "message")) {
[18:05:16.156]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.156]                         if (muffled) 
[18:05:16.156]                           invokeRestart("muffleMessage")
[18:05:16.156]                       }
[18:05:16.156]                       else if (inherits(cond, "warning")) {
[18:05:16.156]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.156]                         if (muffled) 
[18:05:16.156]                           invokeRestart("muffleWarning")
[18:05:16.156]                       }
[18:05:16.156]                       else if (inherits(cond, "condition")) {
[18:05:16.156]                         if (!is.null(pattern)) {
[18:05:16.156]                           computeRestarts <- base::computeRestarts
[18:05:16.156]                           grepl <- base::grepl
[18:05:16.156]                           restarts <- computeRestarts(cond)
[18:05:16.156]                           for (restart in restarts) {
[18:05:16.156]                             name <- restart$name
[18:05:16.156]                             if (is.null(name)) 
[18:05:16.156]                               next
[18:05:16.156]                             if (!grepl(pattern, name)) 
[18:05:16.156]                               next
[18:05:16.156]                             invokeRestart(restart)
[18:05:16.156]                             muffled <- TRUE
[18:05:16.156]                             break
[18:05:16.156]                           }
[18:05:16.156]                         }
[18:05:16.156]                       }
[18:05:16.156]                       invisible(muffled)
[18:05:16.156]                     }
[18:05:16.156]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.156]                   }
[18:05:16.156]                 }
[18:05:16.156]                 else {
[18:05:16.156]                   if (TRUE) {
[18:05:16.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.156]                     {
[18:05:16.156]                       inherits <- base::inherits
[18:05:16.156]                       invokeRestart <- base::invokeRestart
[18:05:16.156]                       is.null <- base::is.null
[18:05:16.156]                       muffled <- FALSE
[18:05:16.156]                       if (inherits(cond, "message")) {
[18:05:16.156]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.156]                         if (muffled) 
[18:05:16.156]                           invokeRestart("muffleMessage")
[18:05:16.156]                       }
[18:05:16.156]                       else if (inherits(cond, "warning")) {
[18:05:16.156]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.156]                         if (muffled) 
[18:05:16.156]                           invokeRestart("muffleWarning")
[18:05:16.156]                       }
[18:05:16.156]                       else if (inherits(cond, "condition")) {
[18:05:16.156]                         if (!is.null(pattern)) {
[18:05:16.156]                           computeRestarts <- base::computeRestarts
[18:05:16.156]                           grepl <- base::grepl
[18:05:16.156]                           restarts <- computeRestarts(cond)
[18:05:16.156]                           for (restart in restarts) {
[18:05:16.156]                             name <- restart$name
[18:05:16.156]                             if (is.null(name)) 
[18:05:16.156]                               next
[18:05:16.156]                             if (!grepl(pattern, name)) 
[18:05:16.156]                               next
[18:05:16.156]                             invokeRestart(restart)
[18:05:16.156]                             muffled <- TRUE
[18:05:16.156]                             break
[18:05:16.156]                           }
[18:05:16.156]                         }
[18:05:16.156]                       }
[18:05:16.156]                       invisible(muffled)
[18:05:16.156]                     }
[18:05:16.156]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.156]                   }
[18:05:16.156]                 }
[18:05:16.156]             }
[18:05:16.156]         }))
[18:05:16.156]     }, error = function(ex) {
[18:05:16.156]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:16.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.156]                 ...future.rng), started = ...future.startTime, 
[18:05:16.156]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:16.156]             version = "1.8"), class = "FutureResult")
[18:05:16.156]     }, finally = {
[18:05:16.156]         if (!identical(...future.workdir, getwd())) 
[18:05:16.156]             setwd(...future.workdir)
[18:05:16.156]         {
[18:05:16.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:16.156]                 ...future.oldOptions$nwarnings <- NULL
[18:05:16.156]             }
[18:05:16.156]             base::options(...future.oldOptions)
[18:05:16.156]             if (.Platform$OS.type == "windows") {
[18:05:16.156]                 old_names <- names(...future.oldEnvVars)
[18:05:16.156]                 envs <- base::Sys.getenv()
[18:05:16.156]                 names <- names(envs)
[18:05:16.156]                 common <- intersect(names, old_names)
[18:05:16.156]                 added <- setdiff(names, old_names)
[18:05:16.156]                 removed <- setdiff(old_names, names)
[18:05:16.156]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:16.156]                   envs[common]]
[18:05:16.156]                 NAMES <- toupper(changed)
[18:05:16.156]                 args <- list()
[18:05:16.156]                 for (kk in seq_along(NAMES)) {
[18:05:16.156]                   name <- changed[[kk]]
[18:05:16.156]                   NAME <- NAMES[[kk]]
[18:05:16.156]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.156]                     next
[18:05:16.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.156]                 }
[18:05:16.156]                 NAMES <- toupper(added)
[18:05:16.156]                 for (kk in seq_along(NAMES)) {
[18:05:16.156]                   name <- added[[kk]]
[18:05:16.156]                   NAME <- NAMES[[kk]]
[18:05:16.156]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.156]                     next
[18:05:16.156]                   args[[name]] <- ""
[18:05:16.156]                 }
[18:05:16.156]                 NAMES <- toupper(removed)
[18:05:16.156]                 for (kk in seq_along(NAMES)) {
[18:05:16.156]                   name <- removed[[kk]]
[18:05:16.156]                   NAME <- NAMES[[kk]]
[18:05:16.156]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.156]                     next
[18:05:16.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.156]                 }
[18:05:16.156]                 if (length(args) > 0) 
[18:05:16.156]                   base::do.call(base::Sys.setenv, args = args)
[18:05:16.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:16.156]             }
[18:05:16.156]             else {
[18:05:16.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:16.156]             }
[18:05:16.156]             {
[18:05:16.156]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:16.156]                   0L) {
[18:05:16.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:16.156]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:16.156]                   base::options(opts)
[18:05:16.156]                 }
[18:05:16.156]                 {
[18:05:16.156]                   {
[18:05:16.156]                     NULL
[18:05:16.156]                     RNGkind("Mersenne-Twister")
[18:05:16.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:16.156]                       inherits = FALSE)
[18:05:16.156]                   }
[18:05:16.156]                   options(future.plan = NULL)
[18:05:16.156]                   if (is.na(NA_character_)) 
[18:05:16.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:16.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:16.156]                     .init = FALSE)
[18:05:16.156]                 }
[18:05:16.156]             }
[18:05:16.156]         }
[18:05:16.156]     })
[18:05:16.156]     if (TRUE) {
[18:05:16.156]         base::sink(type = "output", split = FALSE)
[18:05:16.156]         if (TRUE) {
[18:05:16.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:16.156]         }
[18:05:16.156]         else {
[18:05:16.156]             ...future.result["stdout"] <- base::list(NULL)
[18:05:16.156]         }
[18:05:16.156]         base::close(...future.stdout)
[18:05:16.156]         ...future.stdout <- NULL
[18:05:16.156]     }
[18:05:16.156]     ...future.result$conditions <- ...future.conditions
[18:05:16.156]     ...future.result$finished <- base::Sys.time()
[18:05:16.156]     ...future.result
[18:05:16.156] }
[18:05:16.160] assign_globals() ...
[18:05:16.160] List of 1
[18:05:16.160]  $ ii: int 2
[18:05:16.160]  - attr(*, "where")=List of 1
[18:05:16.160]   ..$ ii:<environment: R_EmptyEnv> 
[18:05:16.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:16.160]  - attr(*, "resolved")= logi FALSE
[18:05:16.160]  - attr(*, "total_size")= num 56
[18:05:16.165] - copied ‘ii’ to environment
[18:05:16.165] assign_globals() ... done
[18:05:16.165] plan(): Setting new future strategy stack:
[18:05:16.166] List of future strategies:
[18:05:16.166] 1. sequential:
[18:05:16.166]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.166]    - tweaked: FALSE
[18:05:16.166]    - call: NULL
[18:05:16.167] plan(): nbrOfWorkers() = 1
[18:05:16.168] plan(): Setting new future strategy stack:
[18:05:16.169] List of future strategies:
[18:05:16.169] 1. sequential:
[18:05:16.169]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.169]    - tweaked: FALSE
[18:05:16.169]    - call: future::plan("sequential")
[18:05:16.170] plan(): nbrOfWorkers() = 1
[18:05:16.170] SequentialFuture started (and completed)
*** multisession() - workers inherit .libPaths()
[18:05:16.171] getGlobalsAndPackages() ...
[18:05:16.171] Searching for globals...
[18:05:16.172] - globals found: [1] ‘.libPaths’
[18:05:16.172] Searching for globals ... DONE
[18:05:16.172] Resolving globals: FALSE
[18:05:16.173] 
[18:05:16.173] 
[18:05:16.174] getGlobalsAndPackages() ... DONE
[18:05:16.174] run() for ‘Future’ ...
[18:05:16.175] - state: ‘created’
[18:05:16.175] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:16.176] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:16.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:16.176]   - Field: ‘label’
[18:05:16.176]   - Field: ‘local’
[18:05:16.176]   - Field: ‘owner’
[18:05:16.177]   - Field: ‘envir’
[18:05:16.177]   - Field: ‘packages’
[18:05:16.177]   - Field: ‘gc’
[18:05:16.177]   - Field: ‘conditions’
[18:05:16.177]   - Field: ‘expr’
[18:05:16.178]   - Field: ‘uuid’
[18:05:16.178]   - Field: ‘seed’
[18:05:16.178]   - Field: ‘version’
[18:05:16.178]   - Field: ‘result’
[18:05:16.178]   - Field: ‘asynchronous’
[18:05:16.179]   - Field: ‘calls’
[18:05:16.179]   - Field: ‘globals’
[18:05:16.179]   - Field: ‘stdout’
[18:05:16.179]   - Field: ‘earlySignal’
[18:05:16.179]   - Field: ‘lazy’
[18:05:16.180]   - Field: ‘state’
[18:05:16.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:16.180] - Launch lazy future ...
[18:05:16.180] Packages needed by the future expression (n = 0): <none>
[18:05:16.181] Packages needed by future strategies (n = 0): <none>
[18:05:16.182] {
[18:05:16.182]     {
[18:05:16.182]         {
[18:05:16.182]             ...future.startTime <- base::Sys.time()
[18:05:16.182]             {
[18:05:16.182]                 {
[18:05:16.182]                   {
[18:05:16.182]                     base::local({
[18:05:16.182]                       has_future <- base::requireNamespace("future", 
[18:05:16.182]                         quietly = TRUE)
[18:05:16.182]                       if (has_future) {
[18:05:16.182]                         ns <- base::getNamespace("future")
[18:05:16.182]                         version <- ns[[".package"]][["version"]]
[18:05:16.182]                         if (is.null(version)) 
[18:05:16.182]                           version <- utils::packageVersion("future")
[18:05:16.182]                       }
[18:05:16.182]                       else {
[18:05:16.182]                         version <- NULL
[18:05:16.182]                       }
[18:05:16.182]                       if (!has_future || version < "1.8.0") {
[18:05:16.182]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:16.182]                           "", base::R.version$version.string), 
[18:05:16.182]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:16.182]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:16.182]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:16.182]                             "release", "version")], collapse = " "), 
[18:05:16.182]                           hostname = base::Sys.info()[["nodename"]])
[18:05:16.182]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:16.182]                           info)
[18:05:16.182]                         info <- base::paste(info, collapse = "; ")
[18:05:16.182]                         if (!has_future) {
[18:05:16.182]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:16.182]                             info)
[18:05:16.182]                         }
[18:05:16.182]                         else {
[18:05:16.182]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:16.182]                             info, version)
[18:05:16.182]                         }
[18:05:16.182]                         base::stop(msg)
[18:05:16.182]                       }
[18:05:16.182]                     })
[18:05:16.182]                   }
[18:05:16.182]                   ...future.strategy.old <- future::plan("list")
[18:05:16.182]                   options(future.plan = NULL)
[18:05:16.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:16.182]                 }
[18:05:16.182]                 ...future.workdir <- getwd()
[18:05:16.182]             }
[18:05:16.182]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:16.182]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:16.182]         }
[18:05:16.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:16.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:16.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:16.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:16.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:16.182]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:16.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:16.182]             base::names(...future.oldOptions))
[18:05:16.182]     }
[18:05:16.182]     if (FALSE) {
[18:05:16.182]     }
[18:05:16.182]     else {
[18:05:16.182]         if (TRUE) {
[18:05:16.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:16.182]                 open = "w")
[18:05:16.182]         }
[18:05:16.182]         else {
[18:05:16.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:16.182]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:16.182]         }
[18:05:16.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:16.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:16.182]             base::sink(type = "output", split = FALSE)
[18:05:16.182]             base::close(...future.stdout)
[18:05:16.182]         }, add = TRUE)
[18:05:16.182]     }
[18:05:16.182]     ...future.frame <- base::sys.nframe()
[18:05:16.182]     ...future.conditions <- base::list()
[18:05:16.182]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:16.182]     if (FALSE) {
[18:05:16.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:16.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:16.182]     }
[18:05:16.182]     ...future.result <- base::tryCatch({
[18:05:16.182]         base::withCallingHandlers({
[18:05:16.182]             ...future.value <- base::withVisible(base::local(.libPaths()))
[18:05:16.182]             future::FutureResult(value = ...future.value$value, 
[18:05:16.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.182]                   ...future.rng), globalenv = if (FALSE) 
[18:05:16.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:16.182]                     ...future.globalenv.names))
[18:05:16.182]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:16.182]         }, condition = base::local({
[18:05:16.182]             c <- base::c
[18:05:16.182]             inherits <- base::inherits
[18:05:16.182]             invokeRestart <- base::invokeRestart
[18:05:16.182]             length <- base::length
[18:05:16.182]             list <- base::list
[18:05:16.182]             seq.int <- base::seq.int
[18:05:16.182]             signalCondition <- base::signalCondition
[18:05:16.182]             sys.calls <- base::sys.calls
[18:05:16.182]             `[[` <- base::`[[`
[18:05:16.182]             `+` <- base::`+`
[18:05:16.182]             `<<-` <- base::`<<-`
[18:05:16.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:16.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:16.182]                   3L)]
[18:05:16.182]             }
[18:05:16.182]             function(cond) {
[18:05:16.182]                 is_error <- inherits(cond, "error")
[18:05:16.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:16.182]                   NULL)
[18:05:16.182]                 if (is_error) {
[18:05:16.182]                   sessionInformation <- function() {
[18:05:16.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:16.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:16.182]                       search = base::search(), system = base::Sys.info())
[18:05:16.182]                   }
[18:05:16.182]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:16.182]                     cond$call), session = sessionInformation(), 
[18:05:16.182]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:16.182]                   signalCondition(cond)
[18:05:16.182]                 }
[18:05:16.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:16.182]                 "immediateCondition"))) {
[18:05:16.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:16.182]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:16.182]                   if (TRUE && !signal) {
[18:05:16.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.182]                     {
[18:05:16.182]                       inherits <- base::inherits
[18:05:16.182]                       invokeRestart <- base::invokeRestart
[18:05:16.182]                       is.null <- base::is.null
[18:05:16.182]                       muffled <- FALSE
[18:05:16.182]                       if (inherits(cond, "message")) {
[18:05:16.182]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.182]                         if (muffled) 
[18:05:16.182]                           invokeRestart("muffleMessage")
[18:05:16.182]                       }
[18:05:16.182]                       else if (inherits(cond, "warning")) {
[18:05:16.182]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.182]                         if (muffled) 
[18:05:16.182]                           invokeRestart("muffleWarning")
[18:05:16.182]                       }
[18:05:16.182]                       else if (inherits(cond, "condition")) {
[18:05:16.182]                         if (!is.null(pattern)) {
[18:05:16.182]                           computeRestarts <- base::computeRestarts
[18:05:16.182]                           grepl <- base::grepl
[18:05:16.182]                           restarts <- computeRestarts(cond)
[18:05:16.182]                           for (restart in restarts) {
[18:05:16.182]                             name <- restart$name
[18:05:16.182]                             if (is.null(name)) 
[18:05:16.182]                               next
[18:05:16.182]                             if (!grepl(pattern, name)) 
[18:05:16.182]                               next
[18:05:16.182]                             invokeRestart(restart)
[18:05:16.182]                             muffled <- TRUE
[18:05:16.182]                             break
[18:05:16.182]                           }
[18:05:16.182]                         }
[18:05:16.182]                       }
[18:05:16.182]                       invisible(muffled)
[18:05:16.182]                     }
[18:05:16.182]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.182]                   }
[18:05:16.182]                 }
[18:05:16.182]                 else {
[18:05:16.182]                   if (TRUE) {
[18:05:16.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.182]                     {
[18:05:16.182]                       inherits <- base::inherits
[18:05:16.182]                       invokeRestart <- base::invokeRestart
[18:05:16.182]                       is.null <- base::is.null
[18:05:16.182]                       muffled <- FALSE
[18:05:16.182]                       if (inherits(cond, "message")) {
[18:05:16.182]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.182]                         if (muffled) 
[18:05:16.182]                           invokeRestart("muffleMessage")
[18:05:16.182]                       }
[18:05:16.182]                       else if (inherits(cond, "warning")) {
[18:05:16.182]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.182]                         if (muffled) 
[18:05:16.182]                           invokeRestart("muffleWarning")
[18:05:16.182]                       }
[18:05:16.182]                       else if (inherits(cond, "condition")) {
[18:05:16.182]                         if (!is.null(pattern)) {
[18:05:16.182]                           computeRestarts <- base::computeRestarts
[18:05:16.182]                           grepl <- base::grepl
[18:05:16.182]                           restarts <- computeRestarts(cond)
[18:05:16.182]                           for (restart in restarts) {
[18:05:16.182]                             name <- restart$name
[18:05:16.182]                             if (is.null(name)) 
[18:05:16.182]                               next
[18:05:16.182]                             if (!grepl(pattern, name)) 
[18:05:16.182]                               next
[18:05:16.182]                             invokeRestart(restart)
[18:05:16.182]                             muffled <- TRUE
[18:05:16.182]                             break
[18:05:16.182]                           }
[18:05:16.182]                         }
[18:05:16.182]                       }
[18:05:16.182]                       invisible(muffled)
[18:05:16.182]                     }
[18:05:16.182]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.182]                   }
[18:05:16.182]                 }
[18:05:16.182]             }
[18:05:16.182]         }))
[18:05:16.182]     }, error = function(ex) {
[18:05:16.182]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:16.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.182]                 ...future.rng), started = ...future.startTime, 
[18:05:16.182]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:16.182]             version = "1.8"), class = "FutureResult")
[18:05:16.182]     }, finally = {
[18:05:16.182]         if (!identical(...future.workdir, getwd())) 
[18:05:16.182]             setwd(...future.workdir)
[18:05:16.182]         {
[18:05:16.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:16.182]                 ...future.oldOptions$nwarnings <- NULL
[18:05:16.182]             }
[18:05:16.182]             base::options(...future.oldOptions)
[18:05:16.182]             if (.Platform$OS.type == "windows") {
[18:05:16.182]                 old_names <- names(...future.oldEnvVars)
[18:05:16.182]                 envs <- base::Sys.getenv()
[18:05:16.182]                 names <- names(envs)
[18:05:16.182]                 common <- intersect(names, old_names)
[18:05:16.182]                 added <- setdiff(names, old_names)
[18:05:16.182]                 removed <- setdiff(old_names, names)
[18:05:16.182]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:16.182]                   envs[common]]
[18:05:16.182]                 NAMES <- toupper(changed)
[18:05:16.182]                 args <- list()
[18:05:16.182]                 for (kk in seq_along(NAMES)) {
[18:05:16.182]                   name <- changed[[kk]]
[18:05:16.182]                   NAME <- NAMES[[kk]]
[18:05:16.182]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.182]                     next
[18:05:16.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.182]                 }
[18:05:16.182]                 NAMES <- toupper(added)
[18:05:16.182]                 for (kk in seq_along(NAMES)) {
[18:05:16.182]                   name <- added[[kk]]
[18:05:16.182]                   NAME <- NAMES[[kk]]
[18:05:16.182]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.182]                     next
[18:05:16.182]                   args[[name]] <- ""
[18:05:16.182]                 }
[18:05:16.182]                 NAMES <- toupper(removed)
[18:05:16.182]                 for (kk in seq_along(NAMES)) {
[18:05:16.182]                   name <- removed[[kk]]
[18:05:16.182]                   NAME <- NAMES[[kk]]
[18:05:16.182]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.182]                     next
[18:05:16.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.182]                 }
[18:05:16.182]                 if (length(args) > 0) 
[18:05:16.182]                   base::do.call(base::Sys.setenv, args = args)
[18:05:16.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:16.182]             }
[18:05:16.182]             else {
[18:05:16.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:16.182]             }
[18:05:16.182]             {
[18:05:16.182]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:16.182]                   0L) {
[18:05:16.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:16.182]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:16.182]                   base::options(opts)
[18:05:16.182]                 }
[18:05:16.182]                 {
[18:05:16.182]                   {
[18:05:16.182]                     NULL
[18:05:16.182]                     RNGkind("Mersenne-Twister")
[18:05:16.182]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:16.182]                       inherits = FALSE)
[18:05:16.182]                   }
[18:05:16.182]                   options(future.plan = NULL)
[18:05:16.182]                   if (is.na(NA_character_)) 
[18:05:16.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:16.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:16.182]                     .init = FALSE)
[18:05:16.182]                 }
[18:05:16.182]             }
[18:05:16.182]         }
[18:05:16.182]     })
[18:05:16.182]     if (TRUE) {
[18:05:16.182]         base::sink(type = "output", split = FALSE)
[18:05:16.182]         if (TRUE) {
[18:05:16.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:16.182]         }
[18:05:16.182]         else {
[18:05:16.182]             ...future.result["stdout"] <- base::list(NULL)
[18:05:16.182]         }
[18:05:16.182]         base::close(...future.stdout)
[18:05:16.182]         ...future.stdout <- NULL
[18:05:16.182]     }
[18:05:16.182]     ...future.result$conditions <- ...future.conditions
[18:05:16.182]     ...future.result$finished <- base::Sys.time()
[18:05:16.182]     ...future.result
[18:05:16.182] }
[18:05:16.185] plan(): Setting new future strategy stack:
[18:05:16.185] List of future strategies:
[18:05:16.185] 1. sequential:
[18:05:16.185]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.185]    - tweaked: FALSE
[18:05:16.185]    - call: NULL
[18:05:16.189] plan(): nbrOfWorkers() = 1
[18:05:16.191] plan(): Setting new future strategy stack:
[18:05:16.191] List of future strategies:
[18:05:16.191] 1. sequential:
[18:05:16.191]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.191]    - tweaked: FALSE
[18:05:16.191]    - call: future::plan("sequential")
[18:05:16.192] plan(): nbrOfWorkers() = 1
[18:05:16.193] SequentialFuture started (and completed)
[18:05:16.193] - Launch lazy future ... done
[18:05:16.193] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[18:05:16.201] getGlobalsAndPackages() ...
[18:05:16.202] Searching for globals...
[18:05:16.204] - globals found: [2] ‘{’, ‘stop’
[18:05:16.204] Searching for globals ... DONE
[18:05:16.204] Resolving globals: FALSE
[18:05:16.205] 
[18:05:16.205] 
[18:05:16.205] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:16.207] Packages needed by the future expression (n = 0): <none>
[18:05:16.207] Packages needed by future strategies (n = 0): <none>
[18:05:16.208] {
[18:05:16.208]     {
[18:05:16.208]         {
[18:05:16.208]             ...future.startTime <- base::Sys.time()
[18:05:16.208]             {
[18:05:16.208]                 {
[18:05:16.208]                   {
[18:05:16.208]                     base::local({
[18:05:16.208]                       has_future <- base::requireNamespace("future", 
[18:05:16.208]                         quietly = TRUE)
[18:05:16.208]                       if (has_future) {
[18:05:16.208]                         ns <- base::getNamespace("future")
[18:05:16.208]                         version <- ns[[".package"]][["version"]]
[18:05:16.208]                         if (is.null(version)) 
[18:05:16.208]                           version <- utils::packageVersion("future")
[18:05:16.208]                       }
[18:05:16.208]                       else {
[18:05:16.208]                         version <- NULL
[18:05:16.208]                       }
[18:05:16.208]                       if (!has_future || version < "1.8.0") {
[18:05:16.208]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:16.208]                           "", base::R.version$version.string), 
[18:05:16.208]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:16.208]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:16.208]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:16.208]                             "release", "version")], collapse = " "), 
[18:05:16.208]                           hostname = base::Sys.info()[["nodename"]])
[18:05:16.208]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:16.208]                           info)
[18:05:16.208]                         info <- base::paste(info, collapse = "; ")
[18:05:16.208]                         if (!has_future) {
[18:05:16.208]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:16.208]                             info)
[18:05:16.208]                         }
[18:05:16.208]                         else {
[18:05:16.208]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:16.208]                             info, version)
[18:05:16.208]                         }
[18:05:16.208]                         base::stop(msg)
[18:05:16.208]                       }
[18:05:16.208]                     })
[18:05:16.208]                   }
[18:05:16.208]                   ...future.strategy.old <- future::plan("list")
[18:05:16.208]                   options(future.plan = NULL)
[18:05:16.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:16.208]                 }
[18:05:16.208]                 ...future.workdir <- getwd()
[18:05:16.208]             }
[18:05:16.208]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:16.208]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:16.208]         }
[18:05:16.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:16.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:16.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:16.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:16.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:16.208]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:16.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:16.208]             base::names(...future.oldOptions))
[18:05:16.208]     }
[18:05:16.208]     if (FALSE) {
[18:05:16.208]     }
[18:05:16.208]     else {
[18:05:16.208]         if (TRUE) {
[18:05:16.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:16.208]                 open = "w")
[18:05:16.208]         }
[18:05:16.208]         else {
[18:05:16.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:16.208]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:16.208]         }
[18:05:16.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:16.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:16.208]             base::sink(type = "output", split = FALSE)
[18:05:16.208]             base::close(...future.stdout)
[18:05:16.208]         }, add = TRUE)
[18:05:16.208]     }
[18:05:16.208]     ...future.frame <- base::sys.nframe()
[18:05:16.208]     ...future.conditions <- base::list()
[18:05:16.208]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:16.208]     if (FALSE) {
[18:05:16.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:16.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:16.208]     }
[18:05:16.208]     ...future.result <- base::tryCatch({
[18:05:16.208]         base::withCallingHandlers({
[18:05:16.208]             ...future.value <- base::withVisible(base::local({
[18:05:16.208]                 stop("Whoops!")
[18:05:16.208]                 1
[18:05:16.208]             }))
[18:05:16.208]             future::FutureResult(value = ...future.value$value, 
[18:05:16.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.208]                   ...future.rng), globalenv = if (FALSE) 
[18:05:16.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:16.208]                     ...future.globalenv.names))
[18:05:16.208]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:16.208]         }, condition = base::local({
[18:05:16.208]             c <- base::c
[18:05:16.208]             inherits <- base::inherits
[18:05:16.208]             invokeRestart <- base::invokeRestart
[18:05:16.208]             length <- base::length
[18:05:16.208]             list <- base::list
[18:05:16.208]             seq.int <- base::seq.int
[18:05:16.208]             signalCondition <- base::signalCondition
[18:05:16.208]             sys.calls <- base::sys.calls
[18:05:16.208]             `[[` <- base::`[[`
[18:05:16.208]             `+` <- base::`+`
[18:05:16.208]             `<<-` <- base::`<<-`
[18:05:16.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:16.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:16.208]                   3L)]
[18:05:16.208]             }
[18:05:16.208]             function(cond) {
[18:05:16.208]                 is_error <- inherits(cond, "error")
[18:05:16.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:16.208]                   NULL)
[18:05:16.208]                 if (is_error) {
[18:05:16.208]                   sessionInformation <- function() {
[18:05:16.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:16.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:16.208]                       search = base::search(), system = base::Sys.info())
[18:05:16.208]                   }
[18:05:16.208]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:16.208]                     cond$call), session = sessionInformation(), 
[18:05:16.208]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:16.208]                   signalCondition(cond)
[18:05:16.208]                 }
[18:05:16.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:16.208]                 "immediateCondition"))) {
[18:05:16.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:16.208]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:16.208]                   if (TRUE && !signal) {
[18:05:16.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.208]                     {
[18:05:16.208]                       inherits <- base::inherits
[18:05:16.208]                       invokeRestart <- base::invokeRestart
[18:05:16.208]                       is.null <- base::is.null
[18:05:16.208]                       muffled <- FALSE
[18:05:16.208]                       if (inherits(cond, "message")) {
[18:05:16.208]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.208]                         if (muffled) 
[18:05:16.208]                           invokeRestart("muffleMessage")
[18:05:16.208]                       }
[18:05:16.208]                       else if (inherits(cond, "warning")) {
[18:05:16.208]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.208]                         if (muffled) 
[18:05:16.208]                           invokeRestart("muffleWarning")
[18:05:16.208]                       }
[18:05:16.208]                       else if (inherits(cond, "condition")) {
[18:05:16.208]                         if (!is.null(pattern)) {
[18:05:16.208]                           computeRestarts <- base::computeRestarts
[18:05:16.208]                           grepl <- base::grepl
[18:05:16.208]                           restarts <- computeRestarts(cond)
[18:05:16.208]                           for (restart in restarts) {
[18:05:16.208]                             name <- restart$name
[18:05:16.208]                             if (is.null(name)) 
[18:05:16.208]                               next
[18:05:16.208]                             if (!grepl(pattern, name)) 
[18:05:16.208]                               next
[18:05:16.208]                             invokeRestart(restart)
[18:05:16.208]                             muffled <- TRUE
[18:05:16.208]                             break
[18:05:16.208]                           }
[18:05:16.208]                         }
[18:05:16.208]                       }
[18:05:16.208]                       invisible(muffled)
[18:05:16.208]                     }
[18:05:16.208]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.208]                   }
[18:05:16.208]                 }
[18:05:16.208]                 else {
[18:05:16.208]                   if (TRUE) {
[18:05:16.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.208]                     {
[18:05:16.208]                       inherits <- base::inherits
[18:05:16.208]                       invokeRestart <- base::invokeRestart
[18:05:16.208]                       is.null <- base::is.null
[18:05:16.208]                       muffled <- FALSE
[18:05:16.208]                       if (inherits(cond, "message")) {
[18:05:16.208]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.208]                         if (muffled) 
[18:05:16.208]                           invokeRestart("muffleMessage")
[18:05:16.208]                       }
[18:05:16.208]                       else if (inherits(cond, "warning")) {
[18:05:16.208]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.208]                         if (muffled) 
[18:05:16.208]                           invokeRestart("muffleWarning")
[18:05:16.208]                       }
[18:05:16.208]                       else if (inherits(cond, "condition")) {
[18:05:16.208]                         if (!is.null(pattern)) {
[18:05:16.208]                           computeRestarts <- base::computeRestarts
[18:05:16.208]                           grepl <- base::grepl
[18:05:16.208]                           restarts <- computeRestarts(cond)
[18:05:16.208]                           for (restart in restarts) {
[18:05:16.208]                             name <- restart$name
[18:05:16.208]                             if (is.null(name)) 
[18:05:16.208]                               next
[18:05:16.208]                             if (!grepl(pattern, name)) 
[18:05:16.208]                               next
[18:05:16.208]                             invokeRestart(restart)
[18:05:16.208]                             muffled <- TRUE
[18:05:16.208]                             break
[18:05:16.208]                           }
[18:05:16.208]                         }
[18:05:16.208]                       }
[18:05:16.208]                       invisible(muffled)
[18:05:16.208]                     }
[18:05:16.208]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.208]                   }
[18:05:16.208]                 }
[18:05:16.208]             }
[18:05:16.208]         }))
[18:05:16.208]     }, error = function(ex) {
[18:05:16.208]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:16.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.208]                 ...future.rng), started = ...future.startTime, 
[18:05:16.208]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:16.208]             version = "1.8"), class = "FutureResult")
[18:05:16.208]     }, finally = {
[18:05:16.208]         if (!identical(...future.workdir, getwd())) 
[18:05:16.208]             setwd(...future.workdir)
[18:05:16.208]         {
[18:05:16.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:16.208]                 ...future.oldOptions$nwarnings <- NULL
[18:05:16.208]             }
[18:05:16.208]             base::options(...future.oldOptions)
[18:05:16.208]             if (.Platform$OS.type == "windows") {
[18:05:16.208]                 old_names <- names(...future.oldEnvVars)
[18:05:16.208]                 envs <- base::Sys.getenv()
[18:05:16.208]                 names <- names(envs)
[18:05:16.208]                 common <- intersect(names, old_names)
[18:05:16.208]                 added <- setdiff(names, old_names)
[18:05:16.208]                 removed <- setdiff(old_names, names)
[18:05:16.208]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:16.208]                   envs[common]]
[18:05:16.208]                 NAMES <- toupper(changed)
[18:05:16.208]                 args <- list()
[18:05:16.208]                 for (kk in seq_along(NAMES)) {
[18:05:16.208]                   name <- changed[[kk]]
[18:05:16.208]                   NAME <- NAMES[[kk]]
[18:05:16.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.208]                     next
[18:05:16.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.208]                 }
[18:05:16.208]                 NAMES <- toupper(added)
[18:05:16.208]                 for (kk in seq_along(NAMES)) {
[18:05:16.208]                   name <- added[[kk]]
[18:05:16.208]                   NAME <- NAMES[[kk]]
[18:05:16.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.208]                     next
[18:05:16.208]                   args[[name]] <- ""
[18:05:16.208]                 }
[18:05:16.208]                 NAMES <- toupper(removed)
[18:05:16.208]                 for (kk in seq_along(NAMES)) {
[18:05:16.208]                   name <- removed[[kk]]
[18:05:16.208]                   NAME <- NAMES[[kk]]
[18:05:16.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.208]                     next
[18:05:16.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.208]                 }
[18:05:16.208]                 if (length(args) > 0) 
[18:05:16.208]                   base::do.call(base::Sys.setenv, args = args)
[18:05:16.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:16.208]             }
[18:05:16.208]             else {
[18:05:16.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:16.208]             }
[18:05:16.208]             {
[18:05:16.208]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:16.208]                   0L) {
[18:05:16.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:16.208]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:16.208]                   base::options(opts)
[18:05:16.208]                 }
[18:05:16.208]                 {
[18:05:16.208]                   {
[18:05:16.208]                     NULL
[18:05:16.208]                     RNGkind("Mersenne-Twister")
[18:05:16.208]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:16.208]                       inherits = FALSE)
[18:05:16.208]                   }
[18:05:16.208]                   options(future.plan = NULL)
[18:05:16.208]                   if (is.na(NA_character_)) 
[18:05:16.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:16.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:16.208]                     .init = FALSE)
[18:05:16.208]                 }
[18:05:16.208]             }
[18:05:16.208]         }
[18:05:16.208]     })
[18:05:16.208]     if (TRUE) {
[18:05:16.208]         base::sink(type = "output", split = FALSE)
[18:05:16.208]         if (TRUE) {
[18:05:16.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:16.208]         }
[18:05:16.208]         else {
[18:05:16.208]             ...future.result["stdout"] <- base::list(NULL)
[18:05:16.208]         }
[18:05:16.208]         base::close(...future.stdout)
[18:05:16.208]         ...future.stdout <- NULL
[18:05:16.208]     }
[18:05:16.208]     ...future.result$conditions <- ...future.conditions
[18:05:16.208]     ...future.result$finished <- base::Sys.time()
[18:05:16.208]     ...future.result
[18:05:16.208] }
[18:05:16.211] plan(): Setting new future strategy stack:
[18:05:16.212] List of future strategies:
[18:05:16.212] 1. sequential:
[18:05:16.212]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.212]    - tweaked: FALSE
[18:05:16.212]    - call: NULL
[18:05:16.213] plan(): nbrOfWorkers() = 1
[18:05:16.215] plan(): Setting new future strategy stack:
[18:05:16.215] List of future strategies:
[18:05:16.215] 1. sequential:
[18:05:16.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.215]    - tweaked: FALSE
[18:05:16.215]    - call: future::plan("sequential")
[18:05:16.216] plan(): nbrOfWorkers() = 1
[18:05:16.217] SequentialFuture started (and completed)
[18:05:16.217] signalConditions() ...
[18:05:16.217]  - include = ‘immediateCondition’
[18:05:16.217]  - exclude = 
[18:05:16.217]  - resignal = FALSE
[18:05:16.218]  - Number of conditions: 1
[18:05:16.218] signalConditions() ... done
[18:05:16.218] signalConditions() ...
[18:05:16.218]  - include = ‘immediateCondition’
[18:05:16.219]  - exclude = 
[18:05:16.219]  - resignal = FALSE
[18:05:16.219]  - Number of conditions: 1
[18:05:16.220] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[18:05:16.221] signalConditions() ...
[18:05:16.221]  - include = ‘immediateCondition’
[18:05:16.221]  - exclude = 
[18:05:16.222]  - resignal = FALSE
[18:05:16.222]  - Number of conditions: 1
[18:05:16.222] signalConditions() ... done
[18:05:16.222] Future state: ‘finished’
[18:05:16.223] signalConditions() ...
[18:05:16.223]  - include = ‘condition’
[18:05:16.223]  - exclude = ‘immediateCondition’
[18:05:16.223]  - resignal = TRUE
[18:05:16.223]  - Number of conditions: 1
[18:05:16.223]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:16.224] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[18:05:16.225] signalConditions() ...
[18:05:16.225]  - include = ‘immediateCondition’
[18:05:16.225]  - exclude = 
[18:05:16.225]  - resignal = FALSE
[18:05:16.225]  - Number of conditions: 1
[18:05:16.226] signalConditions() ... done
[18:05:16.226] Future state: ‘finished’
[18:05:16.226] signalConditions() ...
[18:05:16.226]  - include = ‘condition’
[18:05:16.226]  - exclude = ‘immediateCondition’
[18:05:16.227]  - resignal = TRUE
[18:05:16.227]  - Number of conditions: 1
[18:05:16.227]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:16.227] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[18:05:16.233] getGlobalsAndPackages() ...
[18:05:16.234] Searching for globals...
[18:05:16.236] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[18:05:16.237] Searching for globals ... DONE
[18:05:16.237] Resolving globals: FALSE
[18:05:16.238] 
[18:05:16.238] 
[18:05:16.238] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:16.239] Packages needed by the future expression (n = 0): <none>
[18:05:16.240] Packages needed by future strategies (n = 0): <none>
[18:05:16.241] {
[18:05:16.241]     {
[18:05:16.241]         {
[18:05:16.241]             ...future.startTime <- base::Sys.time()
[18:05:16.241]             {
[18:05:16.241]                 {
[18:05:16.241]                   {
[18:05:16.241]                     base::local({
[18:05:16.241]                       has_future <- base::requireNamespace("future", 
[18:05:16.241]                         quietly = TRUE)
[18:05:16.241]                       if (has_future) {
[18:05:16.241]                         ns <- base::getNamespace("future")
[18:05:16.241]                         version <- ns[[".package"]][["version"]]
[18:05:16.241]                         if (is.null(version)) 
[18:05:16.241]                           version <- utils::packageVersion("future")
[18:05:16.241]                       }
[18:05:16.241]                       else {
[18:05:16.241]                         version <- NULL
[18:05:16.241]                       }
[18:05:16.241]                       if (!has_future || version < "1.8.0") {
[18:05:16.241]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:16.241]                           "", base::R.version$version.string), 
[18:05:16.241]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:16.241]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:16.241]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:16.241]                             "release", "version")], collapse = " "), 
[18:05:16.241]                           hostname = base::Sys.info()[["nodename"]])
[18:05:16.241]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:16.241]                           info)
[18:05:16.241]                         info <- base::paste(info, collapse = "; ")
[18:05:16.241]                         if (!has_future) {
[18:05:16.241]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:16.241]                             info)
[18:05:16.241]                         }
[18:05:16.241]                         else {
[18:05:16.241]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:16.241]                             info, version)
[18:05:16.241]                         }
[18:05:16.241]                         base::stop(msg)
[18:05:16.241]                       }
[18:05:16.241]                     })
[18:05:16.241]                   }
[18:05:16.241]                   ...future.strategy.old <- future::plan("list")
[18:05:16.241]                   options(future.plan = NULL)
[18:05:16.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:16.241]                 }
[18:05:16.241]                 ...future.workdir <- getwd()
[18:05:16.241]             }
[18:05:16.241]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:16.241]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:16.241]         }
[18:05:16.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:16.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:16.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:16.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:16.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:16.241]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:16.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:16.241]             base::names(...future.oldOptions))
[18:05:16.241]     }
[18:05:16.241]     if (FALSE) {
[18:05:16.241]     }
[18:05:16.241]     else {
[18:05:16.241]         if (TRUE) {
[18:05:16.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:16.241]                 open = "w")
[18:05:16.241]         }
[18:05:16.241]         else {
[18:05:16.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:16.241]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:16.241]         }
[18:05:16.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:16.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:16.241]             base::sink(type = "output", split = FALSE)
[18:05:16.241]             base::close(...future.stdout)
[18:05:16.241]         }, add = TRUE)
[18:05:16.241]     }
[18:05:16.241]     ...future.frame <- base::sys.nframe()
[18:05:16.241]     ...future.conditions <- base::list()
[18:05:16.241]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:16.241]     if (FALSE) {
[18:05:16.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:16.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:16.241]     }
[18:05:16.241]     ...future.result <- base::tryCatch({
[18:05:16.241]         base::withCallingHandlers({
[18:05:16.241]             ...future.value <- base::withVisible(base::local({
[18:05:16.241]                 stop(structure(list(message = "boom"), class = c("MyError", 
[18:05:16.241]                   "error", "condition")))
[18:05:16.241]             }))
[18:05:16.241]             future::FutureResult(value = ...future.value$value, 
[18:05:16.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.241]                   ...future.rng), globalenv = if (FALSE) 
[18:05:16.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:16.241]                     ...future.globalenv.names))
[18:05:16.241]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:16.241]         }, condition = base::local({
[18:05:16.241]             c <- base::c
[18:05:16.241]             inherits <- base::inherits
[18:05:16.241]             invokeRestart <- base::invokeRestart
[18:05:16.241]             length <- base::length
[18:05:16.241]             list <- base::list
[18:05:16.241]             seq.int <- base::seq.int
[18:05:16.241]             signalCondition <- base::signalCondition
[18:05:16.241]             sys.calls <- base::sys.calls
[18:05:16.241]             `[[` <- base::`[[`
[18:05:16.241]             `+` <- base::`+`
[18:05:16.241]             `<<-` <- base::`<<-`
[18:05:16.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:16.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:16.241]                   3L)]
[18:05:16.241]             }
[18:05:16.241]             function(cond) {
[18:05:16.241]                 is_error <- inherits(cond, "error")
[18:05:16.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:16.241]                   NULL)
[18:05:16.241]                 if (is_error) {
[18:05:16.241]                   sessionInformation <- function() {
[18:05:16.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:16.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:16.241]                       search = base::search(), system = base::Sys.info())
[18:05:16.241]                   }
[18:05:16.241]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:16.241]                     cond$call), session = sessionInformation(), 
[18:05:16.241]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:16.241]                   signalCondition(cond)
[18:05:16.241]                 }
[18:05:16.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:16.241]                 "immediateCondition"))) {
[18:05:16.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:16.241]                   ...future.conditions[[length(...future.conditions) + 
[18:05:16.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:16.241]                   if (TRUE && !signal) {
[18:05:16.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.241]                     {
[18:05:16.241]                       inherits <- base::inherits
[18:05:16.241]                       invokeRestart <- base::invokeRestart
[18:05:16.241]                       is.null <- base::is.null
[18:05:16.241]                       muffled <- FALSE
[18:05:16.241]                       if (inherits(cond, "message")) {
[18:05:16.241]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.241]                         if (muffled) 
[18:05:16.241]                           invokeRestart("muffleMessage")
[18:05:16.241]                       }
[18:05:16.241]                       else if (inherits(cond, "warning")) {
[18:05:16.241]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.241]                         if (muffled) 
[18:05:16.241]                           invokeRestart("muffleWarning")
[18:05:16.241]                       }
[18:05:16.241]                       else if (inherits(cond, "condition")) {
[18:05:16.241]                         if (!is.null(pattern)) {
[18:05:16.241]                           computeRestarts <- base::computeRestarts
[18:05:16.241]                           grepl <- base::grepl
[18:05:16.241]                           restarts <- computeRestarts(cond)
[18:05:16.241]                           for (restart in restarts) {
[18:05:16.241]                             name <- restart$name
[18:05:16.241]                             if (is.null(name)) 
[18:05:16.241]                               next
[18:05:16.241]                             if (!grepl(pattern, name)) 
[18:05:16.241]                               next
[18:05:16.241]                             invokeRestart(restart)
[18:05:16.241]                             muffled <- TRUE
[18:05:16.241]                             break
[18:05:16.241]                           }
[18:05:16.241]                         }
[18:05:16.241]                       }
[18:05:16.241]                       invisible(muffled)
[18:05:16.241]                     }
[18:05:16.241]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.241]                   }
[18:05:16.241]                 }
[18:05:16.241]                 else {
[18:05:16.241]                   if (TRUE) {
[18:05:16.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:16.241]                     {
[18:05:16.241]                       inherits <- base::inherits
[18:05:16.241]                       invokeRestart <- base::invokeRestart
[18:05:16.241]                       is.null <- base::is.null
[18:05:16.241]                       muffled <- FALSE
[18:05:16.241]                       if (inherits(cond, "message")) {
[18:05:16.241]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:16.241]                         if (muffled) 
[18:05:16.241]                           invokeRestart("muffleMessage")
[18:05:16.241]                       }
[18:05:16.241]                       else if (inherits(cond, "warning")) {
[18:05:16.241]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:16.241]                         if (muffled) 
[18:05:16.241]                           invokeRestart("muffleWarning")
[18:05:16.241]                       }
[18:05:16.241]                       else if (inherits(cond, "condition")) {
[18:05:16.241]                         if (!is.null(pattern)) {
[18:05:16.241]                           computeRestarts <- base::computeRestarts
[18:05:16.241]                           grepl <- base::grepl
[18:05:16.241]                           restarts <- computeRestarts(cond)
[18:05:16.241]                           for (restart in restarts) {
[18:05:16.241]                             name <- restart$name
[18:05:16.241]                             if (is.null(name)) 
[18:05:16.241]                               next
[18:05:16.241]                             if (!grepl(pattern, name)) 
[18:05:16.241]                               next
[18:05:16.241]                             invokeRestart(restart)
[18:05:16.241]                             muffled <- TRUE
[18:05:16.241]                             break
[18:05:16.241]                           }
[18:05:16.241]                         }
[18:05:16.241]                       }
[18:05:16.241]                       invisible(muffled)
[18:05:16.241]                     }
[18:05:16.241]                     muffleCondition(cond, pattern = "^muffle")
[18:05:16.241]                   }
[18:05:16.241]                 }
[18:05:16.241]             }
[18:05:16.241]         }))
[18:05:16.241]     }, error = function(ex) {
[18:05:16.241]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:16.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:16.241]                 ...future.rng), started = ...future.startTime, 
[18:05:16.241]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:16.241]             version = "1.8"), class = "FutureResult")
[18:05:16.241]     }, finally = {
[18:05:16.241]         if (!identical(...future.workdir, getwd())) 
[18:05:16.241]             setwd(...future.workdir)
[18:05:16.241]         {
[18:05:16.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:16.241]                 ...future.oldOptions$nwarnings <- NULL
[18:05:16.241]             }
[18:05:16.241]             base::options(...future.oldOptions)
[18:05:16.241]             if (.Platform$OS.type == "windows") {
[18:05:16.241]                 old_names <- names(...future.oldEnvVars)
[18:05:16.241]                 envs <- base::Sys.getenv()
[18:05:16.241]                 names <- names(envs)
[18:05:16.241]                 common <- intersect(names, old_names)
[18:05:16.241]                 added <- setdiff(names, old_names)
[18:05:16.241]                 removed <- setdiff(old_names, names)
[18:05:16.241]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:16.241]                   envs[common]]
[18:05:16.241]                 NAMES <- toupper(changed)
[18:05:16.241]                 args <- list()
[18:05:16.241]                 for (kk in seq_along(NAMES)) {
[18:05:16.241]                   name <- changed[[kk]]
[18:05:16.241]                   NAME <- NAMES[[kk]]
[18:05:16.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.241]                     next
[18:05:16.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.241]                 }
[18:05:16.241]                 NAMES <- toupper(added)
[18:05:16.241]                 for (kk in seq_along(NAMES)) {
[18:05:16.241]                   name <- added[[kk]]
[18:05:16.241]                   NAME <- NAMES[[kk]]
[18:05:16.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.241]                     next
[18:05:16.241]                   args[[name]] <- ""
[18:05:16.241]                 }
[18:05:16.241]                 NAMES <- toupper(removed)
[18:05:16.241]                 for (kk in seq_along(NAMES)) {
[18:05:16.241]                   name <- removed[[kk]]
[18:05:16.241]                   NAME <- NAMES[[kk]]
[18:05:16.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:16.241]                     next
[18:05:16.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:16.241]                 }
[18:05:16.241]                 if (length(args) > 0) 
[18:05:16.241]                   base::do.call(base::Sys.setenv, args = args)
[18:05:16.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:16.241]             }
[18:05:16.241]             else {
[18:05:16.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:16.241]             }
[18:05:16.241]             {
[18:05:16.241]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:16.241]                   0L) {
[18:05:16.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:16.241]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:16.241]                   base::options(opts)
[18:05:16.241]                 }
[18:05:16.241]                 {
[18:05:16.241]                   {
[18:05:16.241]                     NULL
[18:05:16.241]                     RNGkind("Mersenne-Twister")
[18:05:16.241]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:16.241]                       inherits = FALSE)
[18:05:16.241]                   }
[18:05:16.241]                   options(future.plan = NULL)
[18:05:16.241]                   if (is.na(NA_character_)) 
[18:05:16.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:16.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:16.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:16.241]                     .init = FALSE)
[18:05:16.241]                 }
[18:05:16.241]             }
[18:05:16.241]         }
[18:05:16.241]     })
[18:05:16.241]     if (TRUE) {
[18:05:16.241]         base::sink(type = "output", split = FALSE)
[18:05:16.241]         if (TRUE) {
[18:05:16.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:16.241]         }
[18:05:16.241]         else {
[18:05:16.241]             ...future.result["stdout"] <- base::list(NULL)
[18:05:16.241]         }
[18:05:16.241]         base::close(...future.stdout)
[18:05:16.241]         ...future.stdout <- NULL
[18:05:16.241]     }
[18:05:16.241]     ...future.result$conditions <- ...future.conditions
[18:05:16.241]     ...future.result$finished <- base::Sys.time()
[18:05:16.241]     ...future.result
[18:05:16.241] }
[18:05:16.244] plan(): Setting new future strategy stack:
[18:05:16.245] List of future strategies:
[18:05:16.245] 1. sequential:
[18:05:16.245]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.245]    - tweaked: FALSE
[18:05:16.245]    - call: NULL
[18:05:16.246] plan(): nbrOfWorkers() = 1
[18:05:16.248] plan(): Setting new future strategy stack:
[18:05:16.248] List of future strategies:
[18:05:16.248] 1. sequential:
[18:05:16.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:16.248]    - tweaked: FALSE
[18:05:16.248]    - call: future::plan("sequential")
[18:05:16.249] plan(): nbrOfWorkers() = 1
[18:05:16.249] SequentialFuture started (and completed)
[18:05:16.250] signalConditions() ...
[18:05:16.250]  - include = ‘immediateCondition’
[18:05:16.250]  - exclude = 
[18:05:16.251]  - resignal = FALSE
[18:05:16.251]  - Number of conditions: 1
[18:05:16.251] signalConditions() ... done
[18:05:16.252] signalConditions() ...
[18:05:16.252]  - include = ‘immediateCondition’
[18:05:16.252]  - exclude = 
[18:05:16.252]  - resignal = FALSE
[18:05:16.252]  - Number of conditions: 1
[18:05:16.253] signalConditions() ... done
<MyError: boom>
[18:05:16.253] signalConditions() ...
[18:05:16.253]  - include = ‘immediateCondition’
[18:05:16.253]  - exclude = 
[18:05:16.254]  - resignal = FALSE
[18:05:16.254]  - Number of conditions: 1
[18:05:16.254] signalConditions() ... done
[18:05:16.254] Future state: ‘finished’
[18:05:16.254] signalConditions() ...
[18:05:16.255]  - include = ‘condition’
[18:05:16.255]  - exclude = ‘immediateCondition’
[18:05:16.255]  - resignal = TRUE
[18:05:16.255]  - Number of conditions: 1
[18:05:16.255]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[18:05:16.256] signalConditions() ... done
Testing with 1 cores ... DONE
Testing with 2 cores ...
[18:05:16.265] getGlobalsAndPackages() ...
[18:05:16.265] 
[18:05:16.266] - globals: [0] <none>
[18:05:16.266] getGlobalsAndPackages() ... DONE
[18:05:16.267] [local output] makeClusterPSOCK() ...
[18:05:16.320] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:05:16.322] [local output] Base port: 11116
[18:05:16.323] [local output] Getting setup options for 2 cluster nodes ...
[18:05:16.323] [local output]  - Node 1 of 2 ...
[18:05:16.324] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:16.325] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa04c1d61c4.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa04c1d61c4.pid")'’
[18:05:16.600] - Possible to infer worker's PID: TRUE
[18:05:16.601] [local output] Rscript port: 11116

[18:05:16.602] [local output]  - Node 2 of 2 ...
[18:05:16.602] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:16.604] [local output] Rscript port: 11116

[18:05:16.604] [local output] Getting setup options for 2 cluster nodes ... done
[18:05:16.604] [local output]  - Parallel setup requested for some PSOCK nodes
[18:05:16.605] [local output] Setting up PSOCK nodes in parallel
[18:05:16.606] List of 36
[18:05:16.606]  $ worker          : chr "localhost"
[18:05:16.606]   ..- attr(*, "localhost")= logi TRUE
[18:05:16.606]  $ master          : chr "localhost"
[18:05:16.606]  $ port            : int 11116
[18:05:16.606]  $ connectTimeout  : num 120
[18:05:16.606]  $ timeout         : num 2592000
[18:05:16.606]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:05:16.606]  $ homogeneous     : logi TRUE
[18:05:16.606]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:05:16.606]  $ rscript_envs    : NULL
[18:05:16.606]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:16.606]  $ rscript_startup : NULL
[18:05:16.606]  $ rscript_sh      : chr "sh"
[18:05:16.606]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:16.606]  $ methods         : logi TRUE
[18:05:16.606]  $ socketOptions   : chr "no-delay"
[18:05:16.606]  $ useXDR          : logi FALSE
[18:05:16.606]  $ outfile         : chr "/dev/null"
[18:05:16.606]  $ renice          : int NA
[18:05:16.606]  $ rshcmd          : NULL
[18:05:16.606]  $ user            : chr(0) 
[18:05:16.606]  $ revtunnel       : logi FALSE
[18:05:16.606]  $ rshlogfile      : NULL
[18:05:16.606]  $ rshopts         : chr(0) 
[18:05:16.606]  $ rank            : int 1
[18:05:16.606]  $ manual          : logi FALSE
[18:05:16.606]  $ dryrun          : logi FALSE
[18:05:16.606]  $ quiet           : logi FALSE
[18:05:16.606]  $ setup_strategy  : chr "parallel"
[18:05:16.606]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:16.606]  $ pidfile         : chr "/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa04c1d61c4.pid"
[18:05:16.606]  $ rshcmd_label    : NULL
[18:05:16.606]  $ rsh_call        : NULL
[18:05:16.606]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:16.606]  $ localMachine    : logi TRUE
[18:05:16.606]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:05:16.606]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:05:16.606]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:05:16.606]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:05:16.606]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:05:16.606]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:05:16.606]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:05:16.606]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:05:16.606]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:05:16.606]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:05:16.606]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:05:16.606]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:05:16.606]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:05:16.606]  $ arguments       :List of 28
[18:05:16.606]   ..$ worker          : chr "localhost"
[18:05:16.606]   ..$ master          : NULL
[18:05:16.606]   ..$ port            : int 11116
[18:05:16.606]   ..$ connectTimeout  : num 120
[18:05:16.606]   ..$ timeout         : num 2592000
[18:05:16.606]   ..$ rscript         : NULL
[18:05:16.606]   ..$ homogeneous     : NULL
[18:05:16.606]   ..$ rscript_args    : NULL
[18:05:16.606]   ..$ rscript_envs    : NULL
[18:05:16.606]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:16.606]   ..$ rscript_startup : NULL
[18:05:16.606]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:05:16.606]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:16.606]   ..$ methods         : logi TRUE
[18:05:16.606]   ..$ socketOptions   : chr "no-delay"
[18:05:16.606]   ..$ useXDR          : logi FALSE
[18:05:16.606]   ..$ outfile         : chr "/dev/null"
[18:05:16.606]   ..$ renice          : int NA
[18:05:16.606]   ..$ rshcmd          : NULL
[18:05:16.606]   ..$ user            : NULL
[18:05:16.606]   ..$ revtunnel       : logi NA
[18:05:16.606]   ..$ rshlogfile      : NULL
[18:05:16.606]   ..$ rshopts         : NULL
[18:05:16.606]   ..$ rank            : int 1
[18:05:16.606]   ..$ manual          : logi FALSE
[18:05:16.606]   ..$ dryrun          : logi FALSE
[18:05:16.606]   ..$ quiet           : logi FALSE
[18:05:16.606]   ..$ setup_strategy  : chr "parallel"
[18:05:16.606]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:05:16.644] [local output] System call to launch all workers:
[18:05:16.644] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa04c1d61c4.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11116 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:05:16.644] [local output] Starting PSOCK main server
[18:05:16.652] [local output] Workers launched
[18:05:16.652] [local output] Waiting for workers to connect back
[18:05:16.653]  - [local output] 0 workers out of 2 ready
[18:05:17.069]  - [local output] 0 workers out of 2 ready
[18:05:17.070]  - [local output] 1 workers out of 2 ready
[18:05:17.118]  - [local output] 1 workers out of 2 ready
[18:05:17.119]  - [local output] 2 workers out of 2 ready
[18:05:17.119] [local output] Launching of workers completed
[18:05:17.119] [local output] Collecting session information from workers
[18:05:17.121] [local output]  - Worker #1 of 2
[18:05:17.122] [local output]  - Worker #2 of 2
[18:05:17.123] [local output] makeClusterPSOCK() ... done
[18:05:17.144] Packages needed by the future expression (n = 0): <none>
[18:05:17.144] Packages needed by future strategies (n = 0): <none>
[18:05:17.145] {
[18:05:17.145]     {
[18:05:17.145]         {
[18:05:17.145]             ...future.startTime <- base::Sys.time()
[18:05:17.145]             {
[18:05:17.145]                 {
[18:05:17.145]                   {
[18:05:17.145]                     {
[18:05:17.145]                       base::local({
[18:05:17.145]                         has_future <- base::requireNamespace("future", 
[18:05:17.145]                           quietly = TRUE)
[18:05:17.145]                         if (has_future) {
[18:05:17.145]                           ns <- base::getNamespace("future")
[18:05:17.145]                           version <- ns[[".package"]][["version"]]
[18:05:17.145]                           if (is.null(version)) 
[18:05:17.145]                             version <- utils::packageVersion("future")
[18:05:17.145]                         }
[18:05:17.145]                         else {
[18:05:17.145]                           version <- NULL
[18:05:17.145]                         }
[18:05:17.145]                         if (!has_future || version < "1.8.0") {
[18:05:17.145]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.145]                             "", base::R.version$version.string), 
[18:05:17.145]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:17.145]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.145]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.145]                               "release", "version")], collapse = " "), 
[18:05:17.145]                             hostname = base::Sys.info()[["nodename"]])
[18:05:17.145]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.145]                             info)
[18:05:17.145]                           info <- base::paste(info, collapse = "; ")
[18:05:17.145]                           if (!has_future) {
[18:05:17.145]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.145]                               info)
[18:05:17.145]                           }
[18:05:17.145]                           else {
[18:05:17.145]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.145]                               info, version)
[18:05:17.145]                           }
[18:05:17.145]                           base::stop(msg)
[18:05:17.145]                         }
[18:05:17.145]                       })
[18:05:17.145]                     }
[18:05:17.145]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:17.145]                     base::options(mc.cores = 1L)
[18:05:17.145]                   }
[18:05:17.145]                   ...future.strategy.old <- future::plan("list")
[18:05:17.145]                   options(future.plan = NULL)
[18:05:17.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.145]                 }
[18:05:17.145]                 ...future.workdir <- getwd()
[18:05:17.145]             }
[18:05:17.145]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.145]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.145]         }
[18:05:17.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:17.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.145]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.145]             base::names(...future.oldOptions))
[18:05:17.145]     }
[18:05:17.145]     if (FALSE) {
[18:05:17.145]     }
[18:05:17.145]     else {
[18:05:17.145]         if (TRUE) {
[18:05:17.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.145]                 open = "w")
[18:05:17.145]         }
[18:05:17.145]         else {
[18:05:17.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.145]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.145]         }
[18:05:17.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.145]             base::sink(type = "output", split = FALSE)
[18:05:17.145]             base::close(...future.stdout)
[18:05:17.145]         }, add = TRUE)
[18:05:17.145]     }
[18:05:17.145]     ...future.frame <- base::sys.nframe()
[18:05:17.145]     ...future.conditions <- base::list()
[18:05:17.145]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.145]     if (FALSE) {
[18:05:17.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.145]     }
[18:05:17.145]     ...future.result <- base::tryCatch({
[18:05:17.145]         base::withCallingHandlers({
[18:05:17.145]             ...future.value <- base::withVisible(base::local({
[18:05:17.145]                 ...future.makeSendCondition <- base::local({
[18:05:17.145]                   sendCondition <- NULL
[18:05:17.145]                   function(frame = 1L) {
[18:05:17.145]                     if (is.function(sendCondition)) 
[18:05:17.145]                       return(sendCondition)
[18:05:17.145]                     ns <- getNamespace("parallel")
[18:05:17.145]                     if (exists("sendData", mode = "function", 
[18:05:17.145]                       envir = ns)) {
[18:05:17.145]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:17.145]                         envir = ns)
[18:05:17.145]                       envir <- sys.frame(frame)
[18:05:17.145]                       master <- NULL
[18:05:17.145]                       while (!identical(envir, .GlobalEnv) && 
[18:05:17.145]                         !identical(envir, emptyenv())) {
[18:05:17.145]                         if (exists("master", mode = "list", envir = envir, 
[18:05:17.145]                           inherits = FALSE)) {
[18:05:17.145]                           master <- get("master", mode = "list", 
[18:05:17.145]                             envir = envir, inherits = FALSE)
[18:05:17.145]                           if (inherits(master, c("SOCKnode", 
[18:05:17.145]                             "SOCK0node"))) {
[18:05:17.145]                             sendCondition <<- function(cond) {
[18:05:17.145]                               data <- list(type = "VALUE", value = cond, 
[18:05:17.145]                                 success = TRUE)
[18:05:17.145]                               parallel_sendData(master, data)
[18:05:17.145]                             }
[18:05:17.145]                             return(sendCondition)
[18:05:17.145]                           }
[18:05:17.145]                         }
[18:05:17.145]                         frame <- frame + 1L
[18:05:17.145]                         envir <- sys.frame(frame)
[18:05:17.145]                       }
[18:05:17.145]                     }
[18:05:17.145]                     sendCondition <<- function(cond) NULL
[18:05:17.145]                   }
[18:05:17.145]                 })
[18:05:17.145]                 withCallingHandlers({
[18:05:17.145]                   {
[18:05:17.145]                     42L
[18:05:17.145]                   }
[18:05:17.145]                 }, immediateCondition = function(cond) {
[18:05:17.145]                   sendCondition <- ...future.makeSendCondition()
[18:05:17.145]                   sendCondition(cond)
[18:05:17.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.145]                   {
[18:05:17.145]                     inherits <- base::inherits
[18:05:17.145]                     invokeRestart <- base::invokeRestart
[18:05:17.145]                     is.null <- base::is.null
[18:05:17.145]                     muffled <- FALSE
[18:05:17.145]                     if (inherits(cond, "message")) {
[18:05:17.145]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:17.145]                       if (muffled) 
[18:05:17.145]                         invokeRestart("muffleMessage")
[18:05:17.145]                     }
[18:05:17.145]                     else if (inherits(cond, "warning")) {
[18:05:17.145]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:17.145]                       if (muffled) 
[18:05:17.145]                         invokeRestart("muffleWarning")
[18:05:17.145]                     }
[18:05:17.145]                     else if (inherits(cond, "condition")) {
[18:05:17.145]                       if (!is.null(pattern)) {
[18:05:17.145]                         computeRestarts <- base::computeRestarts
[18:05:17.145]                         grepl <- base::grepl
[18:05:17.145]                         restarts <- computeRestarts(cond)
[18:05:17.145]                         for (restart in restarts) {
[18:05:17.145]                           name <- restart$name
[18:05:17.145]                           if (is.null(name)) 
[18:05:17.145]                             next
[18:05:17.145]                           if (!grepl(pattern, name)) 
[18:05:17.145]                             next
[18:05:17.145]                           invokeRestart(restart)
[18:05:17.145]                           muffled <- TRUE
[18:05:17.145]                           break
[18:05:17.145]                         }
[18:05:17.145]                       }
[18:05:17.145]                     }
[18:05:17.145]                     invisible(muffled)
[18:05:17.145]                   }
[18:05:17.145]                   muffleCondition(cond)
[18:05:17.145]                 })
[18:05:17.145]             }))
[18:05:17.145]             future::FutureResult(value = ...future.value$value, 
[18:05:17.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.145]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.145]                     ...future.globalenv.names))
[18:05:17.145]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.145]         }, condition = base::local({
[18:05:17.145]             c <- base::c
[18:05:17.145]             inherits <- base::inherits
[18:05:17.145]             invokeRestart <- base::invokeRestart
[18:05:17.145]             length <- base::length
[18:05:17.145]             list <- base::list
[18:05:17.145]             seq.int <- base::seq.int
[18:05:17.145]             signalCondition <- base::signalCondition
[18:05:17.145]             sys.calls <- base::sys.calls
[18:05:17.145]             `[[` <- base::`[[`
[18:05:17.145]             `+` <- base::`+`
[18:05:17.145]             `<<-` <- base::`<<-`
[18:05:17.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.145]                   3L)]
[18:05:17.145]             }
[18:05:17.145]             function(cond) {
[18:05:17.145]                 is_error <- inherits(cond, "error")
[18:05:17.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.145]                   NULL)
[18:05:17.145]                 if (is_error) {
[18:05:17.145]                   sessionInformation <- function() {
[18:05:17.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.145]                       search = base::search(), system = base::Sys.info())
[18:05:17.145]                   }
[18:05:17.145]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.145]                     cond$call), session = sessionInformation(), 
[18:05:17.145]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.145]                   signalCondition(cond)
[18:05:17.145]                 }
[18:05:17.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.145]                 "immediateCondition"))) {
[18:05:17.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.145]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.145]                   if (TRUE && !signal) {
[18:05:17.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.145]                     {
[18:05:17.145]                       inherits <- base::inherits
[18:05:17.145]                       invokeRestart <- base::invokeRestart
[18:05:17.145]                       is.null <- base::is.null
[18:05:17.145]                       muffled <- FALSE
[18:05:17.145]                       if (inherits(cond, "message")) {
[18:05:17.145]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.145]                         if (muffled) 
[18:05:17.145]                           invokeRestart("muffleMessage")
[18:05:17.145]                       }
[18:05:17.145]                       else if (inherits(cond, "warning")) {
[18:05:17.145]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.145]                         if (muffled) 
[18:05:17.145]                           invokeRestart("muffleWarning")
[18:05:17.145]                       }
[18:05:17.145]                       else if (inherits(cond, "condition")) {
[18:05:17.145]                         if (!is.null(pattern)) {
[18:05:17.145]                           computeRestarts <- base::computeRestarts
[18:05:17.145]                           grepl <- base::grepl
[18:05:17.145]                           restarts <- computeRestarts(cond)
[18:05:17.145]                           for (restart in restarts) {
[18:05:17.145]                             name <- restart$name
[18:05:17.145]                             if (is.null(name)) 
[18:05:17.145]                               next
[18:05:17.145]                             if (!grepl(pattern, name)) 
[18:05:17.145]                               next
[18:05:17.145]                             invokeRestart(restart)
[18:05:17.145]                             muffled <- TRUE
[18:05:17.145]                             break
[18:05:17.145]                           }
[18:05:17.145]                         }
[18:05:17.145]                       }
[18:05:17.145]                       invisible(muffled)
[18:05:17.145]                     }
[18:05:17.145]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.145]                   }
[18:05:17.145]                 }
[18:05:17.145]                 else {
[18:05:17.145]                   if (TRUE) {
[18:05:17.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.145]                     {
[18:05:17.145]                       inherits <- base::inherits
[18:05:17.145]                       invokeRestart <- base::invokeRestart
[18:05:17.145]                       is.null <- base::is.null
[18:05:17.145]                       muffled <- FALSE
[18:05:17.145]                       if (inherits(cond, "message")) {
[18:05:17.145]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.145]                         if (muffled) 
[18:05:17.145]                           invokeRestart("muffleMessage")
[18:05:17.145]                       }
[18:05:17.145]                       else if (inherits(cond, "warning")) {
[18:05:17.145]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.145]                         if (muffled) 
[18:05:17.145]                           invokeRestart("muffleWarning")
[18:05:17.145]                       }
[18:05:17.145]                       else if (inherits(cond, "condition")) {
[18:05:17.145]                         if (!is.null(pattern)) {
[18:05:17.145]                           computeRestarts <- base::computeRestarts
[18:05:17.145]                           grepl <- base::grepl
[18:05:17.145]                           restarts <- computeRestarts(cond)
[18:05:17.145]                           for (restart in restarts) {
[18:05:17.145]                             name <- restart$name
[18:05:17.145]                             if (is.null(name)) 
[18:05:17.145]                               next
[18:05:17.145]                             if (!grepl(pattern, name)) 
[18:05:17.145]                               next
[18:05:17.145]                             invokeRestart(restart)
[18:05:17.145]                             muffled <- TRUE
[18:05:17.145]                             break
[18:05:17.145]                           }
[18:05:17.145]                         }
[18:05:17.145]                       }
[18:05:17.145]                       invisible(muffled)
[18:05:17.145]                     }
[18:05:17.145]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.145]                   }
[18:05:17.145]                 }
[18:05:17.145]             }
[18:05:17.145]         }))
[18:05:17.145]     }, error = function(ex) {
[18:05:17.145]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.145]                 ...future.rng), started = ...future.startTime, 
[18:05:17.145]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.145]             version = "1.8"), class = "FutureResult")
[18:05:17.145]     }, finally = {
[18:05:17.145]         if (!identical(...future.workdir, getwd())) 
[18:05:17.145]             setwd(...future.workdir)
[18:05:17.145]         {
[18:05:17.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.145]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.145]             }
[18:05:17.145]             base::options(...future.oldOptions)
[18:05:17.145]             if (.Platform$OS.type == "windows") {
[18:05:17.145]                 old_names <- names(...future.oldEnvVars)
[18:05:17.145]                 envs <- base::Sys.getenv()
[18:05:17.145]                 names <- names(envs)
[18:05:17.145]                 common <- intersect(names, old_names)
[18:05:17.145]                 added <- setdiff(names, old_names)
[18:05:17.145]                 removed <- setdiff(old_names, names)
[18:05:17.145]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.145]                   envs[common]]
[18:05:17.145]                 NAMES <- toupper(changed)
[18:05:17.145]                 args <- list()
[18:05:17.145]                 for (kk in seq_along(NAMES)) {
[18:05:17.145]                   name <- changed[[kk]]
[18:05:17.145]                   NAME <- NAMES[[kk]]
[18:05:17.145]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.145]                     next
[18:05:17.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.145]                 }
[18:05:17.145]                 NAMES <- toupper(added)
[18:05:17.145]                 for (kk in seq_along(NAMES)) {
[18:05:17.145]                   name <- added[[kk]]
[18:05:17.145]                   NAME <- NAMES[[kk]]
[18:05:17.145]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.145]                     next
[18:05:17.145]                   args[[name]] <- ""
[18:05:17.145]                 }
[18:05:17.145]                 NAMES <- toupper(removed)
[18:05:17.145]                 for (kk in seq_along(NAMES)) {
[18:05:17.145]                   name <- removed[[kk]]
[18:05:17.145]                   NAME <- NAMES[[kk]]
[18:05:17.145]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.145]                     next
[18:05:17.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.145]                 }
[18:05:17.145]                 if (length(args) > 0) 
[18:05:17.145]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.145]             }
[18:05:17.145]             else {
[18:05:17.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.145]             }
[18:05:17.145]             {
[18:05:17.145]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.145]                   0L) {
[18:05:17.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.145]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.145]                   base::options(opts)
[18:05:17.145]                 }
[18:05:17.145]                 {
[18:05:17.145]                   {
[18:05:17.145]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:17.145]                     NULL
[18:05:17.145]                   }
[18:05:17.145]                   options(future.plan = NULL)
[18:05:17.145]                   if (is.na(NA_character_)) 
[18:05:17.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.145]                     .init = FALSE)
[18:05:17.145]                 }
[18:05:17.145]             }
[18:05:17.145]         }
[18:05:17.145]     })
[18:05:17.145]     if (TRUE) {
[18:05:17.145]         base::sink(type = "output", split = FALSE)
[18:05:17.145]         if (TRUE) {
[18:05:17.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.145]         }
[18:05:17.145]         else {
[18:05:17.145]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.145]         }
[18:05:17.145]         base::close(...future.stdout)
[18:05:17.145]         ...future.stdout <- NULL
[18:05:17.145]     }
[18:05:17.145]     ...future.result$conditions <- ...future.conditions
[18:05:17.145]     ...future.result$finished <- base::Sys.time()
[18:05:17.145]     ...future.result
[18:05:17.145] }
[18:05:17.245] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] FALSE
[18:05:17.269] result() for ClusterFuture ...
[18:05:17.270] receiveMessageFromWorker() for ClusterFuture ...
[18:05:17.270] - Validating connection of MultisessionFuture
[18:05:17.309] - received message: FutureResult
[18:05:17.310] - Received FutureResult
[18:05:17.319] - Erased future from FutureRegistry
[18:05:17.319] result() for ClusterFuture ...
[18:05:17.319] - result already collected: FutureResult
[18:05:17.320] result() for ClusterFuture ... done
[18:05:17.320] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:17.321] result() for ClusterFuture ... done
[18:05:17.321] result() for ClusterFuture ...
[18:05:17.321] - result already collected: FutureResult
[18:05:17.322] result() for ClusterFuture ... done
[1] 42
[18:05:17.330] getGlobalsAndPackages() ...
[18:05:17.330] Searching for globals...
[18:05:17.336] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[18:05:17.336] Searching for globals ... DONE
[18:05:17.336] Resolving globals: FALSE
[18:05:17.338] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:17.339] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:05:17.339] - globals: [1] ‘a’
[18:05:17.339] 
[18:05:17.339] getGlobalsAndPackages() ... DONE
[18:05:17.361] Packages needed by the future expression (n = 0): <none>
[18:05:17.361] Packages needed by future strategies (n = 0): <none>
[18:05:17.362] {
[18:05:17.362]     {
[18:05:17.362]         {
[18:05:17.362]             ...future.startTime <- base::Sys.time()
[18:05:17.362]             {
[18:05:17.362]                 {
[18:05:17.362]                   {
[18:05:17.362]                     {
[18:05:17.362]                       base::local({
[18:05:17.362]                         has_future <- base::requireNamespace("future", 
[18:05:17.362]                           quietly = TRUE)
[18:05:17.362]                         if (has_future) {
[18:05:17.362]                           ns <- base::getNamespace("future")
[18:05:17.362]                           version <- ns[[".package"]][["version"]]
[18:05:17.362]                           if (is.null(version)) 
[18:05:17.362]                             version <- utils::packageVersion("future")
[18:05:17.362]                         }
[18:05:17.362]                         else {
[18:05:17.362]                           version <- NULL
[18:05:17.362]                         }
[18:05:17.362]                         if (!has_future || version < "1.8.0") {
[18:05:17.362]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.362]                             "", base::R.version$version.string), 
[18:05:17.362]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:17.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.362]                               "release", "version")], collapse = " "), 
[18:05:17.362]                             hostname = base::Sys.info()[["nodename"]])
[18:05:17.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.362]                             info)
[18:05:17.362]                           info <- base::paste(info, collapse = "; ")
[18:05:17.362]                           if (!has_future) {
[18:05:17.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.362]                               info)
[18:05:17.362]                           }
[18:05:17.362]                           else {
[18:05:17.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.362]                               info, version)
[18:05:17.362]                           }
[18:05:17.362]                           base::stop(msg)
[18:05:17.362]                         }
[18:05:17.362]                       })
[18:05:17.362]                     }
[18:05:17.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:17.362]                     base::options(mc.cores = 1L)
[18:05:17.362]                   }
[18:05:17.362]                   ...future.strategy.old <- future::plan("list")
[18:05:17.362]                   options(future.plan = NULL)
[18:05:17.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.362]                 }
[18:05:17.362]                 ...future.workdir <- getwd()
[18:05:17.362]             }
[18:05:17.362]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.362]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.362]         }
[18:05:17.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:17.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.362]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.362]             base::names(...future.oldOptions))
[18:05:17.362]     }
[18:05:17.362]     if (FALSE) {
[18:05:17.362]     }
[18:05:17.362]     else {
[18:05:17.362]         if (TRUE) {
[18:05:17.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.362]                 open = "w")
[18:05:17.362]         }
[18:05:17.362]         else {
[18:05:17.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.362]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.362]         }
[18:05:17.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.362]             base::sink(type = "output", split = FALSE)
[18:05:17.362]             base::close(...future.stdout)
[18:05:17.362]         }, add = TRUE)
[18:05:17.362]     }
[18:05:17.362]     ...future.frame <- base::sys.nframe()
[18:05:17.362]     ...future.conditions <- base::list()
[18:05:17.362]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.362]     if (FALSE) {
[18:05:17.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.362]     }
[18:05:17.362]     ...future.result <- base::tryCatch({
[18:05:17.362]         base::withCallingHandlers({
[18:05:17.362]             ...future.value <- base::withVisible(base::local({
[18:05:17.362]                 ...future.makeSendCondition <- base::local({
[18:05:17.362]                   sendCondition <- NULL
[18:05:17.362]                   function(frame = 1L) {
[18:05:17.362]                     if (is.function(sendCondition)) 
[18:05:17.362]                       return(sendCondition)
[18:05:17.362]                     ns <- getNamespace("parallel")
[18:05:17.362]                     if (exists("sendData", mode = "function", 
[18:05:17.362]                       envir = ns)) {
[18:05:17.362]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:17.362]                         envir = ns)
[18:05:17.362]                       envir <- sys.frame(frame)
[18:05:17.362]                       master <- NULL
[18:05:17.362]                       while (!identical(envir, .GlobalEnv) && 
[18:05:17.362]                         !identical(envir, emptyenv())) {
[18:05:17.362]                         if (exists("master", mode = "list", envir = envir, 
[18:05:17.362]                           inherits = FALSE)) {
[18:05:17.362]                           master <- get("master", mode = "list", 
[18:05:17.362]                             envir = envir, inherits = FALSE)
[18:05:17.362]                           if (inherits(master, c("SOCKnode", 
[18:05:17.362]                             "SOCK0node"))) {
[18:05:17.362]                             sendCondition <<- function(cond) {
[18:05:17.362]                               data <- list(type = "VALUE", value = cond, 
[18:05:17.362]                                 success = TRUE)
[18:05:17.362]                               parallel_sendData(master, data)
[18:05:17.362]                             }
[18:05:17.362]                             return(sendCondition)
[18:05:17.362]                           }
[18:05:17.362]                         }
[18:05:17.362]                         frame <- frame + 1L
[18:05:17.362]                         envir <- sys.frame(frame)
[18:05:17.362]                       }
[18:05:17.362]                     }
[18:05:17.362]                     sendCondition <<- function(cond) NULL
[18:05:17.362]                   }
[18:05:17.362]                 })
[18:05:17.362]                 withCallingHandlers({
[18:05:17.362]                   {
[18:05:17.362]                     b <- 3
[18:05:17.362]                     c <- 2
[18:05:17.362]                     a * b * c
[18:05:17.362]                   }
[18:05:17.362]                 }, immediateCondition = function(cond) {
[18:05:17.362]                   sendCondition <- ...future.makeSendCondition()
[18:05:17.362]                   sendCondition(cond)
[18:05:17.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.362]                   {
[18:05:17.362]                     inherits <- base::inherits
[18:05:17.362]                     invokeRestart <- base::invokeRestart
[18:05:17.362]                     is.null <- base::is.null
[18:05:17.362]                     muffled <- FALSE
[18:05:17.362]                     if (inherits(cond, "message")) {
[18:05:17.362]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:17.362]                       if (muffled) 
[18:05:17.362]                         invokeRestart("muffleMessage")
[18:05:17.362]                     }
[18:05:17.362]                     else if (inherits(cond, "warning")) {
[18:05:17.362]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:17.362]                       if (muffled) 
[18:05:17.362]                         invokeRestart("muffleWarning")
[18:05:17.362]                     }
[18:05:17.362]                     else if (inherits(cond, "condition")) {
[18:05:17.362]                       if (!is.null(pattern)) {
[18:05:17.362]                         computeRestarts <- base::computeRestarts
[18:05:17.362]                         grepl <- base::grepl
[18:05:17.362]                         restarts <- computeRestarts(cond)
[18:05:17.362]                         for (restart in restarts) {
[18:05:17.362]                           name <- restart$name
[18:05:17.362]                           if (is.null(name)) 
[18:05:17.362]                             next
[18:05:17.362]                           if (!grepl(pattern, name)) 
[18:05:17.362]                             next
[18:05:17.362]                           invokeRestart(restart)
[18:05:17.362]                           muffled <- TRUE
[18:05:17.362]                           break
[18:05:17.362]                         }
[18:05:17.362]                       }
[18:05:17.362]                     }
[18:05:17.362]                     invisible(muffled)
[18:05:17.362]                   }
[18:05:17.362]                   muffleCondition(cond)
[18:05:17.362]                 })
[18:05:17.362]             }))
[18:05:17.362]             future::FutureResult(value = ...future.value$value, 
[18:05:17.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.362]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.362]                     ...future.globalenv.names))
[18:05:17.362]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.362]         }, condition = base::local({
[18:05:17.362]             c <- base::c
[18:05:17.362]             inherits <- base::inherits
[18:05:17.362]             invokeRestart <- base::invokeRestart
[18:05:17.362]             length <- base::length
[18:05:17.362]             list <- base::list
[18:05:17.362]             seq.int <- base::seq.int
[18:05:17.362]             signalCondition <- base::signalCondition
[18:05:17.362]             sys.calls <- base::sys.calls
[18:05:17.362]             `[[` <- base::`[[`
[18:05:17.362]             `+` <- base::`+`
[18:05:17.362]             `<<-` <- base::`<<-`
[18:05:17.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.362]                   3L)]
[18:05:17.362]             }
[18:05:17.362]             function(cond) {
[18:05:17.362]                 is_error <- inherits(cond, "error")
[18:05:17.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.362]                   NULL)
[18:05:17.362]                 if (is_error) {
[18:05:17.362]                   sessionInformation <- function() {
[18:05:17.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.362]                       search = base::search(), system = base::Sys.info())
[18:05:17.362]                   }
[18:05:17.362]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.362]                     cond$call), session = sessionInformation(), 
[18:05:17.362]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.362]                   signalCondition(cond)
[18:05:17.362]                 }
[18:05:17.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.362]                 "immediateCondition"))) {
[18:05:17.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.362]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.362]                   if (TRUE && !signal) {
[18:05:17.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.362]                     {
[18:05:17.362]                       inherits <- base::inherits
[18:05:17.362]                       invokeRestart <- base::invokeRestart
[18:05:17.362]                       is.null <- base::is.null
[18:05:17.362]                       muffled <- FALSE
[18:05:17.362]                       if (inherits(cond, "message")) {
[18:05:17.362]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.362]                         if (muffled) 
[18:05:17.362]                           invokeRestart("muffleMessage")
[18:05:17.362]                       }
[18:05:17.362]                       else if (inherits(cond, "warning")) {
[18:05:17.362]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.362]                         if (muffled) 
[18:05:17.362]                           invokeRestart("muffleWarning")
[18:05:17.362]                       }
[18:05:17.362]                       else if (inherits(cond, "condition")) {
[18:05:17.362]                         if (!is.null(pattern)) {
[18:05:17.362]                           computeRestarts <- base::computeRestarts
[18:05:17.362]                           grepl <- base::grepl
[18:05:17.362]                           restarts <- computeRestarts(cond)
[18:05:17.362]                           for (restart in restarts) {
[18:05:17.362]                             name <- restart$name
[18:05:17.362]                             if (is.null(name)) 
[18:05:17.362]                               next
[18:05:17.362]                             if (!grepl(pattern, name)) 
[18:05:17.362]                               next
[18:05:17.362]                             invokeRestart(restart)
[18:05:17.362]                             muffled <- TRUE
[18:05:17.362]                             break
[18:05:17.362]                           }
[18:05:17.362]                         }
[18:05:17.362]                       }
[18:05:17.362]                       invisible(muffled)
[18:05:17.362]                     }
[18:05:17.362]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.362]                   }
[18:05:17.362]                 }
[18:05:17.362]                 else {
[18:05:17.362]                   if (TRUE) {
[18:05:17.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.362]                     {
[18:05:17.362]                       inherits <- base::inherits
[18:05:17.362]                       invokeRestart <- base::invokeRestart
[18:05:17.362]                       is.null <- base::is.null
[18:05:17.362]                       muffled <- FALSE
[18:05:17.362]                       if (inherits(cond, "message")) {
[18:05:17.362]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.362]                         if (muffled) 
[18:05:17.362]                           invokeRestart("muffleMessage")
[18:05:17.362]                       }
[18:05:17.362]                       else if (inherits(cond, "warning")) {
[18:05:17.362]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.362]                         if (muffled) 
[18:05:17.362]                           invokeRestart("muffleWarning")
[18:05:17.362]                       }
[18:05:17.362]                       else if (inherits(cond, "condition")) {
[18:05:17.362]                         if (!is.null(pattern)) {
[18:05:17.362]                           computeRestarts <- base::computeRestarts
[18:05:17.362]                           grepl <- base::grepl
[18:05:17.362]                           restarts <- computeRestarts(cond)
[18:05:17.362]                           for (restart in restarts) {
[18:05:17.362]                             name <- restart$name
[18:05:17.362]                             if (is.null(name)) 
[18:05:17.362]                               next
[18:05:17.362]                             if (!grepl(pattern, name)) 
[18:05:17.362]                               next
[18:05:17.362]                             invokeRestart(restart)
[18:05:17.362]                             muffled <- TRUE
[18:05:17.362]                             break
[18:05:17.362]                           }
[18:05:17.362]                         }
[18:05:17.362]                       }
[18:05:17.362]                       invisible(muffled)
[18:05:17.362]                     }
[18:05:17.362]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.362]                   }
[18:05:17.362]                 }
[18:05:17.362]             }
[18:05:17.362]         }))
[18:05:17.362]     }, error = function(ex) {
[18:05:17.362]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.362]                 ...future.rng), started = ...future.startTime, 
[18:05:17.362]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.362]             version = "1.8"), class = "FutureResult")
[18:05:17.362]     }, finally = {
[18:05:17.362]         if (!identical(...future.workdir, getwd())) 
[18:05:17.362]             setwd(...future.workdir)
[18:05:17.362]         {
[18:05:17.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.362]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.362]             }
[18:05:17.362]             base::options(...future.oldOptions)
[18:05:17.362]             if (.Platform$OS.type == "windows") {
[18:05:17.362]                 old_names <- names(...future.oldEnvVars)
[18:05:17.362]                 envs <- base::Sys.getenv()
[18:05:17.362]                 names <- names(envs)
[18:05:17.362]                 common <- intersect(names, old_names)
[18:05:17.362]                 added <- setdiff(names, old_names)
[18:05:17.362]                 removed <- setdiff(old_names, names)
[18:05:17.362]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.362]                   envs[common]]
[18:05:17.362]                 NAMES <- toupper(changed)
[18:05:17.362]                 args <- list()
[18:05:17.362]                 for (kk in seq_along(NAMES)) {
[18:05:17.362]                   name <- changed[[kk]]
[18:05:17.362]                   NAME <- NAMES[[kk]]
[18:05:17.362]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.362]                     next
[18:05:17.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.362]                 }
[18:05:17.362]                 NAMES <- toupper(added)
[18:05:17.362]                 for (kk in seq_along(NAMES)) {
[18:05:17.362]                   name <- added[[kk]]
[18:05:17.362]                   NAME <- NAMES[[kk]]
[18:05:17.362]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.362]                     next
[18:05:17.362]                   args[[name]] <- ""
[18:05:17.362]                 }
[18:05:17.362]                 NAMES <- toupper(removed)
[18:05:17.362]                 for (kk in seq_along(NAMES)) {
[18:05:17.362]                   name <- removed[[kk]]
[18:05:17.362]                   NAME <- NAMES[[kk]]
[18:05:17.362]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.362]                     next
[18:05:17.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.362]                 }
[18:05:17.362]                 if (length(args) > 0) 
[18:05:17.362]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.362]             }
[18:05:17.362]             else {
[18:05:17.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.362]             }
[18:05:17.362]             {
[18:05:17.362]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.362]                   0L) {
[18:05:17.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.362]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.362]                   base::options(opts)
[18:05:17.362]                 }
[18:05:17.362]                 {
[18:05:17.362]                   {
[18:05:17.362]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:17.362]                     NULL
[18:05:17.362]                   }
[18:05:17.362]                   options(future.plan = NULL)
[18:05:17.362]                   if (is.na(NA_character_)) 
[18:05:17.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.362]                     .init = FALSE)
[18:05:17.362]                 }
[18:05:17.362]             }
[18:05:17.362]         }
[18:05:17.362]     })
[18:05:17.362]     if (TRUE) {
[18:05:17.362]         base::sink(type = "output", split = FALSE)
[18:05:17.362]         if (TRUE) {
[18:05:17.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.362]         }
[18:05:17.362]         else {
[18:05:17.362]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.362]         }
[18:05:17.362]         base::close(...future.stdout)
[18:05:17.362]         ...future.stdout <- NULL
[18:05:17.362]     }
[18:05:17.362]     ...future.result$conditions <- ...future.conditions
[18:05:17.362]     ...future.result$finished <- base::Sys.time()
[18:05:17.362]     ...future.result
[18:05:17.362] }
[18:05:17.368] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:05:17.368] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:05:17.369] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:05:17.369] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:05:17.371] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:17.385] result() for ClusterFuture ...
[18:05:17.386] receiveMessageFromWorker() for ClusterFuture ...
[18:05:17.386] - Validating connection of MultisessionFuture
[18:05:17.413] - received message: FutureResult
[18:05:17.414] - Received FutureResult
[18:05:17.414] - Erased future from FutureRegistry
[18:05:17.414] result() for ClusterFuture ...
[18:05:17.415] - result already collected: FutureResult
[18:05:17.415] result() for ClusterFuture ... done
[18:05:17.415] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:17.416] result() for ClusterFuture ... done
[18:05:17.416] result() for ClusterFuture ...
[18:05:17.416] - result already collected: FutureResult
[18:05:17.416] result() for ClusterFuture ... done
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[18:05:17.424] getGlobalsAndPackages() ...
[18:05:17.424] Searching for globals...
[18:05:17.426] - globals found: [2] ‘{’, ‘ii’
[18:05:17.426] Searching for globals ... DONE
[18:05:17.426] Resolving globals: FALSE
[18:05:17.427] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:17.428] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:17.428] - globals: [1] ‘ii’
[18:05:17.428] 
[18:05:17.428] getGlobalsAndPackages() ... DONE
[18:05:17.448] Packages needed by the future expression (n = 0): <none>
[18:05:17.449] Packages needed by future strategies (n = 0): <none>
[18:05:17.449] {
[18:05:17.449]     {
[18:05:17.449]         {
[18:05:17.449]             ...future.startTime <- base::Sys.time()
[18:05:17.449]             {
[18:05:17.449]                 {
[18:05:17.449]                   {
[18:05:17.449]                     {
[18:05:17.449]                       base::local({
[18:05:17.449]                         has_future <- base::requireNamespace("future", 
[18:05:17.449]                           quietly = TRUE)
[18:05:17.449]                         if (has_future) {
[18:05:17.449]                           ns <- base::getNamespace("future")
[18:05:17.449]                           version <- ns[[".package"]][["version"]]
[18:05:17.449]                           if (is.null(version)) 
[18:05:17.449]                             version <- utils::packageVersion("future")
[18:05:17.449]                         }
[18:05:17.449]                         else {
[18:05:17.449]                           version <- NULL
[18:05:17.449]                         }
[18:05:17.449]                         if (!has_future || version < "1.8.0") {
[18:05:17.449]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.449]                             "", base::R.version$version.string), 
[18:05:17.449]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:17.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.449]                               "release", "version")], collapse = " "), 
[18:05:17.449]                             hostname = base::Sys.info()[["nodename"]])
[18:05:17.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.449]                             info)
[18:05:17.449]                           info <- base::paste(info, collapse = "; ")
[18:05:17.449]                           if (!has_future) {
[18:05:17.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.449]                               info)
[18:05:17.449]                           }
[18:05:17.449]                           else {
[18:05:17.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.449]                               info, version)
[18:05:17.449]                           }
[18:05:17.449]                           base::stop(msg)
[18:05:17.449]                         }
[18:05:17.449]                       })
[18:05:17.449]                     }
[18:05:17.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:17.449]                     base::options(mc.cores = 1L)
[18:05:17.449]                   }
[18:05:17.449]                   ...future.strategy.old <- future::plan("list")
[18:05:17.449]                   options(future.plan = NULL)
[18:05:17.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.449]                 }
[18:05:17.449]                 ...future.workdir <- getwd()
[18:05:17.449]             }
[18:05:17.449]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.449]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.449]         }
[18:05:17.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:17.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.449]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.449]             base::names(...future.oldOptions))
[18:05:17.449]     }
[18:05:17.449]     if (FALSE) {
[18:05:17.449]     }
[18:05:17.449]     else {
[18:05:17.449]         if (TRUE) {
[18:05:17.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.449]                 open = "w")
[18:05:17.449]         }
[18:05:17.449]         else {
[18:05:17.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.449]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.449]         }
[18:05:17.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.449]             base::sink(type = "output", split = FALSE)
[18:05:17.449]             base::close(...future.stdout)
[18:05:17.449]         }, add = TRUE)
[18:05:17.449]     }
[18:05:17.449]     ...future.frame <- base::sys.nframe()
[18:05:17.449]     ...future.conditions <- base::list()
[18:05:17.449]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.449]     if (FALSE) {
[18:05:17.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.449]     }
[18:05:17.449]     ...future.result <- base::tryCatch({
[18:05:17.449]         base::withCallingHandlers({
[18:05:17.449]             ...future.value <- base::withVisible(base::local({
[18:05:17.449]                 ...future.makeSendCondition <- base::local({
[18:05:17.449]                   sendCondition <- NULL
[18:05:17.449]                   function(frame = 1L) {
[18:05:17.449]                     if (is.function(sendCondition)) 
[18:05:17.449]                       return(sendCondition)
[18:05:17.449]                     ns <- getNamespace("parallel")
[18:05:17.449]                     if (exists("sendData", mode = "function", 
[18:05:17.449]                       envir = ns)) {
[18:05:17.449]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:17.449]                         envir = ns)
[18:05:17.449]                       envir <- sys.frame(frame)
[18:05:17.449]                       master <- NULL
[18:05:17.449]                       while (!identical(envir, .GlobalEnv) && 
[18:05:17.449]                         !identical(envir, emptyenv())) {
[18:05:17.449]                         if (exists("master", mode = "list", envir = envir, 
[18:05:17.449]                           inherits = FALSE)) {
[18:05:17.449]                           master <- get("master", mode = "list", 
[18:05:17.449]                             envir = envir, inherits = FALSE)
[18:05:17.449]                           if (inherits(master, c("SOCKnode", 
[18:05:17.449]                             "SOCK0node"))) {
[18:05:17.449]                             sendCondition <<- function(cond) {
[18:05:17.449]                               data <- list(type = "VALUE", value = cond, 
[18:05:17.449]                                 success = TRUE)
[18:05:17.449]                               parallel_sendData(master, data)
[18:05:17.449]                             }
[18:05:17.449]                             return(sendCondition)
[18:05:17.449]                           }
[18:05:17.449]                         }
[18:05:17.449]                         frame <- frame + 1L
[18:05:17.449]                         envir <- sys.frame(frame)
[18:05:17.449]                       }
[18:05:17.449]                     }
[18:05:17.449]                     sendCondition <<- function(cond) NULL
[18:05:17.449]                   }
[18:05:17.449]                 })
[18:05:17.449]                 withCallingHandlers({
[18:05:17.449]                   {
[18:05:17.449]                     ii
[18:05:17.449]                   }
[18:05:17.449]                 }, immediateCondition = function(cond) {
[18:05:17.449]                   sendCondition <- ...future.makeSendCondition()
[18:05:17.449]                   sendCondition(cond)
[18:05:17.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.449]                   {
[18:05:17.449]                     inherits <- base::inherits
[18:05:17.449]                     invokeRestart <- base::invokeRestart
[18:05:17.449]                     is.null <- base::is.null
[18:05:17.449]                     muffled <- FALSE
[18:05:17.449]                     if (inherits(cond, "message")) {
[18:05:17.449]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:17.449]                       if (muffled) 
[18:05:17.449]                         invokeRestart("muffleMessage")
[18:05:17.449]                     }
[18:05:17.449]                     else if (inherits(cond, "warning")) {
[18:05:17.449]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:17.449]                       if (muffled) 
[18:05:17.449]                         invokeRestart("muffleWarning")
[18:05:17.449]                     }
[18:05:17.449]                     else if (inherits(cond, "condition")) {
[18:05:17.449]                       if (!is.null(pattern)) {
[18:05:17.449]                         computeRestarts <- base::computeRestarts
[18:05:17.449]                         grepl <- base::grepl
[18:05:17.449]                         restarts <- computeRestarts(cond)
[18:05:17.449]                         for (restart in restarts) {
[18:05:17.449]                           name <- restart$name
[18:05:17.449]                           if (is.null(name)) 
[18:05:17.449]                             next
[18:05:17.449]                           if (!grepl(pattern, name)) 
[18:05:17.449]                             next
[18:05:17.449]                           invokeRestart(restart)
[18:05:17.449]                           muffled <- TRUE
[18:05:17.449]                           break
[18:05:17.449]                         }
[18:05:17.449]                       }
[18:05:17.449]                     }
[18:05:17.449]                     invisible(muffled)
[18:05:17.449]                   }
[18:05:17.449]                   muffleCondition(cond)
[18:05:17.449]                 })
[18:05:17.449]             }))
[18:05:17.449]             future::FutureResult(value = ...future.value$value, 
[18:05:17.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.449]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.449]                     ...future.globalenv.names))
[18:05:17.449]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.449]         }, condition = base::local({
[18:05:17.449]             c <- base::c
[18:05:17.449]             inherits <- base::inherits
[18:05:17.449]             invokeRestart <- base::invokeRestart
[18:05:17.449]             length <- base::length
[18:05:17.449]             list <- base::list
[18:05:17.449]             seq.int <- base::seq.int
[18:05:17.449]             signalCondition <- base::signalCondition
[18:05:17.449]             sys.calls <- base::sys.calls
[18:05:17.449]             `[[` <- base::`[[`
[18:05:17.449]             `+` <- base::`+`
[18:05:17.449]             `<<-` <- base::`<<-`
[18:05:17.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.449]                   3L)]
[18:05:17.449]             }
[18:05:17.449]             function(cond) {
[18:05:17.449]                 is_error <- inherits(cond, "error")
[18:05:17.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.449]                   NULL)
[18:05:17.449]                 if (is_error) {
[18:05:17.449]                   sessionInformation <- function() {
[18:05:17.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.449]                       search = base::search(), system = base::Sys.info())
[18:05:17.449]                   }
[18:05:17.449]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.449]                     cond$call), session = sessionInformation(), 
[18:05:17.449]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.449]                   signalCondition(cond)
[18:05:17.449]                 }
[18:05:17.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.449]                 "immediateCondition"))) {
[18:05:17.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.449]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.449]                   if (TRUE && !signal) {
[18:05:17.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.449]                     {
[18:05:17.449]                       inherits <- base::inherits
[18:05:17.449]                       invokeRestart <- base::invokeRestart
[18:05:17.449]                       is.null <- base::is.null
[18:05:17.449]                       muffled <- FALSE
[18:05:17.449]                       if (inherits(cond, "message")) {
[18:05:17.449]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.449]                         if (muffled) 
[18:05:17.449]                           invokeRestart("muffleMessage")
[18:05:17.449]                       }
[18:05:17.449]                       else if (inherits(cond, "warning")) {
[18:05:17.449]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.449]                         if (muffled) 
[18:05:17.449]                           invokeRestart("muffleWarning")
[18:05:17.449]                       }
[18:05:17.449]                       else if (inherits(cond, "condition")) {
[18:05:17.449]                         if (!is.null(pattern)) {
[18:05:17.449]                           computeRestarts <- base::computeRestarts
[18:05:17.449]                           grepl <- base::grepl
[18:05:17.449]                           restarts <- computeRestarts(cond)
[18:05:17.449]                           for (restart in restarts) {
[18:05:17.449]                             name <- restart$name
[18:05:17.449]                             if (is.null(name)) 
[18:05:17.449]                               next
[18:05:17.449]                             if (!grepl(pattern, name)) 
[18:05:17.449]                               next
[18:05:17.449]                             invokeRestart(restart)
[18:05:17.449]                             muffled <- TRUE
[18:05:17.449]                             break
[18:05:17.449]                           }
[18:05:17.449]                         }
[18:05:17.449]                       }
[18:05:17.449]                       invisible(muffled)
[18:05:17.449]                     }
[18:05:17.449]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.449]                   }
[18:05:17.449]                 }
[18:05:17.449]                 else {
[18:05:17.449]                   if (TRUE) {
[18:05:17.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.449]                     {
[18:05:17.449]                       inherits <- base::inherits
[18:05:17.449]                       invokeRestart <- base::invokeRestart
[18:05:17.449]                       is.null <- base::is.null
[18:05:17.449]                       muffled <- FALSE
[18:05:17.449]                       if (inherits(cond, "message")) {
[18:05:17.449]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.449]                         if (muffled) 
[18:05:17.449]                           invokeRestart("muffleMessage")
[18:05:17.449]                       }
[18:05:17.449]                       else if (inherits(cond, "warning")) {
[18:05:17.449]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.449]                         if (muffled) 
[18:05:17.449]                           invokeRestart("muffleWarning")
[18:05:17.449]                       }
[18:05:17.449]                       else if (inherits(cond, "condition")) {
[18:05:17.449]                         if (!is.null(pattern)) {
[18:05:17.449]                           computeRestarts <- base::computeRestarts
[18:05:17.449]                           grepl <- base::grepl
[18:05:17.449]                           restarts <- computeRestarts(cond)
[18:05:17.449]                           for (restart in restarts) {
[18:05:17.449]                             name <- restart$name
[18:05:17.449]                             if (is.null(name)) 
[18:05:17.449]                               next
[18:05:17.449]                             if (!grepl(pattern, name)) 
[18:05:17.449]                               next
[18:05:17.449]                             invokeRestart(restart)
[18:05:17.449]                             muffled <- TRUE
[18:05:17.449]                             break
[18:05:17.449]                           }
[18:05:17.449]                         }
[18:05:17.449]                       }
[18:05:17.449]                       invisible(muffled)
[18:05:17.449]                     }
[18:05:17.449]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.449]                   }
[18:05:17.449]                 }
[18:05:17.449]             }
[18:05:17.449]         }))
[18:05:17.449]     }, error = function(ex) {
[18:05:17.449]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.449]                 ...future.rng), started = ...future.startTime, 
[18:05:17.449]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.449]             version = "1.8"), class = "FutureResult")
[18:05:17.449]     }, finally = {
[18:05:17.449]         if (!identical(...future.workdir, getwd())) 
[18:05:17.449]             setwd(...future.workdir)
[18:05:17.449]         {
[18:05:17.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.449]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.449]             }
[18:05:17.449]             base::options(...future.oldOptions)
[18:05:17.449]             if (.Platform$OS.type == "windows") {
[18:05:17.449]                 old_names <- names(...future.oldEnvVars)
[18:05:17.449]                 envs <- base::Sys.getenv()
[18:05:17.449]                 names <- names(envs)
[18:05:17.449]                 common <- intersect(names, old_names)
[18:05:17.449]                 added <- setdiff(names, old_names)
[18:05:17.449]                 removed <- setdiff(old_names, names)
[18:05:17.449]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.449]                   envs[common]]
[18:05:17.449]                 NAMES <- toupper(changed)
[18:05:17.449]                 args <- list()
[18:05:17.449]                 for (kk in seq_along(NAMES)) {
[18:05:17.449]                   name <- changed[[kk]]
[18:05:17.449]                   NAME <- NAMES[[kk]]
[18:05:17.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.449]                     next
[18:05:17.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.449]                 }
[18:05:17.449]                 NAMES <- toupper(added)
[18:05:17.449]                 for (kk in seq_along(NAMES)) {
[18:05:17.449]                   name <- added[[kk]]
[18:05:17.449]                   NAME <- NAMES[[kk]]
[18:05:17.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.449]                     next
[18:05:17.449]                   args[[name]] <- ""
[18:05:17.449]                 }
[18:05:17.449]                 NAMES <- toupper(removed)
[18:05:17.449]                 for (kk in seq_along(NAMES)) {
[18:05:17.449]                   name <- removed[[kk]]
[18:05:17.449]                   NAME <- NAMES[[kk]]
[18:05:17.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.449]                     next
[18:05:17.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.449]                 }
[18:05:17.449]                 if (length(args) > 0) 
[18:05:17.449]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.449]             }
[18:05:17.449]             else {
[18:05:17.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.449]             }
[18:05:17.449]             {
[18:05:17.449]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.449]                   0L) {
[18:05:17.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.449]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.449]                   base::options(opts)
[18:05:17.449]                 }
[18:05:17.449]                 {
[18:05:17.449]                   {
[18:05:17.449]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:17.449]                     NULL
[18:05:17.449]                   }
[18:05:17.449]                   options(future.plan = NULL)
[18:05:17.449]                   if (is.na(NA_character_)) 
[18:05:17.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.449]                     .init = FALSE)
[18:05:17.449]                 }
[18:05:17.449]             }
[18:05:17.449]         }
[18:05:17.449]     })
[18:05:17.449]     if (TRUE) {
[18:05:17.449]         base::sink(type = "output", split = FALSE)
[18:05:17.449]         if (TRUE) {
[18:05:17.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.449]         }
[18:05:17.449]         else {
[18:05:17.449]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.449]         }
[18:05:17.449]         base::close(...future.stdout)
[18:05:17.449]         ...future.stdout <- NULL
[18:05:17.449]     }
[18:05:17.449]     ...future.result$conditions <- ...future.conditions
[18:05:17.449]     ...future.result$finished <- base::Sys.time()
[18:05:17.449]     ...future.result
[18:05:17.449] }
[18:05:17.455] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:05:17.455] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:05:17.456] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:05:17.457] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:05:17.458] MultisessionFuture started
 - Creating multisession future #1 ...
[18:05:17.464] getGlobalsAndPackages() ...
[18:05:17.465] Searching for globals...
[18:05:17.466] - globals found: [2] ‘{’, ‘ii’
[18:05:17.467] Searching for globals ... DONE
[18:05:17.467] Resolving globals: FALSE
[18:05:17.468] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:17.469] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:17.469] - globals: [1] ‘ii’
[18:05:17.469] 
[18:05:17.469] getGlobalsAndPackages() ... DONE
[18:05:17.489] Packages needed by the future expression (n = 0): <none>
[18:05:17.489] Packages needed by future strategies (n = 0): <none>
[18:05:17.490] {
[18:05:17.490]     {
[18:05:17.490]         {
[18:05:17.490]             ...future.startTime <- base::Sys.time()
[18:05:17.490]             {
[18:05:17.490]                 {
[18:05:17.490]                   {
[18:05:17.490]                     {
[18:05:17.490]                       base::local({
[18:05:17.490]                         has_future <- base::requireNamespace("future", 
[18:05:17.490]                           quietly = TRUE)
[18:05:17.490]                         if (has_future) {
[18:05:17.490]                           ns <- base::getNamespace("future")
[18:05:17.490]                           version <- ns[[".package"]][["version"]]
[18:05:17.490]                           if (is.null(version)) 
[18:05:17.490]                             version <- utils::packageVersion("future")
[18:05:17.490]                         }
[18:05:17.490]                         else {
[18:05:17.490]                           version <- NULL
[18:05:17.490]                         }
[18:05:17.490]                         if (!has_future || version < "1.8.0") {
[18:05:17.490]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.490]                             "", base::R.version$version.string), 
[18:05:17.490]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:17.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.490]                               "release", "version")], collapse = " "), 
[18:05:17.490]                             hostname = base::Sys.info()[["nodename"]])
[18:05:17.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.490]                             info)
[18:05:17.490]                           info <- base::paste(info, collapse = "; ")
[18:05:17.490]                           if (!has_future) {
[18:05:17.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.490]                               info)
[18:05:17.490]                           }
[18:05:17.490]                           else {
[18:05:17.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.490]                               info, version)
[18:05:17.490]                           }
[18:05:17.490]                           base::stop(msg)
[18:05:17.490]                         }
[18:05:17.490]                       })
[18:05:17.490]                     }
[18:05:17.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:17.490]                     base::options(mc.cores = 1L)
[18:05:17.490]                   }
[18:05:17.490]                   ...future.strategy.old <- future::plan("list")
[18:05:17.490]                   options(future.plan = NULL)
[18:05:17.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.490]                 }
[18:05:17.490]                 ...future.workdir <- getwd()
[18:05:17.490]             }
[18:05:17.490]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.490]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.490]         }
[18:05:17.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:17.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.490]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.490]             base::names(...future.oldOptions))
[18:05:17.490]     }
[18:05:17.490]     if (FALSE) {
[18:05:17.490]     }
[18:05:17.490]     else {
[18:05:17.490]         if (TRUE) {
[18:05:17.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.490]                 open = "w")
[18:05:17.490]         }
[18:05:17.490]         else {
[18:05:17.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.490]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.490]         }
[18:05:17.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.490]             base::sink(type = "output", split = FALSE)
[18:05:17.490]             base::close(...future.stdout)
[18:05:17.490]         }, add = TRUE)
[18:05:17.490]     }
[18:05:17.490]     ...future.frame <- base::sys.nframe()
[18:05:17.490]     ...future.conditions <- base::list()
[18:05:17.490]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.490]     if (FALSE) {
[18:05:17.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.490]     }
[18:05:17.490]     ...future.result <- base::tryCatch({
[18:05:17.490]         base::withCallingHandlers({
[18:05:17.490]             ...future.value <- base::withVisible(base::local({
[18:05:17.490]                 ...future.makeSendCondition <- base::local({
[18:05:17.490]                   sendCondition <- NULL
[18:05:17.490]                   function(frame = 1L) {
[18:05:17.490]                     if (is.function(sendCondition)) 
[18:05:17.490]                       return(sendCondition)
[18:05:17.490]                     ns <- getNamespace("parallel")
[18:05:17.490]                     if (exists("sendData", mode = "function", 
[18:05:17.490]                       envir = ns)) {
[18:05:17.490]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:17.490]                         envir = ns)
[18:05:17.490]                       envir <- sys.frame(frame)
[18:05:17.490]                       master <- NULL
[18:05:17.490]                       while (!identical(envir, .GlobalEnv) && 
[18:05:17.490]                         !identical(envir, emptyenv())) {
[18:05:17.490]                         if (exists("master", mode = "list", envir = envir, 
[18:05:17.490]                           inherits = FALSE)) {
[18:05:17.490]                           master <- get("master", mode = "list", 
[18:05:17.490]                             envir = envir, inherits = FALSE)
[18:05:17.490]                           if (inherits(master, c("SOCKnode", 
[18:05:17.490]                             "SOCK0node"))) {
[18:05:17.490]                             sendCondition <<- function(cond) {
[18:05:17.490]                               data <- list(type = "VALUE", value = cond, 
[18:05:17.490]                                 success = TRUE)
[18:05:17.490]                               parallel_sendData(master, data)
[18:05:17.490]                             }
[18:05:17.490]                             return(sendCondition)
[18:05:17.490]                           }
[18:05:17.490]                         }
[18:05:17.490]                         frame <- frame + 1L
[18:05:17.490]                         envir <- sys.frame(frame)
[18:05:17.490]                       }
[18:05:17.490]                     }
[18:05:17.490]                     sendCondition <<- function(cond) NULL
[18:05:17.490]                   }
[18:05:17.490]                 })
[18:05:17.490]                 withCallingHandlers({
[18:05:17.490]                   {
[18:05:17.490]                     ii
[18:05:17.490]                   }
[18:05:17.490]                 }, immediateCondition = function(cond) {
[18:05:17.490]                   sendCondition <- ...future.makeSendCondition()
[18:05:17.490]                   sendCondition(cond)
[18:05:17.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.490]                   {
[18:05:17.490]                     inherits <- base::inherits
[18:05:17.490]                     invokeRestart <- base::invokeRestart
[18:05:17.490]                     is.null <- base::is.null
[18:05:17.490]                     muffled <- FALSE
[18:05:17.490]                     if (inherits(cond, "message")) {
[18:05:17.490]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:17.490]                       if (muffled) 
[18:05:17.490]                         invokeRestart("muffleMessage")
[18:05:17.490]                     }
[18:05:17.490]                     else if (inherits(cond, "warning")) {
[18:05:17.490]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:17.490]                       if (muffled) 
[18:05:17.490]                         invokeRestart("muffleWarning")
[18:05:17.490]                     }
[18:05:17.490]                     else if (inherits(cond, "condition")) {
[18:05:17.490]                       if (!is.null(pattern)) {
[18:05:17.490]                         computeRestarts <- base::computeRestarts
[18:05:17.490]                         grepl <- base::grepl
[18:05:17.490]                         restarts <- computeRestarts(cond)
[18:05:17.490]                         for (restart in restarts) {
[18:05:17.490]                           name <- restart$name
[18:05:17.490]                           if (is.null(name)) 
[18:05:17.490]                             next
[18:05:17.490]                           if (!grepl(pattern, name)) 
[18:05:17.490]                             next
[18:05:17.490]                           invokeRestart(restart)
[18:05:17.490]                           muffled <- TRUE
[18:05:17.490]                           break
[18:05:17.490]                         }
[18:05:17.490]                       }
[18:05:17.490]                     }
[18:05:17.490]                     invisible(muffled)
[18:05:17.490]                   }
[18:05:17.490]                   muffleCondition(cond)
[18:05:17.490]                 })
[18:05:17.490]             }))
[18:05:17.490]             future::FutureResult(value = ...future.value$value, 
[18:05:17.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.490]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.490]                     ...future.globalenv.names))
[18:05:17.490]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.490]         }, condition = base::local({
[18:05:17.490]             c <- base::c
[18:05:17.490]             inherits <- base::inherits
[18:05:17.490]             invokeRestart <- base::invokeRestart
[18:05:17.490]             length <- base::length
[18:05:17.490]             list <- base::list
[18:05:17.490]             seq.int <- base::seq.int
[18:05:17.490]             signalCondition <- base::signalCondition
[18:05:17.490]             sys.calls <- base::sys.calls
[18:05:17.490]             `[[` <- base::`[[`
[18:05:17.490]             `+` <- base::`+`
[18:05:17.490]             `<<-` <- base::`<<-`
[18:05:17.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.490]                   3L)]
[18:05:17.490]             }
[18:05:17.490]             function(cond) {
[18:05:17.490]                 is_error <- inherits(cond, "error")
[18:05:17.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.490]                   NULL)
[18:05:17.490]                 if (is_error) {
[18:05:17.490]                   sessionInformation <- function() {
[18:05:17.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.490]                       search = base::search(), system = base::Sys.info())
[18:05:17.490]                   }
[18:05:17.490]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.490]                     cond$call), session = sessionInformation(), 
[18:05:17.490]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.490]                   signalCondition(cond)
[18:05:17.490]                 }
[18:05:17.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.490]                 "immediateCondition"))) {
[18:05:17.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.490]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.490]                   if (TRUE && !signal) {
[18:05:17.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.490]                     {
[18:05:17.490]                       inherits <- base::inherits
[18:05:17.490]                       invokeRestart <- base::invokeRestart
[18:05:17.490]                       is.null <- base::is.null
[18:05:17.490]                       muffled <- FALSE
[18:05:17.490]                       if (inherits(cond, "message")) {
[18:05:17.490]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.490]                         if (muffled) 
[18:05:17.490]                           invokeRestart("muffleMessage")
[18:05:17.490]                       }
[18:05:17.490]                       else if (inherits(cond, "warning")) {
[18:05:17.490]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.490]                         if (muffled) 
[18:05:17.490]                           invokeRestart("muffleWarning")
[18:05:17.490]                       }
[18:05:17.490]                       else if (inherits(cond, "condition")) {
[18:05:17.490]                         if (!is.null(pattern)) {
[18:05:17.490]                           computeRestarts <- base::computeRestarts
[18:05:17.490]                           grepl <- base::grepl
[18:05:17.490]                           restarts <- computeRestarts(cond)
[18:05:17.490]                           for (restart in restarts) {
[18:05:17.490]                             name <- restart$name
[18:05:17.490]                             if (is.null(name)) 
[18:05:17.490]                               next
[18:05:17.490]                             if (!grepl(pattern, name)) 
[18:05:17.490]                               next
[18:05:17.490]                             invokeRestart(restart)
[18:05:17.490]                             muffled <- TRUE
[18:05:17.490]                             break
[18:05:17.490]                           }
[18:05:17.490]                         }
[18:05:17.490]                       }
[18:05:17.490]                       invisible(muffled)
[18:05:17.490]                     }
[18:05:17.490]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.490]                   }
[18:05:17.490]                 }
[18:05:17.490]                 else {
[18:05:17.490]                   if (TRUE) {
[18:05:17.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.490]                     {
[18:05:17.490]                       inherits <- base::inherits
[18:05:17.490]                       invokeRestart <- base::invokeRestart
[18:05:17.490]                       is.null <- base::is.null
[18:05:17.490]                       muffled <- FALSE
[18:05:17.490]                       if (inherits(cond, "message")) {
[18:05:17.490]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.490]                         if (muffled) 
[18:05:17.490]                           invokeRestart("muffleMessage")
[18:05:17.490]                       }
[18:05:17.490]                       else if (inherits(cond, "warning")) {
[18:05:17.490]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.490]                         if (muffled) 
[18:05:17.490]                           invokeRestart("muffleWarning")
[18:05:17.490]                       }
[18:05:17.490]                       else if (inherits(cond, "condition")) {
[18:05:17.490]                         if (!is.null(pattern)) {
[18:05:17.490]                           computeRestarts <- base::computeRestarts
[18:05:17.490]                           grepl <- base::grepl
[18:05:17.490]                           restarts <- computeRestarts(cond)
[18:05:17.490]                           for (restart in restarts) {
[18:05:17.490]                             name <- restart$name
[18:05:17.490]                             if (is.null(name)) 
[18:05:17.490]                               next
[18:05:17.490]                             if (!grepl(pattern, name)) 
[18:05:17.490]                               next
[18:05:17.490]                             invokeRestart(restart)
[18:05:17.490]                             muffled <- TRUE
[18:05:17.490]                             break
[18:05:17.490]                           }
[18:05:17.490]                         }
[18:05:17.490]                       }
[18:05:17.490]                       invisible(muffled)
[18:05:17.490]                     }
[18:05:17.490]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.490]                   }
[18:05:17.490]                 }
[18:05:17.490]             }
[18:05:17.490]         }))
[18:05:17.490]     }, error = function(ex) {
[18:05:17.490]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.490]                 ...future.rng), started = ...future.startTime, 
[18:05:17.490]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.490]             version = "1.8"), class = "FutureResult")
[18:05:17.490]     }, finally = {
[18:05:17.490]         if (!identical(...future.workdir, getwd())) 
[18:05:17.490]             setwd(...future.workdir)
[18:05:17.490]         {
[18:05:17.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.490]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.490]             }
[18:05:17.490]             base::options(...future.oldOptions)
[18:05:17.490]             if (.Platform$OS.type == "windows") {
[18:05:17.490]                 old_names <- names(...future.oldEnvVars)
[18:05:17.490]                 envs <- base::Sys.getenv()
[18:05:17.490]                 names <- names(envs)
[18:05:17.490]                 common <- intersect(names, old_names)
[18:05:17.490]                 added <- setdiff(names, old_names)
[18:05:17.490]                 removed <- setdiff(old_names, names)
[18:05:17.490]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.490]                   envs[common]]
[18:05:17.490]                 NAMES <- toupper(changed)
[18:05:17.490]                 args <- list()
[18:05:17.490]                 for (kk in seq_along(NAMES)) {
[18:05:17.490]                   name <- changed[[kk]]
[18:05:17.490]                   NAME <- NAMES[[kk]]
[18:05:17.490]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.490]                     next
[18:05:17.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.490]                 }
[18:05:17.490]                 NAMES <- toupper(added)
[18:05:17.490]                 for (kk in seq_along(NAMES)) {
[18:05:17.490]                   name <- added[[kk]]
[18:05:17.490]                   NAME <- NAMES[[kk]]
[18:05:17.490]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.490]                     next
[18:05:17.490]                   args[[name]] <- ""
[18:05:17.490]                 }
[18:05:17.490]                 NAMES <- toupper(removed)
[18:05:17.490]                 for (kk in seq_along(NAMES)) {
[18:05:17.490]                   name <- removed[[kk]]
[18:05:17.490]                   NAME <- NAMES[[kk]]
[18:05:17.490]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.490]                     next
[18:05:17.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.490]                 }
[18:05:17.490]                 if (length(args) > 0) 
[18:05:17.490]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.490]             }
[18:05:17.490]             else {
[18:05:17.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.490]             }
[18:05:17.490]             {
[18:05:17.490]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.490]                   0L) {
[18:05:17.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.490]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.490]                   base::options(opts)
[18:05:17.490]                 }
[18:05:17.490]                 {
[18:05:17.490]                   {
[18:05:17.490]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:17.490]                     NULL
[18:05:17.490]                   }
[18:05:17.490]                   options(future.plan = NULL)
[18:05:17.490]                   if (is.na(NA_character_)) 
[18:05:17.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.490]                     .init = FALSE)
[18:05:17.490]                 }
[18:05:17.490]             }
[18:05:17.490]         }
[18:05:17.490]     })
[18:05:17.490]     if (TRUE) {
[18:05:17.490]         base::sink(type = "output", split = FALSE)
[18:05:17.490]         if (TRUE) {
[18:05:17.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.490]         }
[18:05:17.490]         else {
[18:05:17.490]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.490]         }
[18:05:17.490]         base::close(...future.stdout)
[18:05:17.490]         ...future.stdout <- NULL
[18:05:17.490]     }
[18:05:17.490]     ...future.result$conditions <- ...future.conditions
[18:05:17.490]     ...future.result$finished <- base::Sys.time()
[18:05:17.490]     ...future.result
[18:05:17.490] }
[18:05:17.590] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:05:17.591] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[18:05:17.592] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[18:05:17.592] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:05:17.593] MultisessionFuture started
 - Resolving 2 multisession futures
[18:05:17.594] result() for ClusterFuture ...
[18:05:17.594] receiveMessageFromWorker() for ClusterFuture ...
[18:05:17.594] - Validating connection of MultisessionFuture
[18:05:17.701] - received message: FutureResult
[18:05:17.701] - Received FutureResult
[18:05:17.702] - Erased future from FutureRegistry
[18:05:17.704] result() for ClusterFuture ...
[18:05:17.704] - result already collected: FutureResult
[18:05:17.704] result() for ClusterFuture ... done
[18:05:17.705] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:17.705] result() for ClusterFuture ... done
[18:05:17.705] result() for ClusterFuture ...
[18:05:17.706] - result already collected: FutureResult
[18:05:17.706] result() for ClusterFuture ... done
[18:05:17.706] result() for ClusterFuture ...
[18:05:17.707] receiveMessageFromWorker() for ClusterFuture ...
[18:05:17.707] - Validating connection of MultisessionFuture
[18:05:17.707] - received message: FutureResult
[18:05:17.708] - Received FutureResult
[18:05:17.708] - Erased future from FutureRegistry
[18:05:17.708] result() for ClusterFuture ...
[18:05:17.709] - result already collected: FutureResult
[18:05:17.709] result() for ClusterFuture ... done
[18:05:17.709] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:17.709] result() for ClusterFuture ... done
[18:05:17.710] result() for ClusterFuture ...
[18:05:17.710] - result already collected: FutureResult
[18:05:17.710] result() for ClusterFuture ... done
*** multisession() - workers inherit .libPaths()
[18:05:17.711] getGlobalsAndPackages() ...
[18:05:17.711] Searching for globals...
[18:05:17.713] - globals found: [1] ‘.libPaths’
[18:05:17.713] Searching for globals ... DONE
[18:05:17.713] Resolving globals: FALSE
[18:05:17.714] 
[18:05:17.714] 
[18:05:17.715] getGlobalsAndPackages() ... DONE
[18:05:17.715] run() for ‘Future’ ...
[18:05:17.716] - state: ‘created’
[18:05:17.716] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:17.717] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:17.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:17.717]   - Field: ‘label’
[18:05:17.718]   - Field: ‘local’
[18:05:17.718]   - Field: ‘owner’
[18:05:17.718]   - Field: ‘envir’
[18:05:17.718]   - Field: ‘packages’
[18:05:17.719]   - Field: ‘gc’
[18:05:17.719]   - Field: ‘conditions’
[18:05:17.719]   - Field: ‘expr’
[18:05:17.720]   - Field: ‘uuid’
[18:05:17.720]   - Field: ‘seed’
[18:05:17.720]   - Field: ‘version’
[18:05:17.720]   - Field: ‘result’
[18:05:17.721]   - Field: ‘asynchronous’
[18:05:17.721]   - Field: ‘calls’
[18:05:17.721]   - Field: ‘globals’
[18:05:17.722]   - Field: ‘stdout’
[18:05:17.722]   - Field: ‘earlySignal’
[18:05:17.722]   - Field: ‘lazy’
[18:05:17.722]   - Field: ‘state’
[18:05:17.723] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:17.723] - Launch lazy future ...
[18:05:17.724] Packages needed by the future expression (n = 0): <none>
[18:05:17.724] Packages needed by future strategies (n = 0): <none>
[18:05:17.725] {
[18:05:17.725]     {
[18:05:17.725]         {
[18:05:17.725]             ...future.startTime <- base::Sys.time()
[18:05:17.725]             {
[18:05:17.725]                 {
[18:05:17.725]                   {
[18:05:17.725]                     base::local({
[18:05:17.725]                       has_future <- base::requireNamespace("future", 
[18:05:17.725]                         quietly = TRUE)
[18:05:17.725]                       if (has_future) {
[18:05:17.725]                         ns <- base::getNamespace("future")
[18:05:17.725]                         version <- ns[[".package"]][["version"]]
[18:05:17.725]                         if (is.null(version)) 
[18:05:17.725]                           version <- utils::packageVersion("future")
[18:05:17.725]                       }
[18:05:17.725]                       else {
[18:05:17.725]                         version <- NULL
[18:05:17.725]                       }
[18:05:17.725]                       if (!has_future || version < "1.8.0") {
[18:05:17.725]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.725]                           "", base::R.version$version.string), 
[18:05:17.725]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:17.725]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.725]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.725]                             "release", "version")], collapse = " "), 
[18:05:17.725]                           hostname = base::Sys.info()[["nodename"]])
[18:05:17.725]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.725]                           info)
[18:05:17.725]                         info <- base::paste(info, collapse = "; ")
[18:05:17.725]                         if (!has_future) {
[18:05:17.725]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.725]                             info)
[18:05:17.725]                         }
[18:05:17.725]                         else {
[18:05:17.725]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.725]                             info, version)
[18:05:17.725]                         }
[18:05:17.725]                         base::stop(msg)
[18:05:17.725]                       }
[18:05:17.725]                     })
[18:05:17.725]                   }
[18:05:17.725]                   ...future.strategy.old <- future::plan("list")
[18:05:17.725]                   options(future.plan = NULL)
[18:05:17.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.725]                 }
[18:05:17.725]                 ...future.workdir <- getwd()
[18:05:17.725]             }
[18:05:17.725]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.725]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.725]         }
[18:05:17.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:17.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.725]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.725]             base::names(...future.oldOptions))
[18:05:17.725]     }
[18:05:17.725]     if (FALSE) {
[18:05:17.725]     }
[18:05:17.725]     else {
[18:05:17.725]         if (TRUE) {
[18:05:17.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.725]                 open = "w")
[18:05:17.725]         }
[18:05:17.725]         else {
[18:05:17.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.725]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.725]         }
[18:05:17.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.725]             base::sink(type = "output", split = FALSE)
[18:05:17.725]             base::close(...future.stdout)
[18:05:17.725]         }, add = TRUE)
[18:05:17.725]     }
[18:05:17.725]     ...future.frame <- base::sys.nframe()
[18:05:17.725]     ...future.conditions <- base::list()
[18:05:17.725]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.725]     if (FALSE) {
[18:05:17.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.725]     }
[18:05:17.725]     ...future.result <- base::tryCatch({
[18:05:17.725]         base::withCallingHandlers({
[18:05:17.725]             ...future.value <- base::withVisible(base::local(.libPaths()))
[18:05:17.725]             future::FutureResult(value = ...future.value$value, 
[18:05:17.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.725]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.725]                     ...future.globalenv.names))
[18:05:17.725]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.725]         }, condition = base::local({
[18:05:17.725]             c <- base::c
[18:05:17.725]             inherits <- base::inherits
[18:05:17.725]             invokeRestart <- base::invokeRestart
[18:05:17.725]             length <- base::length
[18:05:17.725]             list <- base::list
[18:05:17.725]             seq.int <- base::seq.int
[18:05:17.725]             signalCondition <- base::signalCondition
[18:05:17.725]             sys.calls <- base::sys.calls
[18:05:17.725]             `[[` <- base::`[[`
[18:05:17.725]             `+` <- base::`+`
[18:05:17.725]             `<<-` <- base::`<<-`
[18:05:17.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.725]                   3L)]
[18:05:17.725]             }
[18:05:17.725]             function(cond) {
[18:05:17.725]                 is_error <- inherits(cond, "error")
[18:05:17.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.725]                   NULL)
[18:05:17.725]                 if (is_error) {
[18:05:17.725]                   sessionInformation <- function() {
[18:05:17.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.725]                       search = base::search(), system = base::Sys.info())
[18:05:17.725]                   }
[18:05:17.725]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.725]                     cond$call), session = sessionInformation(), 
[18:05:17.725]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.725]                   signalCondition(cond)
[18:05:17.725]                 }
[18:05:17.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.725]                 "immediateCondition"))) {
[18:05:17.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.725]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.725]                   if (TRUE && !signal) {
[18:05:17.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.725]                     {
[18:05:17.725]                       inherits <- base::inherits
[18:05:17.725]                       invokeRestart <- base::invokeRestart
[18:05:17.725]                       is.null <- base::is.null
[18:05:17.725]                       muffled <- FALSE
[18:05:17.725]                       if (inherits(cond, "message")) {
[18:05:17.725]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.725]                         if (muffled) 
[18:05:17.725]                           invokeRestart("muffleMessage")
[18:05:17.725]                       }
[18:05:17.725]                       else if (inherits(cond, "warning")) {
[18:05:17.725]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.725]                         if (muffled) 
[18:05:17.725]                           invokeRestart("muffleWarning")
[18:05:17.725]                       }
[18:05:17.725]                       else if (inherits(cond, "condition")) {
[18:05:17.725]                         if (!is.null(pattern)) {
[18:05:17.725]                           computeRestarts <- base::computeRestarts
[18:05:17.725]                           grepl <- base::grepl
[18:05:17.725]                           restarts <- computeRestarts(cond)
[18:05:17.725]                           for (restart in restarts) {
[18:05:17.725]                             name <- restart$name
[18:05:17.725]                             if (is.null(name)) 
[18:05:17.725]                               next
[18:05:17.725]                             if (!grepl(pattern, name)) 
[18:05:17.725]                               next
[18:05:17.725]                             invokeRestart(restart)
[18:05:17.725]                             muffled <- TRUE
[18:05:17.725]                             break
[18:05:17.725]                           }
[18:05:17.725]                         }
[18:05:17.725]                       }
[18:05:17.725]                       invisible(muffled)
[18:05:17.725]                     }
[18:05:17.725]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.725]                   }
[18:05:17.725]                 }
[18:05:17.725]                 else {
[18:05:17.725]                   if (TRUE) {
[18:05:17.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.725]                     {
[18:05:17.725]                       inherits <- base::inherits
[18:05:17.725]                       invokeRestart <- base::invokeRestart
[18:05:17.725]                       is.null <- base::is.null
[18:05:17.725]                       muffled <- FALSE
[18:05:17.725]                       if (inherits(cond, "message")) {
[18:05:17.725]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.725]                         if (muffled) 
[18:05:17.725]                           invokeRestart("muffleMessage")
[18:05:17.725]                       }
[18:05:17.725]                       else if (inherits(cond, "warning")) {
[18:05:17.725]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.725]                         if (muffled) 
[18:05:17.725]                           invokeRestart("muffleWarning")
[18:05:17.725]                       }
[18:05:17.725]                       else if (inherits(cond, "condition")) {
[18:05:17.725]                         if (!is.null(pattern)) {
[18:05:17.725]                           computeRestarts <- base::computeRestarts
[18:05:17.725]                           grepl <- base::grepl
[18:05:17.725]                           restarts <- computeRestarts(cond)
[18:05:17.725]                           for (restart in restarts) {
[18:05:17.725]                             name <- restart$name
[18:05:17.725]                             if (is.null(name)) 
[18:05:17.725]                               next
[18:05:17.725]                             if (!grepl(pattern, name)) 
[18:05:17.725]                               next
[18:05:17.725]                             invokeRestart(restart)
[18:05:17.725]                             muffled <- TRUE
[18:05:17.725]                             break
[18:05:17.725]                           }
[18:05:17.725]                         }
[18:05:17.725]                       }
[18:05:17.725]                       invisible(muffled)
[18:05:17.725]                     }
[18:05:17.725]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.725]                   }
[18:05:17.725]                 }
[18:05:17.725]             }
[18:05:17.725]         }))
[18:05:17.725]     }, error = function(ex) {
[18:05:17.725]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.725]                 ...future.rng), started = ...future.startTime, 
[18:05:17.725]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.725]             version = "1.8"), class = "FutureResult")
[18:05:17.725]     }, finally = {
[18:05:17.725]         if (!identical(...future.workdir, getwd())) 
[18:05:17.725]             setwd(...future.workdir)
[18:05:17.725]         {
[18:05:17.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.725]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.725]             }
[18:05:17.725]             base::options(...future.oldOptions)
[18:05:17.725]             if (.Platform$OS.type == "windows") {
[18:05:17.725]                 old_names <- names(...future.oldEnvVars)
[18:05:17.725]                 envs <- base::Sys.getenv()
[18:05:17.725]                 names <- names(envs)
[18:05:17.725]                 common <- intersect(names, old_names)
[18:05:17.725]                 added <- setdiff(names, old_names)
[18:05:17.725]                 removed <- setdiff(old_names, names)
[18:05:17.725]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.725]                   envs[common]]
[18:05:17.725]                 NAMES <- toupper(changed)
[18:05:17.725]                 args <- list()
[18:05:17.725]                 for (kk in seq_along(NAMES)) {
[18:05:17.725]                   name <- changed[[kk]]
[18:05:17.725]                   NAME <- NAMES[[kk]]
[18:05:17.725]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.725]                     next
[18:05:17.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.725]                 }
[18:05:17.725]                 NAMES <- toupper(added)
[18:05:17.725]                 for (kk in seq_along(NAMES)) {
[18:05:17.725]                   name <- added[[kk]]
[18:05:17.725]                   NAME <- NAMES[[kk]]
[18:05:17.725]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.725]                     next
[18:05:17.725]                   args[[name]] <- ""
[18:05:17.725]                 }
[18:05:17.725]                 NAMES <- toupper(removed)
[18:05:17.725]                 for (kk in seq_along(NAMES)) {
[18:05:17.725]                   name <- removed[[kk]]
[18:05:17.725]                   NAME <- NAMES[[kk]]
[18:05:17.725]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.725]                     next
[18:05:17.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.725]                 }
[18:05:17.725]                 if (length(args) > 0) 
[18:05:17.725]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.725]             }
[18:05:17.725]             else {
[18:05:17.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.725]             }
[18:05:17.725]             {
[18:05:17.725]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.725]                   0L) {
[18:05:17.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.725]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.725]                   base::options(opts)
[18:05:17.725]                 }
[18:05:17.725]                 {
[18:05:17.725]                   {
[18:05:17.725]                     NULL
[18:05:17.725]                     RNGkind("Mersenne-Twister")
[18:05:17.725]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:17.725]                       inherits = FALSE)
[18:05:17.725]                   }
[18:05:17.725]                   options(future.plan = NULL)
[18:05:17.725]                   if (is.na(NA_character_)) 
[18:05:17.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.725]                     .init = FALSE)
[18:05:17.725]                 }
[18:05:17.725]             }
[18:05:17.725]         }
[18:05:17.725]     })
[18:05:17.725]     if (TRUE) {
[18:05:17.725]         base::sink(type = "output", split = FALSE)
[18:05:17.725]         if (TRUE) {
[18:05:17.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.725]         }
[18:05:17.725]         else {
[18:05:17.725]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.725]         }
[18:05:17.725]         base::close(...future.stdout)
[18:05:17.725]         ...future.stdout <- NULL
[18:05:17.725]     }
[18:05:17.725]     ...future.result$conditions <- ...future.conditions
[18:05:17.725]     ...future.result$finished <- base::Sys.time()
[18:05:17.725]     ...future.result
[18:05:17.725] }
[18:05:17.729] plan(): Setting new future strategy stack:
[18:05:17.730] List of future strategies:
[18:05:17.730] 1. sequential:
[18:05:17.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:17.730]    - tweaked: FALSE
[18:05:17.730]    - call: NULL
[18:05:17.731] plan(): nbrOfWorkers() = 1
[18:05:17.736] plan(): Setting new future strategy stack:
[18:05:17.736] List of future strategies:
[18:05:17.736] 1. sequential:
[18:05:17.736]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:17.736]    - tweaked: FALSE
[18:05:17.736]    - call: future::plan("sequential")
[18:05:17.737] plan(): nbrOfWorkers() = 1
[18:05:17.738] SequentialFuture started (and completed)
[18:05:17.738] - Launch lazy future ... done
[18:05:17.738] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[18:05:17.746] getGlobalsAndPackages() ...
[18:05:17.746] 
[18:05:17.746] - globals: [0] <none>
[18:05:17.746] getGlobalsAndPackages() ... DONE
[18:05:17.764] Packages needed by the future expression (n = 0): <none>
[18:05:17.764] Packages needed by future strategies (n = 0): <none>
[18:05:17.765] {
[18:05:17.765]     {
[18:05:17.765]         {
[18:05:17.765]             ...future.startTime <- base::Sys.time()
[18:05:17.765]             {
[18:05:17.765]                 {
[18:05:17.765]                   {
[18:05:17.765]                     {
[18:05:17.765]                       base::local({
[18:05:17.765]                         has_future <- base::requireNamespace("future", 
[18:05:17.765]                           quietly = TRUE)
[18:05:17.765]                         if (has_future) {
[18:05:17.765]                           ns <- base::getNamespace("future")
[18:05:17.765]                           version <- ns[[".package"]][["version"]]
[18:05:17.765]                           if (is.null(version)) 
[18:05:17.765]                             version <- utils::packageVersion("future")
[18:05:17.765]                         }
[18:05:17.765]                         else {
[18:05:17.765]                           version <- NULL
[18:05:17.765]                         }
[18:05:17.765]                         if (!has_future || version < "1.8.0") {
[18:05:17.765]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.765]                             "", base::R.version$version.string), 
[18:05:17.765]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:17.765]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.765]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.765]                               "release", "version")], collapse = " "), 
[18:05:17.765]                             hostname = base::Sys.info()[["nodename"]])
[18:05:17.765]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.765]                             info)
[18:05:17.765]                           info <- base::paste(info, collapse = "; ")
[18:05:17.765]                           if (!has_future) {
[18:05:17.765]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.765]                               info)
[18:05:17.765]                           }
[18:05:17.765]                           else {
[18:05:17.765]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.765]                               info, version)
[18:05:17.765]                           }
[18:05:17.765]                           base::stop(msg)
[18:05:17.765]                         }
[18:05:17.765]                       })
[18:05:17.765]                     }
[18:05:17.765]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:17.765]                     base::options(mc.cores = 1L)
[18:05:17.765]                   }
[18:05:17.765]                   ...future.strategy.old <- future::plan("list")
[18:05:17.765]                   options(future.plan = NULL)
[18:05:17.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.765]                 }
[18:05:17.765]                 ...future.workdir <- getwd()
[18:05:17.765]             }
[18:05:17.765]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.765]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.765]         }
[18:05:17.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.765]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:17.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.765]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.765]             base::names(...future.oldOptions))
[18:05:17.765]     }
[18:05:17.765]     if (FALSE) {
[18:05:17.765]     }
[18:05:17.765]     else {
[18:05:17.765]         if (TRUE) {
[18:05:17.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.765]                 open = "w")
[18:05:17.765]         }
[18:05:17.765]         else {
[18:05:17.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.765]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.765]         }
[18:05:17.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.765]             base::sink(type = "output", split = FALSE)
[18:05:17.765]             base::close(...future.stdout)
[18:05:17.765]         }, add = TRUE)
[18:05:17.765]     }
[18:05:17.765]     ...future.frame <- base::sys.nframe()
[18:05:17.765]     ...future.conditions <- base::list()
[18:05:17.765]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.765]     if (FALSE) {
[18:05:17.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.765]     }
[18:05:17.765]     ...future.result <- base::tryCatch({
[18:05:17.765]         base::withCallingHandlers({
[18:05:17.765]             ...future.value <- base::withVisible(base::local({
[18:05:17.765]                 ...future.makeSendCondition <- base::local({
[18:05:17.765]                   sendCondition <- NULL
[18:05:17.765]                   function(frame = 1L) {
[18:05:17.765]                     if (is.function(sendCondition)) 
[18:05:17.765]                       return(sendCondition)
[18:05:17.765]                     ns <- getNamespace("parallel")
[18:05:17.765]                     if (exists("sendData", mode = "function", 
[18:05:17.765]                       envir = ns)) {
[18:05:17.765]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:17.765]                         envir = ns)
[18:05:17.765]                       envir <- sys.frame(frame)
[18:05:17.765]                       master <- NULL
[18:05:17.765]                       while (!identical(envir, .GlobalEnv) && 
[18:05:17.765]                         !identical(envir, emptyenv())) {
[18:05:17.765]                         if (exists("master", mode = "list", envir = envir, 
[18:05:17.765]                           inherits = FALSE)) {
[18:05:17.765]                           master <- get("master", mode = "list", 
[18:05:17.765]                             envir = envir, inherits = FALSE)
[18:05:17.765]                           if (inherits(master, c("SOCKnode", 
[18:05:17.765]                             "SOCK0node"))) {
[18:05:17.765]                             sendCondition <<- function(cond) {
[18:05:17.765]                               data <- list(type = "VALUE", value = cond, 
[18:05:17.765]                                 success = TRUE)
[18:05:17.765]                               parallel_sendData(master, data)
[18:05:17.765]                             }
[18:05:17.765]                             return(sendCondition)
[18:05:17.765]                           }
[18:05:17.765]                         }
[18:05:17.765]                         frame <- frame + 1L
[18:05:17.765]                         envir <- sys.frame(frame)
[18:05:17.765]                       }
[18:05:17.765]                     }
[18:05:17.765]                     sendCondition <<- function(cond) NULL
[18:05:17.765]                   }
[18:05:17.765]                 })
[18:05:17.765]                 withCallingHandlers({
[18:05:17.765]                   {
[18:05:17.765]                     stop("Whoops!")
[18:05:17.765]                     1
[18:05:17.765]                   }
[18:05:17.765]                 }, immediateCondition = function(cond) {
[18:05:17.765]                   sendCondition <- ...future.makeSendCondition()
[18:05:17.765]                   sendCondition(cond)
[18:05:17.765]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.765]                   {
[18:05:17.765]                     inherits <- base::inherits
[18:05:17.765]                     invokeRestart <- base::invokeRestart
[18:05:17.765]                     is.null <- base::is.null
[18:05:17.765]                     muffled <- FALSE
[18:05:17.765]                     if (inherits(cond, "message")) {
[18:05:17.765]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:17.765]                       if (muffled) 
[18:05:17.765]                         invokeRestart("muffleMessage")
[18:05:17.765]                     }
[18:05:17.765]                     else if (inherits(cond, "warning")) {
[18:05:17.765]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:17.765]                       if (muffled) 
[18:05:17.765]                         invokeRestart("muffleWarning")
[18:05:17.765]                     }
[18:05:17.765]                     else if (inherits(cond, "condition")) {
[18:05:17.765]                       if (!is.null(pattern)) {
[18:05:17.765]                         computeRestarts <- base::computeRestarts
[18:05:17.765]                         grepl <- base::grepl
[18:05:17.765]                         restarts <- computeRestarts(cond)
[18:05:17.765]                         for (restart in restarts) {
[18:05:17.765]                           name <- restart$name
[18:05:17.765]                           if (is.null(name)) 
[18:05:17.765]                             next
[18:05:17.765]                           if (!grepl(pattern, name)) 
[18:05:17.765]                             next
[18:05:17.765]                           invokeRestart(restart)
[18:05:17.765]                           muffled <- TRUE
[18:05:17.765]                           break
[18:05:17.765]                         }
[18:05:17.765]                       }
[18:05:17.765]                     }
[18:05:17.765]                     invisible(muffled)
[18:05:17.765]                   }
[18:05:17.765]                   muffleCondition(cond)
[18:05:17.765]                 })
[18:05:17.765]             }))
[18:05:17.765]             future::FutureResult(value = ...future.value$value, 
[18:05:17.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.765]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.765]                     ...future.globalenv.names))
[18:05:17.765]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.765]         }, condition = base::local({
[18:05:17.765]             c <- base::c
[18:05:17.765]             inherits <- base::inherits
[18:05:17.765]             invokeRestart <- base::invokeRestart
[18:05:17.765]             length <- base::length
[18:05:17.765]             list <- base::list
[18:05:17.765]             seq.int <- base::seq.int
[18:05:17.765]             signalCondition <- base::signalCondition
[18:05:17.765]             sys.calls <- base::sys.calls
[18:05:17.765]             `[[` <- base::`[[`
[18:05:17.765]             `+` <- base::`+`
[18:05:17.765]             `<<-` <- base::`<<-`
[18:05:17.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.765]                   3L)]
[18:05:17.765]             }
[18:05:17.765]             function(cond) {
[18:05:17.765]                 is_error <- inherits(cond, "error")
[18:05:17.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.765]                   NULL)
[18:05:17.765]                 if (is_error) {
[18:05:17.765]                   sessionInformation <- function() {
[18:05:17.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.765]                       search = base::search(), system = base::Sys.info())
[18:05:17.765]                   }
[18:05:17.765]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.765]                     cond$call), session = sessionInformation(), 
[18:05:17.765]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.765]                   signalCondition(cond)
[18:05:17.765]                 }
[18:05:17.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.765]                 "immediateCondition"))) {
[18:05:17.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.765]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.765]                   if (TRUE && !signal) {
[18:05:17.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.765]                     {
[18:05:17.765]                       inherits <- base::inherits
[18:05:17.765]                       invokeRestart <- base::invokeRestart
[18:05:17.765]                       is.null <- base::is.null
[18:05:17.765]                       muffled <- FALSE
[18:05:17.765]                       if (inherits(cond, "message")) {
[18:05:17.765]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.765]                         if (muffled) 
[18:05:17.765]                           invokeRestart("muffleMessage")
[18:05:17.765]                       }
[18:05:17.765]                       else if (inherits(cond, "warning")) {
[18:05:17.765]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.765]                         if (muffled) 
[18:05:17.765]                           invokeRestart("muffleWarning")
[18:05:17.765]                       }
[18:05:17.765]                       else if (inherits(cond, "condition")) {
[18:05:17.765]                         if (!is.null(pattern)) {
[18:05:17.765]                           computeRestarts <- base::computeRestarts
[18:05:17.765]                           grepl <- base::grepl
[18:05:17.765]                           restarts <- computeRestarts(cond)
[18:05:17.765]                           for (restart in restarts) {
[18:05:17.765]                             name <- restart$name
[18:05:17.765]                             if (is.null(name)) 
[18:05:17.765]                               next
[18:05:17.765]                             if (!grepl(pattern, name)) 
[18:05:17.765]                               next
[18:05:17.765]                             invokeRestart(restart)
[18:05:17.765]                             muffled <- TRUE
[18:05:17.765]                             break
[18:05:17.765]                           }
[18:05:17.765]                         }
[18:05:17.765]                       }
[18:05:17.765]                       invisible(muffled)
[18:05:17.765]                     }
[18:05:17.765]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.765]                   }
[18:05:17.765]                 }
[18:05:17.765]                 else {
[18:05:17.765]                   if (TRUE) {
[18:05:17.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.765]                     {
[18:05:17.765]                       inherits <- base::inherits
[18:05:17.765]                       invokeRestart <- base::invokeRestart
[18:05:17.765]                       is.null <- base::is.null
[18:05:17.765]                       muffled <- FALSE
[18:05:17.765]                       if (inherits(cond, "message")) {
[18:05:17.765]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.765]                         if (muffled) 
[18:05:17.765]                           invokeRestart("muffleMessage")
[18:05:17.765]                       }
[18:05:17.765]                       else if (inherits(cond, "warning")) {
[18:05:17.765]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.765]                         if (muffled) 
[18:05:17.765]                           invokeRestart("muffleWarning")
[18:05:17.765]                       }
[18:05:17.765]                       else if (inherits(cond, "condition")) {
[18:05:17.765]                         if (!is.null(pattern)) {
[18:05:17.765]                           computeRestarts <- base::computeRestarts
[18:05:17.765]                           grepl <- base::grepl
[18:05:17.765]                           restarts <- computeRestarts(cond)
[18:05:17.765]                           for (restart in restarts) {
[18:05:17.765]                             name <- restart$name
[18:05:17.765]                             if (is.null(name)) 
[18:05:17.765]                               next
[18:05:17.765]                             if (!grepl(pattern, name)) 
[18:05:17.765]                               next
[18:05:17.765]                             invokeRestart(restart)
[18:05:17.765]                             muffled <- TRUE
[18:05:17.765]                             break
[18:05:17.765]                           }
[18:05:17.765]                         }
[18:05:17.765]                       }
[18:05:17.765]                       invisible(muffled)
[18:05:17.765]                     }
[18:05:17.765]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.765]                   }
[18:05:17.765]                 }
[18:05:17.765]             }
[18:05:17.765]         }))
[18:05:17.765]     }, error = function(ex) {
[18:05:17.765]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.765]                 ...future.rng), started = ...future.startTime, 
[18:05:17.765]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.765]             version = "1.8"), class = "FutureResult")
[18:05:17.765]     }, finally = {
[18:05:17.765]         if (!identical(...future.workdir, getwd())) 
[18:05:17.765]             setwd(...future.workdir)
[18:05:17.765]         {
[18:05:17.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.765]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.765]             }
[18:05:17.765]             base::options(...future.oldOptions)
[18:05:17.765]             if (.Platform$OS.type == "windows") {
[18:05:17.765]                 old_names <- names(...future.oldEnvVars)
[18:05:17.765]                 envs <- base::Sys.getenv()
[18:05:17.765]                 names <- names(envs)
[18:05:17.765]                 common <- intersect(names, old_names)
[18:05:17.765]                 added <- setdiff(names, old_names)
[18:05:17.765]                 removed <- setdiff(old_names, names)
[18:05:17.765]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.765]                   envs[common]]
[18:05:17.765]                 NAMES <- toupper(changed)
[18:05:17.765]                 args <- list()
[18:05:17.765]                 for (kk in seq_along(NAMES)) {
[18:05:17.765]                   name <- changed[[kk]]
[18:05:17.765]                   NAME <- NAMES[[kk]]
[18:05:17.765]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.765]                     next
[18:05:17.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.765]                 }
[18:05:17.765]                 NAMES <- toupper(added)
[18:05:17.765]                 for (kk in seq_along(NAMES)) {
[18:05:17.765]                   name <- added[[kk]]
[18:05:17.765]                   NAME <- NAMES[[kk]]
[18:05:17.765]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.765]                     next
[18:05:17.765]                   args[[name]] <- ""
[18:05:17.765]                 }
[18:05:17.765]                 NAMES <- toupper(removed)
[18:05:17.765]                 for (kk in seq_along(NAMES)) {
[18:05:17.765]                   name <- removed[[kk]]
[18:05:17.765]                   NAME <- NAMES[[kk]]
[18:05:17.765]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.765]                     next
[18:05:17.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.765]                 }
[18:05:17.765]                 if (length(args) > 0) 
[18:05:17.765]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.765]             }
[18:05:17.765]             else {
[18:05:17.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.765]             }
[18:05:17.765]             {
[18:05:17.765]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.765]                   0L) {
[18:05:17.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.765]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.765]                   base::options(opts)
[18:05:17.765]                 }
[18:05:17.765]                 {
[18:05:17.765]                   {
[18:05:17.765]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:17.765]                     NULL
[18:05:17.765]                   }
[18:05:17.765]                   options(future.plan = NULL)
[18:05:17.765]                   if (is.na(NA_character_)) 
[18:05:17.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.765]                     .init = FALSE)
[18:05:17.765]                 }
[18:05:17.765]             }
[18:05:17.765]         }
[18:05:17.765]     })
[18:05:17.765]     if (TRUE) {
[18:05:17.765]         base::sink(type = "output", split = FALSE)
[18:05:17.765]         if (TRUE) {
[18:05:17.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.765]         }
[18:05:17.765]         else {
[18:05:17.765]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.765]         }
[18:05:17.765]         base::close(...future.stdout)
[18:05:17.765]         ...future.stdout <- NULL
[18:05:17.765]     }
[18:05:17.765]     ...future.result$conditions <- ...future.conditions
[18:05:17.765]     ...future.result$finished <- base::Sys.time()
[18:05:17.765]     ...future.result
[18:05:17.765] }
[18:05:17.770] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:17.782] result() for ClusterFuture ...
[18:05:17.783] receiveMessageFromWorker() for ClusterFuture ...
[18:05:17.783] - Validating connection of MultisessionFuture
[18:05:17.816] - received message: FutureResult
[18:05:17.816] - Received FutureResult
[18:05:17.817] - Erased future from FutureRegistry
[18:05:17.817] result() for ClusterFuture ...
[18:05:17.817] - result already collected: FutureResult
[18:05:17.817] result() for ClusterFuture ... done
[18:05:17.818] signalConditions() ...
[18:05:17.818]  - include = ‘immediateCondition’
[18:05:17.818]  - exclude = 
[18:05:17.818]  - resignal = FALSE
[18:05:17.818]  - Number of conditions: 1
[18:05:17.819] signalConditions() ... done
[18:05:17.819] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:17.819] result() for ClusterFuture ... done
[18:05:17.819] result() for ClusterFuture ...
[18:05:17.820] - result already collected: FutureResult
[18:05:17.820] result() for ClusterFuture ... done
[18:05:17.820] signalConditions() ...
[18:05:17.820]  - include = ‘immediateCondition’
[18:05:17.820]  - exclude = 
[18:05:17.821]  - resignal = FALSE
[18:05:17.821]  - Number of conditions: 1
[18:05:17.821] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[18:05:17.822] result() for ClusterFuture ...
[18:05:17.822] - result already collected: FutureResult
[18:05:17.822] result() for ClusterFuture ... done
[18:05:17.823] result() for ClusterFuture ...
[18:05:17.823] - result already collected: FutureResult
[18:05:17.823] result() for ClusterFuture ... done
[18:05:17.823] signalConditions() ...
[18:05:17.823]  - include = ‘immediateCondition’
[18:05:17.824]  - exclude = 
[18:05:17.824]  - resignal = FALSE
[18:05:17.824]  - Number of conditions: 1
[18:05:17.824] signalConditions() ... done
[18:05:17.825] Future state: ‘finished’
[18:05:17.825] result() for ClusterFuture ...
[18:05:17.825] - result already collected: FutureResult
[18:05:17.825] result() for ClusterFuture ... done
[18:05:17.825] signalConditions() ...
[18:05:17.826]  - include = ‘condition’
[18:05:17.826]  - exclude = ‘immediateCondition’
[18:05:17.826]  - resignal = TRUE
[18:05:17.826]  - Number of conditions: 1
[18:05:17.827]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:17.827] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[18:05:17.828] result() for ClusterFuture ...
[18:05:17.828] - result already collected: FutureResult
[18:05:17.828] result() for ClusterFuture ... done
[18:05:17.829] result() for ClusterFuture ...
[18:05:17.829] - result already collected: FutureResult
[18:05:17.829] result() for ClusterFuture ... done
[18:05:17.829] signalConditions() ...
[18:05:17.829]  - include = ‘immediateCondition’
[18:05:17.830]  - exclude = 
[18:05:17.830]  - resignal = FALSE
[18:05:17.830]  - Number of conditions: 1
[18:05:17.830] signalConditions() ... done
[18:05:17.831] Future state: ‘finished’
[18:05:17.831] result() for ClusterFuture ...
[18:05:17.831] - result already collected: FutureResult
[18:05:17.831] result() for ClusterFuture ... done
[18:05:17.832] signalConditions() ...
[18:05:17.832]  - include = ‘condition’
[18:05:17.832]  - exclude = ‘immediateCondition’
[18:05:17.832]  - resignal = TRUE
[18:05:17.832]  - Number of conditions: 1
[18:05:17.833]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:17.833] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[18:05:17.840] getGlobalsAndPackages() ...
[18:05:17.841] 
[18:05:17.841] - globals: [0] <none>
[18:05:17.841] getGlobalsAndPackages() ... DONE
[18:05:17.862] Packages needed by the future expression (n = 0): <none>
[18:05:17.862] Packages needed by future strategies (n = 0): <none>
[18:05:17.863] {
[18:05:17.863]     {
[18:05:17.863]         {
[18:05:17.863]             ...future.startTime <- base::Sys.time()
[18:05:17.863]             {
[18:05:17.863]                 {
[18:05:17.863]                   {
[18:05:17.863]                     {
[18:05:17.863]                       base::local({
[18:05:17.863]                         has_future <- base::requireNamespace("future", 
[18:05:17.863]                           quietly = TRUE)
[18:05:17.863]                         if (has_future) {
[18:05:17.863]                           ns <- base::getNamespace("future")
[18:05:17.863]                           version <- ns[[".package"]][["version"]]
[18:05:17.863]                           if (is.null(version)) 
[18:05:17.863]                             version <- utils::packageVersion("future")
[18:05:17.863]                         }
[18:05:17.863]                         else {
[18:05:17.863]                           version <- NULL
[18:05:17.863]                         }
[18:05:17.863]                         if (!has_future || version < "1.8.0") {
[18:05:17.863]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.863]                             "", base::R.version$version.string), 
[18:05:17.863]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:17.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.863]                               "release", "version")], collapse = " "), 
[18:05:17.863]                             hostname = base::Sys.info()[["nodename"]])
[18:05:17.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.863]                             info)
[18:05:17.863]                           info <- base::paste(info, collapse = "; ")
[18:05:17.863]                           if (!has_future) {
[18:05:17.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.863]                               info)
[18:05:17.863]                           }
[18:05:17.863]                           else {
[18:05:17.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.863]                               info, version)
[18:05:17.863]                           }
[18:05:17.863]                           base::stop(msg)
[18:05:17.863]                         }
[18:05:17.863]                       })
[18:05:17.863]                     }
[18:05:17.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:17.863]                     base::options(mc.cores = 1L)
[18:05:17.863]                   }
[18:05:17.863]                   ...future.strategy.old <- future::plan("list")
[18:05:17.863]                   options(future.plan = NULL)
[18:05:17.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.863]                 }
[18:05:17.863]                 ...future.workdir <- getwd()
[18:05:17.863]             }
[18:05:17.863]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.863]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.863]         }
[18:05:17.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:17.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.863]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.863]             base::names(...future.oldOptions))
[18:05:17.863]     }
[18:05:17.863]     if (FALSE) {
[18:05:17.863]     }
[18:05:17.863]     else {
[18:05:17.863]         if (TRUE) {
[18:05:17.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.863]                 open = "w")
[18:05:17.863]         }
[18:05:17.863]         else {
[18:05:17.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.863]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.863]         }
[18:05:17.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.863]             base::sink(type = "output", split = FALSE)
[18:05:17.863]             base::close(...future.stdout)
[18:05:17.863]         }, add = TRUE)
[18:05:17.863]     }
[18:05:17.863]     ...future.frame <- base::sys.nframe()
[18:05:17.863]     ...future.conditions <- base::list()
[18:05:17.863]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.863]     if (FALSE) {
[18:05:17.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.863]     }
[18:05:17.863]     ...future.result <- base::tryCatch({
[18:05:17.863]         base::withCallingHandlers({
[18:05:17.863]             ...future.value <- base::withVisible(base::local({
[18:05:17.863]                 ...future.makeSendCondition <- base::local({
[18:05:17.863]                   sendCondition <- NULL
[18:05:17.863]                   function(frame = 1L) {
[18:05:17.863]                     if (is.function(sendCondition)) 
[18:05:17.863]                       return(sendCondition)
[18:05:17.863]                     ns <- getNamespace("parallel")
[18:05:17.863]                     if (exists("sendData", mode = "function", 
[18:05:17.863]                       envir = ns)) {
[18:05:17.863]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:17.863]                         envir = ns)
[18:05:17.863]                       envir <- sys.frame(frame)
[18:05:17.863]                       master <- NULL
[18:05:17.863]                       while (!identical(envir, .GlobalEnv) && 
[18:05:17.863]                         !identical(envir, emptyenv())) {
[18:05:17.863]                         if (exists("master", mode = "list", envir = envir, 
[18:05:17.863]                           inherits = FALSE)) {
[18:05:17.863]                           master <- get("master", mode = "list", 
[18:05:17.863]                             envir = envir, inherits = FALSE)
[18:05:17.863]                           if (inherits(master, c("SOCKnode", 
[18:05:17.863]                             "SOCK0node"))) {
[18:05:17.863]                             sendCondition <<- function(cond) {
[18:05:17.863]                               data <- list(type = "VALUE", value = cond, 
[18:05:17.863]                                 success = TRUE)
[18:05:17.863]                               parallel_sendData(master, data)
[18:05:17.863]                             }
[18:05:17.863]                             return(sendCondition)
[18:05:17.863]                           }
[18:05:17.863]                         }
[18:05:17.863]                         frame <- frame + 1L
[18:05:17.863]                         envir <- sys.frame(frame)
[18:05:17.863]                       }
[18:05:17.863]                     }
[18:05:17.863]                     sendCondition <<- function(cond) NULL
[18:05:17.863]                   }
[18:05:17.863]                 })
[18:05:17.863]                 withCallingHandlers({
[18:05:17.863]                   {
[18:05:17.863]                     stop(structure(list(message = "boom"), class = c("MyError", 
[18:05:17.863]                       "error", "condition")))
[18:05:17.863]                   }
[18:05:17.863]                 }, immediateCondition = function(cond) {
[18:05:17.863]                   sendCondition <- ...future.makeSendCondition()
[18:05:17.863]                   sendCondition(cond)
[18:05:17.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.863]                   {
[18:05:17.863]                     inherits <- base::inherits
[18:05:17.863]                     invokeRestart <- base::invokeRestart
[18:05:17.863]                     is.null <- base::is.null
[18:05:17.863]                     muffled <- FALSE
[18:05:17.863]                     if (inherits(cond, "message")) {
[18:05:17.863]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:17.863]                       if (muffled) 
[18:05:17.863]                         invokeRestart("muffleMessage")
[18:05:17.863]                     }
[18:05:17.863]                     else if (inherits(cond, "warning")) {
[18:05:17.863]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:17.863]                       if (muffled) 
[18:05:17.863]                         invokeRestart("muffleWarning")
[18:05:17.863]                     }
[18:05:17.863]                     else if (inherits(cond, "condition")) {
[18:05:17.863]                       if (!is.null(pattern)) {
[18:05:17.863]                         computeRestarts <- base::computeRestarts
[18:05:17.863]                         grepl <- base::grepl
[18:05:17.863]                         restarts <- computeRestarts(cond)
[18:05:17.863]                         for (restart in restarts) {
[18:05:17.863]                           name <- restart$name
[18:05:17.863]                           if (is.null(name)) 
[18:05:17.863]                             next
[18:05:17.863]                           if (!grepl(pattern, name)) 
[18:05:17.863]                             next
[18:05:17.863]                           invokeRestart(restart)
[18:05:17.863]                           muffled <- TRUE
[18:05:17.863]                           break
[18:05:17.863]                         }
[18:05:17.863]                       }
[18:05:17.863]                     }
[18:05:17.863]                     invisible(muffled)
[18:05:17.863]                   }
[18:05:17.863]                   muffleCondition(cond)
[18:05:17.863]                 })
[18:05:17.863]             }))
[18:05:17.863]             future::FutureResult(value = ...future.value$value, 
[18:05:17.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.863]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.863]                     ...future.globalenv.names))
[18:05:17.863]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.863]         }, condition = base::local({
[18:05:17.863]             c <- base::c
[18:05:17.863]             inherits <- base::inherits
[18:05:17.863]             invokeRestart <- base::invokeRestart
[18:05:17.863]             length <- base::length
[18:05:17.863]             list <- base::list
[18:05:17.863]             seq.int <- base::seq.int
[18:05:17.863]             signalCondition <- base::signalCondition
[18:05:17.863]             sys.calls <- base::sys.calls
[18:05:17.863]             `[[` <- base::`[[`
[18:05:17.863]             `+` <- base::`+`
[18:05:17.863]             `<<-` <- base::`<<-`
[18:05:17.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.863]                   3L)]
[18:05:17.863]             }
[18:05:17.863]             function(cond) {
[18:05:17.863]                 is_error <- inherits(cond, "error")
[18:05:17.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.863]                   NULL)
[18:05:17.863]                 if (is_error) {
[18:05:17.863]                   sessionInformation <- function() {
[18:05:17.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.863]                       search = base::search(), system = base::Sys.info())
[18:05:17.863]                   }
[18:05:17.863]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.863]                     cond$call), session = sessionInformation(), 
[18:05:17.863]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.863]                   signalCondition(cond)
[18:05:17.863]                 }
[18:05:17.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.863]                 "immediateCondition"))) {
[18:05:17.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.863]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.863]                   if (TRUE && !signal) {
[18:05:17.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.863]                     {
[18:05:17.863]                       inherits <- base::inherits
[18:05:17.863]                       invokeRestart <- base::invokeRestart
[18:05:17.863]                       is.null <- base::is.null
[18:05:17.863]                       muffled <- FALSE
[18:05:17.863]                       if (inherits(cond, "message")) {
[18:05:17.863]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.863]                         if (muffled) 
[18:05:17.863]                           invokeRestart("muffleMessage")
[18:05:17.863]                       }
[18:05:17.863]                       else if (inherits(cond, "warning")) {
[18:05:17.863]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.863]                         if (muffled) 
[18:05:17.863]                           invokeRestart("muffleWarning")
[18:05:17.863]                       }
[18:05:17.863]                       else if (inherits(cond, "condition")) {
[18:05:17.863]                         if (!is.null(pattern)) {
[18:05:17.863]                           computeRestarts <- base::computeRestarts
[18:05:17.863]                           grepl <- base::grepl
[18:05:17.863]                           restarts <- computeRestarts(cond)
[18:05:17.863]                           for (restart in restarts) {
[18:05:17.863]                             name <- restart$name
[18:05:17.863]                             if (is.null(name)) 
[18:05:17.863]                               next
[18:05:17.863]                             if (!grepl(pattern, name)) 
[18:05:17.863]                               next
[18:05:17.863]                             invokeRestart(restart)
[18:05:17.863]                             muffled <- TRUE
[18:05:17.863]                             break
[18:05:17.863]                           }
[18:05:17.863]                         }
[18:05:17.863]                       }
[18:05:17.863]                       invisible(muffled)
[18:05:17.863]                     }
[18:05:17.863]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.863]                   }
[18:05:17.863]                 }
[18:05:17.863]                 else {
[18:05:17.863]                   if (TRUE) {
[18:05:17.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.863]                     {
[18:05:17.863]                       inherits <- base::inherits
[18:05:17.863]                       invokeRestart <- base::invokeRestart
[18:05:17.863]                       is.null <- base::is.null
[18:05:17.863]                       muffled <- FALSE
[18:05:17.863]                       if (inherits(cond, "message")) {
[18:05:17.863]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.863]                         if (muffled) 
[18:05:17.863]                           invokeRestart("muffleMessage")
[18:05:17.863]                       }
[18:05:17.863]                       else if (inherits(cond, "warning")) {
[18:05:17.863]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.863]                         if (muffled) 
[18:05:17.863]                           invokeRestart("muffleWarning")
[18:05:17.863]                       }
[18:05:17.863]                       else if (inherits(cond, "condition")) {
[18:05:17.863]                         if (!is.null(pattern)) {
[18:05:17.863]                           computeRestarts <- base::computeRestarts
[18:05:17.863]                           grepl <- base::grepl
[18:05:17.863]                           restarts <- computeRestarts(cond)
[18:05:17.863]                           for (restart in restarts) {
[18:05:17.863]                             name <- restart$name
[18:05:17.863]                             if (is.null(name)) 
[18:05:17.863]                               next
[18:05:17.863]                             if (!grepl(pattern, name)) 
[18:05:17.863]                               next
[18:05:17.863]                             invokeRestart(restart)
[18:05:17.863]                             muffled <- TRUE
[18:05:17.863]                             break
[18:05:17.863]                           }
[18:05:17.863]                         }
[18:05:17.863]                       }
[18:05:17.863]                       invisible(muffled)
[18:05:17.863]                     }
[18:05:17.863]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.863]                   }
[18:05:17.863]                 }
[18:05:17.863]             }
[18:05:17.863]         }))
[18:05:17.863]     }, error = function(ex) {
[18:05:17.863]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.863]                 ...future.rng), started = ...future.startTime, 
[18:05:17.863]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.863]             version = "1.8"), class = "FutureResult")
[18:05:17.863]     }, finally = {
[18:05:17.863]         if (!identical(...future.workdir, getwd())) 
[18:05:17.863]             setwd(...future.workdir)
[18:05:17.863]         {
[18:05:17.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.863]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.863]             }
[18:05:17.863]             base::options(...future.oldOptions)
[18:05:17.863]             if (.Platform$OS.type == "windows") {
[18:05:17.863]                 old_names <- names(...future.oldEnvVars)
[18:05:17.863]                 envs <- base::Sys.getenv()
[18:05:17.863]                 names <- names(envs)
[18:05:17.863]                 common <- intersect(names, old_names)
[18:05:17.863]                 added <- setdiff(names, old_names)
[18:05:17.863]                 removed <- setdiff(old_names, names)
[18:05:17.863]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.863]                   envs[common]]
[18:05:17.863]                 NAMES <- toupper(changed)
[18:05:17.863]                 args <- list()
[18:05:17.863]                 for (kk in seq_along(NAMES)) {
[18:05:17.863]                   name <- changed[[kk]]
[18:05:17.863]                   NAME <- NAMES[[kk]]
[18:05:17.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.863]                     next
[18:05:17.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.863]                 }
[18:05:17.863]                 NAMES <- toupper(added)
[18:05:17.863]                 for (kk in seq_along(NAMES)) {
[18:05:17.863]                   name <- added[[kk]]
[18:05:17.863]                   NAME <- NAMES[[kk]]
[18:05:17.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.863]                     next
[18:05:17.863]                   args[[name]] <- ""
[18:05:17.863]                 }
[18:05:17.863]                 NAMES <- toupper(removed)
[18:05:17.863]                 for (kk in seq_along(NAMES)) {
[18:05:17.863]                   name <- removed[[kk]]
[18:05:17.863]                   NAME <- NAMES[[kk]]
[18:05:17.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.863]                     next
[18:05:17.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.863]                 }
[18:05:17.863]                 if (length(args) > 0) 
[18:05:17.863]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.863]             }
[18:05:17.863]             else {
[18:05:17.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.863]             }
[18:05:17.863]             {
[18:05:17.863]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.863]                   0L) {
[18:05:17.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.863]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.863]                   base::options(opts)
[18:05:17.863]                 }
[18:05:17.863]                 {
[18:05:17.863]                   {
[18:05:17.863]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:17.863]                     NULL
[18:05:17.863]                   }
[18:05:17.863]                   options(future.plan = NULL)
[18:05:17.863]                   if (is.na(NA_character_)) 
[18:05:17.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.863]                     .init = FALSE)
[18:05:17.863]                 }
[18:05:17.863]             }
[18:05:17.863]         }
[18:05:17.863]     })
[18:05:17.863]     if (TRUE) {
[18:05:17.863]         base::sink(type = "output", split = FALSE)
[18:05:17.863]         if (TRUE) {
[18:05:17.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.863]         }
[18:05:17.863]         else {
[18:05:17.863]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.863]         }
[18:05:17.863]         base::close(...future.stdout)
[18:05:17.863]         ...future.stdout <- NULL
[18:05:17.863]     }
[18:05:17.863]     ...future.result$conditions <- ...future.conditions
[18:05:17.863]     ...future.result$finished <- base::Sys.time()
[18:05:17.863]     ...future.result
[18:05:17.863] }
[18:05:17.869] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:17.882] result() for ClusterFuture ...
[18:05:17.883] receiveMessageFromWorker() for ClusterFuture ...
[18:05:17.883] - Validating connection of MultisessionFuture
[18:05:17.914] - received message: FutureResult
[18:05:17.915] - Received FutureResult
[18:05:17.915] - Erased future from FutureRegistry
[18:05:17.915] result() for ClusterFuture ...
[18:05:17.915] - result already collected: FutureResult
[18:05:17.915] result() for ClusterFuture ... done
[18:05:17.916] signalConditions() ...
[18:05:17.916]  - include = ‘immediateCondition’
[18:05:17.916]  - exclude = 
[18:05:17.916]  - resignal = FALSE
[18:05:17.917]  - Number of conditions: 1
[18:05:17.917] signalConditions() ... done
[18:05:17.917] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:17.917] result() for ClusterFuture ... done
[18:05:17.917] result() for ClusterFuture ...
[18:05:17.918] - result already collected: FutureResult
[18:05:17.918] result() for ClusterFuture ... done
[18:05:17.918] signalConditions() ...
[18:05:17.918]  - include = ‘immediateCondition’
[18:05:17.918]  - exclude = 
[18:05:17.919]  - resignal = FALSE
[18:05:17.919]  - Number of conditions: 1
[18:05:17.919] signalConditions() ... done
<MyError: boom>
[18:05:17.919] result() for ClusterFuture ...
[18:05:17.920] - result already collected: FutureResult
[18:05:17.920] result() for ClusterFuture ... done
[18:05:17.920] result() for ClusterFuture ...
[18:05:17.920] - result already collected: FutureResult
[18:05:17.920] result() for ClusterFuture ... done
[18:05:17.921] signalConditions() ...
[18:05:17.921]  - include = ‘immediateCondition’
[18:05:17.921]  - exclude = 
[18:05:17.921]  - resignal = FALSE
[18:05:17.921]  - Number of conditions: 1
[18:05:17.922] signalConditions() ... done
[18:05:17.922] Future state: ‘finished’
[18:05:17.922] result() for ClusterFuture ...
[18:05:17.922] - result already collected: FutureResult
[18:05:17.923] result() for ClusterFuture ... done
[18:05:17.923] signalConditions() ...
[18:05:17.923]  - include = ‘condition’
[18:05:17.923]  - exclude = ‘immediateCondition’
[18:05:17.923]  - resignal = TRUE
[18:05:17.924]  - Number of conditions: 1
[18:05:17.924]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[18:05:17.924] signalConditions() ... done
Testing with 2 cores ... DONE
> 
> 
> message("*** multisession() - too large globals ...")
*** multisession() - too large globals ...
> ooptsT <- options(future.globals.maxSize = object.size(1:1014))
> 
> limit <- getOption("future.globals.maxSize")
> cat(sprintf("Max total size of globals: %g bytes\n", limit))
Max total size of globals: 4104 bytes
> 
> for (workers in unique(c(1L, availableCores()))) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message("Max number of sessions: ", workers)
+ 
+   ## A large object
+   a <- 1:1014
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   f <- multisession({ sum(a) }, globals = TRUE, workers = workers)
+   print(f)
+   rm(list = "a")
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+ 
+   ## A too large object
+   a <- 1:1015
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   res <- try(f <- multisession({ sum(a) }, globals = TRUE, workers = workers), silent = TRUE)
+   rm(list = "a")
+   stopifnot(inherits(res, "try-error"))
+ } ## for (workers in ...)
Max number of sessions: 1
a: 4104 bytes
[18:05:17.959] getGlobalsAndPackages() ...
[18:05:17.959] Searching for globals...
[18:05:17.961] - globals found: [3] ‘{’, ‘sum’, ‘a’
[18:05:17.961] Searching for globals ... DONE
[18:05:17.962] Resolving globals: FALSE
[18:05:17.962] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[18:05:17.963] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[18:05:17.963] - globals: [1] ‘a’
[18:05:17.964] 
[18:05:17.964] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:17.966] Packages needed by the future expression (n = 0): <none>
[18:05:17.966] Packages needed by future strategies (n = 0): <none>
[18:05:17.967] {
[18:05:17.967]     {
[18:05:17.967]         {
[18:05:17.967]             ...future.startTime <- base::Sys.time()
[18:05:17.967]             {
[18:05:17.967]                 {
[18:05:17.967]                   {
[18:05:17.967]                     base::local({
[18:05:17.967]                       has_future <- base::requireNamespace("future", 
[18:05:17.967]                         quietly = TRUE)
[18:05:17.967]                       if (has_future) {
[18:05:17.967]                         ns <- base::getNamespace("future")
[18:05:17.967]                         version <- ns[[".package"]][["version"]]
[18:05:17.967]                         if (is.null(version)) 
[18:05:17.967]                           version <- utils::packageVersion("future")
[18:05:17.967]                       }
[18:05:17.967]                       else {
[18:05:17.967]                         version <- NULL
[18:05:17.967]                       }
[18:05:17.967]                       if (!has_future || version < "1.8.0") {
[18:05:17.967]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:17.967]                           "", base::R.version$version.string), 
[18:05:17.967]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:17.967]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:17.967]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:17.967]                             "release", "version")], collapse = " "), 
[18:05:17.967]                           hostname = base::Sys.info()[["nodename"]])
[18:05:17.967]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:17.967]                           info)
[18:05:17.967]                         info <- base::paste(info, collapse = "; ")
[18:05:17.967]                         if (!has_future) {
[18:05:17.967]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:17.967]                             info)
[18:05:17.967]                         }
[18:05:17.967]                         else {
[18:05:17.967]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:17.967]                             info, version)
[18:05:17.967]                         }
[18:05:17.967]                         base::stop(msg)
[18:05:17.967]                       }
[18:05:17.967]                     })
[18:05:17.967]                   }
[18:05:17.967]                   ...future.strategy.old <- future::plan("list")
[18:05:17.967]                   options(future.plan = NULL)
[18:05:17.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:17.967]                 }
[18:05:17.967]                 ...future.workdir <- getwd()
[18:05:17.967]             }
[18:05:17.967]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:17.967]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:17.967]         }
[18:05:17.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:17.967]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[18:05:17.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:17.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:17.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:17.967]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:17.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:17.967]             base::names(...future.oldOptions))
[18:05:17.967]     }
[18:05:17.967]     if (FALSE) {
[18:05:17.967]     }
[18:05:17.967]     else {
[18:05:17.967]         if (TRUE) {
[18:05:17.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:17.967]                 open = "w")
[18:05:17.967]         }
[18:05:17.967]         else {
[18:05:17.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:17.967]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:17.967]         }
[18:05:17.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:17.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:17.967]             base::sink(type = "output", split = FALSE)
[18:05:17.967]             base::close(...future.stdout)
[18:05:17.967]         }, add = TRUE)
[18:05:17.967]     }
[18:05:17.967]     ...future.frame <- base::sys.nframe()
[18:05:17.967]     ...future.conditions <- base::list()
[18:05:17.967]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:17.967]     if (FALSE) {
[18:05:17.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:17.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:17.967]     }
[18:05:17.967]     ...future.result <- base::tryCatch({
[18:05:17.967]         base::withCallingHandlers({
[18:05:17.967]             ...future.value <- base::withVisible(base::local({
[18:05:17.967]                 sum(a)
[18:05:17.967]             }))
[18:05:17.967]             future::FutureResult(value = ...future.value$value, 
[18:05:17.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.967]                   ...future.rng), globalenv = if (FALSE) 
[18:05:17.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:17.967]                     ...future.globalenv.names))
[18:05:17.967]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:17.967]         }, condition = base::local({
[18:05:17.967]             c <- base::c
[18:05:17.967]             inherits <- base::inherits
[18:05:17.967]             invokeRestart <- base::invokeRestart
[18:05:17.967]             length <- base::length
[18:05:17.967]             list <- base::list
[18:05:17.967]             seq.int <- base::seq.int
[18:05:17.967]             signalCondition <- base::signalCondition
[18:05:17.967]             sys.calls <- base::sys.calls
[18:05:17.967]             `[[` <- base::`[[`
[18:05:17.967]             `+` <- base::`+`
[18:05:17.967]             `<<-` <- base::`<<-`
[18:05:17.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:17.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:17.967]                   3L)]
[18:05:17.967]             }
[18:05:17.967]             function(cond) {
[18:05:17.967]                 is_error <- inherits(cond, "error")
[18:05:17.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:17.967]                   NULL)
[18:05:17.967]                 if (is_error) {
[18:05:17.967]                   sessionInformation <- function() {
[18:05:17.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:17.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:17.967]                       search = base::search(), system = base::Sys.info())
[18:05:17.967]                   }
[18:05:17.967]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:17.967]                     cond$call), session = sessionInformation(), 
[18:05:17.967]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:17.967]                   signalCondition(cond)
[18:05:17.967]                 }
[18:05:17.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:17.967]                 "immediateCondition"))) {
[18:05:17.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:17.967]                   ...future.conditions[[length(...future.conditions) + 
[18:05:17.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:17.967]                   if (TRUE && !signal) {
[18:05:17.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.967]                     {
[18:05:17.967]                       inherits <- base::inherits
[18:05:17.967]                       invokeRestart <- base::invokeRestart
[18:05:17.967]                       is.null <- base::is.null
[18:05:17.967]                       muffled <- FALSE
[18:05:17.967]                       if (inherits(cond, "message")) {
[18:05:17.967]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.967]                         if (muffled) 
[18:05:17.967]                           invokeRestart("muffleMessage")
[18:05:17.967]                       }
[18:05:17.967]                       else if (inherits(cond, "warning")) {
[18:05:17.967]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.967]                         if (muffled) 
[18:05:17.967]                           invokeRestart("muffleWarning")
[18:05:17.967]                       }
[18:05:17.967]                       else if (inherits(cond, "condition")) {
[18:05:17.967]                         if (!is.null(pattern)) {
[18:05:17.967]                           computeRestarts <- base::computeRestarts
[18:05:17.967]                           grepl <- base::grepl
[18:05:17.967]                           restarts <- computeRestarts(cond)
[18:05:17.967]                           for (restart in restarts) {
[18:05:17.967]                             name <- restart$name
[18:05:17.967]                             if (is.null(name)) 
[18:05:17.967]                               next
[18:05:17.967]                             if (!grepl(pattern, name)) 
[18:05:17.967]                               next
[18:05:17.967]                             invokeRestart(restart)
[18:05:17.967]                             muffled <- TRUE
[18:05:17.967]                             break
[18:05:17.967]                           }
[18:05:17.967]                         }
[18:05:17.967]                       }
[18:05:17.967]                       invisible(muffled)
[18:05:17.967]                     }
[18:05:17.967]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.967]                   }
[18:05:17.967]                 }
[18:05:17.967]                 else {
[18:05:17.967]                   if (TRUE) {
[18:05:17.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:17.967]                     {
[18:05:17.967]                       inherits <- base::inherits
[18:05:17.967]                       invokeRestart <- base::invokeRestart
[18:05:17.967]                       is.null <- base::is.null
[18:05:17.967]                       muffled <- FALSE
[18:05:17.967]                       if (inherits(cond, "message")) {
[18:05:17.967]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:17.967]                         if (muffled) 
[18:05:17.967]                           invokeRestart("muffleMessage")
[18:05:17.967]                       }
[18:05:17.967]                       else if (inherits(cond, "warning")) {
[18:05:17.967]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:17.967]                         if (muffled) 
[18:05:17.967]                           invokeRestart("muffleWarning")
[18:05:17.967]                       }
[18:05:17.967]                       else if (inherits(cond, "condition")) {
[18:05:17.967]                         if (!is.null(pattern)) {
[18:05:17.967]                           computeRestarts <- base::computeRestarts
[18:05:17.967]                           grepl <- base::grepl
[18:05:17.967]                           restarts <- computeRestarts(cond)
[18:05:17.967]                           for (restart in restarts) {
[18:05:17.967]                             name <- restart$name
[18:05:17.967]                             if (is.null(name)) 
[18:05:17.967]                               next
[18:05:17.967]                             if (!grepl(pattern, name)) 
[18:05:17.967]                               next
[18:05:17.967]                             invokeRestart(restart)
[18:05:17.967]                             muffled <- TRUE
[18:05:17.967]                             break
[18:05:17.967]                           }
[18:05:17.967]                         }
[18:05:17.967]                       }
[18:05:17.967]                       invisible(muffled)
[18:05:17.967]                     }
[18:05:17.967]                     muffleCondition(cond, pattern = "^muffle")
[18:05:17.967]                   }
[18:05:17.967]                 }
[18:05:17.967]             }
[18:05:17.967]         }))
[18:05:17.967]     }, error = function(ex) {
[18:05:17.967]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:17.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:17.967]                 ...future.rng), started = ...future.startTime, 
[18:05:17.967]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:17.967]             version = "1.8"), class = "FutureResult")
[18:05:17.967]     }, finally = {
[18:05:17.967]         if (!identical(...future.workdir, getwd())) 
[18:05:17.967]             setwd(...future.workdir)
[18:05:17.967]         {
[18:05:17.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:17.967]                 ...future.oldOptions$nwarnings <- NULL
[18:05:17.967]             }
[18:05:17.967]             base::options(...future.oldOptions)
[18:05:17.967]             if (.Platform$OS.type == "windows") {
[18:05:17.967]                 old_names <- names(...future.oldEnvVars)
[18:05:17.967]                 envs <- base::Sys.getenv()
[18:05:17.967]                 names <- names(envs)
[18:05:17.967]                 common <- intersect(names, old_names)
[18:05:17.967]                 added <- setdiff(names, old_names)
[18:05:17.967]                 removed <- setdiff(old_names, names)
[18:05:17.967]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:17.967]                   envs[common]]
[18:05:17.967]                 NAMES <- toupper(changed)
[18:05:17.967]                 args <- list()
[18:05:17.967]                 for (kk in seq_along(NAMES)) {
[18:05:17.967]                   name <- changed[[kk]]
[18:05:17.967]                   NAME <- NAMES[[kk]]
[18:05:17.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.967]                     next
[18:05:17.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.967]                 }
[18:05:17.967]                 NAMES <- toupper(added)
[18:05:17.967]                 for (kk in seq_along(NAMES)) {
[18:05:17.967]                   name <- added[[kk]]
[18:05:17.967]                   NAME <- NAMES[[kk]]
[18:05:17.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.967]                     next
[18:05:17.967]                   args[[name]] <- ""
[18:05:17.967]                 }
[18:05:17.967]                 NAMES <- toupper(removed)
[18:05:17.967]                 for (kk in seq_along(NAMES)) {
[18:05:17.967]                   name <- removed[[kk]]
[18:05:17.967]                   NAME <- NAMES[[kk]]
[18:05:17.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:17.967]                     next
[18:05:17.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:17.967]                 }
[18:05:17.967]                 if (length(args) > 0) 
[18:05:17.967]                   base::do.call(base::Sys.setenv, args = args)
[18:05:17.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:17.967]             }
[18:05:17.967]             else {
[18:05:17.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:17.967]             }
[18:05:17.967]             {
[18:05:17.967]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:17.967]                   0L) {
[18:05:17.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:17.967]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:17.967]                   base::options(opts)
[18:05:17.967]                 }
[18:05:17.967]                 {
[18:05:17.967]                   {
[18:05:17.967]                     NULL
[18:05:17.967]                     RNGkind("Mersenne-Twister")
[18:05:17.967]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:17.967]                       inherits = FALSE)
[18:05:17.967]                   }
[18:05:17.967]                   options(future.plan = NULL)
[18:05:17.967]                   if (is.na(NA_character_)) 
[18:05:17.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:17.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:17.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:17.967]                     .init = FALSE)
[18:05:17.967]                 }
[18:05:17.967]             }
[18:05:17.967]         }
[18:05:17.967]     })
[18:05:17.967]     if (TRUE) {
[18:05:17.967]         base::sink(type = "output", split = FALSE)
[18:05:17.967]         if (TRUE) {
[18:05:17.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:17.967]         }
[18:05:17.967]         else {
[18:05:17.967]             ...future.result["stdout"] <- base::list(NULL)
[18:05:17.967]         }
[18:05:17.967]         base::close(...future.stdout)
[18:05:17.967]         ...future.stdout <- NULL
[18:05:17.967]     }
[18:05:17.967]     ...future.result$conditions <- ...future.conditions
[18:05:17.967]     ...future.result$finished <- base::Sys.time()
[18:05:17.967]     ...future.result
[18:05:17.967] }
[18:05:17.970] assign_globals() ...
[18:05:17.970] List of 1
[18:05:17.970]  $ a: int [1:1014] 1 2 3 4 5 6 7 8 9 10 ...
[18:05:17.970]  - attr(*, "where")=List of 1
[18:05:17.970]   ..$ a:<environment: R_EmptyEnv> 
[18:05:17.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:17.970]  - attr(*, "resolved")= logi FALSE
[18:05:17.970]  - attr(*, "total_size")= num 4104
[18:05:17.974] - copied ‘a’ to environment
[18:05:17.975] assign_globals() ... done
[18:05:17.975] plan(): Setting new future strategy stack:
[18:05:17.975] List of future strategies:
[18:05:17.975] 1. sequential:
[18:05:17.975]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:17.975]    - tweaked: FALSE
[18:05:17.975]    - call: NULL
[18:05:17.976] plan(): nbrOfWorkers() = 1
[18:05:17.978] plan(): Setting new future strategy stack:
[18:05:17.978] List of future strategies:
[18:05:17.978] 1. sequential:
[18:05:17.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:17.978]    - tweaked: FALSE
[18:05:17.978]    - call: future::plan("sequential")
[18:05:17.979] plan(): nbrOfWorkers() = 1
[18:05:17.979] SequentialFuture started (and completed)
[1] 514605
a: 4112 bytes
[18:05:17.980] getGlobalsAndPackages() ...
[18:05:17.980] Searching for globals...
[18:05:17.981] - globals found: [3] ‘{’, ‘sum’, ‘a’
[18:05:17.982] Searching for globals ... DONE
[18:05:17.982] Resolving globals: FALSE
[18:05:17.983] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[18:05:17.983] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
Max number of sessions: 2
a: 4104 bytes
[18:05:17.984] getGlobalsAndPackages() ...
[18:05:17.984] Searching for globals...
[18:05:17.986] - globals found: [3] ‘{’, ‘sum’, ‘a’
[18:05:17.986] Searching for globals ... DONE
[18:05:17.986] Resolving globals: FALSE
[18:05:17.987] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[18:05:17.988] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[18:05:17.988] - globals: [1] ‘a’
[18:05:17.988] 
[18:05:17.988] getGlobalsAndPackages() ... DONE
[18:05:18.007] Packages needed by the future expression (n = 0): <none>
[18:05:18.007] Packages needed by future strategies (n = 0): <none>
[18:05:18.008] {
[18:05:18.008]     {
[18:05:18.008]         {
[18:05:18.008]             ...future.startTime <- base::Sys.time()
[18:05:18.008]             {
[18:05:18.008]                 {
[18:05:18.008]                   {
[18:05:18.008]                     {
[18:05:18.008]                       base::local({
[18:05:18.008]                         has_future <- base::requireNamespace("future", 
[18:05:18.008]                           quietly = TRUE)
[18:05:18.008]                         if (has_future) {
[18:05:18.008]                           ns <- base::getNamespace("future")
[18:05:18.008]                           version <- ns[[".package"]][["version"]]
[18:05:18.008]                           if (is.null(version)) 
[18:05:18.008]                             version <- utils::packageVersion("future")
[18:05:18.008]                         }
[18:05:18.008]                         else {
[18:05:18.008]                           version <- NULL
[18:05:18.008]                         }
[18:05:18.008]                         if (!has_future || version < "1.8.0") {
[18:05:18.008]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:18.008]                             "", base::R.version$version.string), 
[18:05:18.008]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:18.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:18.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:18.008]                               "release", "version")], collapse = " "), 
[18:05:18.008]                             hostname = base::Sys.info()[["nodename"]])
[18:05:18.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:18.008]                             info)
[18:05:18.008]                           info <- base::paste(info, collapse = "; ")
[18:05:18.008]                           if (!has_future) {
[18:05:18.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:18.008]                               info)
[18:05:18.008]                           }
[18:05:18.008]                           else {
[18:05:18.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:18.008]                               info, version)
[18:05:18.008]                           }
[18:05:18.008]                           base::stop(msg)
[18:05:18.008]                         }
[18:05:18.008]                       })
[18:05:18.008]                     }
[18:05:18.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:18.008]                     base::options(mc.cores = 1L)
[18:05:18.008]                   }
[18:05:18.008]                   ...future.strategy.old <- future::plan("list")
[18:05:18.008]                   options(future.plan = NULL)
[18:05:18.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:18.008]                 }
[18:05:18.008]                 ...future.workdir <- getwd()
[18:05:18.008]             }
[18:05:18.008]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:18.008]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:18.008]         }
[18:05:18.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:18.008]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[18:05:18.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:18.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:18.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:18.008]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:18.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:18.008]             base::names(...future.oldOptions))
[18:05:18.008]     }
[18:05:18.008]     if (FALSE) {
[18:05:18.008]     }
[18:05:18.008]     else {
[18:05:18.008]         if (TRUE) {
[18:05:18.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:18.008]                 open = "w")
[18:05:18.008]         }
[18:05:18.008]         else {
[18:05:18.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:18.008]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:18.008]         }
[18:05:18.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:18.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:18.008]             base::sink(type = "output", split = FALSE)
[18:05:18.008]             base::close(...future.stdout)
[18:05:18.008]         }, add = TRUE)
[18:05:18.008]     }
[18:05:18.008]     ...future.frame <- base::sys.nframe()
[18:05:18.008]     ...future.conditions <- base::list()
[18:05:18.008]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:18.008]     if (FALSE) {
[18:05:18.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:18.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:18.008]     }
[18:05:18.008]     ...future.result <- base::tryCatch({
[18:05:18.008]         base::withCallingHandlers({
[18:05:18.008]             ...future.value <- base::withVisible(base::local({
[18:05:18.008]                 ...future.makeSendCondition <- base::local({
[18:05:18.008]                   sendCondition <- NULL
[18:05:18.008]                   function(frame = 1L) {
[18:05:18.008]                     if (is.function(sendCondition)) 
[18:05:18.008]                       return(sendCondition)
[18:05:18.008]                     ns <- getNamespace("parallel")
[18:05:18.008]                     if (exists("sendData", mode = "function", 
[18:05:18.008]                       envir = ns)) {
[18:05:18.008]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:18.008]                         envir = ns)
[18:05:18.008]                       envir <- sys.frame(frame)
[18:05:18.008]                       master <- NULL
[18:05:18.008]                       while (!identical(envir, .GlobalEnv) && 
[18:05:18.008]                         !identical(envir, emptyenv())) {
[18:05:18.008]                         if (exists("master", mode = "list", envir = envir, 
[18:05:18.008]                           inherits = FALSE)) {
[18:05:18.008]                           master <- get("master", mode = "list", 
[18:05:18.008]                             envir = envir, inherits = FALSE)
[18:05:18.008]                           if (inherits(master, c("SOCKnode", 
[18:05:18.008]                             "SOCK0node"))) {
[18:05:18.008]                             sendCondition <<- function(cond) {
[18:05:18.008]                               data <- list(type = "VALUE", value = cond, 
[18:05:18.008]                                 success = TRUE)
[18:05:18.008]                               parallel_sendData(master, data)
[18:05:18.008]                             }
[18:05:18.008]                             return(sendCondition)
[18:05:18.008]                           }
[18:05:18.008]                         }
[18:05:18.008]                         frame <- frame + 1L
[18:05:18.008]                         envir <- sys.frame(frame)
[18:05:18.008]                       }
[18:05:18.008]                     }
[18:05:18.008]                     sendCondition <<- function(cond) NULL
[18:05:18.008]                   }
[18:05:18.008]                 })
[18:05:18.008]                 withCallingHandlers({
[18:05:18.008]                   {
[18:05:18.008]                     sum(a)
[18:05:18.008]                   }
[18:05:18.008]                 }, immediateCondition = function(cond) {
[18:05:18.008]                   sendCondition <- ...future.makeSendCondition()
[18:05:18.008]                   sendCondition(cond)
[18:05:18.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.008]                   {
[18:05:18.008]                     inherits <- base::inherits
[18:05:18.008]                     invokeRestart <- base::invokeRestart
[18:05:18.008]                     is.null <- base::is.null
[18:05:18.008]                     muffled <- FALSE
[18:05:18.008]                     if (inherits(cond, "message")) {
[18:05:18.008]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:18.008]                       if (muffled) 
[18:05:18.008]                         invokeRestart("muffleMessage")
[18:05:18.008]                     }
[18:05:18.008]                     else if (inherits(cond, "warning")) {
[18:05:18.008]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:18.008]                       if (muffled) 
[18:05:18.008]                         invokeRestart("muffleWarning")
[18:05:18.008]                     }
[18:05:18.008]                     else if (inherits(cond, "condition")) {
[18:05:18.008]                       if (!is.null(pattern)) {
[18:05:18.008]                         computeRestarts <- base::computeRestarts
[18:05:18.008]                         grepl <- base::grepl
[18:05:18.008]                         restarts <- computeRestarts(cond)
[18:05:18.008]                         for (restart in restarts) {
[18:05:18.008]                           name <- restart$name
[18:05:18.008]                           if (is.null(name)) 
[18:05:18.008]                             next
[18:05:18.008]                           if (!grepl(pattern, name)) 
[18:05:18.008]                             next
[18:05:18.008]                           invokeRestart(restart)
[18:05:18.008]                           muffled <- TRUE
[18:05:18.008]                           break
[18:05:18.008]                         }
[18:05:18.008]                       }
[18:05:18.008]                     }
[18:05:18.008]                     invisible(muffled)
[18:05:18.008]                   }
[18:05:18.008]                   muffleCondition(cond)
[18:05:18.008]                 })
[18:05:18.008]             }))
[18:05:18.008]             future::FutureResult(value = ...future.value$value, 
[18:05:18.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.008]                   ...future.rng), globalenv = if (FALSE) 
[18:05:18.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:18.008]                     ...future.globalenv.names))
[18:05:18.008]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:18.008]         }, condition = base::local({
[18:05:18.008]             c <- base::c
[18:05:18.008]             inherits <- base::inherits
[18:05:18.008]             invokeRestart <- base::invokeRestart
[18:05:18.008]             length <- base::length
[18:05:18.008]             list <- base::list
[18:05:18.008]             seq.int <- base::seq.int
[18:05:18.008]             signalCondition <- base::signalCondition
[18:05:18.008]             sys.calls <- base::sys.calls
[18:05:18.008]             `[[` <- base::`[[`
[18:05:18.008]             `+` <- base::`+`
[18:05:18.008]             `<<-` <- base::`<<-`
[18:05:18.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:18.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:18.008]                   3L)]
[18:05:18.008]             }
[18:05:18.008]             function(cond) {
[18:05:18.008]                 is_error <- inherits(cond, "error")
[18:05:18.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:18.008]                   NULL)
[18:05:18.008]                 if (is_error) {
[18:05:18.008]                   sessionInformation <- function() {
[18:05:18.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:18.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:18.008]                       search = base::search(), system = base::Sys.info())
[18:05:18.008]                   }
[18:05:18.008]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:18.008]                     cond$call), session = sessionInformation(), 
[18:05:18.008]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:18.008]                   signalCondition(cond)
[18:05:18.008]                 }
[18:05:18.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:18.008]                 "immediateCondition"))) {
[18:05:18.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:18.008]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:18.008]                   if (TRUE && !signal) {
[18:05:18.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.008]                     {
[18:05:18.008]                       inherits <- base::inherits
[18:05:18.008]                       invokeRestart <- base::invokeRestart
[18:05:18.008]                       is.null <- base::is.null
[18:05:18.008]                       muffled <- FALSE
[18:05:18.008]                       if (inherits(cond, "message")) {
[18:05:18.008]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.008]                         if (muffled) 
[18:05:18.008]                           invokeRestart("muffleMessage")
[18:05:18.008]                       }
[18:05:18.008]                       else if (inherits(cond, "warning")) {
[18:05:18.008]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.008]                         if (muffled) 
[18:05:18.008]                           invokeRestart("muffleWarning")
[18:05:18.008]                       }
[18:05:18.008]                       else if (inherits(cond, "condition")) {
[18:05:18.008]                         if (!is.null(pattern)) {
[18:05:18.008]                           computeRestarts <- base::computeRestarts
[18:05:18.008]                           grepl <- base::grepl
[18:05:18.008]                           restarts <- computeRestarts(cond)
[18:05:18.008]                           for (restart in restarts) {
[18:05:18.008]                             name <- restart$name
[18:05:18.008]                             if (is.null(name)) 
[18:05:18.008]                               next
[18:05:18.008]                             if (!grepl(pattern, name)) 
[18:05:18.008]                               next
[18:05:18.008]                             invokeRestart(restart)
[18:05:18.008]                             muffled <- TRUE
[18:05:18.008]                             break
[18:05:18.008]                           }
[18:05:18.008]                         }
[18:05:18.008]                       }
[18:05:18.008]                       invisible(muffled)
[18:05:18.008]                     }
[18:05:18.008]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.008]                   }
[18:05:18.008]                 }
[18:05:18.008]                 else {
[18:05:18.008]                   if (TRUE) {
[18:05:18.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.008]                     {
[18:05:18.008]                       inherits <- base::inherits
[18:05:18.008]                       invokeRestart <- base::invokeRestart
[18:05:18.008]                       is.null <- base::is.null
[18:05:18.008]                       muffled <- FALSE
[18:05:18.008]                       if (inherits(cond, "message")) {
[18:05:18.008]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.008]                         if (muffled) 
[18:05:18.008]                           invokeRestart("muffleMessage")
[18:05:18.008]                       }
[18:05:18.008]                       else if (inherits(cond, "warning")) {
[18:05:18.008]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.008]                         if (muffled) 
[18:05:18.008]                           invokeRestart("muffleWarning")
[18:05:18.008]                       }
[18:05:18.008]                       else if (inherits(cond, "condition")) {
[18:05:18.008]                         if (!is.null(pattern)) {
[18:05:18.008]                           computeRestarts <- base::computeRestarts
[18:05:18.008]                           grepl <- base::grepl
[18:05:18.008]                           restarts <- computeRestarts(cond)
[18:05:18.008]                           for (restart in restarts) {
[18:05:18.008]                             name <- restart$name
[18:05:18.008]                             if (is.null(name)) 
[18:05:18.008]                               next
[18:05:18.008]                             if (!grepl(pattern, name)) 
[18:05:18.008]                               next
[18:05:18.008]                             invokeRestart(restart)
[18:05:18.008]                             muffled <- TRUE
[18:05:18.008]                             break
[18:05:18.008]                           }
[18:05:18.008]                         }
[18:05:18.008]                       }
[18:05:18.008]                       invisible(muffled)
[18:05:18.008]                     }
[18:05:18.008]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.008]                   }
[18:05:18.008]                 }
[18:05:18.008]             }
[18:05:18.008]         }))
[18:05:18.008]     }, error = function(ex) {
[18:05:18.008]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:18.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.008]                 ...future.rng), started = ...future.startTime, 
[18:05:18.008]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:18.008]             version = "1.8"), class = "FutureResult")
[18:05:18.008]     }, finally = {
[18:05:18.008]         if (!identical(...future.workdir, getwd())) 
[18:05:18.008]             setwd(...future.workdir)
[18:05:18.008]         {
[18:05:18.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:18.008]                 ...future.oldOptions$nwarnings <- NULL
[18:05:18.008]             }
[18:05:18.008]             base::options(...future.oldOptions)
[18:05:18.008]             if (.Platform$OS.type == "windows") {
[18:05:18.008]                 old_names <- names(...future.oldEnvVars)
[18:05:18.008]                 envs <- base::Sys.getenv()
[18:05:18.008]                 names <- names(envs)
[18:05:18.008]                 common <- intersect(names, old_names)
[18:05:18.008]                 added <- setdiff(names, old_names)
[18:05:18.008]                 removed <- setdiff(old_names, names)
[18:05:18.008]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:18.008]                   envs[common]]
[18:05:18.008]                 NAMES <- toupper(changed)
[18:05:18.008]                 args <- list()
[18:05:18.008]                 for (kk in seq_along(NAMES)) {
[18:05:18.008]                   name <- changed[[kk]]
[18:05:18.008]                   NAME <- NAMES[[kk]]
[18:05:18.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.008]                     next
[18:05:18.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.008]                 }
[18:05:18.008]                 NAMES <- toupper(added)
[18:05:18.008]                 for (kk in seq_along(NAMES)) {
[18:05:18.008]                   name <- added[[kk]]
[18:05:18.008]                   NAME <- NAMES[[kk]]
[18:05:18.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.008]                     next
[18:05:18.008]                   args[[name]] <- ""
[18:05:18.008]                 }
[18:05:18.008]                 NAMES <- toupper(removed)
[18:05:18.008]                 for (kk in seq_along(NAMES)) {
[18:05:18.008]                   name <- removed[[kk]]
[18:05:18.008]                   NAME <- NAMES[[kk]]
[18:05:18.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.008]                     next
[18:05:18.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.008]                 }
[18:05:18.008]                 if (length(args) > 0) 
[18:05:18.008]                   base::do.call(base::Sys.setenv, args = args)
[18:05:18.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:18.008]             }
[18:05:18.008]             else {
[18:05:18.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:18.008]             }
[18:05:18.008]             {
[18:05:18.008]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:18.008]                   0L) {
[18:05:18.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:18.008]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:18.008]                   base::options(opts)
[18:05:18.008]                 }
[18:05:18.008]                 {
[18:05:18.008]                   {
[18:05:18.008]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:18.008]                     NULL
[18:05:18.008]                   }
[18:05:18.008]                   options(future.plan = NULL)
[18:05:18.008]                   if (is.na(NA_character_)) 
[18:05:18.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:18.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:18.008]                     .init = FALSE)
[18:05:18.008]                 }
[18:05:18.008]             }
[18:05:18.008]         }
[18:05:18.008]     })
[18:05:18.008]     if (TRUE) {
[18:05:18.008]         base::sink(type = "output", split = FALSE)
[18:05:18.008]         if (TRUE) {
[18:05:18.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:18.008]         }
[18:05:18.008]         else {
[18:05:18.008]             ...future.result["stdout"] <- base::list(NULL)
[18:05:18.008]         }
[18:05:18.008]         base::close(...future.stdout)
[18:05:18.008]         ...future.stdout <- NULL
[18:05:18.008]     }
[18:05:18.008]     ...future.result$conditions <- ...future.conditions
[18:05:18.008]     ...future.result$finished <- base::Sys.time()
[18:05:18.008]     ...future.result
[18:05:18.008] }
[18:05:18.013] Exporting 1 global objects (4.01 KiB) to cluster node #1 ...
[18:05:18.013] Exporting ‘a’ (4.01 KiB) to cluster node #1 ...
[18:05:18.014] Exporting ‘a’ (4.01 KiB) to cluster node #1 ... DONE
[18:05:18.014] Exporting 1 global objects (4.01 KiB) to cluster node #1 ... DONE
[18:05:18.015] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fba65c68-3da5-13da-8fba-0535b102693a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:18.027] result() for ClusterFuture ...
[18:05:18.027] receiveMessageFromWorker() for ClusterFuture ...
[18:05:18.028] - Validating connection of MultisessionFuture
[18:05:18.059] - received message: FutureResult
[18:05:18.060] - Received FutureResult
[18:05:18.060] - Erased future from FutureRegistry
[18:05:18.060] result() for ClusterFuture ...
[18:05:18.060] - result already collected: FutureResult
[18:05:18.060] result() for ClusterFuture ... done
[18:05:18.061] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:18.061] result() for ClusterFuture ... done
[18:05:18.061] result() for ClusterFuture ...
[18:05:18.061] - result already collected: FutureResult
[18:05:18.061] result() for ClusterFuture ... done
[1] 514605
a: 4112 bytes
[18:05:18.062] getGlobalsAndPackages() ...
[18:05:18.062] Searching for globals...
[18:05:18.064] - globals found: [3] ‘{’, ‘sum’, ‘a’
[18:05:18.064] Searching for globals ... DONE
[18:05:18.064] Resolving globals: FALSE
[18:05:18.065] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[18:05:18.066] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
> 
> ## Undo options changed in this test
> options(ooptsT)
> 
> message("*** multisession() - too large globals ... DONE")
*** multisession() - too large globals ... DONE
> 
> message("*** multisession(..., workers = 1L) ...")
*** multisession(..., workers = 1L) ...
> 
> a <- 2
> b <- 3
> yTruth <- a * b
> 
> f <- multisession({ a * b }, globals = TRUE, workers = 1L)
[18:05:18.067] getGlobalsAndPackages() ...
[18:05:18.067] Searching for globals...
[18:05:18.069] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[18:05:18.069] Searching for globals ... DONE
[18:05:18.070] Resolving globals: FALSE
[18:05:18.071] The total size of the 2 globals is 112 bytes (112 bytes)
[18:05:18.071] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[18:05:18.072] - globals: [2] ‘a’, ‘b’
[18:05:18.072] 
[18:05:18.072] getGlobalsAndPackages() ... DONE
> rm(list = c("a", "b"))
> 
> v <- value(f)
[18:05:18.073] Packages needed by the future expression (n = 0): <none>
[18:05:18.073] Packages needed by future strategies (n = 0): <none>
[18:05:18.074] {
[18:05:18.074]     {
[18:05:18.074]         {
[18:05:18.074]             ...future.startTime <- base::Sys.time()
[18:05:18.074]             {
[18:05:18.074]                 {
[18:05:18.074]                   {
[18:05:18.074]                     base::local({
[18:05:18.074]                       has_future <- base::requireNamespace("future", 
[18:05:18.074]                         quietly = TRUE)
[18:05:18.074]                       if (has_future) {
[18:05:18.074]                         ns <- base::getNamespace("future")
[18:05:18.074]                         version <- ns[[".package"]][["version"]]
[18:05:18.074]                         if (is.null(version)) 
[18:05:18.074]                           version <- utils::packageVersion("future")
[18:05:18.074]                       }
[18:05:18.074]                       else {
[18:05:18.074]                         version <- NULL
[18:05:18.074]                       }
[18:05:18.074]                       if (!has_future || version < "1.8.0") {
[18:05:18.074]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:18.074]                           "", base::R.version$version.string), 
[18:05:18.074]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:18.074]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:18.074]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:18.074]                             "release", "version")], collapse = " "), 
[18:05:18.074]                           hostname = base::Sys.info()[["nodename"]])
[18:05:18.074]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:18.074]                           info)
[18:05:18.074]                         info <- base::paste(info, collapse = "; ")
[18:05:18.074]                         if (!has_future) {
[18:05:18.074]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:18.074]                             info)
[18:05:18.074]                         }
[18:05:18.074]                         else {
[18:05:18.074]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:18.074]                             info, version)
[18:05:18.074]                         }
[18:05:18.074]                         base::stop(msg)
[18:05:18.074]                       }
[18:05:18.074]                     })
[18:05:18.074]                   }
[18:05:18.074]                   ...future.strategy.old <- future::plan("list")
[18:05:18.074]                   options(future.plan = NULL)
[18:05:18.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:18.074]                 }
[18:05:18.074]                 ...future.workdir <- getwd()
[18:05:18.074]             }
[18:05:18.074]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:18.074]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:18.074]         }
[18:05:18.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:18.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:18.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:18.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:18.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:18.074]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:18.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:18.074]             base::names(...future.oldOptions))
[18:05:18.074]     }
[18:05:18.074]     if (FALSE) {
[18:05:18.074]     }
[18:05:18.074]     else {
[18:05:18.074]         if (TRUE) {
[18:05:18.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:18.074]                 open = "w")
[18:05:18.074]         }
[18:05:18.074]         else {
[18:05:18.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:18.074]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:18.074]         }
[18:05:18.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:18.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:18.074]             base::sink(type = "output", split = FALSE)
[18:05:18.074]             base::close(...future.stdout)
[18:05:18.074]         }, add = TRUE)
[18:05:18.074]     }
[18:05:18.074]     ...future.frame <- base::sys.nframe()
[18:05:18.074]     ...future.conditions <- base::list()
[18:05:18.074]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:18.074]     if (FALSE) {
[18:05:18.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:18.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:18.074]     }
[18:05:18.074]     ...future.result <- base::tryCatch({
[18:05:18.074]         base::withCallingHandlers({
[18:05:18.074]             ...future.value <- base::withVisible(base::local({
[18:05:18.074]                 a * b
[18:05:18.074]             }))
[18:05:18.074]             future::FutureResult(value = ...future.value$value, 
[18:05:18.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.074]                   ...future.rng), globalenv = if (FALSE) 
[18:05:18.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:18.074]                     ...future.globalenv.names))
[18:05:18.074]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:18.074]         }, condition = base::local({
[18:05:18.074]             c <- base::c
[18:05:18.074]             inherits <- base::inherits
[18:05:18.074]             invokeRestart <- base::invokeRestart
[18:05:18.074]             length <- base::length
[18:05:18.074]             list <- base::list
[18:05:18.074]             seq.int <- base::seq.int
[18:05:18.074]             signalCondition <- base::signalCondition
[18:05:18.074]             sys.calls <- base::sys.calls
[18:05:18.074]             `[[` <- base::`[[`
[18:05:18.074]             `+` <- base::`+`
[18:05:18.074]             `<<-` <- base::`<<-`
[18:05:18.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:18.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:18.074]                   3L)]
[18:05:18.074]             }
[18:05:18.074]             function(cond) {
[18:05:18.074]                 is_error <- inherits(cond, "error")
[18:05:18.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:18.074]                   NULL)
[18:05:18.074]                 if (is_error) {
[18:05:18.074]                   sessionInformation <- function() {
[18:05:18.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:18.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:18.074]                       search = base::search(), system = base::Sys.info())
[18:05:18.074]                   }
[18:05:18.074]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:18.074]                     cond$call), session = sessionInformation(), 
[18:05:18.074]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:18.074]                   signalCondition(cond)
[18:05:18.074]                 }
[18:05:18.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:18.074]                 "immediateCondition"))) {
[18:05:18.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:18.074]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:18.074]                   if (TRUE && !signal) {
[18:05:18.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.074]                     {
[18:05:18.074]                       inherits <- base::inherits
[18:05:18.074]                       invokeRestart <- base::invokeRestart
[18:05:18.074]                       is.null <- base::is.null
[18:05:18.074]                       muffled <- FALSE
[18:05:18.074]                       if (inherits(cond, "message")) {
[18:05:18.074]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.074]                         if (muffled) 
[18:05:18.074]                           invokeRestart("muffleMessage")
[18:05:18.074]                       }
[18:05:18.074]                       else if (inherits(cond, "warning")) {
[18:05:18.074]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.074]                         if (muffled) 
[18:05:18.074]                           invokeRestart("muffleWarning")
[18:05:18.074]                       }
[18:05:18.074]                       else if (inherits(cond, "condition")) {
[18:05:18.074]                         if (!is.null(pattern)) {
[18:05:18.074]                           computeRestarts <- base::computeRestarts
[18:05:18.074]                           grepl <- base::grepl
[18:05:18.074]                           restarts <- computeRestarts(cond)
[18:05:18.074]                           for (restart in restarts) {
[18:05:18.074]                             name <- restart$name
[18:05:18.074]                             if (is.null(name)) 
[18:05:18.074]                               next
[18:05:18.074]                             if (!grepl(pattern, name)) 
[18:05:18.074]                               next
[18:05:18.074]                             invokeRestart(restart)
[18:05:18.074]                             muffled <- TRUE
[18:05:18.074]                             break
[18:05:18.074]                           }
[18:05:18.074]                         }
[18:05:18.074]                       }
[18:05:18.074]                       invisible(muffled)
[18:05:18.074]                     }
[18:05:18.074]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.074]                   }
[18:05:18.074]                 }
[18:05:18.074]                 else {
[18:05:18.074]                   if (TRUE) {
[18:05:18.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.074]                     {
[18:05:18.074]                       inherits <- base::inherits
[18:05:18.074]                       invokeRestart <- base::invokeRestart
[18:05:18.074]                       is.null <- base::is.null
[18:05:18.074]                       muffled <- FALSE
[18:05:18.074]                       if (inherits(cond, "message")) {
[18:05:18.074]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.074]                         if (muffled) 
[18:05:18.074]                           invokeRestart("muffleMessage")
[18:05:18.074]                       }
[18:05:18.074]                       else if (inherits(cond, "warning")) {
[18:05:18.074]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.074]                         if (muffled) 
[18:05:18.074]                           invokeRestart("muffleWarning")
[18:05:18.074]                       }
[18:05:18.074]                       else if (inherits(cond, "condition")) {
[18:05:18.074]                         if (!is.null(pattern)) {
[18:05:18.074]                           computeRestarts <- base::computeRestarts
[18:05:18.074]                           grepl <- base::grepl
[18:05:18.074]                           restarts <- computeRestarts(cond)
[18:05:18.074]                           for (restart in restarts) {
[18:05:18.074]                             name <- restart$name
[18:05:18.074]                             if (is.null(name)) 
[18:05:18.074]                               next
[18:05:18.074]                             if (!grepl(pattern, name)) 
[18:05:18.074]                               next
[18:05:18.074]                             invokeRestart(restart)
[18:05:18.074]                             muffled <- TRUE
[18:05:18.074]                             break
[18:05:18.074]                           }
[18:05:18.074]                         }
[18:05:18.074]                       }
[18:05:18.074]                       invisible(muffled)
[18:05:18.074]                     }
[18:05:18.074]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.074]                   }
[18:05:18.074]                 }
[18:05:18.074]             }
[18:05:18.074]         }))
[18:05:18.074]     }, error = function(ex) {
[18:05:18.074]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:18.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.074]                 ...future.rng), started = ...future.startTime, 
[18:05:18.074]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:18.074]             version = "1.8"), class = "FutureResult")
[18:05:18.074]     }, finally = {
[18:05:18.074]         if (!identical(...future.workdir, getwd())) 
[18:05:18.074]             setwd(...future.workdir)
[18:05:18.074]         {
[18:05:18.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:18.074]                 ...future.oldOptions$nwarnings <- NULL
[18:05:18.074]             }
[18:05:18.074]             base::options(...future.oldOptions)
[18:05:18.074]             if (.Platform$OS.type == "windows") {
[18:05:18.074]                 old_names <- names(...future.oldEnvVars)
[18:05:18.074]                 envs <- base::Sys.getenv()
[18:05:18.074]                 names <- names(envs)
[18:05:18.074]                 common <- intersect(names, old_names)
[18:05:18.074]                 added <- setdiff(names, old_names)
[18:05:18.074]                 removed <- setdiff(old_names, names)
[18:05:18.074]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:18.074]                   envs[common]]
[18:05:18.074]                 NAMES <- toupper(changed)
[18:05:18.074]                 args <- list()
[18:05:18.074]                 for (kk in seq_along(NAMES)) {
[18:05:18.074]                   name <- changed[[kk]]
[18:05:18.074]                   NAME <- NAMES[[kk]]
[18:05:18.074]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.074]                     next
[18:05:18.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.074]                 }
[18:05:18.074]                 NAMES <- toupper(added)
[18:05:18.074]                 for (kk in seq_along(NAMES)) {
[18:05:18.074]                   name <- added[[kk]]
[18:05:18.074]                   NAME <- NAMES[[kk]]
[18:05:18.074]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.074]                     next
[18:05:18.074]                   args[[name]] <- ""
[18:05:18.074]                 }
[18:05:18.074]                 NAMES <- toupper(removed)
[18:05:18.074]                 for (kk in seq_along(NAMES)) {
[18:05:18.074]                   name <- removed[[kk]]
[18:05:18.074]                   NAME <- NAMES[[kk]]
[18:05:18.074]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.074]                     next
[18:05:18.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.074]                 }
[18:05:18.074]                 if (length(args) > 0) 
[18:05:18.074]                   base::do.call(base::Sys.setenv, args = args)
[18:05:18.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:18.074]             }
[18:05:18.074]             else {
[18:05:18.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:18.074]             }
[18:05:18.074]             {
[18:05:18.074]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:18.074]                   0L) {
[18:05:18.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:18.074]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:18.074]                   base::options(opts)
[18:05:18.074]                 }
[18:05:18.074]                 {
[18:05:18.074]                   {
[18:05:18.074]                     NULL
[18:05:18.074]                     RNGkind("Mersenne-Twister")
[18:05:18.074]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:18.074]                       inherits = FALSE)
[18:05:18.074]                   }
[18:05:18.074]                   options(future.plan = NULL)
[18:05:18.074]                   if (is.na(NA_character_)) 
[18:05:18.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:18.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:18.074]                     .init = FALSE)
[18:05:18.074]                 }
[18:05:18.074]             }
[18:05:18.074]         }
[18:05:18.074]     })
[18:05:18.074]     if (TRUE) {
[18:05:18.074]         base::sink(type = "output", split = FALSE)
[18:05:18.074]         if (TRUE) {
[18:05:18.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:18.074]         }
[18:05:18.074]         else {
[18:05:18.074]             ...future.result["stdout"] <- base::list(NULL)
[18:05:18.074]         }
[18:05:18.074]         base::close(...future.stdout)
[18:05:18.074]         ...future.stdout <- NULL
[18:05:18.074]     }
[18:05:18.074]     ...future.result$conditions <- ...future.conditions
[18:05:18.074]     ...future.result$finished <- base::Sys.time()
[18:05:18.074]     ...future.result
[18:05:18.074] }
[18:05:18.077] assign_globals() ...
[18:05:18.077] List of 2
[18:05:18.077]  $ a: num 2
[18:05:18.077]  $ b: num 3
[18:05:18.077]  - attr(*, "where")=List of 2
[18:05:18.077]   ..$ a:<environment: R_EmptyEnv> 
[18:05:18.077]   ..$ b:<environment: R_EmptyEnv> 
[18:05:18.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:18.077]  - attr(*, "resolved")= logi FALSE
[18:05:18.077]  - attr(*, "total_size")= num 112
[18:05:18.086] - copied ‘a’ to environment
[18:05:18.086] - copied ‘b’ to environment
[18:05:18.086] assign_globals() ... done
[18:05:18.086] plan(): Setting new future strategy stack:
[18:05:18.087] List of future strategies:
[18:05:18.087] 1. sequential:
[18:05:18.087]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:18.087]    - tweaked: FALSE
[18:05:18.087]    - call: NULL
[18:05:18.088] plan(): nbrOfWorkers() = 1
[18:05:18.089] plan(): Setting new future strategy stack:
[18:05:18.089] List of future strategies:
[18:05:18.089] 1. sequential:
[18:05:18.089]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:18.089]    - tweaked: FALSE
[18:05:18.089]    - call: future::plan("sequential")
[18:05:18.090] plan(): nbrOfWorkers() = 1
[18:05:18.090] SequentialFuture started (and completed)
> print(v)
[1] 6
> stopifnot(v == yTruth)
> 
> message("*** multisession(..., workers = 1L) ... DONE")
*** multisession(..., workers = 1L) ... DONE
> 
> message("*** multisession(..., gc = TRUE) ...")
*** multisession(..., gc = TRUE) ...
> plan(multisession, workers = 2L)
[18:05:18.092] plan(): Setting new future strategy stack:
[18:05:18.092] List of future strategies:
[18:05:18.092] 1. multisession:
[18:05:18.092]    - args: function (..., workers = 2L, envir = parent.frame())
[18:05:18.092]    - tweaked: TRUE
[18:05:18.092]    - call: plan(multisession, workers = 2L)
[18:05:18.119] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:05:18.119] multisession:
[18:05:18.119] - args: function (..., workers = 2L, envir = parent.frame())
[18:05:18.119] - tweaked: TRUE
[18:05:18.119] - call: plan(multisession, workers = 2L)
[18:05:18.120] getGlobalsAndPackages() ...
[18:05:18.120] Not searching for globals
[18:05:18.121] - globals: [0] <none>
[18:05:18.121] getGlobalsAndPackages() ... DONE
[18:05:18.121] [local output] makeClusterPSOCK() ...
[18:05:18.127] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:05:18.128] [local output] Base port: 11590
[18:05:18.129] [local output] Getting setup options for 2 cluster nodes ...
[18:05:18.129] [local output]  - Node 1 of 2 ...
[18:05:18.130] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:18.131] [local output] Rscript port: 11590

[18:05:18.131] [local output]  - Node 2 of 2 ...
[18:05:18.132] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:18.133] [local output] Rscript port: 11590

[18:05:18.134] [local output] Getting setup options for 2 cluster nodes ... done
[18:05:18.134] [local output]  - Parallel setup requested for some PSOCK nodes
[18:05:18.134] [local output] Setting up PSOCK nodes in parallel
[18:05:18.135] List of 36
[18:05:18.135]  $ worker          : chr "localhost"
[18:05:18.135]   ..- attr(*, "localhost")= logi TRUE
[18:05:18.135]  $ master          : chr "localhost"
[18:05:18.135]  $ port            : int 11590
[18:05:18.135]  $ connectTimeout  : num 120
[18:05:18.135]  $ timeout         : num 2592000
[18:05:18.135]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:05:18.135]  $ homogeneous     : logi TRUE
[18:05:18.135]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:05:18.135]  $ rscript_envs    : NULL
[18:05:18.135]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:18.135]  $ rscript_startup : NULL
[18:05:18.135]  $ rscript_sh      : chr "sh"
[18:05:18.135]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:18.135]  $ methods         : logi TRUE
[18:05:18.135]  $ socketOptions   : chr "no-delay"
[18:05:18.135]  $ useXDR          : logi FALSE
[18:05:18.135]  $ outfile         : chr "/dev/null"
[18:05:18.135]  $ renice          : int NA
[18:05:18.135]  $ rshcmd          : NULL
[18:05:18.135]  $ user            : chr(0) 
[18:05:18.135]  $ revtunnel       : logi FALSE
[18:05:18.135]  $ rshlogfile      : NULL
[18:05:18.135]  $ rshopts         : chr(0) 
[18:05:18.135]  $ rank            : int 1
[18:05:18.135]  $ manual          : logi FALSE
[18:05:18.135]  $ dryrun          : logi FALSE
[18:05:18.135]  $ quiet           : logi FALSE
[18:05:18.135]  $ setup_strategy  : chr "parallel"
[18:05:18.135]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:18.135]  $ pidfile         : chr "/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa0475659126.pid"
[18:05:18.135]  $ rshcmd_label    : NULL
[18:05:18.135]  $ rsh_call        : NULL
[18:05:18.135]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:18.135]  $ localMachine    : logi TRUE
[18:05:18.135]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:05:18.135]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:05:18.135]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:05:18.135]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:05:18.135]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:05:18.135]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:05:18.135]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:05:18.135]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:05:18.135]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:05:18.135]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:05:18.135]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:05:18.135]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:05:18.135]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:05:18.135]  $ arguments       :List of 28
[18:05:18.135]   ..$ worker          : chr "localhost"
[18:05:18.135]   ..$ master          : NULL
[18:05:18.135]   ..$ port            : int 11590
[18:05:18.135]   ..$ connectTimeout  : num 120
[18:05:18.135]   ..$ timeout         : num 2592000
[18:05:18.135]   ..$ rscript         : NULL
[18:05:18.135]   ..$ homogeneous     : NULL
[18:05:18.135]   ..$ rscript_args    : NULL
[18:05:18.135]   ..$ rscript_envs    : NULL
[18:05:18.135]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:18.135]   ..$ rscript_startup : NULL
[18:05:18.135]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:05:18.135]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:18.135]   ..$ methods         : logi TRUE
[18:05:18.135]   ..$ socketOptions   : chr "no-delay"
[18:05:18.135]   ..$ useXDR          : logi FALSE
[18:05:18.135]   ..$ outfile         : chr "/dev/null"
[18:05:18.135]   ..$ renice          : int NA
[18:05:18.135]   ..$ rshcmd          : NULL
[18:05:18.135]   ..$ user            : NULL
[18:05:18.135]   ..$ revtunnel       : logi NA
[18:05:18.135]   ..$ rshlogfile      : NULL
[18:05:18.135]   ..$ rshopts         : NULL
[18:05:18.135]   ..$ rank            : int 1
[18:05:18.135]   ..$ manual          : logi FALSE
[18:05:18.135]   ..$ dryrun          : logi FALSE
[18:05:18.135]   ..$ quiet           : logi FALSE
[18:05:18.135]   ..$ setup_strategy  : chr "parallel"
[18:05:18.135]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:05:18.169] [local output] System call to launch all workers:
[18:05:18.170] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa0475659126.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11590 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:05:18.170] [local output] Starting PSOCK main server
[18:05:18.172] [local output] Workers launched
[18:05:18.172] [local output] Waiting for workers to connect back
[18:05:18.172]  - [local output] 0 workers out of 2 ready
[18:05:18.554]  - [local output] 0 workers out of 2 ready
[18:05:18.555]  - [local output] 1 workers out of 2 ready
[18:05:18.556]  - [local output] 2 workers out of 2 ready
[18:05:18.556] [local output] Launching of workers completed
[18:05:18.556] [local output] Collecting session information from workers
[18:05:18.557] [local output]  - Worker #1 of 2
[18:05:18.558] [local output]  - Worker #2 of 2
[18:05:18.559] [local output] makeClusterPSOCK() ... done
[18:05:18.578] Packages needed by the future expression (n = 0): <none>
[18:05:18.578] Packages needed by future strategies (n = 0): <none>
[18:05:18.579] {
[18:05:18.579]     {
[18:05:18.579]         {
[18:05:18.579]             ...future.startTime <- base::Sys.time()
[18:05:18.579]             {
[18:05:18.579]                 {
[18:05:18.579]                   {
[18:05:18.579]                     {
[18:05:18.579]                       base::local({
[18:05:18.579]                         has_future <- base::requireNamespace("future", 
[18:05:18.579]                           quietly = TRUE)
[18:05:18.579]                         if (has_future) {
[18:05:18.579]                           ns <- base::getNamespace("future")
[18:05:18.579]                           version <- ns[[".package"]][["version"]]
[18:05:18.579]                           if (is.null(version)) 
[18:05:18.579]                             version <- utils::packageVersion("future")
[18:05:18.579]                         }
[18:05:18.579]                         else {
[18:05:18.579]                           version <- NULL
[18:05:18.579]                         }
[18:05:18.579]                         if (!has_future || version < "1.8.0") {
[18:05:18.579]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:18.579]                             "", base::R.version$version.string), 
[18:05:18.579]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:18.579]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:18.579]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:18.579]                               "release", "version")], collapse = " "), 
[18:05:18.579]                             hostname = base::Sys.info()[["nodename"]])
[18:05:18.579]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:18.579]                             info)
[18:05:18.579]                           info <- base::paste(info, collapse = "; ")
[18:05:18.579]                           if (!has_future) {
[18:05:18.579]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:18.579]                               info)
[18:05:18.579]                           }
[18:05:18.579]                           else {
[18:05:18.579]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:18.579]                               info, version)
[18:05:18.579]                           }
[18:05:18.579]                           base::stop(msg)
[18:05:18.579]                         }
[18:05:18.579]                       })
[18:05:18.579]                     }
[18:05:18.579]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:18.579]                     base::options(mc.cores = 1L)
[18:05:18.579]                   }
[18:05:18.579]                   ...future.strategy.old <- future::plan("list")
[18:05:18.579]                   options(future.plan = NULL)
[18:05:18.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:18.579]                 }
[18:05:18.579]                 ...future.workdir <- getwd()
[18:05:18.579]             }
[18:05:18.579]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:18.579]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:18.579]         }
[18:05:18.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:18.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:18.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:18.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:18.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:18.579]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:18.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:18.579]             base::names(...future.oldOptions))
[18:05:18.579]     }
[18:05:18.579]     if (FALSE) {
[18:05:18.579]     }
[18:05:18.579]     else {
[18:05:18.579]         if (TRUE) {
[18:05:18.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:18.579]                 open = "w")
[18:05:18.579]         }
[18:05:18.579]         else {
[18:05:18.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:18.579]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:18.579]         }
[18:05:18.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:18.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:18.579]             base::sink(type = "output", split = FALSE)
[18:05:18.579]             base::close(...future.stdout)
[18:05:18.579]         }, add = TRUE)
[18:05:18.579]     }
[18:05:18.579]     ...future.frame <- base::sys.nframe()
[18:05:18.579]     ...future.conditions <- base::list()
[18:05:18.579]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:18.579]     if (FALSE) {
[18:05:18.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:18.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:18.579]     }
[18:05:18.579]     ...future.result <- base::tryCatch({
[18:05:18.579]         base::withCallingHandlers({
[18:05:18.579]             ...future.value <- base::withVisible(base::local({
[18:05:18.579]                 ...future.makeSendCondition <- base::local({
[18:05:18.579]                   sendCondition <- NULL
[18:05:18.579]                   function(frame = 1L) {
[18:05:18.579]                     if (is.function(sendCondition)) 
[18:05:18.579]                       return(sendCondition)
[18:05:18.579]                     ns <- getNamespace("parallel")
[18:05:18.579]                     if (exists("sendData", mode = "function", 
[18:05:18.579]                       envir = ns)) {
[18:05:18.579]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:18.579]                         envir = ns)
[18:05:18.579]                       envir <- sys.frame(frame)
[18:05:18.579]                       master <- NULL
[18:05:18.579]                       while (!identical(envir, .GlobalEnv) && 
[18:05:18.579]                         !identical(envir, emptyenv())) {
[18:05:18.579]                         if (exists("master", mode = "list", envir = envir, 
[18:05:18.579]                           inherits = FALSE)) {
[18:05:18.579]                           master <- get("master", mode = "list", 
[18:05:18.579]                             envir = envir, inherits = FALSE)
[18:05:18.579]                           if (inherits(master, c("SOCKnode", 
[18:05:18.579]                             "SOCK0node"))) {
[18:05:18.579]                             sendCondition <<- function(cond) {
[18:05:18.579]                               data <- list(type = "VALUE", value = cond, 
[18:05:18.579]                                 success = TRUE)
[18:05:18.579]                               parallel_sendData(master, data)
[18:05:18.579]                             }
[18:05:18.579]                             return(sendCondition)
[18:05:18.579]                           }
[18:05:18.579]                         }
[18:05:18.579]                         frame <- frame + 1L
[18:05:18.579]                         envir <- sys.frame(frame)
[18:05:18.579]                       }
[18:05:18.579]                     }
[18:05:18.579]                     sendCondition <<- function(cond) NULL
[18:05:18.579]                   }
[18:05:18.579]                 })
[18:05:18.579]                 withCallingHandlers({
[18:05:18.579]                   NA
[18:05:18.579]                 }, immediateCondition = function(cond) {
[18:05:18.579]                   sendCondition <- ...future.makeSendCondition()
[18:05:18.579]                   sendCondition(cond)
[18:05:18.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.579]                   {
[18:05:18.579]                     inherits <- base::inherits
[18:05:18.579]                     invokeRestart <- base::invokeRestart
[18:05:18.579]                     is.null <- base::is.null
[18:05:18.579]                     muffled <- FALSE
[18:05:18.579]                     if (inherits(cond, "message")) {
[18:05:18.579]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:18.579]                       if (muffled) 
[18:05:18.579]                         invokeRestart("muffleMessage")
[18:05:18.579]                     }
[18:05:18.579]                     else if (inherits(cond, "warning")) {
[18:05:18.579]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:18.579]                       if (muffled) 
[18:05:18.579]                         invokeRestart("muffleWarning")
[18:05:18.579]                     }
[18:05:18.579]                     else if (inherits(cond, "condition")) {
[18:05:18.579]                       if (!is.null(pattern)) {
[18:05:18.579]                         computeRestarts <- base::computeRestarts
[18:05:18.579]                         grepl <- base::grepl
[18:05:18.579]                         restarts <- computeRestarts(cond)
[18:05:18.579]                         for (restart in restarts) {
[18:05:18.579]                           name <- restart$name
[18:05:18.579]                           if (is.null(name)) 
[18:05:18.579]                             next
[18:05:18.579]                           if (!grepl(pattern, name)) 
[18:05:18.579]                             next
[18:05:18.579]                           invokeRestart(restart)
[18:05:18.579]                           muffled <- TRUE
[18:05:18.579]                           break
[18:05:18.579]                         }
[18:05:18.579]                       }
[18:05:18.579]                     }
[18:05:18.579]                     invisible(muffled)
[18:05:18.579]                   }
[18:05:18.579]                   muffleCondition(cond)
[18:05:18.579]                 })
[18:05:18.579]             }))
[18:05:18.579]             future::FutureResult(value = ...future.value$value, 
[18:05:18.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.579]                   ...future.rng), globalenv = if (FALSE) 
[18:05:18.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:18.579]                     ...future.globalenv.names))
[18:05:18.579]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:18.579]         }, condition = base::local({
[18:05:18.579]             c <- base::c
[18:05:18.579]             inherits <- base::inherits
[18:05:18.579]             invokeRestart <- base::invokeRestart
[18:05:18.579]             length <- base::length
[18:05:18.579]             list <- base::list
[18:05:18.579]             seq.int <- base::seq.int
[18:05:18.579]             signalCondition <- base::signalCondition
[18:05:18.579]             sys.calls <- base::sys.calls
[18:05:18.579]             `[[` <- base::`[[`
[18:05:18.579]             `+` <- base::`+`
[18:05:18.579]             `<<-` <- base::`<<-`
[18:05:18.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:18.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:18.579]                   3L)]
[18:05:18.579]             }
[18:05:18.579]             function(cond) {
[18:05:18.579]                 is_error <- inherits(cond, "error")
[18:05:18.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:18.579]                   NULL)
[18:05:18.579]                 if (is_error) {
[18:05:18.579]                   sessionInformation <- function() {
[18:05:18.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:18.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:18.579]                       search = base::search(), system = base::Sys.info())
[18:05:18.579]                   }
[18:05:18.579]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:18.579]                     cond$call), session = sessionInformation(), 
[18:05:18.579]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:18.579]                   signalCondition(cond)
[18:05:18.579]                 }
[18:05:18.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:18.579]                 "immediateCondition"))) {
[18:05:18.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:18.579]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:18.579]                   if (TRUE && !signal) {
[18:05:18.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.579]                     {
[18:05:18.579]                       inherits <- base::inherits
[18:05:18.579]                       invokeRestart <- base::invokeRestart
[18:05:18.579]                       is.null <- base::is.null
[18:05:18.579]                       muffled <- FALSE
[18:05:18.579]                       if (inherits(cond, "message")) {
[18:05:18.579]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.579]                         if (muffled) 
[18:05:18.579]                           invokeRestart("muffleMessage")
[18:05:18.579]                       }
[18:05:18.579]                       else if (inherits(cond, "warning")) {
[18:05:18.579]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.579]                         if (muffled) 
[18:05:18.579]                           invokeRestart("muffleWarning")
[18:05:18.579]                       }
[18:05:18.579]                       else if (inherits(cond, "condition")) {
[18:05:18.579]                         if (!is.null(pattern)) {
[18:05:18.579]                           computeRestarts <- base::computeRestarts
[18:05:18.579]                           grepl <- base::grepl
[18:05:18.579]                           restarts <- computeRestarts(cond)
[18:05:18.579]                           for (restart in restarts) {
[18:05:18.579]                             name <- restart$name
[18:05:18.579]                             if (is.null(name)) 
[18:05:18.579]                               next
[18:05:18.579]                             if (!grepl(pattern, name)) 
[18:05:18.579]                               next
[18:05:18.579]                             invokeRestart(restart)
[18:05:18.579]                             muffled <- TRUE
[18:05:18.579]                             break
[18:05:18.579]                           }
[18:05:18.579]                         }
[18:05:18.579]                       }
[18:05:18.579]                       invisible(muffled)
[18:05:18.579]                     }
[18:05:18.579]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.579]                   }
[18:05:18.579]                 }
[18:05:18.579]                 else {
[18:05:18.579]                   if (TRUE) {
[18:05:18.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.579]                     {
[18:05:18.579]                       inherits <- base::inherits
[18:05:18.579]                       invokeRestart <- base::invokeRestart
[18:05:18.579]                       is.null <- base::is.null
[18:05:18.579]                       muffled <- FALSE
[18:05:18.579]                       if (inherits(cond, "message")) {
[18:05:18.579]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.579]                         if (muffled) 
[18:05:18.579]                           invokeRestart("muffleMessage")
[18:05:18.579]                       }
[18:05:18.579]                       else if (inherits(cond, "warning")) {
[18:05:18.579]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.579]                         if (muffled) 
[18:05:18.579]                           invokeRestart("muffleWarning")
[18:05:18.579]                       }
[18:05:18.579]                       else if (inherits(cond, "condition")) {
[18:05:18.579]                         if (!is.null(pattern)) {
[18:05:18.579]                           computeRestarts <- base::computeRestarts
[18:05:18.579]                           grepl <- base::grepl
[18:05:18.579]                           restarts <- computeRestarts(cond)
[18:05:18.579]                           for (restart in restarts) {
[18:05:18.579]                             name <- restart$name
[18:05:18.579]                             if (is.null(name)) 
[18:05:18.579]                               next
[18:05:18.579]                             if (!grepl(pattern, name)) 
[18:05:18.579]                               next
[18:05:18.579]                             invokeRestart(restart)
[18:05:18.579]                             muffled <- TRUE
[18:05:18.579]                             break
[18:05:18.579]                           }
[18:05:18.579]                         }
[18:05:18.579]                       }
[18:05:18.579]                       invisible(muffled)
[18:05:18.579]                     }
[18:05:18.579]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.579]                   }
[18:05:18.579]                 }
[18:05:18.579]             }
[18:05:18.579]         }))
[18:05:18.579]     }, error = function(ex) {
[18:05:18.579]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:18.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.579]                 ...future.rng), started = ...future.startTime, 
[18:05:18.579]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:18.579]             version = "1.8"), class = "FutureResult")
[18:05:18.579]     }, finally = {
[18:05:18.579]         if (!identical(...future.workdir, getwd())) 
[18:05:18.579]             setwd(...future.workdir)
[18:05:18.579]         {
[18:05:18.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:18.579]                 ...future.oldOptions$nwarnings <- NULL
[18:05:18.579]             }
[18:05:18.579]             base::options(...future.oldOptions)
[18:05:18.579]             if (.Platform$OS.type == "windows") {
[18:05:18.579]                 old_names <- names(...future.oldEnvVars)
[18:05:18.579]                 envs <- base::Sys.getenv()
[18:05:18.579]                 names <- names(envs)
[18:05:18.579]                 common <- intersect(names, old_names)
[18:05:18.579]                 added <- setdiff(names, old_names)
[18:05:18.579]                 removed <- setdiff(old_names, names)
[18:05:18.579]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:18.579]                   envs[common]]
[18:05:18.579]                 NAMES <- toupper(changed)
[18:05:18.579]                 args <- list()
[18:05:18.579]                 for (kk in seq_along(NAMES)) {
[18:05:18.579]                   name <- changed[[kk]]
[18:05:18.579]                   NAME <- NAMES[[kk]]
[18:05:18.579]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.579]                     next
[18:05:18.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.579]                 }
[18:05:18.579]                 NAMES <- toupper(added)
[18:05:18.579]                 for (kk in seq_along(NAMES)) {
[18:05:18.579]                   name <- added[[kk]]
[18:05:18.579]                   NAME <- NAMES[[kk]]
[18:05:18.579]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.579]                     next
[18:05:18.579]                   args[[name]] <- ""
[18:05:18.579]                 }
[18:05:18.579]                 NAMES <- toupper(removed)
[18:05:18.579]                 for (kk in seq_along(NAMES)) {
[18:05:18.579]                   name <- removed[[kk]]
[18:05:18.579]                   NAME <- NAMES[[kk]]
[18:05:18.579]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.579]                     next
[18:05:18.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.579]                 }
[18:05:18.579]                 if (length(args) > 0) 
[18:05:18.579]                   base::do.call(base::Sys.setenv, args = args)
[18:05:18.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:18.579]             }
[18:05:18.579]             else {
[18:05:18.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:18.579]             }
[18:05:18.579]             {
[18:05:18.579]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:18.579]                   0L) {
[18:05:18.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:18.579]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:18.579]                   base::options(opts)
[18:05:18.579]                 }
[18:05:18.579]                 {
[18:05:18.579]                   {
[18:05:18.579]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:18.579]                     NULL
[18:05:18.579]                   }
[18:05:18.579]                   options(future.plan = NULL)
[18:05:18.579]                   if (is.na(NA_character_)) 
[18:05:18.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:18.579]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:18.579]                     .init = FALSE)
[18:05:18.579]                 }
[18:05:18.579]             }
[18:05:18.579]         }
[18:05:18.579]     })
[18:05:18.579]     if (TRUE) {
[18:05:18.579]         base::sink(type = "output", split = FALSE)
[18:05:18.579]         if (TRUE) {
[18:05:18.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:18.579]         }
[18:05:18.579]         else {
[18:05:18.579]             ...future.result["stdout"] <- base::list(NULL)
[18:05:18.579]         }
[18:05:18.579]         base::close(...future.stdout)
[18:05:18.579]         ...future.stdout <- NULL
[18:05:18.579]     }
[18:05:18.579]     ...future.result$conditions <- ...future.conditions
[18:05:18.579]     ...future.result$finished <- base::Sys.time()
[18:05:18.579]     ...future.result
[18:05:18.579] }
[18:05:18.677] MultisessionFuture started
[18:05:18.677] result() for ClusterFuture ...
[18:05:18.677] receiveMessageFromWorker() for ClusterFuture ...
[18:05:18.677] - Validating connection of MultisessionFuture
[18:05:18.743] - received message: FutureResult
[18:05:18.744] - Received FutureResult
[18:05:18.744] - Erased future from FutureRegistry
[18:05:18.744] result() for ClusterFuture ...
[18:05:18.745] - result already collected: FutureResult
[18:05:18.745] result() for ClusterFuture ... done
[18:05:18.745] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:18.745] result() for ClusterFuture ... done
[18:05:18.745] result() for ClusterFuture ...
[18:05:18.745] - result already collected: FutureResult
[18:05:18.746] result() for ClusterFuture ... done
[18:05:18.747] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:05:18.747] plan(): nbrOfWorkers() = 2
> 
> f <- future({ gc() })
[18:05:18.747] getGlobalsAndPackages() ...
[18:05:18.747] Searching for globals...
[18:05:18.749] - globals found: [2] ‘{’, ‘gc’
[18:05:18.749] Searching for globals ... DONE
[18:05:18.750] Resolving globals: FALSE
[18:05:18.750] 
[18:05:18.751] 
[18:05:18.751] getGlobalsAndPackages() ... DONE
[18:05:18.751] run() for ‘Future’ ...
[18:05:18.752] - state: ‘created’
[18:05:18.752] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:18.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:18.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:18.772]   - Field: ‘node’
[18:05:18.772]   - Field: ‘label’
[18:05:18.772]   - Field: ‘local’
[18:05:18.772]   - Field: ‘owner’
[18:05:18.773]   - Field: ‘envir’
[18:05:18.773]   - Field: ‘workers’
[18:05:18.773]   - Field: ‘packages’
[18:05:18.773]   - Field: ‘gc’
[18:05:18.773]   - Field: ‘conditions’
[18:05:18.774]   - Field: ‘persistent’
[18:05:18.774]   - Field: ‘expr’
[18:05:18.774]   - Field: ‘uuid’
[18:05:18.774]   - Field: ‘seed’
[18:05:18.774]   - Field: ‘version’
[18:05:18.774]   - Field: ‘result’
[18:05:18.775]   - Field: ‘asynchronous’
[18:05:18.775]   - Field: ‘calls’
[18:05:18.775]   - Field: ‘globals’
[18:05:18.775]   - Field: ‘stdout’
[18:05:18.775]   - Field: ‘earlySignal’
[18:05:18.776]   - Field: ‘lazy’
[18:05:18.776]   - Field: ‘state’
[18:05:18.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:18.776] - Launch lazy future ...
[18:05:18.777] Packages needed by the future expression (n = 0): <none>
[18:05:18.777] Packages needed by future strategies (n = 0): <none>
[18:05:18.778] {
[18:05:18.778]     {
[18:05:18.778]         {
[18:05:18.778]             ...future.startTime <- base::Sys.time()
[18:05:18.778]             {
[18:05:18.778]                 {
[18:05:18.778]                   {
[18:05:18.778]                     {
[18:05:18.778]                       base::local({
[18:05:18.778]                         has_future <- base::requireNamespace("future", 
[18:05:18.778]                           quietly = TRUE)
[18:05:18.778]                         if (has_future) {
[18:05:18.778]                           ns <- base::getNamespace("future")
[18:05:18.778]                           version <- ns[[".package"]][["version"]]
[18:05:18.778]                           if (is.null(version)) 
[18:05:18.778]                             version <- utils::packageVersion("future")
[18:05:18.778]                         }
[18:05:18.778]                         else {
[18:05:18.778]                           version <- NULL
[18:05:18.778]                         }
[18:05:18.778]                         if (!has_future || version < "1.8.0") {
[18:05:18.778]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:18.778]                             "", base::R.version$version.string), 
[18:05:18.778]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:18.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:18.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:18.778]                               "release", "version")], collapse = " "), 
[18:05:18.778]                             hostname = base::Sys.info()[["nodename"]])
[18:05:18.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:18.778]                             info)
[18:05:18.778]                           info <- base::paste(info, collapse = "; ")
[18:05:18.778]                           if (!has_future) {
[18:05:18.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:18.778]                               info)
[18:05:18.778]                           }
[18:05:18.778]                           else {
[18:05:18.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:18.778]                               info, version)
[18:05:18.778]                           }
[18:05:18.778]                           base::stop(msg)
[18:05:18.778]                         }
[18:05:18.778]                       })
[18:05:18.778]                     }
[18:05:18.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:18.778]                     base::options(mc.cores = 1L)
[18:05:18.778]                   }
[18:05:18.778]                   ...future.strategy.old <- future::plan("list")
[18:05:18.778]                   options(future.plan = NULL)
[18:05:18.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:18.778]                 }
[18:05:18.778]                 ...future.workdir <- getwd()
[18:05:18.778]             }
[18:05:18.778]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:18.778]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:18.778]         }
[18:05:18.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:18.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:18.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:18.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:18.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:18.778]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:18.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:18.778]             base::names(...future.oldOptions))
[18:05:18.778]     }
[18:05:18.778]     if (FALSE) {
[18:05:18.778]     }
[18:05:18.778]     else {
[18:05:18.778]         if (TRUE) {
[18:05:18.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:18.778]                 open = "w")
[18:05:18.778]         }
[18:05:18.778]         else {
[18:05:18.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:18.778]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:18.778]         }
[18:05:18.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:18.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:18.778]             base::sink(type = "output", split = FALSE)
[18:05:18.778]             base::close(...future.stdout)
[18:05:18.778]         }, add = TRUE)
[18:05:18.778]     }
[18:05:18.778]     ...future.frame <- base::sys.nframe()
[18:05:18.778]     ...future.conditions <- base::list()
[18:05:18.778]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:18.778]     if (FALSE) {
[18:05:18.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:18.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:18.778]     }
[18:05:18.778]     ...future.result <- base::tryCatch({
[18:05:18.778]         base::withCallingHandlers({
[18:05:18.778]             ...future.value <- base::withVisible(base::local({
[18:05:18.778]                 ...future.makeSendCondition <- base::local({
[18:05:18.778]                   sendCondition <- NULL
[18:05:18.778]                   function(frame = 1L) {
[18:05:18.778]                     if (is.function(sendCondition)) 
[18:05:18.778]                       return(sendCondition)
[18:05:18.778]                     ns <- getNamespace("parallel")
[18:05:18.778]                     if (exists("sendData", mode = "function", 
[18:05:18.778]                       envir = ns)) {
[18:05:18.778]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:18.778]                         envir = ns)
[18:05:18.778]                       envir <- sys.frame(frame)
[18:05:18.778]                       master <- NULL
[18:05:18.778]                       while (!identical(envir, .GlobalEnv) && 
[18:05:18.778]                         !identical(envir, emptyenv())) {
[18:05:18.778]                         if (exists("master", mode = "list", envir = envir, 
[18:05:18.778]                           inherits = FALSE)) {
[18:05:18.778]                           master <- get("master", mode = "list", 
[18:05:18.778]                             envir = envir, inherits = FALSE)
[18:05:18.778]                           if (inherits(master, c("SOCKnode", 
[18:05:18.778]                             "SOCK0node"))) {
[18:05:18.778]                             sendCondition <<- function(cond) {
[18:05:18.778]                               data <- list(type = "VALUE", value = cond, 
[18:05:18.778]                                 success = TRUE)
[18:05:18.778]                               parallel_sendData(master, data)
[18:05:18.778]                             }
[18:05:18.778]                             return(sendCondition)
[18:05:18.778]                           }
[18:05:18.778]                         }
[18:05:18.778]                         frame <- frame + 1L
[18:05:18.778]                         envir <- sys.frame(frame)
[18:05:18.778]                       }
[18:05:18.778]                     }
[18:05:18.778]                     sendCondition <<- function(cond) NULL
[18:05:18.778]                   }
[18:05:18.778]                 })
[18:05:18.778]                 withCallingHandlers({
[18:05:18.778]                   {
[18:05:18.778]                     gc()
[18:05:18.778]                   }
[18:05:18.778]                 }, immediateCondition = function(cond) {
[18:05:18.778]                   sendCondition <- ...future.makeSendCondition()
[18:05:18.778]                   sendCondition(cond)
[18:05:18.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.778]                   {
[18:05:18.778]                     inherits <- base::inherits
[18:05:18.778]                     invokeRestart <- base::invokeRestart
[18:05:18.778]                     is.null <- base::is.null
[18:05:18.778]                     muffled <- FALSE
[18:05:18.778]                     if (inherits(cond, "message")) {
[18:05:18.778]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:18.778]                       if (muffled) 
[18:05:18.778]                         invokeRestart("muffleMessage")
[18:05:18.778]                     }
[18:05:18.778]                     else if (inherits(cond, "warning")) {
[18:05:18.778]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:18.778]                       if (muffled) 
[18:05:18.778]                         invokeRestart("muffleWarning")
[18:05:18.778]                     }
[18:05:18.778]                     else if (inherits(cond, "condition")) {
[18:05:18.778]                       if (!is.null(pattern)) {
[18:05:18.778]                         computeRestarts <- base::computeRestarts
[18:05:18.778]                         grepl <- base::grepl
[18:05:18.778]                         restarts <- computeRestarts(cond)
[18:05:18.778]                         for (restart in restarts) {
[18:05:18.778]                           name <- restart$name
[18:05:18.778]                           if (is.null(name)) 
[18:05:18.778]                             next
[18:05:18.778]                           if (!grepl(pattern, name)) 
[18:05:18.778]                             next
[18:05:18.778]                           invokeRestart(restart)
[18:05:18.778]                           muffled <- TRUE
[18:05:18.778]                           break
[18:05:18.778]                         }
[18:05:18.778]                       }
[18:05:18.778]                     }
[18:05:18.778]                     invisible(muffled)
[18:05:18.778]                   }
[18:05:18.778]                   muffleCondition(cond)
[18:05:18.778]                 })
[18:05:18.778]             }))
[18:05:18.778]             future::FutureResult(value = ...future.value$value, 
[18:05:18.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.778]                   ...future.rng), globalenv = if (FALSE) 
[18:05:18.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:18.778]                     ...future.globalenv.names))
[18:05:18.778]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:18.778]         }, condition = base::local({
[18:05:18.778]             c <- base::c
[18:05:18.778]             inherits <- base::inherits
[18:05:18.778]             invokeRestart <- base::invokeRestart
[18:05:18.778]             length <- base::length
[18:05:18.778]             list <- base::list
[18:05:18.778]             seq.int <- base::seq.int
[18:05:18.778]             signalCondition <- base::signalCondition
[18:05:18.778]             sys.calls <- base::sys.calls
[18:05:18.778]             `[[` <- base::`[[`
[18:05:18.778]             `+` <- base::`+`
[18:05:18.778]             `<<-` <- base::`<<-`
[18:05:18.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:18.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:18.778]                   3L)]
[18:05:18.778]             }
[18:05:18.778]             function(cond) {
[18:05:18.778]                 is_error <- inherits(cond, "error")
[18:05:18.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:18.778]                   NULL)
[18:05:18.778]                 if (is_error) {
[18:05:18.778]                   sessionInformation <- function() {
[18:05:18.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:18.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:18.778]                       search = base::search(), system = base::Sys.info())
[18:05:18.778]                   }
[18:05:18.778]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:18.778]                     cond$call), session = sessionInformation(), 
[18:05:18.778]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:18.778]                   signalCondition(cond)
[18:05:18.778]                 }
[18:05:18.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:18.778]                 "immediateCondition"))) {
[18:05:18.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:18.778]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:18.778]                   if (TRUE && !signal) {
[18:05:18.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.778]                     {
[18:05:18.778]                       inherits <- base::inherits
[18:05:18.778]                       invokeRestart <- base::invokeRestart
[18:05:18.778]                       is.null <- base::is.null
[18:05:18.778]                       muffled <- FALSE
[18:05:18.778]                       if (inherits(cond, "message")) {
[18:05:18.778]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.778]                         if (muffled) 
[18:05:18.778]                           invokeRestart("muffleMessage")
[18:05:18.778]                       }
[18:05:18.778]                       else if (inherits(cond, "warning")) {
[18:05:18.778]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.778]                         if (muffled) 
[18:05:18.778]                           invokeRestart("muffleWarning")
[18:05:18.778]                       }
[18:05:18.778]                       else if (inherits(cond, "condition")) {
[18:05:18.778]                         if (!is.null(pattern)) {
[18:05:18.778]                           computeRestarts <- base::computeRestarts
[18:05:18.778]                           grepl <- base::grepl
[18:05:18.778]                           restarts <- computeRestarts(cond)
[18:05:18.778]                           for (restart in restarts) {
[18:05:18.778]                             name <- restart$name
[18:05:18.778]                             if (is.null(name)) 
[18:05:18.778]                               next
[18:05:18.778]                             if (!grepl(pattern, name)) 
[18:05:18.778]                               next
[18:05:18.778]                             invokeRestart(restart)
[18:05:18.778]                             muffled <- TRUE
[18:05:18.778]                             break
[18:05:18.778]                           }
[18:05:18.778]                         }
[18:05:18.778]                       }
[18:05:18.778]                       invisible(muffled)
[18:05:18.778]                     }
[18:05:18.778]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.778]                   }
[18:05:18.778]                 }
[18:05:18.778]                 else {
[18:05:18.778]                   if (TRUE) {
[18:05:18.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.778]                     {
[18:05:18.778]                       inherits <- base::inherits
[18:05:18.778]                       invokeRestart <- base::invokeRestart
[18:05:18.778]                       is.null <- base::is.null
[18:05:18.778]                       muffled <- FALSE
[18:05:18.778]                       if (inherits(cond, "message")) {
[18:05:18.778]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.778]                         if (muffled) 
[18:05:18.778]                           invokeRestart("muffleMessage")
[18:05:18.778]                       }
[18:05:18.778]                       else if (inherits(cond, "warning")) {
[18:05:18.778]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.778]                         if (muffled) 
[18:05:18.778]                           invokeRestart("muffleWarning")
[18:05:18.778]                       }
[18:05:18.778]                       else if (inherits(cond, "condition")) {
[18:05:18.778]                         if (!is.null(pattern)) {
[18:05:18.778]                           computeRestarts <- base::computeRestarts
[18:05:18.778]                           grepl <- base::grepl
[18:05:18.778]                           restarts <- computeRestarts(cond)
[18:05:18.778]                           for (restart in restarts) {
[18:05:18.778]                             name <- restart$name
[18:05:18.778]                             if (is.null(name)) 
[18:05:18.778]                               next
[18:05:18.778]                             if (!grepl(pattern, name)) 
[18:05:18.778]                               next
[18:05:18.778]                             invokeRestart(restart)
[18:05:18.778]                             muffled <- TRUE
[18:05:18.778]                             break
[18:05:18.778]                           }
[18:05:18.778]                         }
[18:05:18.778]                       }
[18:05:18.778]                       invisible(muffled)
[18:05:18.778]                     }
[18:05:18.778]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.778]                   }
[18:05:18.778]                 }
[18:05:18.778]             }
[18:05:18.778]         }))
[18:05:18.778]     }, error = function(ex) {
[18:05:18.778]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:18.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.778]                 ...future.rng), started = ...future.startTime, 
[18:05:18.778]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:18.778]             version = "1.8"), class = "FutureResult")
[18:05:18.778]     }, finally = {
[18:05:18.778]         if (!identical(...future.workdir, getwd())) 
[18:05:18.778]             setwd(...future.workdir)
[18:05:18.778]         {
[18:05:18.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:18.778]                 ...future.oldOptions$nwarnings <- NULL
[18:05:18.778]             }
[18:05:18.778]             base::options(...future.oldOptions)
[18:05:18.778]             if (.Platform$OS.type == "windows") {
[18:05:18.778]                 old_names <- names(...future.oldEnvVars)
[18:05:18.778]                 envs <- base::Sys.getenv()
[18:05:18.778]                 names <- names(envs)
[18:05:18.778]                 common <- intersect(names, old_names)
[18:05:18.778]                 added <- setdiff(names, old_names)
[18:05:18.778]                 removed <- setdiff(old_names, names)
[18:05:18.778]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:18.778]                   envs[common]]
[18:05:18.778]                 NAMES <- toupper(changed)
[18:05:18.778]                 args <- list()
[18:05:18.778]                 for (kk in seq_along(NAMES)) {
[18:05:18.778]                   name <- changed[[kk]]
[18:05:18.778]                   NAME <- NAMES[[kk]]
[18:05:18.778]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.778]                     next
[18:05:18.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.778]                 }
[18:05:18.778]                 NAMES <- toupper(added)
[18:05:18.778]                 for (kk in seq_along(NAMES)) {
[18:05:18.778]                   name <- added[[kk]]
[18:05:18.778]                   NAME <- NAMES[[kk]]
[18:05:18.778]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.778]                     next
[18:05:18.778]                   args[[name]] <- ""
[18:05:18.778]                 }
[18:05:18.778]                 NAMES <- toupper(removed)
[18:05:18.778]                 for (kk in seq_along(NAMES)) {
[18:05:18.778]                   name <- removed[[kk]]
[18:05:18.778]                   NAME <- NAMES[[kk]]
[18:05:18.778]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.778]                     next
[18:05:18.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.778]                 }
[18:05:18.778]                 if (length(args) > 0) 
[18:05:18.778]                   base::do.call(base::Sys.setenv, args = args)
[18:05:18.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:18.778]             }
[18:05:18.778]             else {
[18:05:18.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:18.778]             }
[18:05:18.778]             {
[18:05:18.778]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:18.778]                   0L) {
[18:05:18.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:18.778]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:18.778]                   base::options(opts)
[18:05:18.778]                 }
[18:05:18.778]                 {
[18:05:18.778]                   {
[18:05:18.778]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:18.778]                     NULL
[18:05:18.778]                   }
[18:05:18.778]                   options(future.plan = NULL)
[18:05:18.778]                   if (is.na(NA_character_)) 
[18:05:18.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:18.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:18.778]                     .init = FALSE)
[18:05:18.778]                 }
[18:05:18.778]             }
[18:05:18.778]         }
[18:05:18.778]     })
[18:05:18.778]     if (TRUE) {
[18:05:18.778]         base::sink(type = "output", split = FALSE)
[18:05:18.778]         if (TRUE) {
[18:05:18.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:18.778]         }
[18:05:18.778]         else {
[18:05:18.778]             ...future.result["stdout"] <- base::list(NULL)
[18:05:18.778]         }
[18:05:18.778]         base::close(...future.stdout)
[18:05:18.778]         ...future.stdout <- NULL
[18:05:18.778]     }
[18:05:18.778]     ...future.result$conditions <- ...future.conditions
[18:05:18.778]     ...future.result$finished <- base::Sys.time()
[18:05:18.778]     ...future.result
[18:05:18.778] }
[18:05:18.784] MultisessionFuture started
[18:05:18.784] - Launch lazy future ... done
[18:05:18.784] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[18:05:18.785] result() for ClusterFuture ...
[18:05:18.785] receiveMessageFromWorker() for ClusterFuture ...
[18:05:18.785] - Validating connection of MultisessionFuture
[18:05:18.859] - received message: FutureResult
[18:05:18.860] - Received FutureResult
[18:05:18.860] - Erased future from FutureRegistry
[18:05:18.860] result() for ClusterFuture ...
[18:05:18.861] - result already collected: FutureResult
[18:05:18.861] result() for ClusterFuture ... done
[18:05:18.861] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:18.862] result() for ClusterFuture ... done
[18:05:18.862] result() for ClusterFuture ...
[18:05:18.862] - result already collected: FutureResult
[18:05:18.862] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 407013 21.8     692222   37   692222 37.0
Vcells 729849  5.6    8388608   64  1923668 14.7
> 
> f <- future({ integer(10e6) })
[18:05:18.863] getGlobalsAndPackages() ...
[18:05:18.863] Searching for globals...
[18:05:18.865] - globals found: [2] ‘{’, ‘integer’
[18:05:18.866] Searching for globals ... DONE
[18:05:18.866] Resolving globals: FALSE
[18:05:18.867] 
[18:05:18.867] 
[18:05:18.867] getGlobalsAndPackages() ... DONE
[18:05:18.868] run() for ‘Future’ ...
[18:05:18.868] - state: ‘created’
[18:05:18.869] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:18.894] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:18.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:18.895]   - Field: ‘node’
[18:05:18.896]   - Field: ‘label’
[18:05:18.896]   - Field: ‘local’
[18:05:18.896]   - Field: ‘owner’
[18:05:18.896]   - Field: ‘envir’
[18:05:18.897]   - Field: ‘workers’
[18:05:18.897]   - Field: ‘packages’
[18:05:18.897]   - Field: ‘gc’
[18:05:18.897]   - Field: ‘conditions’
[18:05:18.898]   - Field: ‘persistent’
[18:05:18.898]   - Field: ‘expr’
[18:05:18.898]   - Field: ‘uuid’
[18:05:18.899]   - Field: ‘seed’
[18:05:18.899]   - Field: ‘version’
[18:05:18.899]   - Field: ‘result’
[18:05:18.899]   - Field: ‘asynchronous’
[18:05:18.900]   - Field: ‘calls’
[18:05:18.900]   - Field: ‘globals’
[18:05:18.900]   - Field: ‘stdout’
[18:05:18.900]   - Field: ‘earlySignal’
[18:05:18.901]   - Field: ‘lazy’
[18:05:18.901]   - Field: ‘state’
[18:05:18.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:18.902] - Launch lazy future ...
[18:05:18.902] Packages needed by the future expression (n = 0): <none>
[18:05:18.903] Packages needed by future strategies (n = 0): <none>
[18:05:18.907] {
[18:05:18.907]     {
[18:05:18.907]         {
[18:05:18.907]             ...future.startTime <- base::Sys.time()
[18:05:18.907]             {
[18:05:18.907]                 {
[18:05:18.907]                   {
[18:05:18.907]                     {
[18:05:18.907]                       base::local({
[18:05:18.907]                         has_future <- base::requireNamespace("future", 
[18:05:18.907]                           quietly = TRUE)
[18:05:18.907]                         if (has_future) {
[18:05:18.907]                           ns <- base::getNamespace("future")
[18:05:18.907]                           version <- ns[[".package"]][["version"]]
[18:05:18.907]                           if (is.null(version)) 
[18:05:18.907]                             version <- utils::packageVersion("future")
[18:05:18.907]                         }
[18:05:18.907]                         else {
[18:05:18.907]                           version <- NULL
[18:05:18.907]                         }
[18:05:18.907]                         if (!has_future || version < "1.8.0") {
[18:05:18.907]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:18.907]                             "", base::R.version$version.string), 
[18:05:18.907]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:18.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:18.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:18.907]                               "release", "version")], collapse = " "), 
[18:05:18.907]                             hostname = base::Sys.info()[["nodename"]])
[18:05:18.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:18.907]                             info)
[18:05:18.907]                           info <- base::paste(info, collapse = "; ")
[18:05:18.907]                           if (!has_future) {
[18:05:18.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:18.907]                               info)
[18:05:18.907]                           }
[18:05:18.907]                           else {
[18:05:18.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:18.907]                               info, version)
[18:05:18.907]                           }
[18:05:18.907]                           base::stop(msg)
[18:05:18.907]                         }
[18:05:18.907]                       })
[18:05:18.907]                     }
[18:05:18.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:18.907]                     base::options(mc.cores = 1L)
[18:05:18.907]                   }
[18:05:18.907]                   ...future.strategy.old <- future::plan("list")
[18:05:18.907]                   options(future.plan = NULL)
[18:05:18.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:18.907]                 }
[18:05:18.907]                 ...future.workdir <- getwd()
[18:05:18.907]             }
[18:05:18.907]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:18.907]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:18.907]         }
[18:05:18.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:18.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:18.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:18.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:18.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:18.907]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:18.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:18.907]             base::names(...future.oldOptions))
[18:05:18.907]     }
[18:05:18.907]     if (FALSE) {
[18:05:18.907]     }
[18:05:18.907]     else {
[18:05:18.907]         if (TRUE) {
[18:05:18.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:18.907]                 open = "w")
[18:05:18.907]         }
[18:05:18.907]         else {
[18:05:18.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:18.907]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:18.907]         }
[18:05:18.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:18.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:18.907]             base::sink(type = "output", split = FALSE)
[18:05:18.907]             base::close(...future.stdout)
[18:05:18.907]         }, add = TRUE)
[18:05:18.907]     }
[18:05:18.907]     ...future.frame <- base::sys.nframe()
[18:05:18.907]     ...future.conditions <- base::list()
[18:05:18.907]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:18.907]     if (FALSE) {
[18:05:18.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:18.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:18.907]     }
[18:05:18.907]     ...future.result <- base::tryCatch({
[18:05:18.907]         base::withCallingHandlers({
[18:05:18.907]             ...future.value <- base::withVisible(base::local({
[18:05:18.907]                 ...future.makeSendCondition <- base::local({
[18:05:18.907]                   sendCondition <- NULL
[18:05:18.907]                   function(frame = 1L) {
[18:05:18.907]                     if (is.function(sendCondition)) 
[18:05:18.907]                       return(sendCondition)
[18:05:18.907]                     ns <- getNamespace("parallel")
[18:05:18.907]                     if (exists("sendData", mode = "function", 
[18:05:18.907]                       envir = ns)) {
[18:05:18.907]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:18.907]                         envir = ns)
[18:05:18.907]                       envir <- sys.frame(frame)
[18:05:18.907]                       master <- NULL
[18:05:18.907]                       while (!identical(envir, .GlobalEnv) && 
[18:05:18.907]                         !identical(envir, emptyenv())) {
[18:05:18.907]                         if (exists("master", mode = "list", envir = envir, 
[18:05:18.907]                           inherits = FALSE)) {
[18:05:18.907]                           master <- get("master", mode = "list", 
[18:05:18.907]                             envir = envir, inherits = FALSE)
[18:05:18.907]                           if (inherits(master, c("SOCKnode", 
[18:05:18.907]                             "SOCK0node"))) {
[18:05:18.907]                             sendCondition <<- function(cond) {
[18:05:18.907]                               data <- list(type = "VALUE", value = cond, 
[18:05:18.907]                                 success = TRUE)
[18:05:18.907]                               parallel_sendData(master, data)
[18:05:18.907]                             }
[18:05:18.907]                             return(sendCondition)
[18:05:18.907]                           }
[18:05:18.907]                         }
[18:05:18.907]                         frame <- frame + 1L
[18:05:18.907]                         envir <- sys.frame(frame)
[18:05:18.907]                       }
[18:05:18.907]                     }
[18:05:18.907]                     sendCondition <<- function(cond) NULL
[18:05:18.907]                   }
[18:05:18.907]                 })
[18:05:18.907]                 withCallingHandlers({
[18:05:18.907]                   {
[18:05:18.907]                     integer(1e+07)
[18:05:18.907]                   }
[18:05:18.907]                 }, immediateCondition = function(cond) {
[18:05:18.907]                   sendCondition <- ...future.makeSendCondition()
[18:05:18.907]                   sendCondition(cond)
[18:05:18.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.907]                   {
[18:05:18.907]                     inherits <- base::inherits
[18:05:18.907]                     invokeRestart <- base::invokeRestart
[18:05:18.907]                     is.null <- base::is.null
[18:05:18.907]                     muffled <- FALSE
[18:05:18.907]                     if (inherits(cond, "message")) {
[18:05:18.907]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:18.907]                       if (muffled) 
[18:05:18.907]                         invokeRestart("muffleMessage")
[18:05:18.907]                     }
[18:05:18.907]                     else if (inherits(cond, "warning")) {
[18:05:18.907]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:18.907]                       if (muffled) 
[18:05:18.907]                         invokeRestart("muffleWarning")
[18:05:18.907]                     }
[18:05:18.907]                     else if (inherits(cond, "condition")) {
[18:05:18.907]                       if (!is.null(pattern)) {
[18:05:18.907]                         computeRestarts <- base::computeRestarts
[18:05:18.907]                         grepl <- base::grepl
[18:05:18.907]                         restarts <- computeRestarts(cond)
[18:05:18.907]                         for (restart in restarts) {
[18:05:18.907]                           name <- restart$name
[18:05:18.907]                           if (is.null(name)) 
[18:05:18.907]                             next
[18:05:18.907]                           if (!grepl(pattern, name)) 
[18:05:18.907]                             next
[18:05:18.907]                           invokeRestart(restart)
[18:05:18.907]                           muffled <- TRUE
[18:05:18.907]                           break
[18:05:18.907]                         }
[18:05:18.907]                       }
[18:05:18.907]                     }
[18:05:18.907]                     invisible(muffled)
[18:05:18.907]                   }
[18:05:18.907]                   muffleCondition(cond)
[18:05:18.907]                 })
[18:05:18.907]             }))
[18:05:18.907]             future::FutureResult(value = ...future.value$value, 
[18:05:18.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.907]                   ...future.rng), globalenv = if (FALSE) 
[18:05:18.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:18.907]                     ...future.globalenv.names))
[18:05:18.907]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:18.907]         }, condition = base::local({
[18:05:18.907]             c <- base::c
[18:05:18.907]             inherits <- base::inherits
[18:05:18.907]             invokeRestart <- base::invokeRestart
[18:05:18.907]             length <- base::length
[18:05:18.907]             list <- base::list
[18:05:18.907]             seq.int <- base::seq.int
[18:05:18.907]             signalCondition <- base::signalCondition
[18:05:18.907]             sys.calls <- base::sys.calls
[18:05:18.907]             `[[` <- base::`[[`
[18:05:18.907]             `+` <- base::`+`
[18:05:18.907]             `<<-` <- base::`<<-`
[18:05:18.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:18.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:18.907]                   3L)]
[18:05:18.907]             }
[18:05:18.907]             function(cond) {
[18:05:18.907]                 is_error <- inherits(cond, "error")
[18:05:18.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:18.907]                   NULL)
[18:05:18.907]                 if (is_error) {
[18:05:18.907]                   sessionInformation <- function() {
[18:05:18.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:18.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:18.907]                       search = base::search(), system = base::Sys.info())
[18:05:18.907]                   }
[18:05:18.907]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:18.907]                     cond$call), session = sessionInformation(), 
[18:05:18.907]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:18.907]                   signalCondition(cond)
[18:05:18.907]                 }
[18:05:18.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:18.907]                 "immediateCondition"))) {
[18:05:18.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:18.907]                   ...future.conditions[[length(...future.conditions) + 
[18:05:18.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:18.907]                   if (TRUE && !signal) {
[18:05:18.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.907]                     {
[18:05:18.907]                       inherits <- base::inherits
[18:05:18.907]                       invokeRestart <- base::invokeRestart
[18:05:18.907]                       is.null <- base::is.null
[18:05:18.907]                       muffled <- FALSE
[18:05:18.907]                       if (inherits(cond, "message")) {
[18:05:18.907]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.907]                         if (muffled) 
[18:05:18.907]                           invokeRestart("muffleMessage")
[18:05:18.907]                       }
[18:05:18.907]                       else if (inherits(cond, "warning")) {
[18:05:18.907]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.907]                         if (muffled) 
[18:05:18.907]                           invokeRestart("muffleWarning")
[18:05:18.907]                       }
[18:05:18.907]                       else if (inherits(cond, "condition")) {
[18:05:18.907]                         if (!is.null(pattern)) {
[18:05:18.907]                           computeRestarts <- base::computeRestarts
[18:05:18.907]                           grepl <- base::grepl
[18:05:18.907]                           restarts <- computeRestarts(cond)
[18:05:18.907]                           for (restart in restarts) {
[18:05:18.907]                             name <- restart$name
[18:05:18.907]                             if (is.null(name)) 
[18:05:18.907]                               next
[18:05:18.907]                             if (!grepl(pattern, name)) 
[18:05:18.907]                               next
[18:05:18.907]                             invokeRestart(restart)
[18:05:18.907]                             muffled <- TRUE
[18:05:18.907]                             break
[18:05:18.907]                           }
[18:05:18.907]                         }
[18:05:18.907]                       }
[18:05:18.907]                       invisible(muffled)
[18:05:18.907]                     }
[18:05:18.907]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.907]                   }
[18:05:18.907]                 }
[18:05:18.907]                 else {
[18:05:18.907]                   if (TRUE) {
[18:05:18.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:18.907]                     {
[18:05:18.907]                       inherits <- base::inherits
[18:05:18.907]                       invokeRestart <- base::invokeRestart
[18:05:18.907]                       is.null <- base::is.null
[18:05:18.907]                       muffled <- FALSE
[18:05:18.907]                       if (inherits(cond, "message")) {
[18:05:18.907]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:18.907]                         if (muffled) 
[18:05:18.907]                           invokeRestart("muffleMessage")
[18:05:18.907]                       }
[18:05:18.907]                       else if (inherits(cond, "warning")) {
[18:05:18.907]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:18.907]                         if (muffled) 
[18:05:18.907]                           invokeRestart("muffleWarning")
[18:05:18.907]                       }
[18:05:18.907]                       else if (inherits(cond, "condition")) {
[18:05:18.907]                         if (!is.null(pattern)) {
[18:05:18.907]                           computeRestarts <- base::computeRestarts
[18:05:18.907]                           grepl <- base::grepl
[18:05:18.907]                           restarts <- computeRestarts(cond)
[18:05:18.907]                           for (restart in restarts) {
[18:05:18.907]                             name <- restart$name
[18:05:18.907]                             if (is.null(name)) 
[18:05:18.907]                               next
[18:05:18.907]                             if (!grepl(pattern, name)) 
[18:05:18.907]                               next
[18:05:18.907]                             invokeRestart(restart)
[18:05:18.907]                             muffled <- TRUE
[18:05:18.907]                             break
[18:05:18.907]                           }
[18:05:18.907]                         }
[18:05:18.907]                       }
[18:05:18.907]                       invisible(muffled)
[18:05:18.907]                     }
[18:05:18.907]                     muffleCondition(cond, pattern = "^muffle")
[18:05:18.907]                   }
[18:05:18.907]                 }
[18:05:18.907]             }
[18:05:18.907]         }))
[18:05:18.907]     }, error = function(ex) {
[18:05:18.907]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:18.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:18.907]                 ...future.rng), started = ...future.startTime, 
[18:05:18.907]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:18.907]             version = "1.8"), class = "FutureResult")
[18:05:18.907]     }, finally = {
[18:05:18.907]         if (!identical(...future.workdir, getwd())) 
[18:05:18.907]             setwd(...future.workdir)
[18:05:18.907]         {
[18:05:18.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:18.907]                 ...future.oldOptions$nwarnings <- NULL
[18:05:18.907]             }
[18:05:18.907]             base::options(...future.oldOptions)
[18:05:18.907]             if (.Platform$OS.type == "windows") {
[18:05:18.907]                 old_names <- names(...future.oldEnvVars)
[18:05:18.907]                 envs <- base::Sys.getenv()
[18:05:18.907]                 names <- names(envs)
[18:05:18.907]                 common <- intersect(names, old_names)
[18:05:18.907]                 added <- setdiff(names, old_names)
[18:05:18.907]                 removed <- setdiff(old_names, names)
[18:05:18.907]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:18.907]                   envs[common]]
[18:05:18.907]                 NAMES <- toupper(changed)
[18:05:18.907]                 args <- list()
[18:05:18.907]                 for (kk in seq_along(NAMES)) {
[18:05:18.907]                   name <- changed[[kk]]
[18:05:18.907]                   NAME <- NAMES[[kk]]
[18:05:18.907]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.907]                     next
[18:05:18.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.907]                 }
[18:05:18.907]                 NAMES <- toupper(added)
[18:05:18.907]                 for (kk in seq_along(NAMES)) {
[18:05:18.907]                   name <- added[[kk]]
[18:05:18.907]                   NAME <- NAMES[[kk]]
[18:05:18.907]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.907]                     next
[18:05:18.907]                   args[[name]] <- ""
[18:05:18.907]                 }
[18:05:18.907]                 NAMES <- toupper(removed)
[18:05:18.907]                 for (kk in seq_along(NAMES)) {
[18:05:18.907]                   name <- removed[[kk]]
[18:05:18.907]                   NAME <- NAMES[[kk]]
[18:05:18.907]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:18.907]                     next
[18:05:18.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:18.907]                 }
[18:05:18.907]                 if (length(args) > 0) 
[18:05:18.907]                   base::do.call(base::Sys.setenv, args = args)
[18:05:18.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:18.907]             }
[18:05:18.907]             else {
[18:05:18.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:18.907]             }
[18:05:18.907]             {
[18:05:18.907]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:18.907]                   0L) {
[18:05:18.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:18.907]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:18.907]                   base::options(opts)
[18:05:18.907]                 }
[18:05:18.907]                 {
[18:05:18.907]                   {
[18:05:18.907]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:18.907]                     NULL
[18:05:18.907]                   }
[18:05:18.907]                   options(future.plan = NULL)
[18:05:18.907]                   if (is.na(NA_character_)) 
[18:05:18.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:18.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:18.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:18.907]                     .init = FALSE)
[18:05:18.907]                 }
[18:05:18.907]             }
[18:05:18.907]         }
[18:05:18.907]     })
[18:05:18.907]     if (TRUE) {
[18:05:18.907]         base::sink(type = "output", split = FALSE)
[18:05:18.907]         if (TRUE) {
[18:05:18.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:18.907]         }
[18:05:18.907]         else {
[18:05:18.907]             ...future.result["stdout"] <- base::list(NULL)
[18:05:18.907]         }
[18:05:18.907]         base::close(...future.stdout)
[18:05:18.907]         ...future.stdout <- NULL
[18:05:18.907]     }
[18:05:18.907]     ...future.result$conditions <- ...future.conditions
[18:05:18.907]     ...future.result$finished <- base::Sys.time()
[18:05:18.907]     ...future.result
[18:05:18.907] }
[18:05:18.914] MultisessionFuture started
[18:05:18.914] - Launch lazy future ... done
[18:05:18.914] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[18:05:18.915] result() for ClusterFuture ...
[18:05:18.915] receiveMessageFromWorker() for ClusterFuture ...
[18:05:18.915] - Validating connection of MultisessionFuture
[18:05:19.076] - received message: FutureResult
[18:05:19.077] - Received FutureResult
[18:05:19.077] - Erased future from FutureRegistry
[18:05:19.077] result() for ClusterFuture ...
[18:05:19.077] - result already collected: FutureResult
[18:05:19.077] result() for ClusterFuture ... done
[18:05:19.078] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:19.078] result() for ClusterFuture ... done
[18:05:19.078] result() for ClusterFuture ...
[18:05:19.078] - result already collected: FutureResult
[18:05:19.078] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[18:05:19.079] getGlobalsAndPackages() ...
[18:05:19.079] Searching for globals...
[18:05:19.081] - globals found: [2] ‘{’, ‘gc’
[18:05:19.081] Searching for globals ... DONE
[18:05:19.081] Resolving globals: FALSE
[18:05:19.082] 
[18:05:19.082] 
[18:05:19.082] getGlobalsAndPackages() ... DONE
[18:05:19.083] run() for ‘Future’ ...
[18:05:19.083] - state: ‘created’
[18:05:19.083] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:19.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:19.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:19.101]   - Field: ‘node’
[18:05:19.101]   - Field: ‘label’
[18:05:19.101]   - Field: ‘local’
[18:05:19.101]   - Field: ‘owner’
[18:05:19.101]   - Field: ‘envir’
[18:05:19.102]   - Field: ‘workers’
[18:05:19.102]   - Field: ‘packages’
[18:05:19.102]   - Field: ‘gc’
[18:05:19.102]   - Field: ‘conditions’
[18:05:19.102]   - Field: ‘persistent’
[18:05:19.103]   - Field: ‘expr’
[18:05:19.103]   - Field: ‘uuid’
[18:05:19.103]   - Field: ‘seed’
[18:05:19.103]   - Field: ‘version’
[18:05:19.103]   - Field: ‘result’
[18:05:19.104]   - Field: ‘asynchronous’
[18:05:19.104]   - Field: ‘calls’
[18:05:19.104]   - Field: ‘globals’
[18:05:19.104]   - Field: ‘stdout’
[18:05:19.104]   - Field: ‘earlySignal’
[18:05:19.104]   - Field: ‘lazy’
[18:05:19.105]   - Field: ‘state’
[18:05:19.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:19.105] - Launch lazy future ...
[18:05:19.106] Packages needed by the future expression (n = 0): <none>
[18:05:19.106] Packages needed by future strategies (n = 0): <none>
[18:05:19.107] {
[18:05:19.107]     {
[18:05:19.107]         {
[18:05:19.107]             ...future.startTime <- base::Sys.time()
[18:05:19.107]             {
[18:05:19.107]                 {
[18:05:19.107]                   {
[18:05:19.107]                     {
[18:05:19.107]                       base::local({
[18:05:19.107]                         has_future <- base::requireNamespace("future", 
[18:05:19.107]                           quietly = TRUE)
[18:05:19.107]                         if (has_future) {
[18:05:19.107]                           ns <- base::getNamespace("future")
[18:05:19.107]                           version <- ns[[".package"]][["version"]]
[18:05:19.107]                           if (is.null(version)) 
[18:05:19.107]                             version <- utils::packageVersion("future")
[18:05:19.107]                         }
[18:05:19.107]                         else {
[18:05:19.107]                           version <- NULL
[18:05:19.107]                         }
[18:05:19.107]                         if (!has_future || version < "1.8.0") {
[18:05:19.107]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:19.107]                             "", base::R.version$version.string), 
[18:05:19.107]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:19.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:19.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:19.107]                               "release", "version")], collapse = " "), 
[18:05:19.107]                             hostname = base::Sys.info()[["nodename"]])
[18:05:19.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:19.107]                             info)
[18:05:19.107]                           info <- base::paste(info, collapse = "; ")
[18:05:19.107]                           if (!has_future) {
[18:05:19.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:19.107]                               info)
[18:05:19.107]                           }
[18:05:19.107]                           else {
[18:05:19.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:19.107]                               info, version)
[18:05:19.107]                           }
[18:05:19.107]                           base::stop(msg)
[18:05:19.107]                         }
[18:05:19.107]                       })
[18:05:19.107]                     }
[18:05:19.107]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:19.107]                     base::options(mc.cores = 1L)
[18:05:19.107]                   }
[18:05:19.107]                   ...future.strategy.old <- future::plan("list")
[18:05:19.107]                   options(future.plan = NULL)
[18:05:19.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:19.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:19.107]                 }
[18:05:19.107]                 ...future.workdir <- getwd()
[18:05:19.107]             }
[18:05:19.107]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:19.107]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:19.107]         }
[18:05:19.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:19.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:19.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:19.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:19.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:19.107]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:19.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:19.107]             base::names(...future.oldOptions))
[18:05:19.107]     }
[18:05:19.107]     if (FALSE) {
[18:05:19.107]     }
[18:05:19.107]     else {
[18:05:19.107]         if (TRUE) {
[18:05:19.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:19.107]                 open = "w")
[18:05:19.107]         }
[18:05:19.107]         else {
[18:05:19.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:19.107]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:19.107]         }
[18:05:19.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:19.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:19.107]             base::sink(type = "output", split = FALSE)
[18:05:19.107]             base::close(...future.stdout)
[18:05:19.107]         }, add = TRUE)
[18:05:19.107]     }
[18:05:19.107]     ...future.frame <- base::sys.nframe()
[18:05:19.107]     ...future.conditions <- base::list()
[18:05:19.107]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:19.107]     if (FALSE) {
[18:05:19.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:19.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:19.107]     }
[18:05:19.107]     ...future.result <- base::tryCatch({
[18:05:19.107]         base::withCallingHandlers({
[18:05:19.107]             ...future.value <- base::withVisible(base::local({
[18:05:19.107]                 ...future.makeSendCondition <- base::local({
[18:05:19.107]                   sendCondition <- NULL
[18:05:19.107]                   function(frame = 1L) {
[18:05:19.107]                     if (is.function(sendCondition)) 
[18:05:19.107]                       return(sendCondition)
[18:05:19.107]                     ns <- getNamespace("parallel")
[18:05:19.107]                     if (exists("sendData", mode = "function", 
[18:05:19.107]                       envir = ns)) {
[18:05:19.107]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:19.107]                         envir = ns)
[18:05:19.107]                       envir <- sys.frame(frame)
[18:05:19.107]                       master <- NULL
[18:05:19.107]                       while (!identical(envir, .GlobalEnv) && 
[18:05:19.107]                         !identical(envir, emptyenv())) {
[18:05:19.107]                         if (exists("master", mode = "list", envir = envir, 
[18:05:19.107]                           inherits = FALSE)) {
[18:05:19.107]                           master <- get("master", mode = "list", 
[18:05:19.107]                             envir = envir, inherits = FALSE)
[18:05:19.107]                           if (inherits(master, c("SOCKnode", 
[18:05:19.107]                             "SOCK0node"))) {
[18:05:19.107]                             sendCondition <<- function(cond) {
[18:05:19.107]                               data <- list(type = "VALUE", value = cond, 
[18:05:19.107]                                 success = TRUE)
[18:05:19.107]                               parallel_sendData(master, data)
[18:05:19.107]                             }
[18:05:19.107]                             return(sendCondition)
[18:05:19.107]                           }
[18:05:19.107]                         }
[18:05:19.107]                         frame <- frame + 1L
[18:05:19.107]                         envir <- sys.frame(frame)
[18:05:19.107]                       }
[18:05:19.107]                     }
[18:05:19.107]                     sendCondition <<- function(cond) NULL
[18:05:19.107]                   }
[18:05:19.107]                 })
[18:05:19.107]                 withCallingHandlers({
[18:05:19.107]                   {
[18:05:19.107]                     gc()
[18:05:19.107]                   }
[18:05:19.107]                 }, immediateCondition = function(cond) {
[18:05:19.107]                   sendCondition <- ...future.makeSendCondition()
[18:05:19.107]                   sendCondition(cond)
[18:05:19.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.107]                   {
[18:05:19.107]                     inherits <- base::inherits
[18:05:19.107]                     invokeRestart <- base::invokeRestart
[18:05:19.107]                     is.null <- base::is.null
[18:05:19.107]                     muffled <- FALSE
[18:05:19.107]                     if (inherits(cond, "message")) {
[18:05:19.107]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:19.107]                       if (muffled) 
[18:05:19.107]                         invokeRestart("muffleMessage")
[18:05:19.107]                     }
[18:05:19.107]                     else if (inherits(cond, "warning")) {
[18:05:19.107]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:19.107]                       if (muffled) 
[18:05:19.107]                         invokeRestart("muffleWarning")
[18:05:19.107]                     }
[18:05:19.107]                     else if (inherits(cond, "condition")) {
[18:05:19.107]                       if (!is.null(pattern)) {
[18:05:19.107]                         computeRestarts <- base::computeRestarts
[18:05:19.107]                         grepl <- base::grepl
[18:05:19.107]                         restarts <- computeRestarts(cond)
[18:05:19.107]                         for (restart in restarts) {
[18:05:19.107]                           name <- restart$name
[18:05:19.107]                           if (is.null(name)) 
[18:05:19.107]                             next
[18:05:19.107]                           if (!grepl(pattern, name)) 
[18:05:19.107]                             next
[18:05:19.107]                           invokeRestart(restart)
[18:05:19.107]                           muffled <- TRUE
[18:05:19.107]                           break
[18:05:19.107]                         }
[18:05:19.107]                       }
[18:05:19.107]                     }
[18:05:19.107]                     invisible(muffled)
[18:05:19.107]                   }
[18:05:19.107]                   muffleCondition(cond)
[18:05:19.107]                 })
[18:05:19.107]             }))
[18:05:19.107]             future::FutureResult(value = ...future.value$value, 
[18:05:19.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:19.107]                   ...future.rng), globalenv = if (FALSE) 
[18:05:19.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:19.107]                     ...future.globalenv.names))
[18:05:19.107]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:19.107]         }, condition = base::local({
[18:05:19.107]             c <- base::c
[18:05:19.107]             inherits <- base::inherits
[18:05:19.107]             invokeRestart <- base::invokeRestart
[18:05:19.107]             length <- base::length
[18:05:19.107]             list <- base::list
[18:05:19.107]             seq.int <- base::seq.int
[18:05:19.107]             signalCondition <- base::signalCondition
[18:05:19.107]             sys.calls <- base::sys.calls
[18:05:19.107]             `[[` <- base::`[[`
[18:05:19.107]             `+` <- base::`+`
[18:05:19.107]             `<<-` <- base::`<<-`
[18:05:19.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:19.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:19.107]                   3L)]
[18:05:19.107]             }
[18:05:19.107]             function(cond) {
[18:05:19.107]                 is_error <- inherits(cond, "error")
[18:05:19.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:19.107]                   NULL)
[18:05:19.107]                 if (is_error) {
[18:05:19.107]                   sessionInformation <- function() {
[18:05:19.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:19.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:19.107]                       search = base::search(), system = base::Sys.info())
[18:05:19.107]                   }
[18:05:19.107]                   ...future.conditions[[length(...future.conditions) + 
[18:05:19.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:19.107]                     cond$call), session = sessionInformation(), 
[18:05:19.107]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:19.107]                   signalCondition(cond)
[18:05:19.107]                 }
[18:05:19.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:19.107]                 "immediateCondition"))) {
[18:05:19.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:19.107]                   ...future.conditions[[length(...future.conditions) + 
[18:05:19.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:19.107]                   if (TRUE && !signal) {
[18:05:19.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.107]                     {
[18:05:19.107]                       inherits <- base::inherits
[18:05:19.107]                       invokeRestart <- base::invokeRestart
[18:05:19.107]                       is.null <- base::is.null
[18:05:19.107]                       muffled <- FALSE
[18:05:19.107]                       if (inherits(cond, "message")) {
[18:05:19.107]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:19.107]                         if (muffled) 
[18:05:19.107]                           invokeRestart("muffleMessage")
[18:05:19.107]                       }
[18:05:19.107]                       else if (inherits(cond, "warning")) {
[18:05:19.107]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:19.107]                         if (muffled) 
[18:05:19.107]                           invokeRestart("muffleWarning")
[18:05:19.107]                       }
[18:05:19.107]                       else if (inherits(cond, "condition")) {
[18:05:19.107]                         if (!is.null(pattern)) {
[18:05:19.107]                           computeRestarts <- base::computeRestarts
[18:05:19.107]                           grepl <- base::grepl
[18:05:19.107]                           restarts <- computeRestarts(cond)
[18:05:19.107]                           for (restart in restarts) {
[18:05:19.107]                             name <- restart$name
[18:05:19.107]                             if (is.null(name)) 
[18:05:19.107]                               next
[18:05:19.107]                             if (!grepl(pattern, name)) 
[18:05:19.107]                               next
[18:05:19.107]                             invokeRestart(restart)
[18:05:19.107]                             muffled <- TRUE
[18:05:19.107]                             break
[18:05:19.107]                           }
[18:05:19.107]                         }
[18:05:19.107]                       }
[18:05:19.107]                       invisible(muffled)
[18:05:19.107]                     }
[18:05:19.107]                     muffleCondition(cond, pattern = "^muffle")
[18:05:19.107]                   }
[18:05:19.107]                 }
[18:05:19.107]                 else {
[18:05:19.107]                   if (TRUE) {
[18:05:19.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.107]                     {
[18:05:19.107]                       inherits <- base::inherits
[18:05:19.107]                       invokeRestart <- base::invokeRestart
[18:05:19.107]                       is.null <- base::is.null
[18:05:19.107]                       muffled <- FALSE
[18:05:19.107]                       if (inherits(cond, "message")) {
[18:05:19.107]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:19.107]                         if (muffled) 
[18:05:19.107]                           invokeRestart("muffleMessage")
[18:05:19.107]                       }
[18:05:19.107]                       else if (inherits(cond, "warning")) {
[18:05:19.107]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:19.107]                         if (muffled) 
[18:05:19.107]                           invokeRestart("muffleWarning")
[18:05:19.107]                       }
[18:05:19.107]                       else if (inherits(cond, "condition")) {
[18:05:19.107]                         if (!is.null(pattern)) {
[18:05:19.107]                           computeRestarts <- base::computeRestarts
[18:05:19.107]                           grepl <- base::grepl
[18:05:19.107]                           restarts <- computeRestarts(cond)
[18:05:19.107]                           for (restart in restarts) {
[18:05:19.107]                             name <- restart$name
[18:05:19.107]                             if (is.null(name)) 
[18:05:19.107]                               next
[18:05:19.107]                             if (!grepl(pattern, name)) 
[18:05:19.107]                               next
[18:05:19.107]                             invokeRestart(restart)
[18:05:19.107]                             muffled <- TRUE
[18:05:19.107]                             break
[18:05:19.107]                           }
[18:05:19.107]                         }
[18:05:19.107]                       }
[18:05:19.107]                       invisible(muffled)
[18:05:19.107]                     }
[18:05:19.107]                     muffleCondition(cond, pattern = "^muffle")
[18:05:19.107]                   }
[18:05:19.107]                 }
[18:05:19.107]             }
[18:05:19.107]         }))
[18:05:19.107]     }, error = function(ex) {
[18:05:19.107]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:19.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:19.107]                 ...future.rng), started = ...future.startTime, 
[18:05:19.107]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:19.107]             version = "1.8"), class = "FutureResult")
[18:05:19.107]     }, finally = {
[18:05:19.107]         if (!identical(...future.workdir, getwd())) 
[18:05:19.107]             setwd(...future.workdir)
[18:05:19.107]         {
[18:05:19.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:19.107]                 ...future.oldOptions$nwarnings <- NULL
[18:05:19.107]             }
[18:05:19.107]             base::options(...future.oldOptions)
[18:05:19.107]             if (.Platform$OS.type == "windows") {
[18:05:19.107]                 old_names <- names(...future.oldEnvVars)
[18:05:19.107]                 envs <- base::Sys.getenv()
[18:05:19.107]                 names <- names(envs)
[18:05:19.107]                 common <- intersect(names, old_names)
[18:05:19.107]                 added <- setdiff(names, old_names)
[18:05:19.107]                 removed <- setdiff(old_names, names)
[18:05:19.107]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:19.107]                   envs[common]]
[18:05:19.107]                 NAMES <- toupper(changed)
[18:05:19.107]                 args <- list()
[18:05:19.107]                 for (kk in seq_along(NAMES)) {
[18:05:19.107]                   name <- changed[[kk]]
[18:05:19.107]                   NAME <- NAMES[[kk]]
[18:05:19.107]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.107]                     next
[18:05:19.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:19.107]                 }
[18:05:19.107]                 NAMES <- toupper(added)
[18:05:19.107]                 for (kk in seq_along(NAMES)) {
[18:05:19.107]                   name <- added[[kk]]
[18:05:19.107]                   NAME <- NAMES[[kk]]
[18:05:19.107]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.107]                     next
[18:05:19.107]                   args[[name]] <- ""
[18:05:19.107]                 }
[18:05:19.107]                 NAMES <- toupper(removed)
[18:05:19.107]                 for (kk in seq_along(NAMES)) {
[18:05:19.107]                   name <- removed[[kk]]
[18:05:19.107]                   NAME <- NAMES[[kk]]
[18:05:19.107]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.107]                     next
[18:05:19.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:19.107]                 }
[18:05:19.107]                 if (length(args) > 0) 
[18:05:19.107]                   base::do.call(base::Sys.setenv, args = args)
[18:05:19.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:19.107]             }
[18:05:19.107]             else {
[18:05:19.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:19.107]             }
[18:05:19.107]             {
[18:05:19.107]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:19.107]                   0L) {
[18:05:19.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:19.107]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:19.107]                   base::options(opts)
[18:05:19.107]                 }
[18:05:19.107]                 {
[18:05:19.107]                   {
[18:05:19.107]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:19.107]                     NULL
[18:05:19.107]                   }
[18:05:19.107]                   options(future.plan = NULL)
[18:05:19.107]                   if (is.na(NA_character_)) 
[18:05:19.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:19.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:19.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:19.107]                     .init = FALSE)
[18:05:19.107]                 }
[18:05:19.107]             }
[18:05:19.107]         }
[18:05:19.107]     })
[18:05:19.107]     if (TRUE) {
[18:05:19.107]         base::sink(type = "output", split = FALSE)
[18:05:19.107]         if (TRUE) {
[18:05:19.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:19.107]         }
[18:05:19.107]         else {
[18:05:19.107]             ...future.result["stdout"] <- base::list(NULL)
[18:05:19.107]         }
[18:05:19.107]         base::close(...future.stdout)
[18:05:19.107]         ...future.stdout <- NULL
[18:05:19.107]     }
[18:05:19.107]     ...future.result$conditions <- ...future.conditions
[18:05:19.107]     ...future.result$finished <- base::Sys.time()
[18:05:19.107]     ...future.result
[18:05:19.107] }
[18:05:19.112] MultisessionFuture started
[18:05:19.112] - Launch lazy future ... done
[18:05:19.113] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[18:05:19.113] result() for ClusterFuture ...
[18:05:19.113] receiveMessageFromWorker() for ClusterFuture ...
[18:05:19.113] - Validating connection of MultisessionFuture
[18:05:19.198] - received message: FutureResult
[18:05:19.198] - Received FutureResult
[18:05:19.198] - Erased future from FutureRegistry
[18:05:19.198] result() for ClusterFuture ...
[18:05:19.199] - result already collected: FutureResult
[18:05:19.199] result() for ClusterFuture ... done
[18:05:19.199] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:19.199] result() for ClusterFuture ... done
[18:05:19.199] result() for ClusterFuture ...
[18:05:19.200] - result already collected: FutureResult
[18:05:19.200] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 407008 21.8     692222   37   692222 37.0
Vcells 729839  5.6    8388608   64  5752039 43.9
> 
> f <- future({ integer(10e6) }, gc = TRUE)
[18:05:19.200] getGlobalsAndPackages() ...
[18:05:19.200] Searching for globals...
[18:05:19.202] - globals found: [2] ‘{’, ‘integer’
[18:05:19.202] Searching for globals ... DONE
[18:05:19.202] Resolving globals: FALSE
[18:05:19.203] 
[18:05:19.203] 
[18:05:19.203] getGlobalsAndPackages() ... DONE
[18:05:19.204] run() for ‘Future’ ...
[18:05:19.204] - state: ‘created’
[18:05:19.205] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:19.223] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:19.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:19.223]   - Field: ‘node’
[18:05:19.223]   - Field: ‘label’
[18:05:19.224]   - Field: ‘local’
[18:05:19.224]   - Field: ‘owner’
[18:05:19.224]   - Field: ‘envir’
[18:05:19.224]   - Field: ‘workers’
[18:05:19.224]   - Field: ‘packages’
[18:05:19.225]   - Field: ‘gc’
[18:05:19.225]   - Field: ‘conditions’
[18:05:19.225]   - Field: ‘persistent’
[18:05:19.225]   - Field: ‘expr’
[18:05:19.225]   - Field: ‘uuid’
[18:05:19.226]   - Field: ‘seed’
[18:05:19.226]   - Field: ‘version’
[18:05:19.226]   - Field: ‘result’
[18:05:19.226]   - Field: ‘asynchronous’
[18:05:19.226]   - Field: ‘calls’
[18:05:19.227]   - Field: ‘globals’
[18:05:19.227]   - Field: ‘stdout’
[18:05:19.227]   - Field: ‘earlySignal’
[18:05:19.227]   - Field: ‘lazy’
[18:05:19.227]   - Field: ‘state’
[18:05:19.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:19.228] - Launch lazy future ...
[18:05:19.228] Packages needed by the future expression (n = 0): <none>
[18:05:19.228] Packages needed by future strategies (n = 0): <none>
[18:05:19.229] {
[18:05:19.229]     {
[18:05:19.229]         {
[18:05:19.229]             ...future.startTime <- base::Sys.time()
[18:05:19.229]             {
[18:05:19.229]                 {
[18:05:19.229]                   {
[18:05:19.229]                     {
[18:05:19.229]                       base::local({
[18:05:19.229]                         has_future <- base::requireNamespace("future", 
[18:05:19.229]                           quietly = TRUE)
[18:05:19.229]                         if (has_future) {
[18:05:19.229]                           ns <- base::getNamespace("future")
[18:05:19.229]                           version <- ns[[".package"]][["version"]]
[18:05:19.229]                           if (is.null(version)) 
[18:05:19.229]                             version <- utils::packageVersion("future")
[18:05:19.229]                         }
[18:05:19.229]                         else {
[18:05:19.229]                           version <- NULL
[18:05:19.229]                         }
[18:05:19.229]                         if (!has_future || version < "1.8.0") {
[18:05:19.229]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:19.229]                             "", base::R.version$version.string), 
[18:05:19.229]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:19.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:19.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:19.229]                               "release", "version")], collapse = " "), 
[18:05:19.229]                             hostname = base::Sys.info()[["nodename"]])
[18:05:19.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:19.229]                             info)
[18:05:19.229]                           info <- base::paste(info, collapse = "; ")
[18:05:19.229]                           if (!has_future) {
[18:05:19.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:19.229]                               info)
[18:05:19.229]                           }
[18:05:19.229]                           else {
[18:05:19.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:19.229]                               info, version)
[18:05:19.229]                           }
[18:05:19.229]                           base::stop(msg)
[18:05:19.229]                         }
[18:05:19.229]                       })
[18:05:19.229]                     }
[18:05:19.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:19.229]                     base::options(mc.cores = 1L)
[18:05:19.229]                   }
[18:05:19.229]                   ...future.strategy.old <- future::plan("list")
[18:05:19.229]                   options(future.plan = NULL)
[18:05:19.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:19.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:19.229]                 }
[18:05:19.229]                 ...future.workdir <- getwd()
[18:05:19.229]             }
[18:05:19.229]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:19.229]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:19.229]         }
[18:05:19.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:19.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:19.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:19.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:19.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:19.229]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:19.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:19.229]             base::names(...future.oldOptions))
[18:05:19.229]     }
[18:05:19.229]     if (FALSE) {
[18:05:19.229]     }
[18:05:19.229]     else {
[18:05:19.229]         if (TRUE) {
[18:05:19.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:19.229]                 open = "w")
[18:05:19.229]         }
[18:05:19.229]         else {
[18:05:19.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:19.229]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:19.229]         }
[18:05:19.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:19.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:19.229]             base::sink(type = "output", split = FALSE)
[18:05:19.229]             base::close(...future.stdout)
[18:05:19.229]         }, add = TRUE)
[18:05:19.229]     }
[18:05:19.229]     ...future.frame <- base::sys.nframe()
[18:05:19.229]     ...future.conditions <- base::list()
[18:05:19.229]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:19.229]     if (FALSE) {
[18:05:19.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:19.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:19.229]     }
[18:05:19.229]     ...future.result <- base::tryCatch({
[18:05:19.229]         base::withCallingHandlers({
[18:05:19.229]             ...future.value <- base::withVisible(base::local({
[18:05:19.229]                 ...future.makeSendCondition <- base::local({
[18:05:19.229]                   sendCondition <- NULL
[18:05:19.229]                   function(frame = 1L) {
[18:05:19.229]                     if (is.function(sendCondition)) 
[18:05:19.229]                       return(sendCondition)
[18:05:19.229]                     ns <- getNamespace("parallel")
[18:05:19.229]                     if (exists("sendData", mode = "function", 
[18:05:19.229]                       envir = ns)) {
[18:05:19.229]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:19.229]                         envir = ns)
[18:05:19.229]                       envir <- sys.frame(frame)
[18:05:19.229]                       master <- NULL
[18:05:19.229]                       while (!identical(envir, .GlobalEnv) && 
[18:05:19.229]                         !identical(envir, emptyenv())) {
[18:05:19.229]                         if (exists("master", mode = "list", envir = envir, 
[18:05:19.229]                           inherits = FALSE)) {
[18:05:19.229]                           master <- get("master", mode = "list", 
[18:05:19.229]                             envir = envir, inherits = FALSE)
[18:05:19.229]                           if (inherits(master, c("SOCKnode", 
[18:05:19.229]                             "SOCK0node"))) {
[18:05:19.229]                             sendCondition <<- function(cond) {
[18:05:19.229]                               data <- list(type = "VALUE", value = cond, 
[18:05:19.229]                                 success = TRUE)
[18:05:19.229]                               parallel_sendData(master, data)
[18:05:19.229]                             }
[18:05:19.229]                             return(sendCondition)
[18:05:19.229]                           }
[18:05:19.229]                         }
[18:05:19.229]                         frame <- frame + 1L
[18:05:19.229]                         envir <- sys.frame(frame)
[18:05:19.229]                       }
[18:05:19.229]                     }
[18:05:19.229]                     sendCondition <<- function(cond) NULL
[18:05:19.229]                   }
[18:05:19.229]                 })
[18:05:19.229]                 withCallingHandlers({
[18:05:19.229]                   {
[18:05:19.229]                     integer(1e+07)
[18:05:19.229]                   }
[18:05:19.229]                 }, immediateCondition = function(cond) {
[18:05:19.229]                   sendCondition <- ...future.makeSendCondition()
[18:05:19.229]                   sendCondition(cond)
[18:05:19.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.229]                   {
[18:05:19.229]                     inherits <- base::inherits
[18:05:19.229]                     invokeRestart <- base::invokeRestart
[18:05:19.229]                     is.null <- base::is.null
[18:05:19.229]                     muffled <- FALSE
[18:05:19.229]                     if (inherits(cond, "message")) {
[18:05:19.229]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:19.229]                       if (muffled) 
[18:05:19.229]                         invokeRestart("muffleMessage")
[18:05:19.229]                     }
[18:05:19.229]                     else if (inherits(cond, "warning")) {
[18:05:19.229]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:19.229]                       if (muffled) 
[18:05:19.229]                         invokeRestart("muffleWarning")
[18:05:19.229]                     }
[18:05:19.229]                     else if (inherits(cond, "condition")) {
[18:05:19.229]                       if (!is.null(pattern)) {
[18:05:19.229]                         computeRestarts <- base::computeRestarts
[18:05:19.229]                         grepl <- base::grepl
[18:05:19.229]                         restarts <- computeRestarts(cond)
[18:05:19.229]                         for (restart in restarts) {
[18:05:19.229]                           name <- restart$name
[18:05:19.229]                           if (is.null(name)) 
[18:05:19.229]                             next
[18:05:19.229]                           if (!grepl(pattern, name)) 
[18:05:19.229]                             next
[18:05:19.229]                           invokeRestart(restart)
[18:05:19.229]                           muffled <- TRUE
[18:05:19.229]                           break
[18:05:19.229]                         }
[18:05:19.229]                       }
[18:05:19.229]                     }
[18:05:19.229]                     invisible(muffled)
[18:05:19.229]                   }
[18:05:19.229]                   muffleCondition(cond)
[18:05:19.229]                 })
[18:05:19.229]             }))
[18:05:19.229]             future::FutureResult(value = ...future.value$value, 
[18:05:19.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:19.229]                   ...future.rng), globalenv = if (FALSE) 
[18:05:19.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:19.229]                     ...future.globalenv.names))
[18:05:19.229]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:19.229]         }, condition = base::local({
[18:05:19.229]             c <- base::c
[18:05:19.229]             inherits <- base::inherits
[18:05:19.229]             invokeRestart <- base::invokeRestart
[18:05:19.229]             length <- base::length
[18:05:19.229]             list <- base::list
[18:05:19.229]             seq.int <- base::seq.int
[18:05:19.229]             signalCondition <- base::signalCondition
[18:05:19.229]             sys.calls <- base::sys.calls
[18:05:19.229]             `[[` <- base::`[[`
[18:05:19.229]             `+` <- base::`+`
[18:05:19.229]             `<<-` <- base::`<<-`
[18:05:19.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:19.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:19.229]                   3L)]
[18:05:19.229]             }
[18:05:19.229]             function(cond) {
[18:05:19.229]                 is_error <- inherits(cond, "error")
[18:05:19.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:19.229]                   NULL)
[18:05:19.229]                 if (is_error) {
[18:05:19.229]                   sessionInformation <- function() {
[18:05:19.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:19.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:19.229]                       search = base::search(), system = base::Sys.info())
[18:05:19.229]                   }
[18:05:19.229]                   ...future.conditions[[length(...future.conditions) + 
[18:05:19.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:19.229]                     cond$call), session = sessionInformation(), 
[18:05:19.229]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:19.229]                   signalCondition(cond)
[18:05:19.229]                 }
[18:05:19.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:19.229]                 "immediateCondition"))) {
[18:05:19.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:19.229]                   ...future.conditions[[length(...future.conditions) + 
[18:05:19.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:19.229]                   if (TRUE && !signal) {
[18:05:19.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.229]                     {
[18:05:19.229]                       inherits <- base::inherits
[18:05:19.229]                       invokeRestart <- base::invokeRestart
[18:05:19.229]                       is.null <- base::is.null
[18:05:19.229]                       muffled <- FALSE
[18:05:19.229]                       if (inherits(cond, "message")) {
[18:05:19.229]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:19.229]                         if (muffled) 
[18:05:19.229]                           invokeRestart("muffleMessage")
[18:05:19.229]                       }
[18:05:19.229]                       else if (inherits(cond, "warning")) {
[18:05:19.229]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:19.229]                         if (muffled) 
[18:05:19.229]                           invokeRestart("muffleWarning")
[18:05:19.229]                       }
[18:05:19.229]                       else if (inherits(cond, "condition")) {
[18:05:19.229]                         if (!is.null(pattern)) {
[18:05:19.229]                           computeRestarts <- base::computeRestarts
[18:05:19.229]                           grepl <- base::grepl
[18:05:19.229]                           restarts <- computeRestarts(cond)
[18:05:19.229]                           for (restart in restarts) {
[18:05:19.229]                             name <- restart$name
[18:05:19.229]                             if (is.null(name)) 
[18:05:19.229]                               next
[18:05:19.229]                             if (!grepl(pattern, name)) 
[18:05:19.229]                               next
[18:05:19.229]                             invokeRestart(restart)
[18:05:19.229]                             muffled <- TRUE
[18:05:19.229]                             break
[18:05:19.229]                           }
[18:05:19.229]                         }
[18:05:19.229]                       }
[18:05:19.229]                       invisible(muffled)
[18:05:19.229]                     }
[18:05:19.229]                     muffleCondition(cond, pattern = "^muffle")
[18:05:19.229]                   }
[18:05:19.229]                 }
[18:05:19.229]                 else {
[18:05:19.229]                   if (TRUE) {
[18:05:19.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.229]                     {
[18:05:19.229]                       inherits <- base::inherits
[18:05:19.229]                       invokeRestart <- base::invokeRestart
[18:05:19.229]                       is.null <- base::is.null
[18:05:19.229]                       muffled <- FALSE
[18:05:19.229]                       if (inherits(cond, "message")) {
[18:05:19.229]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:19.229]                         if (muffled) 
[18:05:19.229]                           invokeRestart("muffleMessage")
[18:05:19.229]                       }
[18:05:19.229]                       else if (inherits(cond, "warning")) {
[18:05:19.229]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:19.229]                         if (muffled) 
[18:05:19.229]                           invokeRestart("muffleWarning")
[18:05:19.229]                       }
[18:05:19.229]                       else if (inherits(cond, "condition")) {
[18:05:19.229]                         if (!is.null(pattern)) {
[18:05:19.229]                           computeRestarts <- base::computeRestarts
[18:05:19.229]                           grepl <- base::grepl
[18:05:19.229]                           restarts <- computeRestarts(cond)
[18:05:19.229]                           for (restart in restarts) {
[18:05:19.229]                             name <- restart$name
[18:05:19.229]                             if (is.null(name)) 
[18:05:19.229]                               next
[18:05:19.229]                             if (!grepl(pattern, name)) 
[18:05:19.229]                               next
[18:05:19.229]                             invokeRestart(restart)
[18:05:19.229]                             muffled <- TRUE
[18:05:19.229]                             break
[18:05:19.229]                           }
[18:05:19.229]                         }
[18:05:19.229]                       }
[18:05:19.229]                       invisible(muffled)
[18:05:19.229]                     }
[18:05:19.229]                     muffleCondition(cond, pattern = "^muffle")
[18:05:19.229]                   }
[18:05:19.229]                 }
[18:05:19.229]             }
[18:05:19.229]         }))
[18:05:19.229]     }, error = function(ex) {
[18:05:19.229]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:19.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:19.229]                 ...future.rng), started = ...future.startTime, 
[18:05:19.229]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:19.229]             version = "1.8"), class = "FutureResult")
[18:05:19.229]     }, finally = {
[18:05:19.229]         if (!identical(...future.workdir, getwd())) 
[18:05:19.229]             setwd(...future.workdir)
[18:05:19.229]         {
[18:05:19.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:19.229]                 ...future.oldOptions$nwarnings <- NULL
[18:05:19.229]             }
[18:05:19.229]             base::options(...future.oldOptions)
[18:05:19.229]             if (.Platform$OS.type == "windows") {
[18:05:19.229]                 old_names <- names(...future.oldEnvVars)
[18:05:19.229]                 envs <- base::Sys.getenv()
[18:05:19.229]                 names <- names(envs)
[18:05:19.229]                 common <- intersect(names, old_names)
[18:05:19.229]                 added <- setdiff(names, old_names)
[18:05:19.229]                 removed <- setdiff(old_names, names)
[18:05:19.229]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:19.229]                   envs[common]]
[18:05:19.229]                 NAMES <- toupper(changed)
[18:05:19.229]                 args <- list()
[18:05:19.229]                 for (kk in seq_along(NAMES)) {
[18:05:19.229]                   name <- changed[[kk]]
[18:05:19.229]                   NAME <- NAMES[[kk]]
[18:05:19.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.229]                     next
[18:05:19.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:19.229]                 }
[18:05:19.229]                 NAMES <- toupper(added)
[18:05:19.229]                 for (kk in seq_along(NAMES)) {
[18:05:19.229]                   name <- added[[kk]]
[18:05:19.229]                   NAME <- NAMES[[kk]]
[18:05:19.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.229]                     next
[18:05:19.229]                   args[[name]] <- ""
[18:05:19.229]                 }
[18:05:19.229]                 NAMES <- toupper(removed)
[18:05:19.229]                 for (kk in seq_along(NAMES)) {
[18:05:19.229]                   name <- removed[[kk]]
[18:05:19.229]                   NAME <- NAMES[[kk]]
[18:05:19.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.229]                     next
[18:05:19.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:19.229]                 }
[18:05:19.229]                 if (length(args) > 0) 
[18:05:19.229]                   base::do.call(base::Sys.setenv, args = args)
[18:05:19.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:19.229]             }
[18:05:19.229]             else {
[18:05:19.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:19.229]             }
[18:05:19.229]             {
[18:05:19.229]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:19.229]                   0L) {
[18:05:19.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:19.229]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:19.229]                   base::options(opts)
[18:05:19.229]                 }
[18:05:19.229]                 {
[18:05:19.229]                   {
[18:05:19.229]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:19.229]                     NULL
[18:05:19.229]                   }
[18:05:19.229]                   options(future.plan = NULL)
[18:05:19.229]                   if (is.na(NA_character_)) 
[18:05:19.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:19.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:19.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:19.229]                     .init = FALSE)
[18:05:19.229]                 }
[18:05:19.229]             }
[18:05:19.229]         }
[18:05:19.229]     })
[18:05:19.229]     if (TRUE) {
[18:05:19.229]         base::sink(type = "output", split = FALSE)
[18:05:19.229]         if (TRUE) {
[18:05:19.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:19.229]         }
[18:05:19.229]         else {
[18:05:19.229]             ...future.result["stdout"] <- base::list(NULL)
[18:05:19.229]         }
[18:05:19.229]         base::close(...future.stdout)
[18:05:19.229]         ...future.stdout <- NULL
[18:05:19.229]     }
[18:05:19.229]     ...future.result$conditions <- ...future.conditions
[18:05:19.229]     ...future.result$finished <- base::Sys.time()
[18:05:19.229]     ...future.result
[18:05:19.229] }
[18:05:19.235] MultisessionFuture started
[18:05:19.235] - Launch lazy future ... done
[18:05:19.235] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[18:05:19.236] result() for ClusterFuture ...
[18:05:19.236] receiveMessageFromWorker() for ClusterFuture ...
[18:05:19.236] - Validating connection of MultisessionFuture
[18:05:19.408] - received message: FutureResult
[18:05:19.408] - Received FutureResult
[18:05:19.408] - Erased future from FutureRegistry
[18:05:19.408] result() for ClusterFuture ...
[18:05:19.409] - result already collected: FutureResult
[18:05:19.409] result() for ClusterFuture ... done
[18:05:19.409] - Garbage collecting worker ...
[18:05:19.834] - Garbage collecting worker ... done
[18:05:19.834] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:19.835] result() for ClusterFuture ... done
[18:05:19.835] result() for ClusterFuture ...
[18:05:19.835] - result already collected: FutureResult
[18:05:19.836] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[18:05:19.837] getGlobalsAndPackages() ...
[18:05:19.837] Searching for globals...
[18:05:19.840] - globals found: [2] ‘{’, ‘gc’
[18:05:19.840] Searching for globals ... DONE
[18:05:19.840] Resolving globals: FALSE
[18:05:19.841] 
[18:05:19.842] 
[18:05:19.842] getGlobalsAndPackages() ... DONE
[18:05:19.843] run() for ‘Future’ ...
[18:05:19.843] - state: ‘created’
[18:05:19.843] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:19.872] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:19.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:19.873]   - Field: ‘node’
[18:05:19.873]   - Field: ‘label’
[18:05:19.873]   - Field: ‘local’
[18:05:19.874]   - Field: ‘owner’
[18:05:19.874]   - Field: ‘envir’
[18:05:19.874]   - Field: ‘workers’
[18:05:19.875]   - Field: ‘packages’
[18:05:19.875]   - Field: ‘gc’
[18:05:19.875]   - Field: ‘conditions’
[18:05:19.875]   - Field: ‘persistent’
[18:05:19.876]   - Field: ‘expr’
[18:05:19.876]   - Field: ‘uuid’
[18:05:19.876]   - Field: ‘seed’
[18:05:19.877]   - Field: ‘version’
[18:05:19.877]   - Field: ‘result’
[18:05:19.877]   - Field: ‘asynchronous’
[18:05:19.878]   - Field: ‘calls’
[18:05:19.878]   - Field: ‘globals’
[18:05:19.878]   - Field: ‘stdout’
[18:05:19.878]   - Field: ‘earlySignal’
[18:05:19.879]   - Field: ‘lazy’
[18:05:19.879]   - Field: ‘state’
[18:05:19.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:19.880] - Launch lazy future ...
[18:05:19.880] Packages needed by the future expression (n = 0): <none>
[18:05:19.881] Packages needed by future strategies (n = 0): <none>
[18:05:19.882] {
[18:05:19.882]     {
[18:05:19.882]         {
[18:05:19.882]             ...future.startTime <- base::Sys.time()
[18:05:19.882]             {
[18:05:19.882]                 {
[18:05:19.882]                   {
[18:05:19.882]                     {
[18:05:19.882]                       base::local({
[18:05:19.882]                         has_future <- base::requireNamespace("future", 
[18:05:19.882]                           quietly = TRUE)
[18:05:19.882]                         if (has_future) {
[18:05:19.882]                           ns <- base::getNamespace("future")
[18:05:19.882]                           version <- ns[[".package"]][["version"]]
[18:05:19.882]                           if (is.null(version)) 
[18:05:19.882]                             version <- utils::packageVersion("future")
[18:05:19.882]                         }
[18:05:19.882]                         else {
[18:05:19.882]                           version <- NULL
[18:05:19.882]                         }
[18:05:19.882]                         if (!has_future || version < "1.8.0") {
[18:05:19.882]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:19.882]                             "", base::R.version$version.string), 
[18:05:19.882]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:19.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:19.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:19.882]                               "release", "version")], collapse = " "), 
[18:05:19.882]                             hostname = base::Sys.info()[["nodename"]])
[18:05:19.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:19.882]                             info)
[18:05:19.882]                           info <- base::paste(info, collapse = "; ")
[18:05:19.882]                           if (!has_future) {
[18:05:19.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:19.882]                               info)
[18:05:19.882]                           }
[18:05:19.882]                           else {
[18:05:19.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:19.882]                               info, version)
[18:05:19.882]                           }
[18:05:19.882]                           base::stop(msg)
[18:05:19.882]                         }
[18:05:19.882]                       })
[18:05:19.882]                     }
[18:05:19.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:19.882]                     base::options(mc.cores = 1L)
[18:05:19.882]                   }
[18:05:19.882]                   ...future.strategy.old <- future::plan("list")
[18:05:19.882]                   options(future.plan = NULL)
[18:05:19.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:19.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:19.882]                 }
[18:05:19.882]                 ...future.workdir <- getwd()
[18:05:19.882]             }
[18:05:19.882]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:19.882]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:19.882]         }
[18:05:19.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:19.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:19.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:19.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:19.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:19.882]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:19.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:19.882]             base::names(...future.oldOptions))
[18:05:19.882]     }
[18:05:19.882]     if (FALSE) {
[18:05:19.882]     }
[18:05:19.882]     else {
[18:05:19.882]         if (TRUE) {
[18:05:19.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:19.882]                 open = "w")
[18:05:19.882]         }
[18:05:19.882]         else {
[18:05:19.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:19.882]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:19.882]         }
[18:05:19.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:19.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:19.882]             base::sink(type = "output", split = FALSE)
[18:05:19.882]             base::close(...future.stdout)
[18:05:19.882]         }, add = TRUE)
[18:05:19.882]     }
[18:05:19.882]     ...future.frame <- base::sys.nframe()
[18:05:19.882]     ...future.conditions <- base::list()
[18:05:19.882]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:19.882]     if (FALSE) {
[18:05:19.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:19.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:19.882]     }
[18:05:19.882]     ...future.result <- base::tryCatch({
[18:05:19.882]         base::withCallingHandlers({
[18:05:19.882]             ...future.value <- base::withVisible(base::local({
[18:05:19.882]                 ...future.makeSendCondition <- base::local({
[18:05:19.882]                   sendCondition <- NULL
[18:05:19.882]                   function(frame = 1L) {
[18:05:19.882]                     if (is.function(sendCondition)) 
[18:05:19.882]                       return(sendCondition)
[18:05:19.882]                     ns <- getNamespace("parallel")
[18:05:19.882]                     if (exists("sendData", mode = "function", 
[18:05:19.882]                       envir = ns)) {
[18:05:19.882]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:19.882]                         envir = ns)
[18:05:19.882]                       envir <- sys.frame(frame)
[18:05:19.882]                       master <- NULL
[18:05:19.882]                       while (!identical(envir, .GlobalEnv) && 
[18:05:19.882]                         !identical(envir, emptyenv())) {
[18:05:19.882]                         if (exists("master", mode = "list", envir = envir, 
[18:05:19.882]                           inherits = FALSE)) {
[18:05:19.882]                           master <- get("master", mode = "list", 
[18:05:19.882]                             envir = envir, inherits = FALSE)
[18:05:19.882]                           if (inherits(master, c("SOCKnode", 
[18:05:19.882]                             "SOCK0node"))) {
[18:05:19.882]                             sendCondition <<- function(cond) {
[18:05:19.882]                               data <- list(type = "VALUE", value = cond, 
[18:05:19.882]                                 success = TRUE)
[18:05:19.882]                               parallel_sendData(master, data)
[18:05:19.882]                             }
[18:05:19.882]                             return(sendCondition)
[18:05:19.882]                           }
[18:05:19.882]                         }
[18:05:19.882]                         frame <- frame + 1L
[18:05:19.882]                         envir <- sys.frame(frame)
[18:05:19.882]                       }
[18:05:19.882]                     }
[18:05:19.882]                     sendCondition <<- function(cond) NULL
[18:05:19.882]                   }
[18:05:19.882]                 })
[18:05:19.882]                 withCallingHandlers({
[18:05:19.882]                   {
[18:05:19.882]                     gc()
[18:05:19.882]                   }
[18:05:19.882]                 }, immediateCondition = function(cond) {
[18:05:19.882]                   sendCondition <- ...future.makeSendCondition()
[18:05:19.882]                   sendCondition(cond)
[18:05:19.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.882]                   {
[18:05:19.882]                     inherits <- base::inherits
[18:05:19.882]                     invokeRestart <- base::invokeRestart
[18:05:19.882]                     is.null <- base::is.null
[18:05:19.882]                     muffled <- FALSE
[18:05:19.882]                     if (inherits(cond, "message")) {
[18:05:19.882]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:19.882]                       if (muffled) 
[18:05:19.882]                         invokeRestart("muffleMessage")
[18:05:19.882]                     }
[18:05:19.882]                     else if (inherits(cond, "warning")) {
[18:05:19.882]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:19.882]                       if (muffled) 
[18:05:19.882]                         invokeRestart("muffleWarning")
[18:05:19.882]                     }
[18:05:19.882]                     else if (inherits(cond, "condition")) {
[18:05:19.882]                       if (!is.null(pattern)) {
[18:05:19.882]                         computeRestarts <- base::computeRestarts
[18:05:19.882]                         grepl <- base::grepl
[18:05:19.882]                         restarts <- computeRestarts(cond)
[18:05:19.882]                         for (restart in restarts) {
[18:05:19.882]                           name <- restart$name
[18:05:19.882]                           if (is.null(name)) 
[18:05:19.882]                             next
[18:05:19.882]                           if (!grepl(pattern, name)) 
[18:05:19.882]                             next
[18:05:19.882]                           invokeRestart(restart)
[18:05:19.882]                           muffled <- TRUE
[18:05:19.882]                           break
[18:05:19.882]                         }
[18:05:19.882]                       }
[18:05:19.882]                     }
[18:05:19.882]                     invisible(muffled)
[18:05:19.882]                   }
[18:05:19.882]                   muffleCondition(cond)
[18:05:19.882]                 })
[18:05:19.882]             }))
[18:05:19.882]             future::FutureResult(value = ...future.value$value, 
[18:05:19.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:19.882]                   ...future.rng), globalenv = if (FALSE) 
[18:05:19.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:19.882]                     ...future.globalenv.names))
[18:05:19.882]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:19.882]         }, condition = base::local({
[18:05:19.882]             c <- base::c
[18:05:19.882]             inherits <- base::inherits
[18:05:19.882]             invokeRestart <- base::invokeRestart
[18:05:19.882]             length <- base::length
[18:05:19.882]             list <- base::list
[18:05:19.882]             seq.int <- base::seq.int
[18:05:19.882]             signalCondition <- base::signalCondition
[18:05:19.882]             sys.calls <- base::sys.calls
[18:05:19.882]             `[[` <- base::`[[`
[18:05:19.882]             `+` <- base::`+`
[18:05:19.882]             `<<-` <- base::`<<-`
[18:05:19.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:19.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:19.882]                   3L)]
[18:05:19.882]             }
[18:05:19.882]             function(cond) {
[18:05:19.882]                 is_error <- inherits(cond, "error")
[18:05:19.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:19.882]                   NULL)
[18:05:19.882]                 if (is_error) {
[18:05:19.882]                   sessionInformation <- function() {
[18:05:19.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:19.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:19.882]                       search = base::search(), system = base::Sys.info())
[18:05:19.882]                   }
[18:05:19.882]                   ...future.conditions[[length(...future.conditions) + 
[18:05:19.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:19.882]                     cond$call), session = sessionInformation(), 
[18:05:19.882]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:19.882]                   signalCondition(cond)
[18:05:19.882]                 }
[18:05:19.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:19.882]                 "immediateCondition"))) {
[18:05:19.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:19.882]                   ...future.conditions[[length(...future.conditions) + 
[18:05:19.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:19.882]                   if (TRUE && !signal) {
[18:05:19.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.882]                     {
[18:05:19.882]                       inherits <- base::inherits
[18:05:19.882]                       invokeRestart <- base::invokeRestart
[18:05:19.882]                       is.null <- base::is.null
[18:05:19.882]                       muffled <- FALSE
[18:05:19.882]                       if (inherits(cond, "message")) {
[18:05:19.882]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:19.882]                         if (muffled) 
[18:05:19.882]                           invokeRestart("muffleMessage")
[18:05:19.882]                       }
[18:05:19.882]                       else if (inherits(cond, "warning")) {
[18:05:19.882]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:19.882]                         if (muffled) 
[18:05:19.882]                           invokeRestart("muffleWarning")
[18:05:19.882]                       }
[18:05:19.882]                       else if (inherits(cond, "condition")) {
[18:05:19.882]                         if (!is.null(pattern)) {
[18:05:19.882]                           computeRestarts <- base::computeRestarts
[18:05:19.882]                           grepl <- base::grepl
[18:05:19.882]                           restarts <- computeRestarts(cond)
[18:05:19.882]                           for (restart in restarts) {
[18:05:19.882]                             name <- restart$name
[18:05:19.882]                             if (is.null(name)) 
[18:05:19.882]                               next
[18:05:19.882]                             if (!grepl(pattern, name)) 
[18:05:19.882]                               next
[18:05:19.882]                             invokeRestart(restart)
[18:05:19.882]                             muffled <- TRUE
[18:05:19.882]                             break
[18:05:19.882]                           }
[18:05:19.882]                         }
[18:05:19.882]                       }
[18:05:19.882]                       invisible(muffled)
[18:05:19.882]                     }
[18:05:19.882]                     muffleCondition(cond, pattern = "^muffle")
[18:05:19.882]                   }
[18:05:19.882]                 }
[18:05:19.882]                 else {
[18:05:19.882]                   if (TRUE) {
[18:05:19.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:19.882]                     {
[18:05:19.882]                       inherits <- base::inherits
[18:05:19.882]                       invokeRestart <- base::invokeRestart
[18:05:19.882]                       is.null <- base::is.null
[18:05:19.882]                       muffled <- FALSE
[18:05:19.882]                       if (inherits(cond, "message")) {
[18:05:19.882]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:19.882]                         if (muffled) 
[18:05:19.882]                           invokeRestart("muffleMessage")
[18:05:19.882]                       }
[18:05:19.882]                       else if (inherits(cond, "warning")) {
[18:05:19.882]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:19.882]                         if (muffled) 
[18:05:19.882]                           invokeRestart("muffleWarning")
[18:05:19.882]                       }
[18:05:19.882]                       else if (inherits(cond, "condition")) {
[18:05:19.882]                         if (!is.null(pattern)) {
[18:05:19.882]                           computeRestarts <- base::computeRestarts
[18:05:19.882]                           grepl <- base::grepl
[18:05:19.882]                           restarts <- computeRestarts(cond)
[18:05:19.882]                           for (restart in restarts) {
[18:05:19.882]                             name <- restart$name
[18:05:19.882]                             if (is.null(name)) 
[18:05:19.882]                               next
[18:05:19.882]                             if (!grepl(pattern, name)) 
[18:05:19.882]                               next
[18:05:19.882]                             invokeRestart(restart)
[18:05:19.882]                             muffled <- TRUE
[18:05:19.882]                             break
[18:05:19.882]                           }
[18:05:19.882]                         }
[18:05:19.882]                       }
[18:05:19.882]                       invisible(muffled)
[18:05:19.882]                     }
[18:05:19.882]                     muffleCondition(cond, pattern = "^muffle")
[18:05:19.882]                   }
[18:05:19.882]                 }
[18:05:19.882]             }
[18:05:19.882]         }))
[18:05:19.882]     }, error = function(ex) {
[18:05:19.882]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:19.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:19.882]                 ...future.rng), started = ...future.startTime, 
[18:05:19.882]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:19.882]             version = "1.8"), class = "FutureResult")
[18:05:19.882]     }, finally = {
[18:05:19.882]         if (!identical(...future.workdir, getwd())) 
[18:05:19.882]             setwd(...future.workdir)
[18:05:19.882]         {
[18:05:19.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:19.882]                 ...future.oldOptions$nwarnings <- NULL
[18:05:19.882]             }
[18:05:19.882]             base::options(...future.oldOptions)
[18:05:19.882]             if (.Platform$OS.type == "windows") {
[18:05:19.882]                 old_names <- names(...future.oldEnvVars)
[18:05:19.882]                 envs <- base::Sys.getenv()
[18:05:19.882]                 names <- names(envs)
[18:05:19.882]                 common <- intersect(names, old_names)
[18:05:19.882]                 added <- setdiff(names, old_names)
[18:05:19.882]                 removed <- setdiff(old_names, names)
[18:05:19.882]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:19.882]                   envs[common]]
[18:05:19.882]                 NAMES <- toupper(changed)
[18:05:19.882]                 args <- list()
[18:05:19.882]                 for (kk in seq_along(NAMES)) {
[18:05:19.882]                   name <- changed[[kk]]
[18:05:19.882]                   NAME <- NAMES[[kk]]
[18:05:19.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.882]                     next
[18:05:19.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:19.882]                 }
[18:05:19.882]                 NAMES <- toupper(added)
[18:05:19.882]                 for (kk in seq_along(NAMES)) {
[18:05:19.882]                   name <- added[[kk]]
[18:05:19.882]                   NAME <- NAMES[[kk]]
[18:05:19.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.882]                     next
[18:05:19.882]                   args[[name]] <- ""
[18:05:19.882]                 }
[18:05:19.882]                 NAMES <- toupper(removed)
[18:05:19.882]                 for (kk in seq_along(NAMES)) {
[18:05:19.882]                   name <- removed[[kk]]
[18:05:19.882]                   NAME <- NAMES[[kk]]
[18:05:19.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:19.882]                     next
[18:05:19.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:19.882]                 }
[18:05:19.882]                 if (length(args) > 0) 
[18:05:19.882]                   base::do.call(base::Sys.setenv, args = args)
[18:05:19.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:19.882]             }
[18:05:19.882]             else {
[18:05:19.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:19.882]             }
[18:05:19.882]             {
[18:05:19.882]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:19.882]                   0L) {
[18:05:19.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:19.882]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:19.882]                   base::options(opts)
[18:05:19.882]                 }
[18:05:19.882]                 {
[18:05:19.882]                   {
[18:05:19.882]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:19.882]                     NULL
[18:05:19.882]                   }
[18:05:19.882]                   options(future.plan = NULL)
[18:05:19.882]                   if (is.na(NA_character_)) 
[18:05:19.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:19.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:19.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:19.882]                     .init = FALSE)
[18:05:19.882]                 }
[18:05:19.882]             }
[18:05:19.882]         }
[18:05:19.882]     })
[18:05:19.882]     if (TRUE) {
[18:05:19.882]         base::sink(type = "output", split = FALSE)
[18:05:19.882]         if (TRUE) {
[18:05:19.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:19.882]         }
[18:05:19.882]         else {
[18:05:19.882]             ...future.result["stdout"] <- base::list(NULL)
[18:05:19.882]         }
[18:05:19.882]         base::close(...future.stdout)
[18:05:19.882]         ...future.stdout <- NULL
[18:05:19.882]     }
[18:05:19.882]     ...future.result$conditions <- ...future.conditions
[18:05:19.882]     ...future.result$finished <- base::Sys.time()
[18:05:19.882]     ...future.result
[18:05:19.882] }
[18:05:19.889] MultisessionFuture started
[18:05:19.889] - Launch lazy future ... done
[18:05:19.890] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[18:05:19.890] result() for ClusterFuture ...
[18:05:19.890] receiveMessageFromWorker() for ClusterFuture ...
[18:05:19.891] - Validating connection of MultisessionFuture
[18:05:19.962] - received message: FutureResult
[18:05:19.963] - Received FutureResult
[18:05:19.963] - Erased future from FutureRegistry
[18:05:19.964] result() for ClusterFuture ...
[18:05:19.964] - result already collected: FutureResult
[18:05:19.964] result() for ClusterFuture ... done
[18:05:19.964] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:19.965] result() for ClusterFuture ... done
[18:05:19.965] result() for ClusterFuture ...
[18:05:19.965] - result already collected: FutureResult
[18:05:19.966] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 407153 21.8     899088  48.1   692222  37.0
Vcells 729928  5.6   13477007 102.9 15806188 120.6
> 
> message("*** multisession(..., gc = TRUE) ... TRUE")
*** multisession(..., gc = TRUE) ... TRUE
> 
> 
> message("*** multisession(...) - stopping with plan() change ...")
*** multisession(...) - stopping with plan() change ...
>   
> plan(multisession, workers = 2L)
[18:05:19.967] plan(): Setting new future strategy stack:
[18:05:19.968] List of future strategies:
[18:05:19.968] 1. multisession:
[18:05:19.968]    - args: function (..., workers = 2L, envir = parent.frame())
[18:05:19.968]    - tweaked: TRUE
[18:05:19.968]    - call: plan(multisession, workers = 2L)
[18:05:19.969] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:05:19.969] multisession:
[18:05:19.969] - args: function (..., workers = 2L, envir = parent.frame())
[18:05:19.969] - tweaked: TRUE
[18:05:19.969] - call: plan(multisession, workers = 2L)
[18:05:19.970] getGlobalsAndPackages() ...
[18:05:19.970] Not searching for globals
[18:05:19.971] - globals: [0] <none>
[18:05:19.973] getGlobalsAndPackages() ... DONE
[18:05:19.974] [local output] makeClusterPSOCK() ...
[18:05:19.986] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:05:19.987] [local output] Base port: 11013
[18:05:19.987] [local output] Getting setup options for 2 cluster nodes ...
[18:05:19.988] [local output]  - Node 1 of 2 ...
[18:05:19.991] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:19.995] [local output] Rscript port: 11013

[18:05:19.996] [local output]  - Node 2 of 2 ...
[18:05:19.997] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:20.000] [local output] Rscript port: 11013

[18:05:20.003] [local output] Getting setup options for 2 cluster nodes ... done
[18:05:20.003] [local output]  - Parallel setup requested for some PSOCK nodes
[18:05:20.004] [local output] Setting up PSOCK nodes in parallel
[18:05:20.004] List of 36
[18:05:20.004]  $ worker          : chr "localhost"
[18:05:20.004]   ..- attr(*, "localhost")= logi TRUE
[18:05:20.004]  $ master          : chr "localhost"
[18:05:20.004]  $ port            : int 11013
[18:05:20.004]  $ connectTimeout  : num 120
[18:05:20.004]  $ timeout         : num 2592000
[18:05:20.004]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:05:20.004]  $ homogeneous     : logi TRUE
[18:05:20.004]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:05:20.004]  $ rscript_envs    : NULL
[18:05:20.004]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:20.004]  $ rscript_startup : NULL
[18:05:20.004]  $ rscript_sh      : chr "sh"
[18:05:20.004]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:20.004]  $ methods         : logi TRUE
[18:05:20.004]  $ socketOptions   : chr "no-delay"
[18:05:20.004]  $ useXDR          : logi FALSE
[18:05:20.004]  $ outfile         : chr "/dev/null"
[18:05:20.004]  $ renice          : int NA
[18:05:20.004]  $ rshcmd          : NULL
[18:05:20.004]  $ user            : chr(0) 
[18:05:20.004]  $ revtunnel       : logi FALSE
[18:05:20.004]  $ rshlogfile      : NULL
[18:05:20.004]  $ rshopts         : chr(0) 
[18:05:20.004]  $ rank            : int 1
[18:05:20.004]  $ manual          : logi FALSE
[18:05:20.004]  $ dryrun          : logi FALSE
[18:05:20.004]  $ quiet           : logi FALSE
[18:05:20.004]  $ setup_strategy  : chr "parallel"
[18:05:20.004]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:20.004]  $ pidfile         : chr "/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa047ff54478.pid"
[18:05:20.004]  $ rshcmd_label    : NULL
[18:05:20.004]  $ rsh_call        : NULL
[18:05:20.004]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:20.004]  $ localMachine    : logi TRUE
[18:05:20.004]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:05:20.004]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:05:20.004]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:05:20.004]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:05:20.004]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:05:20.004]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:05:20.004]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:05:20.004]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:05:20.004]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:05:20.004]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:05:20.004]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:05:20.004]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:05:20.004]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:05:20.004]  $ arguments       :List of 28
[18:05:20.004]   ..$ worker          : chr "localhost"
[18:05:20.004]   ..$ master          : NULL
[18:05:20.004]   ..$ port            : int 11013
[18:05:20.004]   ..$ connectTimeout  : num 120
[18:05:20.004]   ..$ timeout         : num 2592000
[18:05:20.004]   ..$ rscript         : NULL
[18:05:20.004]   ..$ homogeneous     : NULL
[18:05:20.004]   ..$ rscript_args    : NULL
[18:05:20.004]   ..$ rscript_envs    : NULL
[18:05:20.004]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:20.004]   ..$ rscript_startup : NULL
[18:05:20.004]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:05:20.004]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:20.004]   ..$ methods         : logi TRUE
[18:05:20.004]   ..$ socketOptions   : chr "no-delay"
[18:05:20.004]   ..$ useXDR          : logi FALSE
[18:05:20.004]   ..$ outfile         : chr "/dev/null"
[18:05:20.004]   ..$ renice          : int NA
[18:05:20.004]   ..$ rshcmd          : NULL
[18:05:20.004]   ..$ user            : NULL
[18:05:20.004]   ..$ revtunnel       : logi NA
[18:05:20.004]   ..$ rshlogfile      : NULL
[18:05:20.004]   ..$ rshopts         : NULL
[18:05:20.004]   ..$ rank            : int 1
[18:05:20.004]   ..$ manual          : logi FALSE
[18:05:20.004]   ..$ dryrun          : logi FALSE
[18:05:20.004]   ..$ quiet           : logi FALSE
[18:05:20.004]   ..$ setup_strategy  : chr "parallel"
[18:05:20.004]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:05:20.046] [local output] System call to launch all workers:
[18:05:20.047] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEQ1uBY/worker.rank=1.parallelly.parent=326148.4fa047ff54478.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11013 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:05:20.047] [local output] Starting PSOCK main server
[18:05:20.048] [local output] Workers launched
[18:05:20.049] [local output] Waiting for workers to connect back
[18:05:20.049]  - [local output] 0 workers out of 2 ready
[18:05:20.427]  - [local output] 0 workers out of 2 ready
[18:05:20.428]  - [local output] 1 workers out of 2 ready
[18:05:20.429]  - [local output] 1 workers out of 2 ready
[18:05:20.430]  - [local output] 2 workers out of 2 ready
[18:05:20.430] [local output] Launching of workers completed
[18:05:20.430] [local output] Collecting session information from workers
[18:05:20.431] [local output]  - Worker #1 of 2
[18:05:20.432] [local output]  - Worker #2 of 2
[18:05:20.433] [local output] makeClusterPSOCK() ... done
[18:05:20.451] Packages needed by the future expression (n = 0): <none>
[18:05:20.451] Packages needed by future strategies (n = 0): <none>
[18:05:20.452] {
[18:05:20.452]     {
[18:05:20.452]         {
[18:05:20.452]             ...future.startTime <- base::Sys.time()
[18:05:20.452]             {
[18:05:20.452]                 {
[18:05:20.452]                   {
[18:05:20.452]                     {
[18:05:20.452]                       base::local({
[18:05:20.452]                         has_future <- base::requireNamespace("future", 
[18:05:20.452]                           quietly = TRUE)
[18:05:20.452]                         if (has_future) {
[18:05:20.452]                           ns <- base::getNamespace("future")
[18:05:20.452]                           version <- ns[[".package"]][["version"]]
[18:05:20.452]                           if (is.null(version)) 
[18:05:20.452]                             version <- utils::packageVersion("future")
[18:05:20.452]                         }
[18:05:20.452]                         else {
[18:05:20.452]                           version <- NULL
[18:05:20.452]                         }
[18:05:20.452]                         if (!has_future || version < "1.8.0") {
[18:05:20.452]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:20.452]                             "", base::R.version$version.string), 
[18:05:20.452]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:20.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:20.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:20.452]                               "release", "version")], collapse = " "), 
[18:05:20.452]                             hostname = base::Sys.info()[["nodename"]])
[18:05:20.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:20.452]                             info)
[18:05:20.452]                           info <- base::paste(info, collapse = "; ")
[18:05:20.452]                           if (!has_future) {
[18:05:20.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:20.452]                               info)
[18:05:20.452]                           }
[18:05:20.452]                           else {
[18:05:20.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:20.452]                               info, version)
[18:05:20.452]                           }
[18:05:20.452]                           base::stop(msg)
[18:05:20.452]                         }
[18:05:20.452]                       })
[18:05:20.452]                     }
[18:05:20.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:20.452]                     base::options(mc.cores = 1L)
[18:05:20.452]                   }
[18:05:20.452]                   ...future.strategy.old <- future::plan("list")
[18:05:20.452]                   options(future.plan = NULL)
[18:05:20.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:20.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:20.452]                 }
[18:05:20.452]                 ...future.workdir <- getwd()
[18:05:20.452]             }
[18:05:20.452]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:20.452]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:20.452]         }
[18:05:20.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:20.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:20.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:20.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:20.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:20.452]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:20.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:20.452]             base::names(...future.oldOptions))
[18:05:20.452]     }
[18:05:20.452]     if (FALSE) {
[18:05:20.452]     }
[18:05:20.452]     else {
[18:05:20.452]         if (TRUE) {
[18:05:20.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:20.452]                 open = "w")
[18:05:20.452]         }
[18:05:20.452]         else {
[18:05:20.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:20.452]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:20.452]         }
[18:05:20.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:20.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:20.452]             base::sink(type = "output", split = FALSE)
[18:05:20.452]             base::close(...future.stdout)
[18:05:20.452]         }, add = TRUE)
[18:05:20.452]     }
[18:05:20.452]     ...future.frame <- base::sys.nframe()
[18:05:20.452]     ...future.conditions <- base::list()
[18:05:20.452]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:20.452]     if (FALSE) {
[18:05:20.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:20.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:20.452]     }
[18:05:20.452]     ...future.result <- base::tryCatch({
[18:05:20.452]         base::withCallingHandlers({
[18:05:20.452]             ...future.value <- base::withVisible(base::local({
[18:05:20.452]                 ...future.makeSendCondition <- base::local({
[18:05:20.452]                   sendCondition <- NULL
[18:05:20.452]                   function(frame = 1L) {
[18:05:20.452]                     if (is.function(sendCondition)) 
[18:05:20.452]                       return(sendCondition)
[18:05:20.452]                     ns <- getNamespace("parallel")
[18:05:20.452]                     if (exists("sendData", mode = "function", 
[18:05:20.452]                       envir = ns)) {
[18:05:20.452]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:20.452]                         envir = ns)
[18:05:20.452]                       envir <- sys.frame(frame)
[18:05:20.452]                       master <- NULL
[18:05:20.452]                       while (!identical(envir, .GlobalEnv) && 
[18:05:20.452]                         !identical(envir, emptyenv())) {
[18:05:20.452]                         if (exists("master", mode = "list", envir = envir, 
[18:05:20.452]                           inherits = FALSE)) {
[18:05:20.452]                           master <- get("master", mode = "list", 
[18:05:20.452]                             envir = envir, inherits = FALSE)
[18:05:20.452]                           if (inherits(master, c("SOCKnode", 
[18:05:20.452]                             "SOCK0node"))) {
[18:05:20.452]                             sendCondition <<- function(cond) {
[18:05:20.452]                               data <- list(type = "VALUE", value = cond, 
[18:05:20.452]                                 success = TRUE)
[18:05:20.452]                               parallel_sendData(master, data)
[18:05:20.452]                             }
[18:05:20.452]                             return(sendCondition)
[18:05:20.452]                           }
[18:05:20.452]                         }
[18:05:20.452]                         frame <- frame + 1L
[18:05:20.452]                         envir <- sys.frame(frame)
[18:05:20.452]                       }
[18:05:20.452]                     }
[18:05:20.452]                     sendCondition <<- function(cond) NULL
[18:05:20.452]                   }
[18:05:20.452]                 })
[18:05:20.452]                 withCallingHandlers({
[18:05:20.452]                   NA
[18:05:20.452]                 }, immediateCondition = function(cond) {
[18:05:20.452]                   sendCondition <- ...future.makeSendCondition()
[18:05:20.452]                   sendCondition(cond)
[18:05:20.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:20.452]                   {
[18:05:20.452]                     inherits <- base::inherits
[18:05:20.452]                     invokeRestart <- base::invokeRestart
[18:05:20.452]                     is.null <- base::is.null
[18:05:20.452]                     muffled <- FALSE
[18:05:20.452]                     if (inherits(cond, "message")) {
[18:05:20.452]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:20.452]                       if (muffled) 
[18:05:20.452]                         invokeRestart("muffleMessage")
[18:05:20.452]                     }
[18:05:20.452]                     else if (inherits(cond, "warning")) {
[18:05:20.452]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:20.452]                       if (muffled) 
[18:05:20.452]                         invokeRestart("muffleWarning")
[18:05:20.452]                     }
[18:05:20.452]                     else if (inherits(cond, "condition")) {
[18:05:20.452]                       if (!is.null(pattern)) {
[18:05:20.452]                         computeRestarts <- base::computeRestarts
[18:05:20.452]                         grepl <- base::grepl
[18:05:20.452]                         restarts <- computeRestarts(cond)
[18:05:20.452]                         for (restart in restarts) {
[18:05:20.452]                           name <- restart$name
[18:05:20.452]                           if (is.null(name)) 
[18:05:20.452]                             next
[18:05:20.452]                           if (!grepl(pattern, name)) 
[18:05:20.452]                             next
[18:05:20.452]                           invokeRestart(restart)
[18:05:20.452]                           muffled <- TRUE
[18:05:20.452]                           break
[18:05:20.452]                         }
[18:05:20.452]                       }
[18:05:20.452]                     }
[18:05:20.452]                     invisible(muffled)
[18:05:20.452]                   }
[18:05:20.452]                   muffleCondition(cond)
[18:05:20.452]                 })
[18:05:20.452]             }))
[18:05:20.452]             future::FutureResult(value = ...future.value$value, 
[18:05:20.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:20.452]                   ...future.rng), globalenv = if (FALSE) 
[18:05:20.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:20.452]                     ...future.globalenv.names))
[18:05:20.452]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:20.452]         }, condition = base::local({
[18:05:20.452]             c <- base::c
[18:05:20.452]             inherits <- base::inherits
[18:05:20.452]             invokeRestart <- base::invokeRestart
[18:05:20.452]             length <- base::length
[18:05:20.452]             list <- base::list
[18:05:20.452]             seq.int <- base::seq.int
[18:05:20.452]             signalCondition <- base::signalCondition
[18:05:20.452]             sys.calls <- base::sys.calls
[18:05:20.452]             `[[` <- base::`[[`
[18:05:20.452]             `+` <- base::`+`
[18:05:20.452]             `<<-` <- base::`<<-`
[18:05:20.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:20.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:20.452]                   3L)]
[18:05:20.452]             }
[18:05:20.452]             function(cond) {
[18:05:20.452]                 is_error <- inherits(cond, "error")
[18:05:20.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:20.452]                   NULL)
[18:05:20.452]                 if (is_error) {
[18:05:20.452]                   sessionInformation <- function() {
[18:05:20.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:20.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:20.452]                       search = base::search(), system = base::Sys.info())
[18:05:20.452]                   }
[18:05:20.452]                   ...future.conditions[[length(...future.conditions) + 
[18:05:20.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:20.452]                     cond$call), session = sessionInformation(), 
[18:05:20.452]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:20.452]                   signalCondition(cond)
[18:05:20.452]                 }
[18:05:20.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:20.452]                 "immediateCondition"))) {
[18:05:20.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:20.452]                   ...future.conditions[[length(...future.conditions) + 
[18:05:20.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:20.452]                   if (TRUE && !signal) {
[18:05:20.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:20.452]                     {
[18:05:20.452]                       inherits <- base::inherits
[18:05:20.452]                       invokeRestart <- base::invokeRestart
[18:05:20.452]                       is.null <- base::is.null
[18:05:20.452]                       muffled <- FALSE
[18:05:20.452]                       if (inherits(cond, "message")) {
[18:05:20.452]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:20.452]                         if (muffled) 
[18:05:20.452]                           invokeRestart("muffleMessage")
[18:05:20.452]                       }
[18:05:20.452]                       else if (inherits(cond, "warning")) {
[18:05:20.452]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:20.452]                         if (muffled) 
[18:05:20.452]                           invokeRestart("muffleWarning")
[18:05:20.452]                       }
[18:05:20.452]                       else if (inherits(cond, "condition")) {
[18:05:20.452]                         if (!is.null(pattern)) {
[18:05:20.452]                           computeRestarts <- base::computeRestarts
[18:05:20.452]                           grepl <- base::grepl
[18:05:20.452]                           restarts <- computeRestarts(cond)
[18:05:20.452]                           for (restart in restarts) {
[18:05:20.452]                             name <- restart$name
[18:05:20.452]                             if (is.null(name)) 
[18:05:20.452]                               next
[18:05:20.452]                             if (!grepl(pattern, name)) 
[18:05:20.452]                               next
[18:05:20.452]                             invokeRestart(restart)
[18:05:20.452]                             muffled <- TRUE
[18:05:20.452]                             break
[18:05:20.452]                           }
[18:05:20.452]                         }
[18:05:20.452]                       }
[18:05:20.452]                       invisible(muffled)
[18:05:20.452]                     }
[18:05:20.452]                     muffleCondition(cond, pattern = "^muffle")
[18:05:20.452]                   }
[18:05:20.452]                 }
[18:05:20.452]                 else {
[18:05:20.452]                   if (TRUE) {
[18:05:20.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:20.452]                     {
[18:05:20.452]                       inherits <- base::inherits
[18:05:20.452]                       invokeRestart <- base::invokeRestart
[18:05:20.452]                       is.null <- base::is.null
[18:05:20.452]                       muffled <- FALSE
[18:05:20.452]                       if (inherits(cond, "message")) {
[18:05:20.452]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:20.452]                         if (muffled) 
[18:05:20.452]                           invokeRestart("muffleMessage")
[18:05:20.452]                       }
[18:05:20.452]                       else if (inherits(cond, "warning")) {
[18:05:20.452]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:20.452]                         if (muffled) 
[18:05:20.452]                           invokeRestart("muffleWarning")
[18:05:20.452]                       }
[18:05:20.452]                       else if (inherits(cond, "condition")) {
[18:05:20.452]                         if (!is.null(pattern)) {
[18:05:20.452]                           computeRestarts <- base::computeRestarts
[18:05:20.452]                           grepl <- base::grepl
[18:05:20.452]                           restarts <- computeRestarts(cond)
[18:05:20.452]                           for (restart in restarts) {
[18:05:20.452]                             name <- restart$name
[18:05:20.452]                             if (is.null(name)) 
[18:05:20.452]                               next
[18:05:20.452]                             if (!grepl(pattern, name)) 
[18:05:20.452]                               next
[18:05:20.452]                             invokeRestart(restart)
[18:05:20.452]                             muffled <- TRUE
[18:05:20.452]                             break
[18:05:20.452]                           }
[18:05:20.452]                         }
[18:05:20.452]                       }
[18:05:20.452]                       invisible(muffled)
[18:05:20.452]                     }
[18:05:20.452]                     muffleCondition(cond, pattern = "^muffle")
[18:05:20.452]                   }
[18:05:20.452]                 }
[18:05:20.452]             }
[18:05:20.452]         }))
[18:05:20.452]     }, error = function(ex) {
[18:05:20.452]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:20.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:20.452]                 ...future.rng), started = ...future.startTime, 
[18:05:20.452]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:20.452]             version = "1.8"), class = "FutureResult")
[18:05:20.452]     }, finally = {
[18:05:20.452]         if (!identical(...future.workdir, getwd())) 
[18:05:20.452]             setwd(...future.workdir)
[18:05:20.452]         {
[18:05:20.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:20.452]                 ...future.oldOptions$nwarnings <- NULL
[18:05:20.452]             }
[18:05:20.452]             base::options(...future.oldOptions)
[18:05:20.452]             if (.Platform$OS.type == "windows") {
[18:05:20.452]                 old_names <- names(...future.oldEnvVars)
[18:05:20.452]                 envs <- base::Sys.getenv()
[18:05:20.452]                 names <- names(envs)
[18:05:20.452]                 common <- intersect(names, old_names)
[18:05:20.452]                 added <- setdiff(names, old_names)
[18:05:20.452]                 removed <- setdiff(old_names, names)
[18:05:20.452]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:20.452]                   envs[common]]
[18:05:20.452]                 NAMES <- toupper(changed)
[18:05:20.452]                 args <- list()
[18:05:20.452]                 for (kk in seq_along(NAMES)) {
[18:05:20.452]                   name <- changed[[kk]]
[18:05:20.452]                   NAME <- NAMES[[kk]]
[18:05:20.452]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:20.452]                     next
[18:05:20.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:20.452]                 }
[18:05:20.452]                 NAMES <- toupper(added)
[18:05:20.452]                 for (kk in seq_along(NAMES)) {
[18:05:20.452]                   name <- added[[kk]]
[18:05:20.452]                   NAME <- NAMES[[kk]]
[18:05:20.452]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:20.452]                     next
[18:05:20.452]                   args[[name]] <- ""
[18:05:20.452]                 }
[18:05:20.452]                 NAMES <- toupper(removed)
[18:05:20.452]                 for (kk in seq_along(NAMES)) {
[18:05:20.452]                   name <- removed[[kk]]
[18:05:20.452]                   NAME <- NAMES[[kk]]
[18:05:20.452]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:20.452]                     next
[18:05:20.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:20.452]                 }
[18:05:20.452]                 if (length(args) > 0) 
[18:05:20.452]                   base::do.call(base::Sys.setenv, args = args)
[18:05:20.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:20.452]             }
[18:05:20.452]             else {
[18:05:20.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:20.452]             }
[18:05:20.452]             {
[18:05:20.452]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:20.452]                   0L) {
[18:05:20.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:20.452]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:20.452]                   base::options(opts)
[18:05:20.452]                 }
[18:05:20.452]                 {
[18:05:20.452]                   {
[18:05:20.452]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:20.452]                     NULL
[18:05:20.452]                   }
[18:05:20.452]                   options(future.plan = NULL)
[18:05:20.452]                   if (is.na(NA_character_)) 
[18:05:20.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:20.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:20.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:20.452]                     .init = FALSE)
[18:05:20.452]                 }
[18:05:20.452]             }
[18:05:20.452]         }
[18:05:20.452]     })
[18:05:20.452]     if (TRUE) {
[18:05:20.452]         base::sink(type = "output", split = FALSE)
[18:05:20.452]         if (TRUE) {
[18:05:20.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:20.452]         }
[18:05:20.452]         else {
[18:05:20.452]             ...future.result["stdout"] <- base::list(NULL)
[18:05:20.452]         }
[18:05:20.452]         base::close(...future.stdout)
[18:05:20.452]         ...future.stdout <- NULL
[18:05:20.452]     }
[18:05:20.452]     ...future.result$conditions <- ...future.conditions
[18:05:20.452]     ...future.result$finished <- base::Sys.time()
[18:05:20.452]     ...future.result
[18:05:20.452] }
[18:05:20.551] MultisessionFuture started
[18:05:20.551] result() for ClusterFuture ...
[18:05:20.552] receiveMessageFromWorker() for ClusterFuture ...
[18:05:20.552] - Validating connection of MultisessionFuture
[18:05:20.618] - received message: FutureResult
[18:05:20.618] - Received FutureResult
[18:05:20.619] - Erased future from FutureRegistry
[18:05:20.619] result() for ClusterFuture ...
[18:05:20.620] - result already collected: FutureResult
[18:05:20.620] result() for ClusterFuture ... done
[18:05:20.620] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:20.620] result() for ClusterFuture ... done
[18:05:20.621] result() for ClusterFuture ...
[18:05:20.621] - result already collected: FutureResult
[18:05:20.621] result() for ClusterFuture ... done
[18:05:20.622] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:05:20.622] plan(): nbrOfWorkers() = 2
> f <- future(1L)
[18:05:20.623] getGlobalsAndPackages() ...
[18:05:20.623] Searching for globals...
[18:05:20.624] 
[18:05:20.625] Searching for globals ... DONE
[18:05:20.625] - globals: [0] <none>
[18:05:20.625] getGlobalsAndPackages() ... DONE
[18:05:20.626] run() for ‘Future’ ...
[18:05:20.626] - state: ‘created’
[18:05:20.627] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:20.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:20.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:20.658]   - Field: ‘node’
[18:05:20.659]   - Field: ‘label’
[18:05:20.659]   - Field: ‘local’
[18:05:20.659]   - Field: ‘owner’
[18:05:20.660]   - Field: ‘envir’
[18:05:20.660]   - Field: ‘workers’
[18:05:20.660]   - Field: ‘packages’
[18:05:20.661]   - Field: ‘gc’
[18:05:20.661]   - Field: ‘conditions’
[18:05:20.661]   - Field: ‘persistent’
[18:05:20.662]   - Field: ‘expr’
[18:05:20.662]   - Field: ‘uuid’
[18:05:20.662]   - Field: ‘seed’
[18:05:20.663]   - Field: ‘version’
[18:05:20.663]   - Field: ‘result’
[18:05:20.663]   - Field: ‘asynchronous’
[18:05:20.664]   - Field: ‘calls’
[18:05:20.664]   - Field: ‘globals’
[18:05:20.664]   - Field: ‘stdout’
[18:05:20.665]   - Field: ‘earlySignal’
[18:05:20.665]   - Field: ‘lazy’
[18:05:20.665]   - Field: ‘state’
[18:05:20.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:20.666] - Launch lazy future ...
[18:05:20.667] Packages needed by the future expression (n = 0): <none>
[18:05:20.667] Packages needed by future strategies (n = 0): <none>
[18:05:20.669] {
[18:05:20.669]     {
[18:05:20.669]         {
[18:05:20.669]             ...future.startTime <- base::Sys.time()
[18:05:20.669]             {
[18:05:20.669]                 {
[18:05:20.669]                   {
[18:05:20.669]                     {
[18:05:20.669]                       base::local({
[18:05:20.669]                         has_future <- base::requireNamespace("future", 
[18:05:20.669]                           quietly = TRUE)
[18:05:20.669]                         if (has_future) {
[18:05:20.669]                           ns <- base::getNamespace("future")
[18:05:20.669]                           version <- ns[[".package"]][["version"]]
[18:05:20.669]                           if (is.null(version)) 
[18:05:20.669]                             version <- utils::packageVersion("future")
[18:05:20.669]                         }
[18:05:20.669]                         else {
[18:05:20.669]                           version <- NULL
[18:05:20.669]                         }
[18:05:20.669]                         if (!has_future || version < "1.8.0") {
[18:05:20.669]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:20.669]                             "", base::R.version$version.string), 
[18:05:20.669]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:20.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:20.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:20.669]                               "release", "version")], collapse = " "), 
[18:05:20.669]                             hostname = base::Sys.info()[["nodename"]])
[18:05:20.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:20.669]                             info)
[18:05:20.669]                           info <- base::paste(info, collapse = "; ")
[18:05:20.669]                           if (!has_future) {
[18:05:20.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:20.669]                               info)
[18:05:20.669]                           }
[18:05:20.669]                           else {
[18:05:20.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:20.669]                               info, version)
[18:05:20.669]                           }
[18:05:20.669]                           base::stop(msg)
[18:05:20.669]                         }
[18:05:20.669]                       })
[18:05:20.669]                     }
[18:05:20.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:20.669]                     base::options(mc.cores = 1L)
[18:05:20.669]                   }
[18:05:20.669]                   ...future.strategy.old <- future::plan("list")
[18:05:20.669]                   options(future.plan = NULL)
[18:05:20.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:20.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:20.669]                 }
[18:05:20.669]                 ...future.workdir <- getwd()
[18:05:20.669]             }
[18:05:20.669]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:20.669]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:20.669]         }
[18:05:20.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:20.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:20.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:20.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:20.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:20.669]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:20.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:20.669]             base::names(...future.oldOptions))
[18:05:20.669]     }
[18:05:20.669]     if (FALSE) {
[18:05:20.669]     }
[18:05:20.669]     else {
[18:05:20.669]         if (TRUE) {
[18:05:20.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:20.669]                 open = "w")
[18:05:20.669]         }
[18:05:20.669]         else {
[18:05:20.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:20.669]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:20.669]         }
[18:05:20.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:20.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:20.669]             base::sink(type = "output", split = FALSE)
[18:05:20.669]             base::close(...future.stdout)
[18:05:20.669]         }, add = TRUE)
[18:05:20.669]     }
[18:05:20.669]     ...future.frame <- base::sys.nframe()
[18:05:20.669]     ...future.conditions <- base::list()
[18:05:20.669]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:20.669]     if (FALSE) {
[18:05:20.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:20.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:20.669]     }
[18:05:20.669]     ...future.result <- base::tryCatch({
[18:05:20.669]         base::withCallingHandlers({
[18:05:20.669]             ...future.value <- base::withVisible(base::local({
[18:05:20.669]                 ...future.makeSendCondition <- base::local({
[18:05:20.669]                   sendCondition <- NULL
[18:05:20.669]                   function(frame = 1L) {
[18:05:20.669]                     if (is.function(sendCondition)) 
[18:05:20.669]                       return(sendCondition)
[18:05:20.669]                     ns <- getNamespace("parallel")
[18:05:20.669]                     if (exists("sendData", mode = "function", 
[18:05:20.669]                       envir = ns)) {
[18:05:20.669]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:20.669]                         envir = ns)
[18:05:20.669]                       envir <- sys.frame(frame)
[18:05:20.669]                       master <- NULL
[18:05:20.669]                       while (!identical(envir, .GlobalEnv) && 
[18:05:20.669]                         !identical(envir, emptyenv())) {
[18:05:20.669]                         if (exists("master", mode = "list", envir = envir, 
[18:05:20.669]                           inherits = FALSE)) {
[18:05:20.669]                           master <- get("master", mode = "list", 
[18:05:20.669]                             envir = envir, inherits = FALSE)
[18:05:20.669]                           if (inherits(master, c("SOCKnode", 
[18:05:20.669]                             "SOCK0node"))) {
[18:05:20.669]                             sendCondition <<- function(cond) {
[18:05:20.669]                               data <- list(type = "VALUE", value = cond, 
[18:05:20.669]                                 success = TRUE)
[18:05:20.669]                               parallel_sendData(master, data)
[18:05:20.669]                             }
[18:05:20.669]                             return(sendCondition)
[18:05:20.669]                           }
[18:05:20.669]                         }
[18:05:20.669]                         frame <- frame + 1L
[18:05:20.669]                         envir <- sys.frame(frame)
[18:05:20.669]                       }
[18:05:20.669]                     }
[18:05:20.669]                     sendCondition <<- function(cond) NULL
[18:05:20.669]                   }
[18:05:20.669]                 })
[18:05:20.669]                 withCallingHandlers({
[18:05:20.669]                   1L
[18:05:20.669]                 }, immediateCondition = function(cond) {
[18:05:20.669]                   sendCondition <- ...future.makeSendCondition()
[18:05:20.669]                   sendCondition(cond)
[18:05:20.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:20.669]                   {
[18:05:20.669]                     inherits <- base::inherits
[18:05:20.669]                     invokeRestart <- base::invokeRestart
[18:05:20.669]                     is.null <- base::is.null
[18:05:20.669]                     muffled <- FALSE
[18:05:20.669]                     if (inherits(cond, "message")) {
[18:05:20.669]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:20.669]                       if (muffled) 
[18:05:20.669]                         invokeRestart("muffleMessage")
[18:05:20.669]                     }
[18:05:20.669]                     else if (inherits(cond, "warning")) {
[18:05:20.669]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:20.669]                       if (muffled) 
[18:05:20.669]                         invokeRestart("muffleWarning")
[18:05:20.669]                     }
[18:05:20.669]                     else if (inherits(cond, "condition")) {
[18:05:20.669]                       if (!is.null(pattern)) {
[18:05:20.669]                         computeRestarts <- base::computeRestarts
[18:05:20.669]                         grepl <- base::grepl
[18:05:20.669]                         restarts <- computeRestarts(cond)
[18:05:20.669]                         for (restart in restarts) {
[18:05:20.669]                           name <- restart$name
[18:05:20.669]                           if (is.null(name)) 
[18:05:20.669]                             next
[18:05:20.669]                           if (!grepl(pattern, name)) 
[18:05:20.669]                             next
[18:05:20.669]                           invokeRestart(restart)
[18:05:20.669]                           muffled <- TRUE
[18:05:20.669]                           break
[18:05:20.669]                         }
[18:05:20.669]                       }
[18:05:20.669]                     }
[18:05:20.669]                     invisible(muffled)
[18:05:20.669]                   }
[18:05:20.669]                   muffleCondition(cond)
[18:05:20.669]                 })
[18:05:20.669]             }))
[18:05:20.669]             future::FutureResult(value = ...future.value$value, 
[18:05:20.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:20.669]                   ...future.rng), globalenv = if (FALSE) 
[18:05:20.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:20.669]                     ...future.globalenv.names))
[18:05:20.669]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:20.669]         }, condition = base::local({
[18:05:20.669]             c <- base::c
[18:05:20.669]             inherits <- base::inherits
[18:05:20.669]             invokeRestart <- base::invokeRestart
[18:05:20.669]             length <- base::length
[18:05:20.669]             list <- base::list
[18:05:20.669]             seq.int <- base::seq.int
[18:05:20.669]             signalCondition <- base::signalCondition
[18:05:20.669]             sys.calls <- base::sys.calls
[18:05:20.669]             `[[` <- base::`[[`
[18:05:20.669]             `+` <- base::`+`
[18:05:20.669]             `<<-` <- base::`<<-`
[18:05:20.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:20.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:20.669]                   3L)]
[18:05:20.669]             }
[18:05:20.669]             function(cond) {
[18:05:20.669]                 is_error <- inherits(cond, "error")
[18:05:20.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:20.669]                   NULL)
[18:05:20.669]                 if (is_error) {
[18:05:20.669]                   sessionInformation <- function() {
[18:05:20.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:20.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:20.669]                       search = base::search(), system = base::Sys.info())
[18:05:20.669]                   }
[18:05:20.669]                   ...future.conditions[[length(...future.conditions) + 
[18:05:20.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:20.669]                     cond$call), session = sessionInformation(), 
[18:05:20.669]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:20.669]                   signalCondition(cond)
[18:05:20.669]                 }
[18:05:20.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:20.669]                 "immediateCondition"))) {
[18:05:20.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:20.669]                   ...future.conditions[[length(...future.conditions) + 
[18:05:20.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:20.669]                   if (TRUE && !signal) {
[18:05:20.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:20.669]                     {
[18:05:20.669]                       inherits <- base::inherits
[18:05:20.669]                       invokeRestart <- base::invokeRestart
[18:05:20.669]                       is.null <- base::is.null
[18:05:20.669]                       muffled <- FALSE
[18:05:20.669]                       if (inherits(cond, "message")) {
[18:05:20.669]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:20.669]                         if (muffled) 
[18:05:20.669]                           invokeRestart("muffleMessage")
[18:05:20.669]                       }
[18:05:20.669]                       else if (inherits(cond, "warning")) {
[18:05:20.669]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:20.669]                         if (muffled) 
[18:05:20.669]                           invokeRestart("muffleWarning")
[18:05:20.669]                       }
[18:05:20.669]                       else if (inherits(cond, "condition")) {
[18:05:20.669]                         if (!is.null(pattern)) {
[18:05:20.669]                           computeRestarts <- base::computeRestarts
[18:05:20.669]                           grepl <- base::grepl
[18:05:20.669]                           restarts <- computeRestarts(cond)
[18:05:20.669]                           for (restart in restarts) {
[18:05:20.669]                             name <- restart$name
[18:05:20.669]                             if (is.null(name)) 
[18:05:20.669]                               next
[18:05:20.669]                             if (!grepl(pattern, name)) 
[18:05:20.669]                               next
[18:05:20.669]                             invokeRestart(restart)
[18:05:20.669]                             muffled <- TRUE
[18:05:20.669]                             break
[18:05:20.669]                           }
[18:05:20.669]                         }
[18:05:20.669]                       }
[18:05:20.669]                       invisible(muffled)
[18:05:20.669]                     }
[18:05:20.669]                     muffleCondition(cond, pattern = "^muffle")
[18:05:20.669]                   }
[18:05:20.669]                 }
[18:05:20.669]                 else {
[18:05:20.669]                   if (TRUE) {
[18:05:20.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:20.669]                     {
[18:05:20.669]                       inherits <- base::inherits
[18:05:20.669]                       invokeRestart <- base::invokeRestart
[18:05:20.669]                       is.null <- base::is.null
[18:05:20.669]                       muffled <- FALSE
[18:05:20.669]                       if (inherits(cond, "message")) {
[18:05:20.669]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:20.669]                         if (muffled) 
[18:05:20.669]                           invokeRestart("muffleMessage")
[18:05:20.669]                       }
[18:05:20.669]                       else if (inherits(cond, "warning")) {
[18:05:20.669]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:20.669]                         if (muffled) 
[18:05:20.669]                           invokeRestart("muffleWarning")
[18:05:20.669]                       }
[18:05:20.669]                       else if (inherits(cond, "condition")) {
[18:05:20.669]                         if (!is.null(pattern)) {
[18:05:20.669]                           computeRestarts <- base::computeRestarts
[18:05:20.669]                           grepl <- base::grepl
[18:05:20.669]                           restarts <- computeRestarts(cond)
[18:05:20.669]                           for (restart in restarts) {
[18:05:20.669]                             name <- restart$name
[18:05:20.669]                             if (is.null(name)) 
[18:05:20.669]                               next
[18:05:20.669]                             if (!grepl(pattern, name)) 
[18:05:20.669]                               next
[18:05:20.669]                             invokeRestart(restart)
[18:05:20.669]                             muffled <- TRUE
[18:05:20.669]                             break
[18:05:20.669]                           }
[18:05:20.669]                         }
[18:05:20.669]                       }
[18:05:20.669]                       invisible(muffled)
[18:05:20.669]                     }
[18:05:20.669]                     muffleCondition(cond, pattern = "^muffle")
[18:05:20.669]                   }
[18:05:20.669]                 }
[18:05:20.669]             }
[18:05:20.669]         }))
[18:05:20.669]     }, error = function(ex) {
[18:05:20.669]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:20.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:20.669]                 ...future.rng), started = ...future.startTime, 
[18:05:20.669]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:20.669]             version = "1.8"), class = "FutureResult")
[18:05:20.669]     }, finally = {
[18:05:20.669]         if (!identical(...future.workdir, getwd())) 
[18:05:20.669]             setwd(...future.workdir)
[18:05:20.669]         {
[18:05:20.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:20.669]                 ...future.oldOptions$nwarnings <- NULL
[18:05:20.669]             }
[18:05:20.669]             base::options(...future.oldOptions)
[18:05:20.669]             if (.Platform$OS.type == "windows") {
[18:05:20.669]                 old_names <- names(...future.oldEnvVars)
[18:05:20.669]                 envs <- base::Sys.getenv()
[18:05:20.669]                 names <- names(envs)
[18:05:20.669]                 common <- intersect(names, old_names)
[18:05:20.669]                 added <- setdiff(names, old_names)
[18:05:20.669]                 removed <- setdiff(old_names, names)
[18:05:20.669]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:20.669]                   envs[common]]
[18:05:20.669]                 NAMES <- toupper(changed)
[18:05:20.669]                 args <- list()
[18:05:20.669]                 for (kk in seq_along(NAMES)) {
[18:05:20.669]                   name <- changed[[kk]]
[18:05:20.669]                   NAME <- NAMES[[kk]]
[18:05:20.669]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:20.669]                     next
[18:05:20.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:20.669]                 }
[18:05:20.669]                 NAMES <- toupper(added)
[18:05:20.669]                 for (kk in seq_along(NAMES)) {
[18:05:20.669]                   name <- added[[kk]]
[18:05:20.669]                   NAME <- NAMES[[kk]]
[18:05:20.669]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:20.669]                     next
[18:05:20.669]                   args[[name]] <- ""
[18:05:20.669]                 }
[18:05:20.669]                 NAMES <- toupper(removed)
[18:05:20.669]                 for (kk in seq_along(NAMES)) {
[18:05:20.669]                   name <- removed[[kk]]
[18:05:20.669]                   NAME <- NAMES[[kk]]
[18:05:20.669]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:20.669]                     next
[18:05:20.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:20.669]                 }
[18:05:20.669]                 if (length(args) > 0) 
[18:05:20.669]                   base::do.call(base::Sys.setenv, args = args)
[18:05:20.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:20.669]             }
[18:05:20.669]             else {
[18:05:20.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:20.669]             }
[18:05:20.669]             {
[18:05:20.669]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:20.669]                   0L) {
[18:05:20.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:20.669]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:20.669]                   base::options(opts)
[18:05:20.669]                 }
[18:05:20.669]                 {
[18:05:20.669]                   {
[18:05:20.669]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:20.669]                     NULL
[18:05:20.669]                   }
[18:05:20.669]                   options(future.plan = NULL)
[18:05:20.669]                   if (is.na(NA_character_)) 
[18:05:20.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:20.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:20.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:20.669]                     .init = FALSE)
[18:05:20.669]                 }
[18:05:20.669]             }
[18:05:20.669]         }
[18:05:20.669]     })
[18:05:20.669]     if (TRUE) {
[18:05:20.669]         base::sink(type = "output", split = FALSE)
[18:05:20.669]         if (TRUE) {
[18:05:20.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:20.669]         }
[18:05:20.669]         else {
[18:05:20.669]             ...future.result["stdout"] <- base::list(NULL)
[18:05:20.669]         }
[18:05:20.669]         base::close(...future.stdout)
[18:05:20.669]         ...future.stdout <- NULL
[18:05:20.669]     }
[18:05:20.669]     ...future.result$conditions <- ...future.conditions
[18:05:20.669]     ...future.result$finished <- base::Sys.time()
[18:05:20.669]     ...future.result
[18:05:20.669] }
[18:05:20.676] MultisessionFuture started
[18:05:20.677] - Launch lazy future ... done
[18:05:20.677] run() for ‘MultisessionFuture’ ... done
> cl <- ClusterRegistry("get")
> stopifnot(inherits(cl, "cluster"), length(cl) >= 1L)
> 
> plan(sequential)
[18:05:20.678] plan(): Setting new future strategy stack:
[18:05:20.678] List of future strategies:
[18:05:20.678] 1. sequential:
[18:05:20.678]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:20.678]    - tweaked: FALSE
[18:05:20.678]    - call: plan(sequential)
[18:05:20.680] plan(): nbrOfWorkers() = 1
> cl <- ClusterRegistry("get")
> stopifnot(is.null(cl), length(cl) == 0L)
>   
> message("*** multisession(...) - stopping with plan() change ... DONE")
*** multisession(...) - stopping with plan() change ... DONE
> 
> message("*** multisession() ... DONE")
*** multisession() ... DONE
> 
> source("incl/end.R")
[18:05:20.683] plan(): Setting new future strategy stack:
[18:05:20.683] List of future strategies:
[18:05:20.683] 1. FutureStrategy:
[18:05:20.683]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:20.683]    - tweaked: FALSE
[18:05:20.683]    - call: future::plan(oplan)
[18:05:20.685] plan(): nbrOfWorkers() = 1
> 
