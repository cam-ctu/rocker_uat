
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:04:23.395] plan(): Setting new future strategy stack:
[17:04:23.395] List of future strategies:
[17:04:23.395] 1. sequential:
[17:04:23.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.395]    - tweaked: FALSE
[17:04:23.395]    - call: future::plan("sequential")
[17:04:23.406] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[17:04:23.457] plan(): Setting new future strategy stack:
[17:04:23.458] List of future strategies:
[17:04:23.458] 1. sequential:
[17:04:23.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.458]    - tweaked: FALSE
[17:04:23.458]    - call: plan(strategy)
[17:04:23.469] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[17:04:23.470] getGlobalsAndPackages() ...
[17:04:23.470] Searching for globals...
[17:04:23.480] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.480] Searching for globals ... DONE
[17:04:23.480] Resolving globals: FALSE
[17:04:23.481] 
[17:04:23.481] - packages: [1] ‘utils’
[17:04:23.481] getGlobalsAndPackages() ... DONE
[17:04:23.482] run() for ‘Future’ ...
[17:04:23.482] - state: ‘created’
[17:04:23.482] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.482] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.483]   - Field: ‘label’
[17:04:23.483]   - Field: ‘local’
[17:04:23.483]   - Field: ‘owner’
[17:04:23.483]   - Field: ‘envir’
[17:04:23.483]   - Field: ‘packages’
[17:04:23.483]   - Field: ‘gc’
[17:04:23.483]   - Field: ‘conditions’
[17:04:23.483]   - Field: ‘expr’
[17:04:23.483]   - Field: ‘uuid’
[17:04:23.483]   - Field: ‘seed’
[17:04:23.484]   - Field: ‘version’
[17:04:23.484]   - Field: ‘result’
[17:04:23.484]   - Field: ‘asynchronous’
[17:04:23.484]   - Field: ‘calls’
[17:04:23.484]   - Field: ‘globals’
[17:04:23.484]   - Field: ‘stdout’
[17:04:23.484]   - Field: ‘earlySignal’
[17:04:23.484]   - Field: ‘lazy’
[17:04:23.484]   - Field: ‘state’
[17:04:23.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.484] - Launch lazy future ...
[17:04:23.485] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.485] Packages needed by future strategies (n = 0): <none>
[17:04:23.486] {
[17:04:23.486]     {
[17:04:23.486]         {
[17:04:23.486]             ...future.startTime <- base::Sys.time()
[17:04:23.486]             {
[17:04:23.486]                 {
[17:04:23.486]                   {
[17:04:23.486]                     {
[17:04:23.486]                       base::local({
[17:04:23.486]                         has_future <- base::requireNamespace("future", 
[17:04:23.486]                           quietly = TRUE)
[17:04:23.486]                         if (has_future) {
[17:04:23.486]                           ns <- base::getNamespace("future")
[17:04:23.486]                           version <- ns[[".package"]][["version"]]
[17:04:23.486]                           if (is.null(version)) 
[17:04:23.486]                             version <- utils::packageVersion("future")
[17:04:23.486]                         }
[17:04:23.486]                         else {
[17:04:23.486]                           version <- NULL
[17:04:23.486]                         }
[17:04:23.486]                         if (!has_future || version < "1.8.0") {
[17:04:23.486]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.486]                             "", base::R.version$version.string), 
[17:04:23.486]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.486]                               "release", "version")], collapse = " "), 
[17:04:23.486]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.486]                             info)
[17:04:23.486]                           info <- base::paste(info, collapse = "; ")
[17:04:23.486]                           if (!has_future) {
[17:04:23.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.486]                               info)
[17:04:23.486]                           }
[17:04:23.486]                           else {
[17:04:23.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.486]                               info, version)
[17:04:23.486]                           }
[17:04:23.486]                           base::stop(msg)
[17:04:23.486]                         }
[17:04:23.486]                       })
[17:04:23.486]                     }
[17:04:23.486]                     base::local({
[17:04:23.486]                       for (pkg in "utils") {
[17:04:23.486]                         base::loadNamespace(pkg)
[17:04:23.486]                         base::library(pkg, character.only = TRUE)
[17:04:23.486]                       }
[17:04:23.486]                     })
[17:04:23.486]                   }
[17:04:23.486]                   ...future.strategy.old <- future::plan("list")
[17:04:23.486]                   options(future.plan = NULL)
[17:04:23.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.486]                 }
[17:04:23.486]                 ...future.workdir <- getwd()
[17:04:23.486]             }
[17:04:23.486]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.486]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.486]         }
[17:04:23.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.486]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.486]             base::names(...future.oldOptions))
[17:04:23.486]     }
[17:04:23.486]     if (FALSE) {
[17:04:23.486]     }
[17:04:23.486]     else {
[17:04:23.486]         if (TRUE) {
[17:04:23.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.486]                 open = "w")
[17:04:23.486]         }
[17:04:23.486]         else {
[17:04:23.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.486]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.486]         }
[17:04:23.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.486]             base::sink(type = "output", split = FALSE)
[17:04:23.486]             base::close(...future.stdout)
[17:04:23.486]         }, add = TRUE)
[17:04:23.486]     }
[17:04:23.486]     ...future.frame <- base::sys.nframe()
[17:04:23.486]     ...future.conditions <- base::list()
[17:04:23.486]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.486]     if (FALSE) {
[17:04:23.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.486]     }
[17:04:23.486]     ...future.result <- base::tryCatch({
[17:04:23.486]         base::withCallingHandlers({
[17:04:23.486]             ...future.value <- base::withVisible(base::local({
[17:04:23.486]                 print(1:50)
[17:04:23.486]                 str(1:50)
[17:04:23.486]                 cat(letters, sep = "-")
[17:04:23.486]                 cat(1:6, collapse = "\n")
[17:04:23.486]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.486]                 42L
[17:04:23.486]             }))
[17:04:23.486]             future::FutureResult(value = ...future.value$value, 
[17:04:23.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.486]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.486]                     ...future.globalenv.names))
[17:04:23.486]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.486]         }, condition = base::local({
[17:04:23.486]             c <- base::c
[17:04:23.486]             inherits <- base::inherits
[17:04:23.486]             invokeRestart <- base::invokeRestart
[17:04:23.486]             length <- base::length
[17:04:23.486]             list <- base::list
[17:04:23.486]             seq.int <- base::seq.int
[17:04:23.486]             signalCondition <- base::signalCondition
[17:04:23.486]             sys.calls <- base::sys.calls
[17:04:23.486]             `[[` <- base::`[[`
[17:04:23.486]             `+` <- base::`+`
[17:04:23.486]             `<<-` <- base::`<<-`
[17:04:23.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.486]                   3L)]
[17:04:23.486]             }
[17:04:23.486]             function(cond) {
[17:04:23.486]                 is_error <- inherits(cond, "error")
[17:04:23.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.486]                   NULL)
[17:04:23.486]                 if (is_error) {
[17:04:23.486]                   sessionInformation <- function() {
[17:04:23.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.486]                       search = base::search(), system = base::Sys.info())
[17:04:23.486]                   }
[17:04:23.486]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.486]                     cond$call), session = sessionInformation(), 
[17:04:23.486]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.486]                   signalCondition(cond)
[17:04:23.486]                 }
[17:04:23.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.486]                 "immediateCondition"))) {
[17:04:23.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.486]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.486]                   if (TRUE && !signal) {
[17:04:23.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.486]                     {
[17:04:23.486]                       inherits <- base::inherits
[17:04:23.486]                       invokeRestart <- base::invokeRestart
[17:04:23.486]                       is.null <- base::is.null
[17:04:23.486]                       muffled <- FALSE
[17:04:23.486]                       if (inherits(cond, "message")) {
[17:04:23.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.486]                         if (muffled) 
[17:04:23.486]                           invokeRestart("muffleMessage")
[17:04:23.486]                       }
[17:04:23.486]                       else if (inherits(cond, "warning")) {
[17:04:23.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.486]                         if (muffled) 
[17:04:23.486]                           invokeRestart("muffleWarning")
[17:04:23.486]                       }
[17:04:23.486]                       else if (inherits(cond, "condition")) {
[17:04:23.486]                         if (!is.null(pattern)) {
[17:04:23.486]                           computeRestarts <- base::computeRestarts
[17:04:23.486]                           grepl <- base::grepl
[17:04:23.486]                           restarts <- computeRestarts(cond)
[17:04:23.486]                           for (restart in restarts) {
[17:04:23.486]                             name <- restart$name
[17:04:23.486]                             if (is.null(name)) 
[17:04:23.486]                               next
[17:04:23.486]                             if (!grepl(pattern, name)) 
[17:04:23.486]                               next
[17:04:23.486]                             invokeRestart(restart)
[17:04:23.486]                             muffled <- TRUE
[17:04:23.486]                             break
[17:04:23.486]                           }
[17:04:23.486]                         }
[17:04:23.486]                       }
[17:04:23.486]                       invisible(muffled)
[17:04:23.486]                     }
[17:04:23.486]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.486]                   }
[17:04:23.486]                 }
[17:04:23.486]                 else {
[17:04:23.486]                   if (TRUE) {
[17:04:23.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.486]                     {
[17:04:23.486]                       inherits <- base::inherits
[17:04:23.486]                       invokeRestart <- base::invokeRestart
[17:04:23.486]                       is.null <- base::is.null
[17:04:23.486]                       muffled <- FALSE
[17:04:23.486]                       if (inherits(cond, "message")) {
[17:04:23.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.486]                         if (muffled) 
[17:04:23.486]                           invokeRestart("muffleMessage")
[17:04:23.486]                       }
[17:04:23.486]                       else if (inherits(cond, "warning")) {
[17:04:23.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.486]                         if (muffled) 
[17:04:23.486]                           invokeRestart("muffleWarning")
[17:04:23.486]                       }
[17:04:23.486]                       else if (inherits(cond, "condition")) {
[17:04:23.486]                         if (!is.null(pattern)) {
[17:04:23.486]                           computeRestarts <- base::computeRestarts
[17:04:23.486]                           grepl <- base::grepl
[17:04:23.486]                           restarts <- computeRestarts(cond)
[17:04:23.486]                           for (restart in restarts) {
[17:04:23.486]                             name <- restart$name
[17:04:23.486]                             if (is.null(name)) 
[17:04:23.486]                               next
[17:04:23.486]                             if (!grepl(pattern, name)) 
[17:04:23.486]                               next
[17:04:23.486]                             invokeRestart(restart)
[17:04:23.486]                             muffled <- TRUE
[17:04:23.486]                             break
[17:04:23.486]                           }
[17:04:23.486]                         }
[17:04:23.486]                       }
[17:04:23.486]                       invisible(muffled)
[17:04:23.486]                     }
[17:04:23.486]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.486]                   }
[17:04:23.486]                 }
[17:04:23.486]             }
[17:04:23.486]         }))
[17:04:23.486]     }, error = function(ex) {
[17:04:23.486]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.486]                 ...future.rng), started = ...future.startTime, 
[17:04:23.486]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.486]             version = "1.8"), class = "FutureResult")
[17:04:23.486]     }, finally = {
[17:04:23.486]         if (!identical(...future.workdir, getwd())) 
[17:04:23.486]             setwd(...future.workdir)
[17:04:23.486]         {
[17:04:23.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.486]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.486]             }
[17:04:23.486]             base::options(...future.oldOptions)
[17:04:23.486]             if (.Platform$OS.type == "windows") {
[17:04:23.486]                 old_names <- names(...future.oldEnvVars)
[17:04:23.486]                 envs <- base::Sys.getenv()
[17:04:23.486]                 names <- names(envs)
[17:04:23.486]                 common <- intersect(names, old_names)
[17:04:23.486]                 added <- setdiff(names, old_names)
[17:04:23.486]                 removed <- setdiff(old_names, names)
[17:04:23.486]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.486]                   envs[common]]
[17:04:23.486]                 NAMES <- toupper(changed)
[17:04:23.486]                 args <- list()
[17:04:23.486]                 for (kk in seq_along(NAMES)) {
[17:04:23.486]                   name <- changed[[kk]]
[17:04:23.486]                   NAME <- NAMES[[kk]]
[17:04:23.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.486]                     next
[17:04:23.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.486]                 }
[17:04:23.486]                 NAMES <- toupper(added)
[17:04:23.486]                 for (kk in seq_along(NAMES)) {
[17:04:23.486]                   name <- added[[kk]]
[17:04:23.486]                   NAME <- NAMES[[kk]]
[17:04:23.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.486]                     next
[17:04:23.486]                   args[[name]] <- ""
[17:04:23.486]                 }
[17:04:23.486]                 NAMES <- toupper(removed)
[17:04:23.486]                 for (kk in seq_along(NAMES)) {
[17:04:23.486]                   name <- removed[[kk]]
[17:04:23.486]                   NAME <- NAMES[[kk]]
[17:04:23.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.486]                     next
[17:04:23.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.486]                 }
[17:04:23.486]                 if (length(args) > 0) 
[17:04:23.486]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.486]             }
[17:04:23.486]             else {
[17:04:23.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.486]             }
[17:04:23.486]             {
[17:04:23.486]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.486]                   0L) {
[17:04:23.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.486]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.486]                   base::options(opts)
[17:04:23.486]                 }
[17:04:23.486]                 {
[17:04:23.486]                   {
[17:04:23.486]                     NULL
[17:04:23.486]                     RNGkind("Mersenne-Twister")
[17:04:23.486]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.486]                       inherits = FALSE)
[17:04:23.486]                   }
[17:04:23.486]                   options(future.plan = NULL)
[17:04:23.486]                   if (is.na(NA_character_)) 
[17:04:23.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.486]                     .init = FALSE)
[17:04:23.486]                 }
[17:04:23.486]             }
[17:04:23.486]         }
[17:04:23.486]     })
[17:04:23.486]     if (TRUE) {
[17:04:23.486]         base::sink(type = "output", split = FALSE)
[17:04:23.486]         if (TRUE) {
[17:04:23.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.486]         }
[17:04:23.486]         else {
[17:04:23.486]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.486]         }
[17:04:23.486]         base::close(...future.stdout)
[17:04:23.486]         ...future.stdout <- NULL
[17:04:23.486]     }
[17:04:23.486]     ...future.result$conditions <- ...future.conditions
[17:04:23.486]     ...future.result$finished <- base::Sys.time()
[17:04:23.486]     ...future.result
[17:04:23.486] }
[17:04:23.488] plan(): Setting new future strategy stack:
[17:04:23.488] List of future strategies:
[17:04:23.488] 1. sequential:
[17:04:23.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.488]    - tweaked: FALSE
[17:04:23.488]    - call: NULL
[17:04:23.489] plan(): nbrOfWorkers() = 1
[17:04:23.491] plan(): Setting new future strategy stack:
[17:04:23.491] List of future strategies:
[17:04:23.491] 1. sequential:
[17:04:23.491]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.491]    - tweaked: FALSE
[17:04:23.491]    - call: plan(strategy)
[17:04:23.491] plan(): nbrOfWorkers() = 1
[17:04:23.492] SequentialFuture started (and completed)
[17:04:23.492] - Launch lazy future ... done
[17:04:23.492] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ session_uuid: chr "3697237d-75fc-0dd5-7f9d-42c2e0c2ecf9"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50425
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:23"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.003546715 secs (started 2024-11-25 17:04:23.488443)
version: 1.8
[17:04:23.502] getGlobalsAndPackages() ...
[17:04:23.502] Searching for globals...
[17:04:23.505] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.505] Searching for globals ... DONE
[17:04:23.505] Resolving globals: FALSE
[17:04:23.506] 
[17:04:23.506] - packages: [1] ‘utils’
[17:04:23.506] getGlobalsAndPackages() ... DONE
[17:04:23.506] run() for ‘Future’ ...
[17:04:23.506] - state: ‘created’
[17:04:23.507] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.507]   - Field: ‘label’
[17:04:23.507]   - Field: ‘local’
[17:04:23.507]   - Field: ‘owner’
[17:04:23.507]   - Field: ‘envir’
[17:04:23.507]   - Field: ‘packages’
[17:04:23.508]   - Field: ‘gc’
[17:04:23.508]   - Field: ‘conditions’
[17:04:23.508]   - Field: ‘expr’
[17:04:23.508]   - Field: ‘uuid’
[17:04:23.508]   - Field: ‘seed’
[17:04:23.508]   - Field: ‘version’
[17:04:23.508]   - Field: ‘result’
[17:04:23.508]   - Field: ‘asynchronous’
[17:04:23.508]   - Field: ‘calls’
[17:04:23.508]   - Field: ‘globals’
[17:04:23.508]   - Field: ‘stdout’
[17:04:23.509]   - Field: ‘earlySignal’
[17:04:23.509]   - Field: ‘lazy’
[17:04:23.509]   - Field: ‘state’
[17:04:23.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.509] - Launch lazy future ...
[17:04:23.509] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.511] Packages needed by future strategies (n = 0): <none>
[17:04:23.512] {
[17:04:23.512]     {
[17:04:23.512]         {
[17:04:23.512]             ...future.startTime <- base::Sys.time()
[17:04:23.512]             {
[17:04:23.512]                 {
[17:04:23.512]                   {
[17:04:23.512]                     {
[17:04:23.512]                       base::local({
[17:04:23.512]                         has_future <- base::requireNamespace("future", 
[17:04:23.512]                           quietly = TRUE)
[17:04:23.512]                         if (has_future) {
[17:04:23.512]                           ns <- base::getNamespace("future")
[17:04:23.512]                           version <- ns[[".package"]][["version"]]
[17:04:23.512]                           if (is.null(version)) 
[17:04:23.512]                             version <- utils::packageVersion("future")
[17:04:23.512]                         }
[17:04:23.512]                         else {
[17:04:23.512]                           version <- NULL
[17:04:23.512]                         }
[17:04:23.512]                         if (!has_future || version < "1.8.0") {
[17:04:23.512]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.512]                             "", base::R.version$version.string), 
[17:04:23.512]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.512]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.512]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.512]                               "release", "version")], collapse = " "), 
[17:04:23.512]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.512]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.512]                             info)
[17:04:23.512]                           info <- base::paste(info, collapse = "; ")
[17:04:23.512]                           if (!has_future) {
[17:04:23.512]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.512]                               info)
[17:04:23.512]                           }
[17:04:23.512]                           else {
[17:04:23.512]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.512]                               info, version)
[17:04:23.512]                           }
[17:04:23.512]                           base::stop(msg)
[17:04:23.512]                         }
[17:04:23.512]                       })
[17:04:23.512]                     }
[17:04:23.512]                     base::local({
[17:04:23.512]                       for (pkg in "utils") {
[17:04:23.512]                         base::loadNamespace(pkg)
[17:04:23.512]                         base::library(pkg, character.only = TRUE)
[17:04:23.512]                       }
[17:04:23.512]                     })
[17:04:23.512]                   }
[17:04:23.512]                   ...future.strategy.old <- future::plan("list")
[17:04:23.512]                   options(future.plan = NULL)
[17:04:23.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.512]                 }
[17:04:23.512]                 ...future.workdir <- getwd()
[17:04:23.512]             }
[17:04:23.512]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.512]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.512]         }
[17:04:23.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.512]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.512]             base::names(...future.oldOptions))
[17:04:23.512]     }
[17:04:23.512]     if (FALSE) {
[17:04:23.512]     }
[17:04:23.512]     else {
[17:04:23.512]         if (TRUE) {
[17:04:23.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.512]                 open = "w")
[17:04:23.512]         }
[17:04:23.512]         else {
[17:04:23.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.512]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.512]         }
[17:04:23.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.512]             base::sink(type = "output", split = FALSE)
[17:04:23.512]             base::close(...future.stdout)
[17:04:23.512]         }, add = TRUE)
[17:04:23.512]     }
[17:04:23.512]     ...future.frame <- base::sys.nframe()
[17:04:23.512]     ...future.conditions <- base::list()
[17:04:23.512]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.512]     if (FALSE) {
[17:04:23.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.512]     }
[17:04:23.512]     ...future.result <- base::tryCatch({
[17:04:23.512]         base::withCallingHandlers({
[17:04:23.512]             ...future.value <- base::withVisible(base::local({
[17:04:23.512]                 print(1:50)
[17:04:23.512]                 str(1:50)
[17:04:23.512]                 cat(letters, sep = "-")
[17:04:23.512]                 cat(1:6, collapse = "\n")
[17:04:23.512]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.512]                 42L
[17:04:23.512]             }))
[17:04:23.512]             future::FutureResult(value = ...future.value$value, 
[17:04:23.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.512]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.512]                     ...future.globalenv.names))
[17:04:23.512]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.512]         }, condition = base::local({
[17:04:23.512]             c <- base::c
[17:04:23.512]             inherits <- base::inherits
[17:04:23.512]             invokeRestart <- base::invokeRestart
[17:04:23.512]             length <- base::length
[17:04:23.512]             list <- base::list
[17:04:23.512]             seq.int <- base::seq.int
[17:04:23.512]             signalCondition <- base::signalCondition
[17:04:23.512]             sys.calls <- base::sys.calls
[17:04:23.512]             `[[` <- base::`[[`
[17:04:23.512]             `+` <- base::`+`
[17:04:23.512]             `<<-` <- base::`<<-`
[17:04:23.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.512]                   3L)]
[17:04:23.512]             }
[17:04:23.512]             function(cond) {
[17:04:23.512]                 is_error <- inherits(cond, "error")
[17:04:23.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.512]                   NULL)
[17:04:23.512]                 if (is_error) {
[17:04:23.512]                   sessionInformation <- function() {
[17:04:23.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.512]                       search = base::search(), system = base::Sys.info())
[17:04:23.512]                   }
[17:04:23.512]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.512]                     cond$call), session = sessionInformation(), 
[17:04:23.512]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.512]                   signalCondition(cond)
[17:04:23.512]                 }
[17:04:23.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.512]                 "immediateCondition"))) {
[17:04:23.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.512]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.512]                   if (TRUE && !signal) {
[17:04:23.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.512]                     {
[17:04:23.512]                       inherits <- base::inherits
[17:04:23.512]                       invokeRestart <- base::invokeRestart
[17:04:23.512]                       is.null <- base::is.null
[17:04:23.512]                       muffled <- FALSE
[17:04:23.512]                       if (inherits(cond, "message")) {
[17:04:23.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.512]                         if (muffled) 
[17:04:23.512]                           invokeRestart("muffleMessage")
[17:04:23.512]                       }
[17:04:23.512]                       else if (inherits(cond, "warning")) {
[17:04:23.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.512]                         if (muffled) 
[17:04:23.512]                           invokeRestart("muffleWarning")
[17:04:23.512]                       }
[17:04:23.512]                       else if (inherits(cond, "condition")) {
[17:04:23.512]                         if (!is.null(pattern)) {
[17:04:23.512]                           computeRestarts <- base::computeRestarts
[17:04:23.512]                           grepl <- base::grepl
[17:04:23.512]                           restarts <- computeRestarts(cond)
[17:04:23.512]                           for (restart in restarts) {
[17:04:23.512]                             name <- restart$name
[17:04:23.512]                             if (is.null(name)) 
[17:04:23.512]                               next
[17:04:23.512]                             if (!grepl(pattern, name)) 
[17:04:23.512]                               next
[17:04:23.512]                             invokeRestart(restart)
[17:04:23.512]                             muffled <- TRUE
[17:04:23.512]                             break
[17:04:23.512]                           }
[17:04:23.512]                         }
[17:04:23.512]                       }
[17:04:23.512]                       invisible(muffled)
[17:04:23.512]                     }
[17:04:23.512]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.512]                   }
[17:04:23.512]                 }
[17:04:23.512]                 else {
[17:04:23.512]                   if (TRUE) {
[17:04:23.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.512]                     {
[17:04:23.512]                       inherits <- base::inherits
[17:04:23.512]                       invokeRestart <- base::invokeRestart
[17:04:23.512]                       is.null <- base::is.null
[17:04:23.512]                       muffled <- FALSE
[17:04:23.512]                       if (inherits(cond, "message")) {
[17:04:23.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.512]                         if (muffled) 
[17:04:23.512]                           invokeRestart("muffleMessage")
[17:04:23.512]                       }
[17:04:23.512]                       else if (inherits(cond, "warning")) {
[17:04:23.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.512]                         if (muffled) 
[17:04:23.512]                           invokeRestart("muffleWarning")
[17:04:23.512]                       }
[17:04:23.512]                       else if (inherits(cond, "condition")) {
[17:04:23.512]                         if (!is.null(pattern)) {
[17:04:23.512]                           computeRestarts <- base::computeRestarts
[17:04:23.512]                           grepl <- base::grepl
[17:04:23.512]                           restarts <- computeRestarts(cond)
[17:04:23.512]                           for (restart in restarts) {
[17:04:23.512]                             name <- restart$name
[17:04:23.512]                             if (is.null(name)) 
[17:04:23.512]                               next
[17:04:23.512]                             if (!grepl(pattern, name)) 
[17:04:23.512]                               next
[17:04:23.512]                             invokeRestart(restart)
[17:04:23.512]                             muffled <- TRUE
[17:04:23.512]                             break
[17:04:23.512]                           }
[17:04:23.512]                         }
[17:04:23.512]                       }
[17:04:23.512]                       invisible(muffled)
[17:04:23.512]                     }
[17:04:23.512]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.512]                   }
[17:04:23.512]                 }
[17:04:23.512]             }
[17:04:23.512]         }))
[17:04:23.512]     }, error = function(ex) {
[17:04:23.512]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.512]                 ...future.rng), started = ...future.startTime, 
[17:04:23.512]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.512]             version = "1.8"), class = "FutureResult")
[17:04:23.512]     }, finally = {
[17:04:23.512]         if (!identical(...future.workdir, getwd())) 
[17:04:23.512]             setwd(...future.workdir)
[17:04:23.512]         {
[17:04:23.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.512]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.512]             }
[17:04:23.512]             base::options(...future.oldOptions)
[17:04:23.512]             if (.Platform$OS.type == "windows") {
[17:04:23.512]                 old_names <- names(...future.oldEnvVars)
[17:04:23.512]                 envs <- base::Sys.getenv()
[17:04:23.512]                 names <- names(envs)
[17:04:23.512]                 common <- intersect(names, old_names)
[17:04:23.512]                 added <- setdiff(names, old_names)
[17:04:23.512]                 removed <- setdiff(old_names, names)
[17:04:23.512]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.512]                   envs[common]]
[17:04:23.512]                 NAMES <- toupper(changed)
[17:04:23.512]                 args <- list()
[17:04:23.512]                 for (kk in seq_along(NAMES)) {
[17:04:23.512]                   name <- changed[[kk]]
[17:04:23.512]                   NAME <- NAMES[[kk]]
[17:04:23.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.512]                     next
[17:04:23.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.512]                 }
[17:04:23.512]                 NAMES <- toupper(added)
[17:04:23.512]                 for (kk in seq_along(NAMES)) {
[17:04:23.512]                   name <- added[[kk]]
[17:04:23.512]                   NAME <- NAMES[[kk]]
[17:04:23.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.512]                     next
[17:04:23.512]                   args[[name]] <- ""
[17:04:23.512]                 }
[17:04:23.512]                 NAMES <- toupper(removed)
[17:04:23.512]                 for (kk in seq_along(NAMES)) {
[17:04:23.512]                   name <- removed[[kk]]
[17:04:23.512]                   NAME <- NAMES[[kk]]
[17:04:23.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.512]                     next
[17:04:23.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.512]                 }
[17:04:23.512]                 if (length(args) > 0) 
[17:04:23.512]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.512]             }
[17:04:23.512]             else {
[17:04:23.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.512]             }
[17:04:23.512]             {
[17:04:23.512]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.512]                   0L) {
[17:04:23.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.512]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.512]                   base::options(opts)
[17:04:23.512]                 }
[17:04:23.512]                 {
[17:04:23.512]                   {
[17:04:23.512]                     NULL
[17:04:23.512]                     RNGkind("Mersenne-Twister")
[17:04:23.512]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.512]                       inherits = FALSE)
[17:04:23.512]                   }
[17:04:23.512]                   options(future.plan = NULL)
[17:04:23.512]                   if (is.na(NA_character_)) 
[17:04:23.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.512]                     .init = FALSE)
[17:04:23.512]                 }
[17:04:23.512]             }
[17:04:23.512]         }
[17:04:23.512]     })
[17:04:23.512]     if (TRUE) {
[17:04:23.512]         base::sink(type = "output", split = FALSE)
[17:04:23.512]         if (TRUE) {
[17:04:23.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.512]         }
[17:04:23.512]         else {
[17:04:23.512]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.512]         }
[17:04:23.512]         base::close(...future.stdout)
[17:04:23.512]         ...future.stdout <- NULL
[17:04:23.512]     }
[17:04:23.512]     ...future.result$conditions <- ...future.conditions
[17:04:23.512]     ...future.result$finished <- base::Sys.time()
[17:04:23.512]     ...future.result
[17:04:23.512] }
[17:04:23.514] plan(): Setting new future strategy stack:
[17:04:23.514] List of future strategies:
[17:04:23.514] 1. sequential:
[17:04:23.514]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.514]    - tweaked: FALSE
[17:04:23.514]    - call: NULL
[17:04:23.514] plan(): nbrOfWorkers() = 1
[17:04:23.516] plan(): Setting new future strategy stack:
[17:04:23.516] List of future strategies:
[17:04:23.516] 1. sequential:
[17:04:23.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.516]    - tweaked: FALSE
[17:04:23.516]    - call: plan(strategy)
[17:04:23.516] plan(): nbrOfWorkers() = 1
[17:04:23.517] SequentialFuture started (and completed)
[17:04:23.517] - Launch lazy future ... done
[17:04:23.517] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:04:23.517] getGlobalsAndPackages() ...
[17:04:23.518] Searching for globals...
[17:04:23.518] - globals found: [1] ‘print’
[17:04:23.518] Searching for globals ... DONE
[17:04:23.518] Resolving globals: FALSE
[17:04:23.518] 
[17:04:23.519] 
[17:04:23.519] getGlobalsAndPackages() ... DONE
[17:04:23.519] run() for ‘Future’ ...
[17:04:23.519] - state: ‘created’
[17:04:23.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.520]   - Field: ‘label’
[17:04:23.520]   - Field: ‘local’
[17:04:23.520]   - Field: ‘owner’
[17:04:23.520]   - Field: ‘envir’
[17:04:23.520]   - Field: ‘packages’
[17:04:23.520]   - Field: ‘gc’
[17:04:23.520]   - Field: ‘conditions’
[17:04:23.520]   - Field: ‘expr’
[17:04:23.520]   - Field: ‘uuid’
[17:04:23.520]   - Field: ‘seed’
[17:04:23.521]   - Field: ‘version’
[17:04:23.521]   - Field: ‘result’
[17:04:23.521]   - Field: ‘asynchronous’
[17:04:23.521]   - Field: ‘calls’
[17:04:23.521]   - Field: ‘globals’
[17:04:23.521]   - Field: ‘stdout’
[17:04:23.521]   - Field: ‘earlySignal’
[17:04:23.521]   - Field: ‘lazy’
[17:04:23.521]   - Field: ‘state’
[17:04:23.521] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.521] - Launch lazy future ...
[17:04:23.522] Packages needed by the future expression (n = 0): <none>
[17:04:23.522] Packages needed by future strategies (n = 0): <none>
[17:04:23.522] {
[17:04:23.522]     {
[17:04:23.522]         {
[17:04:23.522]             ...future.startTime <- base::Sys.time()
[17:04:23.522]             {
[17:04:23.522]                 {
[17:04:23.522]                   {
[17:04:23.522]                     base::local({
[17:04:23.522]                       has_future <- base::requireNamespace("future", 
[17:04:23.522]                         quietly = TRUE)
[17:04:23.522]                       if (has_future) {
[17:04:23.522]                         ns <- base::getNamespace("future")
[17:04:23.522]                         version <- ns[[".package"]][["version"]]
[17:04:23.522]                         if (is.null(version)) 
[17:04:23.522]                           version <- utils::packageVersion("future")
[17:04:23.522]                       }
[17:04:23.522]                       else {
[17:04:23.522]                         version <- NULL
[17:04:23.522]                       }
[17:04:23.522]                       if (!has_future || version < "1.8.0") {
[17:04:23.522]                         info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.522]                           "", base::R.version$version.string), 
[17:04:23.522]                           platform = base::sprintf("%s (%s-bit)", 
[17:04:23.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.522]                             "release", "version")], collapse = " "), 
[17:04:23.522]                           hostname = base::Sys.info()[["nodename"]])
[17:04:23.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.522]                           info)
[17:04:23.522]                         info <- base::paste(info, collapse = "; ")
[17:04:23.522]                         if (!has_future) {
[17:04:23.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.522]                             info)
[17:04:23.522]                         }
[17:04:23.522]                         else {
[17:04:23.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.522]                             info, version)
[17:04:23.522]                         }
[17:04:23.522]                         base::stop(msg)
[17:04:23.522]                       }
[17:04:23.522]                     })
[17:04:23.522]                   }
[17:04:23.522]                   ...future.strategy.old <- future::plan("list")
[17:04:23.522]                   options(future.plan = NULL)
[17:04:23.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.522]                 }
[17:04:23.522]                 ...future.workdir <- getwd()
[17:04:23.522]             }
[17:04:23.522]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.522]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.522]         }
[17:04:23.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.522]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.522]             base::names(...future.oldOptions))
[17:04:23.522]     }
[17:04:23.522]     if (FALSE) {
[17:04:23.522]     }
[17:04:23.522]     else {
[17:04:23.522]         if (TRUE) {
[17:04:23.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.522]                 open = "w")
[17:04:23.522]         }
[17:04:23.522]         else {
[17:04:23.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.522]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.522]         }
[17:04:23.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.522]             base::sink(type = "output", split = FALSE)
[17:04:23.522]             base::close(...future.stdout)
[17:04:23.522]         }, add = TRUE)
[17:04:23.522]     }
[17:04:23.522]     ...future.frame <- base::sys.nframe()
[17:04:23.522]     ...future.conditions <- base::list()
[17:04:23.522]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.522]     if (FALSE) {
[17:04:23.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.522]     }
[17:04:23.522]     ...future.result <- base::tryCatch({
[17:04:23.522]         base::withCallingHandlers({
[17:04:23.522]             ...future.value <- base::withVisible(base::local(print(42)))
[17:04:23.522]             future::FutureResult(value = ...future.value$value, 
[17:04:23.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.522]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.522]                     ...future.globalenv.names))
[17:04:23.522]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.522]         }, condition = base::local({
[17:04:23.522]             c <- base::c
[17:04:23.522]             inherits <- base::inherits
[17:04:23.522]             invokeRestart <- base::invokeRestart
[17:04:23.522]             length <- base::length
[17:04:23.522]             list <- base::list
[17:04:23.522]             seq.int <- base::seq.int
[17:04:23.522]             signalCondition <- base::signalCondition
[17:04:23.522]             sys.calls <- base::sys.calls
[17:04:23.522]             `[[` <- base::`[[`
[17:04:23.522]             `+` <- base::`+`
[17:04:23.522]             `<<-` <- base::`<<-`
[17:04:23.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.522]                   3L)]
[17:04:23.522]             }
[17:04:23.522]             function(cond) {
[17:04:23.522]                 is_error <- inherits(cond, "error")
[17:04:23.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.522]                   NULL)
[17:04:23.522]                 if (is_error) {
[17:04:23.522]                   sessionInformation <- function() {
[17:04:23.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.522]                       search = base::search(), system = base::Sys.info())
[17:04:23.522]                   }
[17:04:23.522]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.522]                     cond$call), session = sessionInformation(), 
[17:04:23.522]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.522]                   signalCondition(cond)
[17:04:23.522]                 }
[17:04:23.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.522]                 "immediateCondition"))) {
[17:04:23.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.522]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.522]                   if (TRUE && !signal) {
[17:04:23.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.522]                     {
[17:04:23.522]                       inherits <- base::inherits
[17:04:23.522]                       invokeRestart <- base::invokeRestart
[17:04:23.522]                       is.null <- base::is.null
[17:04:23.522]                       muffled <- FALSE
[17:04:23.522]                       if (inherits(cond, "message")) {
[17:04:23.522]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.522]                         if (muffled) 
[17:04:23.522]                           invokeRestart("muffleMessage")
[17:04:23.522]                       }
[17:04:23.522]                       else if (inherits(cond, "warning")) {
[17:04:23.522]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.522]                         if (muffled) 
[17:04:23.522]                           invokeRestart("muffleWarning")
[17:04:23.522]                       }
[17:04:23.522]                       else if (inherits(cond, "condition")) {
[17:04:23.522]                         if (!is.null(pattern)) {
[17:04:23.522]                           computeRestarts <- base::computeRestarts
[17:04:23.522]                           grepl <- base::grepl
[17:04:23.522]                           restarts <- computeRestarts(cond)
[17:04:23.522]                           for (restart in restarts) {
[17:04:23.522]                             name <- restart$name
[17:04:23.522]                             if (is.null(name)) 
[17:04:23.522]                               next
[17:04:23.522]                             if (!grepl(pattern, name)) 
[17:04:23.522]                               next
[17:04:23.522]                             invokeRestart(restart)
[17:04:23.522]                             muffled <- TRUE
[17:04:23.522]                             break
[17:04:23.522]                           }
[17:04:23.522]                         }
[17:04:23.522]                       }
[17:04:23.522]                       invisible(muffled)
[17:04:23.522]                     }
[17:04:23.522]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.522]                   }
[17:04:23.522]                 }
[17:04:23.522]                 else {
[17:04:23.522]                   if (TRUE) {
[17:04:23.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.522]                     {
[17:04:23.522]                       inherits <- base::inherits
[17:04:23.522]                       invokeRestart <- base::invokeRestart
[17:04:23.522]                       is.null <- base::is.null
[17:04:23.522]                       muffled <- FALSE
[17:04:23.522]                       if (inherits(cond, "message")) {
[17:04:23.522]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.522]                         if (muffled) 
[17:04:23.522]                           invokeRestart("muffleMessage")
[17:04:23.522]                       }
[17:04:23.522]                       else if (inherits(cond, "warning")) {
[17:04:23.522]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.522]                         if (muffled) 
[17:04:23.522]                           invokeRestart("muffleWarning")
[17:04:23.522]                       }
[17:04:23.522]                       else if (inherits(cond, "condition")) {
[17:04:23.522]                         if (!is.null(pattern)) {
[17:04:23.522]                           computeRestarts <- base::computeRestarts
[17:04:23.522]                           grepl <- base::grepl
[17:04:23.522]                           restarts <- computeRestarts(cond)
[17:04:23.522]                           for (restart in restarts) {
[17:04:23.522]                             name <- restart$name
[17:04:23.522]                             if (is.null(name)) 
[17:04:23.522]                               next
[17:04:23.522]                             if (!grepl(pattern, name)) 
[17:04:23.522]                               next
[17:04:23.522]                             invokeRestart(restart)
[17:04:23.522]                             muffled <- TRUE
[17:04:23.522]                             break
[17:04:23.522]                           }
[17:04:23.522]                         }
[17:04:23.522]                       }
[17:04:23.522]                       invisible(muffled)
[17:04:23.522]                     }
[17:04:23.522]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.522]                   }
[17:04:23.522]                 }
[17:04:23.522]             }
[17:04:23.522]         }))
[17:04:23.522]     }, error = function(ex) {
[17:04:23.522]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.522]                 ...future.rng), started = ...future.startTime, 
[17:04:23.522]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.522]             version = "1.8"), class = "FutureResult")
[17:04:23.522]     }, finally = {
[17:04:23.522]         if (!identical(...future.workdir, getwd())) 
[17:04:23.522]             setwd(...future.workdir)
[17:04:23.522]         {
[17:04:23.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.522]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.522]             }
[17:04:23.522]             base::options(...future.oldOptions)
[17:04:23.522]             if (.Platform$OS.type == "windows") {
[17:04:23.522]                 old_names <- names(...future.oldEnvVars)
[17:04:23.522]                 envs <- base::Sys.getenv()
[17:04:23.522]                 names <- names(envs)
[17:04:23.522]                 common <- intersect(names, old_names)
[17:04:23.522]                 added <- setdiff(names, old_names)
[17:04:23.522]                 removed <- setdiff(old_names, names)
[17:04:23.522]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.522]                   envs[common]]
[17:04:23.522]                 NAMES <- toupper(changed)
[17:04:23.522]                 args <- list()
[17:04:23.522]                 for (kk in seq_along(NAMES)) {
[17:04:23.522]                   name <- changed[[kk]]
[17:04:23.522]                   NAME <- NAMES[[kk]]
[17:04:23.522]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.522]                     next
[17:04:23.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.522]                 }
[17:04:23.522]                 NAMES <- toupper(added)
[17:04:23.522]                 for (kk in seq_along(NAMES)) {
[17:04:23.522]                   name <- added[[kk]]
[17:04:23.522]                   NAME <- NAMES[[kk]]
[17:04:23.522]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.522]                     next
[17:04:23.522]                   args[[name]] <- ""
[17:04:23.522]                 }
[17:04:23.522]                 NAMES <- toupper(removed)
[17:04:23.522]                 for (kk in seq_along(NAMES)) {
[17:04:23.522]                   name <- removed[[kk]]
[17:04:23.522]                   NAME <- NAMES[[kk]]
[17:04:23.522]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.522]                     next
[17:04:23.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.522]                 }
[17:04:23.522]                 if (length(args) > 0) 
[17:04:23.522]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.522]             }
[17:04:23.522]             else {
[17:04:23.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.522]             }
[17:04:23.522]             {
[17:04:23.522]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.522]                   0L) {
[17:04:23.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.522]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.522]                   base::options(opts)
[17:04:23.522]                 }
[17:04:23.522]                 {
[17:04:23.522]                   {
[17:04:23.522]                     NULL
[17:04:23.522]                     RNGkind("Mersenne-Twister")
[17:04:23.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.522]                       inherits = FALSE)
[17:04:23.522]                   }
[17:04:23.522]                   options(future.plan = NULL)
[17:04:23.522]                   if (is.na(NA_character_)) 
[17:04:23.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.522]                     .init = FALSE)
[17:04:23.522]                 }
[17:04:23.522]             }
[17:04:23.522]         }
[17:04:23.522]     })
[17:04:23.522]     if (TRUE) {
[17:04:23.522]         base::sink(type = "output", split = FALSE)
[17:04:23.522]         if (TRUE) {
[17:04:23.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.522]         }
[17:04:23.522]         else {
[17:04:23.522]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.522]         }
[17:04:23.522]         base::close(...future.stdout)
[17:04:23.522]         ...future.stdout <- NULL
[17:04:23.522]     }
[17:04:23.522]     ...future.result$conditions <- ...future.conditions
[17:04:23.522]     ...future.result$finished <- base::Sys.time()
[17:04:23.522]     ...future.result
[17:04:23.522] }
[17:04:23.524] plan(): Setting new future strategy stack:
[17:04:23.524] List of future strategies:
[17:04:23.524] 1. sequential:
[17:04:23.524]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.524]    - tweaked: FALSE
[17:04:23.524]    - call: NULL
[17:04:23.525] plan(): nbrOfWorkers() = 1
[17:04:23.525] plan(): Setting new future strategy stack:
[17:04:23.525] List of future strategies:
[17:04:23.525] 1. sequential:
[17:04:23.525]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.525]    - tweaked: FALSE
[17:04:23.525]    - call: plan(strategy)
[17:04:23.526] plan(): nbrOfWorkers() = 1
[17:04:23.526] SequentialFuture started (and completed)
[17:04:23.526] - Launch lazy future ... done
[17:04:23.526] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[17:04:23.527] getGlobalsAndPackages() ...
[17:04:23.527] Searching for globals...
[17:04:23.530] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.530] Searching for globals ... DONE
[17:04:23.530] Resolving globals: FALSE
[17:04:23.530] 
[17:04:23.530] - packages: [1] ‘utils’
[17:04:23.531] getGlobalsAndPackages() ... DONE
[17:04:23.531] run() for ‘Future’ ...
[17:04:23.531] - state: ‘created’
[17:04:23.531] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.531] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.532]   - Field: ‘label’
[17:04:23.532]   - Field: ‘local’
[17:04:23.532]   - Field: ‘owner’
[17:04:23.532]   - Field: ‘envir’
[17:04:23.532]   - Field: ‘packages’
[17:04:23.532]   - Field: ‘gc’
[17:04:23.532]   - Field: ‘conditions’
[17:04:23.532]   - Field: ‘expr’
[17:04:23.532]   - Field: ‘uuid’
[17:04:23.532]   - Field: ‘seed’
[17:04:23.532]   - Field: ‘version’
[17:04:23.533]   - Field: ‘result’
[17:04:23.533]   - Field: ‘asynchronous’
[17:04:23.533]   - Field: ‘calls’
[17:04:23.533]   - Field: ‘globals’
[17:04:23.533]   - Field: ‘stdout’
[17:04:23.533]   - Field: ‘earlySignal’
[17:04:23.533]   - Field: ‘lazy’
[17:04:23.533]   - Field: ‘state’
[17:04:23.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.533] - Launch lazy future ...
[17:04:23.534] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.534] Packages needed by future strategies (n = 0): <none>
[17:04:23.534] {
[17:04:23.534]     {
[17:04:23.534]         {
[17:04:23.534]             ...future.startTime <- base::Sys.time()
[17:04:23.534]             {
[17:04:23.534]                 {
[17:04:23.534]                   {
[17:04:23.534]                     {
[17:04:23.534]                       base::local({
[17:04:23.534]                         has_future <- base::requireNamespace("future", 
[17:04:23.534]                           quietly = TRUE)
[17:04:23.534]                         if (has_future) {
[17:04:23.534]                           ns <- base::getNamespace("future")
[17:04:23.534]                           version <- ns[[".package"]][["version"]]
[17:04:23.534]                           if (is.null(version)) 
[17:04:23.534]                             version <- utils::packageVersion("future")
[17:04:23.534]                         }
[17:04:23.534]                         else {
[17:04:23.534]                           version <- NULL
[17:04:23.534]                         }
[17:04:23.534]                         if (!has_future || version < "1.8.0") {
[17:04:23.534]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.534]                             "", base::R.version$version.string), 
[17:04:23.534]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.534]                               "release", "version")], collapse = " "), 
[17:04:23.534]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.534]                             info)
[17:04:23.534]                           info <- base::paste(info, collapse = "; ")
[17:04:23.534]                           if (!has_future) {
[17:04:23.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.534]                               info)
[17:04:23.534]                           }
[17:04:23.534]                           else {
[17:04:23.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.534]                               info, version)
[17:04:23.534]                           }
[17:04:23.534]                           base::stop(msg)
[17:04:23.534]                         }
[17:04:23.534]                       })
[17:04:23.534]                     }
[17:04:23.534]                     base::local({
[17:04:23.534]                       for (pkg in "utils") {
[17:04:23.534]                         base::loadNamespace(pkg)
[17:04:23.534]                         base::library(pkg, character.only = TRUE)
[17:04:23.534]                       }
[17:04:23.534]                     })
[17:04:23.534]                   }
[17:04:23.534]                   ...future.strategy.old <- future::plan("list")
[17:04:23.534]                   options(future.plan = NULL)
[17:04:23.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.534]                 }
[17:04:23.534]                 ...future.workdir <- getwd()
[17:04:23.534]             }
[17:04:23.534]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.534]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.534]         }
[17:04:23.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.534]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.534]             base::names(...future.oldOptions))
[17:04:23.534]     }
[17:04:23.534]     if (FALSE) {
[17:04:23.534]     }
[17:04:23.534]     else {
[17:04:23.534]         if (FALSE) {
[17:04:23.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.534]                 open = "w")
[17:04:23.534]         }
[17:04:23.534]         else {
[17:04:23.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.534]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.534]         }
[17:04:23.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.534]             base::sink(type = "output", split = FALSE)
[17:04:23.534]             base::close(...future.stdout)
[17:04:23.534]         }, add = TRUE)
[17:04:23.534]     }
[17:04:23.534]     ...future.frame <- base::sys.nframe()
[17:04:23.534]     ...future.conditions <- base::list()
[17:04:23.534]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.534]     if (FALSE) {
[17:04:23.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.534]     }
[17:04:23.534]     ...future.result <- base::tryCatch({
[17:04:23.534]         base::withCallingHandlers({
[17:04:23.534]             ...future.value <- base::withVisible(base::local({
[17:04:23.534]                 print(1:50)
[17:04:23.534]                 str(1:50)
[17:04:23.534]                 cat(letters, sep = "-")
[17:04:23.534]                 cat(1:6, collapse = "\n")
[17:04:23.534]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.534]                 42L
[17:04:23.534]             }))
[17:04:23.534]             future::FutureResult(value = ...future.value$value, 
[17:04:23.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.534]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.534]                     ...future.globalenv.names))
[17:04:23.534]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.534]         }, condition = base::local({
[17:04:23.534]             c <- base::c
[17:04:23.534]             inherits <- base::inherits
[17:04:23.534]             invokeRestart <- base::invokeRestart
[17:04:23.534]             length <- base::length
[17:04:23.534]             list <- base::list
[17:04:23.534]             seq.int <- base::seq.int
[17:04:23.534]             signalCondition <- base::signalCondition
[17:04:23.534]             sys.calls <- base::sys.calls
[17:04:23.534]             `[[` <- base::`[[`
[17:04:23.534]             `+` <- base::`+`
[17:04:23.534]             `<<-` <- base::`<<-`
[17:04:23.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.534]                   3L)]
[17:04:23.534]             }
[17:04:23.534]             function(cond) {
[17:04:23.534]                 is_error <- inherits(cond, "error")
[17:04:23.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.534]                   NULL)
[17:04:23.534]                 if (is_error) {
[17:04:23.534]                   sessionInformation <- function() {
[17:04:23.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.534]                       search = base::search(), system = base::Sys.info())
[17:04:23.534]                   }
[17:04:23.534]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.534]                     cond$call), session = sessionInformation(), 
[17:04:23.534]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.534]                   signalCondition(cond)
[17:04:23.534]                 }
[17:04:23.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.534]                 "immediateCondition"))) {
[17:04:23.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.534]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.534]                   if (TRUE && !signal) {
[17:04:23.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.534]                     {
[17:04:23.534]                       inherits <- base::inherits
[17:04:23.534]                       invokeRestart <- base::invokeRestart
[17:04:23.534]                       is.null <- base::is.null
[17:04:23.534]                       muffled <- FALSE
[17:04:23.534]                       if (inherits(cond, "message")) {
[17:04:23.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.534]                         if (muffled) 
[17:04:23.534]                           invokeRestart("muffleMessage")
[17:04:23.534]                       }
[17:04:23.534]                       else if (inherits(cond, "warning")) {
[17:04:23.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.534]                         if (muffled) 
[17:04:23.534]                           invokeRestart("muffleWarning")
[17:04:23.534]                       }
[17:04:23.534]                       else if (inherits(cond, "condition")) {
[17:04:23.534]                         if (!is.null(pattern)) {
[17:04:23.534]                           computeRestarts <- base::computeRestarts
[17:04:23.534]                           grepl <- base::grepl
[17:04:23.534]                           restarts <- computeRestarts(cond)
[17:04:23.534]                           for (restart in restarts) {
[17:04:23.534]                             name <- restart$name
[17:04:23.534]                             if (is.null(name)) 
[17:04:23.534]                               next
[17:04:23.534]                             if (!grepl(pattern, name)) 
[17:04:23.534]                               next
[17:04:23.534]                             invokeRestart(restart)
[17:04:23.534]                             muffled <- TRUE
[17:04:23.534]                             break
[17:04:23.534]                           }
[17:04:23.534]                         }
[17:04:23.534]                       }
[17:04:23.534]                       invisible(muffled)
[17:04:23.534]                     }
[17:04:23.534]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.534]                   }
[17:04:23.534]                 }
[17:04:23.534]                 else {
[17:04:23.534]                   if (TRUE) {
[17:04:23.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.534]                     {
[17:04:23.534]                       inherits <- base::inherits
[17:04:23.534]                       invokeRestart <- base::invokeRestart
[17:04:23.534]                       is.null <- base::is.null
[17:04:23.534]                       muffled <- FALSE
[17:04:23.534]                       if (inherits(cond, "message")) {
[17:04:23.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.534]                         if (muffled) 
[17:04:23.534]                           invokeRestart("muffleMessage")
[17:04:23.534]                       }
[17:04:23.534]                       else if (inherits(cond, "warning")) {
[17:04:23.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.534]                         if (muffled) 
[17:04:23.534]                           invokeRestart("muffleWarning")
[17:04:23.534]                       }
[17:04:23.534]                       else if (inherits(cond, "condition")) {
[17:04:23.534]                         if (!is.null(pattern)) {
[17:04:23.534]                           computeRestarts <- base::computeRestarts
[17:04:23.534]                           grepl <- base::grepl
[17:04:23.534]                           restarts <- computeRestarts(cond)
[17:04:23.534]                           for (restart in restarts) {
[17:04:23.534]                             name <- restart$name
[17:04:23.534]                             if (is.null(name)) 
[17:04:23.534]                               next
[17:04:23.534]                             if (!grepl(pattern, name)) 
[17:04:23.534]                               next
[17:04:23.534]                             invokeRestart(restart)
[17:04:23.534]                             muffled <- TRUE
[17:04:23.534]                             break
[17:04:23.534]                           }
[17:04:23.534]                         }
[17:04:23.534]                       }
[17:04:23.534]                       invisible(muffled)
[17:04:23.534]                     }
[17:04:23.534]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.534]                   }
[17:04:23.534]                 }
[17:04:23.534]             }
[17:04:23.534]         }))
[17:04:23.534]     }, error = function(ex) {
[17:04:23.534]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.534]                 ...future.rng), started = ...future.startTime, 
[17:04:23.534]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.534]             version = "1.8"), class = "FutureResult")
[17:04:23.534]     }, finally = {
[17:04:23.534]         if (!identical(...future.workdir, getwd())) 
[17:04:23.534]             setwd(...future.workdir)
[17:04:23.534]         {
[17:04:23.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.534]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.534]             }
[17:04:23.534]             base::options(...future.oldOptions)
[17:04:23.534]             if (.Platform$OS.type == "windows") {
[17:04:23.534]                 old_names <- names(...future.oldEnvVars)
[17:04:23.534]                 envs <- base::Sys.getenv()
[17:04:23.534]                 names <- names(envs)
[17:04:23.534]                 common <- intersect(names, old_names)
[17:04:23.534]                 added <- setdiff(names, old_names)
[17:04:23.534]                 removed <- setdiff(old_names, names)
[17:04:23.534]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.534]                   envs[common]]
[17:04:23.534]                 NAMES <- toupper(changed)
[17:04:23.534]                 args <- list()
[17:04:23.534]                 for (kk in seq_along(NAMES)) {
[17:04:23.534]                   name <- changed[[kk]]
[17:04:23.534]                   NAME <- NAMES[[kk]]
[17:04:23.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.534]                     next
[17:04:23.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.534]                 }
[17:04:23.534]                 NAMES <- toupper(added)
[17:04:23.534]                 for (kk in seq_along(NAMES)) {
[17:04:23.534]                   name <- added[[kk]]
[17:04:23.534]                   NAME <- NAMES[[kk]]
[17:04:23.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.534]                     next
[17:04:23.534]                   args[[name]] <- ""
[17:04:23.534]                 }
[17:04:23.534]                 NAMES <- toupper(removed)
[17:04:23.534]                 for (kk in seq_along(NAMES)) {
[17:04:23.534]                   name <- removed[[kk]]
[17:04:23.534]                   NAME <- NAMES[[kk]]
[17:04:23.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.534]                     next
[17:04:23.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.534]                 }
[17:04:23.534]                 if (length(args) > 0) 
[17:04:23.534]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.534]             }
[17:04:23.534]             else {
[17:04:23.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.534]             }
[17:04:23.534]             {
[17:04:23.534]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.534]                   0L) {
[17:04:23.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.534]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.534]                   base::options(opts)
[17:04:23.534]                 }
[17:04:23.534]                 {
[17:04:23.534]                   {
[17:04:23.534]                     NULL
[17:04:23.534]                     RNGkind("Mersenne-Twister")
[17:04:23.534]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.534]                       inherits = FALSE)
[17:04:23.534]                   }
[17:04:23.534]                   options(future.plan = NULL)
[17:04:23.534]                   if (is.na(NA_character_)) 
[17:04:23.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.534]                     .init = FALSE)
[17:04:23.534]                 }
[17:04:23.534]             }
[17:04:23.534]         }
[17:04:23.534]     })
[17:04:23.534]     if (TRUE) {
[17:04:23.534]         base::sink(type = "output", split = FALSE)
[17:04:23.534]         if (FALSE) {
[17:04:23.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.534]         }
[17:04:23.534]         else {
[17:04:23.534]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.534]         }
[17:04:23.534]         base::close(...future.stdout)
[17:04:23.534]         ...future.stdout <- NULL
[17:04:23.534]     }
[17:04:23.534]     ...future.result$conditions <- ...future.conditions
[17:04:23.534]     ...future.result$finished <- base::Sys.time()
[17:04:23.534]     ...future.result
[17:04:23.534] }
[17:04:23.536] plan(): Setting new future strategy stack:
[17:04:23.536] List of future strategies:
[17:04:23.536] 1. sequential:
[17:04:23.536]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.536]    - tweaked: FALSE
[17:04:23.536]    - call: NULL
[17:04:23.537] plan(): nbrOfWorkers() = 1
[17:04:23.538] plan(): Setting new future strategy stack:
[17:04:23.538] List of future strategies:
[17:04:23.538] 1. sequential:
[17:04:23.538]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.538]    - tweaked: FALSE
[17:04:23.538]    - call: plan(strategy)
[17:04:23.539] plan(): nbrOfWorkers() = 1
[17:04:23.539] SequentialFuture started (and completed)
[17:04:23.539] - Launch lazy future ... done
[17:04:23.539] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ session_uuid: chr "3697237d-75fc-0dd5-7f9d-42c2e0c2ecf9"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50425
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:23"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:23.549] getGlobalsAndPackages() ...
[17:04:23.550] Searching for globals...
[17:04:23.552] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.553] Searching for globals ... DONE
[17:04:23.553] Resolving globals: FALSE
[17:04:23.553] 
[17:04:23.553] - packages: [1] ‘utils’
[17:04:23.553] getGlobalsAndPackages() ... DONE
[17:04:23.554] run() for ‘Future’ ...
[17:04:23.554] - state: ‘created’
[17:04:23.554] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.554] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.555]   - Field: ‘label’
[17:04:23.555]   - Field: ‘local’
[17:04:23.555]   - Field: ‘owner’
[17:04:23.555]   - Field: ‘envir’
[17:04:23.555]   - Field: ‘packages’
[17:04:23.555]   - Field: ‘gc’
[17:04:23.555]   - Field: ‘conditions’
[17:04:23.555]   - Field: ‘expr’
[17:04:23.555]   - Field: ‘uuid’
[17:04:23.555]   - Field: ‘seed’
[17:04:23.556]   - Field: ‘version’
[17:04:23.556]   - Field: ‘result’
[17:04:23.556]   - Field: ‘asynchronous’
[17:04:23.556]   - Field: ‘calls’
[17:04:23.556]   - Field: ‘globals’
[17:04:23.556]   - Field: ‘stdout’
[17:04:23.556]   - Field: ‘earlySignal’
[17:04:23.556]   - Field: ‘lazy’
[17:04:23.556]   - Field: ‘state’
[17:04:23.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.556] - Launch lazy future ...
[17:04:23.557] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.557] Packages needed by future strategies (n = 0): <none>
[17:04:23.557] {
[17:04:23.557]     {
[17:04:23.557]         {
[17:04:23.557]             ...future.startTime <- base::Sys.time()
[17:04:23.557]             {
[17:04:23.557]                 {
[17:04:23.557]                   {
[17:04:23.557]                     {
[17:04:23.557]                       base::local({
[17:04:23.557]                         has_future <- base::requireNamespace("future", 
[17:04:23.557]                           quietly = TRUE)
[17:04:23.557]                         if (has_future) {
[17:04:23.557]                           ns <- base::getNamespace("future")
[17:04:23.557]                           version <- ns[[".package"]][["version"]]
[17:04:23.557]                           if (is.null(version)) 
[17:04:23.557]                             version <- utils::packageVersion("future")
[17:04:23.557]                         }
[17:04:23.557]                         else {
[17:04:23.557]                           version <- NULL
[17:04:23.557]                         }
[17:04:23.557]                         if (!has_future || version < "1.8.0") {
[17:04:23.557]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.557]                             "", base::R.version$version.string), 
[17:04:23.557]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.557]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.557]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.557]                               "release", "version")], collapse = " "), 
[17:04:23.557]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.557]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.557]                             info)
[17:04:23.557]                           info <- base::paste(info, collapse = "; ")
[17:04:23.557]                           if (!has_future) {
[17:04:23.557]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.557]                               info)
[17:04:23.557]                           }
[17:04:23.557]                           else {
[17:04:23.557]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.557]                               info, version)
[17:04:23.557]                           }
[17:04:23.557]                           base::stop(msg)
[17:04:23.557]                         }
[17:04:23.557]                       })
[17:04:23.557]                     }
[17:04:23.557]                     base::local({
[17:04:23.557]                       for (pkg in "utils") {
[17:04:23.557]                         base::loadNamespace(pkg)
[17:04:23.557]                         base::library(pkg, character.only = TRUE)
[17:04:23.557]                       }
[17:04:23.557]                     })
[17:04:23.557]                   }
[17:04:23.557]                   ...future.strategy.old <- future::plan("list")
[17:04:23.557]                   options(future.plan = NULL)
[17:04:23.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.557]                 }
[17:04:23.557]                 ...future.workdir <- getwd()
[17:04:23.557]             }
[17:04:23.557]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.557]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.557]         }
[17:04:23.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.557]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.557]             base::names(...future.oldOptions))
[17:04:23.557]     }
[17:04:23.557]     if (FALSE) {
[17:04:23.557]     }
[17:04:23.557]     else {
[17:04:23.557]         if (FALSE) {
[17:04:23.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.557]                 open = "w")
[17:04:23.557]         }
[17:04:23.557]         else {
[17:04:23.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.557]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.557]         }
[17:04:23.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.557]             base::sink(type = "output", split = FALSE)
[17:04:23.557]             base::close(...future.stdout)
[17:04:23.557]         }, add = TRUE)
[17:04:23.557]     }
[17:04:23.557]     ...future.frame <- base::sys.nframe()
[17:04:23.557]     ...future.conditions <- base::list()
[17:04:23.557]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.557]     if (FALSE) {
[17:04:23.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.557]     }
[17:04:23.557]     ...future.result <- base::tryCatch({
[17:04:23.557]         base::withCallingHandlers({
[17:04:23.557]             ...future.value <- base::withVisible(base::local({
[17:04:23.557]                 print(1:50)
[17:04:23.557]                 str(1:50)
[17:04:23.557]                 cat(letters, sep = "-")
[17:04:23.557]                 cat(1:6, collapse = "\n")
[17:04:23.557]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.557]                 42L
[17:04:23.557]             }))
[17:04:23.557]             future::FutureResult(value = ...future.value$value, 
[17:04:23.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.557]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.557]                     ...future.globalenv.names))
[17:04:23.557]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.557]         }, condition = base::local({
[17:04:23.557]             c <- base::c
[17:04:23.557]             inherits <- base::inherits
[17:04:23.557]             invokeRestart <- base::invokeRestart
[17:04:23.557]             length <- base::length
[17:04:23.557]             list <- base::list
[17:04:23.557]             seq.int <- base::seq.int
[17:04:23.557]             signalCondition <- base::signalCondition
[17:04:23.557]             sys.calls <- base::sys.calls
[17:04:23.557]             `[[` <- base::`[[`
[17:04:23.557]             `+` <- base::`+`
[17:04:23.557]             `<<-` <- base::`<<-`
[17:04:23.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.557]                   3L)]
[17:04:23.557]             }
[17:04:23.557]             function(cond) {
[17:04:23.557]                 is_error <- inherits(cond, "error")
[17:04:23.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.557]                   NULL)
[17:04:23.557]                 if (is_error) {
[17:04:23.557]                   sessionInformation <- function() {
[17:04:23.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.557]                       search = base::search(), system = base::Sys.info())
[17:04:23.557]                   }
[17:04:23.557]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.557]                     cond$call), session = sessionInformation(), 
[17:04:23.557]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.557]                   signalCondition(cond)
[17:04:23.557]                 }
[17:04:23.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.557]                 "immediateCondition"))) {
[17:04:23.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.557]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.557]                   if (TRUE && !signal) {
[17:04:23.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.557]                     {
[17:04:23.557]                       inherits <- base::inherits
[17:04:23.557]                       invokeRestart <- base::invokeRestart
[17:04:23.557]                       is.null <- base::is.null
[17:04:23.557]                       muffled <- FALSE
[17:04:23.557]                       if (inherits(cond, "message")) {
[17:04:23.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.557]                         if (muffled) 
[17:04:23.557]                           invokeRestart("muffleMessage")
[17:04:23.557]                       }
[17:04:23.557]                       else if (inherits(cond, "warning")) {
[17:04:23.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.557]                         if (muffled) 
[17:04:23.557]                           invokeRestart("muffleWarning")
[17:04:23.557]                       }
[17:04:23.557]                       else if (inherits(cond, "condition")) {
[17:04:23.557]                         if (!is.null(pattern)) {
[17:04:23.557]                           computeRestarts <- base::computeRestarts
[17:04:23.557]                           grepl <- base::grepl
[17:04:23.557]                           restarts <- computeRestarts(cond)
[17:04:23.557]                           for (restart in restarts) {
[17:04:23.557]                             name <- restart$name
[17:04:23.557]                             if (is.null(name)) 
[17:04:23.557]                               next
[17:04:23.557]                             if (!grepl(pattern, name)) 
[17:04:23.557]                               next
[17:04:23.557]                             invokeRestart(restart)
[17:04:23.557]                             muffled <- TRUE
[17:04:23.557]                             break
[17:04:23.557]                           }
[17:04:23.557]                         }
[17:04:23.557]                       }
[17:04:23.557]                       invisible(muffled)
[17:04:23.557]                     }
[17:04:23.557]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.557]                   }
[17:04:23.557]                 }
[17:04:23.557]                 else {
[17:04:23.557]                   if (TRUE) {
[17:04:23.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.557]                     {
[17:04:23.557]                       inherits <- base::inherits
[17:04:23.557]                       invokeRestart <- base::invokeRestart
[17:04:23.557]                       is.null <- base::is.null
[17:04:23.557]                       muffled <- FALSE
[17:04:23.557]                       if (inherits(cond, "message")) {
[17:04:23.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.557]                         if (muffled) 
[17:04:23.557]                           invokeRestart("muffleMessage")
[17:04:23.557]                       }
[17:04:23.557]                       else if (inherits(cond, "warning")) {
[17:04:23.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.557]                         if (muffled) 
[17:04:23.557]                           invokeRestart("muffleWarning")
[17:04:23.557]                       }
[17:04:23.557]                       else if (inherits(cond, "condition")) {
[17:04:23.557]                         if (!is.null(pattern)) {
[17:04:23.557]                           computeRestarts <- base::computeRestarts
[17:04:23.557]                           grepl <- base::grepl
[17:04:23.557]                           restarts <- computeRestarts(cond)
[17:04:23.557]                           for (restart in restarts) {
[17:04:23.557]                             name <- restart$name
[17:04:23.557]                             if (is.null(name)) 
[17:04:23.557]                               next
[17:04:23.557]                             if (!grepl(pattern, name)) 
[17:04:23.557]                               next
[17:04:23.557]                             invokeRestart(restart)
[17:04:23.557]                             muffled <- TRUE
[17:04:23.557]                             break
[17:04:23.557]                           }
[17:04:23.557]                         }
[17:04:23.557]                       }
[17:04:23.557]                       invisible(muffled)
[17:04:23.557]                     }
[17:04:23.557]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.557]                   }
[17:04:23.557]                 }
[17:04:23.557]             }
[17:04:23.557]         }))
[17:04:23.557]     }, error = function(ex) {
[17:04:23.557]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.557]                 ...future.rng), started = ...future.startTime, 
[17:04:23.557]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.557]             version = "1.8"), class = "FutureResult")
[17:04:23.557]     }, finally = {
[17:04:23.557]         if (!identical(...future.workdir, getwd())) 
[17:04:23.557]             setwd(...future.workdir)
[17:04:23.557]         {
[17:04:23.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.557]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.557]             }
[17:04:23.557]             base::options(...future.oldOptions)
[17:04:23.557]             if (.Platform$OS.type == "windows") {
[17:04:23.557]                 old_names <- names(...future.oldEnvVars)
[17:04:23.557]                 envs <- base::Sys.getenv()
[17:04:23.557]                 names <- names(envs)
[17:04:23.557]                 common <- intersect(names, old_names)
[17:04:23.557]                 added <- setdiff(names, old_names)
[17:04:23.557]                 removed <- setdiff(old_names, names)
[17:04:23.557]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.557]                   envs[common]]
[17:04:23.557]                 NAMES <- toupper(changed)
[17:04:23.557]                 args <- list()
[17:04:23.557]                 for (kk in seq_along(NAMES)) {
[17:04:23.557]                   name <- changed[[kk]]
[17:04:23.557]                   NAME <- NAMES[[kk]]
[17:04:23.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.557]                     next
[17:04:23.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.557]                 }
[17:04:23.557]                 NAMES <- toupper(added)
[17:04:23.557]                 for (kk in seq_along(NAMES)) {
[17:04:23.557]                   name <- added[[kk]]
[17:04:23.557]                   NAME <- NAMES[[kk]]
[17:04:23.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.557]                     next
[17:04:23.557]                   args[[name]] <- ""
[17:04:23.557]                 }
[17:04:23.557]                 NAMES <- toupper(removed)
[17:04:23.557]                 for (kk in seq_along(NAMES)) {
[17:04:23.557]                   name <- removed[[kk]]
[17:04:23.557]                   NAME <- NAMES[[kk]]
[17:04:23.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.557]                     next
[17:04:23.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.557]                 }
[17:04:23.557]                 if (length(args) > 0) 
[17:04:23.557]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.557]             }
[17:04:23.557]             else {
[17:04:23.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.557]             }
[17:04:23.557]             {
[17:04:23.557]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.557]                   0L) {
[17:04:23.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.557]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.557]                   base::options(opts)
[17:04:23.557]                 }
[17:04:23.557]                 {
[17:04:23.557]                   {
[17:04:23.557]                     NULL
[17:04:23.557]                     RNGkind("Mersenne-Twister")
[17:04:23.557]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.557]                       inherits = FALSE)
[17:04:23.557]                   }
[17:04:23.557]                   options(future.plan = NULL)
[17:04:23.557]                   if (is.na(NA_character_)) 
[17:04:23.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.557]                     .init = FALSE)
[17:04:23.557]                 }
[17:04:23.557]             }
[17:04:23.557]         }
[17:04:23.557]     })
[17:04:23.557]     if (TRUE) {
[17:04:23.557]         base::sink(type = "output", split = FALSE)
[17:04:23.557]         if (FALSE) {
[17:04:23.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.557]         }
[17:04:23.557]         else {
[17:04:23.557]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.557]         }
[17:04:23.557]         base::close(...future.stdout)
[17:04:23.557]         ...future.stdout <- NULL
[17:04:23.557]     }
[17:04:23.557]     ...future.result$conditions <- ...future.conditions
[17:04:23.557]     ...future.result$finished <- base::Sys.time()
[17:04:23.557]     ...future.result
[17:04:23.557] }
[17:04:23.560] plan(): Setting new future strategy stack:
[17:04:23.560] List of future strategies:
[17:04:23.560] 1. sequential:
[17:04:23.560]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.560]    - tweaked: FALSE
[17:04:23.560]    - call: NULL
[17:04:23.560] plan(): nbrOfWorkers() = 1
[17:04:23.562] plan(): Setting new future strategy stack:
[17:04:23.562] List of future strategies:
[17:04:23.562] 1. sequential:
[17:04:23.562]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.562]    - tweaked: FALSE
[17:04:23.562]    - call: plan(strategy)
[17:04:23.562] plan(): nbrOfWorkers() = 1
[17:04:23.563] SequentialFuture started (and completed)
[17:04:23.563] - Launch lazy future ... done
[17:04:23.563] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[17:04:23.563] getGlobalsAndPackages() ...
[17:04:23.563] Searching for globals...
[17:04:23.564] - globals found: [1] ‘print’
[17:04:23.564] Searching for globals ... DONE
[17:04:23.564] Resolving globals: FALSE
[17:04:23.564] 
[17:04:23.564] 
[17:04:23.565] getGlobalsAndPackages() ... DONE
[17:04:23.565] run() for ‘Future’ ...
[17:04:23.565] - state: ‘created’
[17:04:23.565] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.565] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.566]   - Field: ‘label’
[17:04:23.566]   - Field: ‘local’
[17:04:23.566]   - Field: ‘owner’
[17:04:23.566]   - Field: ‘envir’
[17:04:23.566]   - Field: ‘packages’
[17:04:23.566]   - Field: ‘gc’
[17:04:23.566]   - Field: ‘conditions’
[17:04:23.566]   - Field: ‘expr’
[17:04:23.566]   - Field: ‘uuid’
[17:04:23.566]   - Field: ‘seed’
[17:04:23.566]   - Field: ‘version’
[17:04:23.567]   - Field: ‘result’
[17:04:23.567]   - Field: ‘asynchronous’
[17:04:23.567]   - Field: ‘calls’
[17:04:23.567]   - Field: ‘globals’
[17:04:23.567]   - Field: ‘stdout’
[17:04:23.567]   - Field: ‘earlySignal’
[17:04:23.567]   - Field: ‘lazy’
[17:04:23.567]   - Field: ‘state’
[17:04:23.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.567] - Launch lazy future ...
[17:04:23.568] Packages needed by the future expression (n = 0): <none>
[17:04:23.568] Packages needed by future strategies (n = 0): <none>
[17:04:23.568] {
[17:04:23.568]     {
[17:04:23.568]         {
[17:04:23.568]             ...future.startTime <- base::Sys.time()
[17:04:23.568]             {
[17:04:23.568]                 {
[17:04:23.568]                   {
[17:04:23.568]                     base::local({
[17:04:23.568]                       has_future <- base::requireNamespace("future", 
[17:04:23.568]                         quietly = TRUE)
[17:04:23.568]                       if (has_future) {
[17:04:23.568]                         ns <- base::getNamespace("future")
[17:04:23.568]                         version <- ns[[".package"]][["version"]]
[17:04:23.568]                         if (is.null(version)) 
[17:04:23.568]                           version <- utils::packageVersion("future")
[17:04:23.568]                       }
[17:04:23.568]                       else {
[17:04:23.568]                         version <- NULL
[17:04:23.568]                       }
[17:04:23.568]                       if (!has_future || version < "1.8.0") {
[17:04:23.568]                         info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.568]                           "", base::R.version$version.string), 
[17:04:23.568]                           platform = base::sprintf("%s (%s-bit)", 
[17:04:23.568]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.568]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.568]                             "release", "version")], collapse = " "), 
[17:04:23.568]                           hostname = base::Sys.info()[["nodename"]])
[17:04:23.568]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.568]                           info)
[17:04:23.568]                         info <- base::paste(info, collapse = "; ")
[17:04:23.568]                         if (!has_future) {
[17:04:23.568]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.568]                             info)
[17:04:23.568]                         }
[17:04:23.568]                         else {
[17:04:23.568]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.568]                             info, version)
[17:04:23.568]                         }
[17:04:23.568]                         base::stop(msg)
[17:04:23.568]                       }
[17:04:23.568]                     })
[17:04:23.568]                   }
[17:04:23.568]                   ...future.strategy.old <- future::plan("list")
[17:04:23.568]                   options(future.plan = NULL)
[17:04:23.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.568]                 }
[17:04:23.568]                 ...future.workdir <- getwd()
[17:04:23.568]             }
[17:04:23.568]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.568]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.568]         }
[17:04:23.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.568]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.568]             base::names(...future.oldOptions))
[17:04:23.568]     }
[17:04:23.568]     if (FALSE) {
[17:04:23.568]     }
[17:04:23.568]     else {
[17:04:23.568]         if (TRUE) {
[17:04:23.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.568]                 open = "w")
[17:04:23.568]         }
[17:04:23.568]         else {
[17:04:23.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.568]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.568]         }
[17:04:23.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.568]             base::sink(type = "output", split = FALSE)
[17:04:23.568]             base::close(...future.stdout)
[17:04:23.568]         }, add = TRUE)
[17:04:23.568]     }
[17:04:23.568]     ...future.frame <- base::sys.nframe()
[17:04:23.568]     ...future.conditions <- base::list()
[17:04:23.568]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.568]     if (FALSE) {
[17:04:23.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.568]     }
[17:04:23.568]     ...future.result <- base::tryCatch({
[17:04:23.568]         base::withCallingHandlers({
[17:04:23.568]             ...future.value <- base::withVisible(base::local(print(42)))
[17:04:23.568]             future::FutureResult(value = ...future.value$value, 
[17:04:23.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.568]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.568]                     ...future.globalenv.names))
[17:04:23.568]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.568]         }, condition = base::local({
[17:04:23.568]             c <- base::c
[17:04:23.568]             inherits <- base::inherits
[17:04:23.568]             invokeRestart <- base::invokeRestart
[17:04:23.568]             length <- base::length
[17:04:23.568]             list <- base::list
[17:04:23.568]             seq.int <- base::seq.int
[17:04:23.568]             signalCondition <- base::signalCondition
[17:04:23.568]             sys.calls <- base::sys.calls
[17:04:23.568]             `[[` <- base::`[[`
[17:04:23.568]             `+` <- base::`+`
[17:04:23.568]             `<<-` <- base::`<<-`
[17:04:23.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.568]                   3L)]
[17:04:23.568]             }
[17:04:23.568]             function(cond) {
[17:04:23.568]                 is_error <- inherits(cond, "error")
[17:04:23.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.568]                   NULL)
[17:04:23.568]                 if (is_error) {
[17:04:23.568]                   sessionInformation <- function() {
[17:04:23.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.568]                       search = base::search(), system = base::Sys.info())
[17:04:23.568]                   }
[17:04:23.568]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.568]                     cond$call), session = sessionInformation(), 
[17:04:23.568]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.568]                   signalCondition(cond)
[17:04:23.568]                 }
[17:04:23.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.568]                 "immediateCondition"))) {
[17:04:23.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.568]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.568]                   if (TRUE && !signal) {
[17:04:23.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.568]                     {
[17:04:23.568]                       inherits <- base::inherits
[17:04:23.568]                       invokeRestart <- base::invokeRestart
[17:04:23.568]                       is.null <- base::is.null
[17:04:23.568]                       muffled <- FALSE
[17:04:23.568]                       if (inherits(cond, "message")) {
[17:04:23.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.568]                         if (muffled) 
[17:04:23.568]                           invokeRestart("muffleMessage")
[17:04:23.568]                       }
[17:04:23.568]                       else if (inherits(cond, "warning")) {
[17:04:23.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.568]                         if (muffled) 
[17:04:23.568]                           invokeRestart("muffleWarning")
[17:04:23.568]                       }
[17:04:23.568]                       else if (inherits(cond, "condition")) {
[17:04:23.568]                         if (!is.null(pattern)) {
[17:04:23.568]                           computeRestarts <- base::computeRestarts
[17:04:23.568]                           grepl <- base::grepl
[17:04:23.568]                           restarts <- computeRestarts(cond)
[17:04:23.568]                           for (restart in restarts) {
[17:04:23.568]                             name <- restart$name
[17:04:23.568]                             if (is.null(name)) 
[17:04:23.568]                               next
[17:04:23.568]                             if (!grepl(pattern, name)) 
[17:04:23.568]                               next
[17:04:23.568]                             invokeRestart(restart)
[17:04:23.568]                             muffled <- TRUE
[17:04:23.568]                             break
[17:04:23.568]                           }
[17:04:23.568]                         }
[17:04:23.568]                       }
[17:04:23.568]                       invisible(muffled)
[17:04:23.568]                     }
[17:04:23.568]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.568]                   }
[17:04:23.568]                 }
[17:04:23.568]                 else {
[17:04:23.568]                   if (TRUE) {
[17:04:23.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.568]                     {
[17:04:23.568]                       inherits <- base::inherits
[17:04:23.568]                       invokeRestart <- base::invokeRestart
[17:04:23.568]                       is.null <- base::is.null
[17:04:23.568]                       muffled <- FALSE
[17:04:23.568]                       if (inherits(cond, "message")) {
[17:04:23.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.568]                         if (muffled) 
[17:04:23.568]                           invokeRestart("muffleMessage")
[17:04:23.568]                       }
[17:04:23.568]                       else if (inherits(cond, "warning")) {
[17:04:23.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.568]                         if (muffled) 
[17:04:23.568]                           invokeRestart("muffleWarning")
[17:04:23.568]                       }
[17:04:23.568]                       else if (inherits(cond, "condition")) {
[17:04:23.568]                         if (!is.null(pattern)) {
[17:04:23.568]                           computeRestarts <- base::computeRestarts
[17:04:23.568]                           grepl <- base::grepl
[17:04:23.568]                           restarts <- computeRestarts(cond)
[17:04:23.568]                           for (restart in restarts) {
[17:04:23.568]                             name <- restart$name
[17:04:23.568]                             if (is.null(name)) 
[17:04:23.568]                               next
[17:04:23.568]                             if (!grepl(pattern, name)) 
[17:04:23.568]                               next
[17:04:23.568]                             invokeRestart(restart)
[17:04:23.568]                             muffled <- TRUE
[17:04:23.568]                             break
[17:04:23.568]                           }
[17:04:23.568]                         }
[17:04:23.568]                       }
[17:04:23.568]                       invisible(muffled)
[17:04:23.568]                     }
[17:04:23.568]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.568]                   }
[17:04:23.568]                 }
[17:04:23.568]             }
[17:04:23.568]         }))
[17:04:23.568]     }, error = function(ex) {
[17:04:23.568]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.568]                 ...future.rng), started = ...future.startTime, 
[17:04:23.568]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.568]             version = "1.8"), class = "FutureResult")
[17:04:23.568]     }, finally = {
[17:04:23.568]         if (!identical(...future.workdir, getwd())) 
[17:04:23.568]             setwd(...future.workdir)
[17:04:23.568]         {
[17:04:23.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.568]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.568]             }
[17:04:23.568]             base::options(...future.oldOptions)
[17:04:23.568]             if (.Platform$OS.type == "windows") {
[17:04:23.568]                 old_names <- names(...future.oldEnvVars)
[17:04:23.568]                 envs <- base::Sys.getenv()
[17:04:23.568]                 names <- names(envs)
[17:04:23.568]                 common <- intersect(names, old_names)
[17:04:23.568]                 added <- setdiff(names, old_names)
[17:04:23.568]                 removed <- setdiff(old_names, names)
[17:04:23.568]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.568]                   envs[common]]
[17:04:23.568]                 NAMES <- toupper(changed)
[17:04:23.568]                 args <- list()
[17:04:23.568]                 for (kk in seq_along(NAMES)) {
[17:04:23.568]                   name <- changed[[kk]]
[17:04:23.568]                   NAME <- NAMES[[kk]]
[17:04:23.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.568]                     next
[17:04:23.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.568]                 }
[17:04:23.568]                 NAMES <- toupper(added)
[17:04:23.568]                 for (kk in seq_along(NAMES)) {
[17:04:23.568]                   name <- added[[kk]]
[17:04:23.568]                   NAME <- NAMES[[kk]]
[17:04:23.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.568]                     next
[17:04:23.568]                   args[[name]] <- ""
[17:04:23.568]                 }
[17:04:23.568]                 NAMES <- toupper(removed)
[17:04:23.568]                 for (kk in seq_along(NAMES)) {
[17:04:23.568]                   name <- removed[[kk]]
[17:04:23.568]                   NAME <- NAMES[[kk]]
[17:04:23.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.568]                     next
[17:04:23.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.568]                 }
[17:04:23.568]                 if (length(args) > 0) 
[17:04:23.568]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.568]             }
[17:04:23.568]             else {
[17:04:23.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.568]             }
[17:04:23.568]             {
[17:04:23.568]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.568]                   0L) {
[17:04:23.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.568]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.568]                   base::options(opts)
[17:04:23.568]                 }
[17:04:23.568]                 {
[17:04:23.568]                   {
[17:04:23.568]                     NULL
[17:04:23.568]                     RNGkind("Mersenne-Twister")
[17:04:23.568]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.568]                       inherits = FALSE)
[17:04:23.568]                   }
[17:04:23.568]                   options(future.plan = NULL)
[17:04:23.568]                   if (is.na(NA_character_)) 
[17:04:23.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.568]                     .init = FALSE)
[17:04:23.568]                 }
[17:04:23.568]             }
[17:04:23.568]         }
[17:04:23.568]     })
[17:04:23.568]     if (TRUE) {
[17:04:23.568]         base::sink(type = "output", split = FALSE)
[17:04:23.568]         if (TRUE) {
[17:04:23.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.568]         }
[17:04:23.568]         else {
[17:04:23.568]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.568]         }
[17:04:23.568]         base::close(...future.stdout)
[17:04:23.568]         ...future.stdout <- NULL
[17:04:23.568]     }
[17:04:23.568]     ...future.result$conditions <- ...future.conditions
[17:04:23.568]     ...future.result$finished <- base::Sys.time()
[17:04:23.568]     ...future.result
[17:04:23.568] }
[17:04:23.570] plan(): Setting new future strategy stack:
[17:04:23.570] List of future strategies:
[17:04:23.570] 1. sequential:
[17:04:23.570]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.570]    - tweaked: FALSE
[17:04:23.570]    - call: NULL
[17:04:23.571] plan(): nbrOfWorkers() = 1
[17:04:23.571] plan(): Setting new future strategy stack:
[17:04:23.572] List of future strategies:
[17:04:23.572] 1. sequential:
[17:04:23.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.572]    - tweaked: FALSE
[17:04:23.572]    - call: plan(strategy)
[17:04:23.572] plan(): nbrOfWorkers() = 1
[17:04:23.572] SequentialFuture started (and completed)
[17:04:23.572] - Launch lazy future ... done
[17:04:23.572] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[17:04:23.573] getGlobalsAndPackages() ...
[17:04:23.573] Searching for globals...
[17:04:23.578] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.578] Searching for globals ... DONE
[17:04:23.578] Resolving globals: FALSE
[17:04:23.579] 
[17:04:23.579] - packages: [1] ‘utils’
[17:04:23.579] getGlobalsAndPackages() ... DONE
[17:04:23.579] run() for ‘Future’ ...
[17:04:23.579] - state: ‘created’
[17:04:23.579] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.580] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.580]   - Field: ‘label’
[17:04:23.580]   - Field: ‘local’
[17:04:23.580]   - Field: ‘owner’
[17:04:23.580]   - Field: ‘envir’
[17:04:23.580]   - Field: ‘packages’
[17:04:23.580]   - Field: ‘gc’
[17:04:23.581]   - Field: ‘conditions’
[17:04:23.581]   - Field: ‘expr’
[17:04:23.581]   - Field: ‘uuid’
[17:04:23.581]   - Field: ‘seed’
[17:04:23.581]   - Field: ‘version’
[17:04:23.581]   - Field: ‘result’
[17:04:23.581]   - Field: ‘asynchronous’
[17:04:23.581]   - Field: ‘calls’
[17:04:23.581]   - Field: ‘globals’
[17:04:23.581]   - Field: ‘stdout’
[17:04:23.581]   - Field: ‘earlySignal’
[17:04:23.582]   - Field: ‘lazy’
[17:04:23.582]   - Field: ‘state’
[17:04:23.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.582] - Launch lazy future ...
[17:04:23.582] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.582] Packages needed by future strategies (n = 0): <none>
[17:04:23.583] {
[17:04:23.583]     {
[17:04:23.583]         {
[17:04:23.583]             ...future.startTime <- base::Sys.time()
[17:04:23.583]             {
[17:04:23.583]                 {
[17:04:23.583]                   {
[17:04:23.583]                     {
[17:04:23.583]                       base::local({
[17:04:23.583]                         has_future <- base::requireNamespace("future", 
[17:04:23.583]                           quietly = TRUE)
[17:04:23.583]                         if (has_future) {
[17:04:23.583]                           ns <- base::getNamespace("future")
[17:04:23.583]                           version <- ns[[".package"]][["version"]]
[17:04:23.583]                           if (is.null(version)) 
[17:04:23.583]                             version <- utils::packageVersion("future")
[17:04:23.583]                         }
[17:04:23.583]                         else {
[17:04:23.583]                           version <- NULL
[17:04:23.583]                         }
[17:04:23.583]                         if (!has_future || version < "1.8.0") {
[17:04:23.583]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.583]                             "", base::R.version$version.string), 
[17:04:23.583]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.583]                               "release", "version")], collapse = " "), 
[17:04:23.583]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.583]                             info)
[17:04:23.583]                           info <- base::paste(info, collapse = "; ")
[17:04:23.583]                           if (!has_future) {
[17:04:23.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.583]                               info)
[17:04:23.583]                           }
[17:04:23.583]                           else {
[17:04:23.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.583]                               info, version)
[17:04:23.583]                           }
[17:04:23.583]                           base::stop(msg)
[17:04:23.583]                         }
[17:04:23.583]                       })
[17:04:23.583]                     }
[17:04:23.583]                     base::local({
[17:04:23.583]                       for (pkg in "utils") {
[17:04:23.583]                         base::loadNamespace(pkg)
[17:04:23.583]                         base::library(pkg, character.only = TRUE)
[17:04:23.583]                       }
[17:04:23.583]                     })
[17:04:23.583]                   }
[17:04:23.583]                   ...future.strategy.old <- future::plan("list")
[17:04:23.583]                   options(future.plan = NULL)
[17:04:23.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.583]                 }
[17:04:23.583]                 ...future.workdir <- getwd()
[17:04:23.583]             }
[17:04:23.583]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.583]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.583]         }
[17:04:23.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.583]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.583]             base::names(...future.oldOptions))
[17:04:23.583]     }
[17:04:23.583]     if (TRUE) {
[17:04:23.583]     }
[17:04:23.583]     else {
[17:04:23.583]         if (NA) {
[17:04:23.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.583]                 open = "w")
[17:04:23.583]         }
[17:04:23.583]         else {
[17:04:23.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.583]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.583]         }
[17:04:23.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.583]             base::sink(type = "output", split = FALSE)
[17:04:23.583]             base::close(...future.stdout)
[17:04:23.583]         }, add = TRUE)
[17:04:23.583]     }
[17:04:23.583]     ...future.frame <- base::sys.nframe()
[17:04:23.583]     ...future.conditions <- base::list()
[17:04:23.583]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.583]     if (FALSE) {
[17:04:23.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.583]     }
[17:04:23.583]     ...future.result <- base::tryCatch({
[17:04:23.583]         base::withCallingHandlers({
[17:04:23.583]             ...future.value <- base::withVisible(base::local({
[17:04:23.583]                 print(1:50)
[17:04:23.583]                 str(1:50)
[17:04:23.583]                 cat(letters, sep = "-")
[17:04:23.583]                 cat(1:6, collapse = "\n")
[17:04:23.583]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.583]                 42L
[17:04:23.583]             }))
[17:04:23.583]             future::FutureResult(value = ...future.value$value, 
[17:04:23.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.583]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.583]                     ...future.globalenv.names))
[17:04:23.583]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.583]         }, condition = base::local({
[17:04:23.583]             c <- base::c
[17:04:23.583]             inherits <- base::inherits
[17:04:23.583]             invokeRestart <- base::invokeRestart
[17:04:23.583]             length <- base::length
[17:04:23.583]             list <- base::list
[17:04:23.583]             seq.int <- base::seq.int
[17:04:23.583]             signalCondition <- base::signalCondition
[17:04:23.583]             sys.calls <- base::sys.calls
[17:04:23.583]             `[[` <- base::`[[`
[17:04:23.583]             `+` <- base::`+`
[17:04:23.583]             `<<-` <- base::`<<-`
[17:04:23.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.583]                   3L)]
[17:04:23.583]             }
[17:04:23.583]             function(cond) {
[17:04:23.583]                 is_error <- inherits(cond, "error")
[17:04:23.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.583]                   NULL)
[17:04:23.583]                 if (is_error) {
[17:04:23.583]                   sessionInformation <- function() {
[17:04:23.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.583]                       search = base::search(), system = base::Sys.info())
[17:04:23.583]                   }
[17:04:23.583]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.583]                     cond$call), session = sessionInformation(), 
[17:04:23.583]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.583]                   signalCondition(cond)
[17:04:23.583]                 }
[17:04:23.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.583]                 "immediateCondition"))) {
[17:04:23.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.583]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.583]                   if (TRUE && !signal) {
[17:04:23.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.583]                     {
[17:04:23.583]                       inherits <- base::inherits
[17:04:23.583]                       invokeRestart <- base::invokeRestart
[17:04:23.583]                       is.null <- base::is.null
[17:04:23.583]                       muffled <- FALSE
[17:04:23.583]                       if (inherits(cond, "message")) {
[17:04:23.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.583]                         if (muffled) 
[17:04:23.583]                           invokeRestart("muffleMessage")
[17:04:23.583]                       }
[17:04:23.583]                       else if (inherits(cond, "warning")) {
[17:04:23.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.583]                         if (muffled) 
[17:04:23.583]                           invokeRestart("muffleWarning")
[17:04:23.583]                       }
[17:04:23.583]                       else if (inherits(cond, "condition")) {
[17:04:23.583]                         if (!is.null(pattern)) {
[17:04:23.583]                           computeRestarts <- base::computeRestarts
[17:04:23.583]                           grepl <- base::grepl
[17:04:23.583]                           restarts <- computeRestarts(cond)
[17:04:23.583]                           for (restart in restarts) {
[17:04:23.583]                             name <- restart$name
[17:04:23.583]                             if (is.null(name)) 
[17:04:23.583]                               next
[17:04:23.583]                             if (!grepl(pattern, name)) 
[17:04:23.583]                               next
[17:04:23.583]                             invokeRestart(restart)
[17:04:23.583]                             muffled <- TRUE
[17:04:23.583]                             break
[17:04:23.583]                           }
[17:04:23.583]                         }
[17:04:23.583]                       }
[17:04:23.583]                       invisible(muffled)
[17:04:23.583]                     }
[17:04:23.583]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.583]                   }
[17:04:23.583]                 }
[17:04:23.583]                 else {
[17:04:23.583]                   if (TRUE) {
[17:04:23.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.583]                     {
[17:04:23.583]                       inherits <- base::inherits
[17:04:23.583]                       invokeRestart <- base::invokeRestart
[17:04:23.583]                       is.null <- base::is.null
[17:04:23.583]                       muffled <- FALSE
[17:04:23.583]                       if (inherits(cond, "message")) {
[17:04:23.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.583]                         if (muffled) 
[17:04:23.583]                           invokeRestart("muffleMessage")
[17:04:23.583]                       }
[17:04:23.583]                       else if (inherits(cond, "warning")) {
[17:04:23.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.583]                         if (muffled) 
[17:04:23.583]                           invokeRestart("muffleWarning")
[17:04:23.583]                       }
[17:04:23.583]                       else if (inherits(cond, "condition")) {
[17:04:23.583]                         if (!is.null(pattern)) {
[17:04:23.583]                           computeRestarts <- base::computeRestarts
[17:04:23.583]                           grepl <- base::grepl
[17:04:23.583]                           restarts <- computeRestarts(cond)
[17:04:23.583]                           for (restart in restarts) {
[17:04:23.583]                             name <- restart$name
[17:04:23.583]                             if (is.null(name)) 
[17:04:23.583]                               next
[17:04:23.583]                             if (!grepl(pattern, name)) 
[17:04:23.583]                               next
[17:04:23.583]                             invokeRestart(restart)
[17:04:23.583]                             muffled <- TRUE
[17:04:23.583]                             break
[17:04:23.583]                           }
[17:04:23.583]                         }
[17:04:23.583]                       }
[17:04:23.583]                       invisible(muffled)
[17:04:23.583]                     }
[17:04:23.583]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.583]                   }
[17:04:23.583]                 }
[17:04:23.583]             }
[17:04:23.583]         }))
[17:04:23.583]     }, error = function(ex) {
[17:04:23.583]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.583]                 ...future.rng), started = ...future.startTime, 
[17:04:23.583]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.583]             version = "1.8"), class = "FutureResult")
[17:04:23.583]     }, finally = {
[17:04:23.583]         if (!identical(...future.workdir, getwd())) 
[17:04:23.583]             setwd(...future.workdir)
[17:04:23.583]         {
[17:04:23.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.583]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.583]             }
[17:04:23.583]             base::options(...future.oldOptions)
[17:04:23.583]             if (.Platform$OS.type == "windows") {
[17:04:23.583]                 old_names <- names(...future.oldEnvVars)
[17:04:23.583]                 envs <- base::Sys.getenv()
[17:04:23.583]                 names <- names(envs)
[17:04:23.583]                 common <- intersect(names, old_names)
[17:04:23.583]                 added <- setdiff(names, old_names)
[17:04:23.583]                 removed <- setdiff(old_names, names)
[17:04:23.583]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.583]                   envs[common]]
[17:04:23.583]                 NAMES <- toupper(changed)
[17:04:23.583]                 args <- list()
[17:04:23.583]                 for (kk in seq_along(NAMES)) {
[17:04:23.583]                   name <- changed[[kk]]
[17:04:23.583]                   NAME <- NAMES[[kk]]
[17:04:23.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.583]                     next
[17:04:23.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.583]                 }
[17:04:23.583]                 NAMES <- toupper(added)
[17:04:23.583]                 for (kk in seq_along(NAMES)) {
[17:04:23.583]                   name <- added[[kk]]
[17:04:23.583]                   NAME <- NAMES[[kk]]
[17:04:23.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.583]                     next
[17:04:23.583]                   args[[name]] <- ""
[17:04:23.583]                 }
[17:04:23.583]                 NAMES <- toupper(removed)
[17:04:23.583]                 for (kk in seq_along(NAMES)) {
[17:04:23.583]                   name <- removed[[kk]]
[17:04:23.583]                   NAME <- NAMES[[kk]]
[17:04:23.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.583]                     next
[17:04:23.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.583]                 }
[17:04:23.583]                 if (length(args) > 0) 
[17:04:23.583]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.583]             }
[17:04:23.583]             else {
[17:04:23.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.583]             }
[17:04:23.583]             {
[17:04:23.583]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.583]                   0L) {
[17:04:23.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.583]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.583]                   base::options(opts)
[17:04:23.583]                 }
[17:04:23.583]                 {
[17:04:23.583]                   {
[17:04:23.583]                     NULL
[17:04:23.583]                     RNGkind("Mersenne-Twister")
[17:04:23.583]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.583]                       inherits = FALSE)
[17:04:23.583]                   }
[17:04:23.583]                   options(future.plan = NULL)
[17:04:23.583]                   if (is.na(NA_character_)) 
[17:04:23.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.583]                     .init = FALSE)
[17:04:23.583]                 }
[17:04:23.583]             }
[17:04:23.583]         }
[17:04:23.583]     })
[17:04:23.583]     if (FALSE) {
[17:04:23.583]         base::sink(type = "output", split = FALSE)
[17:04:23.583]         if (NA) {
[17:04:23.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.583]         }
[17:04:23.583]         else {
[17:04:23.583]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.583]         }
[17:04:23.583]         base::close(...future.stdout)
[17:04:23.583]         ...future.stdout <- NULL
[17:04:23.583]     }
[17:04:23.583]     ...future.result$conditions <- ...future.conditions
[17:04:23.583]     ...future.result$finished <- base::Sys.time()
[17:04:23.583]     ...future.result
[17:04:23.583] }
[17:04:23.585] plan(): Setting new future strategy stack:
[17:04:23.585] List of future strategies:
[17:04:23.585] 1. sequential:
[17:04:23.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.585]    - tweaked: FALSE
[17:04:23.585]    - call: NULL
[17:04:23.585] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:04:23.587] plan(): Setting new future strategy stack:
[17:04:23.587] List of future strategies:
[17:04:23.587] 1. sequential:
[17:04:23.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.587]    - tweaked: FALSE
[17:04:23.587]    - call: plan(strategy)
[17:04:23.588] plan(): nbrOfWorkers() = 1
[17:04:23.588] SequentialFuture started (and completed)
[17:04:23.588] - Launch lazy future ... done
[17:04:23.588] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ session_uuid: chr "3697237d-75fc-0dd5-7f9d-42c2e0c2ecf9"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50425
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:23"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:23.596] getGlobalsAndPackages() ...
[17:04:23.596] Searching for globals...
[17:04:23.599] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.599] Searching for globals ... DONE
[17:04:23.600] Resolving globals: FALSE
[17:04:23.600] 
[17:04:23.600] - packages: [1] ‘utils’
[17:04:23.600] getGlobalsAndPackages() ... DONE
[17:04:23.601] run() for ‘Future’ ...
[17:04:23.601] - state: ‘created’
[17:04:23.601] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.601] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.601]   - Field: ‘label’
[17:04:23.601]   - Field: ‘local’
[17:04:23.602]   - Field: ‘owner’
[17:04:23.602]   - Field: ‘envir’
[17:04:23.602]   - Field: ‘packages’
[17:04:23.602]   - Field: ‘gc’
[17:04:23.602]   - Field: ‘conditions’
[17:04:23.602]   - Field: ‘expr’
[17:04:23.602]   - Field: ‘uuid’
[17:04:23.602]   - Field: ‘seed’
[17:04:23.602]   - Field: ‘version’
[17:04:23.602]   - Field: ‘result’
[17:04:23.602]   - Field: ‘asynchronous’
[17:04:23.603]   - Field: ‘calls’
[17:04:23.603]   - Field: ‘globals’
[17:04:23.603]   - Field: ‘stdout’
[17:04:23.603]   - Field: ‘earlySignal’
[17:04:23.603]   - Field: ‘lazy’
[17:04:23.605]   - Field: ‘state’
[17:04:23.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.605] - Launch lazy future ...
[17:04:23.605] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.606] Packages needed by future strategies (n = 0): <none>
[17:04:23.606] {
[17:04:23.606]     {
[17:04:23.606]         {
[17:04:23.606]             ...future.startTime <- base::Sys.time()
[17:04:23.606]             {
[17:04:23.606]                 {
[17:04:23.606]                   {
[17:04:23.606]                     {
[17:04:23.606]                       base::local({
[17:04:23.606]                         has_future <- base::requireNamespace("future", 
[17:04:23.606]                           quietly = TRUE)
[17:04:23.606]                         if (has_future) {
[17:04:23.606]                           ns <- base::getNamespace("future")
[17:04:23.606]                           version <- ns[[".package"]][["version"]]
[17:04:23.606]                           if (is.null(version)) 
[17:04:23.606]                             version <- utils::packageVersion("future")
[17:04:23.606]                         }
[17:04:23.606]                         else {
[17:04:23.606]                           version <- NULL
[17:04:23.606]                         }
[17:04:23.606]                         if (!has_future || version < "1.8.0") {
[17:04:23.606]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.606]                             "", base::R.version$version.string), 
[17:04:23.606]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.606]                               "release", "version")], collapse = " "), 
[17:04:23.606]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.606]                             info)
[17:04:23.606]                           info <- base::paste(info, collapse = "; ")
[17:04:23.606]                           if (!has_future) {
[17:04:23.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.606]                               info)
[17:04:23.606]                           }
[17:04:23.606]                           else {
[17:04:23.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.606]                               info, version)
[17:04:23.606]                           }
[17:04:23.606]                           base::stop(msg)
[17:04:23.606]                         }
[17:04:23.606]                       })
[17:04:23.606]                     }
[17:04:23.606]                     base::local({
[17:04:23.606]                       for (pkg in "utils") {
[17:04:23.606]                         base::loadNamespace(pkg)
[17:04:23.606]                         base::library(pkg, character.only = TRUE)
[17:04:23.606]                       }
[17:04:23.606]                     })
[17:04:23.606]                   }
[17:04:23.606]                   ...future.strategy.old <- future::plan("list")
[17:04:23.606]                   options(future.plan = NULL)
[17:04:23.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.606]                 }
[17:04:23.606]                 ...future.workdir <- getwd()
[17:04:23.606]             }
[17:04:23.606]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.606]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.606]         }
[17:04:23.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.606]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.606]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.606]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.606]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.606]             base::names(...future.oldOptions))
[17:04:23.606]     }
[17:04:23.606]     if (TRUE) {
[17:04:23.606]     }
[17:04:23.606]     else {
[17:04:23.606]         if (NA) {
[17:04:23.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.606]                 open = "w")
[17:04:23.606]         }
[17:04:23.606]         else {
[17:04:23.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.606]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.606]         }
[17:04:23.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.606]             base::sink(type = "output", split = FALSE)
[17:04:23.606]             base::close(...future.stdout)
[17:04:23.606]         }, add = TRUE)
[17:04:23.606]     }
[17:04:23.606]     ...future.frame <- base::sys.nframe()
[17:04:23.606]     ...future.conditions <- base::list()
[17:04:23.606]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.606]     if (FALSE) {
[17:04:23.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.606]     }
[17:04:23.606]     ...future.result <- base::tryCatch({
[17:04:23.606]         base::withCallingHandlers({
[17:04:23.606]             ...future.value <- base::withVisible(base::local({
[17:04:23.606]                 print(1:50)
[17:04:23.606]                 str(1:50)
[17:04:23.606]                 cat(letters, sep = "-")
[17:04:23.606]                 cat(1:6, collapse = "\n")
[17:04:23.606]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.606]                 42L
[17:04:23.606]             }))
[17:04:23.606]             future::FutureResult(value = ...future.value$value, 
[17:04:23.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.606]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.606]                     ...future.globalenv.names))
[17:04:23.606]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.606]         }, condition = base::local({
[17:04:23.606]             c <- base::c
[17:04:23.606]             inherits <- base::inherits
[17:04:23.606]             invokeRestart <- base::invokeRestart
[17:04:23.606]             length <- base::length
[17:04:23.606]             list <- base::list
[17:04:23.606]             seq.int <- base::seq.int
[17:04:23.606]             signalCondition <- base::signalCondition
[17:04:23.606]             sys.calls <- base::sys.calls
[17:04:23.606]             `[[` <- base::`[[`
[17:04:23.606]             `+` <- base::`+`
[17:04:23.606]             `<<-` <- base::`<<-`
[17:04:23.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.606]                   3L)]
[17:04:23.606]             }
[17:04:23.606]             function(cond) {
[17:04:23.606]                 is_error <- inherits(cond, "error")
[17:04:23.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.606]                   NULL)
[17:04:23.606]                 if (is_error) {
[17:04:23.606]                   sessionInformation <- function() {
[17:04:23.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.606]                       search = base::search(), system = base::Sys.info())
[17:04:23.606]                   }
[17:04:23.606]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.606]                     cond$call), session = sessionInformation(), 
[17:04:23.606]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.606]                   signalCondition(cond)
[17:04:23.606]                 }
[17:04:23.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.606]                 "immediateCondition"))) {
[17:04:23.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.606]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.606]                   if (TRUE && !signal) {
[17:04:23.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.606]                     {
[17:04:23.606]                       inherits <- base::inherits
[17:04:23.606]                       invokeRestart <- base::invokeRestart
[17:04:23.606]                       is.null <- base::is.null
[17:04:23.606]                       muffled <- FALSE
[17:04:23.606]                       if (inherits(cond, "message")) {
[17:04:23.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.606]                         if (muffled) 
[17:04:23.606]                           invokeRestart("muffleMessage")
[17:04:23.606]                       }
[17:04:23.606]                       else if (inherits(cond, "warning")) {
[17:04:23.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.606]                         if (muffled) 
[17:04:23.606]                           invokeRestart("muffleWarning")
[17:04:23.606]                       }
[17:04:23.606]                       else if (inherits(cond, "condition")) {
[17:04:23.606]                         if (!is.null(pattern)) {
[17:04:23.606]                           computeRestarts <- base::computeRestarts
[17:04:23.606]                           grepl <- base::grepl
[17:04:23.606]                           restarts <- computeRestarts(cond)
[17:04:23.606]                           for (restart in restarts) {
[17:04:23.606]                             name <- restart$name
[17:04:23.606]                             if (is.null(name)) 
[17:04:23.606]                               next
[17:04:23.606]                             if (!grepl(pattern, name)) 
[17:04:23.606]                               next
[17:04:23.606]                             invokeRestart(restart)
[17:04:23.606]                             muffled <- TRUE
[17:04:23.606]                             break
[17:04:23.606]                           }
[17:04:23.606]                         }
[17:04:23.606]                       }
[17:04:23.606]                       invisible(muffled)
[17:04:23.606]                     }
[17:04:23.606]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.606]                   }
[17:04:23.606]                 }
[17:04:23.606]                 else {
[17:04:23.606]                   if (TRUE) {
[17:04:23.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.606]                     {
[17:04:23.606]                       inherits <- base::inherits
[17:04:23.606]                       invokeRestart <- base::invokeRestart
[17:04:23.606]                       is.null <- base::is.null
[17:04:23.606]                       muffled <- FALSE
[17:04:23.606]                       if (inherits(cond, "message")) {
[17:04:23.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.606]                         if (muffled) 
[17:04:23.606]                           invokeRestart("muffleMessage")
[17:04:23.606]                       }
[17:04:23.606]                       else if (inherits(cond, "warning")) {
[17:04:23.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.606]                         if (muffled) 
[17:04:23.606]                           invokeRestart("muffleWarning")
[17:04:23.606]                       }
[17:04:23.606]                       else if (inherits(cond, "condition")) {
[17:04:23.606]                         if (!is.null(pattern)) {
[17:04:23.606]                           computeRestarts <- base::computeRestarts
[17:04:23.606]                           grepl <- base::grepl
[17:04:23.606]                           restarts <- computeRestarts(cond)
[17:04:23.606]                           for (restart in restarts) {
[17:04:23.606]                             name <- restart$name
[17:04:23.606]                             if (is.null(name)) 
[17:04:23.606]                               next
[17:04:23.606]                             if (!grepl(pattern, name)) 
[17:04:23.606]                               next
[17:04:23.606]                             invokeRestart(restart)
[17:04:23.606]                             muffled <- TRUE
[17:04:23.606]                             break
[17:04:23.606]                           }
[17:04:23.606]                         }
[17:04:23.606]                       }
[17:04:23.606]                       invisible(muffled)
[17:04:23.606]                     }
[17:04:23.606]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.606]                   }
[17:04:23.606]                 }
[17:04:23.606]             }
[17:04:23.606]         }))
[17:04:23.606]     }, error = function(ex) {
[17:04:23.606]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.606]                 ...future.rng), started = ...future.startTime, 
[17:04:23.606]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.606]             version = "1.8"), class = "FutureResult")
[17:04:23.606]     }, finally = {
[17:04:23.606]         if (!identical(...future.workdir, getwd())) 
[17:04:23.606]             setwd(...future.workdir)
[17:04:23.606]         {
[17:04:23.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.606]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.606]             }
[17:04:23.606]             base::options(...future.oldOptions)
[17:04:23.606]             if (.Platform$OS.type == "windows") {
[17:04:23.606]                 old_names <- names(...future.oldEnvVars)
[17:04:23.606]                 envs <- base::Sys.getenv()
[17:04:23.606]                 names <- names(envs)
[17:04:23.606]                 common <- intersect(names, old_names)
[17:04:23.606]                 added <- setdiff(names, old_names)
[17:04:23.606]                 removed <- setdiff(old_names, names)
[17:04:23.606]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.606]                   envs[common]]
[17:04:23.606]                 NAMES <- toupper(changed)
[17:04:23.606]                 args <- list()
[17:04:23.606]                 for (kk in seq_along(NAMES)) {
[17:04:23.606]                   name <- changed[[kk]]
[17:04:23.606]                   NAME <- NAMES[[kk]]
[17:04:23.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.606]                     next
[17:04:23.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.606]                 }
[17:04:23.606]                 NAMES <- toupper(added)
[17:04:23.606]                 for (kk in seq_along(NAMES)) {
[17:04:23.606]                   name <- added[[kk]]
[17:04:23.606]                   NAME <- NAMES[[kk]]
[17:04:23.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.606]                     next
[17:04:23.606]                   args[[name]] <- ""
[17:04:23.606]                 }
[17:04:23.606]                 NAMES <- toupper(removed)
[17:04:23.606]                 for (kk in seq_along(NAMES)) {
[17:04:23.606]                   name <- removed[[kk]]
[17:04:23.606]                   NAME <- NAMES[[kk]]
[17:04:23.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.606]                     next
[17:04:23.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.606]                 }
[17:04:23.606]                 if (length(args) > 0) 
[17:04:23.606]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.606]             }
[17:04:23.606]             else {
[17:04:23.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.606]             }
[17:04:23.606]             {
[17:04:23.606]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.606]                   0L) {
[17:04:23.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.606]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.606]                   base::options(opts)
[17:04:23.606]                 }
[17:04:23.606]                 {
[17:04:23.606]                   {
[17:04:23.606]                     NULL
[17:04:23.606]                     RNGkind("Mersenne-Twister")
[17:04:23.606]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.606]                       inherits = FALSE)
[17:04:23.606]                   }
[17:04:23.606]                   options(future.plan = NULL)
[17:04:23.606]                   if (is.na(NA_character_)) 
[17:04:23.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.606]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.606]                     .init = FALSE)
[17:04:23.606]                 }
[17:04:23.606]             }
[17:04:23.606]         }
[17:04:23.606]     })
[17:04:23.606]     if (FALSE) {
[17:04:23.606]         base::sink(type = "output", split = FALSE)
[17:04:23.606]         if (NA) {
[17:04:23.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.606]         }
[17:04:23.606]         else {
[17:04:23.606]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.606]         }
[17:04:23.606]         base::close(...future.stdout)
[17:04:23.606]         ...future.stdout <- NULL
[17:04:23.606]     }
[17:04:23.606]     ...future.result$conditions <- ...future.conditions
[17:04:23.606]     ...future.result$finished <- base::Sys.time()
[17:04:23.606]     ...future.result
[17:04:23.606] }
[17:04:23.608] plan(): Setting new future strategy stack:
[17:04:23.608] List of future strategies:
[17:04:23.608] 1. sequential:
[17:04:23.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.608]    - tweaked: FALSE
[17:04:23.608]    - call: NULL
[17:04:23.609] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:04:23.611] plan(): Setting new future strategy stack:
[17:04:23.611] List of future strategies:
[17:04:23.611] 1. sequential:
[17:04:23.611]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.611]    - tweaked: FALSE
[17:04:23.611]    - call: plan(strategy)
[17:04:23.611] plan(): nbrOfWorkers() = 1
[17:04:23.612] SequentialFuture started (and completed)
[17:04:23.612] - Launch lazy future ... done
[17:04:23.612] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[17:04:23.612] getGlobalsAndPackages() ...
[17:04:23.612] Searching for globals...
[17:04:23.613] - globals found: [1] ‘print’
[17:04:23.613] Searching for globals ... DONE
[17:04:23.613] Resolving globals: FALSE
[17:04:23.613] 
[17:04:23.613] 
[17:04:23.614] getGlobalsAndPackages() ... DONE
[17:04:23.614] run() for ‘Future’ ...
[17:04:23.614] - state: ‘created’
[17:04:23.614] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:04:23.614] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:04:23.614] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:04:23.615]   - Field: ‘label’
[17:04:23.615]   - Field: ‘local’
[17:04:23.615]   - Field: ‘owner’
[17:04:23.615]   - Field: ‘envir’
[17:04:23.615]   - Field: ‘packages’
[17:04:23.615]   - Field: ‘gc’
[17:04:23.615]   - Field: ‘conditions’
[17:04:23.615]   - Field: ‘expr’
[17:04:23.615]   - Field: ‘uuid’
[17:04:23.615]   - Field: ‘seed’
[17:04:23.616]   - Field: ‘version’
[17:04:23.616]   - Field: ‘result’
[17:04:23.616]   - Field: ‘asynchronous’
[17:04:23.616]   - Field: ‘calls’
[17:04:23.616]   - Field: ‘globals’
[17:04:23.616]   - Field: ‘stdout’
[17:04:23.616]   - Field: ‘earlySignal’
[17:04:23.616]   - Field: ‘lazy’
[17:04:23.616]   - Field: ‘state’
[17:04:23.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:04:23.616] - Launch lazy future ...
[17:04:23.617] Packages needed by the future expression (n = 0): <none>
[17:04:23.617] Packages needed by future strategies (n = 0): <none>
[17:04:23.617] {
[17:04:23.617]     {
[17:04:23.617]         {
[17:04:23.617]             ...future.startTime <- base::Sys.time()
[17:04:23.617]             {
[17:04:23.617]                 {
[17:04:23.617]                   {
[17:04:23.617]                     base::local({
[17:04:23.617]                       has_future <- base::requireNamespace("future", 
[17:04:23.617]                         quietly = TRUE)
[17:04:23.617]                       if (has_future) {
[17:04:23.617]                         ns <- base::getNamespace("future")
[17:04:23.617]                         version <- ns[[".package"]][["version"]]
[17:04:23.617]                         if (is.null(version)) 
[17:04:23.617]                           version <- utils::packageVersion("future")
[17:04:23.617]                       }
[17:04:23.617]                       else {
[17:04:23.617]                         version <- NULL
[17:04:23.617]                       }
[17:04:23.617]                       if (!has_future || version < "1.8.0") {
[17:04:23.617]                         info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.617]                           "", base::R.version$version.string), 
[17:04:23.617]                           platform = base::sprintf("%s (%s-bit)", 
[17:04:23.617]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.617]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.617]                             "release", "version")], collapse = " "), 
[17:04:23.617]                           hostname = base::Sys.info()[["nodename"]])
[17:04:23.617]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.617]                           info)
[17:04:23.617]                         info <- base::paste(info, collapse = "; ")
[17:04:23.617]                         if (!has_future) {
[17:04:23.617]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.617]                             info)
[17:04:23.617]                         }
[17:04:23.617]                         else {
[17:04:23.617]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.617]                             info, version)
[17:04:23.617]                         }
[17:04:23.617]                         base::stop(msg)
[17:04:23.617]                       }
[17:04:23.617]                     })
[17:04:23.617]                   }
[17:04:23.617]                   ...future.strategy.old <- future::plan("list")
[17:04:23.617]                   options(future.plan = NULL)
[17:04:23.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.617]                 }
[17:04:23.617]                 ...future.workdir <- getwd()
[17:04:23.617]             }
[17:04:23.617]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.617]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.617]         }
[17:04:23.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.617]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.617]             base::names(...future.oldOptions))
[17:04:23.617]     }
[17:04:23.617]     if (FALSE) {
[17:04:23.617]     }
[17:04:23.617]     else {
[17:04:23.617]         if (TRUE) {
[17:04:23.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.617]                 open = "w")
[17:04:23.617]         }
[17:04:23.617]         else {
[17:04:23.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.617]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.617]         }
[17:04:23.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.617]             base::sink(type = "output", split = FALSE)
[17:04:23.617]             base::close(...future.stdout)
[17:04:23.617]         }, add = TRUE)
[17:04:23.617]     }
[17:04:23.617]     ...future.frame <- base::sys.nframe()
[17:04:23.617]     ...future.conditions <- base::list()
[17:04:23.617]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.617]     if (FALSE) {
[17:04:23.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.617]     }
[17:04:23.617]     ...future.result <- base::tryCatch({
[17:04:23.617]         base::withCallingHandlers({
[17:04:23.617]             ...future.value <- base::withVisible(base::local(print(42)))
[17:04:23.617]             future::FutureResult(value = ...future.value$value, 
[17:04:23.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.617]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.617]                     ...future.globalenv.names))
[17:04:23.617]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.617]         }, condition = base::local({
[17:04:23.617]             c <- base::c
[17:04:23.617]             inherits <- base::inherits
[17:04:23.617]             invokeRestart <- base::invokeRestart
[17:04:23.617]             length <- base::length
[17:04:23.617]             list <- base::list
[17:04:23.617]             seq.int <- base::seq.int
[17:04:23.617]             signalCondition <- base::signalCondition
[17:04:23.617]             sys.calls <- base::sys.calls
[17:04:23.617]             `[[` <- base::`[[`
[17:04:23.617]             `+` <- base::`+`
[17:04:23.617]             `<<-` <- base::`<<-`
[17:04:23.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.617]                   3L)]
[17:04:23.617]             }
[17:04:23.617]             function(cond) {
[17:04:23.617]                 is_error <- inherits(cond, "error")
[17:04:23.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.617]                   NULL)
[17:04:23.617]                 if (is_error) {
[17:04:23.617]                   sessionInformation <- function() {
[17:04:23.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.617]                       search = base::search(), system = base::Sys.info())
[17:04:23.617]                   }
[17:04:23.617]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.617]                     cond$call), session = sessionInformation(), 
[17:04:23.617]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.617]                   signalCondition(cond)
[17:04:23.617]                 }
[17:04:23.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.617]                 "immediateCondition"))) {
[17:04:23.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.617]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.617]                   if (TRUE && !signal) {
[17:04:23.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.617]                     {
[17:04:23.617]                       inherits <- base::inherits
[17:04:23.617]                       invokeRestart <- base::invokeRestart
[17:04:23.617]                       is.null <- base::is.null
[17:04:23.617]                       muffled <- FALSE
[17:04:23.617]                       if (inherits(cond, "message")) {
[17:04:23.617]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.617]                         if (muffled) 
[17:04:23.617]                           invokeRestart("muffleMessage")
[17:04:23.617]                       }
[17:04:23.617]                       else if (inherits(cond, "warning")) {
[17:04:23.617]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.617]                         if (muffled) 
[17:04:23.617]                           invokeRestart("muffleWarning")
[17:04:23.617]                       }
[17:04:23.617]                       else if (inherits(cond, "condition")) {
[17:04:23.617]                         if (!is.null(pattern)) {
[17:04:23.617]                           computeRestarts <- base::computeRestarts
[17:04:23.617]                           grepl <- base::grepl
[17:04:23.617]                           restarts <- computeRestarts(cond)
[17:04:23.617]                           for (restart in restarts) {
[17:04:23.617]                             name <- restart$name
[17:04:23.617]                             if (is.null(name)) 
[17:04:23.617]                               next
[17:04:23.617]                             if (!grepl(pattern, name)) 
[17:04:23.617]                               next
[17:04:23.617]                             invokeRestart(restart)
[17:04:23.617]                             muffled <- TRUE
[17:04:23.617]                             break
[17:04:23.617]                           }
[17:04:23.617]                         }
[17:04:23.617]                       }
[17:04:23.617]                       invisible(muffled)
[17:04:23.617]                     }
[17:04:23.617]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.617]                   }
[17:04:23.617]                 }
[17:04:23.617]                 else {
[17:04:23.617]                   if (TRUE) {
[17:04:23.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.617]                     {
[17:04:23.617]                       inherits <- base::inherits
[17:04:23.617]                       invokeRestart <- base::invokeRestart
[17:04:23.617]                       is.null <- base::is.null
[17:04:23.617]                       muffled <- FALSE
[17:04:23.617]                       if (inherits(cond, "message")) {
[17:04:23.617]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.617]                         if (muffled) 
[17:04:23.617]                           invokeRestart("muffleMessage")
[17:04:23.617]                       }
[17:04:23.617]                       else if (inherits(cond, "warning")) {
[17:04:23.617]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.617]                         if (muffled) 
[17:04:23.617]                           invokeRestart("muffleWarning")
[17:04:23.617]                       }
[17:04:23.617]                       else if (inherits(cond, "condition")) {
[17:04:23.617]                         if (!is.null(pattern)) {
[17:04:23.617]                           computeRestarts <- base::computeRestarts
[17:04:23.617]                           grepl <- base::grepl
[17:04:23.617]                           restarts <- computeRestarts(cond)
[17:04:23.617]                           for (restart in restarts) {
[17:04:23.617]                             name <- restart$name
[17:04:23.617]                             if (is.null(name)) 
[17:04:23.617]                               next
[17:04:23.617]                             if (!grepl(pattern, name)) 
[17:04:23.617]                               next
[17:04:23.617]                             invokeRestart(restart)
[17:04:23.617]                             muffled <- TRUE
[17:04:23.617]                             break
[17:04:23.617]                           }
[17:04:23.617]                         }
[17:04:23.617]                       }
[17:04:23.617]                       invisible(muffled)
[17:04:23.617]                     }
[17:04:23.617]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.617]                   }
[17:04:23.617]                 }
[17:04:23.617]             }
[17:04:23.617]         }))
[17:04:23.617]     }, error = function(ex) {
[17:04:23.617]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.617]                 ...future.rng), started = ...future.startTime, 
[17:04:23.617]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.617]             version = "1.8"), class = "FutureResult")
[17:04:23.617]     }, finally = {
[17:04:23.617]         if (!identical(...future.workdir, getwd())) 
[17:04:23.617]             setwd(...future.workdir)
[17:04:23.617]         {
[17:04:23.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.617]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.617]             }
[17:04:23.617]             base::options(...future.oldOptions)
[17:04:23.617]             if (.Platform$OS.type == "windows") {
[17:04:23.617]                 old_names <- names(...future.oldEnvVars)
[17:04:23.617]                 envs <- base::Sys.getenv()
[17:04:23.617]                 names <- names(envs)
[17:04:23.617]                 common <- intersect(names, old_names)
[17:04:23.617]                 added <- setdiff(names, old_names)
[17:04:23.617]                 removed <- setdiff(old_names, names)
[17:04:23.617]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.617]                   envs[common]]
[17:04:23.617]                 NAMES <- toupper(changed)
[17:04:23.617]                 args <- list()
[17:04:23.617]                 for (kk in seq_along(NAMES)) {
[17:04:23.617]                   name <- changed[[kk]]
[17:04:23.617]                   NAME <- NAMES[[kk]]
[17:04:23.617]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.617]                     next
[17:04:23.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.617]                 }
[17:04:23.617]                 NAMES <- toupper(added)
[17:04:23.617]                 for (kk in seq_along(NAMES)) {
[17:04:23.617]                   name <- added[[kk]]
[17:04:23.617]                   NAME <- NAMES[[kk]]
[17:04:23.617]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.617]                     next
[17:04:23.617]                   args[[name]] <- ""
[17:04:23.617]                 }
[17:04:23.617]                 NAMES <- toupper(removed)
[17:04:23.617]                 for (kk in seq_along(NAMES)) {
[17:04:23.617]                   name <- removed[[kk]]
[17:04:23.617]                   NAME <- NAMES[[kk]]
[17:04:23.617]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.617]                     next
[17:04:23.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.617]                 }
[17:04:23.617]                 if (length(args) > 0) 
[17:04:23.617]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.617]             }
[17:04:23.617]             else {
[17:04:23.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.617]             }
[17:04:23.617]             {
[17:04:23.617]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.617]                   0L) {
[17:04:23.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.617]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.617]                   base::options(opts)
[17:04:23.617]                 }
[17:04:23.617]                 {
[17:04:23.617]                   {
[17:04:23.617]                     NULL
[17:04:23.617]                     RNGkind("Mersenne-Twister")
[17:04:23.617]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:04:23.617]                       inherits = FALSE)
[17:04:23.617]                   }
[17:04:23.617]                   options(future.plan = NULL)
[17:04:23.617]                   if (is.na(NA_character_)) 
[17:04:23.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.617]                     .init = FALSE)
[17:04:23.617]                 }
[17:04:23.617]             }
[17:04:23.617]         }
[17:04:23.617]     })
[17:04:23.617]     if (TRUE) {
[17:04:23.617]         base::sink(type = "output", split = FALSE)
[17:04:23.617]         if (TRUE) {
[17:04:23.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.617]         }
[17:04:23.617]         else {
[17:04:23.617]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.617]         }
[17:04:23.617]         base::close(...future.stdout)
[17:04:23.617]         ...future.stdout <- NULL
[17:04:23.617]     }
[17:04:23.617]     ...future.result$conditions <- ...future.conditions
[17:04:23.617]     ...future.result$finished <- base::Sys.time()
[17:04:23.617]     ...future.result
[17:04:23.617] }
[17:04:23.619] plan(): Setting new future strategy stack:
[17:04:23.619] List of future strategies:
[17:04:23.619] 1. sequential:
[17:04:23.619]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.619]    - tweaked: FALSE
[17:04:23.619]    - call: NULL
[17:04:23.620] plan(): nbrOfWorkers() = 1
[17:04:23.621] plan(): Setting new future strategy stack:
[17:04:23.621] List of future strategies:
[17:04:23.621] 1. sequential:
[17:04:23.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.621]    - tweaked: FALSE
[17:04:23.621]    - call: plan(strategy)
[17:04:23.621] plan(): nbrOfWorkers() = 1
[17:04:23.621] SequentialFuture started (and completed)
[17:04:23.621] - Launch lazy future ... done
[17:04:23.621] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[17:04:23.627] plan(): Setting new future strategy stack:
[17:04:23.627] List of future strategies:
[17:04:23.627] 1. multicore:
[17:04:23.627]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.627]    - tweaked: FALSE
[17:04:23.627]    - call: plan(strategy)
[17:04:23.631] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[17:04:23.631] getGlobalsAndPackages() ...
[17:04:23.632] Searching for globals...
[17:04:23.634] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.635] Searching for globals ... DONE
[17:04:23.635] Resolving globals: FALSE
[17:04:23.635] 
[17:04:23.635] - packages: [1] ‘utils’
[17:04:23.635] getGlobalsAndPackages() ... DONE
[17:04:23.636] run() for ‘Future’ ...
[17:04:23.636] - state: ‘created’
[17:04:23.636] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.642] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.642]   - Field: ‘label’
[17:04:23.642]   - Field: ‘local’
[17:04:23.643]   - Field: ‘owner’
[17:04:23.643]   - Field: ‘envir’
[17:04:23.643]   - Field: ‘workers’
[17:04:23.643]   - Field: ‘packages’
[17:04:23.643]   - Field: ‘gc’
[17:04:23.643]   - Field: ‘job’
[17:04:23.643]   - Field: ‘conditions’
[17:04:23.643]   - Field: ‘expr’
[17:04:23.643]   - Field: ‘uuid’
[17:04:23.644]   - Field: ‘seed’
[17:04:23.644]   - Field: ‘version’
[17:04:23.644]   - Field: ‘result’
[17:04:23.644]   - Field: ‘asynchronous’
[17:04:23.644]   - Field: ‘calls’
[17:04:23.644]   - Field: ‘globals’
[17:04:23.644]   - Field: ‘stdout’
[17:04:23.644]   - Field: ‘earlySignal’
[17:04:23.644]   - Field: ‘lazy’
[17:04:23.644]   - Field: ‘state’
[17:04:23.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.645] - Launch lazy future ...
[17:04:23.646] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.646] Packages needed by future strategies (n = 0): <none>
[17:04:23.646] {
[17:04:23.646]     {
[17:04:23.646]         {
[17:04:23.646]             ...future.startTime <- base::Sys.time()
[17:04:23.646]             {
[17:04:23.646]                 {
[17:04:23.646]                   {
[17:04:23.646]                     {
[17:04:23.646]                       {
[17:04:23.646]                         base::local({
[17:04:23.646]                           has_future <- base::requireNamespace("future", 
[17:04:23.646]                             quietly = TRUE)
[17:04:23.646]                           if (has_future) {
[17:04:23.646]                             ns <- base::getNamespace("future")
[17:04:23.646]                             version <- ns[[".package"]][["version"]]
[17:04:23.646]                             if (is.null(version)) 
[17:04:23.646]                               version <- utils::packageVersion("future")
[17:04:23.646]                           }
[17:04:23.646]                           else {
[17:04:23.646]                             version <- NULL
[17:04:23.646]                           }
[17:04:23.646]                           if (!has_future || version < "1.8.0") {
[17:04:23.646]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.646]                               "", base::R.version$version.string), 
[17:04:23.646]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:23.646]                                 base::R.version$platform, 8 * 
[17:04:23.646]                                   base::.Machine$sizeof.pointer), 
[17:04:23.646]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.646]                                 "release", "version")], collapse = " "), 
[17:04:23.646]                               hostname = base::Sys.info()[["nodename"]])
[17:04:23.646]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.646]                               info)
[17:04:23.646]                             info <- base::paste(info, collapse = "; ")
[17:04:23.646]                             if (!has_future) {
[17:04:23.646]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.646]                                 info)
[17:04:23.646]                             }
[17:04:23.646]                             else {
[17:04:23.646]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.646]                                 info, version)
[17:04:23.646]                             }
[17:04:23.646]                             base::stop(msg)
[17:04:23.646]                           }
[17:04:23.646]                         })
[17:04:23.646]                       }
[17:04:23.646]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.646]                       base::options(mc.cores = 1L)
[17:04:23.646]                     }
[17:04:23.646]                     base::local({
[17:04:23.646]                       for (pkg in "utils") {
[17:04:23.646]                         base::loadNamespace(pkg)
[17:04:23.646]                         base::library(pkg, character.only = TRUE)
[17:04:23.646]                       }
[17:04:23.646]                     })
[17:04:23.646]                   }
[17:04:23.646]                   ...future.strategy.old <- future::plan("list")
[17:04:23.646]                   options(future.plan = NULL)
[17:04:23.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.646]                 }
[17:04:23.646]                 ...future.workdir <- getwd()
[17:04:23.646]             }
[17:04:23.646]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.646]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.646]         }
[17:04:23.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.646]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.646]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.646]             base::names(...future.oldOptions))
[17:04:23.646]     }
[17:04:23.646]     if (FALSE) {
[17:04:23.646]     }
[17:04:23.646]     else {
[17:04:23.646]         if (TRUE) {
[17:04:23.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.646]                 open = "w")
[17:04:23.646]         }
[17:04:23.646]         else {
[17:04:23.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.646]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.646]         }
[17:04:23.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.646]             base::sink(type = "output", split = FALSE)
[17:04:23.646]             base::close(...future.stdout)
[17:04:23.646]         }, add = TRUE)
[17:04:23.646]     }
[17:04:23.646]     ...future.frame <- base::sys.nframe()
[17:04:23.646]     ...future.conditions <- base::list()
[17:04:23.646]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.646]     if (FALSE) {
[17:04:23.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.646]     }
[17:04:23.646]     ...future.result <- base::tryCatch({
[17:04:23.646]         base::withCallingHandlers({
[17:04:23.646]             ...future.value <- base::withVisible(base::local({
[17:04:23.646]                 withCallingHandlers({
[17:04:23.646]                   {
[17:04:23.646]                     print(1:50)
[17:04:23.646]                     str(1:50)
[17:04:23.646]                     cat(letters, sep = "-")
[17:04:23.646]                     cat(1:6, collapse = "\n")
[17:04:23.646]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.646]                     42L
[17:04:23.646]                   }
[17:04:23.646]                 }, immediateCondition = function(cond) {
[17:04:23.646]                   save_rds <- function (object, pathname, ...) 
[17:04:23.646]                   {
[17:04:23.646]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.646]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.646]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.646]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.646]                         fi_tmp[["mtime"]])
[17:04:23.646]                     }
[17:04:23.646]                     tryCatch({
[17:04:23.646]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.646]                     }, error = function(ex) {
[17:04:23.646]                       msg <- conditionMessage(ex)
[17:04:23.646]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.646]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.646]                         fi_tmp[["mtime"]], msg)
[17:04:23.646]                       ex$message <- msg
[17:04:23.646]                       stop(ex)
[17:04:23.646]                     })
[17:04:23.646]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.646]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.646]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.646]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.646]                       fi <- file.info(pathname)
[17:04:23.646]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.646]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.646]                         fi[["size"]], fi[["mtime"]])
[17:04:23.646]                       stop(msg)
[17:04:23.646]                     }
[17:04:23.646]                     invisible(pathname)
[17:04:23.646]                   }
[17:04:23.646]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.646]                     rootPath = tempdir()) 
[17:04:23.646]                   {
[17:04:23.646]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.646]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.646]                       tmpdir = path, fileext = ".rds")
[17:04:23.646]                     save_rds(obj, file)
[17:04:23.646]                   }
[17:04:23.646]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.646]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.646]                   {
[17:04:23.646]                     inherits <- base::inherits
[17:04:23.646]                     invokeRestart <- base::invokeRestart
[17:04:23.646]                     is.null <- base::is.null
[17:04:23.646]                     muffled <- FALSE
[17:04:23.646]                     if (inherits(cond, "message")) {
[17:04:23.646]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.646]                       if (muffled) 
[17:04:23.646]                         invokeRestart("muffleMessage")
[17:04:23.646]                     }
[17:04:23.646]                     else if (inherits(cond, "warning")) {
[17:04:23.646]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.646]                       if (muffled) 
[17:04:23.646]                         invokeRestart("muffleWarning")
[17:04:23.646]                     }
[17:04:23.646]                     else if (inherits(cond, "condition")) {
[17:04:23.646]                       if (!is.null(pattern)) {
[17:04:23.646]                         computeRestarts <- base::computeRestarts
[17:04:23.646]                         grepl <- base::grepl
[17:04:23.646]                         restarts <- computeRestarts(cond)
[17:04:23.646]                         for (restart in restarts) {
[17:04:23.646]                           name <- restart$name
[17:04:23.646]                           if (is.null(name)) 
[17:04:23.646]                             next
[17:04:23.646]                           if (!grepl(pattern, name)) 
[17:04:23.646]                             next
[17:04:23.646]                           invokeRestart(restart)
[17:04:23.646]                           muffled <- TRUE
[17:04:23.646]                           break
[17:04:23.646]                         }
[17:04:23.646]                       }
[17:04:23.646]                     }
[17:04:23.646]                     invisible(muffled)
[17:04:23.646]                   }
[17:04:23.646]                   muffleCondition(cond)
[17:04:23.646]                 })
[17:04:23.646]             }))
[17:04:23.646]             future::FutureResult(value = ...future.value$value, 
[17:04:23.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.646]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.646]                     ...future.globalenv.names))
[17:04:23.646]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.646]         }, condition = base::local({
[17:04:23.646]             c <- base::c
[17:04:23.646]             inherits <- base::inherits
[17:04:23.646]             invokeRestart <- base::invokeRestart
[17:04:23.646]             length <- base::length
[17:04:23.646]             list <- base::list
[17:04:23.646]             seq.int <- base::seq.int
[17:04:23.646]             signalCondition <- base::signalCondition
[17:04:23.646]             sys.calls <- base::sys.calls
[17:04:23.646]             `[[` <- base::`[[`
[17:04:23.646]             `+` <- base::`+`
[17:04:23.646]             `<<-` <- base::`<<-`
[17:04:23.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.646]                   3L)]
[17:04:23.646]             }
[17:04:23.646]             function(cond) {
[17:04:23.646]                 is_error <- inherits(cond, "error")
[17:04:23.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.646]                   NULL)
[17:04:23.646]                 if (is_error) {
[17:04:23.646]                   sessionInformation <- function() {
[17:04:23.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.646]                       search = base::search(), system = base::Sys.info())
[17:04:23.646]                   }
[17:04:23.646]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.646]                     cond$call), session = sessionInformation(), 
[17:04:23.646]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.646]                   signalCondition(cond)
[17:04:23.646]                 }
[17:04:23.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.646]                 "immediateCondition"))) {
[17:04:23.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.646]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.646]                   if (TRUE && !signal) {
[17:04:23.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.646]                     {
[17:04:23.646]                       inherits <- base::inherits
[17:04:23.646]                       invokeRestart <- base::invokeRestart
[17:04:23.646]                       is.null <- base::is.null
[17:04:23.646]                       muffled <- FALSE
[17:04:23.646]                       if (inherits(cond, "message")) {
[17:04:23.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.646]                         if (muffled) 
[17:04:23.646]                           invokeRestart("muffleMessage")
[17:04:23.646]                       }
[17:04:23.646]                       else if (inherits(cond, "warning")) {
[17:04:23.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.646]                         if (muffled) 
[17:04:23.646]                           invokeRestart("muffleWarning")
[17:04:23.646]                       }
[17:04:23.646]                       else if (inherits(cond, "condition")) {
[17:04:23.646]                         if (!is.null(pattern)) {
[17:04:23.646]                           computeRestarts <- base::computeRestarts
[17:04:23.646]                           grepl <- base::grepl
[17:04:23.646]                           restarts <- computeRestarts(cond)
[17:04:23.646]                           for (restart in restarts) {
[17:04:23.646]                             name <- restart$name
[17:04:23.646]                             if (is.null(name)) 
[17:04:23.646]                               next
[17:04:23.646]                             if (!grepl(pattern, name)) 
[17:04:23.646]                               next
[17:04:23.646]                             invokeRestart(restart)
[17:04:23.646]                             muffled <- TRUE
[17:04:23.646]                             break
[17:04:23.646]                           }
[17:04:23.646]                         }
[17:04:23.646]                       }
[17:04:23.646]                       invisible(muffled)
[17:04:23.646]                     }
[17:04:23.646]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.646]                   }
[17:04:23.646]                 }
[17:04:23.646]                 else {
[17:04:23.646]                   if (TRUE) {
[17:04:23.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.646]                     {
[17:04:23.646]                       inherits <- base::inherits
[17:04:23.646]                       invokeRestart <- base::invokeRestart
[17:04:23.646]                       is.null <- base::is.null
[17:04:23.646]                       muffled <- FALSE
[17:04:23.646]                       if (inherits(cond, "message")) {
[17:04:23.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.646]                         if (muffled) 
[17:04:23.646]                           invokeRestart("muffleMessage")
[17:04:23.646]                       }
[17:04:23.646]                       else if (inherits(cond, "warning")) {
[17:04:23.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.646]                         if (muffled) 
[17:04:23.646]                           invokeRestart("muffleWarning")
[17:04:23.646]                       }
[17:04:23.646]                       else if (inherits(cond, "condition")) {
[17:04:23.646]                         if (!is.null(pattern)) {
[17:04:23.646]                           computeRestarts <- base::computeRestarts
[17:04:23.646]                           grepl <- base::grepl
[17:04:23.646]                           restarts <- computeRestarts(cond)
[17:04:23.646]                           for (restart in restarts) {
[17:04:23.646]                             name <- restart$name
[17:04:23.646]                             if (is.null(name)) 
[17:04:23.646]                               next
[17:04:23.646]                             if (!grepl(pattern, name)) 
[17:04:23.646]                               next
[17:04:23.646]                             invokeRestart(restart)
[17:04:23.646]                             muffled <- TRUE
[17:04:23.646]                             break
[17:04:23.646]                           }
[17:04:23.646]                         }
[17:04:23.646]                       }
[17:04:23.646]                       invisible(muffled)
[17:04:23.646]                     }
[17:04:23.646]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.646]                   }
[17:04:23.646]                 }
[17:04:23.646]             }
[17:04:23.646]         }))
[17:04:23.646]     }, error = function(ex) {
[17:04:23.646]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.646]                 ...future.rng), started = ...future.startTime, 
[17:04:23.646]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.646]             version = "1.8"), class = "FutureResult")
[17:04:23.646]     }, finally = {
[17:04:23.646]         if (!identical(...future.workdir, getwd())) 
[17:04:23.646]             setwd(...future.workdir)
[17:04:23.646]         {
[17:04:23.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.646]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.646]             }
[17:04:23.646]             base::options(...future.oldOptions)
[17:04:23.646]             if (.Platform$OS.type == "windows") {
[17:04:23.646]                 old_names <- names(...future.oldEnvVars)
[17:04:23.646]                 envs <- base::Sys.getenv()
[17:04:23.646]                 names <- names(envs)
[17:04:23.646]                 common <- intersect(names, old_names)
[17:04:23.646]                 added <- setdiff(names, old_names)
[17:04:23.646]                 removed <- setdiff(old_names, names)
[17:04:23.646]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.646]                   envs[common]]
[17:04:23.646]                 NAMES <- toupper(changed)
[17:04:23.646]                 args <- list()
[17:04:23.646]                 for (kk in seq_along(NAMES)) {
[17:04:23.646]                   name <- changed[[kk]]
[17:04:23.646]                   NAME <- NAMES[[kk]]
[17:04:23.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.646]                     next
[17:04:23.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.646]                 }
[17:04:23.646]                 NAMES <- toupper(added)
[17:04:23.646]                 for (kk in seq_along(NAMES)) {
[17:04:23.646]                   name <- added[[kk]]
[17:04:23.646]                   NAME <- NAMES[[kk]]
[17:04:23.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.646]                     next
[17:04:23.646]                   args[[name]] <- ""
[17:04:23.646]                 }
[17:04:23.646]                 NAMES <- toupper(removed)
[17:04:23.646]                 for (kk in seq_along(NAMES)) {
[17:04:23.646]                   name <- removed[[kk]]
[17:04:23.646]                   NAME <- NAMES[[kk]]
[17:04:23.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.646]                     next
[17:04:23.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.646]                 }
[17:04:23.646]                 if (length(args) > 0) 
[17:04:23.646]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.646]             }
[17:04:23.646]             else {
[17:04:23.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.646]             }
[17:04:23.646]             {
[17:04:23.646]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.646]                   0L) {
[17:04:23.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.646]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.646]                   base::options(opts)
[17:04:23.646]                 }
[17:04:23.646]                 {
[17:04:23.646]                   {
[17:04:23.646]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.646]                     NULL
[17:04:23.646]                   }
[17:04:23.646]                   options(future.plan = NULL)
[17:04:23.646]                   if (is.na(NA_character_)) 
[17:04:23.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.646]                     .init = FALSE)
[17:04:23.646]                 }
[17:04:23.646]             }
[17:04:23.646]         }
[17:04:23.646]     })
[17:04:23.646]     if (TRUE) {
[17:04:23.646]         base::sink(type = "output", split = FALSE)
[17:04:23.646]         if (TRUE) {
[17:04:23.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.646]         }
[17:04:23.646]         else {
[17:04:23.646]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.646]         }
[17:04:23.646]         base::close(...future.stdout)
[17:04:23.646]         ...future.stdout <- NULL
[17:04:23.646]     }
[17:04:23.646]     ...future.result$conditions <- ...future.conditions
[17:04:23.646]     ...future.result$finished <- base::Sys.time()
[17:04:23.646]     ...future.result
[17:04:23.646] }
[17:04:23.649] requestCore(): workers = 2
[17:04:23.652] MulticoreFuture started
[17:04:23.652] - Launch lazy future ... done
[17:04:23.652] run() for ‘MulticoreFuture’ ... done
[17:04:23.653] plan(): Setting new future strategy stack:
[17:04:23.653] result() for MulticoreFuture ...
[17:04:23.653] List of future strategies:
[17:04:23.653] 1. sequential:
[17:04:23.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.653]    - tweaked: FALSE
[17:04:23.653]    - call: NULL
[17:04:23.654] plan(): nbrOfWorkers() = 1
[17:04:23.658] plan(): Setting new future strategy stack:
[17:04:23.658] List of future strategies:
[17:04:23.658] 1. multicore:
[17:04:23.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.658]    - tweaked: FALSE
[17:04:23.658]    - call: plan(strategy)
[17:04:23.663] plan(): nbrOfWorkers() = 2
[17:04:23.668] result() for MulticoreFuture ...
[17:04:23.668] result() for MulticoreFuture ... done
[17:04:23.668] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ session_uuid: chr "788e4385-a8d0-6531-3c80-a526e104b624"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50449
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:23"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:23.678] result() for MulticoreFuture ...
[17:04:23.679] result() for MulticoreFuture ... done
[17:04:23.679] result() for MulticoreFuture ...
[17:04:23.679] result() for MulticoreFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.01208186 secs (started 2024-11-25 17:04:23.652125)
version: 1.8
[17:04:23.680] getGlobalsAndPackages() ...
[17:04:23.680] Searching for globals...
[17:04:23.684] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.684] Searching for globals ... DONE
[17:04:23.684] Resolving globals: FALSE
[17:04:23.685] 
[17:04:23.685] - packages: [1] ‘utils’
[17:04:23.685] getGlobalsAndPackages() ... DONE
[17:04:23.686] run() for ‘Future’ ...
[17:04:23.686] - state: ‘created’
[17:04:23.686] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.690] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.690] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.690]   - Field: ‘label’
[17:04:23.691]   - Field: ‘local’
[17:04:23.691]   - Field: ‘owner’
[17:04:23.691]   - Field: ‘envir’
[17:04:23.691]   - Field: ‘workers’
[17:04:23.691]   - Field: ‘packages’
[17:04:23.691]   - Field: ‘gc’
[17:04:23.694]   - Field: ‘job’
[17:04:23.694]   - Field: ‘conditions’
[17:04:23.694]   - Field: ‘expr’
[17:04:23.694]   - Field: ‘uuid’
[17:04:23.694]   - Field: ‘seed’
[17:04:23.694]   - Field: ‘version’
[17:04:23.695]   - Field: ‘result’
[17:04:23.695]   - Field: ‘asynchronous’
[17:04:23.695]   - Field: ‘calls’
[17:04:23.695]   - Field: ‘globals’
[17:04:23.695]   - Field: ‘stdout’
[17:04:23.695]   - Field: ‘earlySignal’
[17:04:23.695]   - Field: ‘lazy’
[17:04:23.696]   - Field: ‘state’
[17:04:23.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.696] - Launch lazy future ...
[17:04:23.696] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.696] Packages needed by future strategies (n = 0): <none>
[17:04:23.697] {
[17:04:23.697]     {
[17:04:23.697]         {
[17:04:23.697]             ...future.startTime <- base::Sys.time()
[17:04:23.697]             {
[17:04:23.697]                 {
[17:04:23.697]                   {
[17:04:23.697]                     {
[17:04:23.697]                       {
[17:04:23.697]                         base::local({
[17:04:23.697]                           has_future <- base::requireNamespace("future", 
[17:04:23.697]                             quietly = TRUE)
[17:04:23.697]                           if (has_future) {
[17:04:23.697]                             ns <- base::getNamespace("future")
[17:04:23.697]                             version <- ns[[".package"]][["version"]]
[17:04:23.697]                             if (is.null(version)) 
[17:04:23.697]                               version <- utils::packageVersion("future")
[17:04:23.697]                           }
[17:04:23.697]                           else {
[17:04:23.697]                             version <- NULL
[17:04:23.697]                           }
[17:04:23.697]                           if (!has_future || version < "1.8.0") {
[17:04:23.697]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.697]                               "", base::R.version$version.string), 
[17:04:23.697]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:23.697]                                 base::R.version$platform, 8 * 
[17:04:23.697]                                   base::.Machine$sizeof.pointer), 
[17:04:23.697]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.697]                                 "release", "version")], collapse = " "), 
[17:04:23.697]                               hostname = base::Sys.info()[["nodename"]])
[17:04:23.697]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.697]                               info)
[17:04:23.697]                             info <- base::paste(info, collapse = "; ")
[17:04:23.697]                             if (!has_future) {
[17:04:23.697]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.697]                                 info)
[17:04:23.697]                             }
[17:04:23.697]                             else {
[17:04:23.697]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.697]                                 info, version)
[17:04:23.697]                             }
[17:04:23.697]                             base::stop(msg)
[17:04:23.697]                           }
[17:04:23.697]                         })
[17:04:23.697]                       }
[17:04:23.697]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.697]                       base::options(mc.cores = 1L)
[17:04:23.697]                     }
[17:04:23.697]                     base::local({
[17:04:23.697]                       for (pkg in "utils") {
[17:04:23.697]                         base::loadNamespace(pkg)
[17:04:23.697]                         base::library(pkg, character.only = TRUE)
[17:04:23.697]                       }
[17:04:23.697]                     })
[17:04:23.697]                   }
[17:04:23.697]                   ...future.strategy.old <- future::plan("list")
[17:04:23.697]                   options(future.plan = NULL)
[17:04:23.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.697]                 }
[17:04:23.697]                 ...future.workdir <- getwd()
[17:04:23.697]             }
[17:04:23.697]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.697]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.697]         }
[17:04:23.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.697]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.697]             base::names(...future.oldOptions))
[17:04:23.697]     }
[17:04:23.697]     if (FALSE) {
[17:04:23.697]     }
[17:04:23.697]     else {
[17:04:23.697]         if (TRUE) {
[17:04:23.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.697]                 open = "w")
[17:04:23.697]         }
[17:04:23.697]         else {
[17:04:23.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.697]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.697]         }
[17:04:23.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.697]             base::sink(type = "output", split = FALSE)
[17:04:23.697]             base::close(...future.stdout)
[17:04:23.697]         }, add = TRUE)
[17:04:23.697]     }
[17:04:23.697]     ...future.frame <- base::sys.nframe()
[17:04:23.697]     ...future.conditions <- base::list()
[17:04:23.697]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.697]     if (FALSE) {
[17:04:23.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.697]     }
[17:04:23.697]     ...future.result <- base::tryCatch({
[17:04:23.697]         base::withCallingHandlers({
[17:04:23.697]             ...future.value <- base::withVisible(base::local({
[17:04:23.697]                 withCallingHandlers({
[17:04:23.697]                   {
[17:04:23.697]                     print(1:50)
[17:04:23.697]                     str(1:50)
[17:04:23.697]                     cat(letters, sep = "-")
[17:04:23.697]                     cat(1:6, collapse = "\n")
[17:04:23.697]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.697]                     42L
[17:04:23.697]                   }
[17:04:23.697]                 }, immediateCondition = function(cond) {
[17:04:23.697]                   save_rds <- function (object, pathname, ...) 
[17:04:23.697]                   {
[17:04:23.697]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.697]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.697]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.697]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.697]                         fi_tmp[["mtime"]])
[17:04:23.697]                     }
[17:04:23.697]                     tryCatch({
[17:04:23.697]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.697]                     }, error = function(ex) {
[17:04:23.697]                       msg <- conditionMessage(ex)
[17:04:23.697]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.697]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.697]                         fi_tmp[["mtime"]], msg)
[17:04:23.697]                       ex$message <- msg
[17:04:23.697]                       stop(ex)
[17:04:23.697]                     })
[17:04:23.697]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.697]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.697]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.697]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.697]                       fi <- file.info(pathname)
[17:04:23.697]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.697]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.697]                         fi[["size"]], fi[["mtime"]])
[17:04:23.697]                       stop(msg)
[17:04:23.697]                     }
[17:04:23.697]                     invisible(pathname)
[17:04:23.697]                   }
[17:04:23.697]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.697]                     rootPath = tempdir()) 
[17:04:23.697]                   {
[17:04:23.697]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.697]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.697]                       tmpdir = path, fileext = ".rds")
[17:04:23.697]                     save_rds(obj, file)
[17:04:23.697]                   }
[17:04:23.697]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.697]                   {
[17:04:23.697]                     inherits <- base::inherits
[17:04:23.697]                     invokeRestart <- base::invokeRestart
[17:04:23.697]                     is.null <- base::is.null
[17:04:23.697]                     muffled <- FALSE
[17:04:23.697]                     if (inherits(cond, "message")) {
[17:04:23.697]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.697]                       if (muffled) 
[17:04:23.697]                         invokeRestart("muffleMessage")
[17:04:23.697]                     }
[17:04:23.697]                     else if (inherits(cond, "warning")) {
[17:04:23.697]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.697]                       if (muffled) 
[17:04:23.697]                         invokeRestart("muffleWarning")
[17:04:23.697]                     }
[17:04:23.697]                     else if (inherits(cond, "condition")) {
[17:04:23.697]                       if (!is.null(pattern)) {
[17:04:23.697]                         computeRestarts <- base::computeRestarts
[17:04:23.697]                         grepl <- base::grepl
[17:04:23.697]                         restarts <- computeRestarts(cond)
[17:04:23.697]                         for (restart in restarts) {
[17:04:23.697]                           name <- restart$name
[17:04:23.697]                           if (is.null(name)) 
[17:04:23.697]                             next
[17:04:23.697]                           if (!grepl(pattern, name)) 
[17:04:23.697]                             next
[17:04:23.697]                           invokeRestart(restart)
[17:04:23.697]                           muffled <- TRUE
[17:04:23.697]                           break
[17:04:23.697]                         }
[17:04:23.697]                       }
[17:04:23.697]                     }
[17:04:23.697]                     invisible(muffled)
[17:04:23.697]                   }
[17:04:23.697]                   muffleCondition(cond)
[17:04:23.697]                 })
[17:04:23.697]             }))
[17:04:23.697]             future::FutureResult(value = ...future.value$value, 
[17:04:23.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.697]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.697]                     ...future.globalenv.names))
[17:04:23.697]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.697]         }, condition = base::local({
[17:04:23.697]             c <- base::c
[17:04:23.697]             inherits <- base::inherits
[17:04:23.697]             invokeRestart <- base::invokeRestart
[17:04:23.697]             length <- base::length
[17:04:23.697]             list <- base::list
[17:04:23.697]             seq.int <- base::seq.int
[17:04:23.697]             signalCondition <- base::signalCondition
[17:04:23.697]             sys.calls <- base::sys.calls
[17:04:23.697]             `[[` <- base::`[[`
[17:04:23.697]             `+` <- base::`+`
[17:04:23.697]             `<<-` <- base::`<<-`
[17:04:23.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.697]                   3L)]
[17:04:23.697]             }
[17:04:23.697]             function(cond) {
[17:04:23.697]                 is_error <- inherits(cond, "error")
[17:04:23.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.697]                   NULL)
[17:04:23.697]                 if (is_error) {
[17:04:23.697]                   sessionInformation <- function() {
[17:04:23.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.697]                       search = base::search(), system = base::Sys.info())
[17:04:23.697]                   }
[17:04:23.697]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.697]                     cond$call), session = sessionInformation(), 
[17:04:23.697]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.697]                   signalCondition(cond)
[17:04:23.697]                 }
[17:04:23.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.697]                 "immediateCondition"))) {
[17:04:23.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.697]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.697]                   if (TRUE && !signal) {
[17:04:23.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.697]                     {
[17:04:23.697]                       inherits <- base::inherits
[17:04:23.697]                       invokeRestart <- base::invokeRestart
[17:04:23.697]                       is.null <- base::is.null
[17:04:23.697]                       muffled <- FALSE
[17:04:23.697]                       if (inherits(cond, "message")) {
[17:04:23.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.697]                         if (muffled) 
[17:04:23.697]                           invokeRestart("muffleMessage")
[17:04:23.697]                       }
[17:04:23.697]                       else if (inherits(cond, "warning")) {
[17:04:23.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.697]                         if (muffled) 
[17:04:23.697]                           invokeRestart("muffleWarning")
[17:04:23.697]                       }
[17:04:23.697]                       else if (inherits(cond, "condition")) {
[17:04:23.697]                         if (!is.null(pattern)) {
[17:04:23.697]                           computeRestarts <- base::computeRestarts
[17:04:23.697]                           grepl <- base::grepl
[17:04:23.697]                           restarts <- computeRestarts(cond)
[17:04:23.697]                           for (restart in restarts) {
[17:04:23.697]                             name <- restart$name
[17:04:23.697]                             if (is.null(name)) 
[17:04:23.697]                               next
[17:04:23.697]                             if (!grepl(pattern, name)) 
[17:04:23.697]                               next
[17:04:23.697]                             invokeRestart(restart)
[17:04:23.697]                             muffled <- TRUE
[17:04:23.697]                             break
[17:04:23.697]                           }
[17:04:23.697]                         }
[17:04:23.697]                       }
[17:04:23.697]                       invisible(muffled)
[17:04:23.697]                     }
[17:04:23.697]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.697]                   }
[17:04:23.697]                 }
[17:04:23.697]                 else {
[17:04:23.697]                   if (TRUE) {
[17:04:23.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.697]                     {
[17:04:23.697]                       inherits <- base::inherits
[17:04:23.697]                       invokeRestart <- base::invokeRestart
[17:04:23.697]                       is.null <- base::is.null
[17:04:23.697]                       muffled <- FALSE
[17:04:23.697]                       if (inherits(cond, "message")) {
[17:04:23.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.697]                         if (muffled) 
[17:04:23.697]                           invokeRestart("muffleMessage")
[17:04:23.697]                       }
[17:04:23.697]                       else if (inherits(cond, "warning")) {
[17:04:23.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.697]                         if (muffled) 
[17:04:23.697]                           invokeRestart("muffleWarning")
[17:04:23.697]                       }
[17:04:23.697]                       else if (inherits(cond, "condition")) {
[17:04:23.697]                         if (!is.null(pattern)) {
[17:04:23.697]                           computeRestarts <- base::computeRestarts
[17:04:23.697]                           grepl <- base::grepl
[17:04:23.697]                           restarts <- computeRestarts(cond)
[17:04:23.697]                           for (restart in restarts) {
[17:04:23.697]                             name <- restart$name
[17:04:23.697]                             if (is.null(name)) 
[17:04:23.697]                               next
[17:04:23.697]                             if (!grepl(pattern, name)) 
[17:04:23.697]                               next
[17:04:23.697]                             invokeRestart(restart)
[17:04:23.697]                             muffled <- TRUE
[17:04:23.697]                             break
[17:04:23.697]                           }
[17:04:23.697]                         }
[17:04:23.697]                       }
[17:04:23.697]                       invisible(muffled)
[17:04:23.697]                     }
[17:04:23.697]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.697]                   }
[17:04:23.697]                 }
[17:04:23.697]             }
[17:04:23.697]         }))
[17:04:23.697]     }, error = function(ex) {
[17:04:23.697]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.697]                 ...future.rng), started = ...future.startTime, 
[17:04:23.697]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.697]             version = "1.8"), class = "FutureResult")
[17:04:23.697]     }, finally = {
[17:04:23.697]         if (!identical(...future.workdir, getwd())) 
[17:04:23.697]             setwd(...future.workdir)
[17:04:23.697]         {
[17:04:23.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.697]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.697]             }
[17:04:23.697]             base::options(...future.oldOptions)
[17:04:23.697]             if (.Platform$OS.type == "windows") {
[17:04:23.697]                 old_names <- names(...future.oldEnvVars)
[17:04:23.697]                 envs <- base::Sys.getenv()
[17:04:23.697]                 names <- names(envs)
[17:04:23.697]                 common <- intersect(names, old_names)
[17:04:23.697]                 added <- setdiff(names, old_names)
[17:04:23.697]                 removed <- setdiff(old_names, names)
[17:04:23.697]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.697]                   envs[common]]
[17:04:23.697]                 NAMES <- toupper(changed)
[17:04:23.697]                 args <- list()
[17:04:23.697]                 for (kk in seq_along(NAMES)) {
[17:04:23.697]                   name <- changed[[kk]]
[17:04:23.697]                   NAME <- NAMES[[kk]]
[17:04:23.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.697]                     next
[17:04:23.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.697]                 }
[17:04:23.697]                 NAMES <- toupper(added)
[17:04:23.697]                 for (kk in seq_along(NAMES)) {
[17:04:23.697]                   name <- added[[kk]]
[17:04:23.697]                   NAME <- NAMES[[kk]]
[17:04:23.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.697]                     next
[17:04:23.697]                   args[[name]] <- ""
[17:04:23.697]                 }
[17:04:23.697]                 NAMES <- toupper(removed)
[17:04:23.697]                 for (kk in seq_along(NAMES)) {
[17:04:23.697]                   name <- removed[[kk]]
[17:04:23.697]                   NAME <- NAMES[[kk]]
[17:04:23.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.697]                     next
[17:04:23.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.697]                 }
[17:04:23.697]                 if (length(args) > 0) 
[17:04:23.697]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.697]             }
[17:04:23.697]             else {
[17:04:23.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.697]             }
[17:04:23.697]             {
[17:04:23.697]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.697]                   0L) {
[17:04:23.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.697]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.697]                   base::options(opts)
[17:04:23.697]                 }
[17:04:23.697]                 {
[17:04:23.697]                   {
[17:04:23.697]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.697]                     NULL
[17:04:23.697]                   }
[17:04:23.697]                   options(future.plan = NULL)
[17:04:23.697]                   if (is.na(NA_character_)) 
[17:04:23.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.697]                     .init = FALSE)
[17:04:23.697]                 }
[17:04:23.697]             }
[17:04:23.697]         }
[17:04:23.697]     })
[17:04:23.697]     if (TRUE) {
[17:04:23.697]         base::sink(type = "output", split = FALSE)
[17:04:23.697]         if (TRUE) {
[17:04:23.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.697]         }
[17:04:23.697]         else {
[17:04:23.697]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.697]         }
[17:04:23.697]         base::close(...future.stdout)
[17:04:23.697]         ...future.stdout <- NULL
[17:04:23.697]     }
[17:04:23.697]     ...future.result$conditions <- ...future.conditions
[17:04:23.697]     ...future.result$finished <- base::Sys.time()
[17:04:23.697]     ...future.result
[17:04:23.697] }
[17:04:23.700] requestCore(): workers = 2
[17:04:23.702] MulticoreFuture started
[17:04:23.702] - Launch lazy future ... done
[17:04:23.702] run() for ‘MulticoreFuture’ ... done
[17:04:23.703] result() for MulticoreFuture ...
[17:04:23.703] plan(): Setting new future strategy stack:
[17:04:23.704] List of future strategies:
[17:04:23.704] 1. sequential:
[17:04:23.704]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.704]    - tweaked: FALSE
[17:04:23.704]    - call: NULL
[17:04:23.705] plan(): nbrOfWorkers() = 1
[17:04:23.708] plan(): Setting new future strategy stack:
[17:04:23.708] List of future strategies:
[17:04:23.708] 1. multicore:
[17:04:23.708]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.708]    - tweaked: FALSE
[17:04:23.708]    - call: plan(strategy)
[17:04:23.713] plan(): nbrOfWorkers() = 2
[17:04:23.714] result() for MulticoreFuture ...
[17:04:23.714] result() for MulticoreFuture ... done
[17:04:23.715] result() for MulticoreFuture ... done
[17:04:23.715] result() for MulticoreFuture ...
[17:04:23.715] result() for MulticoreFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:04:23.716] getGlobalsAndPackages() ...
[17:04:23.716] Searching for globals...
[17:04:23.717] - globals found: [1] ‘print’
[17:04:23.717] Searching for globals ... DONE
[17:04:23.717] Resolving globals: FALSE
[17:04:23.717] 
[17:04:23.718] 
[17:04:23.718] getGlobalsAndPackages() ... DONE
[17:04:23.718] run() for ‘Future’ ...
[17:04:23.718] - state: ‘created’
[17:04:23.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.723] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.723]   - Field: ‘label’
[17:04:23.723]   - Field: ‘local’
[17:04:23.723]   - Field: ‘owner’
[17:04:23.723]   - Field: ‘envir’
[17:04:23.723]   - Field: ‘workers’
[17:04:23.724]   - Field: ‘packages’
[17:04:23.724]   - Field: ‘gc’
[17:04:23.724]   - Field: ‘job’
[17:04:23.724]   - Field: ‘conditions’
[17:04:23.724]   - Field: ‘expr’
[17:04:23.724]   - Field: ‘uuid’
[17:04:23.724]   - Field: ‘seed’
[17:04:23.724]   - Field: ‘version’
[17:04:23.724]   - Field: ‘result’
[17:04:23.725]   - Field: ‘asynchronous’
[17:04:23.725]   - Field: ‘calls’
[17:04:23.725]   - Field: ‘globals’
[17:04:23.725]   - Field: ‘stdout’
[17:04:23.725]   - Field: ‘earlySignal’
[17:04:23.725]   - Field: ‘lazy’
[17:04:23.725]   - Field: ‘state’
[17:04:23.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.725] - Launch lazy future ...
[17:04:23.726] Packages needed by the future expression (n = 0): <none>
[17:04:23.726] Packages needed by future strategies (n = 0): <none>
[17:04:23.727] {
[17:04:23.727]     {
[17:04:23.727]         {
[17:04:23.727]             ...future.startTime <- base::Sys.time()
[17:04:23.727]             {
[17:04:23.727]                 {
[17:04:23.727]                   {
[17:04:23.727]                     {
[17:04:23.727]                       base::local({
[17:04:23.727]                         has_future <- base::requireNamespace("future", 
[17:04:23.727]                           quietly = TRUE)
[17:04:23.727]                         if (has_future) {
[17:04:23.727]                           ns <- base::getNamespace("future")
[17:04:23.727]                           version <- ns[[".package"]][["version"]]
[17:04:23.727]                           if (is.null(version)) 
[17:04:23.727]                             version <- utils::packageVersion("future")
[17:04:23.727]                         }
[17:04:23.727]                         else {
[17:04:23.727]                           version <- NULL
[17:04:23.727]                         }
[17:04:23.727]                         if (!has_future || version < "1.8.0") {
[17:04:23.727]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.727]                             "", base::R.version$version.string), 
[17:04:23.727]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.727]                               "release", "version")], collapse = " "), 
[17:04:23.727]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.727]                             info)
[17:04:23.727]                           info <- base::paste(info, collapse = "; ")
[17:04:23.727]                           if (!has_future) {
[17:04:23.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.727]                               info)
[17:04:23.727]                           }
[17:04:23.727]                           else {
[17:04:23.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.727]                               info, version)
[17:04:23.727]                           }
[17:04:23.727]                           base::stop(msg)
[17:04:23.727]                         }
[17:04:23.727]                       })
[17:04:23.727]                     }
[17:04:23.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.727]                     base::options(mc.cores = 1L)
[17:04:23.727]                   }
[17:04:23.727]                   ...future.strategy.old <- future::plan("list")
[17:04:23.727]                   options(future.plan = NULL)
[17:04:23.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.727]                 }
[17:04:23.727]                 ...future.workdir <- getwd()
[17:04:23.727]             }
[17:04:23.727]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.727]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.727]         }
[17:04:23.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.727]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.727]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.727]             base::names(...future.oldOptions))
[17:04:23.727]     }
[17:04:23.727]     if (FALSE) {
[17:04:23.727]     }
[17:04:23.727]     else {
[17:04:23.727]         if (TRUE) {
[17:04:23.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.727]                 open = "w")
[17:04:23.727]         }
[17:04:23.727]         else {
[17:04:23.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.727]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.727]         }
[17:04:23.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.727]             base::sink(type = "output", split = FALSE)
[17:04:23.727]             base::close(...future.stdout)
[17:04:23.727]         }, add = TRUE)
[17:04:23.727]     }
[17:04:23.727]     ...future.frame <- base::sys.nframe()
[17:04:23.727]     ...future.conditions <- base::list()
[17:04:23.727]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.727]     if (FALSE) {
[17:04:23.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.727]     }
[17:04:23.727]     ...future.result <- base::tryCatch({
[17:04:23.727]         base::withCallingHandlers({
[17:04:23.727]             ...future.value <- base::withVisible(base::local({
[17:04:23.727]                 withCallingHandlers({
[17:04:23.727]                   print(42)
[17:04:23.727]                 }, immediateCondition = function(cond) {
[17:04:23.727]                   save_rds <- function (object, pathname, ...) 
[17:04:23.727]                   {
[17:04:23.727]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.727]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.727]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.727]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.727]                         fi_tmp[["mtime"]])
[17:04:23.727]                     }
[17:04:23.727]                     tryCatch({
[17:04:23.727]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.727]                     }, error = function(ex) {
[17:04:23.727]                       msg <- conditionMessage(ex)
[17:04:23.727]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.727]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.727]                         fi_tmp[["mtime"]], msg)
[17:04:23.727]                       ex$message <- msg
[17:04:23.727]                       stop(ex)
[17:04:23.727]                     })
[17:04:23.727]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.727]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.727]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.727]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.727]                       fi <- file.info(pathname)
[17:04:23.727]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.727]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.727]                         fi[["size"]], fi[["mtime"]])
[17:04:23.727]                       stop(msg)
[17:04:23.727]                     }
[17:04:23.727]                     invisible(pathname)
[17:04:23.727]                   }
[17:04:23.727]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.727]                     rootPath = tempdir()) 
[17:04:23.727]                   {
[17:04:23.727]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.727]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.727]                       tmpdir = path, fileext = ".rds")
[17:04:23.727]                     save_rds(obj, file)
[17:04:23.727]                   }
[17:04:23.727]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.727]                   {
[17:04:23.727]                     inherits <- base::inherits
[17:04:23.727]                     invokeRestart <- base::invokeRestart
[17:04:23.727]                     is.null <- base::is.null
[17:04:23.727]                     muffled <- FALSE
[17:04:23.727]                     if (inherits(cond, "message")) {
[17:04:23.727]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.727]                       if (muffled) 
[17:04:23.727]                         invokeRestart("muffleMessage")
[17:04:23.727]                     }
[17:04:23.727]                     else if (inherits(cond, "warning")) {
[17:04:23.727]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.727]                       if (muffled) 
[17:04:23.727]                         invokeRestart("muffleWarning")
[17:04:23.727]                     }
[17:04:23.727]                     else if (inherits(cond, "condition")) {
[17:04:23.727]                       if (!is.null(pattern)) {
[17:04:23.727]                         computeRestarts <- base::computeRestarts
[17:04:23.727]                         grepl <- base::grepl
[17:04:23.727]                         restarts <- computeRestarts(cond)
[17:04:23.727]                         for (restart in restarts) {
[17:04:23.727]                           name <- restart$name
[17:04:23.727]                           if (is.null(name)) 
[17:04:23.727]                             next
[17:04:23.727]                           if (!grepl(pattern, name)) 
[17:04:23.727]                             next
[17:04:23.727]                           invokeRestart(restart)
[17:04:23.727]                           muffled <- TRUE
[17:04:23.727]                           break
[17:04:23.727]                         }
[17:04:23.727]                       }
[17:04:23.727]                     }
[17:04:23.727]                     invisible(muffled)
[17:04:23.727]                   }
[17:04:23.727]                   muffleCondition(cond)
[17:04:23.727]                 })
[17:04:23.727]             }))
[17:04:23.727]             future::FutureResult(value = ...future.value$value, 
[17:04:23.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.727]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.727]                     ...future.globalenv.names))
[17:04:23.727]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.727]         }, condition = base::local({
[17:04:23.727]             c <- base::c
[17:04:23.727]             inherits <- base::inherits
[17:04:23.727]             invokeRestart <- base::invokeRestart
[17:04:23.727]             length <- base::length
[17:04:23.727]             list <- base::list
[17:04:23.727]             seq.int <- base::seq.int
[17:04:23.727]             signalCondition <- base::signalCondition
[17:04:23.727]             sys.calls <- base::sys.calls
[17:04:23.727]             `[[` <- base::`[[`
[17:04:23.727]             `+` <- base::`+`
[17:04:23.727]             `<<-` <- base::`<<-`
[17:04:23.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.727]                   3L)]
[17:04:23.727]             }
[17:04:23.727]             function(cond) {
[17:04:23.727]                 is_error <- inherits(cond, "error")
[17:04:23.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.727]                   NULL)
[17:04:23.727]                 if (is_error) {
[17:04:23.727]                   sessionInformation <- function() {
[17:04:23.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.727]                       search = base::search(), system = base::Sys.info())
[17:04:23.727]                   }
[17:04:23.727]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.727]                     cond$call), session = sessionInformation(), 
[17:04:23.727]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.727]                   signalCondition(cond)
[17:04:23.727]                 }
[17:04:23.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.727]                 "immediateCondition"))) {
[17:04:23.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.727]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.727]                   if (TRUE && !signal) {
[17:04:23.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.727]                     {
[17:04:23.727]                       inherits <- base::inherits
[17:04:23.727]                       invokeRestart <- base::invokeRestart
[17:04:23.727]                       is.null <- base::is.null
[17:04:23.727]                       muffled <- FALSE
[17:04:23.727]                       if (inherits(cond, "message")) {
[17:04:23.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.727]                         if (muffled) 
[17:04:23.727]                           invokeRestart("muffleMessage")
[17:04:23.727]                       }
[17:04:23.727]                       else if (inherits(cond, "warning")) {
[17:04:23.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.727]                         if (muffled) 
[17:04:23.727]                           invokeRestart("muffleWarning")
[17:04:23.727]                       }
[17:04:23.727]                       else if (inherits(cond, "condition")) {
[17:04:23.727]                         if (!is.null(pattern)) {
[17:04:23.727]                           computeRestarts <- base::computeRestarts
[17:04:23.727]                           grepl <- base::grepl
[17:04:23.727]                           restarts <- computeRestarts(cond)
[17:04:23.727]                           for (restart in restarts) {
[17:04:23.727]                             name <- restart$name
[17:04:23.727]                             if (is.null(name)) 
[17:04:23.727]                               next
[17:04:23.727]                             if (!grepl(pattern, name)) 
[17:04:23.727]                               next
[17:04:23.727]                             invokeRestart(restart)
[17:04:23.727]                             muffled <- TRUE
[17:04:23.727]                             break
[17:04:23.727]                           }
[17:04:23.727]                         }
[17:04:23.727]                       }
[17:04:23.727]                       invisible(muffled)
[17:04:23.727]                     }
[17:04:23.727]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.727]                   }
[17:04:23.727]                 }
[17:04:23.727]                 else {
[17:04:23.727]                   if (TRUE) {
[17:04:23.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.727]                     {
[17:04:23.727]                       inherits <- base::inherits
[17:04:23.727]                       invokeRestart <- base::invokeRestart
[17:04:23.727]                       is.null <- base::is.null
[17:04:23.727]                       muffled <- FALSE
[17:04:23.727]                       if (inherits(cond, "message")) {
[17:04:23.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.727]                         if (muffled) 
[17:04:23.727]                           invokeRestart("muffleMessage")
[17:04:23.727]                       }
[17:04:23.727]                       else if (inherits(cond, "warning")) {
[17:04:23.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.727]                         if (muffled) 
[17:04:23.727]                           invokeRestart("muffleWarning")
[17:04:23.727]                       }
[17:04:23.727]                       else if (inherits(cond, "condition")) {
[17:04:23.727]                         if (!is.null(pattern)) {
[17:04:23.727]                           computeRestarts <- base::computeRestarts
[17:04:23.727]                           grepl <- base::grepl
[17:04:23.727]                           restarts <- computeRestarts(cond)
[17:04:23.727]                           for (restart in restarts) {
[17:04:23.727]                             name <- restart$name
[17:04:23.727]                             if (is.null(name)) 
[17:04:23.727]                               next
[17:04:23.727]                             if (!grepl(pattern, name)) 
[17:04:23.727]                               next
[17:04:23.727]                             invokeRestart(restart)
[17:04:23.727]                             muffled <- TRUE
[17:04:23.727]                             break
[17:04:23.727]                           }
[17:04:23.727]                         }
[17:04:23.727]                       }
[17:04:23.727]                       invisible(muffled)
[17:04:23.727]                     }
[17:04:23.727]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.727]                   }
[17:04:23.727]                 }
[17:04:23.727]             }
[17:04:23.727]         }))
[17:04:23.727]     }, error = function(ex) {
[17:04:23.727]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.727]                 ...future.rng), started = ...future.startTime, 
[17:04:23.727]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.727]             version = "1.8"), class = "FutureResult")
[17:04:23.727]     }, finally = {
[17:04:23.727]         if (!identical(...future.workdir, getwd())) 
[17:04:23.727]             setwd(...future.workdir)
[17:04:23.727]         {
[17:04:23.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.727]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.727]             }
[17:04:23.727]             base::options(...future.oldOptions)
[17:04:23.727]             if (.Platform$OS.type == "windows") {
[17:04:23.727]                 old_names <- names(...future.oldEnvVars)
[17:04:23.727]                 envs <- base::Sys.getenv()
[17:04:23.727]                 names <- names(envs)
[17:04:23.727]                 common <- intersect(names, old_names)
[17:04:23.727]                 added <- setdiff(names, old_names)
[17:04:23.727]                 removed <- setdiff(old_names, names)
[17:04:23.727]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.727]                   envs[common]]
[17:04:23.727]                 NAMES <- toupper(changed)
[17:04:23.727]                 args <- list()
[17:04:23.727]                 for (kk in seq_along(NAMES)) {
[17:04:23.727]                   name <- changed[[kk]]
[17:04:23.727]                   NAME <- NAMES[[kk]]
[17:04:23.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.727]                     next
[17:04:23.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.727]                 }
[17:04:23.727]                 NAMES <- toupper(added)
[17:04:23.727]                 for (kk in seq_along(NAMES)) {
[17:04:23.727]                   name <- added[[kk]]
[17:04:23.727]                   NAME <- NAMES[[kk]]
[17:04:23.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.727]                     next
[17:04:23.727]                   args[[name]] <- ""
[17:04:23.727]                 }
[17:04:23.727]                 NAMES <- toupper(removed)
[17:04:23.727]                 for (kk in seq_along(NAMES)) {
[17:04:23.727]                   name <- removed[[kk]]
[17:04:23.727]                   NAME <- NAMES[[kk]]
[17:04:23.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.727]                     next
[17:04:23.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.727]                 }
[17:04:23.727]                 if (length(args) > 0) 
[17:04:23.727]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.727]             }
[17:04:23.727]             else {
[17:04:23.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.727]             }
[17:04:23.727]             {
[17:04:23.727]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.727]                   0L) {
[17:04:23.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.727]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.727]                   base::options(opts)
[17:04:23.727]                 }
[17:04:23.727]                 {
[17:04:23.727]                   {
[17:04:23.727]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.727]                     NULL
[17:04:23.727]                   }
[17:04:23.727]                   options(future.plan = NULL)
[17:04:23.727]                   if (is.na(NA_character_)) 
[17:04:23.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.727]                     .init = FALSE)
[17:04:23.727]                 }
[17:04:23.727]             }
[17:04:23.727]         }
[17:04:23.727]     })
[17:04:23.727]     if (TRUE) {
[17:04:23.727]         base::sink(type = "output", split = FALSE)
[17:04:23.727]         if (TRUE) {
[17:04:23.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.727]         }
[17:04:23.727]         else {
[17:04:23.727]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.727]         }
[17:04:23.727]         base::close(...future.stdout)
[17:04:23.727]         ...future.stdout <- NULL
[17:04:23.727]     }
[17:04:23.727]     ...future.result$conditions <- ...future.conditions
[17:04:23.727]     ...future.result$finished <- base::Sys.time()
[17:04:23.727]     ...future.result
[17:04:23.727] }
[17:04:23.729] requestCore(): workers = 2
[17:04:23.731] MulticoreFuture started
[17:04:23.732] - Launch lazy future ... done
[17:04:23.732] run() for ‘MulticoreFuture’ ... done
[17:04:23.732] result() for MulticoreFuture ...
[17:04:23.732] plan(): Setting new future strategy stack:
[17:04:23.733] List of future strategies:
[17:04:23.733] 1. sequential:
[17:04:23.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.733]    - tweaked: FALSE
[17:04:23.733]    - call: NULL
[17:04:23.734] plan(): nbrOfWorkers() = 1
[17:04:23.736] plan(): Setting new future strategy stack:
[17:04:23.736] List of future strategies:
[17:04:23.736] 1. multicore:
[17:04:23.736]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.736]    - tweaked: FALSE
[17:04:23.736]    - call: plan(strategy)
[17:04:23.741] plan(): nbrOfWorkers() = 2
[17:04:23.742] result() for MulticoreFuture ...
[17:04:23.742] result() for MulticoreFuture ... done
[17:04:23.742] result() for MulticoreFuture ... done
[17:04:23.742] result() for MulticoreFuture ...
[17:04:23.742] result() for MulticoreFuture ... done
[17:04:23.743] result() for MulticoreFuture ...
[17:04:23.743] result() for MulticoreFuture ... done
[1] 42
[17:04:23.743] result() for MulticoreFuture ...
[17:04:23.743] result() for MulticoreFuture ... done
- stdout = FALSE
[17:04:23.743] getGlobalsAndPackages() ...
[17:04:23.743] Searching for globals...
[17:04:23.747] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.748] Searching for globals ... DONE
[17:04:23.748] Resolving globals: FALSE
[17:04:23.748] 
[17:04:23.748] - packages: [1] ‘utils’
[17:04:23.749] getGlobalsAndPackages() ... DONE
[17:04:23.749] run() for ‘Future’ ...
[17:04:23.749] - state: ‘created’
[17:04:23.749] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.753] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.754]   - Field: ‘label’
[17:04:23.754]   - Field: ‘local’
[17:04:23.754]   - Field: ‘owner’
[17:04:23.754]   - Field: ‘envir’
[17:04:23.754]   - Field: ‘workers’
[17:04:23.754]   - Field: ‘packages’
[17:04:23.754]   - Field: ‘gc’
[17:04:23.754]   - Field: ‘job’
[17:04:23.755]   - Field: ‘conditions’
[17:04:23.755]   - Field: ‘expr’
[17:04:23.755]   - Field: ‘uuid’
[17:04:23.755]   - Field: ‘seed’
[17:04:23.755]   - Field: ‘version’
[17:04:23.755]   - Field: ‘result’
[17:04:23.755]   - Field: ‘asynchronous’
[17:04:23.755]   - Field: ‘calls’
[17:04:23.755]   - Field: ‘globals’
[17:04:23.756]   - Field: ‘stdout’
[17:04:23.756]   - Field: ‘earlySignal’
[17:04:23.756]   - Field: ‘lazy’
[17:04:23.756]   - Field: ‘state’
[17:04:23.756] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.756] - Launch lazy future ...
[17:04:23.756] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.757] Packages needed by future strategies (n = 0): <none>
[17:04:23.757] {
[17:04:23.757]     {
[17:04:23.757]         {
[17:04:23.757]             ...future.startTime <- base::Sys.time()
[17:04:23.757]             {
[17:04:23.757]                 {
[17:04:23.757]                   {
[17:04:23.757]                     {
[17:04:23.757]                       {
[17:04:23.757]                         base::local({
[17:04:23.757]                           has_future <- base::requireNamespace("future", 
[17:04:23.757]                             quietly = TRUE)
[17:04:23.757]                           if (has_future) {
[17:04:23.757]                             ns <- base::getNamespace("future")
[17:04:23.757]                             version <- ns[[".package"]][["version"]]
[17:04:23.757]                             if (is.null(version)) 
[17:04:23.757]                               version <- utils::packageVersion("future")
[17:04:23.757]                           }
[17:04:23.757]                           else {
[17:04:23.757]                             version <- NULL
[17:04:23.757]                           }
[17:04:23.757]                           if (!has_future || version < "1.8.0") {
[17:04:23.757]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.757]                               "", base::R.version$version.string), 
[17:04:23.757]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:23.757]                                 base::R.version$platform, 8 * 
[17:04:23.757]                                   base::.Machine$sizeof.pointer), 
[17:04:23.757]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.757]                                 "release", "version")], collapse = " "), 
[17:04:23.757]                               hostname = base::Sys.info()[["nodename"]])
[17:04:23.757]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.757]                               info)
[17:04:23.757]                             info <- base::paste(info, collapse = "; ")
[17:04:23.757]                             if (!has_future) {
[17:04:23.757]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.757]                                 info)
[17:04:23.757]                             }
[17:04:23.757]                             else {
[17:04:23.757]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.757]                                 info, version)
[17:04:23.757]                             }
[17:04:23.757]                             base::stop(msg)
[17:04:23.757]                           }
[17:04:23.757]                         })
[17:04:23.757]                       }
[17:04:23.757]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.757]                       base::options(mc.cores = 1L)
[17:04:23.757]                     }
[17:04:23.757]                     base::local({
[17:04:23.757]                       for (pkg in "utils") {
[17:04:23.757]                         base::loadNamespace(pkg)
[17:04:23.757]                         base::library(pkg, character.only = TRUE)
[17:04:23.757]                       }
[17:04:23.757]                     })
[17:04:23.757]                   }
[17:04:23.757]                   ...future.strategy.old <- future::plan("list")
[17:04:23.757]                   options(future.plan = NULL)
[17:04:23.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.757]                 }
[17:04:23.757]                 ...future.workdir <- getwd()
[17:04:23.757]             }
[17:04:23.757]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.757]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.757]         }
[17:04:23.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.757]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.757]             base::names(...future.oldOptions))
[17:04:23.757]     }
[17:04:23.757]     if (FALSE) {
[17:04:23.757]     }
[17:04:23.757]     else {
[17:04:23.757]         if (FALSE) {
[17:04:23.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.757]                 open = "w")
[17:04:23.757]         }
[17:04:23.757]         else {
[17:04:23.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.757]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.757]         }
[17:04:23.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.757]             base::sink(type = "output", split = FALSE)
[17:04:23.757]             base::close(...future.stdout)
[17:04:23.757]         }, add = TRUE)
[17:04:23.757]     }
[17:04:23.757]     ...future.frame <- base::sys.nframe()
[17:04:23.757]     ...future.conditions <- base::list()
[17:04:23.757]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.757]     if (FALSE) {
[17:04:23.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.757]     }
[17:04:23.757]     ...future.result <- base::tryCatch({
[17:04:23.757]         base::withCallingHandlers({
[17:04:23.757]             ...future.value <- base::withVisible(base::local({
[17:04:23.757]                 withCallingHandlers({
[17:04:23.757]                   {
[17:04:23.757]                     print(1:50)
[17:04:23.757]                     str(1:50)
[17:04:23.757]                     cat(letters, sep = "-")
[17:04:23.757]                     cat(1:6, collapse = "\n")
[17:04:23.757]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.757]                     42L
[17:04:23.757]                   }
[17:04:23.757]                 }, immediateCondition = function(cond) {
[17:04:23.757]                   save_rds <- function (object, pathname, ...) 
[17:04:23.757]                   {
[17:04:23.757]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.757]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.757]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.757]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.757]                         fi_tmp[["mtime"]])
[17:04:23.757]                     }
[17:04:23.757]                     tryCatch({
[17:04:23.757]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.757]                     }, error = function(ex) {
[17:04:23.757]                       msg <- conditionMessage(ex)
[17:04:23.757]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.757]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.757]                         fi_tmp[["mtime"]], msg)
[17:04:23.757]                       ex$message <- msg
[17:04:23.757]                       stop(ex)
[17:04:23.757]                     })
[17:04:23.757]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.757]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.757]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.757]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.757]                       fi <- file.info(pathname)
[17:04:23.757]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.757]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.757]                         fi[["size"]], fi[["mtime"]])
[17:04:23.757]                       stop(msg)
[17:04:23.757]                     }
[17:04:23.757]                     invisible(pathname)
[17:04:23.757]                   }
[17:04:23.757]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.757]                     rootPath = tempdir()) 
[17:04:23.757]                   {
[17:04:23.757]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.757]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.757]                       tmpdir = path, fileext = ".rds")
[17:04:23.757]                     save_rds(obj, file)
[17:04:23.757]                   }
[17:04:23.757]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.757]                   {
[17:04:23.757]                     inherits <- base::inherits
[17:04:23.757]                     invokeRestart <- base::invokeRestart
[17:04:23.757]                     is.null <- base::is.null
[17:04:23.757]                     muffled <- FALSE
[17:04:23.757]                     if (inherits(cond, "message")) {
[17:04:23.757]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.757]                       if (muffled) 
[17:04:23.757]                         invokeRestart("muffleMessage")
[17:04:23.757]                     }
[17:04:23.757]                     else if (inherits(cond, "warning")) {
[17:04:23.757]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.757]                       if (muffled) 
[17:04:23.757]                         invokeRestart("muffleWarning")
[17:04:23.757]                     }
[17:04:23.757]                     else if (inherits(cond, "condition")) {
[17:04:23.757]                       if (!is.null(pattern)) {
[17:04:23.757]                         computeRestarts <- base::computeRestarts
[17:04:23.757]                         grepl <- base::grepl
[17:04:23.757]                         restarts <- computeRestarts(cond)
[17:04:23.757]                         for (restart in restarts) {
[17:04:23.757]                           name <- restart$name
[17:04:23.757]                           if (is.null(name)) 
[17:04:23.757]                             next
[17:04:23.757]                           if (!grepl(pattern, name)) 
[17:04:23.757]                             next
[17:04:23.757]                           invokeRestart(restart)
[17:04:23.757]                           muffled <- TRUE
[17:04:23.757]                           break
[17:04:23.757]                         }
[17:04:23.757]                       }
[17:04:23.757]                     }
[17:04:23.757]                     invisible(muffled)
[17:04:23.757]                   }
[17:04:23.757]                   muffleCondition(cond)
[17:04:23.757]                 })
[17:04:23.757]             }))
[17:04:23.757]             future::FutureResult(value = ...future.value$value, 
[17:04:23.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.757]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.757]                     ...future.globalenv.names))
[17:04:23.757]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.757]         }, condition = base::local({
[17:04:23.757]             c <- base::c
[17:04:23.757]             inherits <- base::inherits
[17:04:23.757]             invokeRestart <- base::invokeRestart
[17:04:23.757]             length <- base::length
[17:04:23.757]             list <- base::list
[17:04:23.757]             seq.int <- base::seq.int
[17:04:23.757]             signalCondition <- base::signalCondition
[17:04:23.757]             sys.calls <- base::sys.calls
[17:04:23.757]             `[[` <- base::`[[`
[17:04:23.757]             `+` <- base::`+`
[17:04:23.757]             `<<-` <- base::`<<-`
[17:04:23.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.757]                   3L)]
[17:04:23.757]             }
[17:04:23.757]             function(cond) {
[17:04:23.757]                 is_error <- inherits(cond, "error")
[17:04:23.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.757]                   NULL)
[17:04:23.757]                 if (is_error) {
[17:04:23.757]                   sessionInformation <- function() {
[17:04:23.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.757]                       search = base::search(), system = base::Sys.info())
[17:04:23.757]                   }
[17:04:23.757]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.757]                     cond$call), session = sessionInformation(), 
[17:04:23.757]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.757]                   signalCondition(cond)
[17:04:23.757]                 }
[17:04:23.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.757]                 "immediateCondition"))) {
[17:04:23.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.757]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.757]                   if (TRUE && !signal) {
[17:04:23.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.757]                     {
[17:04:23.757]                       inherits <- base::inherits
[17:04:23.757]                       invokeRestart <- base::invokeRestart
[17:04:23.757]                       is.null <- base::is.null
[17:04:23.757]                       muffled <- FALSE
[17:04:23.757]                       if (inherits(cond, "message")) {
[17:04:23.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.757]                         if (muffled) 
[17:04:23.757]                           invokeRestart("muffleMessage")
[17:04:23.757]                       }
[17:04:23.757]                       else if (inherits(cond, "warning")) {
[17:04:23.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.757]                         if (muffled) 
[17:04:23.757]                           invokeRestart("muffleWarning")
[17:04:23.757]                       }
[17:04:23.757]                       else if (inherits(cond, "condition")) {
[17:04:23.757]                         if (!is.null(pattern)) {
[17:04:23.757]                           computeRestarts <- base::computeRestarts
[17:04:23.757]                           grepl <- base::grepl
[17:04:23.757]                           restarts <- computeRestarts(cond)
[17:04:23.757]                           for (restart in restarts) {
[17:04:23.757]                             name <- restart$name
[17:04:23.757]                             if (is.null(name)) 
[17:04:23.757]                               next
[17:04:23.757]                             if (!grepl(pattern, name)) 
[17:04:23.757]                               next
[17:04:23.757]                             invokeRestart(restart)
[17:04:23.757]                             muffled <- TRUE
[17:04:23.757]                             break
[17:04:23.757]                           }
[17:04:23.757]                         }
[17:04:23.757]                       }
[17:04:23.757]                       invisible(muffled)
[17:04:23.757]                     }
[17:04:23.757]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.757]                   }
[17:04:23.757]                 }
[17:04:23.757]                 else {
[17:04:23.757]                   if (TRUE) {
[17:04:23.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.757]                     {
[17:04:23.757]                       inherits <- base::inherits
[17:04:23.757]                       invokeRestart <- base::invokeRestart
[17:04:23.757]                       is.null <- base::is.null
[17:04:23.757]                       muffled <- FALSE
[17:04:23.757]                       if (inherits(cond, "message")) {
[17:04:23.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.757]                         if (muffled) 
[17:04:23.757]                           invokeRestart("muffleMessage")
[17:04:23.757]                       }
[17:04:23.757]                       else if (inherits(cond, "warning")) {
[17:04:23.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.757]                         if (muffled) 
[17:04:23.757]                           invokeRestart("muffleWarning")
[17:04:23.757]                       }
[17:04:23.757]                       else if (inherits(cond, "condition")) {
[17:04:23.757]                         if (!is.null(pattern)) {
[17:04:23.757]                           computeRestarts <- base::computeRestarts
[17:04:23.757]                           grepl <- base::grepl
[17:04:23.757]                           restarts <- computeRestarts(cond)
[17:04:23.757]                           for (restart in restarts) {
[17:04:23.757]                             name <- restart$name
[17:04:23.757]                             if (is.null(name)) 
[17:04:23.757]                               next
[17:04:23.757]                             if (!grepl(pattern, name)) 
[17:04:23.757]                               next
[17:04:23.757]                             invokeRestart(restart)
[17:04:23.757]                             muffled <- TRUE
[17:04:23.757]                             break
[17:04:23.757]                           }
[17:04:23.757]                         }
[17:04:23.757]                       }
[17:04:23.757]                       invisible(muffled)
[17:04:23.757]                     }
[17:04:23.757]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.757]                   }
[17:04:23.757]                 }
[17:04:23.757]             }
[17:04:23.757]         }))
[17:04:23.757]     }, error = function(ex) {
[17:04:23.757]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.757]                 ...future.rng), started = ...future.startTime, 
[17:04:23.757]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.757]             version = "1.8"), class = "FutureResult")
[17:04:23.757]     }, finally = {
[17:04:23.757]         if (!identical(...future.workdir, getwd())) 
[17:04:23.757]             setwd(...future.workdir)
[17:04:23.757]         {
[17:04:23.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.757]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.757]             }
[17:04:23.757]             base::options(...future.oldOptions)
[17:04:23.757]             if (.Platform$OS.type == "windows") {
[17:04:23.757]                 old_names <- names(...future.oldEnvVars)
[17:04:23.757]                 envs <- base::Sys.getenv()
[17:04:23.757]                 names <- names(envs)
[17:04:23.757]                 common <- intersect(names, old_names)
[17:04:23.757]                 added <- setdiff(names, old_names)
[17:04:23.757]                 removed <- setdiff(old_names, names)
[17:04:23.757]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.757]                   envs[common]]
[17:04:23.757]                 NAMES <- toupper(changed)
[17:04:23.757]                 args <- list()
[17:04:23.757]                 for (kk in seq_along(NAMES)) {
[17:04:23.757]                   name <- changed[[kk]]
[17:04:23.757]                   NAME <- NAMES[[kk]]
[17:04:23.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.757]                     next
[17:04:23.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.757]                 }
[17:04:23.757]                 NAMES <- toupper(added)
[17:04:23.757]                 for (kk in seq_along(NAMES)) {
[17:04:23.757]                   name <- added[[kk]]
[17:04:23.757]                   NAME <- NAMES[[kk]]
[17:04:23.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.757]                     next
[17:04:23.757]                   args[[name]] <- ""
[17:04:23.757]                 }
[17:04:23.757]                 NAMES <- toupper(removed)
[17:04:23.757]                 for (kk in seq_along(NAMES)) {
[17:04:23.757]                   name <- removed[[kk]]
[17:04:23.757]                   NAME <- NAMES[[kk]]
[17:04:23.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.757]                     next
[17:04:23.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.757]                 }
[17:04:23.757]                 if (length(args) > 0) 
[17:04:23.757]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.757]             }
[17:04:23.757]             else {
[17:04:23.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.757]             }
[17:04:23.757]             {
[17:04:23.757]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.757]                   0L) {
[17:04:23.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.757]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.757]                   base::options(opts)
[17:04:23.757]                 }
[17:04:23.757]                 {
[17:04:23.757]                   {
[17:04:23.757]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.757]                     NULL
[17:04:23.757]                   }
[17:04:23.757]                   options(future.plan = NULL)
[17:04:23.757]                   if (is.na(NA_character_)) 
[17:04:23.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.757]                     .init = FALSE)
[17:04:23.757]                 }
[17:04:23.757]             }
[17:04:23.757]         }
[17:04:23.757]     })
[17:04:23.757]     if (TRUE) {
[17:04:23.757]         base::sink(type = "output", split = FALSE)
[17:04:23.757]         if (FALSE) {
[17:04:23.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.757]         }
[17:04:23.757]         else {
[17:04:23.757]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.757]         }
[17:04:23.757]         base::close(...future.stdout)
[17:04:23.757]         ...future.stdout <- NULL
[17:04:23.757]     }
[17:04:23.757]     ...future.result$conditions <- ...future.conditions
[17:04:23.757]     ...future.result$finished <- base::Sys.time()
[17:04:23.757]     ...future.result
[17:04:23.757] }
[17:04:23.760] requestCore(): workers = 2
[17:04:23.762] MulticoreFuture started
[17:04:23.762] - Launch lazy future ... done
[17:04:23.763] run() for ‘MulticoreFuture’ ... done
[17:04:23.763] result() for MulticoreFuture ...
[17:04:23.763] plan(): Setting new future strategy stack:
[17:04:23.764] List of future strategies:
[17:04:23.764] 1. sequential:
[17:04:23.764]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.764]    - tweaked: FALSE
[17:04:23.764]    - call: NULL
[17:04:23.765] plan(): nbrOfWorkers() = 1
[17:04:23.773] plan(): Setting new future strategy stack:
[17:04:23.774] List of future strategies:
[17:04:23.774] 1. multicore:
[17:04:23.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.774]    - tweaked: FALSE
[17:04:23.774]    - call: plan(strategy)
[17:04:23.779] plan(): nbrOfWorkers() = 2
[17:04:23.780] result() for MulticoreFuture ...
[17:04:23.780] result() for MulticoreFuture ... done
[17:04:23.780] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ session_uuid: chr "f0cff844-b4ce-6054-5a3a-1203e85e1e68"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50464
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:23"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:23.793] result() for MulticoreFuture ...
[17:04:23.793] result() for MulticoreFuture ... done
[17:04:23.794] result() for MulticoreFuture ...
[17:04:23.794] result() for MulticoreFuture ... done
[17:04:23.794] getGlobalsAndPackages() ...
[17:04:23.794] Searching for globals...
[17:04:23.798] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.798] Searching for globals ... DONE
[17:04:23.798] Resolving globals: FALSE
[17:04:23.799] 
[17:04:23.799] - packages: [1] ‘utils’
[17:04:23.799] getGlobalsAndPackages() ... DONE
[17:04:23.799] run() for ‘Future’ ...
[17:04:23.799] - state: ‘created’
[17:04:23.800] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.804] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.804] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.804]   - Field: ‘label’
[17:04:23.804]   - Field: ‘local’
[17:04:23.804]   - Field: ‘owner’
[17:04:23.804]   - Field: ‘envir’
[17:04:23.804]   - Field: ‘workers’
[17:04:23.804]   - Field: ‘packages’
[17:04:23.805]   - Field: ‘gc’
[17:04:23.805]   - Field: ‘job’
[17:04:23.805]   - Field: ‘conditions’
[17:04:23.805]   - Field: ‘expr’
[17:04:23.805]   - Field: ‘uuid’
[17:04:23.805]   - Field: ‘seed’
[17:04:23.805]   - Field: ‘version’
[17:04:23.805]   - Field: ‘result’
[17:04:23.805]   - Field: ‘asynchronous’
[17:04:23.806]   - Field: ‘calls’
[17:04:23.806]   - Field: ‘globals’
[17:04:23.806]   - Field: ‘stdout’
[17:04:23.806]   - Field: ‘earlySignal’
[17:04:23.806]   - Field: ‘lazy’
[17:04:23.806]   - Field: ‘state’
[17:04:23.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.806] - Launch lazy future ...
[17:04:23.807] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.807] Packages needed by future strategies (n = 0): <none>
[17:04:23.807] {
[17:04:23.807]     {
[17:04:23.807]         {
[17:04:23.807]             ...future.startTime <- base::Sys.time()
[17:04:23.807]             {
[17:04:23.807]                 {
[17:04:23.807]                   {
[17:04:23.807]                     {
[17:04:23.807]                       {
[17:04:23.807]                         base::local({
[17:04:23.807]                           has_future <- base::requireNamespace("future", 
[17:04:23.807]                             quietly = TRUE)
[17:04:23.807]                           if (has_future) {
[17:04:23.807]                             ns <- base::getNamespace("future")
[17:04:23.807]                             version <- ns[[".package"]][["version"]]
[17:04:23.807]                             if (is.null(version)) 
[17:04:23.807]                               version <- utils::packageVersion("future")
[17:04:23.807]                           }
[17:04:23.807]                           else {
[17:04:23.807]                             version <- NULL
[17:04:23.807]                           }
[17:04:23.807]                           if (!has_future || version < "1.8.0") {
[17:04:23.807]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.807]                               "", base::R.version$version.string), 
[17:04:23.807]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:23.807]                                 base::R.version$platform, 8 * 
[17:04:23.807]                                   base::.Machine$sizeof.pointer), 
[17:04:23.807]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.807]                                 "release", "version")], collapse = " "), 
[17:04:23.807]                               hostname = base::Sys.info()[["nodename"]])
[17:04:23.807]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.807]                               info)
[17:04:23.807]                             info <- base::paste(info, collapse = "; ")
[17:04:23.807]                             if (!has_future) {
[17:04:23.807]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.807]                                 info)
[17:04:23.807]                             }
[17:04:23.807]                             else {
[17:04:23.807]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.807]                                 info, version)
[17:04:23.807]                             }
[17:04:23.807]                             base::stop(msg)
[17:04:23.807]                           }
[17:04:23.807]                         })
[17:04:23.807]                       }
[17:04:23.807]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.807]                       base::options(mc.cores = 1L)
[17:04:23.807]                     }
[17:04:23.807]                     base::local({
[17:04:23.807]                       for (pkg in "utils") {
[17:04:23.807]                         base::loadNamespace(pkg)
[17:04:23.807]                         base::library(pkg, character.only = TRUE)
[17:04:23.807]                       }
[17:04:23.807]                     })
[17:04:23.807]                   }
[17:04:23.807]                   ...future.strategy.old <- future::plan("list")
[17:04:23.807]                   options(future.plan = NULL)
[17:04:23.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.807]                 }
[17:04:23.807]                 ...future.workdir <- getwd()
[17:04:23.807]             }
[17:04:23.807]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.807]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.807]         }
[17:04:23.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.807]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.807]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.807]             base::names(...future.oldOptions))
[17:04:23.807]     }
[17:04:23.807]     if (FALSE) {
[17:04:23.807]     }
[17:04:23.807]     else {
[17:04:23.807]         if (FALSE) {
[17:04:23.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.807]                 open = "w")
[17:04:23.807]         }
[17:04:23.807]         else {
[17:04:23.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.807]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.807]         }
[17:04:23.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.807]             base::sink(type = "output", split = FALSE)
[17:04:23.807]             base::close(...future.stdout)
[17:04:23.807]         }, add = TRUE)
[17:04:23.807]     }
[17:04:23.807]     ...future.frame <- base::sys.nframe()
[17:04:23.807]     ...future.conditions <- base::list()
[17:04:23.807]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.807]     if (FALSE) {
[17:04:23.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.807]     }
[17:04:23.807]     ...future.result <- base::tryCatch({
[17:04:23.807]         base::withCallingHandlers({
[17:04:23.807]             ...future.value <- base::withVisible(base::local({
[17:04:23.807]                 withCallingHandlers({
[17:04:23.807]                   {
[17:04:23.807]                     print(1:50)
[17:04:23.807]                     str(1:50)
[17:04:23.807]                     cat(letters, sep = "-")
[17:04:23.807]                     cat(1:6, collapse = "\n")
[17:04:23.807]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.807]                     42L
[17:04:23.807]                   }
[17:04:23.807]                 }, immediateCondition = function(cond) {
[17:04:23.807]                   save_rds <- function (object, pathname, ...) 
[17:04:23.807]                   {
[17:04:23.807]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.807]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.807]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.807]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.807]                         fi_tmp[["mtime"]])
[17:04:23.807]                     }
[17:04:23.807]                     tryCatch({
[17:04:23.807]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.807]                     }, error = function(ex) {
[17:04:23.807]                       msg <- conditionMessage(ex)
[17:04:23.807]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.807]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.807]                         fi_tmp[["mtime"]], msg)
[17:04:23.807]                       ex$message <- msg
[17:04:23.807]                       stop(ex)
[17:04:23.807]                     })
[17:04:23.807]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.807]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.807]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.807]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.807]                       fi <- file.info(pathname)
[17:04:23.807]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.807]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.807]                         fi[["size"]], fi[["mtime"]])
[17:04:23.807]                       stop(msg)
[17:04:23.807]                     }
[17:04:23.807]                     invisible(pathname)
[17:04:23.807]                   }
[17:04:23.807]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.807]                     rootPath = tempdir()) 
[17:04:23.807]                   {
[17:04:23.807]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.807]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.807]                       tmpdir = path, fileext = ".rds")
[17:04:23.807]                     save_rds(obj, file)
[17:04:23.807]                   }
[17:04:23.807]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.807]                   {
[17:04:23.807]                     inherits <- base::inherits
[17:04:23.807]                     invokeRestart <- base::invokeRestart
[17:04:23.807]                     is.null <- base::is.null
[17:04:23.807]                     muffled <- FALSE
[17:04:23.807]                     if (inherits(cond, "message")) {
[17:04:23.807]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.807]                       if (muffled) 
[17:04:23.807]                         invokeRestart("muffleMessage")
[17:04:23.807]                     }
[17:04:23.807]                     else if (inherits(cond, "warning")) {
[17:04:23.807]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.807]                       if (muffled) 
[17:04:23.807]                         invokeRestart("muffleWarning")
[17:04:23.807]                     }
[17:04:23.807]                     else if (inherits(cond, "condition")) {
[17:04:23.807]                       if (!is.null(pattern)) {
[17:04:23.807]                         computeRestarts <- base::computeRestarts
[17:04:23.807]                         grepl <- base::grepl
[17:04:23.807]                         restarts <- computeRestarts(cond)
[17:04:23.807]                         for (restart in restarts) {
[17:04:23.807]                           name <- restart$name
[17:04:23.807]                           if (is.null(name)) 
[17:04:23.807]                             next
[17:04:23.807]                           if (!grepl(pattern, name)) 
[17:04:23.807]                             next
[17:04:23.807]                           invokeRestart(restart)
[17:04:23.807]                           muffled <- TRUE
[17:04:23.807]                           break
[17:04:23.807]                         }
[17:04:23.807]                       }
[17:04:23.807]                     }
[17:04:23.807]                     invisible(muffled)
[17:04:23.807]                   }
[17:04:23.807]                   muffleCondition(cond)
[17:04:23.807]                 })
[17:04:23.807]             }))
[17:04:23.807]             future::FutureResult(value = ...future.value$value, 
[17:04:23.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.807]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.807]                     ...future.globalenv.names))
[17:04:23.807]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.807]         }, condition = base::local({
[17:04:23.807]             c <- base::c
[17:04:23.807]             inherits <- base::inherits
[17:04:23.807]             invokeRestart <- base::invokeRestart
[17:04:23.807]             length <- base::length
[17:04:23.807]             list <- base::list
[17:04:23.807]             seq.int <- base::seq.int
[17:04:23.807]             signalCondition <- base::signalCondition
[17:04:23.807]             sys.calls <- base::sys.calls
[17:04:23.807]             `[[` <- base::`[[`
[17:04:23.807]             `+` <- base::`+`
[17:04:23.807]             `<<-` <- base::`<<-`
[17:04:23.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.807]                   3L)]
[17:04:23.807]             }
[17:04:23.807]             function(cond) {
[17:04:23.807]                 is_error <- inherits(cond, "error")
[17:04:23.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.807]                   NULL)
[17:04:23.807]                 if (is_error) {
[17:04:23.807]                   sessionInformation <- function() {
[17:04:23.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.807]                       search = base::search(), system = base::Sys.info())
[17:04:23.807]                   }
[17:04:23.807]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.807]                     cond$call), session = sessionInformation(), 
[17:04:23.807]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.807]                   signalCondition(cond)
[17:04:23.807]                 }
[17:04:23.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.807]                 "immediateCondition"))) {
[17:04:23.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.807]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.807]                   if (TRUE && !signal) {
[17:04:23.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.807]                     {
[17:04:23.807]                       inherits <- base::inherits
[17:04:23.807]                       invokeRestart <- base::invokeRestart
[17:04:23.807]                       is.null <- base::is.null
[17:04:23.807]                       muffled <- FALSE
[17:04:23.807]                       if (inherits(cond, "message")) {
[17:04:23.807]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.807]                         if (muffled) 
[17:04:23.807]                           invokeRestart("muffleMessage")
[17:04:23.807]                       }
[17:04:23.807]                       else if (inherits(cond, "warning")) {
[17:04:23.807]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.807]                         if (muffled) 
[17:04:23.807]                           invokeRestart("muffleWarning")
[17:04:23.807]                       }
[17:04:23.807]                       else if (inherits(cond, "condition")) {
[17:04:23.807]                         if (!is.null(pattern)) {
[17:04:23.807]                           computeRestarts <- base::computeRestarts
[17:04:23.807]                           grepl <- base::grepl
[17:04:23.807]                           restarts <- computeRestarts(cond)
[17:04:23.807]                           for (restart in restarts) {
[17:04:23.807]                             name <- restart$name
[17:04:23.807]                             if (is.null(name)) 
[17:04:23.807]                               next
[17:04:23.807]                             if (!grepl(pattern, name)) 
[17:04:23.807]                               next
[17:04:23.807]                             invokeRestart(restart)
[17:04:23.807]                             muffled <- TRUE
[17:04:23.807]                             break
[17:04:23.807]                           }
[17:04:23.807]                         }
[17:04:23.807]                       }
[17:04:23.807]                       invisible(muffled)
[17:04:23.807]                     }
[17:04:23.807]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.807]                   }
[17:04:23.807]                 }
[17:04:23.807]                 else {
[17:04:23.807]                   if (TRUE) {
[17:04:23.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.807]                     {
[17:04:23.807]                       inherits <- base::inherits
[17:04:23.807]                       invokeRestart <- base::invokeRestart
[17:04:23.807]                       is.null <- base::is.null
[17:04:23.807]                       muffled <- FALSE
[17:04:23.807]                       if (inherits(cond, "message")) {
[17:04:23.807]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.807]                         if (muffled) 
[17:04:23.807]                           invokeRestart("muffleMessage")
[17:04:23.807]                       }
[17:04:23.807]                       else if (inherits(cond, "warning")) {
[17:04:23.807]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.807]                         if (muffled) 
[17:04:23.807]                           invokeRestart("muffleWarning")
[17:04:23.807]                       }
[17:04:23.807]                       else if (inherits(cond, "condition")) {
[17:04:23.807]                         if (!is.null(pattern)) {
[17:04:23.807]                           computeRestarts <- base::computeRestarts
[17:04:23.807]                           grepl <- base::grepl
[17:04:23.807]                           restarts <- computeRestarts(cond)
[17:04:23.807]                           for (restart in restarts) {
[17:04:23.807]                             name <- restart$name
[17:04:23.807]                             if (is.null(name)) 
[17:04:23.807]                               next
[17:04:23.807]                             if (!grepl(pattern, name)) 
[17:04:23.807]                               next
[17:04:23.807]                             invokeRestart(restart)
[17:04:23.807]                             muffled <- TRUE
[17:04:23.807]                             break
[17:04:23.807]                           }
[17:04:23.807]                         }
[17:04:23.807]                       }
[17:04:23.807]                       invisible(muffled)
[17:04:23.807]                     }
[17:04:23.807]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.807]                   }
[17:04:23.807]                 }
[17:04:23.807]             }
[17:04:23.807]         }))
[17:04:23.807]     }, error = function(ex) {
[17:04:23.807]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.807]                 ...future.rng), started = ...future.startTime, 
[17:04:23.807]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.807]             version = "1.8"), class = "FutureResult")
[17:04:23.807]     }, finally = {
[17:04:23.807]         if (!identical(...future.workdir, getwd())) 
[17:04:23.807]             setwd(...future.workdir)
[17:04:23.807]         {
[17:04:23.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.807]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.807]             }
[17:04:23.807]             base::options(...future.oldOptions)
[17:04:23.807]             if (.Platform$OS.type == "windows") {
[17:04:23.807]                 old_names <- names(...future.oldEnvVars)
[17:04:23.807]                 envs <- base::Sys.getenv()
[17:04:23.807]                 names <- names(envs)
[17:04:23.807]                 common <- intersect(names, old_names)
[17:04:23.807]                 added <- setdiff(names, old_names)
[17:04:23.807]                 removed <- setdiff(old_names, names)
[17:04:23.807]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.807]                   envs[common]]
[17:04:23.807]                 NAMES <- toupper(changed)
[17:04:23.807]                 args <- list()
[17:04:23.807]                 for (kk in seq_along(NAMES)) {
[17:04:23.807]                   name <- changed[[kk]]
[17:04:23.807]                   NAME <- NAMES[[kk]]
[17:04:23.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.807]                     next
[17:04:23.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.807]                 }
[17:04:23.807]                 NAMES <- toupper(added)
[17:04:23.807]                 for (kk in seq_along(NAMES)) {
[17:04:23.807]                   name <- added[[kk]]
[17:04:23.807]                   NAME <- NAMES[[kk]]
[17:04:23.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.807]                     next
[17:04:23.807]                   args[[name]] <- ""
[17:04:23.807]                 }
[17:04:23.807]                 NAMES <- toupper(removed)
[17:04:23.807]                 for (kk in seq_along(NAMES)) {
[17:04:23.807]                   name <- removed[[kk]]
[17:04:23.807]                   NAME <- NAMES[[kk]]
[17:04:23.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.807]                     next
[17:04:23.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.807]                 }
[17:04:23.807]                 if (length(args) > 0) 
[17:04:23.807]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.807]             }
[17:04:23.807]             else {
[17:04:23.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.807]             }
[17:04:23.807]             {
[17:04:23.807]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.807]                   0L) {
[17:04:23.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.807]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.807]                   base::options(opts)
[17:04:23.807]                 }
[17:04:23.807]                 {
[17:04:23.807]                   {
[17:04:23.807]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.807]                     NULL
[17:04:23.807]                   }
[17:04:23.807]                   options(future.plan = NULL)
[17:04:23.807]                   if (is.na(NA_character_)) 
[17:04:23.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.807]                     .init = FALSE)
[17:04:23.807]                 }
[17:04:23.807]             }
[17:04:23.807]         }
[17:04:23.807]     })
[17:04:23.807]     if (TRUE) {
[17:04:23.807]         base::sink(type = "output", split = FALSE)
[17:04:23.807]         if (FALSE) {
[17:04:23.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.807]         }
[17:04:23.807]         else {
[17:04:23.807]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.807]         }
[17:04:23.807]         base::close(...future.stdout)
[17:04:23.807]         ...future.stdout <- NULL
[17:04:23.807]     }
[17:04:23.807]     ...future.result$conditions <- ...future.conditions
[17:04:23.807]     ...future.result$finished <- base::Sys.time()
[17:04:23.807]     ...future.result
[17:04:23.807] }
[17:04:23.810] requestCore(): workers = 2
[17:04:23.812] MulticoreFuture started
[17:04:23.813] - Launch lazy future ... done
[17:04:23.813] run() for ‘MulticoreFuture’ ... done
[17:04:23.814] result() for MulticoreFuture ...
[17:04:23.814] plan(): Setting new future strategy stack:
[17:04:23.814] List of future strategies:
[17:04:23.814] 1. sequential:
[17:04:23.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.814]    - tweaked: FALSE
[17:04:23.814]    - call: NULL
[17:04:23.815] plan(): nbrOfWorkers() = 1
[17:04:23.819] plan(): Setting new future strategy stack:
[17:04:23.819] List of future strategies:
[17:04:23.819] 1. multicore:
[17:04:23.819]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.819]    - tweaked: FALSE
[17:04:23.819]    - call: plan(strategy)
[17:04:23.824] plan(): nbrOfWorkers() = 2
[17:04:23.825] result() for MulticoreFuture ...
[17:04:23.825] result() for MulticoreFuture ... done
[17:04:23.825] result() for MulticoreFuture ... done
[17:04:23.825] result() for MulticoreFuture ...
[17:04:23.826] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:04:23.826] getGlobalsAndPackages() ...
[17:04:23.826] Searching for globals...
[17:04:23.827] - globals found: [1] ‘print’
[17:04:23.827] Searching for globals ... DONE
[17:04:23.827] Resolving globals: FALSE
[17:04:23.828] 
[17:04:23.828] 
[17:04:23.828] getGlobalsAndPackages() ... DONE
[17:04:23.828] run() for ‘Future’ ...
[17:04:23.828] - state: ‘created’
[17:04:23.829] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.833]   - Field: ‘label’
[17:04:23.833]   - Field: ‘local’
[17:04:23.833]   - Field: ‘owner’
[17:04:23.834]   - Field: ‘envir’
[17:04:23.834]   - Field: ‘workers’
[17:04:23.834]   - Field: ‘packages’
[17:04:23.834]   - Field: ‘gc’
[17:04:23.834]   - Field: ‘job’
[17:04:23.834]   - Field: ‘conditions’
[17:04:23.834]   - Field: ‘expr’
[17:04:23.834]   - Field: ‘uuid’
[17:04:23.834]   - Field: ‘seed’
[17:04:23.835]   - Field: ‘version’
[17:04:23.835]   - Field: ‘result’
[17:04:23.835]   - Field: ‘asynchronous’
[17:04:23.837]   - Field: ‘calls’
[17:04:23.837]   - Field: ‘globals’
[17:04:23.838]   - Field: ‘stdout’
[17:04:23.838]   - Field: ‘earlySignal’
[17:04:23.838]   - Field: ‘lazy’
[17:04:23.838]   - Field: ‘state’
[17:04:23.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.838] - Launch lazy future ...
[17:04:23.839] Packages needed by the future expression (n = 0): <none>
[17:04:23.839] Packages needed by future strategies (n = 0): <none>
[17:04:23.840] {
[17:04:23.840]     {
[17:04:23.840]         {
[17:04:23.840]             ...future.startTime <- base::Sys.time()
[17:04:23.840]             {
[17:04:23.840]                 {
[17:04:23.840]                   {
[17:04:23.840]                     {
[17:04:23.840]                       base::local({
[17:04:23.840]                         has_future <- base::requireNamespace("future", 
[17:04:23.840]                           quietly = TRUE)
[17:04:23.840]                         if (has_future) {
[17:04:23.840]                           ns <- base::getNamespace("future")
[17:04:23.840]                           version <- ns[[".package"]][["version"]]
[17:04:23.840]                           if (is.null(version)) 
[17:04:23.840]                             version <- utils::packageVersion("future")
[17:04:23.840]                         }
[17:04:23.840]                         else {
[17:04:23.840]                           version <- NULL
[17:04:23.840]                         }
[17:04:23.840]                         if (!has_future || version < "1.8.0") {
[17:04:23.840]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.840]                             "", base::R.version$version.string), 
[17:04:23.840]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.840]                               "release", "version")], collapse = " "), 
[17:04:23.840]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.840]                             info)
[17:04:23.840]                           info <- base::paste(info, collapse = "; ")
[17:04:23.840]                           if (!has_future) {
[17:04:23.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.840]                               info)
[17:04:23.840]                           }
[17:04:23.840]                           else {
[17:04:23.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.840]                               info, version)
[17:04:23.840]                           }
[17:04:23.840]                           base::stop(msg)
[17:04:23.840]                         }
[17:04:23.840]                       })
[17:04:23.840]                     }
[17:04:23.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.840]                     base::options(mc.cores = 1L)
[17:04:23.840]                   }
[17:04:23.840]                   ...future.strategy.old <- future::plan("list")
[17:04:23.840]                   options(future.plan = NULL)
[17:04:23.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.840]                 }
[17:04:23.840]                 ...future.workdir <- getwd()
[17:04:23.840]             }
[17:04:23.840]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.840]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.840]         }
[17:04:23.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.840]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.840]             base::names(...future.oldOptions))
[17:04:23.840]     }
[17:04:23.840]     if (FALSE) {
[17:04:23.840]     }
[17:04:23.840]     else {
[17:04:23.840]         if (TRUE) {
[17:04:23.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.840]                 open = "w")
[17:04:23.840]         }
[17:04:23.840]         else {
[17:04:23.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.840]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.840]         }
[17:04:23.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.840]             base::sink(type = "output", split = FALSE)
[17:04:23.840]             base::close(...future.stdout)
[17:04:23.840]         }, add = TRUE)
[17:04:23.840]     }
[17:04:23.840]     ...future.frame <- base::sys.nframe()
[17:04:23.840]     ...future.conditions <- base::list()
[17:04:23.840]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.840]     if (FALSE) {
[17:04:23.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.840]     }
[17:04:23.840]     ...future.result <- base::tryCatch({
[17:04:23.840]         base::withCallingHandlers({
[17:04:23.840]             ...future.value <- base::withVisible(base::local({
[17:04:23.840]                 withCallingHandlers({
[17:04:23.840]                   print(42)
[17:04:23.840]                 }, immediateCondition = function(cond) {
[17:04:23.840]                   save_rds <- function (object, pathname, ...) 
[17:04:23.840]                   {
[17:04:23.840]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.840]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.840]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.840]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.840]                         fi_tmp[["mtime"]])
[17:04:23.840]                     }
[17:04:23.840]                     tryCatch({
[17:04:23.840]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.840]                     }, error = function(ex) {
[17:04:23.840]                       msg <- conditionMessage(ex)
[17:04:23.840]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.840]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.840]                         fi_tmp[["mtime"]], msg)
[17:04:23.840]                       ex$message <- msg
[17:04:23.840]                       stop(ex)
[17:04:23.840]                     })
[17:04:23.840]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.840]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.840]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.840]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.840]                       fi <- file.info(pathname)
[17:04:23.840]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.840]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.840]                         fi[["size"]], fi[["mtime"]])
[17:04:23.840]                       stop(msg)
[17:04:23.840]                     }
[17:04:23.840]                     invisible(pathname)
[17:04:23.840]                   }
[17:04:23.840]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.840]                     rootPath = tempdir()) 
[17:04:23.840]                   {
[17:04:23.840]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.840]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.840]                       tmpdir = path, fileext = ".rds")
[17:04:23.840]                     save_rds(obj, file)
[17:04:23.840]                   }
[17:04:23.840]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.840]                   {
[17:04:23.840]                     inherits <- base::inherits
[17:04:23.840]                     invokeRestart <- base::invokeRestart
[17:04:23.840]                     is.null <- base::is.null
[17:04:23.840]                     muffled <- FALSE
[17:04:23.840]                     if (inherits(cond, "message")) {
[17:04:23.840]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.840]                       if (muffled) 
[17:04:23.840]                         invokeRestart("muffleMessage")
[17:04:23.840]                     }
[17:04:23.840]                     else if (inherits(cond, "warning")) {
[17:04:23.840]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.840]                       if (muffled) 
[17:04:23.840]                         invokeRestart("muffleWarning")
[17:04:23.840]                     }
[17:04:23.840]                     else if (inherits(cond, "condition")) {
[17:04:23.840]                       if (!is.null(pattern)) {
[17:04:23.840]                         computeRestarts <- base::computeRestarts
[17:04:23.840]                         grepl <- base::grepl
[17:04:23.840]                         restarts <- computeRestarts(cond)
[17:04:23.840]                         for (restart in restarts) {
[17:04:23.840]                           name <- restart$name
[17:04:23.840]                           if (is.null(name)) 
[17:04:23.840]                             next
[17:04:23.840]                           if (!grepl(pattern, name)) 
[17:04:23.840]                             next
[17:04:23.840]                           invokeRestart(restart)
[17:04:23.840]                           muffled <- TRUE
[17:04:23.840]                           break
[17:04:23.840]                         }
[17:04:23.840]                       }
[17:04:23.840]                     }
[17:04:23.840]                     invisible(muffled)
[17:04:23.840]                   }
[17:04:23.840]                   muffleCondition(cond)
[17:04:23.840]                 })
[17:04:23.840]             }))
[17:04:23.840]             future::FutureResult(value = ...future.value$value, 
[17:04:23.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.840]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.840]                     ...future.globalenv.names))
[17:04:23.840]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.840]         }, condition = base::local({
[17:04:23.840]             c <- base::c
[17:04:23.840]             inherits <- base::inherits
[17:04:23.840]             invokeRestart <- base::invokeRestart
[17:04:23.840]             length <- base::length
[17:04:23.840]             list <- base::list
[17:04:23.840]             seq.int <- base::seq.int
[17:04:23.840]             signalCondition <- base::signalCondition
[17:04:23.840]             sys.calls <- base::sys.calls
[17:04:23.840]             `[[` <- base::`[[`
[17:04:23.840]             `+` <- base::`+`
[17:04:23.840]             `<<-` <- base::`<<-`
[17:04:23.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.840]                   3L)]
[17:04:23.840]             }
[17:04:23.840]             function(cond) {
[17:04:23.840]                 is_error <- inherits(cond, "error")
[17:04:23.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.840]                   NULL)
[17:04:23.840]                 if (is_error) {
[17:04:23.840]                   sessionInformation <- function() {
[17:04:23.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.840]                       search = base::search(), system = base::Sys.info())
[17:04:23.840]                   }
[17:04:23.840]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.840]                     cond$call), session = sessionInformation(), 
[17:04:23.840]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.840]                   signalCondition(cond)
[17:04:23.840]                 }
[17:04:23.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.840]                 "immediateCondition"))) {
[17:04:23.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.840]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.840]                   if (TRUE && !signal) {
[17:04:23.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.840]                     {
[17:04:23.840]                       inherits <- base::inherits
[17:04:23.840]                       invokeRestart <- base::invokeRestart
[17:04:23.840]                       is.null <- base::is.null
[17:04:23.840]                       muffled <- FALSE
[17:04:23.840]                       if (inherits(cond, "message")) {
[17:04:23.840]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.840]                         if (muffled) 
[17:04:23.840]                           invokeRestart("muffleMessage")
[17:04:23.840]                       }
[17:04:23.840]                       else if (inherits(cond, "warning")) {
[17:04:23.840]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.840]                         if (muffled) 
[17:04:23.840]                           invokeRestart("muffleWarning")
[17:04:23.840]                       }
[17:04:23.840]                       else if (inherits(cond, "condition")) {
[17:04:23.840]                         if (!is.null(pattern)) {
[17:04:23.840]                           computeRestarts <- base::computeRestarts
[17:04:23.840]                           grepl <- base::grepl
[17:04:23.840]                           restarts <- computeRestarts(cond)
[17:04:23.840]                           for (restart in restarts) {
[17:04:23.840]                             name <- restart$name
[17:04:23.840]                             if (is.null(name)) 
[17:04:23.840]                               next
[17:04:23.840]                             if (!grepl(pattern, name)) 
[17:04:23.840]                               next
[17:04:23.840]                             invokeRestart(restart)
[17:04:23.840]                             muffled <- TRUE
[17:04:23.840]                             break
[17:04:23.840]                           }
[17:04:23.840]                         }
[17:04:23.840]                       }
[17:04:23.840]                       invisible(muffled)
[17:04:23.840]                     }
[17:04:23.840]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.840]                   }
[17:04:23.840]                 }
[17:04:23.840]                 else {
[17:04:23.840]                   if (TRUE) {
[17:04:23.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.840]                     {
[17:04:23.840]                       inherits <- base::inherits
[17:04:23.840]                       invokeRestart <- base::invokeRestart
[17:04:23.840]                       is.null <- base::is.null
[17:04:23.840]                       muffled <- FALSE
[17:04:23.840]                       if (inherits(cond, "message")) {
[17:04:23.840]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.840]                         if (muffled) 
[17:04:23.840]                           invokeRestart("muffleMessage")
[17:04:23.840]                       }
[17:04:23.840]                       else if (inherits(cond, "warning")) {
[17:04:23.840]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.840]                         if (muffled) 
[17:04:23.840]                           invokeRestart("muffleWarning")
[17:04:23.840]                       }
[17:04:23.840]                       else if (inherits(cond, "condition")) {
[17:04:23.840]                         if (!is.null(pattern)) {
[17:04:23.840]                           computeRestarts <- base::computeRestarts
[17:04:23.840]                           grepl <- base::grepl
[17:04:23.840]                           restarts <- computeRestarts(cond)
[17:04:23.840]                           for (restart in restarts) {
[17:04:23.840]                             name <- restart$name
[17:04:23.840]                             if (is.null(name)) 
[17:04:23.840]                               next
[17:04:23.840]                             if (!grepl(pattern, name)) 
[17:04:23.840]                               next
[17:04:23.840]                             invokeRestart(restart)
[17:04:23.840]                             muffled <- TRUE
[17:04:23.840]                             break
[17:04:23.840]                           }
[17:04:23.840]                         }
[17:04:23.840]                       }
[17:04:23.840]                       invisible(muffled)
[17:04:23.840]                     }
[17:04:23.840]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.840]                   }
[17:04:23.840]                 }
[17:04:23.840]             }
[17:04:23.840]         }))
[17:04:23.840]     }, error = function(ex) {
[17:04:23.840]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.840]                 ...future.rng), started = ...future.startTime, 
[17:04:23.840]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.840]             version = "1.8"), class = "FutureResult")
[17:04:23.840]     }, finally = {
[17:04:23.840]         if (!identical(...future.workdir, getwd())) 
[17:04:23.840]             setwd(...future.workdir)
[17:04:23.840]         {
[17:04:23.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.840]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.840]             }
[17:04:23.840]             base::options(...future.oldOptions)
[17:04:23.840]             if (.Platform$OS.type == "windows") {
[17:04:23.840]                 old_names <- names(...future.oldEnvVars)
[17:04:23.840]                 envs <- base::Sys.getenv()
[17:04:23.840]                 names <- names(envs)
[17:04:23.840]                 common <- intersect(names, old_names)
[17:04:23.840]                 added <- setdiff(names, old_names)
[17:04:23.840]                 removed <- setdiff(old_names, names)
[17:04:23.840]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.840]                   envs[common]]
[17:04:23.840]                 NAMES <- toupper(changed)
[17:04:23.840]                 args <- list()
[17:04:23.840]                 for (kk in seq_along(NAMES)) {
[17:04:23.840]                   name <- changed[[kk]]
[17:04:23.840]                   NAME <- NAMES[[kk]]
[17:04:23.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.840]                     next
[17:04:23.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.840]                 }
[17:04:23.840]                 NAMES <- toupper(added)
[17:04:23.840]                 for (kk in seq_along(NAMES)) {
[17:04:23.840]                   name <- added[[kk]]
[17:04:23.840]                   NAME <- NAMES[[kk]]
[17:04:23.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.840]                     next
[17:04:23.840]                   args[[name]] <- ""
[17:04:23.840]                 }
[17:04:23.840]                 NAMES <- toupper(removed)
[17:04:23.840]                 for (kk in seq_along(NAMES)) {
[17:04:23.840]                   name <- removed[[kk]]
[17:04:23.840]                   NAME <- NAMES[[kk]]
[17:04:23.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.840]                     next
[17:04:23.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.840]                 }
[17:04:23.840]                 if (length(args) > 0) 
[17:04:23.840]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.840]             }
[17:04:23.840]             else {
[17:04:23.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.840]             }
[17:04:23.840]             {
[17:04:23.840]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.840]                   0L) {
[17:04:23.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.840]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.840]                   base::options(opts)
[17:04:23.840]                 }
[17:04:23.840]                 {
[17:04:23.840]                   {
[17:04:23.840]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.840]                     NULL
[17:04:23.840]                   }
[17:04:23.840]                   options(future.plan = NULL)
[17:04:23.840]                   if (is.na(NA_character_)) 
[17:04:23.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.840]                     .init = FALSE)
[17:04:23.840]                 }
[17:04:23.840]             }
[17:04:23.840]         }
[17:04:23.840]     })
[17:04:23.840]     if (TRUE) {
[17:04:23.840]         base::sink(type = "output", split = FALSE)
[17:04:23.840]         if (TRUE) {
[17:04:23.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.840]         }
[17:04:23.840]         else {
[17:04:23.840]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.840]         }
[17:04:23.840]         base::close(...future.stdout)
[17:04:23.840]         ...future.stdout <- NULL
[17:04:23.840]     }
[17:04:23.840]     ...future.result$conditions <- ...future.conditions
[17:04:23.840]     ...future.result$finished <- base::Sys.time()
[17:04:23.840]     ...future.result
[17:04:23.840] }
[17:04:23.842] requestCore(): workers = 2
[17:04:23.844] MulticoreFuture started
[17:04:23.845] - Launch lazy future ... done
[17:04:23.845] run() for ‘MulticoreFuture’ ... done
[17:04:23.845] result() for MulticoreFuture ...
[17:04:23.845] plan(): Setting new future strategy stack:
[17:04:23.846] List of future strategies:
[17:04:23.846] 1. sequential:
[17:04:23.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.846]    - tweaked: FALSE
[17:04:23.846]    - call: NULL
[17:04:23.847] plan(): nbrOfWorkers() = 1
[17:04:23.849] plan(): Setting new future strategy stack:
[17:04:23.849] List of future strategies:
[17:04:23.849] 1. multicore:
[17:04:23.849]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.849]    - tweaked: FALSE
[17:04:23.849]    - call: plan(strategy)
[17:04:23.854] plan(): nbrOfWorkers() = 2
[17:04:23.855] result() for MulticoreFuture ...
[17:04:23.856] result() for MulticoreFuture ... done
[17:04:23.856] result() for MulticoreFuture ... done
[17:04:23.856] result() for MulticoreFuture ...
[17:04:23.856] result() for MulticoreFuture ... done
[17:04:23.856] result() for MulticoreFuture ...
[17:04:23.856] result() for MulticoreFuture ... done
[1] 42
[17:04:23.857] result() for MulticoreFuture ...
[17:04:23.857] result() for MulticoreFuture ... done
- stdout = NA
[17:04:23.857] getGlobalsAndPackages() ...
[17:04:23.857] Searching for globals...
[17:04:23.861] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.861] Searching for globals ... DONE
[17:04:23.862] Resolving globals: FALSE
[17:04:23.862] 
[17:04:23.862] - packages: [1] ‘utils’
[17:04:23.862] getGlobalsAndPackages() ... DONE
[17:04:23.863] run() for ‘Future’ ...
[17:04:23.863] - state: ‘created’
[17:04:23.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.868]   - Field: ‘label’
[17:04:23.868]   - Field: ‘local’
[17:04:23.868]   - Field: ‘owner’
[17:04:23.868]   - Field: ‘envir’
[17:04:23.868]   - Field: ‘workers’
[17:04:23.868]   - Field: ‘packages’
[17:04:23.868]   - Field: ‘gc’
[17:04:23.868]   - Field: ‘job’
[17:04:23.869]   - Field: ‘conditions’
[17:04:23.869]   - Field: ‘expr’
[17:04:23.869]   - Field: ‘uuid’
[17:04:23.869]   - Field: ‘seed’
[17:04:23.869]   - Field: ‘version’
[17:04:23.869]   - Field: ‘result’
[17:04:23.869]   - Field: ‘asynchronous’
[17:04:23.869]   - Field: ‘calls’
[17:04:23.869]   - Field: ‘globals’
[17:04:23.870]   - Field: ‘stdout’
[17:04:23.870]   - Field: ‘earlySignal’
[17:04:23.870]   - Field: ‘lazy’
[17:04:23.870]   - Field: ‘state’
[17:04:23.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.870] - Launch lazy future ...
[17:04:23.870] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.871] Packages needed by future strategies (n = 0): <none>
[17:04:23.871] {
[17:04:23.871]     {
[17:04:23.871]         {
[17:04:23.871]             ...future.startTime <- base::Sys.time()
[17:04:23.871]             {
[17:04:23.871]                 {
[17:04:23.871]                   {
[17:04:23.871]                     {
[17:04:23.871]                       {
[17:04:23.871]                         base::local({
[17:04:23.871]                           has_future <- base::requireNamespace("future", 
[17:04:23.871]                             quietly = TRUE)
[17:04:23.871]                           if (has_future) {
[17:04:23.871]                             ns <- base::getNamespace("future")
[17:04:23.871]                             version <- ns[[".package"]][["version"]]
[17:04:23.871]                             if (is.null(version)) 
[17:04:23.871]                               version <- utils::packageVersion("future")
[17:04:23.871]                           }
[17:04:23.871]                           else {
[17:04:23.871]                             version <- NULL
[17:04:23.871]                           }
[17:04:23.871]                           if (!has_future || version < "1.8.0") {
[17:04:23.871]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.871]                               "", base::R.version$version.string), 
[17:04:23.871]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:23.871]                                 base::R.version$platform, 8 * 
[17:04:23.871]                                   base::.Machine$sizeof.pointer), 
[17:04:23.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.871]                                 "release", "version")], collapse = " "), 
[17:04:23.871]                               hostname = base::Sys.info()[["nodename"]])
[17:04:23.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.871]                               info)
[17:04:23.871]                             info <- base::paste(info, collapse = "; ")
[17:04:23.871]                             if (!has_future) {
[17:04:23.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.871]                                 info)
[17:04:23.871]                             }
[17:04:23.871]                             else {
[17:04:23.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.871]                                 info, version)
[17:04:23.871]                             }
[17:04:23.871]                             base::stop(msg)
[17:04:23.871]                           }
[17:04:23.871]                         })
[17:04:23.871]                       }
[17:04:23.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.871]                       base::options(mc.cores = 1L)
[17:04:23.871]                     }
[17:04:23.871]                     base::local({
[17:04:23.871]                       for (pkg in "utils") {
[17:04:23.871]                         base::loadNamespace(pkg)
[17:04:23.871]                         base::library(pkg, character.only = TRUE)
[17:04:23.871]                       }
[17:04:23.871]                     })
[17:04:23.871]                   }
[17:04:23.871]                   ...future.strategy.old <- future::plan("list")
[17:04:23.871]                   options(future.plan = NULL)
[17:04:23.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.871]                 }
[17:04:23.871]                 ...future.workdir <- getwd()
[17:04:23.871]             }
[17:04:23.871]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.871]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.871]         }
[17:04:23.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.871]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.871]             base::names(...future.oldOptions))
[17:04:23.871]     }
[17:04:23.871]     if (TRUE) {
[17:04:23.871]     }
[17:04:23.871]     else {
[17:04:23.871]         if (NA) {
[17:04:23.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.871]                 open = "w")
[17:04:23.871]         }
[17:04:23.871]         else {
[17:04:23.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.871]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.871]         }
[17:04:23.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.871]             base::sink(type = "output", split = FALSE)
[17:04:23.871]             base::close(...future.stdout)
[17:04:23.871]         }, add = TRUE)
[17:04:23.871]     }
[17:04:23.871]     ...future.frame <- base::sys.nframe()
[17:04:23.871]     ...future.conditions <- base::list()
[17:04:23.871]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.871]     if (FALSE) {
[17:04:23.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.871]     }
[17:04:23.871]     ...future.result <- base::tryCatch({
[17:04:23.871]         base::withCallingHandlers({
[17:04:23.871]             ...future.value <- base::withVisible(base::local({
[17:04:23.871]                 withCallingHandlers({
[17:04:23.871]                   {
[17:04:23.871]                     print(1:50)
[17:04:23.871]                     str(1:50)
[17:04:23.871]                     cat(letters, sep = "-")
[17:04:23.871]                     cat(1:6, collapse = "\n")
[17:04:23.871]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.871]                     42L
[17:04:23.871]                   }
[17:04:23.871]                 }, immediateCondition = function(cond) {
[17:04:23.871]                   save_rds <- function (object, pathname, ...) 
[17:04:23.871]                   {
[17:04:23.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.871]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.871]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.871]                         fi_tmp[["mtime"]])
[17:04:23.871]                     }
[17:04:23.871]                     tryCatch({
[17:04:23.871]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.871]                     }, error = function(ex) {
[17:04:23.871]                       msg <- conditionMessage(ex)
[17:04:23.871]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.871]                         fi_tmp[["mtime"]], msg)
[17:04:23.871]                       ex$message <- msg
[17:04:23.871]                       stop(ex)
[17:04:23.871]                     })
[17:04:23.871]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.871]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.871]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.871]                       fi <- file.info(pathname)
[17:04:23.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.871]                         fi[["size"]], fi[["mtime"]])
[17:04:23.871]                       stop(msg)
[17:04:23.871]                     }
[17:04:23.871]                     invisible(pathname)
[17:04:23.871]                   }
[17:04:23.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.871]                     rootPath = tempdir()) 
[17:04:23.871]                   {
[17:04:23.871]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.871]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.871]                       tmpdir = path, fileext = ".rds")
[17:04:23.871]                     save_rds(obj, file)
[17:04:23.871]                   }
[17:04:23.871]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.871]                   {
[17:04:23.871]                     inherits <- base::inherits
[17:04:23.871]                     invokeRestart <- base::invokeRestart
[17:04:23.871]                     is.null <- base::is.null
[17:04:23.871]                     muffled <- FALSE
[17:04:23.871]                     if (inherits(cond, "message")) {
[17:04:23.871]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.871]                       if (muffled) 
[17:04:23.871]                         invokeRestart("muffleMessage")
[17:04:23.871]                     }
[17:04:23.871]                     else if (inherits(cond, "warning")) {
[17:04:23.871]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.871]                       if (muffled) 
[17:04:23.871]                         invokeRestart("muffleWarning")
[17:04:23.871]                     }
[17:04:23.871]                     else if (inherits(cond, "condition")) {
[17:04:23.871]                       if (!is.null(pattern)) {
[17:04:23.871]                         computeRestarts <- base::computeRestarts
[17:04:23.871]                         grepl <- base::grepl
[17:04:23.871]                         restarts <- computeRestarts(cond)
[17:04:23.871]                         for (restart in restarts) {
[17:04:23.871]                           name <- restart$name
[17:04:23.871]                           if (is.null(name)) 
[17:04:23.871]                             next
[17:04:23.871]                           if (!grepl(pattern, name)) 
[17:04:23.871]                             next
[17:04:23.871]                           invokeRestart(restart)
[17:04:23.871]                           muffled <- TRUE
[17:04:23.871]                           break
[17:04:23.871]                         }
[17:04:23.871]                       }
[17:04:23.871]                     }
[17:04:23.871]                     invisible(muffled)
[17:04:23.871]                   }
[17:04:23.871]                   muffleCondition(cond)
[17:04:23.871]                 })
[17:04:23.871]             }))
[17:04:23.871]             future::FutureResult(value = ...future.value$value, 
[17:04:23.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.871]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.871]                     ...future.globalenv.names))
[17:04:23.871]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.871]         }, condition = base::local({
[17:04:23.871]             c <- base::c
[17:04:23.871]             inherits <- base::inherits
[17:04:23.871]             invokeRestart <- base::invokeRestart
[17:04:23.871]             length <- base::length
[17:04:23.871]             list <- base::list
[17:04:23.871]             seq.int <- base::seq.int
[17:04:23.871]             signalCondition <- base::signalCondition
[17:04:23.871]             sys.calls <- base::sys.calls
[17:04:23.871]             `[[` <- base::`[[`
[17:04:23.871]             `+` <- base::`+`
[17:04:23.871]             `<<-` <- base::`<<-`
[17:04:23.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.871]                   3L)]
[17:04:23.871]             }
[17:04:23.871]             function(cond) {
[17:04:23.871]                 is_error <- inherits(cond, "error")
[17:04:23.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.871]                   NULL)
[17:04:23.871]                 if (is_error) {
[17:04:23.871]                   sessionInformation <- function() {
[17:04:23.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.871]                       search = base::search(), system = base::Sys.info())
[17:04:23.871]                   }
[17:04:23.871]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.871]                     cond$call), session = sessionInformation(), 
[17:04:23.871]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.871]                   signalCondition(cond)
[17:04:23.871]                 }
[17:04:23.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.871]                 "immediateCondition"))) {
[17:04:23.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.871]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.871]                   if (TRUE && !signal) {
[17:04:23.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.871]                     {
[17:04:23.871]                       inherits <- base::inherits
[17:04:23.871]                       invokeRestart <- base::invokeRestart
[17:04:23.871]                       is.null <- base::is.null
[17:04:23.871]                       muffled <- FALSE
[17:04:23.871]                       if (inherits(cond, "message")) {
[17:04:23.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.871]                         if (muffled) 
[17:04:23.871]                           invokeRestart("muffleMessage")
[17:04:23.871]                       }
[17:04:23.871]                       else if (inherits(cond, "warning")) {
[17:04:23.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.871]                         if (muffled) 
[17:04:23.871]                           invokeRestart("muffleWarning")
[17:04:23.871]                       }
[17:04:23.871]                       else if (inherits(cond, "condition")) {
[17:04:23.871]                         if (!is.null(pattern)) {
[17:04:23.871]                           computeRestarts <- base::computeRestarts
[17:04:23.871]                           grepl <- base::grepl
[17:04:23.871]                           restarts <- computeRestarts(cond)
[17:04:23.871]                           for (restart in restarts) {
[17:04:23.871]                             name <- restart$name
[17:04:23.871]                             if (is.null(name)) 
[17:04:23.871]                               next
[17:04:23.871]                             if (!grepl(pattern, name)) 
[17:04:23.871]                               next
[17:04:23.871]                             invokeRestart(restart)
[17:04:23.871]                             muffled <- TRUE
[17:04:23.871]                             break
[17:04:23.871]                           }
[17:04:23.871]                         }
[17:04:23.871]                       }
[17:04:23.871]                       invisible(muffled)
[17:04:23.871]                     }
[17:04:23.871]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.871]                   }
[17:04:23.871]                 }
[17:04:23.871]                 else {
[17:04:23.871]                   if (TRUE) {
[17:04:23.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.871]                     {
[17:04:23.871]                       inherits <- base::inherits
[17:04:23.871]                       invokeRestart <- base::invokeRestart
[17:04:23.871]                       is.null <- base::is.null
[17:04:23.871]                       muffled <- FALSE
[17:04:23.871]                       if (inherits(cond, "message")) {
[17:04:23.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.871]                         if (muffled) 
[17:04:23.871]                           invokeRestart("muffleMessage")
[17:04:23.871]                       }
[17:04:23.871]                       else if (inherits(cond, "warning")) {
[17:04:23.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.871]                         if (muffled) 
[17:04:23.871]                           invokeRestart("muffleWarning")
[17:04:23.871]                       }
[17:04:23.871]                       else if (inherits(cond, "condition")) {
[17:04:23.871]                         if (!is.null(pattern)) {
[17:04:23.871]                           computeRestarts <- base::computeRestarts
[17:04:23.871]                           grepl <- base::grepl
[17:04:23.871]                           restarts <- computeRestarts(cond)
[17:04:23.871]                           for (restart in restarts) {
[17:04:23.871]                             name <- restart$name
[17:04:23.871]                             if (is.null(name)) 
[17:04:23.871]                               next
[17:04:23.871]                             if (!grepl(pattern, name)) 
[17:04:23.871]                               next
[17:04:23.871]                             invokeRestart(restart)
[17:04:23.871]                             muffled <- TRUE
[17:04:23.871]                             break
[17:04:23.871]                           }
[17:04:23.871]                         }
[17:04:23.871]                       }
[17:04:23.871]                       invisible(muffled)
[17:04:23.871]                     }
[17:04:23.871]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.871]                   }
[17:04:23.871]                 }
[17:04:23.871]             }
[17:04:23.871]         }))
[17:04:23.871]     }, error = function(ex) {
[17:04:23.871]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.871]                 ...future.rng), started = ...future.startTime, 
[17:04:23.871]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.871]             version = "1.8"), class = "FutureResult")
[17:04:23.871]     }, finally = {
[17:04:23.871]         if (!identical(...future.workdir, getwd())) 
[17:04:23.871]             setwd(...future.workdir)
[17:04:23.871]         {
[17:04:23.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.871]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.871]             }
[17:04:23.871]             base::options(...future.oldOptions)
[17:04:23.871]             if (.Platform$OS.type == "windows") {
[17:04:23.871]                 old_names <- names(...future.oldEnvVars)
[17:04:23.871]                 envs <- base::Sys.getenv()
[17:04:23.871]                 names <- names(envs)
[17:04:23.871]                 common <- intersect(names, old_names)
[17:04:23.871]                 added <- setdiff(names, old_names)
[17:04:23.871]                 removed <- setdiff(old_names, names)
[17:04:23.871]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.871]                   envs[common]]
[17:04:23.871]                 NAMES <- toupper(changed)
[17:04:23.871]                 args <- list()
[17:04:23.871]                 for (kk in seq_along(NAMES)) {
[17:04:23.871]                   name <- changed[[kk]]
[17:04:23.871]                   NAME <- NAMES[[kk]]
[17:04:23.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.871]                     next
[17:04:23.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.871]                 }
[17:04:23.871]                 NAMES <- toupper(added)
[17:04:23.871]                 for (kk in seq_along(NAMES)) {
[17:04:23.871]                   name <- added[[kk]]
[17:04:23.871]                   NAME <- NAMES[[kk]]
[17:04:23.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.871]                     next
[17:04:23.871]                   args[[name]] <- ""
[17:04:23.871]                 }
[17:04:23.871]                 NAMES <- toupper(removed)
[17:04:23.871]                 for (kk in seq_along(NAMES)) {
[17:04:23.871]                   name <- removed[[kk]]
[17:04:23.871]                   NAME <- NAMES[[kk]]
[17:04:23.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.871]                     next
[17:04:23.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.871]                 }
[17:04:23.871]                 if (length(args) > 0) 
[17:04:23.871]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.871]             }
[17:04:23.871]             else {
[17:04:23.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.871]             }
[17:04:23.871]             {
[17:04:23.871]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.871]                   0L) {
[17:04:23.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.871]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.871]                   base::options(opts)
[17:04:23.871]                 }
[17:04:23.871]                 {
[17:04:23.871]                   {
[17:04:23.871]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.871]                     NULL
[17:04:23.871]                   }
[17:04:23.871]                   options(future.plan = NULL)
[17:04:23.871]                   if (is.na(NA_character_)) 
[17:04:23.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.871]                     .init = FALSE)
[17:04:23.871]                 }
[17:04:23.871]             }
[17:04:23.871]         }
[17:04:23.871]     })
[17:04:23.871]     if (FALSE) {
[17:04:23.871]         base::sink(type = "output", split = FALSE)
[17:04:23.871]         if (NA) {
[17:04:23.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.871]         }
[17:04:23.871]         else {
[17:04:23.871]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.871]         }
[17:04:23.871]         base::close(...future.stdout)
[17:04:23.871]         ...future.stdout <- NULL
[17:04:23.871]     }
[17:04:23.871]     ...future.result$conditions <- ...future.conditions
[17:04:23.871]     ...future.result$finished <- base::Sys.time()
[17:04:23.871]     ...future.result
[17:04:23.871] }
[17:04:23.874] requestCore(): workers = 2
[17:04:23.876] MulticoreFuture started
[17:04:23.876] - Launch lazy future ... done
[17:04:23.877] run() for ‘MulticoreFuture’ ... done
[17:04:23.877] result() for MulticoreFuture ...
[17:04:23.877] plan(): Setting new future strategy stack:
[17:04:23.878] List of future strategies:
[17:04:23.878] 1. sequential:
[17:04:23.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.878]    - tweaked: FALSE
[17:04:23.878]    - call: NULL
[17:04:23.879] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:04:23.882] plan(): Setting new future strategy stack:
[17:04:23.883] List of future strategies:
[17:04:23.883] 1. multicore:
[17:04:23.883]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.883]    - tweaked: FALSE
[17:04:23.883]    - call: plan(strategy)
[17:04:23.888] plan(): nbrOfWorkers() = 2
[17:04:23.888] result() for MulticoreFuture ...
[17:04:23.889] result() for MulticoreFuture ... done
[17:04:23.889] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:23"
 $ session_uuid: chr "445750c3-35c7-1490-5da7-55bdc7c078a6"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50479
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:23"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:23.899] result() for MulticoreFuture ...
[17:04:23.899] result() for MulticoreFuture ... done
[17:04:23.899] result() for MulticoreFuture ...
[17:04:23.899] result() for MulticoreFuture ... done
[17:04:23.899] getGlobalsAndPackages() ...
[17:04:23.899] Searching for globals...
[17:04:23.906] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:23.906] Searching for globals ... DONE
[17:04:23.907] Resolving globals: FALSE
[17:04:23.907] 
[17:04:23.907] - packages: [1] ‘utils’
[17:04:23.908] getGlobalsAndPackages() ... DONE
[17:04:23.908] run() for ‘Future’ ...
[17:04:23.908] - state: ‘created’
[17:04:23.908] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.912] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.913]   - Field: ‘label’
[17:04:23.913]   - Field: ‘local’
[17:04:23.913]   - Field: ‘owner’
[17:04:23.913]   - Field: ‘envir’
[17:04:23.913]   - Field: ‘workers’
[17:04:23.913]   - Field: ‘packages’
[17:04:23.913]   - Field: ‘gc’
[17:04:23.913]   - Field: ‘job’
[17:04:23.914]   - Field: ‘conditions’
[17:04:23.914]   - Field: ‘expr’
[17:04:23.914]   - Field: ‘uuid’
[17:04:23.914]   - Field: ‘seed’
[17:04:23.914]   - Field: ‘version’
[17:04:23.914]   - Field: ‘result’
[17:04:23.914]   - Field: ‘asynchronous’
[17:04:23.914]   - Field: ‘calls’
[17:04:23.914]   - Field: ‘globals’
[17:04:23.915]   - Field: ‘stdout’
[17:04:23.915]   - Field: ‘earlySignal’
[17:04:23.915]   - Field: ‘lazy’
[17:04:23.915]   - Field: ‘state’
[17:04:23.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.915] - Launch lazy future ...
[17:04:23.915] Packages needed by the future expression (n = 1): ‘utils’
[17:04:23.916] Packages needed by future strategies (n = 0): <none>
[17:04:23.916] {
[17:04:23.916]     {
[17:04:23.916]         {
[17:04:23.916]             ...future.startTime <- base::Sys.time()
[17:04:23.916]             {
[17:04:23.916]                 {
[17:04:23.916]                   {
[17:04:23.916]                     {
[17:04:23.916]                       {
[17:04:23.916]                         base::local({
[17:04:23.916]                           has_future <- base::requireNamespace("future", 
[17:04:23.916]                             quietly = TRUE)
[17:04:23.916]                           if (has_future) {
[17:04:23.916]                             ns <- base::getNamespace("future")
[17:04:23.916]                             version <- ns[[".package"]][["version"]]
[17:04:23.916]                             if (is.null(version)) 
[17:04:23.916]                               version <- utils::packageVersion("future")
[17:04:23.916]                           }
[17:04:23.916]                           else {
[17:04:23.916]                             version <- NULL
[17:04:23.916]                           }
[17:04:23.916]                           if (!has_future || version < "1.8.0") {
[17:04:23.916]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.916]                               "", base::R.version$version.string), 
[17:04:23.916]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:23.916]                                 base::R.version$platform, 8 * 
[17:04:23.916]                                   base::.Machine$sizeof.pointer), 
[17:04:23.916]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.916]                                 "release", "version")], collapse = " "), 
[17:04:23.916]                               hostname = base::Sys.info()[["nodename"]])
[17:04:23.916]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.916]                               info)
[17:04:23.916]                             info <- base::paste(info, collapse = "; ")
[17:04:23.916]                             if (!has_future) {
[17:04:23.916]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.916]                                 info)
[17:04:23.916]                             }
[17:04:23.916]                             else {
[17:04:23.916]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.916]                                 info, version)
[17:04:23.916]                             }
[17:04:23.916]                             base::stop(msg)
[17:04:23.916]                           }
[17:04:23.916]                         })
[17:04:23.916]                       }
[17:04:23.916]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.916]                       base::options(mc.cores = 1L)
[17:04:23.916]                     }
[17:04:23.916]                     base::local({
[17:04:23.916]                       for (pkg in "utils") {
[17:04:23.916]                         base::loadNamespace(pkg)
[17:04:23.916]                         base::library(pkg, character.only = TRUE)
[17:04:23.916]                       }
[17:04:23.916]                     })
[17:04:23.916]                   }
[17:04:23.916]                   ...future.strategy.old <- future::plan("list")
[17:04:23.916]                   options(future.plan = NULL)
[17:04:23.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.916]                 }
[17:04:23.916]                 ...future.workdir <- getwd()
[17:04:23.916]             }
[17:04:23.916]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.916]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.916]         }
[17:04:23.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.916]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.916]             base::names(...future.oldOptions))
[17:04:23.916]     }
[17:04:23.916]     if (TRUE) {
[17:04:23.916]     }
[17:04:23.916]     else {
[17:04:23.916]         if (NA) {
[17:04:23.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.916]                 open = "w")
[17:04:23.916]         }
[17:04:23.916]         else {
[17:04:23.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.916]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.916]         }
[17:04:23.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.916]             base::sink(type = "output", split = FALSE)
[17:04:23.916]             base::close(...future.stdout)
[17:04:23.916]         }, add = TRUE)
[17:04:23.916]     }
[17:04:23.916]     ...future.frame <- base::sys.nframe()
[17:04:23.916]     ...future.conditions <- base::list()
[17:04:23.916]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.916]     if (FALSE) {
[17:04:23.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.916]     }
[17:04:23.916]     ...future.result <- base::tryCatch({
[17:04:23.916]         base::withCallingHandlers({
[17:04:23.916]             ...future.value <- base::withVisible(base::local({
[17:04:23.916]                 withCallingHandlers({
[17:04:23.916]                   {
[17:04:23.916]                     print(1:50)
[17:04:23.916]                     str(1:50)
[17:04:23.916]                     cat(letters, sep = "-")
[17:04:23.916]                     cat(1:6, collapse = "\n")
[17:04:23.916]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:23.916]                     42L
[17:04:23.916]                   }
[17:04:23.916]                 }, immediateCondition = function(cond) {
[17:04:23.916]                   save_rds <- function (object, pathname, ...) 
[17:04:23.916]                   {
[17:04:23.916]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.916]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.916]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.916]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.916]                         fi_tmp[["mtime"]])
[17:04:23.916]                     }
[17:04:23.916]                     tryCatch({
[17:04:23.916]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.916]                     }, error = function(ex) {
[17:04:23.916]                       msg <- conditionMessage(ex)
[17:04:23.916]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.916]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.916]                         fi_tmp[["mtime"]], msg)
[17:04:23.916]                       ex$message <- msg
[17:04:23.916]                       stop(ex)
[17:04:23.916]                     })
[17:04:23.916]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.916]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.916]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.916]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.916]                       fi <- file.info(pathname)
[17:04:23.916]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.916]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.916]                         fi[["size"]], fi[["mtime"]])
[17:04:23.916]                       stop(msg)
[17:04:23.916]                     }
[17:04:23.916]                     invisible(pathname)
[17:04:23.916]                   }
[17:04:23.916]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.916]                     rootPath = tempdir()) 
[17:04:23.916]                   {
[17:04:23.916]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.916]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.916]                       tmpdir = path, fileext = ".rds")
[17:04:23.916]                     save_rds(obj, file)
[17:04:23.916]                   }
[17:04:23.916]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.916]                   {
[17:04:23.916]                     inherits <- base::inherits
[17:04:23.916]                     invokeRestart <- base::invokeRestart
[17:04:23.916]                     is.null <- base::is.null
[17:04:23.916]                     muffled <- FALSE
[17:04:23.916]                     if (inherits(cond, "message")) {
[17:04:23.916]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.916]                       if (muffled) 
[17:04:23.916]                         invokeRestart("muffleMessage")
[17:04:23.916]                     }
[17:04:23.916]                     else if (inherits(cond, "warning")) {
[17:04:23.916]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.916]                       if (muffled) 
[17:04:23.916]                         invokeRestart("muffleWarning")
[17:04:23.916]                     }
[17:04:23.916]                     else if (inherits(cond, "condition")) {
[17:04:23.916]                       if (!is.null(pattern)) {
[17:04:23.916]                         computeRestarts <- base::computeRestarts
[17:04:23.916]                         grepl <- base::grepl
[17:04:23.916]                         restarts <- computeRestarts(cond)
[17:04:23.916]                         for (restart in restarts) {
[17:04:23.916]                           name <- restart$name
[17:04:23.916]                           if (is.null(name)) 
[17:04:23.916]                             next
[17:04:23.916]                           if (!grepl(pattern, name)) 
[17:04:23.916]                             next
[17:04:23.916]                           invokeRestart(restart)
[17:04:23.916]                           muffled <- TRUE
[17:04:23.916]                           break
[17:04:23.916]                         }
[17:04:23.916]                       }
[17:04:23.916]                     }
[17:04:23.916]                     invisible(muffled)
[17:04:23.916]                   }
[17:04:23.916]                   muffleCondition(cond)
[17:04:23.916]                 })
[17:04:23.916]             }))
[17:04:23.916]             future::FutureResult(value = ...future.value$value, 
[17:04:23.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.916]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.916]                     ...future.globalenv.names))
[17:04:23.916]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.916]         }, condition = base::local({
[17:04:23.916]             c <- base::c
[17:04:23.916]             inherits <- base::inherits
[17:04:23.916]             invokeRestart <- base::invokeRestart
[17:04:23.916]             length <- base::length
[17:04:23.916]             list <- base::list
[17:04:23.916]             seq.int <- base::seq.int
[17:04:23.916]             signalCondition <- base::signalCondition
[17:04:23.916]             sys.calls <- base::sys.calls
[17:04:23.916]             `[[` <- base::`[[`
[17:04:23.916]             `+` <- base::`+`
[17:04:23.916]             `<<-` <- base::`<<-`
[17:04:23.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.916]                   3L)]
[17:04:23.916]             }
[17:04:23.916]             function(cond) {
[17:04:23.916]                 is_error <- inherits(cond, "error")
[17:04:23.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.916]                   NULL)
[17:04:23.916]                 if (is_error) {
[17:04:23.916]                   sessionInformation <- function() {
[17:04:23.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.916]                       search = base::search(), system = base::Sys.info())
[17:04:23.916]                   }
[17:04:23.916]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.916]                     cond$call), session = sessionInformation(), 
[17:04:23.916]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.916]                   signalCondition(cond)
[17:04:23.916]                 }
[17:04:23.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.916]                 "immediateCondition"))) {
[17:04:23.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.916]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.916]                   if (TRUE && !signal) {
[17:04:23.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.916]                     {
[17:04:23.916]                       inherits <- base::inherits
[17:04:23.916]                       invokeRestart <- base::invokeRestart
[17:04:23.916]                       is.null <- base::is.null
[17:04:23.916]                       muffled <- FALSE
[17:04:23.916]                       if (inherits(cond, "message")) {
[17:04:23.916]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.916]                         if (muffled) 
[17:04:23.916]                           invokeRestart("muffleMessage")
[17:04:23.916]                       }
[17:04:23.916]                       else if (inherits(cond, "warning")) {
[17:04:23.916]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.916]                         if (muffled) 
[17:04:23.916]                           invokeRestart("muffleWarning")
[17:04:23.916]                       }
[17:04:23.916]                       else if (inherits(cond, "condition")) {
[17:04:23.916]                         if (!is.null(pattern)) {
[17:04:23.916]                           computeRestarts <- base::computeRestarts
[17:04:23.916]                           grepl <- base::grepl
[17:04:23.916]                           restarts <- computeRestarts(cond)
[17:04:23.916]                           for (restart in restarts) {
[17:04:23.916]                             name <- restart$name
[17:04:23.916]                             if (is.null(name)) 
[17:04:23.916]                               next
[17:04:23.916]                             if (!grepl(pattern, name)) 
[17:04:23.916]                               next
[17:04:23.916]                             invokeRestart(restart)
[17:04:23.916]                             muffled <- TRUE
[17:04:23.916]                             break
[17:04:23.916]                           }
[17:04:23.916]                         }
[17:04:23.916]                       }
[17:04:23.916]                       invisible(muffled)
[17:04:23.916]                     }
[17:04:23.916]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.916]                   }
[17:04:23.916]                 }
[17:04:23.916]                 else {
[17:04:23.916]                   if (TRUE) {
[17:04:23.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.916]                     {
[17:04:23.916]                       inherits <- base::inherits
[17:04:23.916]                       invokeRestart <- base::invokeRestart
[17:04:23.916]                       is.null <- base::is.null
[17:04:23.916]                       muffled <- FALSE
[17:04:23.916]                       if (inherits(cond, "message")) {
[17:04:23.916]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.916]                         if (muffled) 
[17:04:23.916]                           invokeRestart("muffleMessage")
[17:04:23.916]                       }
[17:04:23.916]                       else if (inherits(cond, "warning")) {
[17:04:23.916]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.916]                         if (muffled) 
[17:04:23.916]                           invokeRestart("muffleWarning")
[17:04:23.916]                       }
[17:04:23.916]                       else if (inherits(cond, "condition")) {
[17:04:23.916]                         if (!is.null(pattern)) {
[17:04:23.916]                           computeRestarts <- base::computeRestarts
[17:04:23.916]                           grepl <- base::grepl
[17:04:23.916]                           restarts <- computeRestarts(cond)
[17:04:23.916]                           for (restart in restarts) {
[17:04:23.916]                             name <- restart$name
[17:04:23.916]                             if (is.null(name)) 
[17:04:23.916]                               next
[17:04:23.916]                             if (!grepl(pattern, name)) 
[17:04:23.916]                               next
[17:04:23.916]                             invokeRestart(restart)
[17:04:23.916]                             muffled <- TRUE
[17:04:23.916]                             break
[17:04:23.916]                           }
[17:04:23.916]                         }
[17:04:23.916]                       }
[17:04:23.916]                       invisible(muffled)
[17:04:23.916]                     }
[17:04:23.916]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.916]                   }
[17:04:23.916]                 }
[17:04:23.916]             }
[17:04:23.916]         }))
[17:04:23.916]     }, error = function(ex) {
[17:04:23.916]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.916]                 ...future.rng), started = ...future.startTime, 
[17:04:23.916]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.916]             version = "1.8"), class = "FutureResult")
[17:04:23.916]     }, finally = {
[17:04:23.916]         if (!identical(...future.workdir, getwd())) 
[17:04:23.916]             setwd(...future.workdir)
[17:04:23.916]         {
[17:04:23.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.916]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.916]             }
[17:04:23.916]             base::options(...future.oldOptions)
[17:04:23.916]             if (.Platform$OS.type == "windows") {
[17:04:23.916]                 old_names <- names(...future.oldEnvVars)
[17:04:23.916]                 envs <- base::Sys.getenv()
[17:04:23.916]                 names <- names(envs)
[17:04:23.916]                 common <- intersect(names, old_names)
[17:04:23.916]                 added <- setdiff(names, old_names)
[17:04:23.916]                 removed <- setdiff(old_names, names)
[17:04:23.916]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.916]                   envs[common]]
[17:04:23.916]                 NAMES <- toupper(changed)
[17:04:23.916]                 args <- list()
[17:04:23.916]                 for (kk in seq_along(NAMES)) {
[17:04:23.916]                   name <- changed[[kk]]
[17:04:23.916]                   NAME <- NAMES[[kk]]
[17:04:23.916]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.916]                     next
[17:04:23.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.916]                 }
[17:04:23.916]                 NAMES <- toupper(added)
[17:04:23.916]                 for (kk in seq_along(NAMES)) {
[17:04:23.916]                   name <- added[[kk]]
[17:04:23.916]                   NAME <- NAMES[[kk]]
[17:04:23.916]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.916]                     next
[17:04:23.916]                   args[[name]] <- ""
[17:04:23.916]                 }
[17:04:23.916]                 NAMES <- toupper(removed)
[17:04:23.916]                 for (kk in seq_along(NAMES)) {
[17:04:23.916]                   name <- removed[[kk]]
[17:04:23.916]                   NAME <- NAMES[[kk]]
[17:04:23.916]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.916]                     next
[17:04:23.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.916]                 }
[17:04:23.916]                 if (length(args) > 0) 
[17:04:23.916]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.916]             }
[17:04:23.916]             else {
[17:04:23.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.916]             }
[17:04:23.916]             {
[17:04:23.916]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.916]                   0L) {
[17:04:23.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.916]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.916]                   base::options(opts)
[17:04:23.916]                 }
[17:04:23.916]                 {
[17:04:23.916]                   {
[17:04:23.916]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.916]                     NULL
[17:04:23.916]                   }
[17:04:23.916]                   options(future.plan = NULL)
[17:04:23.916]                   if (is.na(NA_character_)) 
[17:04:23.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.916]                     .init = FALSE)
[17:04:23.916]                 }
[17:04:23.916]             }
[17:04:23.916]         }
[17:04:23.916]     })
[17:04:23.916]     if (FALSE) {
[17:04:23.916]         base::sink(type = "output", split = FALSE)
[17:04:23.916]         if (NA) {
[17:04:23.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.916]         }
[17:04:23.916]         else {
[17:04:23.916]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.916]         }
[17:04:23.916]         base::close(...future.stdout)
[17:04:23.916]         ...future.stdout <- NULL
[17:04:23.916]     }
[17:04:23.916]     ...future.result$conditions <- ...future.conditions
[17:04:23.916]     ...future.result$finished <- base::Sys.time()
[17:04:23.916]     ...future.result
[17:04:23.916] }
[17:04:23.919] requestCore(): workers = 2
[17:04:23.921] MulticoreFuture started
[17:04:23.921] - Launch lazy future ... done
[17:04:23.921] run() for ‘MulticoreFuture’ ... done
[17:04:23.922] result() for MulticoreFuture ...
[17:04:23.922] plan(): Setting new future strategy stack:
[17:04:23.922] List of future strategies:
[17:04:23.922] 1. sequential:
[17:04:23.922]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.922]    - tweaked: FALSE
[17:04:23.922]    - call: NULL
[17:04:23.923] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:04:23.927] plan(): Setting new future strategy stack:
[17:04:23.928] List of future strategies:
[17:04:23.928] 1. multicore:
[17:04:23.928]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.928]    - tweaked: FALSE
[17:04:23.928]    - call: plan(strategy)
[17:04:23.933] plan(): nbrOfWorkers() = 2
[17:04:23.934] result() for MulticoreFuture ...
[17:04:23.934] result() for MulticoreFuture ... done
[17:04:23.934] result() for MulticoreFuture ... done
[17:04:23.934] result() for MulticoreFuture ...
[17:04:23.934] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:04:23.935] getGlobalsAndPackages() ...
[17:04:23.935] Searching for globals...
[17:04:23.936] - globals found: [1] ‘print’
[17:04:23.936] Searching for globals ... DONE
[17:04:23.936] Resolving globals: FALSE
[17:04:23.936] 
[17:04:23.937] 
[17:04:23.937] getGlobalsAndPackages() ... DONE
[17:04:23.937] run() for ‘Future’ ...
[17:04:23.937] - state: ‘created’
[17:04:23.937] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:04:23.942] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:23.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:04:23.942]   - Field: ‘label’
[17:04:23.942]   - Field: ‘local’
[17:04:23.942]   - Field: ‘owner’
[17:04:23.943]   - Field: ‘envir’
[17:04:23.943]   - Field: ‘workers’
[17:04:23.943]   - Field: ‘packages’
[17:04:23.943]   - Field: ‘gc’
[17:04:23.943]   - Field: ‘job’
[17:04:23.943]   - Field: ‘conditions’
[17:04:23.943]   - Field: ‘expr’
[17:04:23.943]   - Field: ‘uuid’
[17:04:23.944]   - Field: ‘seed’
[17:04:23.944]   - Field: ‘version’
[17:04:23.944]   - Field: ‘result’
[17:04:23.944]   - Field: ‘asynchronous’
[17:04:23.944]   - Field: ‘calls’
[17:04:23.944]   - Field: ‘globals’
[17:04:23.944]   - Field: ‘stdout’
[17:04:23.944]   - Field: ‘earlySignal’
[17:04:23.944]   - Field: ‘lazy’
[17:04:23.945]   - Field: ‘state’
[17:04:23.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:04:23.945] - Launch lazy future ...
[17:04:23.945] Packages needed by the future expression (n = 0): <none>
[17:04:23.945] Packages needed by future strategies (n = 0): <none>
[17:04:23.946] {
[17:04:23.946]     {
[17:04:23.946]         {
[17:04:23.946]             ...future.startTime <- base::Sys.time()
[17:04:23.946]             {
[17:04:23.946]                 {
[17:04:23.946]                   {
[17:04:23.946]                     {
[17:04:23.946]                       base::local({
[17:04:23.946]                         has_future <- base::requireNamespace("future", 
[17:04:23.946]                           quietly = TRUE)
[17:04:23.946]                         if (has_future) {
[17:04:23.946]                           ns <- base::getNamespace("future")
[17:04:23.946]                           version <- ns[[".package"]][["version"]]
[17:04:23.946]                           if (is.null(version)) 
[17:04:23.946]                             version <- utils::packageVersion("future")
[17:04:23.946]                         }
[17:04:23.946]                         else {
[17:04:23.946]                           version <- NULL
[17:04:23.946]                         }
[17:04:23.946]                         if (!has_future || version < "1.8.0") {
[17:04:23.946]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:23.946]                             "", base::R.version$version.string), 
[17:04:23.946]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:23.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:23.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:23.946]                               "release", "version")], collapse = " "), 
[17:04:23.946]                             hostname = base::Sys.info()[["nodename"]])
[17:04:23.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:23.946]                             info)
[17:04:23.946]                           info <- base::paste(info, collapse = "; ")
[17:04:23.946]                           if (!has_future) {
[17:04:23.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:23.946]                               info)
[17:04:23.946]                           }
[17:04:23.946]                           else {
[17:04:23.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:23.946]                               info, version)
[17:04:23.946]                           }
[17:04:23.946]                           base::stop(msg)
[17:04:23.946]                         }
[17:04:23.946]                       })
[17:04:23.946]                     }
[17:04:23.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:23.946]                     base::options(mc.cores = 1L)
[17:04:23.946]                   }
[17:04:23.946]                   ...future.strategy.old <- future::plan("list")
[17:04:23.946]                   options(future.plan = NULL)
[17:04:23.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:23.946]                 }
[17:04:23.946]                 ...future.workdir <- getwd()
[17:04:23.946]             }
[17:04:23.946]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:23.946]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:23.946]         }
[17:04:23.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:23.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:23.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:23.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:23.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:23.946]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:23.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:23.946]             base::names(...future.oldOptions))
[17:04:23.946]     }
[17:04:23.946]     if (FALSE) {
[17:04:23.946]     }
[17:04:23.946]     else {
[17:04:23.946]         if (TRUE) {
[17:04:23.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:23.946]                 open = "w")
[17:04:23.946]         }
[17:04:23.946]         else {
[17:04:23.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:23.946]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:23.946]         }
[17:04:23.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:23.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:23.946]             base::sink(type = "output", split = FALSE)
[17:04:23.946]             base::close(...future.stdout)
[17:04:23.946]         }, add = TRUE)
[17:04:23.946]     }
[17:04:23.946]     ...future.frame <- base::sys.nframe()
[17:04:23.946]     ...future.conditions <- base::list()
[17:04:23.946]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:23.946]     if (FALSE) {
[17:04:23.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:23.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:23.946]     }
[17:04:23.946]     ...future.result <- base::tryCatch({
[17:04:23.946]         base::withCallingHandlers({
[17:04:23.946]             ...future.value <- base::withVisible(base::local({
[17:04:23.946]                 withCallingHandlers({
[17:04:23.946]                   print(42)
[17:04:23.946]                 }, immediateCondition = function(cond) {
[17:04:23.946]                   save_rds <- function (object, pathname, ...) 
[17:04:23.946]                   {
[17:04:23.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:04:23.946]                     if (file_test("-f", pathname_tmp)) {
[17:04:23.946]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:04:23.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.946]                         fi_tmp[["mtime"]])
[17:04:23.946]                     }
[17:04:23.946]                     tryCatch({
[17:04:23.946]                       saveRDS(object, file = pathname_tmp, ...)
[17:04:23.946]                     }, error = function(ex) {
[17:04:23.946]                       msg <- conditionMessage(ex)
[17:04:23.946]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:04:23.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.946]                         fi_tmp[["mtime"]], msg)
[17:04:23.946]                       ex$message <- msg
[17:04:23.946]                       stop(ex)
[17:04:23.946]                     })
[17:04:23.946]                     stopifnot(file_test("-f", pathname_tmp))
[17:04:23.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:04:23.946]                     if (!res || file_test("-f", pathname_tmp)) {
[17:04:23.946]                       fi_tmp <- file.info(pathname_tmp)
[17:04:23.946]                       fi <- file.info(pathname)
[17:04:23.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:04:23.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:04:23.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:04:23.946]                         fi[["size"]], fi[["mtime"]])
[17:04:23.946]                       stop(msg)
[17:04:23.946]                     }
[17:04:23.946]                     invisible(pathname)
[17:04:23.946]                   }
[17:04:23.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:04:23.946]                     rootPath = tempdir()) 
[17:04:23.946]                   {
[17:04:23.946]                     obj <- list(time = Sys.time(), condition = cond)
[17:04:23.946]                     file <- tempfile(pattern = class(cond)[1], 
[17:04:23.946]                       tmpdir = path, fileext = ".rds")
[17:04:23.946]                     save_rds(obj, file)
[17:04:23.946]                   }
[17:04:23.946]                   saveImmediateCondition(cond, path = "/tmp/RtmpQeqnEl/.future/immediateConditions")
[17:04:23.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.946]                   {
[17:04:23.946]                     inherits <- base::inherits
[17:04:23.946]                     invokeRestart <- base::invokeRestart
[17:04:23.946]                     is.null <- base::is.null
[17:04:23.946]                     muffled <- FALSE
[17:04:23.946]                     if (inherits(cond, "message")) {
[17:04:23.946]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:23.946]                       if (muffled) 
[17:04:23.946]                         invokeRestart("muffleMessage")
[17:04:23.946]                     }
[17:04:23.946]                     else if (inherits(cond, "warning")) {
[17:04:23.946]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:23.946]                       if (muffled) 
[17:04:23.946]                         invokeRestart("muffleWarning")
[17:04:23.946]                     }
[17:04:23.946]                     else if (inherits(cond, "condition")) {
[17:04:23.946]                       if (!is.null(pattern)) {
[17:04:23.946]                         computeRestarts <- base::computeRestarts
[17:04:23.946]                         grepl <- base::grepl
[17:04:23.946]                         restarts <- computeRestarts(cond)
[17:04:23.946]                         for (restart in restarts) {
[17:04:23.946]                           name <- restart$name
[17:04:23.946]                           if (is.null(name)) 
[17:04:23.946]                             next
[17:04:23.946]                           if (!grepl(pattern, name)) 
[17:04:23.946]                             next
[17:04:23.946]                           invokeRestart(restart)
[17:04:23.946]                           muffled <- TRUE
[17:04:23.946]                           break
[17:04:23.946]                         }
[17:04:23.946]                       }
[17:04:23.946]                     }
[17:04:23.946]                     invisible(muffled)
[17:04:23.946]                   }
[17:04:23.946]                   muffleCondition(cond)
[17:04:23.946]                 })
[17:04:23.946]             }))
[17:04:23.946]             future::FutureResult(value = ...future.value$value, 
[17:04:23.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.946]                   ...future.rng), globalenv = if (FALSE) 
[17:04:23.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:23.946]                     ...future.globalenv.names))
[17:04:23.946]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:23.946]         }, condition = base::local({
[17:04:23.946]             c <- base::c
[17:04:23.946]             inherits <- base::inherits
[17:04:23.946]             invokeRestart <- base::invokeRestart
[17:04:23.946]             length <- base::length
[17:04:23.946]             list <- base::list
[17:04:23.946]             seq.int <- base::seq.int
[17:04:23.946]             signalCondition <- base::signalCondition
[17:04:23.946]             sys.calls <- base::sys.calls
[17:04:23.946]             `[[` <- base::`[[`
[17:04:23.946]             `+` <- base::`+`
[17:04:23.946]             `<<-` <- base::`<<-`
[17:04:23.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:23.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:23.946]                   3L)]
[17:04:23.946]             }
[17:04:23.946]             function(cond) {
[17:04:23.946]                 is_error <- inherits(cond, "error")
[17:04:23.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:23.946]                   NULL)
[17:04:23.946]                 if (is_error) {
[17:04:23.946]                   sessionInformation <- function() {
[17:04:23.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:23.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:23.946]                       search = base::search(), system = base::Sys.info())
[17:04:23.946]                   }
[17:04:23.946]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:23.946]                     cond$call), session = sessionInformation(), 
[17:04:23.946]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:23.946]                   signalCondition(cond)
[17:04:23.946]                 }
[17:04:23.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:23.946]                 "immediateCondition"))) {
[17:04:23.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:23.946]                   ...future.conditions[[length(...future.conditions) + 
[17:04:23.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:23.946]                   if (TRUE && !signal) {
[17:04:23.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.946]                     {
[17:04:23.946]                       inherits <- base::inherits
[17:04:23.946]                       invokeRestart <- base::invokeRestart
[17:04:23.946]                       is.null <- base::is.null
[17:04:23.946]                       muffled <- FALSE
[17:04:23.946]                       if (inherits(cond, "message")) {
[17:04:23.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.946]                         if (muffled) 
[17:04:23.946]                           invokeRestart("muffleMessage")
[17:04:23.946]                       }
[17:04:23.946]                       else if (inherits(cond, "warning")) {
[17:04:23.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.946]                         if (muffled) 
[17:04:23.946]                           invokeRestart("muffleWarning")
[17:04:23.946]                       }
[17:04:23.946]                       else if (inherits(cond, "condition")) {
[17:04:23.946]                         if (!is.null(pattern)) {
[17:04:23.946]                           computeRestarts <- base::computeRestarts
[17:04:23.946]                           grepl <- base::grepl
[17:04:23.946]                           restarts <- computeRestarts(cond)
[17:04:23.946]                           for (restart in restarts) {
[17:04:23.946]                             name <- restart$name
[17:04:23.946]                             if (is.null(name)) 
[17:04:23.946]                               next
[17:04:23.946]                             if (!grepl(pattern, name)) 
[17:04:23.946]                               next
[17:04:23.946]                             invokeRestart(restart)
[17:04:23.946]                             muffled <- TRUE
[17:04:23.946]                             break
[17:04:23.946]                           }
[17:04:23.946]                         }
[17:04:23.946]                       }
[17:04:23.946]                       invisible(muffled)
[17:04:23.946]                     }
[17:04:23.946]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.946]                   }
[17:04:23.946]                 }
[17:04:23.946]                 else {
[17:04:23.946]                   if (TRUE) {
[17:04:23.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:23.946]                     {
[17:04:23.946]                       inherits <- base::inherits
[17:04:23.946]                       invokeRestart <- base::invokeRestart
[17:04:23.946]                       is.null <- base::is.null
[17:04:23.946]                       muffled <- FALSE
[17:04:23.946]                       if (inherits(cond, "message")) {
[17:04:23.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:23.946]                         if (muffled) 
[17:04:23.946]                           invokeRestart("muffleMessage")
[17:04:23.946]                       }
[17:04:23.946]                       else if (inherits(cond, "warning")) {
[17:04:23.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:23.946]                         if (muffled) 
[17:04:23.946]                           invokeRestart("muffleWarning")
[17:04:23.946]                       }
[17:04:23.946]                       else if (inherits(cond, "condition")) {
[17:04:23.946]                         if (!is.null(pattern)) {
[17:04:23.946]                           computeRestarts <- base::computeRestarts
[17:04:23.946]                           grepl <- base::grepl
[17:04:23.946]                           restarts <- computeRestarts(cond)
[17:04:23.946]                           for (restart in restarts) {
[17:04:23.946]                             name <- restart$name
[17:04:23.946]                             if (is.null(name)) 
[17:04:23.946]                               next
[17:04:23.946]                             if (!grepl(pattern, name)) 
[17:04:23.946]                               next
[17:04:23.946]                             invokeRestart(restart)
[17:04:23.946]                             muffled <- TRUE
[17:04:23.946]                             break
[17:04:23.946]                           }
[17:04:23.946]                         }
[17:04:23.946]                       }
[17:04:23.946]                       invisible(muffled)
[17:04:23.946]                     }
[17:04:23.946]                     muffleCondition(cond, pattern = "^muffle")
[17:04:23.946]                   }
[17:04:23.946]                 }
[17:04:23.946]             }
[17:04:23.946]         }))
[17:04:23.946]     }, error = function(ex) {
[17:04:23.946]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:23.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:23.946]                 ...future.rng), started = ...future.startTime, 
[17:04:23.946]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:23.946]             version = "1.8"), class = "FutureResult")
[17:04:23.946]     }, finally = {
[17:04:23.946]         if (!identical(...future.workdir, getwd())) 
[17:04:23.946]             setwd(...future.workdir)
[17:04:23.946]         {
[17:04:23.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:23.946]                 ...future.oldOptions$nwarnings <- NULL
[17:04:23.946]             }
[17:04:23.946]             base::options(...future.oldOptions)
[17:04:23.946]             if (.Platform$OS.type == "windows") {
[17:04:23.946]                 old_names <- names(...future.oldEnvVars)
[17:04:23.946]                 envs <- base::Sys.getenv()
[17:04:23.946]                 names <- names(envs)
[17:04:23.946]                 common <- intersect(names, old_names)
[17:04:23.946]                 added <- setdiff(names, old_names)
[17:04:23.946]                 removed <- setdiff(old_names, names)
[17:04:23.946]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:23.946]                   envs[common]]
[17:04:23.946]                 NAMES <- toupper(changed)
[17:04:23.946]                 args <- list()
[17:04:23.946]                 for (kk in seq_along(NAMES)) {
[17:04:23.946]                   name <- changed[[kk]]
[17:04:23.946]                   NAME <- NAMES[[kk]]
[17:04:23.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.946]                     next
[17:04:23.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.946]                 }
[17:04:23.946]                 NAMES <- toupper(added)
[17:04:23.946]                 for (kk in seq_along(NAMES)) {
[17:04:23.946]                   name <- added[[kk]]
[17:04:23.946]                   NAME <- NAMES[[kk]]
[17:04:23.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.946]                     next
[17:04:23.946]                   args[[name]] <- ""
[17:04:23.946]                 }
[17:04:23.946]                 NAMES <- toupper(removed)
[17:04:23.946]                 for (kk in seq_along(NAMES)) {
[17:04:23.946]                   name <- removed[[kk]]
[17:04:23.946]                   NAME <- NAMES[[kk]]
[17:04:23.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:23.946]                     next
[17:04:23.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:23.946]                 }
[17:04:23.946]                 if (length(args) > 0) 
[17:04:23.946]                   base::do.call(base::Sys.setenv, args = args)
[17:04:23.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:23.946]             }
[17:04:23.946]             else {
[17:04:23.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:23.946]             }
[17:04:23.946]             {
[17:04:23.946]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:23.946]                   0L) {
[17:04:23.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:23.946]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:23.946]                   base::options(opts)
[17:04:23.946]                 }
[17:04:23.946]                 {
[17:04:23.946]                   {
[17:04:23.946]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:23.946]                     NULL
[17:04:23.946]                   }
[17:04:23.946]                   options(future.plan = NULL)
[17:04:23.946]                   if (is.na(NA_character_)) 
[17:04:23.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:23.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:23.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:23.946]                     .init = FALSE)
[17:04:23.946]                 }
[17:04:23.946]             }
[17:04:23.946]         }
[17:04:23.946]     })
[17:04:23.946]     if (TRUE) {
[17:04:23.946]         base::sink(type = "output", split = FALSE)
[17:04:23.946]         if (TRUE) {
[17:04:23.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:23.946]         }
[17:04:23.946]         else {
[17:04:23.946]             ...future.result["stdout"] <- base::list(NULL)
[17:04:23.946]         }
[17:04:23.946]         base::close(...future.stdout)
[17:04:23.946]         ...future.stdout <- NULL
[17:04:23.946]     }
[17:04:23.946]     ...future.result$conditions <- ...future.conditions
[17:04:23.946]     ...future.result$finished <- base::Sys.time()
[17:04:23.946]     ...future.result
[17:04:23.946] }
[17:04:23.949] requestCore(): workers = 2
[17:04:23.951] MulticoreFuture started
[17:04:23.951] - Launch lazy future ... done
[17:04:23.951] run() for ‘MulticoreFuture’ ... done
[17:04:23.952] result() for MulticoreFuture ...
[17:04:23.952] plan(): Setting new future strategy stack:
[17:04:23.952] List of future strategies:
[17:04:23.952] 1. sequential:
[17:04:23.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:23.952]    - tweaked: FALSE
[17:04:23.952]    - call: NULL
[17:04:23.953] plan(): nbrOfWorkers() = 1
[17:04:23.955] plan(): Setting new future strategy stack:
[17:04:23.956] List of future strategies:
[17:04:23.956] 1. multicore:
[17:04:23.956]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:04:23.956]    - tweaked: FALSE
[17:04:23.956]    - call: plan(strategy)
[17:04:23.961] plan(): nbrOfWorkers() = 2
[17:04:23.962] result() for MulticoreFuture ...
[17:04:23.962] result() for MulticoreFuture ... done
[17:04:23.962] result() for MulticoreFuture ... done
[17:04:23.962] result() for MulticoreFuture ...
[17:04:23.962] result() for MulticoreFuture ... done
[17:04:23.963] result() for MulticoreFuture ...
[17:04:23.963] result() for MulticoreFuture ... done
[1] 42
[17:04:23.963] result() for MulticoreFuture ...
[17:04:23.963] result() for MulticoreFuture ... done
multicore ... done
multisession ...
[17:04:23.964] plan(): Setting new future strategy stack:
[17:04:23.964] List of future strategies:
[17:04:23.964] 1. multisession:
[17:04:23.964]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:04:23.964]    - tweaked: FALSE
[17:04:23.964]    - call: plan(strategy)
[17:04:23.964] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:04:23.965] multisession:
[17:04:23.965] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:04:23.965] - tweaked: FALSE
[17:04:23.965] - call: plan(strategy)
[17:04:23.971] getGlobalsAndPackages() ...
[17:04:23.971] Not searching for globals
[17:04:23.972] - globals: [0] <none>
[17:04:23.972] getGlobalsAndPackages() ... DONE
[17:04:23.973] [local output] makeClusterPSOCK() ...
[17:04:24.021] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:04:24.022] [local output] Base port: 11562
[17:04:24.023] [local output] Getting setup options for 2 cluster nodes ...
[17:04:24.023] [local output]  - Node 1 of 2 ...
[17:04:24.023] [local output] localMachine=TRUE => revtunnel=FALSE

[17:04:24.024] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQeqnEl/worker.rank=1.parallelly.parent=50425.c4f91133ed57.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpQeqnEl/worker.rank=1.parallelly.parent=50425.c4f91133ed57.pid")'’
[17:04:24.215] - Possible to infer worker's PID: TRUE
[17:04:24.215] [local output] Rscript port: 11562

[17:04:24.216] [local output]  - Node 2 of 2 ...
[17:04:24.216] [local output] localMachine=TRUE => revtunnel=FALSE

[17:04:24.217] [local output] Rscript port: 11562

[17:04:24.217] [local output] Getting setup options for 2 cluster nodes ... done
[17:04:24.217] [local output]  - Parallel setup requested for some PSOCK nodes
[17:04:24.218] [local output] Setting up PSOCK nodes in parallel
[17:04:24.218] List of 36
[17:04:24.218]  $ worker          : chr "localhost"
[17:04:24.218]   ..- attr(*, "localhost")= logi TRUE
[17:04:24.218]  $ master          : chr "localhost"
[17:04:24.218]  $ port            : int 11562
[17:04:24.218]  $ connectTimeout  : num 120
[17:04:24.218]  $ timeout         : num 2592000
[17:04:24.218]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:04:24.218]  $ homogeneous     : logi TRUE
[17:04:24.218]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:04:24.218]  $ rscript_envs    : NULL
[17:04:24.218]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:04:24.218]  $ rscript_startup : NULL
[17:04:24.218]  $ rscript_sh      : chr "sh"
[17:04:24.218]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:04:24.218]  $ methods         : logi TRUE
[17:04:24.218]  $ socketOptions   : chr "no-delay"
[17:04:24.218]  $ useXDR          : logi FALSE
[17:04:24.218]  $ outfile         : chr "/dev/null"
[17:04:24.218]  $ renice          : int NA
[17:04:24.218]  $ rshcmd          : NULL
[17:04:24.218]  $ user            : chr(0) 
[17:04:24.218]  $ revtunnel       : logi FALSE
[17:04:24.218]  $ rshlogfile      : NULL
[17:04:24.218]  $ rshopts         : chr(0) 
[17:04:24.218]  $ rank            : int 1
[17:04:24.218]  $ manual          : logi FALSE
[17:04:24.218]  $ dryrun          : logi FALSE
[17:04:24.218]  $ quiet           : logi FALSE
[17:04:24.218]  $ setup_strategy  : chr "parallel"
[17:04:24.218]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:04:24.218]  $ pidfile         : chr "/tmp/RtmpQeqnEl/worker.rank=1.parallelly.parent=50425.c4f91133ed57.pid"
[17:04:24.218]  $ rshcmd_label    : NULL
[17:04:24.218]  $ rsh_call        : NULL
[17:04:24.218]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:04:24.218]  $ localMachine    : logi TRUE
[17:04:24.218]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:04:24.218]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:04:24.218]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:04:24.218]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:04:24.218]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:04:24.218]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:04:24.218]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:04:24.218]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:04:24.218]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:04:24.218]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:04:24.218]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:04:24.218]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:04:24.218]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:04:24.218]  $ arguments       :List of 28
[17:04:24.218]   ..$ worker          : chr "localhost"
[17:04:24.218]   ..$ master          : NULL
[17:04:24.218]   ..$ port            : int 11562
[17:04:24.218]   ..$ connectTimeout  : num 120
[17:04:24.218]   ..$ timeout         : num 2592000
[17:04:24.218]   ..$ rscript         : NULL
[17:04:24.218]   ..$ homogeneous     : NULL
[17:04:24.218]   ..$ rscript_args    : NULL
[17:04:24.218]   ..$ rscript_envs    : NULL
[17:04:24.218]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:04:24.218]   ..$ rscript_startup : NULL
[17:04:24.218]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:04:24.218]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:04:24.218]   ..$ methods         : logi TRUE
[17:04:24.218]   ..$ socketOptions   : chr "no-delay"
[17:04:24.218]   ..$ useXDR          : logi FALSE
[17:04:24.218]   ..$ outfile         : chr "/dev/null"
[17:04:24.218]   ..$ renice          : int NA
[17:04:24.218]   ..$ rshcmd          : NULL
[17:04:24.218]   ..$ user            : NULL
[17:04:24.218]   ..$ revtunnel       : logi NA
[17:04:24.218]   ..$ rshlogfile      : NULL
[17:04:24.218]   ..$ rshopts         : NULL
[17:04:24.218]   ..$ rank            : int 1
[17:04:24.218]   ..$ manual          : logi FALSE
[17:04:24.218]   ..$ dryrun          : logi FALSE
[17:04:24.218]   ..$ quiet           : logi FALSE
[17:04:24.218]   ..$ setup_strategy  : chr "parallel"
[17:04:24.218]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:04:24.234] [local output] System call to launch all workers:
[17:04:24.235] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQeqnEl/worker.rank=1.parallelly.parent=50425.c4f91133ed57.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11562 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:04:24.235] [local output] Starting PSOCK main server
[17:04:24.241] [local output] Workers launched
[17:04:24.241] [local output] Waiting for workers to connect back
[17:04:24.241]  - [local output] 0 workers out of 2 ready
[17:04:24.480]  - [local output] 0 workers out of 2 ready
[17:04:24.480]  - [local output] 1 workers out of 2 ready
[17:04:24.490]  - [local output] 1 workers out of 2 ready
[17:04:24.490]  - [local output] 2 workers out of 2 ready
[17:04:24.491] [local output] Launching of workers completed
[17:04:24.491] [local output] Collecting session information from workers
[17:04:24.492] [local output]  - Worker #1 of 2
[17:04:24.492] [local output]  - Worker #2 of 2
[17:04:24.492] [local output] makeClusterPSOCK() ... done
[17:04:24.505] Packages needed by the future expression (n = 0): <none>
[17:04:24.505] Packages needed by future strategies (n = 0): <none>
[17:04:24.505] {
[17:04:24.505]     {
[17:04:24.505]         {
[17:04:24.505]             ...future.startTime <- base::Sys.time()
[17:04:24.505]             {
[17:04:24.505]                 {
[17:04:24.505]                   {
[17:04:24.505]                     {
[17:04:24.505]                       base::local({
[17:04:24.505]                         has_future <- base::requireNamespace("future", 
[17:04:24.505]                           quietly = TRUE)
[17:04:24.505]                         if (has_future) {
[17:04:24.505]                           ns <- base::getNamespace("future")
[17:04:24.505]                           version <- ns[[".package"]][["version"]]
[17:04:24.505]                           if (is.null(version)) 
[17:04:24.505]                             version <- utils::packageVersion("future")
[17:04:24.505]                         }
[17:04:24.505]                         else {
[17:04:24.505]                           version <- NULL
[17:04:24.505]                         }
[17:04:24.505]                         if (!has_future || version < "1.8.0") {
[17:04:24.505]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.505]                             "", base::R.version$version.string), 
[17:04:24.505]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:24.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:24.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.505]                               "release", "version")], collapse = " "), 
[17:04:24.505]                             hostname = base::Sys.info()[["nodename"]])
[17:04:24.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.505]                             info)
[17:04:24.505]                           info <- base::paste(info, collapse = "; ")
[17:04:24.505]                           if (!has_future) {
[17:04:24.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.505]                               info)
[17:04:24.505]                           }
[17:04:24.505]                           else {
[17:04:24.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.505]                               info, version)
[17:04:24.505]                           }
[17:04:24.505]                           base::stop(msg)
[17:04:24.505]                         }
[17:04:24.505]                       })
[17:04:24.505]                     }
[17:04:24.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.505]                     base::options(mc.cores = 1L)
[17:04:24.505]                   }
[17:04:24.505]                   ...future.strategy.old <- future::plan("list")
[17:04:24.505]                   options(future.plan = NULL)
[17:04:24.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.505]                 }
[17:04:24.505]                 ...future.workdir <- getwd()
[17:04:24.505]             }
[17:04:24.505]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.505]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.505]         }
[17:04:24.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.505]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.505]             base::names(...future.oldOptions))
[17:04:24.505]     }
[17:04:24.505]     if (FALSE) {
[17:04:24.505]     }
[17:04:24.505]     else {
[17:04:24.505]         if (TRUE) {
[17:04:24.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.505]                 open = "w")
[17:04:24.505]         }
[17:04:24.505]         else {
[17:04:24.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.505]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.505]         }
[17:04:24.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.505]             base::sink(type = "output", split = FALSE)
[17:04:24.505]             base::close(...future.stdout)
[17:04:24.505]         }, add = TRUE)
[17:04:24.505]     }
[17:04:24.505]     ...future.frame <- base::sys.nframe()
[17:04:24.505]     ...future.conditions <- base::list()
[17:04:24.505]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.505]     if (FALSE) {
[17:04:24.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.505]     }
[17:04:24.505]     ...future.result <- base::tryCatch({
[17:04:24.505]         base::withCallingHandlers({
[17:04:24.505]             ...future.value <- base::withVisible(base::local({
[17:04:24.505]                 ...future.makeSendCondition <- base::local({
[17:04:24.505]                   sendCondition <- NULL
[17:04:24.505]                   function(frame = 1L) {
[17:04:24.505]                     if (is.function(sendCondition)) 
[17:04:24.505]                       return(sendCondition)
[17:04:24.505]                     ns <- getNamespace("parallel")
[17:04:24.505]                     if (exists("sendData", mode = "function", 
[17:04:24.505]                       envir = ns)) {
[17:04:24.505]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.505]                         envir = ns)
[17:04:24.505]                       envir <- sys.frame(frame)
[17:04:24.505]                       master <- NULL
[17:04:24.505]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.505]                         !identical(envir, emptyenv())) {
[17:04:24.505]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.505]                           inherits = FALSE)) {
[17:04:24.505]                           master <- get("master", mode = "list", 
[17:04:24.505]                             envir = envir, inherits = FALSE)
[17:04:24.505]                           if (inherits(master, c("SOCKnode", 
[17:04:24.505]                             "SOCK0node"))) {
[17:04:24.505]                             sendCondition <<- function(cond) {
[17:04:24.505]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.505]                                 success = TRUE)
[17:04:24.505]                               parallel_sendData(master, data)
[17:04:24.505]                             }
[17:04:24.505]                             return(sendCondition)
[17:04:24.505]                           }
[17:04:24.505]                         }
[17:04:24.505]                         frame <- frame + 1L
[17:04:24.505]                         envir <- sys.frame(frame)
[17:04:24.505]                       }
[17:04:24.505]                     }
[17:04:24.505]                     sendCondition <<- function(cond) NULL
[17:04:24.505]                   }
[17:04:24.505]                 })
[17:04:24.505]                 withCallingHandlers({
[17:04:24.505]                   NA
[17:04:24.505]                 }, immediateCondition = function(cond) {
[17:04:24.505]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.505]                   sendCondition(cond)
[17:04:24.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.505]                   {
[17:04:24.505]                     inherits <- base::inherits
[17:04:24.505]                     invokeRestart <- base::invokeRestart
[17:04:24.505]                     is.null <- base::is.null
[17:04:24.505]                     muffled <- FALSE
[17:04:24.505]                     if (inherits(cond, "message")) {
[17:04:24.505]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.505]                       if (muffled) 
[17:04:24.505]                         invokeRestart("muffleMessage")
[17:04:24.505]                     }
[17:04:24.505]                     else if (inherits(cond, "warning")) {
[17:04:24.505]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.505]                       if (muffled) 
[17:04:24.505]                         invokeRestart("muffleWarning")
[17:04:24.505]                     }
[17:04:24.505]                     else if (inherits(cond, "condition")) {
[17:04:24.505]                       if (!is.null(pattern)) {
[17:04:24.505]                         computeRestarts <- base::computeRestarts
[17:04:24.505]                         grepl <- base::grepl
[17:04:24.505]                         restarts <- computeRestarts(cond)
[17:04:24.505]                         for (restart in restarts) {
[17:04:24.505]                           name <- restart$name
[17:04:24.505]                           if (is.null(name)) 
[17:04:24.505]                             next
[17:04:24.505]                           if (!grepl(pattern, name)) 
[17:04:24.505]                             next
[17:04:24.505]                           invokeRestart(restart)
[17:04:24.505]                           muffled <- TRUE
[17:04:24.505]                           break
[17:04:24.505]                         }
[17:04:24.505]                       }
[17:04:24.505]                     }
[17:04:24.505]                     invisible(muffled)
[17:04:24.505]                   }
[17:04:24.505]                   muffleCondition(cond)
[17:04:24.505]                 })
[17:04:24.505]             }))
[17:04:24.505]             future::FutureResult(value = ...future.value$value, 
[17:04:24.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.505]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.505]                     ...future.globalenv.names))
[17:04:24.505]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.505]         }, condition = base::local({
[17:04:24.505]             c <- base::c
[17:04:24.505]             inherits <- base::inherits
[17:04:24.505]             invokeRestart <- base::invokeRestart
[17:04:24.505]             length <- base::length
[17:04:24.505]             list <- base::list
[17:04:24.505]             seq.int <- base::seq.int
[17:04:24.505]             signalCondition <- base::signalCondition
[17:04:24.505]             sys.calls <- base::sys.calls
[17:04:24.505]             `[[` <- base::`[[`
[17:04:24.505]             `+` <- base::`+`
[17:04:24.505]             `<<-` <- base::`<<-`
[17:04:24.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.505]                   3L)]
[17:04:24.505]             }
[17:04:24.505]             function(cond) {
[17:04:24.505]                 is_error <- inherits(cond, "error")
[17:04:24.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.505]                   NULL)
[17:04:24.505]                 if (is_error) {
[17:04:24.505]                   sessionInformation <- function() {
[17:04:24.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.505]                       search = base::search(), system = base::Sys.info())
[17:04:24.505]                   }
[17:04:24.505]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.505]                     cond$call), session = sessionInformation(), 
[17:04:24.505]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.505]                   signalCondition(cond)
[17:04:24.505]                 }
[17:04:24.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.505]                 "immediateCondition"))) {
[17:04:24.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.505]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.505]                   if (TRUE && !signal) {
[17:04:24.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.505]                     {
[17:04:24.505]                       inherits <- base::inherits
[17:04:24.505]                       invokeRestart <- base::invokeRestart
[17:04:24.505]                       is.null <- base::is.null
[17:04:24.505]                       muffled <- FALSE
[17:04:24.505]                       if (inherits(cond, "message")) {
[17:04:24.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.505]                         if (muffled) 
[17:04:24.505]                           invokeRestart("muffleMessage")
[17:04:24.505]                       }
[17:04:24.505]                       else if (inherits(cond, "warning")) {
[17:04:24.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.505]                         if (muffled) 
[17:04:24.505]                           invokeRestart("muffleWarning")
[17:04:24.505]                       }
[17:04:24.505]                       else if (inherits(cond, "condition")) {
[17:04:24.505]                         if (!is.null(pattern)) {
[17:04:24.505]                           computeRestarts <- base::computeRestarts
[17:04:24.505]                           grepl <- base::grepl
[17:04:24.505]                           restarts <- computeRestarts(cond)
[17:04:24.505]                           for (restart in restarts) {
[17:04:24.505]                             name <- restart$name
[17:04:24.505]                             if (is.null(name)) 
[17:04:24.505]                               next
[17:04:24.505]                             if (!grepl(pattern, name)) 
[17:04:24.505]                               next
[17:04:24.505]                             invokeRestart(restart)
[17:04:24.505]                             muffled <- TRUE
[17:04:24.505]                             break
[17:04:24.505]                           }
[17:04:24.505]                         }
[17:04:24.505]                       }
[17:04:24.505]                       invisible(muffled)
[17:04:24.505]                     }
[17:04:24.505]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.505]                   }
[17:04:24.505]                 }
[17:04:24.505]                 else {
[17:04:24.505]                   if (TRUE) {
[17:04:24.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.505]                     {
[17:04:24.505]                       inherits <- base::inherits
[17:04:24.505]                       invokeRestart <- base::invokeRestart
[17:04:24.505]                       is.null <- base::is.null
[17:04:24.505]                       muffled <- FALSE
[17:04:24.505]                       if (inherits(cond, "message")) {
[17:04:24.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.505]                         if (muffled) 
[17:04:24.505]                           invokeRestart("muffleMessage")
[17:04:24.505]                       }
[17:04:24.505]                       else if (inherits(cond, "warning")) {
[17:04:24.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.505]                         if (muffled) 
[17:04:24.505]                           invokeRestart("muffleWarning")
[17:04:24.505]                       }
[17:04:24.505]                       else if (inherits(cond, "condition")) {
[17:04:24.505]                         if (!is.null(pattern)) {
[17:04:24.505]                           computeRestarts <- base::computeRestarts
[17:04:24.505]                           grepl <- base::grepl
[17:04:24.505]                           restarts <- computeRestarts(cond)
[17:04:24.505]                           for (restart in restarts) {
[17:04:24.505]                             name <- restart$name
[17:04:24.505]                             if (is.null(name)) 
[17:04:24.505]                               next
[17:04:24.505]                             if (!grepl(pattern, name)) 
[17:04:24.505]                               next
[17:04:24.505]                             invokeRestart(restart)
[17:04:24.505]                             muffled <- TRUE
[17:04:24.505]                             break
[17:04:24.505]                           }
[17:04:24.505]                         }
[17:04:24.505]                       }
[17:04:24.505]                       invisible(muffled)
[17:04:24.505]                     }
[17:04:24.505]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.505]                   }
[17:04:24.505]                 }
[17:04:24.505]             }
[17:04:24.505]         }))
[17:04:24.505]     }, error = function(ex) {
[17:04:24.505]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.505]                 ...future.rng), started = ...future.startTime, 
[17:04:24.505]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.505]             version = "1.8"), class = "FutureResult")
[17:04:24.505]     }, finally = {
[17:04:24.505]         if (!identical(...future.workdir, getwd())) 
[17:04:24.505]             setwd(...future.workdir)
[17:04:24.505]         {
[17:04:24.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.505]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.505]             }
[17:04:24.505]             base::options(...future.oldOptions)
[17:04:24.505]             if (.Platform$OS.type == "windows") {
[17:04:24.505]                 old_names <- names(...future.oldEnvVars)
[17:04:24.505]                 envs <- base::Sys.getenv()
[17:04:24.505]                 names <- names(envs)
[17:04:24.505]                 common <- intersect(names, old_names)
[17:04:24.505]                 added <- setdiff(names, old_names)
[17:04:24.505]                 removed <- setdiff(old_names, names)
[17:04:24.505]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.505]                   envs[common]]
[17:04:24.505]                 NAMES <- toupper(changed)
[17:04:24.505]                 args <- list()
[17:04:24.505]                 for (kk in seq_along(NAMES)) {
[17:04:24.505]                   name <- changed[[kk]]
[17:04:24.505]                   NAME <- NAMES[[kk]]
[17:04:24.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.505]                     next
[17:04:24.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.505]                 }
[17:04:24.505]                 NAMES <- toupper(added)
[17:04:24.505]                 for (kk in seq_along(NAMES)) {
[17:04:24.505]                   name <- added[[kk]]
[17:04:24.505]                   NAME <- NAMES[[kk]]
[17:04:24.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.505]                     next
[17:04:24.505]                   args[[name]] <- ""
[17:04:24.505]                 }
[17:04:24.505]                 NAMES <- toupper(removed)
[17:04:24.505]                 for (kk in seq_along(NAMES)) {
[17:04:24.505]                   name <- removed[[kk]]
[17:04:24.505]                   NAME <- NAMES[[kk]]
[17:04:24.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.505]                     next
[17:04:24.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.505]                 }
[17:04:24.505]                 if (length(args) > 0) 
[17:04:24.505]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.505]             }
[17:04:24.505]             else {
[17:04:24.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.505]             }
[17:04:24.505]             {
[17:04:24.505]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.505]                   0L) {
[17:04:24.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.505]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.505]                   base::options(opts)
[17:04:24.505]                 }
[17:04:24.505]                 {
[17:04:24.505]                   {
[17:04:24.505]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.505]                     NULL
[17:04:24.505]                   }
[17:04:24.505]                   options(future.plan = NULL)
[17:04:24.505]                   if (is.na(NA_character_)) 
[17:04:24.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.505]                     .init = FALSE)
[17:04:24.505]                 }
[17:04:24.505]             }
[17:04:24.505]         }
[17:04:24.505]     })
[17:04:24.505]     if (TRUE) {
[17:04:24.505]         base::sink(type = "output", split = FALSE)
[17:04:24.505]         if (TRUE) {
[17:04:24.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.505]         }
[17:04:24.505]         else {
[17:04:24.505]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.505]         }
[17:04:24.505]         base::close(...future.stdout)
[17:04:24.505]         ...future.stdout <- NULL
[17:04:24.505]     }
[17:04:24.505]     ...future.result$conditions <- ...future.conditions
[17:04:24.505]     ...future.result$finished <- base::Sys.time()
[17:04:24.505]     ...future.result
[17:04:24.505] }
[17:04:24.558] MultisessionFuture started
[17:04:24.558] result() for ClusterFuture ...
[17:04:24.559] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.559] - Validating connection of MultisessionFuture
[17:04:24.590] - received message: FutureResult
[17:04:24.591] - Received FutureResult
[17:04:24.591] - Erased future from FutureRegistry
[17:04:24.591] result() for ClusterFuture ...
[17:04:24.591] - result already collected: FutureResult
[17:04:24.591] result() for ClusterFuture ... done
[17:04:24.591] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:24.591] result() for ClusterFuture ... done
[17:04:24.591] result() for ClusterFuture ...
[17:04:24.591] - result already collected: FutureResult
[17:04:24.591] result() for ClusterFuture ... done
[17:04:24.592] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:04:24.596] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[17:04:24.596] getGlobalsAndPackages() ...
[17:04:24.596] Searching for globals...
[17:04:24.600] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:24.600] Searching for globals ... DONE
[17:04:24.600] Resolving globals: FALSE
[17:04:24.601] 
[17:04:24.601] - packages: [1] ‘utils’
[17:04:24.601] getGlobalsAndPackages() ... DONE
[17:04:24.601] run() for ‘Future’ ...
[17:04:24.601] - state: ‘created’
[17:04:24.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:24.616] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:24.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:24.616]   - Field: ‘node’
[17:04:24.616]   - Field: ‘label’
[17:04:24.616]   - Field: ‘local’
[17:04:24.616]   - Field: ‘owner’
[17:04:24.617]   - Field: ‘envir’
[17:04:24.617]   - Field: ‘workers’
[17:04:24.617]   - Field: ‘packages’
[17:04:24.617]   - Field: ‘gc’
[17:04:24.617]   - Field: ‘conditions’
[17:04:24.617]   - Field: ‘persistent’
[17:04:24.617]   - Field: ‘expr’
[17:04:24.617]   - Field: ‘uuid’
[17:04:24.617]   - Field: ‘seed’
[17:04:24.617]   - Field: ‘version’
[17:04:24.618]   - Field: ‘result’
[17:04:24.618]   - Field: ‘asynchronous’
[17:04:24.618]   - Field: ‘calls’
[17:04:24.618]   - Field: ‘globals’
[17:04:24.618]   - Field: ‘stdout’
[17:04:24.618]   - Field: ‘earlySignal’
[17:04:24.618]   - Field: ‘lazy’
[17:04:24.618]   - Field: ‘state’
[17:04:24.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:24.619] - Launch lazy future ...
[17:04:24.619] Packages needed by the future expression (n = 1): ‘utils’
[17:04:24.619] Packages needed by future strategies (n = 0): <none>
[17:04:24.620] {
[17:04:24.620]     {
[17:04:24.620]         {
[17:04:24.620]             ...future.startTime <- base::Sys.time()
[17:04:24.620]             {
[17:04:24.620]                 {
[17:04:24.620]                   {
[17:04:24.620]                     {
[17:04:24.620]                       {
[17:04:24.620]                         base::local({
[17:04:24.620]                           has_future <- base::requireNamespace("future", 
[17:04:24.620]                             quietly = TRUE)
[17:04:24.620]                           if (has_future) {
[17:04:24.620]                             ns <- base::getNamespace("future")
[17:04:24.620]                             version <- ns[[".package"]][["version"]]
[17:04:24.620]                             if (is.null(version)) 
[17:04:24.620]                               version <- utils::packageVersion("future")
[17:04:24.620]                           }
[17:04:24.620]                           else {
[17:04:24.620]                             version <- NULL
[17:04:24.620]                           }
[17:04:24.620]                           if (!has_future || version < "1.8.0") {
[17:04:24.620]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.620]                               "", base::R.version$version.string), 
[17:04:24.620]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:24.620]                                 base::R.version$platform, 8 * 
[17:04:24.620]                                   base::.Machine$sizeof.pointer), 
[17:04:24.620]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.620]                                 "release", "version")], collapse = " "), 
[17:04:24.620]                               hostname = base::Sys.info()[["nodename"]])
[17:04:24.620]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.620]                               info)
[17:04:24.620]                             info <- base::paste(info, collapse = "; ")
[17:04:24.620]                             if (!has_future) {
[17:04:24.620]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.620]                                 info)
[17:04:24.620]                             }
[17:04:24.620]                             else {
[17:04:24.620]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.620]                                 info, version)
[17:04:24.620]                             }
[17:04:24.620]                             base::stop(msg)
[17:04:24.620]                           }
[17:04:24.620]                         })
[17:04:24.620]                       }
[17:04:24.620]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.620]                       base::options(mc.cores = 1L)
[17:04:24.620]                     }
[17:04:24.620]                     base::local({
[17:04:24.620]                       for (pkg in "utils") {
[17:04:24.620]                         base::loadNamespace(pkg)
[17:04:24.620]                         base::library(pkg, character.only = TRUE)
[17:04:24.620]                       }
[17:04:24.620]                     })
[17:04:24.620]                   }
[17:04:24.620]                   ...future.strategy.old <- future::plan("list")
[17:04:24.620]                   options(future.plan = NULL)
[17:04:24.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.620]                 }
[17:04:24.620]                 ...future.workdir <- getwd()
[17:04:24.620]             }
[17:04:24.620]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.620]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.620]         }
[17:04:24.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.620]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.620]             base::names(...future.oldOptions))
[17:04:24.620]     }
[17:04:24.620]     if (FALSE) {
[17:04:24.620]     }
[17:04:24.620]     else {
[17:04:24.620]         if (TRUE) {
[17:04:24.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.620]                 open = "w")
[17:04:24.620]         }
[17:04:24.620]         else {
[17:04:24.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.620]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.620]         }
[17:04:24.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.620]             base::sink(type = "output", split = FALSE)
[17:04:24.620]             base::close(...future.stdout)
[17:04:24.620]         }, add = TRUE)
[17:04:24.620]     }
[17:04:24.620]     ...future.frame <- base::sys.nframe()
[17:04:24.620]     ...future.conditions <- base::list()
[17:04:24.620]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.620]     if (FALSE) {
[17:04:24.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.620]     }
[17:04:24.620]     ...future.result <- base::tryCatch({
[17:04:24.620]         base::withCallingHandlers({
[17:04:24.620]             ...future.value <- base::withVisible(base::local({
[17:04:24.620]                 ...future.makeSendCondition <- base::local({
[17:04:24.620]                   sendCondition <- NULL
[17:04:24.620]                   function(frame = 1L) {
[17:04:24.620]                     if (is.function(sendCondition)) 
[17:04:24.620]                       return(sendCondition)
[17:04:24.620]                     ns <- getNamespace("parallel")
[17:04:24.620]                     if (exists("sendData", mode = "function", 
[17:04:24.620]                       envir = ns)) {
[17:04:24.620]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.620]                         envir = ns)
[17:04:24.620]                       envir <- sys.frame(frame)
[17:04:24.620]                       master <- NULL
[17:04:24.620]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.620]                         !identical(envir, emptyenv())) {
[17:04:24.620]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.620]                           inherits = FALSE)) {
[17:04:24.620]                           master <- get("master", mode = "list", 
[17:04:24.620]                             envir = envir, inherits = FALSE)
[17:04:24.620]                           if (inherits(master, c("SOCKnode", 
[17:04:24.620]                             "SOCK0node"))) {
[17:04:24.620]                             sendCondition <<- function(cond) {
[17:04:24.620]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.620]                                 success = TRUE)
[17:04:24.620]                               parallel_sendData(master, data)
[17:04:24.620]                             }
[17:04:24.620]                             return(sendCondition)
[17:04:24.620]                           }
[17:04:24.620]                         }
[17:04:24.620]                         frame <- frame + 1L
[17:04:24.620]                         envir <- sys.frame(frame)
[17:04:24.620]                       }
[17:04:24.620]                     }
[17:04:24.620]                     sendCondition <<- function(cond) NULL
[17:04:24.620]                   }
[17:04:24.620]                 })
[17:04:24.620]                 withCallingHandlers({
[17:04:24.620]                   {
[17:04:24.620]                     print(1:50)
[17:04:24.620]                     str(1:50)
[17:04:24.620]                     cat(letters, sep = "-")
[17:04:24.620]                     cat(1:6, collapse = "\n")
[17:04:24.620]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:24.620]                     42L
[17:04:24.620]                   }
[17:04:24.620]                 }, immediateCondition = function(cond) {
[17:04:24.620]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.620]                   sendCondition(cond)
[17:04:24.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.620]                   {
[17:04:24.620]                     inherits <- base::inherits
[17:04:24.620]                     invokeRestart <- base::invokeRestart
[17:04:24.620]                     is.null <- base::is.null
[17:04:24.620]                     muffled <- FALSE
[17:04:24.620]                     if (inherits(cond, "message")) {
[17:04:24.620]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.620]                       if (muffled) 
[17:04:24.620]                         invokeRestart("muffleMessage")
[17:04:24.620]                     }
[17:04:24.620]                     else if (inherits(cond, "warning")) {
[17:04:24.620]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.620]                       if (muffled) 
[17:04:24.620]                         invokeRestart("muffleWarning")
[17:04:24.620]                     }
[17:04:24.620]                     else if (inherits(cond, "condition")) {
[17:04:24.620]                       if (!is.null(pattern)) {
[17:04:24.620]                         computeRestarts <- base::computeRestarts
[17:04:24.620]                         grepl <- base::grepl
[17:04:24.620]                         restarts <- computeRestarts(cond)
[17:04:24.620]                         for (restart in restarts) {
[17:04:24.620]                           name <- restart$name
[17:04:24.620]                           if (is.null(name)) 
[17:04:24.620]                             next
[17:04:24.620]                           if (!grepl(pattern, name)) 
[17:04:24.620]                             next
[17:04:24.620]                           invokeRestart(restart)
[17:04:24.620]                           muffled <- TRUE
[17:04:24.620]                           break
[17:04:24.620]                         }
[17:04:24.620]                       }
[17:04:24.620]                     }
[17:04:24.620]                     invisible(muffled)
[17:04:24.620]                   }
[17:04:24.620]                   muffleCondition(cond)
[17:04:24.620]                 })
[17:04:24.620]             }))
[17:04:24.620]             future::FutureResult(value = ...future.value$value, 
[17:04:24.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.620]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.620]                     ...future.globalenv.names))
[17:04:24.620]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.620]         }, condition = base::local({
[17:04:24.620]             c <- base::c
[17:04:24.620]             inherits <- base::inherits
[17:04:24.620]             invokeRestart <- base::invokeRestart
[17:04:24.620]             length <- base::length
[17:04:24.620]             list <- base::list
[17:04:24.620]             seq.int <- base::seq.int
[17:04:24.620]             signalCondition <- base::signalCondition
[17:04:24.620]             sys.calls <- base::sys.calls
[17:04:24.620]             `[[` <- base::`[[`
[17:04:24.620]             `+` <- base::`+`
[17:04:24.620]             `<<-` <- base::`<<-`
[17:04:24.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.620]                   3L)]
[17:04:24.620]             }
[17:04:24.620]             function(cond) {
[17:04:24.620]                 is_error <- inherits(cond, "error")
[17:04:24.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.620]                   NULL)
[17:04:24.620]                 if (is_error) {
[17:04:24.620]                   sessionInformation <- function() {
[17:04:24.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.620]                       search = base::search(), system = base::Sys.info())
[17:04:24.620]                   }
[17:04:24.620]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.620]                     cond$call), session = sessionInformation(), 
[17:04:24.620]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.620]                   signalCondition(cond)
[17:04:24.620]                 }
[17:04:24.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.620]                 "immediateCondition"))) {
[17:04:24.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.620]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.620]                   if (TRUE && !signal) {
[17:04:24.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.620]                     {
[17:04:24.620]                       inherits <- base::inherits
[17:04:24.620]                       invokeRestart <- base::invokeRestart
[17:04:24.620]                       is.null <- base::is.null
[17:04:24.620]                       muffled <- FALSE
[17:04:24.620]                       if (inherits(cond, "message")) {
[17:04:24.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.620]                         if (muffled) 
[17:04:24.620]                           invokeRestart("muffleMessage")
[17:04:24.620]                       }
[17:04:24.620]                       else if (inherits(cond, "warning")) {
[17:04:24.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.620]                         if (muffled) 
[17:04:24.620]                           invokeRestart("muffleWarning")
[17:04:24.620]                       }
[17:04:24.620]                       else if (inherits(cond, "condition")) {
[17:04:24.620]                         if (!is.null(pattern)) {
[17:04:24.620]                           computeRestarts <- base::computeRestarts
[17:04:24.620]                           grepl <- base::grepl
[17:04:24.620]                           restarts <- computeRestarts(cond)
[17:04:24.620]                           for (restart in restarts) {
[17:04:24.620]                             name <- restart$name
[17:04:24.620]                             if (is.null(name)) 
[17:04:24.620]                               next
[17:04:24.620]                             if (!grepl(pattern, name)) 
[17:04:24.620]                               next
[17:04:24.620]                             invokeRestart(restart)
[17:04:24.620]                             muffled <- TRUE
[17:04:24.620]                             break
[17:04:24.620]                           }
[17:04:24.620]                         }
[17:04:24.620]                       }
[17:04:24.620]                       invisible(muffled)
[17:04:24.620]                     }
[17:04:24.620]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.620]                   }
[17:04:24.620]                 }
[17:04:24.620]                 else {
[17:04:24.620]                   if (TRUE) {
[17:04:24.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.620]                     {
[17:04:24.620]                       inherits <- base::inherits
[17:04:24.620]                       invokeRestart <- base::invokeRestart
[17:04:24.620]                       is.null <- base::is.null
[17:04:24.620]                       muffled <- FALSE
[17:04:24.620]                       if (inherits(cond, "message")) {
[17:04:24.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.620]                         if (muffled) 
[17:04:24.620]                           invokeRestart("muffleMessage")
[17:04:24.620]                       }
[17:04:24.620]                       else if (inherits(cond, "warning")) {
[17:04:24.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.620]                         if (muffled) 
[17:04:24.620]                           invokeRestart("muffleWarning")
[17:04:24.620]                       }
[17:04:24.620]                       else if (inherits(cond, "condition")) {
[17:04:24.620]                         if (!is.null(pattern)) {
[17:04:24.620]                           computeRestarts <- base::computeRestarts
[17:04:24.620]                           grepl <- base::grepl
[17:04:24.620]                           restarts <- computeRestarts(cond)
[17:04:24.620]                           for (restart in restarts) {
[17:04:24.620]                             name <- restart$name
[17:04:24.620]                             if (is.null(name)) 
[17:04:24.620]                               next
[17:04:24.620]                             if (!grepl(pattern, name)) 
[17:04:24.620]                               next
[17:04:24.620]                             invokeRestart(restart)
[17:04:24.620]                             muffled <- TRUE
[17:04:24.620]                             break
[17:04:24.620]                           }
[17:04:24.620]                         }
[17:04:24.620]                       }
[17:04:24.620]                       invisible(muffled)
[17:04:24.620]                     }
[17:04:24.620]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.620]                   }
[17:04:24.620]                 }
[17:04:24.620]             }
[17:04:24.620]         }))
[17:04:24.620]     }, error = function(ex) {
[17:04:24.620]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.620]                 ...future.rng), started = ...future.startTime, 
[17:04:24.620]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.620]             version = "1.8"), class = "FutureResult")
[17:04:24.620]     }, finally = {
[17:04:24.620]         if (!identical(...future.workdir, getwd())) 
[17:04:24.620]             setwd(...future.workdir)
[17:04:24.620]         {
[17:04:24.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.620]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.620]             }
[17:04:24.620]             base::options(...future.oldOptions)
[17:04:24.620]             if (.Platform$OS.type == "windows") {
[17:04:24.620]                 old_names <- names(...future.oldEnvVars)
[17:04:24.620]                 envs <- base::Sys.getenv()
[17:04:24.620]                 names <- names(envs)
[17:04:24.620]                 common <- intersect(names, old_names)
[17:04:24.620]                 added <- setdiff(names, old_names)
[17:04:24.620]                 removed <- setdiff(old_names, names)
[17:04:24.620]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.620]                   envs[common]]
[17:04:24.620]                 NAMES <- toupper(changed)
[17:04:24.620]                 args <- list()
[17:04:24.620]                 for (kk in seq_along(NAMES)) {
[17:04:24.620]                   name <- changed[[kk]]
[17:04:24.620]                   NAME <- NAMES[[kk]]
[17:04:24.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.620]                     next
[17:04:24.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.620]                 }
[17:04:24.620]                 NAMES <- toupper(added)
[17:04:24.620]                 for (kk in seq_along(NAMES)) {
[17:04:24.620]                   name <- added[[kk]]
[17:04:24.620]                   NAME <- NAMES[[kk]]
[17:04:24.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.620]                     next
[17:04:24.620]                   args[[name]] <- ""
[17:04:24.620]                 }
[17:04:24.620]                 NAMES <- toupper(removed)
[17:04:24.620]                 for (kk in seq_along(NAMES)) {
[17:04:24.620]                   name <- removed[[kk]]
[17:04:24.620]                   NAME <- NAMES[[kk]]
[17:04:24.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.620]                     next
[17:04:24.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.620]                 }
[17:04:24.620]                 if (length(args) > 0) 
[17:04:24.620]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.620]             }
[17:04:24.620]             else {
[17:04:24.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.620]             }
[17:04:24.620]             {
[17:04:24.620]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.620]                   0L) {
[17:04:24.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.620]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.620]                   base::options(opts)
[17:04:24.620]                 }
[17:04:24.620]                 {
[17:04:24.620]                   {
[17:04:24.620]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.620]                     NULL
[17:04:24.620]                   }
[17:04:24.620]                   options(future.plan = NULL)
[17:04:24.620]                   if (is.na(NA_character_)) 
[17:04:24.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.620]                     .init = FALSE)
[17:04:24.620]                 }
[17:04:24.620]             }
[17:04:24.620]         }
[17:04:24.620]     })
[17:04:24.620]     if (TRUE) {
[17:04:24.620]         base::sink(type = "output", split = FALSE)
[17:04:24.620]         if (TRUE) {
[17:04:24.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.620]         }
[17:04:24.620]         else {
[17:04:24.620]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.620]         }
[17:04:24.620]         base::close(...future.stdout)
[17:04:24.620]         ...future.stdout <- NULL
[17:04:24.620]     }
[17:04:24.620]     ...future.result$conditions <- ...future.conditions
[17:04:24.620]     ...future.result$finished <- base::Sys.time()
[17:04:24.620]     ...future.result
[17:04:24.620] }
[17:04:24.623] MultisessionFuture started
[17:04:24.624] - Launch lazy future ... done
[17:04:24.624] run() for ‘MultisessionFuture’ ... done
[17:04:24.624] result() for ClusterFuture ...
[17:04:24.624] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.624] - Validating connection of MultisessionFuture
[17:04:24.673] - received message: FutureResult
[17:04:24.673] - Received FutureResult
[17:04:24.673] - Erased future from FutureRegistry
[17:04:24.673] result() for ClusterFuture ...
[17:04:24.673] - result already collected: FutureResult
[17:04:24.673] result() for ClusterFuture ... done
[17:04:24.674] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:24.674] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:24"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:24"
 $ session_uuid: chr "08089032-45d4-f166-8a5d-17039f6c107b"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50528
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:24"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:24.683] result() for ClusterFuture ...
[17:04:24.683] - result already collected: FutureResult
[17:04:24.684] result() for ClusterFuture ... done
[17:04:24.684] result() for ClusterFuture ...
[17:04:24.684] - result already collected: FutureResult
[17:04:24.684] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.008774519 secs (started 2024-11-25 17:04:24.664088)
version: 1.8
[17:04:24.685] getGlobalsAndPackages() ...
[17:04:24.685] Searching for globals...
[17:04:24.691] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:24.691] Searching for globals ... DONE
[17:04:24.691] Resolving globals: FALSE
[17:04:24.692] 
[17:04:24.692] - packages: [1] ‘utils’
[17:04:24.692] getGlobalsAndPackages() ... DONE
[17:04:24.693] run() for ‘Future’ ...
[17:04:24.693] - state: ‘created’
[17:04:24.693] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:24.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:24.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:24.709]   - Field: ‘node’
[17:04:24.709]   - Field: ‘label’
[17:04:24.709]   - Field: ‘local’
[17:04:24.709]   - Field: ‘owner’
[17:04:24.709]   - Field: ‘envir’
[17:04:24.709]   - Field: ‘workers’
[17:04:24.709]   - Field: ‘packages’
[17:04:24.709]   - Field: ‘gc’
[17:04:24.709]   - Field: ‘conditions’
[17:04:24.709]   - Field: ‘persistent’
[17:04:24.710]   - Field: ‘expr’
[17:04:24.710]   - Field: ‘uuid’
[17:04:24.710]   - Field: ‘seed’
[17:04:24.710]   - Field: ‘version’
[17:04:24.710]   - Field: ‘result’
[17:04:24.710]   - Field: ‘asynchronous’
[17:04:24.710]   - Field: ‘calls’
[17:04:24.710]   - Field: ‘globals’
[17:04:24.710]   - Field: ‘stdout’
[17:04:24.711]   - Field: ‘earlySignal’
[17:04:24.711]   - Field: ‘lazy’
[17:04:24.711]   - Field: ‘state’
[17:04:24.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:24.711] - Launch lazy future ...
[17:04:24.711] Packages needed by the future expression (n = 1): ‘utils’
[17:04:24.712] Packages needed by future strategies (n = 0): <none>
[17:04:24.712] {
[17:04:24.712]     {
[17:04:24.712]         {
[17:04:24.712]             ...future.startTime <- base::Sys.time()
[17:04:24.712]             {
[17:04:24.712]                 {
[17:04:24.712]                   {
[17:04:24.712]                     {
[17:04:24.712]                       {
[17:04:24.712]                         base::local({
[17:04:24.712]                           has_future <- base::requireNamespace("future", 
[17:04:24.712]                             quietly = TRUE)
[17:04:24.712]                           if (has_future) {
[17:04:24.712]                             ns <- base::getNamespace("future")
[17:04:24.712]                             version <- ns[[".package"]][["version"]]
[17:04:24.712]                             if (is.null(version)) 
[17:04:24.712]                               version <- utils::packageVersion("future")
[17:04:24.712]                           }
[17:04:24.712]                           else {
[17:04:24.712]                             version <- NULL
[17:04:24.712]                           }
[17:04:24.712]                           if (!has_future || version < "1.8.0") {
[17:04:24.712]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.712]                               "", base::R.version$version.string), 
[17:04:24.712]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:24.712]                                 base::R.version$platform, 8 * 
[17:04:24.712]                                   base::.Machine$sizeof.pointer), 
[17:04:24.712]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.712]                                 "release", "version")], collapse = " "), 
[17:04:24.712]                               hostname = base::Sys.info()[["nodename"]])
[17:04:24.712]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.712]                               info)
[17:04:24.712]                             info <- base::paste(info, collapse = "; ")
[17:04:24.712]                             if (!has_future) {
[17:04:24.712]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.712]                                 info)
[17:04:24.712]                             }
[17:04:24.712]                             else {
[17:04:24.712]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.712]                                 info, version)
[17:04:24.712]                             }
[17:04:24.712]                             base::stop(msg)
[17:04:24.712]                           }
[17:04:24.712]                         })
[17:04:24.712]                       }
[17:04:24.712]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.712]                       base::options(mc.cores = 1L)
[17:04:24.712]                     }
[17:04:24.712]                     base::local({
[17:04:24.712]                       for (pkg in "utils") {
[17:04:24.712]                         base::loadNamespace(pkg)
[17:04:24.712]                         base::library(pkg, character.only = TRUE)
[17:04:24.712]                       }
[17:04:24.712]                     })
[17:04:24.712]                   }
[17:04:24.712]                   ...future.strategy.old <- future::plan("list")
[17:04:24.712]                   options(future.plan = NULL)
[17:04:24.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.712]                 }
[17:04:24.712]                 ...future.workdir <- getwd()
[17:04:24.712]             }
[17:04:24.712]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.712]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.712]         }
[17:04:24.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.712]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.712]             base::names(...future.oldOptions))
[17:04:24.712]     }
[17:04:24.712]     if (FALSE) {
[17:04:24.712]     }
[17:04:24.712]     else {
[17:04:24.712]         if (TRUE) {
[17:04:24.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.712]                 open = "w")
[17:04:24.712]         }
[17:04:24.712]         else {
[17:04:24.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.712]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.712]         }
[17:04:24.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.712]             base::sink(type = "output", split = FALSE)
[17:04:24.712]             base::close(...future.stdout)
[17:04:24.712]         }, add = TRUE)
[17:04:24.712]     }
[17:04:24.712]     ...future.frame <- base::sys.nframe()
[17:04:24.712]     ...future.conditions <- base::list()
[17:04:24.712]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.712]     if (FALSE) {
[17:04:24.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.712]     }
[17:04:24.712]     ...future.result <- base::tryCatch({
[17:04:24.712]         base::withCallingHandlers({
[17:04:24.712]             ...future.value <- base::withVisible(base::local({
[17:04:24.712]                 ...future.makeSendCondition <- base::local({
[17:04:24.712]                   sendCondition <- NULL
[17:04:24.712]                   function(frame = 1L) {
[17:04:24.712]                     if (is.function(sendCondition)) 
[17:04:24.712]                       return(sendCondition)
[17:04:24.712]                     ns <- getNamespace("parallel")
[17:04:24.712]                     if (exists("sendData", mode = "function", 
[17:04:24.712]                       envir = ns)) {
[17:04:24.712]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.712]                         envir = ns)
[17:04:24.712]                       envir <- sys.frame(frame)
[17:04:24.712]                       master <- NULL
[17:04:24.712]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.712]                         !identical(envir, emptyenv())) {
[17:04:24.712]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.712]                           inherits = FALSE)) {
[17:04:24.712]                           master <- get("master", mode = "list", 
[17:04:24.712]                             envir = envir, inherits = FALSE)
[17:04:24.712]                           if (inherits(master, c("SOCKnode", 
[17:04:24.712]                             "SOCK0node"))) {
[17:04:24.712]                             sendCondition <<- function(cond) {
[17:04:24.712]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.712]                                 success = TRUE)
[17:04:24.712]                               parallel_sendData(master, data)
[17:04:24.712]                             }
[17:04:24.712]                             return(sendCondition)
[17:04:24.712]                           }
[17:04:24.712]                         }
[17:04:24.712]                         frame <- frame + 1L
[17:04:24.712]                         envir <- sys.frame(frame)
[17:04:24.712]                       }
[17:04:24.712]                     }
[17:04:24.712]                     sendCondition <<- function(cond) NULL
[17:04:24.712]                   }
[17:04:24.712]                 })
[17:04:24.712]                 withCallingHandlers({
[17:04:24.712]                   {
[17:04:24.712]                     print(1:50)
[17:04:24.712]                     str(1:50)
[17:04:24.712]                     cat(letters, sep = "-")
[17:04:24.712]                     cat(1:6, collapse = "\n")
[17:04:24.712]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:24.712]                     42L
[17:04:24.712]                   }
[17:04:24.712]                 }, immediateCondition = function(cond) {
[17:04:24.712]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.712]                   sendCondition(cond)
[17:04:24.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.712]                   {
[17:04:24.712]                     inherits <- base::inherits
[17:04:24.712]                     invokeRestart <- base::invokeRestart
[17:04:24.712]                     is.null <- base::is.null
[17:04:24.712]                     muffled <- FALSE
[17:04:24.712]                     if (inherits(cond, "message")) {
[17:04:24.712]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.712]                       if (muffled) 
[17:04:24.712]                         invokeRestart("muffleMessage")
[17:04:24.712]                     }
[17:04:24.712]                     else if (inherits(cond, "warning")) {
[17:04:24.712]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.712]                       if (muffled) 
[17:04:24.712]                         invokeRestart("muffleWarning")
[17:04:24.712]                     }
[17:04:24.712]                     else if (inherits(cond, "condition")) {
[17:04:24.712]                       if (!is.null(pattern)) {
[17:04:24.712]                         computeRestarts <- base::computeRestarts
[17:04:24.712]                         grepl <- base::grepl
[17:04:24.712]                         restarts <- computeRestarts(cond)
[17:04:24.712]                         for (restart in restarts) {
[17:04:24.712]                           name <- restart$name
[17:04:24.712]                           if (is.null(name)) 
[17:04:24.712]                             next
[17:04:24.712]                           if (!grepl(pattern, name)) 
[17:04:24.712]                             next
[17:04:24.712]                           invokeRestart(restart)
[17:04:24.712]                           muffled <- TRUE
[17:04:24.712]                           break
[17:04:24.712]                         }
[17:04:24.712]                       }
[17:04:24.712]                     }
[17:04:24.712]                     invisible(muffled)
[17:04:24.712]                   }
[17:04:24.712]                   muffleCondition(cond)
[17:04:24.712]                 })
[17:04:24.712]             }))
[17:04:24.712]             future::FutureResult(value = ...future.value$value, 
[17:04:24.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.712]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.712]                     ...future.globalenv.names))
[17:04:24.712]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.712]         }, condition = base::local({
[17:04:24.712]             c <- base::c
[17:04:24.712]             inherits <- base::inherits
[17:04:24.712]             invokeRestart <- base::invokeRestart
[17:04:24.712]             length <- base::length
[17:04:24.712]             list <- base::list
[17:04:24.712]             seq.int <- base::seq.int
[17:04:24.712]             signalCondition <- base::signalCondition
[17:04:24.712]             sys.calls <- base::sys.calls
[17:04:24.712]             `[[` <- base::`[[`
[17:04:24.712]             `+` <- base::`+`
[17:04:24.712]             `<<-` <- base::`<<-`
[17:04:24.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.712]                   3L)]
[17:04:24.712]             }
[17:04:24.712]             function(cond) {
[17:04:24.712]                 is_error <- inherits(cond, "error")
[17:04:24.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.712]                   NULL)
[17:04:24.712]                 if (is_error) {
[17:04:24.712]                   sessionInformation <- function() {
[17:04:24.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.712]                       search = base::search(), system = base::Sys.info())
[17:04:24.712]                   }
[17:04:24.712]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.712]                     cond$call), session = sessionInformation(), 
[17:04:24.712]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.712]                   signalCondition(cond)
[17:04:24.712]                 }
[17:04:24.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.712]                 "immediateCondition"))) {
[17:04:24.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.712]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.712]                   if (TRUE && !signal) {
[17:04:24.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.712]                     {
[17:04:24.712]                       inherits <- base::inherits
[17:04:24.712]                       invokeRestart <- base::invokeRestart
[17:04:24.712]                       is.null <- base::is.null
[17:04:24.712]                       muffled <- FALSE
[17:04:24.712]                       if (inherits(cond, "message")) {
[17:04:24.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.712]                         if (muffled) 
[17:04:24.712]                           invokeRestart("muffleMessage")
[17:04:24.712]                       }
[17:04:24.712]                       else if (inherits(cond, "warning")) {
[17:04:24.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.712]                         if (muffled) 
[17:04:24.712]                           invokeRestart("muffleWarning")
[17:04:24.712]                       }
[17:04:24.712]                       else if (inherits(cond, "condition")) {
[17:04:24.712]                         if (!is.null(pattern)) {
[17:04:24.712]                           computeRestarts <- base::computeRestarts
[17:04:24.712]                           grepl <- base::grepl
[17:04:24.712]                           restarts <- computeRestarts(cond)
[17:04:24.712]                           for (restart in restarts) {
[17:04:24.712]                             name <- restart$name
[17:04:24.712]                             if (is.null(name)) 
[17:04:24.712]                               next
[17:04:24.712]                             if (!grepl(pattern, name)) 
[17:04:24.712]                               next
[17:04:24.712]                             invokeRestart(restart)
[17:04:24.712]                             muffled <- TRUE
[17:04:24.712]                             break
[17:04:24.712]                           }
[17:04:24.712]                         }
[17:04:24.712]                       }
[17:04:24.712]                       invisible(muffled)
[17:04:24.712]                     }
[17:04:24.712]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.712]                   }
[17:04:24.712]                 }
[17:04:24.712]                 else {
[17:04:24.712]                   if (TRUE) {
[17:04:24.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.712]                     {
[17:04:24.712]                       inherits <- base::inherits
[17:04:24.712]                       invokeRestart <- base::invokeRestart
[17:04:24.712]                       is.null <- base::is.null
[17:04:24.712]                       muffled <- FALSE
[17:04:24.712]                       if (inherits(cond, "message")) {
[17:04:24.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.712]                         if (muffled) 
[17:04:24.712]                           invokeRestart("muffleMessage")
[17:04:24.712]                       }
[17:04:24.712]                       else if (inherits(cond, "warning")) {
[17:04:24.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.712]                         if (muffled) 
[17:04:24.712]                           invokeRestart("muffleWarning")
[17:04:24.712]                       }
[17:04:24.712]                       else if (inherits(cond, "condition")) {
[17:04:24.712]                         if (!is.null(pattern)) {
[17:04:24.712]                           computeRestarts <- base::computeRestarts
[17:04:24.712]                           grepl <- base::grepl
[17:04:24.712]                           restarts <- computeRestarts(cond)
[17:04:24.712]                           for (restart in restarts) {
[17:04:24.712]                             name <- restart$name
[17:04:24.712]                             if (is.null(name)) 
[17:04:24.712]                               next
[17:04:24.712]                             if (!grepl(pattern, name)) 
[17:04:24.712]                               next
[17:04:24.712]                             invokeRestart(restart)
[17:04:24.712]                             muffled <- TRUE
[17:04:24.712]                             break
[17:04:24.712]                           }
[17:04:24.712]                         }
[17:04:24.712]                       }
[17:04:24.712]                       invisible(muffled)
[17:04:24.712]                     }
[17:04:24.712]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.712]                   }
[17:04:24.712]                 }
[17:04:24.712]             }
[17:04:24.712]         }))
[17:04:24.712]     }, error = function(ex) {
[17:04:24.712]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.712]                 ...future.rng), started = ...future.startTime, 
[17:04:24.712]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.712]             version = "1.8"), class = "FutureResult")
[17:04:24.712]     }, finally = {
[17:04:24.712]         if (!identical(...future.workdir, getwd())) 
[17:04:24.712]             setwd(...future.workdir)
[17:04:24.712]         {
[17:04:24.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.712]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.712]             }
[17:04:24.712]             base::options(...future.oldOptions)
[17:04:24.712]             if (.Platform$OS.type == "windows") {
[17:04:24.712]                 old_names <- names(...future.oldEnvVars)
[17:04:24.712]                 envs <- base::Sys.getenv()
[17:04:24.712]                 names <- names(envs)
[17:04:24.712]                 common <- intersect(names, old_names)
[17:04:24.712]                 added <- setdiff(names, old_names)
[17:04:24.712]                 removed <- setdiff(old_names, names)
[17:04:24.712]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.712]                   envs[common]]
[17:04:24.712]                 NAMES <- toupper(changed)
[17:04:24.712]                 args <- list()
[17:04:24.712]                 for (kk in seq_along(NAMES)) {
[17:04:24.712]                   name <- changed[[kk]]
[17:04:24.712]                   NAME <- NAMES[[kk]]
[17:04:24.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.712]                     next
[17:04:24.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.712]                 }
[17:04:24.712]                 NAMES <- toupper(added)
[17:04:24.712]                 for (kk in seq_along(NAMES)) {
[17:04:24.712]                   name <- added[[kk]]
[17:04:24.712]                   NAME <- NAMES[[kk]]
[17:04:24.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.712]                     next
[17:04:24.712]                   args[[name]] <- ""
[17:04:24.712]                 }
[17:04:24.712]                 NAMES <- toupper(removed)
[17:04:24.712]                 for (kk in seq_along(NAMES)) {
[17:04:24.712]                   name <- removed[[kk]]
[17:04:24.712]                   NAME <- NAMES[[kk]]
[17:04:24.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.712]                     next
[17:04:24.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.712]                 }
[17:04:24.712]                 if (length(args) > 0) 
[17:04:24.712]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.712]             }
[17:04:24.712]             else {
[17:04:24.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.712]             }
[17:04:24.712]             {
[17:04:24.712]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.712]                   0L) {
[17:04:24.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.712]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.712]                   base::options(opts)
[17:04:24.712]                 }
[17:04:24.712]                 {
[17:04:24.712]                   {
[17:04:24.712]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.712]                     NULL
[17:04:24.712]                   }
[17:04:24.712]                   options(future.plan = NULL)
[17:04:24.712]                   if (is.na(NA_character_)) 
[17:04:24.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.712]                     .init = FALSE)
[17:04:24.712]                 }
[17:04:24.712]             }
[17:04:24.712]         }
[17:04:24.712]     })
[17:04:24.712]     if (TRUE) {
[17:04:24.712]         base::sink(type = "output", split = FALSE)
[17:04:24.712]         if (TRUE) {
[17:04:24.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.712]         }
[17:04:24.712]         else {
[17:04:24.712]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.712]         }
[17:04:24.712]         base::close(...future.stdout)
[17:04:24.712]         ...future.stdout <- NULL
[17:04:24.712]     }
[17:04:24.712]     ...future.result$conditions <- ...future.conditions
[17:04:24.712]     ...future.result$finished <- base::Sys.time()
[17:04:24.712]     ...future.result
[17:04:24.712] }
[17:04:24.716] MultisessionFuture started
[17:04:24.716] - Launch lazy future ... done
[17:04:24.716] run() for ‘MultisessionFuture’ ... done
[17:04:24.717] result() for ClusterFuture ...
[17:04:24.717] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.717] - Validating connection of MultisessionFuture
[17:04:24.762] - received message: FutureResult
[17:04:24.762] - Received FutureResult
[17:04:24.763] - Erased future from FutureRegistry
[17:04:24.763] result() for ClusterFuture ...
[17:04:24.763] - result already collected: FutureResult
[17:04:24.763] result() for ClusterFuture ... done
[17:04:24.763] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:24.763] result() for ClusterFuture ... done
[17:04:24.763] result() for ClusterFuture ...
[17:04:24.763] - result already collected: FutureResult
[17:04:24.764] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:04:24.767] getGlobalsAndPackages() ...
[17:04:24.767] Searching for globals...
[17:04:24.767] - globals found: [1] ‘print’
[17:04:24.767] Searching for globals ... DONE
[17:04:24.768] Resolving globals: FALSE
[17:04:24.768] 
[17:04:24.768] 
[17:04:24.768] getGlobalsAndPackages() ... DONE
[17:04:24.768] run() for ‘Future’ ...
[17:04:24.768] - state: ‘created’
[17:04:24.768] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:24.783] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:24.783] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:24.783]   - Field: ‘node’
[17:04:24.783]   - Field: ‘label’
[17:04:24.783]   - Field: ‘local’
[17:04:24.783]   - Field: ‘owner’
[17:04:24.783]   - Field: ‘envir’
[17:04:24.783]   - Field: ‘workers’
[17:04:24.783]   - Field: ‘packages’
[17:04:24.784]   - Field: ‘gc’
[17:04:24.784]   - Field: ‘conditions’
[17:04:24.784]   - Field: ‘persistent’
[17:04:24.784]   - Field: ‘expr’
[17:04:24.784]   - Field: ‘uuid’
[17:04:24.784]   - Field: ‘seed’
[17:04:24.784]   - Field: ‘version’
[17:04:24.784]   - Field: ‘result’
[17:04:24.784]   - Field: ‘asynchronous’
[17:04:24.784]   - Field: ‘calls’
[17:04:24.784]   - Field: ‘globals’
[17:04:24.784]   - Field: ‘stdout’
[17:04:24.785]   - Field: ‘earlySignal’
[17:04:24.785]   - Field: ‘lazy’
[17:04:24.785]   - Field: ‘state’
[17:04:24.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:24.785] - Launch lazy future ...
[17:04:24.785] Packages needed by the future expression (n = 0): <none>
[17:04:24.785] Packages needed by future strategies (n = 0): <none>
[17:04:24.786] {
[17:04:24.786]     {
[17:04:24.786]         {
[17:04:24.786]             ...future.startTime <- base::Sys.time()
[17:04:24.786]             {
[17:04:24.786]                 {
[17:04:24.786]                   {
[17:04:24.786]                     {
[17:04:24.786]                       base::local({
[17:04:24.786]                         has_future <- base::requireNamespace("future", 
[17:04:24.786]                           quietly = TRUE)
[17:04:24.786]                         if (has_future) {
[17:04:24.786]                           ns <- base::getNamespace("future")
[17:04:24.786]                           version <- ns[[".package"]][["version"]]
[17:04:24.786]                           if (is.null(version)) 
[17:04:24.786]                             version <- utils::packageVersion("future")
[17:04:24.786]                         }
[17:04:24.786]                         else {
[17:04:24.786]                           version <- NULL
[17:04:24.786]                         }
[17:04:24.786]                         if (!has_future || version < "1.8.0") {
[17:04:24.786]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.786]                             "", base::R.version$version.string), 
[17:04:24.786]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:24.786]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:24.786]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.786]                               "release", "version")], collapse = " "), 
[17:04:24.786]                             hostname = base::Sys.info()[["nodename"]])
[17:04:24.786]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.786]                             info)
[17:04:24.786]                           info <- base::paste(info, collapse = "; ")
[17:04:24.786]                           if (!has_future) {
[17:04:24.786]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.786]                               info)
[17:04:24.786]                           }
[17:04:24.786]                           else {
[17:04:24.786]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.786]                               info, version)
[17:04:24.786]                           }
[17:04:24.786]                           base::stop(msg)
[17:04:24.786]                         }
[17:04:24.786]                       })
[17:04:24.786]                     }
[17:04:24.786]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.786]                     base::options(mc.cores = 1L)
[17:04:24.786]                   }
[17:04:24.786]                   ...future.strategy.old <- future::plan("list")
[17:04:24.786]                   options(future.plan = NULL)
[17:04:24.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.786]                 }
[17:04:24.786]                 ...future.workdir <- getwd()
[17:04:24.786]             }
[17:04:24.786]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.786]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.786]         }
[17:04:24.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.786]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.786]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.786]             base::names(...future.oldOptions))
[17:04:24.786]     }
[17:04:24.786]     if (FALSE) {
[17:04:24.786]     }
[17:04:24.786]     else {
[17:04:24.786]         if (TRUE) {
[17:04:24.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.786]                 open = "w")
[17:04:24.786]         }
[17:04:24.786]         else {
[17:04:24.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.786]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.786]         }
[17:04:24.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.786]             base::sink(type = "output", split = FALSE)
[17:04:24.786]             base::close(...future.stdout)
[17:04:24.786]         }, add = TRUE)
[17:04:24.786]     }
[17:04:24.786]     ...future.frame <- base::sys.nframe()
[17:04:24.786]     ...future.conditions <- base::list()
[17:04:24.786]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.786]     if (FALSE) {
[17:04:24.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.786]     }
[17:04:24.786]     ...future.result <- base::tryCatch({
[17:04:24.786]         base::withCallingHandlers({
[17:04:24.786]             ...future.value <- base::withVisible(base::local({
[17:04:24.786]                 ...future.makeSendCondition <- base::local({
[17:04:24.786]                   sendCondition <- NULL
[17:04:24.786]                   function(frame = 1L) {
[17:04:24.786]                     if (is.function(sendCondition)) 
[17:04:24.786]                       return(sendCondition)
[17:04:24.786]                     ns <- getNamespace("parallel")
[17:04:24.786]                     if (exists("sendData", mode = "function", 
[17:04:24.786]                       envir = ns)) {
[17:04:24.786]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.786]                         envir = ns)
[17:04:24.786]                       envir <- sys.frame(frame)
[17:04:24.786]                       master <- NULL
[17:04:24.786]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.786]                         !identical(envir, emptyenv())) {
[17:04:24.786]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.786]                           inherits = FALSE)) {
[17:04:24.786]                           master <- get("master", mode = "list", 
[17:04:24.786]                             envir = envir, inherits = FALSE)
[17:04:24.786]                           if (inherits(master, c("SOCKnode", 
[17:04:24.786]                             "SOCK0node"))) {
[17:04:24.786]                             sendCondition <<- function(cond) {
[17:04:24.786]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.786]                                 success = TRUE)
[17:04:24.786]                               parallel_sendData(master, data)
[17:04:24.786]                             }
[17:04:24.786]                             return(sendCondition)
[17:04:24.786]                           }
[17:04:24.786]                         }
[17:04:24.786]                         frame <- frame + 1L
[17:04:24.786]                         envir <- sys.frame(frame)
[17:04:24.786]                       }
[17:04:24.786]                     }
[17:04:24.786]                     sendCondition <<- function(cond) NULL
[17:04:24.786]                   }
[17:04:24.786]                 })
[17:04:24.786]                 withCallingHandlers({
[17:04:24.786]                   print(42)
[17:04:24.786]                 }, immediateCondition = function(cond) {
[17:04:24.786]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.786]                   sendCondition(cond)
[17:04:24.786]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.786]                   {
[17:04:24.786]                     inherits <- base::inherits
[17:04:24.786]                     invokeRestart <- base::invokeRestart
[17:04:24.786]                     is.null <- base::is.null
[17:04:24.786]                     muffled <- FALSE
[17:04:24.786]                     if (inherits(cond, "message")) {
[17:04:24.786]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.786]                       if (muffled) 
[17:04:24.786]                         invokeRestart("muffleMessage")
[17:04:24.786]                     }
[17:04:24.786]                     else if (inherits(cond, "warning")) {
[17:04:24.786]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.786]                       if (muffled) 
[17:04:24.786]                         invokeRestart("muffleWarning")
[17:04:24.786]                     }
[17:04:24.786]                     else if (inherits(cond, "condition")) {
[17:04:24.786]                       if (!is.null(pattern)) {
[17:04:24.786]                         computeRestarts <- base::computeRestarts
[17:04:24.786]                         grepl <- base::grepl
[17:04:24.786]                         restarts <- computeRestarts(cond)
[17:04:24.786]                         for (restart in restarts) {
[17:04:24.786]                           name <- restart$name
[17:04:24.786]                           if (is.null(name)) 
[17:04:24.786]                             next
[17:04:24.786]                           if (!grepl(pattern, name)) 
[17:04:24.786]                             next
[17:04:24.786]                           invokeRestart(restart)
[17:04:24.786]                           muffled <- TRUE
[17:04:24.786]                           break
[17:04:24.786]                         }
[17:04:24.786]                       }
[17:04:24.786]                     }
[17:04:24.786]                     invisible(muffled)
[17:04:24.786]                   }
[17:04:24.786]                   muffleCondition(cond)
[17:04:24.786]                 })
[17:04:24.786]             }))
[17:04:24.786]             future::FutureResult(value = ...future.value$value, 
[17:04:24.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.786]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.786]                     ...future.globalenv.names))
[17:04:24.786]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.786]         }, condition = base::local({
[17:04:24.786]             c <- base::c
[17:04:24.786]             inherits <- base::inherits
[17:04:24.786]             invokeRestart <- base::invokeRestart
[17:04:24.786]             length <- base::length
[17:04:24.786]             list <- base::list
[17:04:24.786]             seq.int <- base::seq.int
[17:04:24.786]             signalCondition <- base::signalCondition
[17:04:24.786]             sys.calls <- base::sys.calls
[17:04:24.786]             `[[` <- base::`[[`
[17:04:24.786]             `+` <- base::`+`
[17:04:24.786]             `<<-` <- base::`<<-`
[17:04:24.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.786]                   3L)]
[17:04:24.786]             }
[17:04:24.786]             function(cond) {
[17:04:24.786]                 is_error <- inherits(cond, "error")
[17:04:24.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.786]                   NULL)
[17:04:24.786]                 if (is_error) {
[17:04:24.786]                   sessionInformation <- function() {
[17:04:24.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.786]                       search = base::search(), system = base::Sys.info())
[17:04:24.786]                   }
[17:04:24.786]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.786]                     cond$call), session = sessionInformation(), 
[17:04:24.786]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.786]                   signalCondition(cond)
[17:04:24.786]                 }
[17:04:24.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.786]                 "immediateCondition"))) {
[17:04:24.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.786]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.786]                   if (TRUE && !signal) {
[17:04:24.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.786]                     {
[17:04:24.786]                       inherits <- base::inherits
[17:04:24.786]                       invokeRestart <- base::invokeRestart
[17:04:24.786]                       is.null <- base::is.null
[17:04:24.786]                       muffled <- FALSE
[17:04:24.786]                       if (inherits(cond, "message")) {
[17:04:24.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.786]                         if (muffled) 
[17:04:24.786]                           invokeRestart("muffleMessage")
[17:04:24.786]                       }
[17:04:24.786]                       else if (inherits(cond, "warning")) {
[17:04:24.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.786]                         if (muffled) 
[17:04:24.786]                           invokeRestart("muffleWarning")
[17:04:24.786]                       }
[17:04:24.786]                       else if (inherits(cond, "condition")) {
[17:04:24.786]                         if (!is.null(pattern)) {
[17:04:24.786]                           computeRestarts <- base::computeRestarts
[17:04:24.786]                           grepl <- base::grepl
[17:04:24.786]                           restarts <- computeRestarts(cond)
[17:04:24.786]                           for (restart in restarts) {
[17:04:24.786]                             name <- restart$name
[17:04:24.786]                             if (is.null(name)) 
[17:04:24.786]                               next
[17:04:24.786]                             if (!grepl(pattern, name)) 
[17:04:24.786]                               next
[17:04:24.786]                             invokeRestart(restart)
[17:04:24.786]                             muffled <- TRUE
[17:04:24.786]                             break
[17:04:24.786]                           }
[17:04:24.786]                         }
[17:04:24.786]                       }
[17:04:24.786]                       invisible(muffled)
[17:04:24.786]                     }
[17:04:24.786]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.786]                   }
[17:04:24.786]                 }
[17:04:24.786]                 else {
[17:04:24.786]                   if (TRUE) {
[17:04:24.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.786]                     {
[17:04:24.786]                       inherits <- base::inherits
[17:04:24.786]                       invokeRestart <- base::invokeRestart
[17:04:24.786]                       is.null <- base::is.null
[17:04:24.786]                       muffled <- FALSE
[17:04:24.786]                       if (inherits(cond, "message")) {
[17:04:24.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.786]                         if (muffled) 
[17:04:24.786]                           invokeRestart("muffleMessage")
[17:04:24.786]                       }
[17:04:24.786]                       else if (inherits(cond, "warning")) {
[17:04:24.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.786]                         if (muffled) 
[17:04:24.786]                           invokeRestart("muffleWarning")
[17:04:24.786]                       }
[17:04:24.786]                       else if (inherits(cond, "condition")) {
[17:04:24.786]                         if (!is.null(pattern)) {
[17:04:24.786]                           computeRestarts <- base::computeRestarts
[17:04:24.786]                           grepl <- base::grepl
[17:04:24.786]                           restarts <- computeRestarts(cond)
[17:04:24.786]                           for (restart in restarts) {
[17:04:24.786]                             name <- restart$name
[17:04:24.786]                             if (is.null(name)) 
[17:04:24.786]                               next
[17:04:24.786]                             if (!grepl(pattern, name)) 
[17:04:24.786]                               next
[17:04:24.786]                             invokeRestart(restart)
[17:04:24.786]                             muffled <- TRUE
[17:04:24.786]                             break
[17:04:24.786]                           }
[17:04:24.786]                         }
[17:04:24.786]                       }
[17:04:24.786]                       invisible(muffled)
[17:04:24.786]                     }
[17:04:24.786]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.786]                   }
[17:04:24.786]                 }
[17:04:24.786]             }
[17:04:24.786]         }))
[17:04:24.786]     }, error = function(ex) {
[17:04:24.786]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.786]                 ...future.rng), started = ...future.startTime, 
[17:04:24.786]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.786]             version = "1.8"), class = "FutureResult")
[17:04:24.786]     }, finally = {
[17:04:24.786]         if (!identical(...future.workdir, getwd())) 
[17:04:24.786]             setwd(...future.workdir)
[17:04:24.786]         {
[17:04:24.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.786]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.786]             }
[17:04:24.786]             base::options(...future.oldOptions)
[17:04:24.786]             if (.Platform$OS.type == "windows") {
[17:04:24.786]                 old_names <- names(...future.oldEnvVars)
[17:04:24.786]                 envs <- base::Sys.getenv()
[17:04:24.786]                 names <- names(envs)
[17:04:24.786]                 common <- intersect(names, old_names)
[17:04:24.786]                 added <- setdiff(names, old_names)
[17:04:24.786]                 removed <- setdiff(old_names, names)
[17:04:24.786]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.786]                   envs[common]]
[17:04:24.786]                 NAMES <- toupper(changed)
[17:04:24.786]                 args <- list()
[17:04:24.786]                 for (kk in seq_along(NAMES)) {
[17:04:24.786]                   name <- changed[[kk]]
[17:04:24.786]                   NAME <- NAMES[[kk]]
[17:04:24.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.786]                     next
[17:04:24.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.786]                 }
[17:04:24.786]                 NAMES <- toupper(added)
[17:04:24.786]                 for (kk in seq_along(NAMES)) {
[17:04:24.786]                   name <- added[[kk]]
[17:04:24.786]                   NAME <- NAMES[[kk]]
[17:04:24.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.786]                     next
[17:04:24.786]                   args[[name]] <- ""
[17:04:24.786]                 }
[17:04:24.786]                 NAMES <- toupper(removed)
[17:04:24.786]                 for (kk in seq_along(NAMES)) {
[17:04:24.786]                   name <- removed[[kk]]
[17:04:24.786]                   NAME <- NAMES[[kk]]
[17:04:24.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.786]                     next
[17:04:24.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.786]                 }
[17:04:24.786]                 if (length(args) > 0) 
[17:04:24.786]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.786]             }
[17:04:24.786]             else {
[17:04:24.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.786]             }
[17:04:24.786]             {
[17:04:24.786]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.786]                   0L) {
[17:04:24.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.786]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.786]                   base::options(opts)
[17:04:24.786]                 }
[17:04:24.786]                 {
[17:04:24.786]                   {
[17:04:24.786]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.786]                     NULL
[17:04:24.786]                   }
[17:04:24.786]                   options(future.plan = NULL)
[17:04:24.786]                   if (is.na(NA_character_)) 
[17:04:24.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.786]                     .init = FALSE)
[17:04:24.786]                 }
[17:04:24.786]             }
[17:04:24.786]         }
[17:04:24.786]     })
[17:04:24.786]     if (TRUE) {
[17:04:24.786]         base::sink(type = "output", split = FALSE)
[17:04:24.786]         if (TRUE) {
[17:04:24.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.786]         }
[17:04:24.786]         else {
[17:04:24.786]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.786]         }
[17:04:24.786]         base::close(...future.stdout)
[17:04:24.786]         ...future.stdout <- NULL
[17:04:24.786]     }
[17:04:24.786]     ...future.result$conditions <- ...future.conditions
[17:04:24.786]     ...future.result$finished <- base::Sys.time()
[17:04:24.786]     ...future.result
[17:04:24.786] }
[17:04:24.789] MultisessionFuture started
[17:04:24.789] - Launch lazy future ... done
[17:04:24.789] run() for ‘MultisessionFuture’ ... done
[17:04:24.789] result() for ClusterFuture ...
[17:04:24.789] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.789] - Validating connection of MultisessionFuture
[17:04:24.790] - received message: FutureResult
[17:04:24.791] - Received FutureResult
[17:04:24.791] - Erased future from FutureRegistry
[17:04:24.791] result() for ClusterFuture ...
[17:04:24.791] - result already collected: FutureResult
[17:04:24.791] result() for ClusterFuture ... done
[17:04:24.791] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:24.791] result() for ClusterFuture ... done
[17:04:24.791] result() for ClusterFuture ...
[17:04:24.791] - result already collected: FutureResult
[17:04:24.791] result() for ClusterFuture ... done
[17:04:24.792] result() for ClusterFuture ...
[17:04:24.792] - result already collected: FutureResult
[17:04:24.792] result() for ClusterFuture ... done
[1] 42
[17:04:24.792] result() for ClusterFuture ...
[17:04:24.792] - result already collected: FutureResult
[17:04:24.792] result() for ClusterFuture ... done
- stdout = FALSE
[17:04:24.792] getGlobalsAndPackages() ...
[17:04:24.792] Searching for globals...
[17:04:24.795] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:24.795] Searching for globals ... DONE
[17:04:24.795] Resolving globals: FALSE
[17:04:24.796] 
[17:04:24.796] - packages: [1] ‘utils’
[17:04:24.796] getGlobalsAndPackages() ... DONE
[17:04:24.796] run() for ‘Future’ ...
[17:04:24.796] - state: ‘created’
[17:04:24.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:24.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:24.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:24.811]   - Field: ‘node’
[17:04:24.811]   - Field: ‘label’
[17:04:24.811]   - Field: ‘local’
[17:04:24.811]   - Field: ‘owner’
[17:04:24.811]   - Field: ‘envir’
[17:04:24.811]   - Field: ‘workers’
[17:04:24.811]   - Field: ‘packages’
[17:04:24.811]   - Field: ‘gc’
[17:04:24.812]   - Field: ‘conditions’
[17:04:24.812]   - Field: ‘persistent’
[17:04:24.812]   - Field: ‘expr’
[17:04:24.812]   - Field: ‘uuid’
[17:04:24.812]   - Field: ‘seed’
[17:04:24.812]   - Field: ‘version’
[17:04:24.812]   - Field: ‘result’
[17:04:24.812]   - Field: ‘asynchronous’
[17:04:24.812]   - Field: ‘calls’
[17:04:24.812]   - Field: ‘globals’
[17:04:24.812]   - Field: ‘stdout’
[17:04:24.812]   - Field: ‘earlySignal’
[17:04:24.813]   - Field: ‘lazy’
[17:04:24.813]   - Field: ‘state’
[17:04:24.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:24.813] - Launch lazy future ...
[17:04:24.813] Packages needed by the future expression (n = 1): ‘utils’
[17:04:24.813] Packages needed by future strategies (n = 0): <none>
[17:04:24.814] {
[17:04:24.814]     {
[17:04:24.814]         {
[17:04:24.814]             ...future.startTime <- base::Sys.time()
[17:04:24.814]             {
[17:04:24.814]                 {
[17:04:24.814]                   {
[17:04:24.814]                     {
[17:04:24.814]                       {
[17:04:24.814]                         base::local({
[17:04:24.814]                           has_future <- base::requireNamespace("future", 
[17:04:24.814]                             quietly = TRUE)
[17:04:24.814]                           if (has_future) {
[17:04:24.814]                             ns <- base::getNamespace("future")
[17:04:24.814]                             version <- ns[[".package"]][["version"]]
[17:04:24.814]                             if (is.null(version)) 
[17:04:24.814]                               version <- utils::packageVersion("future")
[17:04:24.814]                           }
[17:04:24.814]                           else {
[17:04:24.814]                             version <- NULL
[17:04:24.814]                           }
[17:04:24.814]                           if (!has_future || version < "1.8.0") {
[17:04:24.814]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.814]                               "", base::R.version$version.string), 
[17:04:24.814]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:24.814]                                 base::R.version$platform, 8 * 
[17:04:24.814]                                   base::.Machine$sizeof.pointer), 
[17:04:24.814]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.814]                                 "release", "version")], collapse = " "), 
[17:04:24.814]                               hostname = base::Sys.info()[["nodename"]])
[17:04:24.814]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.814]                               info)
[17:04:24.814]                             info <- base::paste(info, collapse = "; ")
[17:04:24.814]                             if (!has_future) {
[17:04:24.814]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.814]                                 info)
[17:04:24.814]                             }
[17:04:24.814]                             else {
[17:04:24.814]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.814]                                 info, version)
[17:04:24.814]                             }
[17:04:24.814]                             base::stop(msg)
[17:04:24.814]                           }
[17:04:24.814]                         })
[17:04:24.814]                       }
[17:04:24.814]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.814]                       base::options(mc.cores = 1L)
[17:04:24.814]                     }
[17:04:24.814]                     base::local({
[17:04:24.814]                       for (pkg in "utils") {
[17:04:24.814]                         base::loadNamespace(pkg)
[17:04:24.814]                         base::library(pkg, character.only = TRUE)
[17:04:24.814]                       }
[17:04:24.814]                     })
[17:04:24.814]                   }
[17:04:24.814]                   ...future.strategy.old <- future::plan("list")
[17:04:24.814]                   options(future.plan = NULL)
[17:04:24.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.814]                 }
[17:04:24.814]                 ...future.workdir <- getwd()
[17:04:24.814]             }
[17:04:24.814]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.814]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.814]         }
[17:04:24.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.814]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.814]             base::names(...future.oldOptions))
[17:04:24.814]     }
[17:04:24.814]     if (FALSE) {
[17:04:24.814]     }
[17:04:24.814]     else {
[17:04:24.814]         if (FALSE) {
[17:04:24.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.814]                 open = "w")
[17:04:24.814]         }
[17:04:24.814]         else {
[17:04:24.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.814]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.814]         }
[17:04:24.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.814]             base::sink(type = "output", split = FALSE)
[17:04:24.814]             base::close(...future.stdout)
[17:04:24.814]         }, add = TRUE)
[17:04:24.814]     }
[17:04:24.814]     ...future.frame <- base::sys.nframe()
[17:04:24.814]     ...future.conditions <- base::list()
[17:04:24.814]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.814]     if (FALSE) {
[17:04:24.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.814]     }
[17:04:24.814]     ...future.result <- base::tryCatch({
[17:04:24.814]         base::withCallingHandlers({
[17:04:24.814]             ...future.value <- base::withVisible(base::local({
[17:04:24.814]                 ...future.makeSendCondition <- base::local({
[17:04:24.814]                   sendCondition <- NULL
[17:04:24.814]                   function(frame = 1L) {
[17:04:24.814]                     if (is.function(sendCondition)) 
[17:04:24.814]                       return(sendCondition)
[17:04:24.814]                     ns <- getNamespace("parallel")
[17:04:24.814]                     if (exists("sendData", mode = "function", 
[17:04:24.814]                       envir = ns)) {
[17:04:24.814]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.814]                         envir = ns)
[17:04:24.814]                       envir <- sys.frame(frame)
[17:04:24.814]                       master <- NULL
[17:04:24.814]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.814]                         !identical(envir, emptyenv())) {
[17:04:24.814]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.814]                           inherits = FALSE)) {
[17:04:24.814]                           master <- get("master", mode = "list", 
[17:04:24.814]                             envir = envir, inherits = FALSE)
[17:04:24.814]                           if (inherits(master, c("SOCKnode", 
[17:04:24.814]                             "SOCK0node"))) {
[17:04:24.814]                             sendCondition <<- function(cond) {
[17:04:24.814]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.814]                                 success = TRUE)
[17:04:24.814]                               parallel_sendData(master, data)
[17:04:24.814]                             }
[17:04:24.814]                             return(sendCondition)
[17:04:24.814]                           }
[17:04:24.814]                         }
[17:04:24.814]                         frame <- frame + 1L
[17:04:24.814]                         envir <- sys.frame(frame)
[17:04:24.814]                       }
[17:04:24.814]                     }
[17:04:24.814]                     sendCondition <<- function(cond) NULL
[17:04:24.814]                   }
[17:04:24.814]                 })
[17:04:24.814]                 withCallingHandlers({
[17:04:24.814]                   {
[17:04:24.814]                     print(1:50)
[17:04:24.814]                     str(1:50)
[17:04:24.814]                     cat(letters, sep = "-")
[17:04:24.814]                     cat(1:6, collapse = "\n")
[17:04:24.814]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:24.814]                     42L
[17:04:24.814]                   }
[17:04:24.814]                 }, immediateCondition = function(cond) {
[17:04:24.814]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.814]                   sendCondition(cond)
[17:04:24.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.814]                   {
[17:04:24.814]                     inherits <- base::inherits
[17:04:24.814]                     invokeRestart <- base::invokeRestart
[17:04:24.814]                     is.null <- base::is.null
[17:04:24.814]                     muffled <- FALSE
[17:04:24.814]                     if (inherits(cond, "message")) {
[17:04:24.814]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.814]                       if (muffled) 
[17:04:24.814]                         invokeRestart("muffleMessage")
[17:04:24.814]                     }
[17:04:24.814]                     else if (inherits(cond, "warning")) {
[17:04:24.814]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.814]                       if (muffled) 
[17:04:24.814]                         invokeRestart("muffleWarning")
[17:04:24.814]                     }
[17:04:24.814]                     else if (inherits(cond, "condition")) {
[17:04:24.814]                       if (!is.null(pattern)) {
[17:04:24.814]                         computeRestarts <- base::computeRestarts
[17:04:24.814]                         grepl <- base::grepl
[17:04:24.814]                         restarts <- computeRestarts(cond)
[17:04:24.814]                         for (restart in restarts) {
[17:04:24.814]                           name <- restart$name
[17:04:24.814]                           if (is.null(name)) 
[17:04:24.814]                             next
[17:04:24.814]                           if (!grepl(pattern, name)) 
[17:04:24.814]                             next
[17:04:24.814]                           invokeRestart(restart)
[17:04:24.814]                           muffled <- TRUE
[17:04:24.814]                           break
[17:04:24.814]                         }
[17:04:24.814]                       }
[17:04:24.814]                     }
[17:04:24.814]                     invisible(muffled)
[17:04:24.814]                   }
[17:04:24.814]                   muffleCondition(cond)
[17:04:24.814]                 })
[17:04:24.814]             }))
[17:04:24.814]             future::FutureResult(value = ...future.value$value, 
[17:04:24.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.814]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.814]                     ...future.globalenv.names))
[17:04:24.814]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.814]         }, condition = base::local({
[17:04:24.814]             c <- base::c
[17:04:24.814]             inherits <- base::inherits
[17:04:24.814]             invokeRestart <- base::invokeRestart
[17:04:24.814]             length <- base::length
[17:04:24.814]             list <- base::list
[17:04:24.814]             seq.int <- base::seq.int
[17:04:24.814]             signalCondition <- base::signalCondition
[17:04:24.814]             sys.calls <- base::sys.calls
[17:04:24.814]             `[[` <- base::`[[`
[17:04:24.814]             `+` <- base::`+`
[17:04:24.814]             `<<-` <- base::`<<-`
[17:04:24.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.814]                   3L)]
[17:04:24.814]             }
[17:04:24.814]             function(cond) {
[17:04:24.814]                 is_error <- inherits(cond, "error")
[17:04:24.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.814]                   NULL)
[17:04:24.814]                 if (is_error) {
[17:04:24.814]                   sessionInformation <- function() {
[17:04:24.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.814]                       search = base::search(), system = base::Sys.info())
[17:04:24.814]                   }
[17:04:24.814]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.814]                     cond$call), session = sessionInformation(), 
[17:04:24.814]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.814]                   signalCondition(cond)
[17:04:24.814]                 }
[17:04:24.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.814]                 "immediateCondition"))) {
[17:04:24.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.814]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.814]                   if (TRUE && !signal) {
[17:04:24.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.814]                     {
[17:04:24.814]                       inherits <- base::inherits
[17:04:24.814]                       invokeRestart <- base::invokeRestart
[17:04:24.814]                       is.null <- base::is.null
[17:04:24.814]                       muffled <- FALSE
[17:04:24.814]                       if (inherits(cond, "message")) {
[17:04:24.814]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.814]                         if (muffled) 
[17:04:24.814]                           invokeRestart("muffleMessage")
[17:04:24.814]                       }
[17:04:24.814]                       else if (inherits(cond, "warning")) {
[17:04:24.814]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.814]                         if (muffled) 
[17:04:24.814]                           invokeRestart("muffleWarning")
[17:04:24.814]                       }
[17:04:24.814]                       else if (inherits(cond, "condition")) {
[17:04:24.814]                         if (!is.null(pattern)) {
[17:04:24.814]                           computeRestarts <- base::computeRestarts
[17:04:24.814]                           grepl <- base::grepl
[17:04:24.814]                           restarts <- computeRestarts(cond)
[17:04:24.814]                           for (restart in restarts) {
[17:04:24.814]                             name <- restart$name
[17:04:24.814]                             if (is.null(name)) 
[17:04:24.814]                               next
[17:04:24.814]                             if (!grepl(pattern, name)) 
[17:04:24.814]                               next
[17:04:24.814]                             invokeRestart(restart)
[17:04:24.814]                             muffled <- TRUE
[17:04:24.814]                             break
[17:04:24.814]                           }
[17:04:24.814]                         }
[17:04:24.814]                       }
[17:04:24.814]                       invisible(muffled)
[17:04:24.814]                     }
[17:04:24.814]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.814]                   }
[17:04:24.814]                 }
[17:04:24.814]                 else {
[17:04:24.814]                   if (TRUE) {
[17:04:24.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.814]                     {
[17:04:24.814]                       inherits <- base::inherits
[17:04:24.814]                       invokeRestart <- base::invokeRestart
[17:04:24.814]                       is.null <- base::is.null
[17:04:24.814]                       muffled <- FALSE
[17:04:24.814]                       if (inherits(cond, "message")) {
[17:04:24.814]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.814]                         if (muffled) 
[17:04:24.814]                           invokeRestart("muffleMessage")
[17:04:24.814]                       }
[17:04:24.814]                       else if (inherits(cond, "warning")) {
[17:04:24.814]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.814]                         if (muffled) 
[17:04:24.814]                           invokeRestart("muffleWarning")
[17:04:24.814]                       }
[17:04:24.814]                       else if (inherits(cond, "condition")) {
[17:04:24.814]                         if (!is.null(pattern)) {
[17:04:24.814]                           computeRestarts <- base::computeRestarts
[17:04:24.814]                           grepl <- base::grepl
[17:04:24.814]                           restarts <- computeRestarts(cond)
[17:04:24.814]                           for (restart in restarts) {
[17:04:24.814]                             name <- restart$name
[17:04:24.814]                             if (is.null(name)) 
[17:04:24.814]                               next
[17:04:24.814]                             if (!grepl(pattern, name)) 
[17:04:24.814]                               next
[17:04:24.814]                             invokeRestart(restart)
[17:04:24.814]                             muffled <- TRUE
[17:04:24.814]                             break
[17:04:24.814]                           }
[17:04:24.814]                         }
[17:04:24.814]                       }
[17:04:24.814]                       invisible(muffled)
[17:04:24.814]                     }
[17:04:24.814]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.814]                   }
[17:04:24.814]                 }
[17:04:24.814]             }
[17:04:24.814]         }))
[17:04:24.814]     }, error = function(ex) {
[17:04:24.814]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.814]                 ...future.rng), started = ...future.startTime, 
[17:04:24.814]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.814]             version = "1.8"), class = "FutureResult")
[17:04:24.814]     }, finally = {
[17:04:24.814]         if (!identical(...future.workdir, getwd())) 
[17:04:24.814]             setwd(...future.workdir)
[17:04:24.814]         {
[17:04:24.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.814]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.814]             }
[17:04:24.814]             base::options(...future.oldOptions)
[17:04:24.814]             if (.Platform$OS.type == "windows") {
[17:04:24.814]                 old_names <- names(...future.oldEnvVars)
[17:04:24.814]                 envs <- base::Sys.getenv()
[17:04:24.814]                 names <- names(envs)
[17:04:24.814]                 common <- intersect(names, old_names)
[17:04:24.814]                 added <- setdiff(names, old_names)
[17:04:24.814]                 removed <- setdiff(old_names, names)
[17:04:24.814]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.814]                   envs[common]]
[17:04:24.814]                 NAMES <- toupper(changed)
[17:04:24.814]                 args <- list()
[17:04:24.814]                 for (kk in seq_along(NAMES)) {
[17:04:24.814]                   name <- changed[[kk]]
[17:04:24.814]                   NAME <- NAMES[[kk]]
[17:04:24.814]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.814]                     next
[17:04:24.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.814]                 }
[17:04:24.814]                 NAMES <- toupper(added)
[17:04:24.814]                 for (kk in seq_along(NAMES)) {
[17:04:24.814]                   name <- added[[kk]]
[17:04:24.814]                   NAME <- NAMES[[kk]]
[17:04:24.814]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.814]                     next
[17:04:24.814]                   args[[name]] <- ""
[17:04:24.814]                 }
[17:04:24.814]                 NAMES <- toupper(removed)
[17:04:24.814]                 for (kk in seq_along(NAMES)) {
[17:04:24.814]                   name <- removed[[kk]]
[17:04:24.814]                   NAME <- NAMES[[kk]]
[17:04:24.814]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.814]                     next
[17:04:24.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.814]                 }
[17:04:24.814]                 if (length(args) > 0) 
[17:04:24.814]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.814]             }
[17:04:24.814]             else {
[17:04:24.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.814]             }
[17:04:24.814]             {
[17:04:24.814]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.814]                   0L) {
[17:04:24.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.814]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.814]                   base::options(opts)
[17:04:24.814]                 }
[17:04:24.814]                 {
[17:04:24.814]                   {
[17:04:24.814]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.814]                     NULL
[17:04:24.814]                   }
[17:04:24.814]                   options(future.plan = NULL)
[17:04:24.814]                   if (is.na(NA_character_)) 
[17:04:24.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.814]                     .init = FALSE)
[17:04:24.814]                 }
[17:04:24.814]             }
[17:04:24.814]         }
[17:04:24.814]     })
[17:04:24.814]     if (TRUE) {
[17:04:24.814]         base::sink(type = "output", split = FALSE)
[17:04:24.814]         if (FALSE) {
[17:04:24.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.814]         }
[17:04:24.814]         else {
[17:04:24.814]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.814]         }
[17:04:24.814]         base::close(...future.stdout)
[17:04:24.814]         ...future.stdout <- NULL
[17:04:24.814]     }
[17:04:24.814]     ...future.result$conditions <- ...future.conditions
[17:04:24.814]     ...future.result$finished <- base::Sys.time()
[17:04:24.814]     ...future.result
[17:04:24.814] }
[17:04:24.817] MultisessionFuture started
[17:04:24.817] - Launch lazy future ... done
[17:04:24.817] run() for ‘MultisessionFuture’ ... done
[17:04:24.817] result() for ClusterFuture ...
[17:04:24.818] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.818] - Validating connection of MultisessionFuture
[17:04:24.862] - received message: FutureResult
[17:04:24.863] - Received FutureResult
[17:04:24.863] - Erased future from FutureRegistry
[17:04:24.863] result() for ClusterFuture ...
[17:04:24.863] - result already collected: FutureResult
[17:04:24.863] result() for ClusterFuture ... done
[17:04:24.863] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:24.863] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:24"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:24"
 $ session_uuid: chr "08089032-45d4-f166-8a5d-17039f6c107b"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50528
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:24"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:24.871] result() for ClusterFuture ...
[17:04:24.871] - result already collected: FutureResult
[17:04:24.871] result() for ClusterFuture ... done
[17:04:24.871] result() for ClusterFuture ...
[17:04:24.871] - result already collected: FutureResult
[17:04:24.872] result() for ClusterFuture ... done
[17:04:24.872] getGlobalsAndPackages() ...
[17:04:24.872] Searching for globals...
[17:04:24.875] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:24.875] Searching for globals ... DONE
[17:04:24.875] Resolving globals: FALSE
[17:04:24.876] 
[17:04:24.876] - packages: [1] ‘utils’
[17:04:24.876] getGlobalsAndPackages() ... DONE
[17:04:24.876] run() for ‘Future’ ...
[17:04:24.876] - state: ‘created’
[17:04:24.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:24.890] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:24.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:24.890]   - Field: ‘node’
[17:04:24.891]   - Field: ‘label’
[17:04:24.891]   - Field: ‘local’
[17:04:24.891]   - Field: ‘owner’
[17:04:24.891]   - Field: ‘envir’
[17:04:24.891]   - Field: ‘workers’
[17:04:24.891]   - Field: ‘packages’
[17:04:24.891]   - Field: ‘gc’
[17:04:24.891]   - Field: ‘conditions’
[17:04:24.891]   - Field: ‘persistent’
[17:04:24.891]   - Field: ‘expr’
[17:04:24.892]   - Field: ‘uuid’
[17:04:24.892]   - Field: ‘seed’
[17:04:24.892]   - Field: ‘version’
[17:04:24.892]   - Field: ‘result’
[17:04:24.892]   - Field: ‘asynchronous’
[17:04:24.892]   - Field: ‘calls’
[17:04:24.892]   - Field: ‘globals’
[17:04:24.892]   - Field: ‘stdout’
[17:04:24.892]   - Field: ‘earlySignal’
[17:04:24.892]   - Field: ‘lazy’
[17:04:24.892]   - Field: ‘state’
[17:04:24.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:24.893] - Launch lazy future ...
[17:04:24.893] Packages needed by the future expression (n = 1): ‘utils’
[17:04:24.893] Packages needed by future strategies (n = 0): <none>
[17:04:24.894] {
[17:04:24.894]     {
[17:04:24.894]         {
[17:04:24.894]             ...future.startTime <- base::Sys.time()
[17:04:24.894]             {
[17:04:24.894]                 {
[17:04:24.894]                   {
[17:04:24.894]                     {
[17:04:24.894]                       {
[17:04:24.894]                         base::local({
[17:04:24.894]                           has_future <- base::requireNamespace("future", 
[17:04:24.894]                             quietly = TRUE)
[17:04:24.894]                           if (has_future) {
[17:04:24.894]                             ns <- base::getNamespace("future")
[17:04:24.894]                             version <- ns[[".package"]][["version"]]
[17:04:24.894]                             if (is.null(version)) 
[17:04:24.894]                               version <- utils::packageVersion("future")
[17:04:24.894]                           }
[17:04:24.894]                           else {
[17:04:24.894]                             version <- NULL
[17:04:24.894]                           }
[17:04:24.894]                           if (!has_future || version < "1.8.0") {
[17:04:24.894]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.894]                               "", base::R.version$version.string), 
[17:04:24.894]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:24.894]                                 base::R.version$platform, 8 * 
[17:04:24.894]                                   base::.Machine$sizeof.pointer), 
[17:04:24.894]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.894]                                 "release", "version")], collapse = " "), 
[17:04:24.894]                               hostname = base::Sys.info()[["nodename"]])
[17:04:24.894]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.894]                               info)
[17:04:24.894]                             info <- base::paste(info, collapse = "; ")
[17:04:24.894]                             if (!has_future) {
[17:04:24.894]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.894]                                 info)
[17:04:24.894]                             }
[17:04:24.894]                             else {
[17:04:24.894]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.894]                                 info, version)
[17:04:24.894]                             }
[17:04:24.894]                             base::stop(msg)
[17:04:24.894]                           }
[17:04:24.894]                         })
[17:04:24.894]                       }
[17:04:24.894]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.894]                       base::options(mc.cores = 1L)
[17:04:24.894]                     }
[17:04:24.894]                     base::local({
[17:04:24.894]                       for (pkg in "utils") {
[17:04:24.894]                         base::loadNamespace(pkg)
[17:04:24.894]                         base::library(pkg, character.only = TRUE)
[17:04:24.894]                       }
[17:04:24.894]                     })
[17:04:24.894]                   }
[17:04:24.894]                   ...future.strategy.old <- future::plan("list")
[17:04:24.894]                   options(future.plan = NULL)
[17:04:24.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.894]                 }
[17:04:24.894]                 ...future.workdir <- getwd()
[17:04:24.894]             }
[17:04:24.894]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.894]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.894]         }
[17:04:24.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.894]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.894]             base::names(...future.oldOptions))
[17:04:24.894]     }
[17:04:24.894]     if (FALSE) {
[17:04:24.894]     }
[17:04:24.894]     else {
[17:04:24.894]         if (FALSE) {
[17:04:24.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.894]                 open = "w")
[17:04:24.894]         }
[17:04:24.894]         else {
[17:04:24.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.894]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.894]         }
[17:04:24.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.894]             base::sink(type = "output", split = FALSE)
[17:04:24.894]             base::close(...future.stdout)
[17:04:24.894]         }, add = TRUE)
[17:04:24.894]     }
[17:04:24.894]     ...future.frame <- base::sys.nframe()
[17:04:24.894]     ...future.conditions <- base::list()
[17:04:24.894]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.894]     if (FALSE) {
[17:04:24.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.894]     }
[17:04:24.894]     ...future.result <- base::tryCatch({
[17:04:24.894]         base::withCallingHandlers({
[17:04:24.894]             ...future.value <- base::withVisible(base::local({
[17:04:24.894]                 ...future.makeSendCondition <- base::local({
[17:04:24.894]                   sendCondition <- NULL
[17:04:24.894]                   function(frame = 1L) {
[17:04:24.894]                     if (is.function(sendCondition)) 
[17:04:24.894]                       return(sendCondition)
[17:04:24.894]                     ns <- getNamespace("parallel")
[17:04:24.894]                     if (exists("sendData", mode = "function", 
[17:04:24.894]                       envir = ns)) {
[17:04:24.894]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.894]                         envir = ns)
[17:04:24.894]                       envir <- sys.frame(frame)
[17:04:24.894]                       master <- NULL
[17:04:24.894]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.894]                         !identical(envir, emptyenv())) {
[17:04:24.894]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.894]                           inherits = FALSE)) {
[17:04:24.894]                           master <- get("master", mode = "list", 
[17:04:24.894]                             envir = envir, inherits = FALSE)
[17:04:24.894]                           if (inherits(master, c("SOCKnode", 
[17:04:24.894]                             "SOCK0node"))) {
[17:04:24.894]                             sendCondition <<- function(cond) {
[17:04:24.894]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.894]                                 success = TRUE)
[17:04:24.894]                               parallel_sendData(master, data)
[17:04:24.894]                             }
[17:04:24.894]                             return(sendCondition)
[17:04:24.894]                           }
[17:04:24.894]                         }
[17:04:24.894]                         frame <- frame + 1L
[17:04:24.894]                         envir <- sys.frame(frame)
[17:04:24.894]                       }
[17:04:24.894]                     }
[17:04:24.894]                     sendCondition <<- function(cond) NULL
[17:04:24.894]                   }
[17:04:24.894]                 })
[17:04:24.894]                 withCallingHandlers({
[17:04:24.894]                   {
[17:04:24.894]                     print(1:50)
[17:04:24.894]                     str(1:50)
[17:04:24.894]                     cat(letters, sep = "-")
[17:04:24.894]                     cat(1:6, collapse = "\n")
[17:04:24.894]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:24.894]                     42L
[17:04:24.894]                   }
[17:04:24.894]                 }, immediateCondition = function(cond) {
[17:04:24.894]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.894]                   sendCondition(cond)
[17:04:24.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.894]                   {
[17:04:24.894]                     inherits <- base::inherits
[17:04:24.894]                     invokeRestart <- base::invokeRestart
[17:04:24.894]                     is.null <- base::is.null
[17:04:24.894]                     muffled <- FALSE
[17:04:24.894]                     if (inherits(cond, "message")) {
[17:04:24.894]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.894]                       if (muffled) 
[17:04:24.894]                         invokeRestart("muffleMessage")
[17:04:24.894]                     }
[17:04:24.894]                     else if (inherits(cond, "warning")) {
[17:04:24.894]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.894]                       if (muffled) 
[17:04:24.894]                         invokeRestart("muffleWarning")
[17:04:24.894]                     }
[17:04:24.894]                     else if (inherits(cond, "condition")) {
[17:04:24.894]                       if (!is.null(pattern)) {
[17:04:24.894]                         computeRestarts <- base::computeRestarts
[17:04:24.894]                         grepl <- base::grepl
[17:04:24.894]                         restarts <- computeRestarts(cond)
[17:04:24.894]                         for (restart in restarts) {
[17:04:24.894]                           name <- restart$name
[17:04:24.894]                           if (is.null(name)) 
[17:04:24.894]                             next
[17:04:24.894]                           if (!grepl(pattern, name)) 
[17:04:24.894]                             next
[17:04:24.894]                           invokeRestart(restart)
[17:04:24.894]                           muffled <- TRUE
[17:04:24.894]                           break
[17:04:24.894]                         }
[17:04:24.894]                       }
[17:04:24.894]                     }
[17:04:24.894]                     invisible(muffled)
[17:04:24.894]                   }
[17:04:24.894]                   muffleCondition(cond)
[17:04:24.894]                 })
[17:04:24.894]             }))
[17:04:24.894]             future::FutureResult(value = ...future.value$value, 
[17:04:24.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.894]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.894]                     ...future.globalenv.names))
[17:04:24.894]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.894]         }, condition = base::local({
[17:04:24.894]             c <- base::c
[17:04:24.894]             inherits <- base::inherits
[17:04:24.894]             invokeRestart <- base::invokeRestart
[17:04:24.894]             length <- base::length
[17:04:24.894]             list <- base::list
[17:04:24.894]             seq.int <- base::seq.int
[17:04:24.894]             signalCondition <- base::signalCondition
[17:04:24.894]             sys.calls <- base::sys.calls
[17:04:24.894]             `[[` <- base::`[[`
[17:04:24.894]             `+` <- base::`+`
[17:04:24.894]             `<<-` <- base::`<<-`
[17:04:24.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.894]                   3L)]
[17:04:24.894]             }
[17:04:24.894]             function(cond) {
[17:04:24.894]                 is_error <- inherits(cond, "error")
[17:04:24.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.894]                   NULL)
[17:04:24.894]                 if (is_error) {
[17:04:24.894]                   sessionInformation <- function() {
[17:04:24.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.894]                       search = base::search(), system = base::Sys.info())
[17:04:24.894]                   }
[17:04:24.894]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.894]                     cond$call), session = sessionInformation(), 
[17:04:24.894]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.894]                   signalCondition(cond)
[17:04:24.894]                 }
[17:04:24.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.894]                 "immediateCondition"))) {
[17:04:24.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.894]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.894]                   if (TRUE && !signal) {
[17:04:24.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.894]                     {
[17:04:24.894]                       inherits <- base::inherits
[17:04:24.894]                       invokeRestart <- base::invokeRestart
[17:04:24.894]                       is.null <- base::is.null
[17:04:24.894]                       muffled <- FALSE
[17:04:24.894]                       if (inherits(cond, "message")) {
[17:04:24.894]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.894]                         if (muffled) 
[17:04:24.894]                           invokeRestart("muffleMessage")
[17:04:24.894]                       }
[17:04:24.894]                       else if (inherits(cond, "warning")) {
[17:04:24.894]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.894]                         if (muffled) 
[17:04:24.894]                           invokeRestart("muffleWarning")
[17:04:24.894]                       }
[17:04:24.894]                       else if (inherits(cond, "condition")) {
[17:04:24.894]                         if (!is.null(pattern)) {
[17:04:24.894]                           computeRestarts <- base::computeRestarts
[17:04:24.894]                           grepl <- base::grepl
[17:04:24.894]                           restarts <- computeRestarts(cond)
[17:04:24.894]                           for (restart in restarts) {
[17:04:24.894]                             name <- restart$name
[17:04:24.894]                             if (is.null(name)) 
[17:04:24.894]                               next
[17:04:24.894]                             if (!grepl(pattern, name)) 
[17:04:24.894]                               next
[17:04:24.894]                             invokeRestart(restart)
[17:04:24.894]                             muffled <- TRUE
[17:04:24.894]                             break
[17:04:24.894]                           }
[17:04:24.894]                         }
[17:04:24.894]                       }
[17:04:24.894]                       invisible(muffled)
[17:04:24.894]                     }
[17:04:24.894]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.894]                   }
[17:04:24.894]                 }
[17:04:24.894]                 else {
[17:04:24.894]                   if (TRUE) {
[17:04:24.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.894]                     {
[17:04:24.894]                       inherits <- base::inherits
[17:04:24.894]                       invokeRestart <- base::invokeRestart
[17:04:24.894]                       is.null <- base::is.null
[17:04:24.894]                       muffled <- FALSE
[17:04:24.894]                       if (inherits(cond, "message")) {
[17:04:24.894]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.894]                         if (muffled) 
[17:04:24.894]                           invokeRestart("muffleMessage")
[17:04:24.894]                       }
[17:04:24.894]                       else if (inherits(cond, "warning")) {
[17:04:24.894]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.894]                         if (muffled) 
[17:04:24.894]                           invokeRestart("muffleWarning")
[17:04:24.894]                       }
[17:04:24.894]                       else if (inherits(cond, "condition")) {
[17:04:24.894]                         if (!is.null(pattern)) {
[17:04:24.894]                           computeRestarts <- base::computeRestarts
[17:04:24.894]                           grepl <- base::grepl
[17:04:24.894]                           restarts <- computeRestarts(cond)
[17:04:24.894]                           for (restart in restarts) {
[17:04:24.894]                             name <- restart$name
[17:04:24.894]                             if (is.null(name)) 
[17:04:24.894]                               next
[17:04:24.894]                             if (!grepl(pattern, name)) 
[17:04:24.894]                               next
[17:04:24.894]                             invokeRestart(restart)
[17:04:24.894]                             muffled <- TRUE
[17:04:24.894]                             break
[17:04:24.894]                           }
[17:04:24.894]                         }
[17:04:24.894]                       }
[17:04:24.894]                       invisible(muffled)
[17:04:24.894]                     }
[17:04:24.894]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.894]                   }
[17:04:24.894]                 }
[17:04:24.894]             }
[17:04:24.894]         }))
[17:04:24.894]     }, error = function(ex) {
[17:04:24.894]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.894]                 ...future.rng), started = ...future.startTime, 
[17:04:24.894]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.894]             version = "1.8"), class = "FutureResult")
[17:04:24.894]     }, finally = {
[17:04:24.894]         if (!identical(...future.workdir, getwd())) 
[17:04:24.894]             setwd(...future.workdir)
[17:04:24.894]         {
[17:04:24.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.894]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.894]             }
[17:04:24.894]             base::options(...future.oldOptions)
[17:04:24.894]             if (.Platform$OS.type == "windows") {
[17:04:24.894]                 old_names <- names(...future.oldEnvVars)
[17:04:24.894]                 envs <- base::Sys.getenv()
[17:04:24.894]                 names <- names(envs)
[17:04:24.894]                 common <- intersect(names, old_names)
[17:04:24.894]                 added <- setdiff(names, old_names)
[17:04:24.894]                 removed <- setdiff(old_names, names)
[17:04:24.894]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.894]                   envs[common]]
[17:04:24.894]                 NAMES <- toupper(changed)
[17:04:24.894]                 args <- list()
[17:04:24.894]                 for (kk in seq_along(NAMES)) {
[17:04:24.894]                   name <- changed[[kk]]
[17:04:24.894]                   NAME <- NAMES[[kk]]
[17:04:24.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.894]                     next
[17:04:24.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.894]                 }
[17:04:24.894]                 NAMES <- toupper(added)
[17:04:24.894]                 for (kk in seq_along(NAMES)) {
[17:04:24.894]                   name <- added[[kk]]
[17:04:24.894]                   NAME <- NAMES[[kk]]
[17:04:24.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.894]                     next
[17:04:24.894]                   args[[name]] <- ""
[17:04:24.894]                 }
[17:04:24.894]                 NAMES <- toupper(removed)
[17:04:24.894]                 for (kk in seq_along(NAMES)) {
[17:04:24.894]                   name <- removed[[kk]]
[17:04:24.894]                   NAME <- NAMES[[kk]]
[17:04:24.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.894]                     next
[17:04:24.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.894]                 }
[17:04:24.894]                 if (length(args) > 0) 
[17:04:24.894]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.894]             }
[17:04:24.894]             else {
[17:04:24.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.894]             }
[17:04:24.894]             {
[17:04:24.894]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.894]                   0L) {
[17:04:24.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.894]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.894]                   base::options(opts)
[17:04:24.894]                 }
[17:04:24.894]                 {
[17:04:24.894]                   {
[17:04:24.894]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.894]                     NULL
[17:04:24.894]                   }
[17:04:24.894]                   options(future.plan = NULL)
[17:04:24.894]                   if (is.na(NA_character_)) 
[17:04:24.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.894]                     .init = FALSE)
[17:04:24.894]                 }
[17:04:24.894]             }
[17:04:24.894]         }
[17:04:24.894]     })
[17:04:24.894]     if (TRUE) {
[17:04:24.894]         base::sink(type = "output", split = FALSE)
[17:04:24.894]         if (FALSE) {
[17:04:24.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.894]         }
[17:04:24.894]         else {
[17:04:24.894]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.894]         }
[17:04:24.894]         base::close(...future.stdout)
[17:04:24.894]         ...future.stdout <- NULL
[17:04:24.894]     }
[17:04:24.894]     ...future.result$conditions <- ...future.conditions
[17:04:24.894]     ...future.result$finished <- base::Sys.time()
[17:04:24.894]     ...future.result
[17:04:24.894] }
[17:04:24.897] MultisessionFuture started
[17:04:24.897] - Launch lazy future ... done
[17:04:24.897] run() for ‘MultisessionFuture’ ... done
[17:04:24.897] result() for ClusterFuture ...
[17:04:24.897] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.897] - Validating connection of MultisessionFuture
[17:04:24.942] - received message: FutureResult
[17:04:24.942] - Received FutureResult
[17:04:24.942] - Erased future from FutureRegistry
[17:04:24.943] result() for ClusterFuture ...
[17:04:24.943] - result already collected: FutureResult
[17:04:24.943] result() for ClusterFuture ... done
[17:04:24.943] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:24.943] result() for ClusterFuture ... done
[17:04:24.943] result() for ClusterFuture ...
[17:04:24.943] - result already collected: FutureResult
[17:04:24.943] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:04:24.944] getGlobalsAndPackages() ...
[17:04:24.944] Searching for globals...
[17:04:24.944] - globals found: [1] ‘print’
[17:04:24.944] Searching for globals ... DONE
[17:04:24.944] Resolving globals: FALSE
[17:04:24.945] 
[17:04:24.945] 
[17:04:24.945] getGlobalsAndPackages() ... DONE
[17:04:24.945] run() for ‘Future’ ...
[17:04:24.945] - state: ‘created’
[17:04:24.945] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:24.959] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:24.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:24.960]   - Field: ‘node’
[17:04:24.960]   - Field: ‘label’
[17:04:24.960]   - Field: ‘local’
[17:04:24.960]   - Field: ‘owner’
[17:04:24.960]   - Field: ‘envir’
[17:04:24.960]   - Field: ‘workers’
[17:04:24.960]   - Field: ‘packages’
[17:04:24.960]   - Field: ‘gc’
[17:04:24.961]   - Field: ‘conditions’
[17:04:24.961]   - Field: ‘persistent’
[17:04:24.961]   - Field: ‘expr’
[17:04:24.961]   - Field: ‘uuid’
[17:04:24.961]   - Field: ‘seed’
[17:04:24.961]   - Field: ‘version’
[17:04:24.961]   - Field: ‘result’
[17:04:24.961]   - Field: ‘asynchronous’
[17:04:24.961]   - Field: ‘calls’
[17:04:24.961]   - Field: ‘globals’
[17:04:24.961]   - Field: ‘stdout’
[17:04:24.962]   - Field: ‘earlySignal’
[17:04:24.962]   - Field: ‘lazy’
[17:04:24.962]   - Field: ‘state’
[17:04:24.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:24.962] - Launch lazy future ...
[17:04:24.962] Packages needed by the future expression (n = 0): <none>
[17:04:24.962] Packages needed by future strategies (n = 0): <none>
[17:04:24.963] {
[17:04:24.963]     {
[17:04:24.963]         {
[17:04:24.963]             ...future.startTime <- base::Sys.time()
[17:04:24.963]             {
[17:04:24.963]                 {
[17:04:24.963]                   {
[17:04:24.963]                     {
[17:04:24.963]                       base::local({
[17:04:24.963]                         has_future <- base::requireNamespace("future", 
[17:04:24.963]                           quietly = TRUE)
[17:04:24.963]                         if (has_future) {
[17:04:24.963]                           ns <- base::getNamespace("future")
[17:04:24.963]                           version <- ns[[".package"]][["version"]]
[17:04:24.963]                           if (is.null(version)) 
[17:04:24.963]                             version <- utils::packageVersion("future")
[17:04:24.963]                         }
[17:04:24.963]                         else {
[17:04:24.963]                           version <- NULL
[17:04:24.963]                         }
[17:04:24.963]                         if (!has_future || version < "1.8.0") {
[17:04:24.963]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.963]                             "", base::R.version$version.string), 
[17:04:24.963]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:24.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:24.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.963]                               "release", "version")], collapse = " "), 
[17:04:24.963]                             hostname = base::Sys.info()[["nodename"]])
[17:04:24.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.963]                             info)
[17:04:24.963]                           info <- base::paste(info, collapse = "; ")
[17:04:24.963]                           if (!has_future) {
[17:04:24.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.963]                               info)
[17:04:24.963]                           }
[17:04:24.963]                           else {
[17:04:24.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.963]                               info, version)
[17:04:24.963]                           }
[17:04:24.963]                           base::stop(msg)
[17:04:24.963]                         }
[17:04:24.963]                       })
[17:04:24.963]                     }
[17:04:24.963]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.963]                     base::options(mc.cores = 1L)
[17:04:24.963]                   }
[17:04:24.963]                   ...future.strategy.old <- future::plan("list")
[17:04:24.963]                   options(future.plan = NULL)
[17:04:24.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.963]                 }
[17:04:24.963]                 ...future.workdir <- getwd()
[17:04:24.963]             }
[17:04:24.963]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.963]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.963]         }
[17:04:24.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.963]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.963]             base::names(...future.oldOptions))
[17:04:24.963]     }
[17:04:24.963]     if (FALSE) {
[17:04:24.963]     }
[17:04:24.963]     else {
[17:04:24.963]         if (TRUE) {
[17:04:24.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.963]                 open = "w")
[17:04:24.963]         }
[17:04:24.963]         else {
[17:04:24.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.963]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.963]         }
[17:04:24.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.963]             base::sink(type = "output", split = FALSE)
[17:04:24.963]             base::close(...future.stdout)
[17:04:24.963]         }, add = TRUE)
[17:04:24.963]     }
[17:04:24.963]     ...future.frame <- base::sys.nframe()
[17:04:24.963]     ...future.conditions <- base::list()
[17:04:24.963]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.963]     if (FALSE) {
[17:04:24.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.963]     }
[17:04:24.963]     ...future.result <- base::tryCatch({
[17:04:24.963]         base::withCallingHandlers({
[17:04:24.963]             ...future.value <- base::withVisible(base::local({
[17:04:24.963]                 ...future.makeSendCondition <- base::local({
[17:04:24.963]                   sendCondition <- NULL
[17:04:24.963]                   function(frame = 1L) {
[17:04:24.963]                     if (is.function(sendCondition)) 
[17:04:24.963]                       return(sendCondition)
[17:04:24.963]                     ns <- getNamespace("parallel")
[17:04:24.963]                     if (exists("sendData", mode = "function", 
[17:04:24.963]                       envir = ns)) {
[17:04:24.963]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.963]                         envir = ns)
[17:04:24.963]                       envir <- sys.frame(frame)
[17:04:24.963]                       master <- NULL
[17:04:24.963]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.963]                         !identical(envir, emptyenv())) {
[17:04:24.963]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.963]                           inherits = FALSE)) {
[17:04:24.963]                           master <- get("master", mode = "list", 
[17:04:24.963]                             envir = envir, inherits = FALSE)
[17:04:24.963]                           if (inherits(master, c("SOCKnode", 
[17:04:24.963]                             "SOCK0node"))) {
[17:04:24.963]                             sendCondition <<- function(cond) {
[17:04:24.963]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.963]                                 success = TRUE)
[17:04:24.963]                               parallel_sendData(master, data)
[17:04:24.963]                             }
[17:04:24.963]                             return(sendCondition)
[17:04:24.963]                           }
[17:04:24.963]                         }
[17:04:24.963]                         frame <- frame + 1L
[17:04:24.963]                         envir <- sys.frame(frame)
[17:04:24.963]                       }
[17:04:24.963]                     }
[17:04:24.963]                     sendCondition <<- function(cond) NULL
[17:04:24.963]                   }
[17:04:24.963]                 })
[17:04:24.963]                 withCallingHandlers({
[17:04:24.963]                   print(42)
[17:04:24.963]                 }, immediateCondition = function(cond) {
[17:04:24.963]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.963]                   sendCondition(cond)
[17:04:24.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.963]                   {
[17:04:24.963]                     inherits <- base::inherits
[17:04:24.963]                     invokeRestart <- base::invokeRestart
[17:04:24.963]                     is.null <- base::is.null
[17:04:24.963]                     muffled <- FALSE
[17:04:24.963]                     if (inherits(cond, "message")) {
[17:04:24.963]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.963]                       if (muffled) 
[17:04:24.963]                         invokeRestart("muffleMessage")
[17:04:24.963]                     }
[17:04:24.963]                     else if (inherits(cond, "warning")) {
[17:04:24.963]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.963]                       if (muffled) 
[17:04:24.963]                         invokeRestart("muffleWarning")
[17:04:24.963]                     }
[17:04:24.963]                     else if (inherits(cond, "condition")) {
[17:04:24.963]                       if (!is.null(pattern)) {
[17:04:24.963]                         computeRestarts <- base::computeRestarts
[17:04:24.963]                         grepl <- base::grepl
[17:04:24.963]                         restarts <- computeRestarts(cond)
[17:04:24.963]                         for (restart in restarts) {
[17:04:24.963]                           name <- restart$name
[17:04:24.963]                           if (is.null(name)) 
[17:04:24.963]                             next
[17:04:24.963]                           if (!grepl(pattern, name)) 
[17:04:24.963]                             next
[17:04:24.963]                           invokeRestart(restart)
[17:04:24.963]                           muffled <- TRUE
[17:04:24.963]                           break
[17:04:24.963]                         }
[17:04:24.963]                       }
[17:04:24.963]                     }
[17:04:24.963]                     invisible(muffled)
[17:04:24.963]                   }
[17:04:24.963]                   muffleCondition(cond)
[17:04:24.963]                 })
[17:04:24.963]             }))
[17:04:24.963]             future::FutureResult(value = ...future.value$value, 
[17:04:24.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.963]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.963]                     ...future.globalenv.names))
[17:04:24.963]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.963]         }, condition = base::local({
[17:04:24.963]             c <- base::c
[17:04:24.963]             inherits <- base::inherits
[17:04:24.963]             invokeRestart <- base::invokeRestart
[17:04:24.963]             length <- base::length
[17:04:24.963]             list <- base::list
[17:04:24.963]             seq.int <- base::seq.int
[17:04:24.963]             signalCondition <- base::signalCondition
[17:04:24.963]             sys.calls <- base::sys.calls
[17:04:24.963]             `[[` <- base::`[[`
[17:04:24.963]             `+` <- base::`+`
[17:04:24.963]             `<<-` <- base::`<<-`
[17:04:24.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.963]                   3L)]
[17:04:24.963]             }
[17:04:24.963]             function(cond) {
[17:04:24.963]                 is_error <- inherits(cond, "error")
[17:04:24.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.963]                   NULL)
[17:04:24.963]                 if (is_error) {
[17:04:24.963]                   sessionInformation <- function() {
[17:04:24.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.963]                       search = base::search(), system = base::Sys.info())
[17:04:24.963]                   }
[17:04:24.963]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.963]                     cond$call), session = sessionInformation(), 
[17:04:24.963]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.963]                   signalCondition(cond)
[17:04:24.963]                 }
[17:04:24.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.963]                 "immediateCondition"))) {
[17:04:24.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.963]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.963]                   if (TRUE && !signal) {
[17:04:24.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.963]                     {
[17:04:24.963]                       inherits <- base::inherits
[17:04:24.963]                       invokeRestart <- base::invokeRestart
[17:04:24.963]                       is.null <- base::is.null
[17:04:24.963]                       muffled <- FALSE
[17:04:24.963]                       if (inherits(cond, "message")) {
[17:04:24.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.963]                         if (muffled) 
[17:04:24.963]                           invokeRestart("muffleMessage")
[17:04:24.963]                       }
[17:04:24.963]                       else if (inherits(cond, "warning")) {
[17:04:24.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.963]                         if (muffled) 
[17:04:24.963]                           invokeRestart("muffleWarning")
[17:04:24.963]                       }
[17:04:24.963]                       else if (inherits(cond, "condition")) {
[17:04:24.963]                         if (!is.null(pattern)) {
[17:04:24.963]                           computeRestarts <- base::computeRestarts
[17:04:24.963]                           grepl <- base::grepl
[17:04:24.963]                           restarts <- computeRestarts(cond)
[17:04:24.963]                           for (restart in restarts) {
[17:04:24.963]                             name <- restart$name
[17:04:24.963]                             if (is.null(name)) 
[17:04:24.963]                               next
[17:04:24.963]                             if (!grepl(pattern, name)) 
[17:04:24.963]                               next
[17:04:24.963]                             invokeRestart(restart)
[17:04:24.963]                             muffled <- TRUE
[17:04:24.963]                             break
[17:04:24.963]                           }
[17:04:24.963]                         }
[17:04:24.963]                       }
[17:04:24.963]                       invisible(muffled)
[17:04:24.963]                     }
[17:04:24.963]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.963]                   }
[17:04:24.963]                 }
[17:04:24.963]                 else {
[17:04:24.963]                   if (TRUE) {
[17:04:24.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.963]                     {
[17:04:24.963]                       inherits <- base::inherits
[17:04:24.963]                       invokeRestart <- base::invokeRestart
[17:04:24.963]                       is.null <- base::is.null
[17:04:24.963]                       muffled <- FALSE
[17:04:24.963]                       if (inherits(cond, "message")) {
[17:04:24.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.963]                         if (muffled) 
[17:04:24.963]                           invokeRestart("muffleMessage")
[17:04:24.963]                       }
[17:04:24.963]                       else if (inherits(cond, "warning")) {
[17:04:24.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.963]                         if (muffled) 
[17:04:24.963]                           invokeRestart("muffleWarning")
[17:04:24.963]                       }
[17:04:24.963]                       else if (inherits(cond, "condition")) {
[17:04:24.963]                         if (!is.null(pattern)) {
[17:04:24.963]                           computeRestarts <- base::computeRestarts
[17:04:24.963]                           grepl <- base::grepl
[17:04:24.963]                           restarts <- computeRestarts(cond)
[17:04:24.963]                           for (restart in restarts) {
[17:04:24.963]                             name <- restart$name
[17:04:24.963]                             if (is.null(name)) 
[17:04:24.963]                               next
[17:04:24.963]                             if (!grepl(pattern, name)) 
[17:04:24.963]                               next
[17:04:24.963]                             invokeRestart(restart)
[17:04:24.963]                             muffled <- TRUE
[17:04:24.963]                             break
[17:04:24.963]                           }
[17:04:24.963]                         }
[17:04:24.963]                       }
[17:04:24.963]                       invisible(muffled)
[17:04:24.963]                     }
[17:04:24.963]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.963]                   }
[17:04:24.963]                 }
[17:04:24.963]             }
[17:04:24.963]         }))
[17:04:24.963]     }, error = function(ex) {
[17:04:24.963]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.963]                 ...future.rng), started = ...future.startTime, 
[17:04:24.963]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.963]             version = "1.8"), class = "FutureResult")
[17:04:24.963]     }, finally = {
[17:04:24.963]         if (!identical(...future.workdir, getwd())) 
[17:04:24.963]             setwd(...future.workdir)
[17:04:24.963]         {
[17:04:24.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.963]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.963]             }
[17:04:24.963]             base::options(...future.oldOptions)
[17:04:24.963]             if (.Platform$OS.type == "windows") {
[17:04:24.963]                 old_names <- names(...future.oldEnvVars)
[17:04:24.963]                 envs <- base::Sys.getenv()
[17:04:24.963]                 names <- names(envs)
[17:04:24.963]                 common <- intersect(names, old_names)
[17:04:24.963]                 added <- setdiff(names, old_names)
[17:04:24.963]                 removed <- setdiff(old_names, names)
[17:04:24.963]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.963]                   envs[common]]
[17:04:24.963]                 NAMES <- toupper(changed)
[17:04:24.963]                 args <- list()
[17:04:24.963]                 for (kk in seq_along(NAMES)) {
[17:04:24.963]                   name <- changed[[kk]]
[17:04:24.963]                   NAME <- NAMES[[kk]]
[17:04:24.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.963]                     next
[17:04:24.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.963]                 }
[17:04:24.963]                 NAMES <- toupper(added)
[17:04:24.963]                 for (kk in seq_along(NAMES)) {
[17:04:24.963]                   name <- added[[kk]]
[17:04:24.963]                   NAME <- NAMES[[kk]]
[17:04:24.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.963]                     next
[17:04:24.963]                   args[[name]] <- ""
[17:04:24.963]                 }
[17:04:24.963]                 NAMES <- toupper(removed)
[17:04:24.963]                 for (kk in seq_along(NAMES)) {
[17:04:24.963]                   name <- removed[[kk]]
[17:04:24.963]                   NAME <- NAMES[[kk]]
[17:04:24.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.963]                     next
[17:04:24.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.963]                 }
[17:04:24.963]                 if (length(args) > 0) 
[17:04:24.963]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.963]             }
[17:04:24.963]             else {
[17:04:24.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.963]             }
[17:04:24.963]             {
[17:04:24.963]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.963]                   0L) {
[17:04:24.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.963]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.963]                   base::options(opts)
[17:04:24.963]                 }
[17:04:24.963]                 {
[17:04:24.963]                   {
[17:04:24.963]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.963]                     NULL
[17:04:24.963]                   }
[17:04:24.963]                   options(future.plan = NULL)
[17:04:24.963]                   if (is.na(NA_character_)) 
[17:04:24.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.963]                     .init = FALSE)
[17:04:24.963]                 }
[17:04:24.963]             }
[17:04:24.963]         }
[17:04:24.963]     })
[17:04:24.963]     if (TRUE) {
[17:04:24.963]         base::sink(type = "output", split = FALSE)
[17:04:24.963]         if (TRUE) {
[17:04:24.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.963]         }
[17:04:24.963]         else {
[17:04:24.963]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.963]         }
[17:04:24.963]         base::close(...future.stdout)
[17:04:24.963]         ...future.stdout <- NULL
[17:04:24.963]     }
[17:04:24.963]     ...future.result$conditions <- ...future.conditions
[17:04:24.963]     ...future.result$finished <- base::Sys.time()
[17:04:24.963]     ...future.result
[17:04:24.963] }
[17:04:24.966] MultisessionFuture started
[17:04:24.966] - Launch lazy future ... done
[17:04:24.966] run() for ‘MultisessionFuture’ ... done
[17:04:24.966] result() for ClusterFuture ...
[17:04:24.967] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.967] - Validating connection of MultisessionFuture
[17:04:24.968] - received message: FutureResult
[17:04:24.968] - Received FutureResult
[17:04:24.968] - Erased future from FutureRegistry
[17:04:24.969] result() for ClusterFuture ...
[17:04:24.969] - result already collected: FutureResult
[17:04:24.969] result() for ClusterFuture ... done
[17:04:24.969] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:24.969] result() for ClusterFuture ... done
[17:04:24.969] result() for ClusterFuture ...
[17:04:24.969] - result already collected: FutureResult
[17:04:24.969] result() for ClusterFuture ... done
[17:04:24.969] result() for ClusterFuture ...
[17:04:24.969] - result already collected: FutureResult
[17:04:24.969] result() for ClusterFuture ... done
[1] 42
[17:04:24.970] result() for ClusterFuture ...
[17:04:24.970] - result already collected: FutureResult
[17:04:24.970] result() for ClusterFuture ... done
- stdout = NA
[17:04:24.970] getGlobalsAndPackages() ...
[17:04:24.970] Searching for globals...
[17:04:24.973] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:24.973] Searching for globals ... DONE
[17:04:24.973] Resolving globals: FALSE
[17:04:24.974] 
[17:04:24.974] - packages: [1] ‘utils’
[17:04:24.974] getGlobalsAndPackages() ... DONE
[17:04:24.974] run() for ‘Future’ ...
[17:04:24.974] - state: ‘created’
[17:04:24.974] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:24.989] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:24.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:24.989]   - Field: ‘node’
[17:04:24.989]   - Field: ‘label’
[17:04:24.989]   - Field: ‘local’
[17:04:24.989]   - Field: ‘owner’
[17:04:24.989]   - Field: ‘envir’
[17:04:24.989]   - Field: ‘workers’
[17:04:24.989]   - Field: ‘packages’
[17:04:24.990]   - Field: ‘gc’
[17:04:24.990]   - Field: ‘conditions’
[17:04:24.990]   - Field: ‘persistent’
[17:04:24.990]   - Field: ‘expr’
[17:04:24.990]   - Field: ‘uuid’
[17:04:24.990]   - Field: ‘seed’
[17:04:24.990]   - Field: ‘version’
[17:04:24.990]   - Field: ‘result’
[17:04:24.990]   - Field: ‘asynchronous’
[17:04:24.990]   - Field: ‘calls’
[17:04:24.990]   - Field: ‘globals’
[17:04:24.991]   - Field: ‘stdout’
[17:04:24.991]   - Field: ‘earlySignal’
[17:04:24.991]   - Field: ‘lazy’
[17:04:24.991]   - Field: ‘state’
[17:04:24.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:24.991] - Launch lazy future ...
[17:04:24.993] Packages needed by the future expression (n = 1): ‘utils’
[17:04:24.993] Packages needed by future strategies (n = 0): <none>
[17:04:24.994] {
[17:04:24.994]     {
[17:04:24.994]         {
[17:04:24.994]             ...future.startTime <- base::Sys.time()
[17:04:24.994]             {
[17:04:24.994]                 {
[17:04:24.994]                   {
[17:04:24.994]                     {
[17:04:24.994]                       {
[17:04:24.994]                         base::local({
[17:04:24.994]                           has_future <- base::requireNamespace("future", 
[17:04:24.994]                             quietly = TRUE)
[17:04:24.994]                           if (has_future) {
[17:04:24.994]                             ns <- base::getNamespace("future")
[17:04:24.994]                             version <- ns[[".package"]][["version"]]
[17:04:24.994]                             if (is.null(version)) 
[17:04:24.994]                               version <- utils::packageVersion("future")
[17:04:24.994]                           }
[17:04:24.994]                           else {
[17:04:24.994]                             version <- NULL
[17:04:24.994]                           }
[17:04:24.994]                           if (!has_future || version < "1.8.0") {
[17:04:24.994]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:24.994]                               "", base::R.version$version.string), 
[17:04:24.994]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:24.994]                                 base::R.version$platform, 8 * 
[17:04:24.994]                                   base::.Machine$sizeof.pointer), 
[17:04:24.994]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:24.994]                                 "release", "version")], collapse = " "), 
[17:04:24.994]                               hostname = base::Sys.info()[["nodename"]])
[17:04:24.994]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:24.994]                               info)
[17:04:24.994]                             info <- base::paste(info, collapse = "; ")
[17:04:24.994]                             if (!has_future) {
[17:04:24.994]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:24.994]                                 info)
[17:04:24.994]                             }
[17:04:24.994]                             else {
[17:04:24.994]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:24.994]                                 info, version)
[17:04:24.994]                             }
[17:04:24.994]                             base::stop(msg)
[17:04:24.994]                           }
[17:04:24.994]                         })
[17:04:24.994]                       }
[17:04:24.994]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:24.994]                       base::options(mc.cores = 1L)
[17:04:24.994]                     }
[17:04:24.994]                     base::local({
[17:04:24.994]                       for (pkg in "utils") {
[17:04:24.994]                         base::loadNamespace(pkg)
[17:04:24.994]                         base::library(pkg, character.only = TRUE)
[17:04:24.994]                       }
[17:04:24.994]                     })
[17:04:24.994]                   }
[17:04:24.994]                   ...future.strategy.old <- future::plan("list")
[17:04:24.994]                   options(future.plan = NULL)
[17:04:24.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:24.994]                 }
[17:04:24.994]                 ...future.workdir <- getwd()
[17:04:24.994]             }
[17:04:24.994]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:24.994]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:24.994]         }
[17:04:24.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:24.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:24.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:24.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:24.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:24.994]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:24.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:24.994]             base::names(...future.oldOptions))
[17:04:24.994]     }
[17:04:24.994]     if (TRUE) {
[17:04:24.994]     }
[17:04:24.994]     else {
[17:04:24.994]         if (NA) {
[17:04:24.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:24.994]                 open = "w")
[17:04:24.994]         }
[17:04:24.994]         else {
[17:04:24.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:24.994]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:24.994]         }
[17:04:24.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:24.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:24.994]             base::sink(type = "output", split = FALSE)
[17:04:24.994]             base::close(...future.stdout)
[17:04:24.994]         }, add = TRUE)
[17:04:24.994]     }
[17:04:24.994]     ...future.frame <- base::sys.nframe()
[17:04:24.994]     ...future.conditions <- base::list()
[17:04:24.994]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:24.994]     if (FALSE) {
[17:04:24.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:24.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:24.994]     }
[17:04:24.994]     ...future.result <- base::tryCatch({
[17:04:24.994]         base::withCallingHandlers({
[17:04:24.994]             ...future.value <- base::withVisible(base::local({
[17:04:24.994]                 ...future.makeSendCondition <- base::local({
[17:04:24.994]                   sendCondition <- NULL
[17:04:24.994]                   function(frame = 1L) {
[17:04:24.994]                     if (is.function(sendCondition)) 
[17:04:24.994]                       return(sendCondition)
[17:04:24.994]                     ns <- getNamespace("parallel")
[17:04:24.994]                     if (exists("sendData", mode = "function", 
[17:04:24.994]                       envir = ns)) {
[17:04:24.994]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:24.994]                         envir = ns)
[17:04:24.994]                       envir <- sys.frame(frame)
[17:04:24.994]                       master <- NULL
[17:04:24.994]                       while (!identical(envir, .GlobalEnv) && 
[17:04:24.994]                         !identical(envir, emptyenv())) {
[17:04:24.994]                         if (exists("master", mode = "list", envir = envir, 
[17:04:24.994]                           inherits = FALSE)) {
[17:04:24.994]                           master <- get("master", mode = "list", 
[17:04:24.994]                             envir = envir, inherits = FALSE)
[17:04:24.994]                           if (inherits(master, c("SOCKnode", 
[17:04:24.994]                             "SOCK0node"))) {
[17:04:24.994]                             sendCondition <<- function(cond) {
[17:04:24.994]                               data <- list(type = "VALUE", value = cond, 
[17:04:24.994]                                 success = TRUE)
[17:04:24.994]                               parallel_sendData(master, data)
[17:04:24.994]                             }
[17:04:24.994]                             return(sendCondition)
[17:04:24.994]                           }
[17:04:24.994]                         }
[17:04:24.994]                         frame <- frame + 1L
[17:04:24.994]                         envir <- sys.frame(frame)
[17:04:24.994]                       }
[17:04:24.994]                     }
[17:04:24.994]                     sendCondition <<- function(cond) NULL
[17:04:24.994]                   }
[17:04:24.994]                 })
[17:04:24.994]                 withCallingHandlers({
[17:04:24.994]                   {
[17:04:24.994]                     print(1:50)
[17:04:24.994]                     str(1:50)
[17:04:24.994]                     cat(letters, sep = "-")
[17:04:24.994]                     cat(1:6, collapse = "\n")
[17:04:24.994]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:24.994]                     42L
[17:04:24.994]                   }
[17:04:24.994]                 }, immediateCondition = function(cond) {
[17:04:24.994]                   sendCondition <- ...future.makeSendCondition()
[17:04:24.994]                   sendCondition(cond)
[17:04:24.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.994]                   {
[17:04:24.994]                     inherits <- base::inherits
[17:04:24.994]                     invokeRestart <- base::invokeRestart
[17:04:24.994]                     is.null <- base::is.null
[17:04:24.994]                     muffled <- FALSE
[17:04:24.994]                     if (inherits(cond, "message")) {
[17:04:24.994]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:24.994]                       if (muffled) 
[17:04:24.994]                         invokeRestart("muffleMessage")
[17:04:24.994]                     }
[17:04:24.994]                     else if (inherits(cond, "warning")) {
[17:04:24.994]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:24.994]                       if (muffled) 
[17:04:24.994]                         invokeRestart("muffleWarning")
[17:04:24.994]                     }
[17:04:24.994]                     else if (inherits(cond, "condition")) {
[17:04:24.994]                       if (!is.null(pattern)) {
[17:04:24.994]                         computeRestarts <- base::computeRestarts
[17:04:24.994]                         grepl <- base::grepl
[17:04:24.994]                         restarts <- computeRestarts(cond)
[17:04:24.994]                         for (restart in restarts) {
[17:04:24.994]                           name <- restart$name
[17:04:24.994]                           if (is.null(name)) 
[17:04:24.994]                             next
[17:04:24.994]                           if (!grepl(pattern, name)) 
[17:04:24.994]                             next
[17:04:24.994]                           invokeRestart(restart)
[17:04:24.994]                           muffled <- TRUE
[17:04:24.994]                           break
[17:04:24.994]                         }
[17:04:24.994]                       }
[17:04:24.994]                     }
[17:04:24.994]                     invisible(muffled)
[17:04:24.994]                   }
[17:04:24.994]                   muffleCondition(cond)
[17:04:24.994]                 })
[17:04:24.994]             }))
[17:04:24.994]             future::FutureResult(value = ...future.value$value, 
[17:04:24.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.994]                   ...future.rng), globalenv = if (FALSE) 
[17:04:24.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:24.994]                     ...future.globalenv.names))
[17:04:24.994]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:24.994]         }, condition = base::local({
[17:04:24.994]             c <- base::c
[17:04:24.994]             inherits <- base::inherits
[17:04:24.994]             invokeRestart <- base::invokeRestart
[17:04:24.994]             length <- base::length
[17:04:24.994]             list <- base::list
[17:04:24.994]             seq.int <- base::seq.int
[17:04:24.994]             signalCondition <- base::signalCondition
[17:04:24.994]             sys.calls <- base::sys.calls
[17:04:24.994]             `[[` <- base::`[[`
[17:04:24.994]             `+` <- base::`+`
[17:04:24.994]             `<<-` <- base::`<<-`
[17:04:24.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:24.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:24.994]                   3L)]
[17:04:24.994]             }
[17:04:24.994]             function(cond) {
[17:04:24.994]                 is_error <- inherits(cond, "error")
[17:04:24.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:24.994]                   NULL)
[17:04:24.994]                 if (is_error) {
[17:04:24.994]                   sessionInformation <- function() {
[17:04:24.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:24.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:24.994]                       search = base::search(), system = base::Sys.info())
[17:04:24.994]                   }
[17:04:24.994]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:24.994]                     cond$call), session = sessionInformation(), 
[17:04:24.994]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:24.994]                   signalCondition(cond)
[17:04:24.994]                 }
[17:04:24.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:24.994]                 "immediateCondition"))) {
[17:04:24.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:24.994]                   ...future.conditions[[length(...future.conditions) + 
[17:04:24.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:24.994]                   if (TRUE && !signal) {
[17:04:24.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.994]                     {
[17:04:24.994]                       inherits <- base::inherits
[17:04:24.994]                       invokeRestart <- base::invokeRestart
[17:04:24.994]                       is.null <- base::is.null
[17:04:24.994]                       muffled <- FALSE
[17:04:24.994]                       if (inherits(cond, "message")) {
[17:04:24.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.994]                         if (muffled) 
[17:04:24.994]                           invokeRestart("muffleMessage")
[17:04:24.994]                       }
[17:04:24.994]                       else if (inherits(cond, "warning")) {
[17:04:24.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.994]                         if (muffled) 
[17:04:24.994]                           invokeRestart("muffleWarning")
[17:04:24.994]                       }
[17:04:24.994]                       else if (inherits(cond, "condition")) {
[17:04:24.994]                         if (!is.null(pattern)) {
[17:04:24.994]                           computeRestarts <- base::computeRestarts
[17:04:24.994]                           grepl <- base::grepl
[17:04:24.994]                           restarts <- computeRestarts(cond)
[17:04:24.994]                           for (restart in restarts) {
[17:04:24.994]                             name <- restart$name
[17:04:24.994]                             if (is.null(name)) 
[17:04:24.994]                               next
[17:04:24.994]                             if (!grepl(pattern, name)) 
[17:04:24.994]                               next
[17:04:24.994]                             invokeRestart(restart)
[17:04:24.994]                             muffled <- TRUE
[17:04:24.994]                             break
[17:04:24.994]                           }
[17:04:24.994]                         }
[17:04:24.994]                       }
[17:04:24.994]                       invisible(muffled)
[17:04:24.994]                     }
[17:04:24.994]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.994]                   }
[17:04:24.994]                 }
[17:04:24.994]                 else {
[17:04:24.994]                   if (TRUE) {
[17:04:24.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:24.994]                     {
[17:04:24.994]                       inherits <- base::inherits
[17:04:24.994]                       invokeRestart <- base::invokeRestart
[17:04:24.994]                       is.null <- base::is.null
[17:04:24.994]                       muffled <- FALSE
[17:04:24.994]                       if (inherits(cond, "message")) {
[17:04:24.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:24.994]                         if (muffled) 
[17:04:24.994]                           invokeRestart("muffleMessage")
[17:04:24.994]                       }
[17:04:24.994]                       else if (inherits(cond, "warning")) {
[17:04:24.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:24.994]                         if (muffled) 
[17:04:24.994]                           invokeRestart("muffleWarning")
[17:04:24.994]                       }
[17:04:24.994]                       else if (inherits(cond, "condition")) {
[17:04:24.994]                         if (!is.null(pattern)) {
[17:04:24.994]                           computeRestarts <- base::computeRestarts
[17:04:24.994]                           grepl <- base::grepl
[17:04:24.994]                           restarts <- computeRestarts(cond)
[17:04:24.994]                           for (restart in restarts) {
[17:04:24.994]                             name <- restart$name
[17:04:24.994]                             if (is.null(name)) 
[17:04:24.994]                               next
[17:04:24.994]                             if (!grepl(pattern, name)) 
[17:04:24.994]                               next
[17:04:24.994]                             invokeRestart(restart)
[17:04:24.994]                             muffled <- TRUE
[17:04:24.994]                             break
[17:04:24.994]                           }
[17:04:24.994]                         }
[17:04:24.994]                       }
[17:04:24.994]                       invisible(muffled)
[17:04:24.994]                     }
[17:04:24.994]                     muffleCondition(cond, pattern = "^muffle")
[17:04:24.994]                   }
[17:04:24.994]                 }
[17:04:24.994]             }
[17:04:24.994]         }))
[17:04:24.994]     }, error = function(ex) {
[17:04:24.994]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:24.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:24.994]                 ...future.rng), started = ...future.startTime, 
[17:04:24.994]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:24.994]             version = "1.8"), class = "FutureResult")
[17:04:24.994]     }, finally = {
[17:04:24.994]         if (!identical(...future.workdir, getwd())) 
[17:04:24.994]             setwd(...future.workdir)
[17:04:24.994]         {
[17:04:24.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:24.994]                 ...future.oldOptions$nwarnings <- NULL
[17:04:24.994]             }
[17:04:24.994]             base::options(...future.oldOptions)
[17:04:24.994]             if (.Platform$OS.type == "windows") {
[17:04:24.994]                 old_names <- names(...future.oldEnvVars)
[17:04:24.994]                 envs <- base::Sys.getenv()
[17:04:24.994]                 names <- names(envs)
[17:04:24.994]                 common <- intersect(names, old_names)
[17:04:24.994]                 added <- setdiff(names, old_names)
[17:04:24.994]                 removed <- setdiff(old_names, names)
[17:04:24.994]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:24.994]                   envs[common]]
[17:04:24.994]                 NAMES <- toupper(changed)
[17:04:24.994]                 args <- list()
[17:04:24.994]                 for (kk in seq_along(NAMES)) {
[17:04:24.994]                   name <- changed[[kk]]
[17:04:24.994]                   NAME <- NAMES[[kk]]
[17:04:24.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.994]                     next
[17:04:24.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.994]                 }
[17:04:24.994]                 NAMES <- toupper(added)
[17:04:24.994]                 for (kk in seq_along(NAMES)) {
[17:04:24.994]                   name <- added[[kk]]
[17:04:24.994]                   NAME <- NAMES[[kk]]
[17:04:24.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.994]                     next
[17:04:24.994]                   args[[name]] <- ""
[17:04:24.994]                 }
[17:04:24.994]                 NAMES <- toupper(removed)
[17:04:24.994]                 for (kk in seq_along(NAMES)) {
[17:04:24.994]                   name <- removed[[kk]]
[17:04:24.994]                   NAME <- NAMES[[kk]]
[17:04:24.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:24.994]                     next
[17:04:24.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:24.994]                 }
[17:04:24.994]                 if (length(args) > 0) 
[17:04:24.994]                   base::do.call(base::Sys.setenv, args = args)
[17:04:24.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:24.994]             }
[17:04:24.994]             else {
[17:04:24.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:24.994]             }
[17:04:24.994]             {
[17:04:24.994]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:24.994]                   0L) {
[17:04:24.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:24.994]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:24.994]                   base::options(opts)
[17:04:24.994]                 }
[17:04:24.994]                 {
[17:04:24.994]                   {
[17:04:24.994]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:24.994]                     NULL
[17:04:24.994]                   }
[17:04:24.994]                   options(future.plan = NULL)
[17:04:24.994]                   if (is.na(NA_character_)) 
[17:04:24.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:24.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:24.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:24.994]                     .init = FALSE)
[17:04:24.994]                 }
[17:04:24.994]             }
[17:04:24.994]         }
[17:04:24.994]     })
[17:04:24.994]     if (FALSE) {
[17:04:24.994]         base::sink(type = "output", split = FALSE)
[17:04:24.994]         if (NA) {
[17:04:24.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:24.994]         }
[17:04:24.994]         else {
[17:04:24.994]             ...future.result["stdout"] <- base::list(NULL)
[17:04:24.994]         }
[17:04:24.994]         base::close(...future.stdout)
[17:04:24.994]         ...future.stdout <- NULL
[17:04:24.994]     }
[17:04:24.994]     ...future.result$conditions <- ...future.conditions
[17:04:24.994]     ...future.result$finished <- base::Sys.time()
[17:04:24.994]     ...future.result
[17:04:24.994] }
[17:04:24.997] MultisessionFuture started
[17:04:24.997] - Launch lazy future ... done
[17:04:24.997] run() for ‘MultisessionFuture’ ... done
[17:04:24.997] result() for ClusterFuture ...
[17:04:24.998] receiveMessageFromWorker() for ClusterFuture ...
[17:04:24.998] - Validating connection of MultisessionFuture
[17:04:25.042] - received message: FutureResult
[17:04:25.042] - Received FutureResult
[17:04:25.042] - Erased future from FutureRegistry
[17:04:25.043] result() for ClusterFuture ...
[17:04:25.043] - result already collected: FutureResult
[17:04:25.043] result() for ClusterFuture ... done
[17:04:25.043] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:25.043] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-25 17:04:25"
 $ finished    : POSIXct[1:1], format: "2024-11-25 17:04:25"
 $ session_uuid: chr "08089032-45d4-f166-8a5d-17039f6c107b"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "48b61fc2246e"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50528
  .. ..$ time  : POSIXct[1:1], format: "2024-11-25 17:04:24"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:04:25.051] result() for ClusterFuture ...
[17:04:25.051] - result already collected: FutureResult
[17:04:25.051] result() for ClusterFuture ... done
[17:04:25.051] result() for ClusterFuture ...
[17:04:25.051] - result already collected: FutureResult
[17:04:25.051] result() for ClusterFuture ... done
[17:04:25.051] getGlobalsAndPackages() ...
[17:04:25.052] Searching for globals...
[17:04:25.054] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:04:25.055] Searching for globals ... DONE
[17:04:25.055] Resolving globals: FALSE
[17:04:25.055] 
[17:04:25.055] - packages: [1] ‘utils’
[17:04:25.055] getGlobalsAndPackages() ... DONE
[17:04:25.056] run() for ‘Future’ ...
[17:04:25.056] - state: ‘created’
[17:04:25.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:25.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:25.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:25.071]   - Field: ‘node’
[17:04:25.071]   - Field: ‘label’
[17:04:25.071]   - Field: ‘local’
[17:04:25.071]   - Field: ‘owner’
[17:04:25.071]   - Field: ‘envir’
[17:04:25.071]   - Field: ‘workers’
[17:04:25.071]   - Field: ‘packages’
[17:04:25.071]   - Field: ‘gc’
[17:04:25.072]   - Field: ‘conditions’
[17:04:25.072]   - Field: ‘persistent’
[17:04:25.072]   - Field: ‘expr’
[17:04:25.072]   - Field: ‘uuid’
[17:04:25.072]   - Field: ‘seed’
[17:04:25.072]   - Field: ‘version’
[17:04:25.072]   - Field: ‘result’
[17:04:25.072]   - Field: ‘asynchronous’
[17:04:25.072]   - Field: ‘calls’
[17:04:25.072]   - Field: ‘globals’
[17:04:25.072]   - Field: ‘stdout’
[17:04:25.072]   - Field: ‘earlySignal’
[17:04:25.073]   - Field: ‘lazy’
[17:04:25.073]   - Field: ‘state’
[17:04:25.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:25.073] - Launch lazy future ...
[17:04:25.073] Packages needed by the future expression (n = 1): ‘utils’
[17:04:25.073] Packages needed by future strategies (n = 0): <none>
[17:04:25.074] {
[17:04:25.074]     {
[17:04:25.074]         {
[17:04:25.074]             ...future.startTime <- base::Sys.time()
[17:04:25.074]             {
[17:04:25.074]                 {
[17:04:25.074]                   {
[17:04:25.074]                     {
[17:04:25.074]                       {
[17:04:25.074]                         base::local({
[17:04:25.074]                           has_future <- base::requireNamespace("future", 
[17:04:25.074]                             quietly = TRUE)
[17:04:25.074]                           if (has_future) {
[17:04:25.074]                             ns <- base::getNamespace("future")
[17:04:25.074]                             version <- ns[[".package"]][["version"]]
[17:04:25.074]                             if (is.null(version)) 
[17:04:25.074]                               version <- utils::packageVersion("future")
[17:04:25.074]                           }
[17:04:25.074]                           else {
[17:04:25.074]                             version <- NULL
[17:04:25.074]                           }
[17:04:25.074]                           if (!has_future || version < "1.8.0") {
[17:04:25.074]                             info <- base::c(r_version = base::gsub("R version ", 
[17:04:25.074]                               "", base::R.version$version.string), 
[17:04:25.074]                               platform = base::sprintf("%s (%s-bit)", 
[17:04:25.074]                                 base::R.version$platform, 8 * 
[17:04:25.074]                                   base::.Machine$sizeof.pointer), 
[17:04:25.074]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:25.074]                                 "release", "version")], collapse = " "), 
[17:04:25.074]                               hostname = base::Sys.info()[["nodename"]])
[17:04:25.074]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:04:25.074]                               info)
[17:04:25.074]                             info <- base::paste(info, collapse = "; ")
[17:04:25.074]                             if (!has_future) {
[17:04:25.074]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:25.074]                                 info)
[17:04:25.074]                             }
[17:04:25.074]                             else {
[17:04:25.074]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:25.074]                                 info, version)
[17:04:25.074]                             }
[17:04:25.074]                             base::stop(msg)
[17:04:25.074]                           }
[17:04:25.074]                         })
[17:04:25.074]                       }
[17:04:25.074]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:25.074]                       base::options(mc.cores = 1L)
[17:04:25.074]                     }
[17:04:25.074]                     base::local({
[17:04:25.074]                       for (pkg in "utils") {
[17:04:25.074]                         base::loadNamespace(pkg)
[17:04:25.074]                         base::library(pkg, character.only = TRUE)
[17:04:25.074]                       }
[17:04:25.074]                     })
[17:04:25.074]                   }
[17:04:25.074]                   ...future.strategy.old <- future::plan("list")
[17:04:25.074]                   options(future.plan = NULL)
[17:04:25.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:25.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:25.074]                 }
[17:04:25.074]                 ...future.workdir <- getwd()
[17:04:25.074]             }
[17:04:25.074]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:25.074]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:25.074]         }
[17:04:25.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:25.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:25.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:25.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:25.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:25.074]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:25.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:25.074]             base::names(...future.oldOptions))
[17:04:25.074]     }
[17:04:25.074]     if (TRUE) {
[17:04:25.074]     }
[17:04:25.074]     else {
[17:04:25.074]         if (NA) {
[17:04:25.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:25.074]                 open = "w")
[17:04:25.074]         }
[17:04:25.074]         else {
[17:04:25.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:25.074]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:25.074]         }
[17:04:25.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:25.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:25.074]             base::sink(type = "output", split = FALSE)
[17:04:25.074]             base::close(...future.stdout)
[17:04:25.074]         }, add = TRUE)
[17:04:25.074]     }
[17:04:25.074]     ...future.frame <- base::sys.nframe()
[17:04:25.074]     ...future.conditions <- base::list()
[17:04:25.074]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:25.074]     if (FALSE) {
[17:04:25.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:25.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:25.074]     }
[17:04:25.074]     ...future.result <- base::tryCatch({
[17:04:25.074]         base::withCallingHandlers({
[17:04:25.074]             ...future.value <- base::withVisible(base::local({
[17:04:25.074]                 ...future.makeSendCondition <- base::local({
[17:04:25.074]                   sendCondition <- NULL
[17:04:25.074]                   function(frame = 1L) {
[17:04:25.074]                     if (is.function(sendCondition)) 
[17:04:25.074]                       return(sendCondition)
[17:04:25.074]                     ns <- getNamespace("parallel")
[17:04:25.074]                     if (exists("sendData", mode = "function", 
[17:04:25.074]                       envir = ns)) {
[17:04:25.074]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:25.074]                         envir = ns)
[17:04:25.074]                       envir <- sys.frame(frame)
[17:04:25.074]                       master <- NULL
[17:04:25.074]                       while (!identical(envir, .GlobalEnv) && 
[17:04:25.074]                         !identical(envir, emptyenv())) {
[17:04:25.074]                         if (exists("master", mode = "list", envir = envir, 
[17:04:25.074]                           inherits = FALSE)) {
[17:04:25.074]                           master <- get("master", mode = "list", 
[17:04:25.074]                             envir = envir, inherits = FALSE)
[17:04:25.074]                           if (inherits(master, c("SOCKnode", 
[17:04:25.074]                             "SOCK0node"))) {
[17:04:25.074]                             sendCondition <<- function(cond) {
[17:04:25.074]                               data <- list(type = "VALUE", value = cond, 
[17:04:25.074]                                 success = TRUE)
[17:04:25.074]                               parallel_sendData(master, data)
[17:04:25.074]                             }
[17:04:25.074]                             return(sendCondition)
[17:04:25.074]                           }
[17:04:25.074]                         }
[17:04:25.074]                         frame <- frame + 1L
[17:04:25.074]                         envir <- sys.frame(frame)
[17:04:25.074]                       }
[17:04:25.074]                     }
[17:04:25.074]                     sendCondition <<- function(cond) NULL
[17:04:25.074]                   }
[17:04:25.074]                 })
[17:04:25.074]                 withCallingHandlers({
[17:04:25.074]                   {
[17:04:25.074]                     print(1:50)
[17:04:25.074]                     str(1:50)
[17:04:25.074]                     cat(letters, sep = "-")
[17:04:25.074]                     cat(1:6, collapse = "\n")
[17:04:25.074]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:04:25.074]                     42L
[17:04:25.074]                   }
[17:04:25.074]                 }, immediateCondition = function(cond) {
[17:04:25.074]                   sendCondition <- ...future.makeSendCondition()
[17:04:25.074]                   sendCondition(cond)
[17:04:25.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:25.074]                   {
[17:04:25.074]                     inherits <- base::inherits
[17:04:25.074]                     invokeRestart <- base::invokeRestart
[17:04:25.074]                     is.null <- base::is.null
[17:04:25.074]                     muffled <- FALSE
[17:04:25.074]                     if (inherits(cond, "message")) {
[17:04:25.074]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:25.074]                       if (muffled) 
[17:04:25.074]                         invokeRestart("muffleMessage")
[17:04:25.074]                     }
[17:04:25.074]                     else if (inherits(cond, "warning")) {
[17:04:25.074]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:25.074]                       if (muffled) 
[17:04:25.074]                         invokeRestart("muffleWarning")
[17:04:25.074]                     }
[17:04:25.074]                     else if (inherits(cond, "condition")) {
[17:04:25.074]                       if (!is.null(pattern)) {
[17:04:25.074]                         computeRestarts <- base::computeRestarts
[17:04:25.074]                         grepl <- base::grepl
[17:04:25.074]                         restarts <- computeRestarts(cond)
[17:04:25.074]                         for (restart in restarts) {
[17:04:25.074]                           name <- restart$name
[17:04:25.074]                           if (is.null(name)) 
[17:04:25.074]                             next
[17:04:25.074]                           if (!grepl(pattern, name)) 
[17:04:25.074]                             next
[17:04:25.074]                           invokeRestart(restart)
[17:04:25.074]                           muffled <- TRUE
[17:04:25.074]                           break
[17:04:25.074]                         }
[17:04:25.074]                       }
[17:04:25.074]                     }
[17:04:25.074]                     invisible(muffled)
[17:04:25.074]                   }
[17:04:25.074]                   muffleCondition(cond)
[17:04:25.074]                 })
[17:04:25.074]             }))
[17:04:25.074]             future::FutureResult(value = ...future.value$value, 
[17:04:25.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:25.074]                   ...future.rng), globalenv = if (FALSE) 
[17:04:25.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:25.074]                     ...future.globalenv.names))
[17:04:25.074]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:25.074]         }, condition = base::local({
[17:04:25.074]             c <- base::c
[17:04:25.074]             inherits <- base::inherits
[17:04:25.074]             invokeRestart <- base::invokeRestart
[17:04:25.074]             length <- base::length
[17:04:25.074]             list <- base::list
[17:04:25.074]             seq.int <- base::seq.int
[17:04:25.074]             signalCondition <- base::signalCondition
[17:04:25.074]             sys.calls <- base::sys.calls
[17:04:25.074]             `[[` <- base::`[[`
[17:04:25.074]             `+` <- base::`+`
[17:04:25.074]             `<<-` <- base::`<<-`
[17:04:25.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:25.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:25.074]                   3L)]
[17:04:25.074]             }
[17:04:25.074]             function(cond) {
[17:04:25.074]                 is_error <- inherits(cond, "error")
[17:04:25.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:25.074]                   NULL)
[17:04:25.074]                 if (is_error) {
[17:04:25.074]                   sessionInformation <- function() {
[17:04:25.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:25.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:25.074]                       search = base::search(), system = base::Sys.info())
[17:04:25.074]                   }
[17:04:25.074]                   ...future.conditions[[length(...future.conditions) + 
[17:04:25.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:25.074]                     cond$call), session = sessionInformation(), 
[17:04:25.074]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:25.074]                   signalCondition(cond)
[17:04:25.074]                 }
[17:04:25.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:25.074]                 "immediateCondition"))) {
[17:04:25.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:25.074]                   ...future.conditions[[length(...future.conditions) + 
[17:04:25.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:25.074]                   if (TRUE && !signal) {
[17:04:25.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:25.074]                     {
[17:04:25.074]                       inherits <- base::inherits
[17:04:25.074]                       invokeRestart <- base::invokeRestart
[17:04:25.074]                       is.null <- base::is.null
[17:04:25.074]                       muffled <- FALSE
[17:04:25.074]                       if (inherits(cond, "message")) {
[17:04:25.074]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:25.074]                         if (muffled) 
[17:04:25.074]                           invokeRestart("muffleMessage")
[17:04:25.074]                       }
[17:04:25.074]                       else if (inherits(cond, "warning")) {
[17:04:25.074]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:25.074]                         if (muffled) 
[17:04:25.074]                           invokeRestart("muffleWarning")
[17:04:25.074]                       }
[17:04:25.074]                       else if (inherits(cond, "condition")) {
[17:04:25.074]                         if (!is.null(pattern)) {
[17:04:25.074]                           computeRestarts <- base::computeRestarts
[17:04:25.074]                           grepl <- base::grepl
[17:04:25.074]                           restarts <- computeRestarts(cond)
[17:04:25.074]                           for (restart in restarts) {
[17:04:25.074]                             name <- restart$name
[17:04:25.074]                             if (is.null(name)) 
[17:04:25.074]                               next
[17:04:25.074]                             if (!grepl(pattern, name)) 
[17:04:25.074]                               next
[17:04:25.074]                             invokeRestart(restart)
[17:04:25.074]                             muffled <- TRUE
[17:04:25.074]                             break
[17:04:25.074]                           }
[17:04:25.074]                         }
[17:04:25.074]                       }
[17:04:25.074]                       invisible(muffled)
[17:04:25.074]                     }
[17:04:25.074]                     muffleCondition(cond, pattern = "^muffle")
[17:04:25.074]                   }
[17:04:25.074]                 }
[17:04:25.074]                 else {
[17:04:25.074]                   if (TRUE) {
[17:04:25.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:25.074]                     {
[17:04:25.074]                       inherits <- base::inherits
[17:04:25.074]                       invokeRestart <- base::invokeRestart
[17:04:25.074]                       is.null <- base::is.null
[17:04:25.074]                       muffled <- FALSE
[17:04:25.074]                       if (inherits(cond, "message")) {
[17:04:25.074]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:25.074]                         if (muffled) 
[17:04:25.074]                           invokeRestart("muffleMessage")
[17:04:25.074]                       }
[17:04:25.074]                       else if (inherits(cond, "warning")) {
[17:04:25.074]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:25.074]                         if (muffled) 
[17:04:25.074]                           invokeRestart("muffleWarning")
[17:04:25.074]                       }
[17:04:25.074]                       else if (inherits(cond, "condition")) {
[17:04:25.074]                         if (!is.null(pattern)) {
[17:04:25.074]                           computeRestarts <- base::computeRestarts
[17:04:25.074]                           grepl <- base::grepl
[17:04:25.074]                           restarts <- computeRestarts(cond)
[17:04:25.074]                           for (restart in restarts) {
[17:04:25.074]                             name <- restart$name
[17:04:25.074]                             if (is.null(name)) 
[17:04:25.074]                               next
[17:04:25.074]                             if (!grepl(pattern, name)) 
[17:04:25.074]                               next
[17:04:25.074]                             invokeRestart(restart)
[17:04:25.074]                             muffled <- TRUE
[17:04:25.074]                             break
[17:04:25.074]                           }
[17:04:25.074]                         }
[17:04:25.074]                       }
[17:04:25.074]                       invisible(muffled)
[17:04:25.074]                     }
[17:04:25.074]                     muffleCondition(cond, pattern = "^muffle")
[17:04:25.074]                   }
[17:04:25.074]                 }
[17:04:25.074]             }
[17:04:25.074]         }))
[17:04:25.074]     }, error = function(ex) {
[17:04:25.074]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:25.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:25.074]                 ...future.rng), started = ...future.startTime, 
[17:04:25.074]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:25.074]             version = "1.8"), class = "FutureResult")
[17:04:25.074]     }, finally = {
[17:04:25.074]         if (!identical(...future.workdir, getwd())) 
[17:04:25.074]             setwd(...future.workdir)
[17:04:25.074]         {
[17:04:25.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:25.074]                 ...future.oldOptions$nwarnings <- NULL
[17:04:25.074]             }
[17:04:25.074]             base::options(...future.oldOptions)
[17:04:25.074]             if (.Platform$OS.type == "windows") {
[17:04:25.074]                 old_names <- names(...future.oldEnvVars)
[17:04:25.074]                 envs <- base::Sys.getenv()
[17:04:25.074]                 names <- names(envs)
[17:04:25.074]                 common <- intersect(names, old_names)
[17:04:25.074]                 added <- setdiff(names, old_names)
[17:04:25.074]                 removed <- setdiff(old_names, names)
[17:04:25.074]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:25.074]                   envs[common]]
[17:04:25.074]                 NAMES <- toupper(changed)
[17:04:25.074]                 args <- list()
[17:04:25.074]                 for (kk in seq_along(NAMES)) {
[17:04:25.074]                   name <- changed[[kk]]
[17:04:25.074]                   NAME <- NAMES[[kk]]
[17:04:25.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:25.074]                     next
[17:04:25.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:25.074]                 }
[17:04:25.074]                 NAMES <- toupper(added)
[17:04:25.074]                 for (kk in seq_along(NAMES)) {
[17:04:25.074]                   name <- added[[kk]]
[17:04:25.074]                   NAME <- NAMES[[kk]]
[17:04:25.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:25.074]                     next
[17:04:25.074]                   args[[name]] <- ""
[17:04:25.074]                 }
[17:04:25.074]                 NAMES <- toupper(removed)
[17:04:25.074]                 for (kk in seq_along(NAMES)) {
[17:04:25.074]                   name <- removed[[kk]]
[17:04:25.074]                   NAME <- NAMES[[kk]]
[17:04:25.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:25.074]                     next
[17:04:25.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:25.074]                 }
[17:04:25.074]                 if (length(args) > 0) 
[17:04:25.074]                   base::do.call(base::Sys.setenv, args = args)
[17:04:25.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:25.074]             }
[17:04:25.074]             else {
[17:04:25.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:25.074]             }
[17:04:25.074]             {
[17:04:25.074]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:25.074]                   0L) {
[17:04:25.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:25.074]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:25.074]                   base::options(opts)
[17:04:25.074]                 }
[17:04:25.074]                 {
[17:04:25.074]                   {
[17:04:25.074]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:25.074]                     NULL
[17:04:25.074]                   }
[17:04:25.074]                   options(future.plan = NULL)
[17:04:25.074]                   if (is.na(NA_character_)) 
[17:04:25.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:25.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:25.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:25.074]                     .init = FALSE)
[17:04:25.074]                 }
[17:04:25.074]             }
[17:04:25.074]         }
[17:04:25.074]     })
[17:04:25.074]     if (FALSE) {
[17:04:25.074]         base::sink(type = "output", split = FALSE)
[17:04:25.074]         if (NA) {
[17:04:25.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:25.074]         }
[17:04:25.074]         else {
[17:04:25.074]             ...future.result["stdout"] <- base::list(NULL)
[17:04:25.074]         }
[17:04:25.074]         base::close(...future.stdout)
[17:04:25.074]         ...future.stdout <- NULL
[17:04:25.074]     }
[17:04:25.074]     ...future.result$conditions <- ...future.conditions
[17:04:25.074]     ...future.result$finished <- base::Sys.time()
[17:04:25.074]     ...future.result
[17:04:25.074] }
[17:04:25.077] MultisessionFuture started
[17:04:25.077] - Launch lazy future ... done
[17:04:25.077] run() for ‘MultisessionFuture’ ... done
[17:04:25.078] result() for ClusterFuture ...
[17:04:25.078] receiveMessageFromWorker() for ClusterFuture ...
[17:04:25.078] - Validating connection of MultisessionFuture
[17:04:25.122] - received message: FutureResult
[17:04:25.122] - Received FutureResult
[17:04:25.122] - Erased future from FutureRegistry
[17:04:25.123] result() for ClusterFuture ...
[17:04:25.123] - result already collected: FutureResult
[17:04:25.123] result() for ClusterFuture ... done
[17:04:25.123] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:25.123] result() for ClusterFuture ... done
[17:04:25.123] result() for ClusterFuture ...
[17:04:25.123] - result already collected: FutureResult
[17:04:25.123] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:04:25.124] getGlobalsAndPackages() ...
[17:04:25.124] Searching for globals...
[17:04:25.124] - globals found: [1] ‘print’
[17:04:25.124] Searching for globals ... DONE
[17:04:25.124] Resolving globals: FALSE
[17:04:25.125] 
[17:04:25.125] 
[17:04:25.125] getGlobalsAndPackages() ... DONE
[17:04:25.125] run() for ‘Future’ ...
[17:04:25.125] - state: ‘created’
[17:04:25.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:04:25.141] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:04:25.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:04:25.142]   - Field: ‘node’
[17:04:25.142]   - Field: ‘label’
[17:04:25.142]   - Field: ‘local’
[17:04:25.142]   - Field: ‘owner’
[17:04:25.142]   - Field: ‘envir’
[17:04:25.142]   - Field: ‘workers’
[17:04:25.142]   - Field: ‘packages’
[17:04:25.142]   - Field: ‘gc’
[17:04:25.142]   - Field: ‘conditions’
[17:04:25.143]   - Field: ‘persistent’
[17:04:25.143]   - Field: ‘expr’
[17:04:25.143]   - Field: ‘uuid’
[17:04:25.143]   - Field: ‘seed’
[17:04:25.143]   - Field: ‘version’
[17:04:25.143]   - Field: ‘result’
[17:04:25.143]   - Field: ‘asynchronous’
[17:04:25.143]   - Field: ‘calls’
[17:04:25.143]   - Field: ‘globals’
[17:04:25.143]   - Field: ‘stdout’
[17:04:25.143]   - Field: ‘earlySignal’
[17:04:25.144]   - Field: ‘lazy’
[17:04:25.144]   - Field: ‘state’
[17:04:25.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:04:25.144] - Launch lazy future ...
[17:04:25.144] Packages needed by the future expression (n = 0): <none>
[17:04:25.144] Packages needed by future strategies (n = 0): <none>
[17:04:25.145] {
[17:04:25.145]     {
[17:04:25.145]         {
[17:04:25.145]             ...future.startTime <- base::Sys.time()
[17:04:25.145]             {
[17:04:25.145]                 {
[17:04:25.145]                   {
[17:04:25.145]                     {
[17:04:25.145]                       base::local({
[17:04:25.145]                         has_future <- base::requireNamespace("future", 
[17:04:25.145]                           quietly = TRUE)
[17:04:25.145]                         if (has_future) {
[17:04:25.145]                           ns <- base::getNamespace("future")
[17:04:25.145]                           version <- ns[[".package"]][["version"]]
[17:04:25.145]                           if (is.null(version)) 
[17:04:25.145]                             version <- utils::packageVersion("future")
[17:04:25.145]                         }
[17:04:25.145]                         else {
[17:04:25.145]                           version <- NULL
[17:04:25.145]                         }
[17:04:25.145]                         if (!has_future || version < "1.8.0") {
[17:04:25.145]                           info <- base::c(r_version = base::gsub("R version ", 
[17:04:25.145]                             "", base::R.version$version.string), 
[17:04:25.145]                             platform = base::sprintf("%s (%s-bit)", 
[17:04:25.145]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:04:25.145]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:04:25.145]                               "release", "version")], collapse = " "), 
[17:04:25.145]                             hostname = base::Sys.info()[["nodename"]])
[17:04:25.145]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:04:25.145]                             info)
[17:04:25.145]                           info <- base::paste(info, collapse = "; ")
[17:04:25.145]                           if (!has_future) {
[17:04:25.145]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:04:25.145]                               info)
[17:04:25.145]                           }
[17:04:25.145]                           else {
[17:04:25.145]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:04:25.145]                               info, version)
[17:04:25.145]                           }
[17:04:25.145]                           base::stop(msg)
[17:04:25.145]                         }
[17:04:25.145]                       })
[17:04:25.145]                     }
[17:04:25.145]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:04:25.145]                     base::options(mc.cores = 1L)
[17:04:25.145]                   }
[17:04:25.145]                   ...future.strategy.old <- future::plan("list")
[17:04:25.145]                   options(future.plan = NULL)
[17:04:25.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:04:25.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:04:25.145]                 }
[17:04:25.145]                 ...future.workdir <- getwd()
[17:04:25.145]             }
[17:04:25.145]             ...future.oldOptions <- base::as.list(base::.Options)
[17:04:25.145]             ...future.oldEnvVars <- base::Sys.getenv()
[17:04:25.145]         }
[17:04:25.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:04:25.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:04:25.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:04:25.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:04:25.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:04:25.145]             future.stdout.windows.reencode = NULL, width = 80L)
[17:04:25.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:04:25.145]             base::names(...future.oldOptions))
[17:04:25.145]     }
[17:04:25.145]     if (FALSE) {
[17:04:25.145]     }
[17:04:25.145]     else {
[17:04:25.145]         if (TRUE) {
[17:04:25.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:04:25.145]                 open = "w")
[17:04:25.145]         }
[17:04:25.145]         else {
[17:04:25.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:04:25.145]                 windows = "NUL", "/dev/null"), open = "w")
[17:04:25.145]         }
[17:04:25.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:04:25.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:04:25.145]             base::sink(type = "output", split = FALSE)
[17:04:25.145]             base::close(...future.stdout)
[17:04:25.145]         }, add = TRUE)
[17:04:25.145]     }
[17:04:25.145]     ...future.frame <- base::sys.nframe()
[17:04:25.145]     ...future.conditions <- base::list()
[17:04:25.145]     ...future.rng <- base::globalenv()$.Random.seed
[17:04:25.145]     if (FALSE) {
[17:04:25.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:04:25.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:04:25.145]     }
[17:04:25.145]     ...future.result <- base::tryCatch({
[17:04:25.145]         base::withCallingHandlers({
[17:04:25.145]             ...future.value <- base::withVisible(base::local({
[17:04:25.145]                 ...future.makeSendCondition <- base::local({
[17:04:25.145]                   sendCondition <- NULL
[17:04:25.145]                   function(frame = 1L) {
[17:04:25.145]                     if (is.function(sendCondition)) 
[17:04:25.145]                       return(sendCondition)
[17:04:25.145]                     ns <- getNamespace("parallel")
[17:04:25.145]                     if (exists("sendData", mode = "function", 
[17:04:25.145]                       envir = ns)) {
[17:04:25.145]                       parallel_sendData <- get("sendData", mode = "function", 
[17:04:25.145]                         envir = ns)
[17:04:25.145]                       envir <- sys.frame(frame)
[17:04:25.145]                       master <- NULL
[17:04:25.145]                       while (!identical(envir, .GlobalEnv) && 
[17:04:25.145]                         !identical(envir, emptyenv())) {
[17:04:25.145]                         if (exists("master", mode = "list", envir = envir, 
[17:04:25.145]                           inherits = FALSE)) {
[17:04:25.145]                           master <- get("master", mode = "list", 
[17:04:25.145]                             envir = envir, inherits = FALSE)
[17:04:25.145]                           if (inherits(master, c("SOCKnode", 
[17:04:25.145]                             "SOCK0node"))) {
[17:04:25.145]                             sendCondition <<- function(cond) {
[17:04:25.145]                               data <- list(type = "VALUE", value = cond, 
[17:04:25.145]                                 success = TRUE)
[17:04:25.145]                               parallel_sendData(master, data)
[17:04:25.145]                             }
[17:04:25.145]                             return(sendCondition)
[17:04:25.145]                           }
[17:04:25.145]                         }
[17:04:25.145]                         frame <- frame + 1L
[17:04:25.145]                         envir <- sys.frame(frame)
[17:04:25.145]                       }
[17:04:25.145]                     }
[17:04:25.145]                     sendCondition <<- function(cond) NULL
[17:04:25.145]                   }
[17:04:25.145]                 })
[17:04:25.145]                 withCallingHandlers({
[17:04:25.145]                   print(42)
[17:04:25.145]                 }, immediateCondition = function(cond) {
[17:04:25.145]                   sendCondition <- ...future.makeSendCondition()
[17:04:25.145]                   sendCondition(cond)
[17:04:25.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:25.145]                   {
[17:04:25.145]                     inherits <- base::inherits
[17:04:25.145]                     invokeRestart <- base::invokeRestart
[17:04:25.145]                     is.null <- base::is.null
[17:04:25.145]                     muffled <- FALSE
[17:04:25.145]                     if (inherits(cond, "message")) {
[17:04:25.145]                       muffled <- grepl(pattern, "muffleMessage")
[17:04:25.145]                       if (muffled) 
[17:04:25.145]                         invokeRestart("muffleMessage")
[17:04:25.145]                     }
[17:04:25.145]                     else if (inherits(cond, "warning")) {
[17:04:25.145]                       muffled <- grepl(pattern, "muffleWarning")
[17:04:25.145]                       if (muffled) 
[17:04:25.145]                         invokeRestart("muffleWarning")
[17:04:25.145]                     }
[17:04:25.145]                     else if (inherits(cond, "condition")) {
[17:04:25.145]                       if (!is.null(pattern)) {
[17:04:25.145]                         computeRestarts <- base::computeRestarts
[17:04:25.145]                         grepl <- base::grepl
[17:04:25.145]                         restarts <- computeRestarts(cond)
[17:04:25.145]                         for (restart in restarts) {
[17:04:25.145]                           name <- restart$name
[17:04:25.145]                           if (is.null(name)) 
[17:04:25.145]                             next
[17:04:25.145]                           if (!grepl(pattern, name)) 
[17:04:25.145]                             next
[17:04:25.145]                           invokeRestart(restart)
[17:04:25.145]                           muffled <- TRUE
[17:04:25.145]                           break
[17:04:25.145]                         }
[17:04:25.145]                       }
[17:04:25.145]                     }
[17:04:25.145]                     invisible(muffled)
[17:04:25.145]                   }
[17:04:25.145]                   muffleCondition(cond)
[17:04:25.145]                 })
[17:04:25.145]             }))
[17:04:25.145]             future::FutureResult(value = ...future.value$value, 
[17:04:25.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:25.145]                   ...future.rng), globalenv = if (FALSE) 
[17:04:25.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:04:25.145]                     ...future.globalenv.names))
[17:04:25.145]                 else NULL, started = ...future.startTime, version = "1.8")
[17:04:25.145]         }, condition = base::local({
[17:04:25.145]             c <- base::c
[17:04:25.145]             inherits <- base::inherits
[17:04:25.145]             invokeRestart <- base::invokeRestart
[17:04:25.145]             length <- base::length
[17:04:25.145]             list <- base::list
[17:04:25.145]             seq.int <- base::seq.int
[17:04:25.145]             signalCondition <- base::signalCondition
[17:04:25.145]             sys.calls <- base::sys.calls
[17:04:25.145]             `[[` <- base::`[[`
[17:04:25.145]             `+` <- base::`+`
[17:04:25.145]             `<<-` <- base::`<<-`
[17:04:25.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:04:25.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:04:25.145]                   3L)]
[17:04:25.145]             }
[17:04:25.145]             function(cond) {
[17:04:25.145]                 is_error <- inherits(cond, "error")
[17:04:25.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:04:25.145]                   NULL)
[17:04:25.145]                 if (is_error) {
[17:04:25.145]                   sessionInformation <- function() {
[17:04:25.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:04:25.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:04:25.145]                       search = base::search(), system = base::Sys.info())
[17:04:25.145]                   }
[17:04:25.145]                   ...future.conditions[[length(...future.conditions) + 
[17:04:25.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:04:25.145]                     cond$call), session = sessionInformation(), 
[17:04:25.145]                     timestamp = base::Sys.time(), signaled = 0L)
[17:04:25.145]                   signalCondition(cond)
[17:04:25.145]                 }
[17:04:25.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:04:25.145]                 "immediateCondition"))) {
[17:04:25.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:04:25.145]                   ...future.conditions[[length(...future.conditions) + 
[17:04:25.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:04:25.145]                   if (TRUE && !signal) {
[17:04:25.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:25.145]                     {
[17:04:25.145]                       inherits <- base::inherits
[17:04:25.145]                       invokeRestart <- base::invokeRestart
[17:04:25.145]                       is.null <- base::is.null
[17:04:25.145]                       muffled <- FALSE
[17:04:25.145]                       if (inherits(cond, "message")) {
[17:04:25.145]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:25.145]                         if (muffled) 
[17:04:25.145]                           invokeRestart("muffleMessage")
[17:04:25.145]                       }
[17:04:25.145]                       else if (inherits(cond, "warning")) {
[17:04:25.145]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:25.145]                         if (muffled) 
[17:04:25.145]                           invokeRestart("muffleWarning")
[17:04:25.145]                       }
[17:04:25.145]                       else if (inherits(cond, "condition")) {
[17:04:25.145]                         if (!is.null(pattern)) {
[17:04:25.145]                           computeRestarts <- base::computeRestarts
[17:04:25.145]                           grepl <- base::grepl
[17:04:25.145]                           restarts <- computeRestarts(cond)
[17:04:25.145]                           for (restart in restarts) {
[17:04:25.145]                             name <- restart$name
[17:04:25.145]                             if (is.null(name)) 
[17:04:25.145]                               next
[17:04:25.145]                             if (!grepl(pattern, name)) 
[17:04:25.145]                               next
[17:04:25.145]                             invokeRestart(restart)
[17:04:25.145]                             muffled <- TRUE
[17:04:25.145]                             break
[17:04:25.145]                           }
[17:04:25.145]                         }
[17:04:25.145]                       }
[17:04:25.145]                       invisible(muffled)
[17:04:25.145]                     }
[17:04:25.145]                     muffleCondition(cond, pattern = "^muffle")
[17:04:25.145]                   }
[17:04:25.145]                 }
[17:04:25.145]                 else {
[17:04:25.145]                   if (TRUE) {
[17:04:25.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:04:25.145]                     {
[17:04:25.145]                       inherits <- base::inherits
[17:04:25.145]                       invokeRestart <- base::invokeRestart
[17:04:25.145]                       is.null <- base::is.null
[17:04:25.145]                       muffled <- FALSE
[17:04:25.145]                       if (inherits(cond, "message")) {
[17:04:25.145]                         muffled <- grepl(pattern, "muffleMessage")
[17:04:25.145]                         if (muffled) 
[17:04:25.145]                           invokeRestart("muffleMessage")
[17:04:25.145]                       }
[17:04:25.145]                       else if (inherits(cond, "warning")) {
[17:04:25.145]                         muffled <- grepl(pattern, "muffleWarning")
[17:04:25.145]                         if (muffled) 
[17:04:25.145]                           invokeRestart("muffleWarning")
[17:04:25.145]                       }
[17:04:25.145]                       else if (inherits(cond, "condition")) {
[17:04:25.145]                         if (!is.null(pattern)) {
[17:04:25.145]                           computeRestarts <- base::computeRestarts
[17:04:25.145]                           grepl <- base::grepl
[17:04:25.145]                           restarts <- computeRestarts(cond)
[17:04:25.145]                           for (restart in restarts) {
[17:04:25.145]                             name <- restart$name
[17:04:25.145]                             if (is.null(name)) 
[17:04:25.145]                               next
[17:04:25.145]                             if (!grepl(pattern, name)) 
[17:04:25.145]                               next
[17:04:25.145]                             invokeRestart(restart)
[17:04:25.145]                             muffled <- TRUE
[17:04:25.145]                             break
[17:04:25.145]                           }
[17:04:25.145]                         }
[17:04:25.145]                       }
[17:04:25.145]                       invisible(muffled)
[17:04:25.145]                     }
[17:04:25.145]                     muffleCondition(cond, pattern = "^muffle")
[17:04:25.145]                   }
[17:04:25.145]                 }
[17:04:25.145]             }
[17:04:25.145]         }))
[17:04:25.145]     }, error = function(ex) {
[17:04:25.145]         base::structure(base::list(value = NULL, visible = NULL, 
[17:04:25.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:04:25.145]                 ...future.rng), started = ...future.startTime, 
[17:04:25.145]             finished = Sys.time(), session_uuid = NA_character_, 
[17:04:25.145]             version = "1.8"), class = "FutureResult")
[17:04:25.145]     }, finally = {
[17:04:25.145]         if (!identical(...future.workdir, getwd())) 
[17:04:25.145]             setwd(...future.workdir)
[17:04:25.145]         {
[17:04:25.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:04:25.145]                 ...future.oldOptions$nwarnings <- NULL
[17:04:25.145]             }
[17:04:25.145]             base::options(...future.oldOptions)
[17:04:25.145]             if (.Platform$OS.type == "windows") {
[17:04:25.145]                 old_names <- names(...future.oldEnvVars)
[17:04:25.145]                 envs <- base::Sys.getenv()
[17:04:25.145]                 names <- names(envs)
[17:04:25.145]                 common <- intersect(names, old_names)
[17:04:25.145]                 added <- setdiff(names, old_names)
[17:04:25.145]                 removed <- setdiff(old_names, names)
[17:04:25.145]                 changed <- common[...future.oldEnvVars[common] != 
[17:04:25.145]                   envs[common]]
[17:04:25.145]                 NAMES <- toupper(changed)
[17:04:25.145]                 args <- list()
[17:04:25.145]                 for (kk in seq_along(NAMES)) {
[17:04:25.145]                   name <- changed[[kk]]
[17:04:25.145]                   NAME <- NAMES[[kk]]
[17:04:25.145]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:25.145]                     next
[17:04:25.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:25.145]                 }
[17:04:25.145]                 NAMES <- toupper(added)
[17:04:25.145]                 for (kk in seq_along(NAMES)) {
[17:04:25.145]                   name <- added[[kk]]
[17:04:25.145]                   NAME <- NAMES[[kk]]
[17:04:25.145]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:25.145]                     next
[17:04:25.145]                   args[[name]] <- ""
[17:04:25.145]                 }
[17:04:25.145]                 NAMES <- toupper(removed)
[17:04:25.145]                 for (kk in seq_along(NAMES)) {
[17:04:25.145]                   name <- removed[[kk]]
[17:04:25.145]                   NAME <- NAMES[[kk]]
[17:04:25.145]                   if (name != NAME && is.element(NAME, old_names)) 
[17:04:25.145]                     next
[17:04:25.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:04:25.145]                 }
[17:04:25.145]                 if (length(args) > 0) 
[17:04:25.145]                   base::do.call(base::Sys.setenv, args = args)
[17:04:25.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:04:25.145]             }
[17:04:25.145]             else {
[17:04:25.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:04:25.145]             }
[17:04:25.145]             {
[17:04:25.145]                 if (base::length(...future.futureOptionsAdded) > 
[17:04:25.145]                   0L) {
[17:04:25.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:04:25.145]                   base::names(opts) <- ...future.futureOptionsAdded
[17:04:25.145]                   base::options(opts)
[17:04:25.145]                 }
[17:04:25.145]                 {
[17:04:25.145]                   {
[17:04:25.145]                     base::options(mc.cores = ...future.mc.cores.old)
[17:04:25.145]                     NULL
[17:04:25.145]                   }
[17:04:25.145]                   options(future.plan = NULL)
[17:04:25.145]                   if (is.na(NA_character_)) 
[17:04:25.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:04:25.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:04:25.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:04:25.145]                     .init = FALSE)
[17:04:25.145]                 }
[17:04:25.145]             }
[17:04:25.145]         }
[17:04:25.145]     })
[17:04:25.145]     if (TRUE) {
[17:04:25.145]         base::sink(type = "output", split = FALSE)
[17:04:25.145]         if (TRUE) {
[17:04:25.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:04:25.145]         }
[17:04:25.145]         else {
[17:04:25.145]             ...future.result["stdout"] <- base::list(NULL)
[17:04:25.145]         }
[17:04:25.145]         base::close(...future.stdout)
[17:04:25.145]         ...future.stdout <- NULL
[17:04:25.145]     }
[17:04:25.145]     ...future.result$conditions <- ...future.conditions
[17:04:25.145]     ...future.result$finished <- base::Sys.time()
[17:04:25.145]     ...future.result
[17:04:25.145] }
[17:04:25.148] MultisessionFuture started
[17:04:25.148] - Launch lazy future ... done
[17:04:25.148] run() for ‘MultisessionFuture’ ... done
[17:04:25.148] result() for ClusterFuture ...
[17:04:25.148] receiveMessageFromWorker() for ClusterFuture ...
[17:04:25.148] - Validating connection of MultisessionFuture
[17:04:25.150] - received message: FutureResult
[17:04:25.150] - Received FutureResult
[17:04:25.150] - Erased future from FutureRegistry
[17:04:25.150] result() for ClusterFuture ...
[17:04:25.150] - result already collected: FutureResult
[17:04:25.150] result() for ClusterFuture ... done
[17:04:25.150] receiveMessageFromWorker() for ClusterFuture ... done
[17:04:25.150] result() for ClusterFuture ... done
[17:04:25.150] result() for ClusterFuture ...
[17:04:25.150] - result already collected: FutureResult
[17:04:25.150] result() for ClusterFuture ... done
[17:04:25.151] result() for ClusterFuture ...
[17:04:25.151] - result already collected: FutureResult
[17:04:25.151] result() for ClusterFuture ... done
[1] 42
[17:04:25.151] result() for ClusterFuture ...
[17:04:25.151] - result already collected: FutureResult
[17:04:25.151] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[17:04:25.152] plan(): Setting new future strategy stack:
[17:04:25.152] List of future strategies:
[17:04:25.152] 1. FutureStrategy:
[17:04:25.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:04:25.152]    - tweaked: FALSE
[17:04:25.152]    - call: future::plan(oplan)
[17:04:25.153] plan(): nbrOfWorkers() = 1
> 
