
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:03:36.320] plan(): Setting new future strategy stack:
[17:03:36.321] List of future strategies:
[17:03:36.321] 1. sequential:
[17:03:36.321]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.321]    - tweaked: FALSE
[17:03:36.321]    - call: future::plan("sequential")
[17:03:36.332] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[17:03:36.525] plan(): Setting new future strategy stack:
[17:03:36.525] List of future strategies:
[17:03:36.525] 1. sequential:
[17:03:36.525]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.525]    - tweaked: FALSE
[17:03:36.525]    - call: plan(strategy)
[17:03:36.537] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[17:03:36.537] resolve() on list ...
[17:03:36.537]  recursive: 0
[17:03:36.537]  length: 2
[17:03:36.538]  elements: ‘a’, ‘b’
[17:03:36.539]  length: 1 (resolved future 1)
[17:03:36.540]  length: 0 (resolved future 2)
[17:03:36.540] resolve() on list ... DONE
[17:03:36.540] getGlobalsAndPackages() ...
[17:03:36.540] Searching for globals...
[17:03:36.543] 
[17:03:36.543] Searching for globals ... DONE
[17:03:36.543] - globals: [0] <none>
[17:03:36.543] getGlobalsAndPackages() ... DONE
[17:03:36.544] run() for ‘Future’ ...
[17:03:36.544] - state: ‘created’
[17:03:36.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.544] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.545]   - Field: ‘label’
[17:03:36.545]   - Field: ‘local’
[17:03:36.545]   - Field: ‘owner’
[17:03:36.545]   - Field: ‘envir’
[17:03:36.545]   - Field: ‘packages’
[17:03:36.545]   - Field: ‘gc’
[17:03:36.545]   - Field: ‘conditions’
[17:03:36.545]   - Field: ‘expr’
[17:03:36.545]   - Field: ‘uuid’
[17:03:36.545]   - Field: ‘seed’
[17:03:36.545]   - Field: ‘version’
[17:03:36.546]   - Field: ‘result’
[17:03:36.546]   - Field: ‘asynchronous’
[17:03:36.546]   - Field: ‘calls’
[17:03:36.546]   - Field: ‘globals’
[17:03:36.546]   - Field: ‘stdout’
[17:03:36.546]   - Field: ‘earlySignal’
[17:03:36.546]   - Field: ‘lazy’
[17:03:36.546]   - Field: ‘state’
[17:03:36.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.546] - Launch lazy future ...
[17:03:36.547] Packages needed by the future expression (n = 0): <none>
[17:03:36.547] Packages needed by future strategies (n = 0): <none>
[17:03:36.548] {
[17:03:36.548]     {
[17:03:36.548]         {
[17:03:36.548]             ...future.startTime <- base::Sys.time()
[17:03:36.548]             {
[17:03:36.548]                 {
[17:03:36.548]                   {
[17:03:36.548]                     base::local({
[17:03:36.548]                       has_future <- base::requireNamespace("future", 
[17:03:36.548]                         quietly = TRUE)
[17:03:36.548]                       if (has_future) {
[17:03:36.548]                         ns <- base::getNamespace("future")
[17:03:36.548]                         version <- ns[[".package"]][["version"]]
[17:03:36.548]                         if (is.null(version)) 
[17:03:36.548]                           version <- utils::packageVersion("future")
[17:03:36.548]                       }
[17:03:36.548]                       else {
[17:03:36.548]                         version <- NULL
[17:03:36.548]                       }
[17:03:36.548]                       if (!has_future || version < "1.8.0") {
[17:03:36.548]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.548]                           "", base::R.version$version.string), 
[17:03:36.548]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.548]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.548]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.548]                             "release", "version")], collapse = " "), 
[17:03:36.548]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.548]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.548]                           info)
[17:03:36.548]                         info <- base::paste(info, collapse = "; ")
[17:03:36.548]                         if (!has_future) {
[17:03:36.548]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.548]                             info)
[17:03:36.548]                         }
[17:03:36.548]                         else {
[17:03:36.548]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.548]                             info, version)
[17:03:36.548]                         }
[17:03:36.548]                         base::stop(msg)
[17:03:36.548]                       }
[17:03:36.548]                     })
[17:03:36.548]                   }
[17:03:36.548]                   ...future.strategy.old <- future::plan("list")
[17:03:36.548]                   options(future.plan = NULL)
[17:03:36.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.548]                 }
[17:03:36.548]                 ...future.workdir <- getwd()
[17:03:36.548]             }
[17:03:36.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.548]         }
[17:03:36.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.548]             base::names(...future.oldOptions))
[17:03:36.548]     }
[17:03:36.548]     if (FALSE) {
[17:03:36.548]     }
[17:03:36.548]     else {
[17:03:36.548]         if (TRUE) {
[17:03:36.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.548]                 open = "w")
[17:03:36.548]         }
[17:03:36.548]         else {
[17:03:36.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.548]         }
[17:03:36.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.548]             base::sink(type = "output", split = FALSE)
[17:03:36.548]             base::close(...future.stdout)
[17:03:36.548]         }, add = TRUE)
[17:03:36.548]     }
[17:03:36.548]     ...future.frame <- base::sys.nframe()
[17:03:36.548]     ...future.conditions <- base::list()
[17:03:36.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.548]     if (FALSE) {
[17:03:36.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.548]     }
[17:03:36.548]     ...future.result <- base::tryCatch({
[17:03:36.548]         base::withCallingHandlers({
[17:03:36.548]             ...future.value <- base::withVisible(base::local(1))
[17:03:36.548]             future::FutureResult(value = ...future.value$value, 
[17:03:36.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.548]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.548]                     ...future.globalenv.names))
[17:03:36.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.548]         }, condition = base::local({
[17:03:36.548]             c <- base::c
[17:03:36.548]             inherits <- base::inherits
[17:03:36.548]             invokeRestart <- base::invokeRestart
[17:03:36.548]             length <- base::length
[17:03:36.548]             list <- base::list
[17:03:36.548]             seq.int <- base::seq.int
[17:03:36.548]             signalCondition <- base::signalCondition
[17:03:36.548]             sys.calls <- base::sys.calls
[17:03:36.548]             `[[` <- base::`[[`
[17:03:36.548]             `+` <- base::`+`
[17:03:36.548]             `<<-` <- base::`<<-`
[17:03:36.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.548]                   3L)]
[17:03:36.548]             }
[17:03:36.548]             function(cond) {
[17:03:36.548]                 is_error <- inherits(cond, "error")
[17:03:36.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.548]                   NULL)
[17:03:36.548]                 if (is_error) {
[17:03:36.548]                   sessionInformation <- function() {
[17:03:36.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.548]                       search = base::search(), system = base::Sys.info())
[17:03:36.548]                   }
[17:03:36.548]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.548]                     cond$call), session = sessionInformation(), 
[17:03:36.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.548]                   signalCondition(cond)
[17:03:36.548]                 }
[17:03:36.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.548]                 "immediateCondition"))) {
[17:03:36.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.548]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.548]                   if (TRUE && !signal) {
[17:03:36.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.548]                     {
[17:03:36.548]                       inherits <- base::inherits
[17:03:36.548]                       invokeRestart <- base::invokeRestart
[17:03:36.548]                       is.null <- base::is.null
[17:03:36.548]                       muffled <- FALSE
[17:03:36.548]                       if (inherits(cond, "message")) {
[17:03:36.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.548]                         if (muffled) 
[17:03:36.548]                           invokeRestart("muffleMessage")
[17:03:36.548]                       }
[17:03:36.548]                       else if (inherits(cond, "warning")) {
[17:03:36.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.548]                         if (muffled) 
[17:03:36.548]                           invokeRestart("muffleWarning")
[17:03:36.548]                       }
[17:03:36.548]                       else if (inherits(cond, "condition")) {
[17:03:36.548]                         if (!is.null(pattern)) {
[17:03:36.548]                           computeRestarts <- base::computeRestarts
[17:03:36.548]                           grepl <- base::grepl
[17:03:36.548]                           restarts <- computeRestarts(cond)
[17:03:36.548]                           for (restart in restarts) {
[17:03:36.548]                             name <- restart$name
[17:03:36.548]                             if (is.null(name)) 
[17:03:36.548]                               next
[17:03:36.548]                             if (!grepl(pattern, name)) 
[17:03:36.548]                               next
[17:03:36.548]                             invokeRestart(restart)
[17:03:36.548]                             muffled <- TRUE
[17:03:36.548]                             break
[17:03:36.548]                           }
[17:03:36.548]                         }
[17:03:36.548]                       }
[17:03:36.548]                       invisible(muffled)
[17:03:36.548]                     }
[17:03:36.548]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.548]                   }
[17:03:36.548]                 }
[17:03:36.548]                 else {
[17:03:36.548]                   if (TRUE) {
[17:03:36.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.548]                     {
[17:03:36.548]                       inherits <- base::inherits
[17:03:36.548]                       invokeRestart <- base::invokeRestart
[17:03:36.548]                       is.null <- base::is.null
[17:03:36.548]                       muffled <- FALSE
[17:03:36.548]                       if (inherits(cond, "message")) {
[17:03:36.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.548]                         if (muffled) 
[17:03:36.548]                           invokeRestart("muffleMessage")
[17:03:36.548]                       }
[17:03:36.548]                       else if (inherits(cond, "warning")) {
[17:03:36.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.548]                         if (muffled) 
[17:03:36.548]                           invokeRestart("muffleWarning")
[17:03:36.548]                       }
[17:03:36.548]                       else if (inherits(cond, "condition")) {
[17:03:36.548]                         if (!is.null(pattern)) {
[17:03:36.548]                           computeRestarts <- base::computeRestarts
[17:03:36.548]                           grepl <- base::grepl
[17:03:36.548]                           restarts <- computeRestarts(cond)
[17:03:36.548]                           for (restart in restarts) {
[17:03:36.548]                             name <- restart$name
[17:03:36.548]                             if (is.null(name)) 
[17:03:36.548]                               next
[17:03:36.548]                             if (!grepl(pattern, name)) 
[17:03:36.548]                               next
[17:03:36.548]                             invokeRestart(restart)
[17:03:36.548]                             muffled <- TRUE
[17:03:36.548]                             break
[17:03:36.548]                           }
[17:03:36.548]                         }
[17:03:36.548]                       }
[17:03:36.548]                       invisible(muffled)
[17:03:36.548]                     }
[17:03:36.548]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.548]                   }
[17:03:36.548]                 }
[17:03:36.548]             }
[17:03:36.548]         }))
[17:03:36.548]     }, error = function(ex) {
[17:03:36.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.548]                 ...future.rng), started = ...future.startTime, 
[17:03:36.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.548]             version = "1.8"), class = "FutureResult")
[17:03:36.548]     }, finally = {
[17:03:36.548]         if (!identical(...future.workdir, getwd())) 
[17:03:36.548]             setwd(...future.workdir)
[17:03:36.548]         {
[17:03:36.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.548]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.548]             }
[17:03:36.548]             base::options(...future.oldOptions)
[17:03:36.548]             if (.Platform$OS.type == "windows") {
[17:03:36.548]                 old_names <- names(...future.oldEnvVars)
[17:03:36.548]                 envs <- base::Sys.getenv()
[17:03:36.548]                 names <- names(envs)
[17:03:36.548]                 common <- intersect(names, old_names)
[17:03:36.548]                 added <- setdiff(names, old_names)
[17:03:36.548]                 removed <- setdiff(old_names, names)
[17:03:36.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.548]                   envs[common]]
[17:03:36.548]                 NAMES <- toupper(changed)
[17:03:36.548]                 args <- list()
[17:03:36.548]                 for (kk in seq_along(NAMES)) {
[17:03:36.548]                   name <- changed[[kk]]
[17:03:36.548]                   NAME <- NAMES[[kk]]
[17:03:36.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.548]                     next
[17:03:36.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.548]                 }
[17:03:36.548]                 NAMES <- toupper(added)
[17:03:36.548]                 for (kk in seq_along(NAMES)) {
[17:03:36.548]                   name <- added[[kk]]
[17:03:36.548]                   NAME <- NAMES[[kk]]
[17:03:36.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.548]                     next
[17:03:36.548]                   args[[name]] <- ""
[17:03:36.548]                 }
[17:03:36.548]                 NAMES <- toupper(removed)
[17:03:36.548]                 for (kk in seq_along(NAMES)) {
[17:03:36.548]                   name <- removed[[kk]]
[17:03:36.548]                   NAME <- NAMES[[kk]]
[17:03:36.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.548]                     next
[17:03:36.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.548]                 }
[17:03:36.548]                 if (length(args) > 0) 
[17:03:36.548]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.548]             }
[17:03:36.548]             else {
[17:03:36.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.548]             }
[17:03:36.548]             {
[17:03:36.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.548]                   0L) {
[17:03:36.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.548]                   base::options(opts)
[17:03:36.548]                 }
[17:03:36.548]                 {
[17:03:36.548]                   {
[17:03:36.548]                     NULL
[17:03:36.548]                     RNGkind("Mersenne-Twister")
[17:03:36.548]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.548]                       inherits = FALSE)
[17:03:36.548]                   }
[17:03:36.548]                   options(future.plan = NULL)
[17:03:36.548]                   if (is.na(NA_character_)) 
[17:03:36.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.548]                     .init = FALSE)
[17:03:36.548]                 }
[17:03:36.548]             }
[17:03:36.548]         }
[17:03:36.548]     })
[17:03:36.548]     if (TRUE) {
[17:03:36.548]         base::sink(type = "output", split = FALSE)
[17:03:36.548]         if (TRUE) {
[17:03:36.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.548]         }
[17:03:36.548]         else {
[17:03:36.548]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.548]         }
[17:03:36.548]         base::close(...future.stdout)
[17:03:36.548]         ...future.stdout <- NULL
[17:03:36.548]     }
[17:03:36.548]     ...future.result$conditions <- ...future.conditions
[17:03:36.548]     ...future.result$finished <- base::Sys.time()
[17:03:36.548]     ...future.result
[17:03:36.548] }
[17:03:36.550] plan(): Setting new future strategy stack:
[17:03:36.550] List of future strategies:
[17:03:36.550] 1. sequential:
[17:03:36.550]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.550]    - tweaked: FALSE
[17:03:36.550]    - call: NULL
[17:03:36.551] plan(): nbrOfWorkers() = 1
[17:03:36.552] plan(): Setting new future strategy stack:
[17:03:36.552] List of future strategies:
[17:03:36.552] 1. sequential:
[17:03:36.552]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.552]    - tweaked: FALSE
[17:03:36.552]    - call: plan(strategy)
[17:03:36.552] plan(): nbrOfWorkers() = 1
[17:03:36.552] SequentialFuture started (and completed)
[17:03:36.553] - Launch lazy future ... done
[17:03:36.553] run() for ‘SequentialFuture’ ... done
[17:03:36.553] getGlobalsAndPackages() ...
[17:03:36.553] Searching for globals...
[17:03:36.554] 
[17:03:36.554] Searching for globals ... DONE
[17:03:36.554] - globals: [0] <none>
[17:03:36.554] getGlobalsAndPackages() ... DONE
[17:03:36.554] run() for ‘Future’ ...
[17:03:36.554] - state: ‘created’
[17:03:36.554] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.555] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.555] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.555]   - Field: ‘label’
[17:03:36.555]   - Field: ‘local’
[17:03:36.555]   - Field: ‘owner’
[17:03:36.555]   - Field: ‘envir’
[17:03:36.555]   - Field: ‘packages’
[17:03:36.555]   - Field: ‘gc’
[17:03:36.555]   - Field: ‘conditions’
[17:03:36.555]   - Field: ‘expr’
[17:03:36.555]   - Field: ‘uuid’
[17:03:36.556]   - Field: ‘seed’
[17:03:36.556]   - Field: ‘version’
[17:03:36.556]   - Field: ‘result’
[17:03:36.556]   - Field: ‘asynchronous’
[17:03:36.556]   - Field: ‘calls’
[17:03:36.556]   - Field: ‘globals’
[17:03:36.556]   - Field: ‘stdout’
[17:03:36.556]   - Field: ‘earlySignal’
[17:03:36.556]   - Field: ‘lazy’
[17:03:36.556]   - Field: ‘state’
[17:03:36.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.557] - Launch lazy future ...
[17:03:36.557] Packages needed by the future expression (n = 0): <none>
[17:03:36.557] Packages needed by future strategies (n = 0): <none>
[17:03:36.557] {
[17:03:36.557]     {
[17:03:36.557]         {
[17:03:36.557]             ...future.startTime <- base::Sys.time()
[17:03:36.557]             {
[17:03:36.557]                 {
[17:03:36.557]                   {
[17:03:36.557]                     base::local({
[17:03:36.557]                       has_future <- base::requireNamespace("future", 
[17:03:36.557]                         quietly = TRUE)
[17:03:36.557]                       if (has_future) {
[17:03:36.557]                         ns <- base::getNamespace("future")
[17:03:36.557]                         version <- ns[[".package"]][["version"]]
[17:03:36.557]                         if (is.null(version)) 
[17:03:36.557]                           version <- utils::packageVersion("future")
[17:03:36.557]                       }
[17:03:36.557]                       else {
[17:03:36.557]                         version <- NULL
[17:03:36.557]                       }
[17:03:36.557]                       if (!has_future || version < "1.8.0") {
[17:03:36.557]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.557]                           "", base::R.version$version.string), 
[17:03:36.557]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.557]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.557]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.557]                             "release", "version")], collapse = " "), 
[17:03:36.557]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.557]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.557]                           info)
[17:03:36.557]                         info <- base::paste(info, collapse = "; ")
[17:03:36.557]                         if (!has_future) {
[17:03:36.557]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.557]                             info)
[17:03:36.557]                         }
[17:03:36.557]                         else {
[17:03:36.557]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.557]                             info, version)
[17:03:36.557]                         }
[17:03:36.557]                         base::stop(msg)
[17:03:36.557]                       }
[17:03:36.557]                     })
[17:03:36.557]                   }
[17:03:36.557]                   ...future.strategy.old <- future::plan("list")
[17:03:36.557]                   options(future.plan = NULL)
[17:03:36.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.557]                 }
[17:03:36.557]                 ...future.workdir <- getwd()
[17:03:36.557]             }
[17:03:36.557]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.557]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.557]         }
[17:03:36.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.557]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.557]             base::names(...future.oldOptions))
[17:03:36.557]     }
[17:03:36.557]     if (FALSE) {
[17:03:36.557]     }
[17:03:36.557]     else {
[17:03:36.557]         if (TRUE) {
[17:03:36.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.557]                 open = "w")
[17:03:36.557]         }
[17:03:36.557]         else {
[17:03:36.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.557]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.557]         }
[17:03:36.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.557]             base::sink(type = "output", split = FALSE)
[17:03:36.557]             base::close(...future.stdout)
[17:03:36.557]         }, add = TRUE)
[17:03:36.557]     }
[17:03:36.557]     ...future.frame <- base::sys.nframe()
[17:03:36.557]     ...future.conditions <- base::list()
[17:03:36.557]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.557]     if (FALSE) {
[17:03:36.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.557]     }
[17:03:36.557]     ...future.result <- base::tryCatch({
[17:03:36.557]         base::withCallingHandlers({
[17:03:36.557]             ...future.value <- base::withVisible(base::local(2))
[17:03:36.557]             future::FutureResult(value = ...future.value$value, 
[17:03:36.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.557]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.557]                     ...future.globalenv.names))
[17:03:36.557]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.557]         }, condition = base::local({
[17:03:36.557]             c <- base::c
[17:03:36.557]             inherits <- base::inherits
[17:03:36.557]             invokeRestart <- base::invokeRestart
[17:03:36.557]             length <- base::length
[17:03:36.557]             list <- base::list
[17:03:36.557]             seq.int <- base::seq.int
[17:03:36.557]             signalCondition <- base::signalCondition
[17:03:36.557]             sys.calls <- base::sys.calls
[17:03:36.557]             `[[` <- base::`[[`
[17:03:36.557]             `+` <- base::`+`
[17:03:36.557]             `<<-` <- base::`<<-`
[17:03:36.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.557]                   3L)]
[17:03:36.557]             }
[17:03:36.557]             function(cond) {
[17:03:36.557]                 is_error <- inherits(cond, "error")
[17:03:36.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.557]                   NULL)
[17:03:36.557]                 if (is_error) {
[17:03:36.557]                   sessionInformation <- function() {
[17:03:36.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.557]                       search = base::search(), system = base::Sys.info())
[17:03:36.557]                   }
[17:03:36.557]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.557]                     cond$call), session = sessionInformation(), 
[17:03:36.557]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.557]                   signalCondition(cond)
[17:03:36.557]                 }
[17:03:36.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.557]                 "immediateCondition"))) {
[17:03:36.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.557]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.557]                   if (TRUE && !signal) {
[17:03:36.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.557]                     {
[17:03:36.557]                       inherits <- base::inherits
[17:03:36.557]                       invokeRestart <- base::invokeRestart
[17:03:36.557]                       is.null <- base::is.null
[17:03:36.557]                       muffled <- FALSE
[17:03:36.557]                       if (inherits(cond, "message")) {
[17:03:36.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.557]                         if (muffled) 
[17:03:36.557]                           invokeRestart("muffleMessage")
[17:03:36.557]                       }
[17:03:36.557]                       else if (inherits(cond, "warning")) {
[17:03:36.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.557]                         if (muffled) 
[17:03:36.557]                           invokeRestart("muffleWarning")
[17:03:36.557]                       }
[17:03:36.557]                       else if (inherits(cond, "condition")) {
[17:03:36.557]                         if (!is.null(pattern)) {
[17:03:36.557]                           computeRestarts <- base::computeRestarts
[17:03:36.557]                           grepl <- base::grepl
[17:03:36.557]                           restarts <- computeRestarts(cond)
[17:03:36.557]                           for (restart in restarts) {
[17:03:36.557]                             name <- restart$name
[17:03:36.557]                             if (is.null(name)) 
[17:03:36.557]                               next
[17:03:36.557]                             if (!grepl(pattern, name)) 
[17:03:36.557]                               next
[17:03:36.557]                             invokeRestart(restart)
[17:03:36.557]                             muffled <- TRUE
[17:03:36.557]                             break
[17:03:36.557]                           }
[17:03:36.557]                         }
[17:03:36.557]                       }
[17:03:36.557]                       invisible(muffled)
[17:03:36.557]                     }
[17:03:36.557]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.557]                   }
[17:03:36.557]                 }
[17:03:36.557]                 else {
[17:03:36.557]                   if (TRUE) {
[17:03:36.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.557]                     {
[17:03:36.557]                       inherits <- base::inherits
[17:03:36.557]                       invokeRestart <- base::invokeRestart
[17:03:36.557]                       is.null <- base::is.null
[17:03:36.557]                       muffled <- FALSE
[17:03:36.557]                       if (inherits(cond, "message")) {
[17:03:36.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.557]                         if (muffled) 
[17:03:36.557]                           invokeRestart("muffleMessage")
[17:03:36.557]                       }
[17:03:36.557]                       else if (inherits(cond, "warning")) {
[17:03:36.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.557]                         if (muffled) 
[17:03:36.557]                           invokeRestart("muffleWarning")
[17:03:36.557]                       }
[17:03:36.557]                       else if (inherits(cond, "condition")) {
[17:03:36.557]                         if (!is.null(pattern)) {
[17:03:36.557]                           computeRestarts <- base::computeRestarts
[17:03:36.557]                           grepl <- base::grepl
[17:03:36.557]                           restarts <- computeRestarts(cond)
[17:03:36.557]                           for (restart in restarts) {
[17:03:36.557]                             name <- restart$name
[17:03:36.557]                             if (is.null(name)) 
[17:03:36.557]                               next
[17:03:36.557]                             if (!grepl(pattern, name)) 
[17:03:36.557]                               next
[17:03:36.557]                             invokeRestart(restart)
[17:03:36.557]                             muffled <- TRUE
[17:03:36.557]                             break
[17:03:36.557]                           }
[17:03:36.557]                         }
[17:03:36.557]                       }
[17:03:36.557]                       invisible(muffled)
[17:03:36.557]                     }
[17:03:36.557]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.557]                   }
[17:03:36.557]                 }
[17:03:36.557]             }
[17:03:36.557]         }))
[17:03:36.557]     }, error = function(ex) {
[17:03:36.557]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.557]                 ...future.rng), started = ...future.startTime, 
[17:03:36.557]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.557]             version = "1.8"), class = "FutureResult")
[17:03:36.557]     }, finally = {
[17:03:36.557]         if (!identical(...future.workdir, getwd())) 
[17:03:36.557]             setwd(...future.workdir)
[17:03:36.557]         {
[17:03:36.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.557]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.557]             }
[17:03:36.557]             base::options(...future.oldOptions)
[17:03:36.557]             if (.Platform$OS.type == "windows") {
[17:03:36.557]                 old_names <- names(...future.oldEnvVars)
[17:03:36.557]                 envs <- base::Sys.getenv()
[17:03:36.557]                 names <- names(envs)
[17:03:36.557]                 common <- intersect(names, old_names)
[17:03:36.557]                 added <- setdiff(names, old_names)
[17:03:36.557]                 removed <- setdiff(old_names, names)
[17:03:36.557]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.557]                   envs[common]]
[17:03:36.557]                 NAMES <- toupper(changed)
[17:03:36.557]                 args <- list()
[17:03:36.557]                 for (kk in seq_along(NAMES)) {
[17:03:36.557]                   name <- changed[[kk]]
[17:03:36.557]                   NAME <- NAMES[[kk]]
[17:03:36.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.557]                     next
[17:03:36.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.557]                 }
[17:03:36.557]                 NAMES <- toupper(added)
[17:03:36.557]                 for (kk in seq_along(NAMES)) {
[17:03:36.557]                   name <- added[[kk]]
[17:03:36.557]                   NAME <- NAMES[[kk]]
[17:03:36.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.557]                     next
[17:03:36.557]                   args[[name]] <- ""
[17:03:36.557]                 }
[17:03:36.557]                 NAMES <- toupper(removed)
[17:03:36.557]                 for (kk in seq_along(NAMES)) {
[17:03:36.557]                   name <- removed[[kk]]
[17:03:36.557]                   NAME <- NAMES[[kk]]
[17:03:36.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.557]                     next
[17:03:36.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.557]                 }
[17:03:36.557]                 if (length(args) > 0) 
[17:03:36.557]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.557]             }
[17:03:36.557]             else {
[17:03:36.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.557]             }
[17:03:36.557]             {
[17:03:36.557]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.557]                   0L) {
[17:03:36.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.557]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.557]                   base::options(opts)
[17:03:36.557]                 }
[17:03:36.557]                 {
[17:03:36.557]                   {
[17:03:36.557]                     NULL
[17:03:36.557]                     RNGkind("Mersenne-Twister")
[17:03:36.557]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.557]                       inherits = FALSE)
[17:03:36.557]                   }
[17:03:36.557]                   options(future.plan = NULL)
[17:03:36.557]                   if (is.na(NA_character_)) 
[17:03:36.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.557]                     .init = FALSE)
[17:03:36.557]                 }
[17:03:36.557]             }
[17:03:36.557]         }
[17:03:36.557]     })
[17:03:36.557]     if (TRUE) {
[17:03:36.557]         base::sink(type = "output", split = FALSE)
[17:03:36.557]         if (TRUE) {
[17:03:36.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.557]         }
[17:03:36.557]         else {
[17:03:36.557]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.557]         }
[17:03:36.557]         base::close(...future.stdout)
[17:03:36.557]         ...future.stdout <- NULL
[17:03:36.557]     }
[17:03:36.557]     ...future.result$conditions <- ...future.conditions
[17:03:36.557]     ...future.result$finished <- base::Sys.time()
[17:03:36.557]     ...future.result
[17:03:36.557] }
[17:03:36.559] plan(): Setting new future strategy stack:
[17:03:36.559] List of future strategies:
[17:03:36.559] 1. sequential:
[17:03:36.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.559]    - tweaked: FALSE
[17:03:36.559]    - call: NULL
[17:03:36.560] plan(): nbrOfWorkers() = 1
[17:03:36.560] plan(): Setting new future strategy stack:
[17:03:36.560] List of future strategies:
[17:03:36.560] 1. sequential:
[17:03:36.560]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.560]    - tweaked: FALSE
[17:03:36.560]    - call: plan(strategy)
[17:03:36.561] plan(): nbrOfWorkers() = 1
[17:03:36.561] SequentialFuture started (and completed)
[17:03:36.561] - Launch lazy future ... done
[17:03:36.561] run() for ‘SequentialFuture’ ... done
[17:03:36.561] resolve() on list ...
[17:03:36.562]  recursive: 0
[17:03:36.562]  length: 3
[17:03:36.562]  elements: ‘a’, ‘b’, ‘’
[17:03:36.562] resolved() for ‘SequentialFuture’ ...
[17:03:36.562] - state: ‘finished’
[17:03:36.562] - run: TRUE
[17:03:36.562] - result: ‘FutureResult’
[17:03:36.562] resolved() for ‘SequentialFuture’ ... done
[17:03:36.562] Future #1
[17:03:36.563]  length: 2 (resolved future 1)
[17:03:36.563] resolved() for ‘SequentialFuture’ ...
[17:03:36.563] - state: ‘finished’
[17:03:36.563] - run: TRUE
[17:03:36.563] - result: ‘FutureResult’
[17:03:36.563] resolved() for ‘SequentialFuture’ ... done
[17:03:36.563] Future #2
[17:03:36.563]  length: 1 (resolved future 2)
[17:03:36.563]  length: 0 (resolved future 3)
[17:03:36.564] resolve() on list ... DONE
[17:03:36.564] resolved() for ‘SequentialFuture’ ...
[17:03:36.564] - state: ‘finished’
[17:03:36.564] - run: TRUE
[17:03:36.564] - result: ‘FutureResult’
[17:03:36.564] resolved() for ‘SequentialFuture’ ... done
[17:03:36.564] resolved() for ‘SequentialFuture’ ...
[17:03:36.564] - state: ‘finished’
[17:03:36.564] - run: TRUE
[17:03:36.564] - result: ‘FutureResult’
[17:03:36.564] resolved() for ‘SequentialFuture’ ... done
[17:03:36.565] getGlobalsAndPackages() ...
[17:03:36.565] Searching for globals...
[17:03:36.565] 
[17:03:36.565] Searching for globals ... DONE
[17:03:36.565] - globals: [0] <none>
[17:03:36.565] getGlobalsAndPackages() ... DONE
[17:03:36.565] getGlobalsAndPackages() ...
[17:03:36.566] Searching for globals...
[17:03:36.566] 
[17:03:36.566] Searching for globals ... DONE
[17:03:36.566] - globals: [0] <none>
[17:03:36.566] getGlobalsAndPackages() ... DONE
[17:03:36.566] run() for ‘Future’ ...
[17:03:36.566] - state: ‘created’
[17:03:36.567] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.567] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.567]   - Field: ‘label’
[17:03:36.567]   - Field: ‘local’
[17:03:36.567]   - Field: ‘owner’
[17:03:36.567]   - Field: ‘envir’
[17:03:36.567]   - Field: ‘packages’
[17:03:36.568]   - Field: ‘gc’
[17:03:36.568]   - Field: ‘conditions’
[17:03:36.568]   - Field: ‘expr’
[17:03:36.568]   - Field: ‘uuid’
[17:03:36.568]   - Field: ‘seed’
[17:03:36.568]   - Field: ‘version’
[17:03:36.568]   - Field: ‘result’
[17:03:36.568]   - Field: ‘asynchronous’
[17:03:36.568]   - Field: ‘calls’
[17:03:36.568]   - Field: ‘globals’
[17:03:36.568]   - Field: ‘stdout’
[17:03:36.569]   - Field: ‘earlySignal’
[17:03:36.569]   - Field: ‘lazy’
[17:03:36.569]   - Field: ‘state’
[17:03:36.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.569] - Launch lazy future ...
[17:03:36.569] Packages needed by the future expression (n = 0): <none>
[17:03:36.569] Packages needed by future strategies (n = 0): <none>
[17:03:36.570] {
[17:03:36.570]     {
[17:03:36.570]         {
[17:03:36.570]             ...future.startTime <- base::Sys.time()
[17:03:36.570]             {
[17:03:36.570]                 {
[17:03:36.570]                   {
[17:03:36.570]                     base::local({
[17:03:36.570]                       has_future <- base::requireNamespace("future", 
[17:03:36.570]                         quietly = TRUE)
[17:03:36.570]                       if (has_future) {
[17:03:36.570]                         ns <- base::getNamespace("future")
[17:03:36.570]                         version <- ns[[".package"]][["version"]]
[17:03:36.570]                         if (is.null(version)) 
[17:03:36.570]                           version <- utils::packageVersion("future")
[17:03:36.570]                       }
[17:03:36.570]                       else {
[17:03:36.570]                         version <- NULL
[17:03:36.570]                       }
[17:03:36.570]                       if (!has_future || version < "1.8.0") {
[17:03:36.570]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.570]                           "", base::R.version$version.string), 
[17:03:36.570]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.570]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.570]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.570]                             "release", "version")], collapse = " "), 
[17:03:36.570]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.570]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.570]                           info)
[17:03:36.570]                         info <- base::paste(info, collapse = "; ")
[17:03:36.570]                         if (!has_future) {
[17:03:36.570]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.570]                             info)
[17:03:36.570]                         }
[17:03:36.570]                         else {
[17:03:36.570]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.570]                             info, version)
[17:03:36.570]                         }
[17:03:36.570]                         base::stop(msg)
[17:03:36.570]                       }
[17:03:36.570]                     })
[17:03:36.570]                   }
[17:03:36.570]                   ...future.strategy.old <- future::plan("list")
[17:03:36.570]                   options(future.plan = NULL)
[17:03:36.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.570]                 }
[17:03:36.570]                 ...future.workdir <- getwd()
[17:03:36.570]             }
[17:03:36.570]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.570]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.570]         }
[17:03:36.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.570]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.570]             base::names(...future.oldOptions))
[17:03:36.570]     }
[17:03:36.570]     if (FALSE) {
[17:03:36.570]     }
[17:03:36.570]     else {
[17:03:36.570]         if (TRUE) {
[17:03:36.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.570]                 open = "w")
[17:03:36.570]         }
[17:03:36.570]         else {
[17:03:36.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.570]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.570]         }
[17:03:36.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.570]             base::sink(type = "output", split = FALSE)
[17:03:36.570]             base::close(...future.stdout)
[17:03:36.570]         }, add = TRUE)
[17:03:36.570]     }
[17:03:36.570]     ...future.frame <- base::sys.nframe()
[17:03:36.570]     ...future.conditions <- base::list()
[17:03:36.570]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.570]     if (FALSE) {
[17:03:36.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.570]     }
[17:03:36.570]     ...future.result <- base::tryCatch({
[17:03:36.570]         base::withCallingHandlers({
[17:03:36.570]             ...future.value <- base::withVisible(base::local(2))
[17:03:36.570]             future::FutureResult(value = ...future.value$value, 
[17:03:36.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.570]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.570]                     ...future.globalenv.names))
[17:03:36.570]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.570]         }, condition = base::local({
[17:03:36.570]             c <- base::c
[17:03:36.570]             inherits <- base::inherits
[17:03:36.570]             invokeRestart <- base::invokeRestart
[17:03:36.570]             length <- base::length
[17:03:36.570]             list <- base::list
[17:03:36.570]             seq.int <- base::seq.int
[17:03:36.570]             signalCondition <- base::signalCondition
[17:03:36.570]             sys.calls <- base::sys.calls
[17:03:36.570]             `[[` <- base::`[[`
[17:03:36.570]             `+` <- base::`+`
[17:03:36.570]             `<<-` <- base::`<<-`
[17:03:36.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.570]                   3L)]
[17:03:36.570]             }
[17:03:36.570]             function(cond) {
[17:03:36.570]                 is_error <- inherits(cond, "error")
[17:03:36.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.570]                   NULL)
[17:03:36.570]                 if (is_error) {
[17:03:36.570]                   sessionInformation <- function() {
[17:03:36.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.570]                       search = base::search(), system = base::Sys.info())
[17:03:36.570]                   }
[17:03:36.570]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.570]                     cond$call), session = sessionInformation(), 
[17:03:36.570]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.570]                   signalCondition(cond)
[17:03:36.570]                 }
[17:03:36.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.570]                 "immediateCondition"))) {
[17:03:36.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.570]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.570]                   if (TRUE && !signal) {
[17:03:36.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.570]                     {
[17:03:36.570]                       inherits <- base::inherits
[17:03:36.570]                       invokeRestart <- base::invokeRestart
[17:03:36.570]                       is.null <- base::is.null
[17:03:36.570]                       muffled <- FALSE
[17:03:36.570]                       if (inherits(cond, "message")) {
[17:03:36.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.570]                         if (muffled) 
[17:03:36.570]                           invokeRestart("muffleMessage")
[17:03:36.570]                       }
[17:03:36.570]                       else if (inherits(cond, "warning")) {
[17:03:36.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.570]                         if (muffled) 
[17:03:36.570]                           invokeRestart("muffleWarning")
[17:03:36.570]                       }
[17:03:36.570]                       else if (inherits(cond, "condition")) {
[17:03:36.570]                         if (!is.null(pattern)) {
[17:03:36.570]                           computeRestarts <- base::computeRestarts
[17:03:36.570]                           grepl <- base::grepl
[17:03:36.570]                           restarts <- computeRestarts(cond)
[17:03:36.570]                           for (restart in restarts) {
[17:03:36.570]                             name <- restart$name
[17:03:36.570]                             if (is.null(name)) 
[17:03:36.570]                               next
[17:03:36.570]                             if (!grepl(pattern, name)) 
[17:03:36.570]                               next
[17:03:36.570]                             invokeRestart(restart)
[17:03:36.570]                             muffled <- TRUE
[17:03:36.570]                             break
[17:03:36.570]                           }
[17:03:36.570]                         }
[17:03:36.570]                       }
[17:03:36.570]                       invisible(muffled)
[17:03:36.570]                     }
[17:03:36.570]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.570]                   }
[17:03:36.570]                 }
[17:03:36.570]                 else {
[17:03:36.570]                   if (TRUE) {
[17:03:36.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.570]                     {
[17:03:36.570]                       inherits <- base::inherits
[17:03:36.570]                       invokeRestart <- base::invokeRestart
[17:03:36.570]                       is.null <- base::is.null
[17:03:36.570]                       muffled <- FALSE
[17:03:36.570]                       if (inherits(cond, "message")) {
[17:03:36.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.570]                         if (muffled) 
[17:03:36.570]                           invokeRestart("muffleMessage")
[17:03:36.570]                       }
[17:03:36.570]                       else if (inherits(cond, "warning")) {
[17:03:36.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.570]                         if (muffled) 
[17:03:36.570]                           invokeRestart("muffleWarning")
[17:03:36.570]                       }
[17:03:36.570]                       else if (inherits(cond, "condition")) {
[17:03:36.570]                         if (!is.null(pattern)) {
[17:03:36.570]                           computeRestarts <- base::computeRestarts
[17:03:36.570]                           grepl <- base::grepl
[17:03:36.570]                           restarts <- computeRestarts(cond)
[17:03:36.570]                           for (restart in restarts) {
[17:03:36.570]                             name <- restart$name
[17:03:36.570]                             if (is.null(name)) 
[17:03:36.570]                               next
[17:03:36.570]                             if (!grepl(pattern, name)) 
[17:03:36.570]                               next
[17:03:36.570]                             invokeRestart(restart)
[17:03:36.570]                             muffled <- TRUE
[17:03:36.570]                             break
[17:03:36.570]                           }
[17:03:36.570]                         }
[17:03:36.570]                       }
[17:03:36.570]                       invisible(muffled)
[17:03:36.570]                     }
[17:03:36.570]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.570]                   }
[17:03:36.570]                 }
[17:03:36.570]             }
[17:03:36.570]         }))
[17:03:36.570]     }, error = function(ex) {
[17:03:36.570]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.570]                 ...future.rng), started = ...future.startTime, 
[17:03:36.570]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.570]             version = "1.8"), class = "FutureResult")
[17:03:36.570]     }, finally = {
[17:03:36.570]         if (!identical(...future.workdir, getwd())) 
[17:03:36.570]             setwd(...future.workdir)
[17:03:36.570]         {
[17:03:36.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.570]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.570]             }
[17:03:36.570]             base::options(...future.oldOptions)
[17:03:36.570]             if (.Platform$OS.type == "windows") {
[17:03:36.570]                 old_names <- names(...future.oldEnvVars)
[17:03:36.570]                 envs <- base::Sys.getenv()
[17:03:36.570]                 names <- names(envs)
[17:03:36.570]                 common <- intersect(names, old_names)
[17:03:36.570]                 added <- setdiff(names, old_names)
[17:03:36.570]                 removed <- setdiff(old_names, names)
[17:03:36.570]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.570]                   envs[common]]
[17:03:36.570]                 NAMES <- toupper(changed)
[17:03:36.570]                 args <- list()
[17:03:36.570]                 for (kk in seq_along(NAMES)) {
[17:03:36.570]                   name <- changed[[kk]]
[17:03:36.570]                   NAME <- NAMES[[kk]]
[17:03:36.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.570]                     next
[17:03:36.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.570]                 }
[17:03:36.570]                 NAMES <- toupper(added)
[17:03:36.570]                 for (kk in seq_along(NAMES)) {
[17:03:36.570]                   name <- added[[kk]]
[17:03:36.570]                   NAME <- NAMES[[kk]]
[17:03:36.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.570]                     next
[17:03:36.570]                   args[[name]] <- ""
[17:03:36.570]                 }
[17:03:36.570]                 NAMES <- toupper(removed)
[17:03:36.570]                 for (kk in seq_along(NAMES)) {
[17:03:36.570]                   name <- removed[[kk]]
[17:03:36.570]                   NAME <- NAMES[[kk]]
[17:03:36.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.570]                     next
[17:03:36.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.570]                 }
[17:03:36.570]                 if (length(args) > 0) 
[17:03:36.570]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.570]             }
[17:03:36.570]             else {
[17:03:36.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.570]             }
[17:03:36.570]             {
[17:03:36.570]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.570]                   0L) {
[17:03:36.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.570]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.570]                   base::options(opts)
[17:03:36.570]                 }
[17:03:36.570]                 {
[17:03:36.570]                   {
[17:03:36.570]                     NULL
[17:03:36.570]                     RNGkind("Mersenne-Twister")
[17:03:36.570]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.570]                       inherits = FALSE)
[17:03:36.570]                   }
[17:03:36.570]                   options(future.plan = NULL)
[17:03:36.570]                   if (is.na(NA_character_)) 
[17:03:36.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.570]                     .init = FALSE)
[17:03:36.570]                 }
[17:03:36.570]             }
[17:03:36.570]         }
[17:03:36.570]     })
[17:03:36.570]     if (TRUE) {
[17:03:36.570]         base::sink(type = "output", split = FALSE)
[17:03:36.570]         if (TRUE) {
[17:03:36.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.570]         }
[17:03:36.570]         else {
[17:03:36.570]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.570]         }
[17:03:36.570]         base::close(...future.stdout)
[17:03:36.570]         ...future.stdout <- NULL
[17:03:36.570]     }
[17:03:36.570]     ...future.result$conditions <- ...future.conditions
[17:03:36.570]     ...future.result$finished <- base::Sys.time()
[17:03:36.570]     ...future.result
[17:03:36.570] }
[17:03:36.571] plan(): Setting new future strategy stack:
[17:03:36.571] List of future strategies:
[17:03:36.571] 1. sequential:
[17:03:36.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.571]    - tweaked: FALSE
[17:03:36.571]    - call: NULL
[17:03:36.572] plan(): nbrOfWorkers() = 1
[17:03:36.573] plan(): Setting new future strategy stack:
[17:03:36.573] List of future strategies:
[17:03:36.573] 1. sequential:
[17:03:36.573]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.573]    - tweaked: FALSE
[17:03:36.573]    - call: plan(strategy)
[17:03:36.573] plan(): nbrOfWorkers() = 1
[17:03:36.573] SequentialFuture started (and completed)
[17:03:36.573] - Launch lazy future ... done
[17:03:36.574] run() for ‘SequentialFuture’ ... done
[17:03:36.574] resolve() on list ...
[17:03:36.574]  recursive: 0
[17:03:36.574]  length: 3
[17:03:36.574]  elements: ‘a’, ‘b’, ‘’
[17:03:36.574] run() for ‘Future’ ...
[17:03:36.574] - state: ‘created’
[17:03:36.574] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.574] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.575]   - Field: ‘label’
[17:03:36.575]   - Field: ‘local’
[17:03:36.575]   - Field: ‘owner’
[17:03:36.575]   - Field: ‘envir’
[17:03:36.575]   - Field: ‘packages’
[17:03:36.575]   - Field: ‘gc’
[17:03:36.575]   - Field: ‘conditions’
[17:03:36.575]   - Field: ‘expr’
[17:03:36.575]   - Field: ‘uuid’
[17:03:36.576]   - Field: ‘seed’
[17:03:36.576]   - Field: ‘version’
[17:03:36.576]   - Field: ‘result’
[17:03:36.576]   - Field: ‘asynchronous’
[17:03:36.576]   - Field: ‘calls’
[17:03:36.576]   - Field: ‘globals’
[17:03:36.576]   - Field: ‘stdout’
[17:03:36.576]   - Field: ‘earlySignal’
[17:03:36.576]   - Field: ‘lazy’
[17:03:36.576]   - Field: ‘state’
[17:03:36.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.577] - Launch lazy future ...
[17:03:36.577] Packages needed by the future expression (n = 0): <none>
[17:03:36.577] Packages needed by future strategies (n = 0): <none>
[17:03:36.577] {
[17:03:36.577]     {
[17:03:36.577]         {
[17:03:36.577]             ...future.startTime <- base::Sys.time()
[17:03:36.577]             {
[17:03:36.577]                 {
[17:03:36.577]                   {
[17:03:36.577]                     base::local({
[17:03:36.577]                       has_future <- base::requireNamespace("future", 
[17:03:36.577]                         quietly = TRUE)
[17:03:36.577]                       if (has_future) {
[17:03:36.577]                         ns <- base::getNamespace("future")
[17:03:36.577]                         version <- ns[[".package"]][["version"]]
[17:03:36.577]                         if (is.null(version)) 
[17:03:36.577]                           version <- utils::packageVersion("future")
[17:03:36.577]                       }
[17:03:36.577]                       else {
[17:03:36.577]                         version <- NULL
[17:03:36.577]                       }
[17:03:36.577]                       if (!has_future || version < "1.8.0") {
[17:03:36.577]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.577]                           "", base::R.version$version.string), 
[17:03:36.577]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.577]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.577]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.577]                             "release", "version")], collapse = " "), 
[17:03:36.577]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.577]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.577]                           info)
[17:03:36.577]                         info <- base::paste(info, collapse = "; ")
[17:03:36.577]                         if (!has_future) {
[17:03:36.577]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.577]                             info)
[17:03:36.577]                         }
[17:03:36.577]                         else {
[17:03:36.577]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.577]                             info, version)
[17:03:36.577]                         }
[17:03:36.577]                         base::stop(msg)
[17:03:36.577]                       }
[17:03:36.577]                     })
[17:03:36.577]                   }
[17:03:36.577]                   ...future.strategy.old <- future::plan("list")
[17:03:36.577]                   options(future.plan = NULL)
[17:03:36.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.577]                 }
[17:03:36.577]                 ...future.workdir <- getwd()
[17:03:36.577]             }
[17:03:36.577]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.577]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.577]         }
[17:03:36.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.577]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.577]             base::names(...future.oldOptions))
[17:03:36.577]     }
[17:03:36.577]     if (FALSE) {
[17:03:36.577]     }
[17:03:36.577]     else {
[17:03:36.577]         if (TRUE) {
[17:03:36.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.577]                 open = "w")
[17:03:36.577]         }
[17:03:36.577]         else {
[17:03:36.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.577]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.577]         }
[17:03:36.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.577]             base::sink(type = "output", split = FALSE)
[17:03:36.577]             base::close(...future.stdout)
[17:03:36.577]         }, add = TRUE)
[17:03:36.577]     }
[17:03:36.577]     ...future.frame <- base::sys.nframe()
[17:03:36.577]     ...future.conditions <- base::list()
[17:03:36.577]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.577]     if (FALSE) {
[17:03:36.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.577]     }
[17:03:36.577]     ...future.result <- base::tryCatch({
[17:03:36.577]         base::withCallingHandlers({
[17:03:36.577]             ...future.value <- base::withVisible(base::local(1))
[17:03:36.577]             future::FutureResult(value = ...future.value$value, 
[17:03:36.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.577]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.577]                     ...future.globalenv.names))
[17:03:36.577]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.577]         }, condition = base::local({
[17:03:36.577]             c <- base::c
[17:03:36.577]             inherits <- base::inherits
[17:03:36.577]             invokeRestart <- base::invokeRestart
[17:03:36.577]             length <- base::length
[17:03:36.577]             list <- base::list
[17:03:36.577]             seq.int <- base::seq.int
[17:03:36.577]             signalCondition <- base::signalCondition
[17:03:36.577]             sys.calls <- base::sys.calls
[17:03:36.577]             `[[` <- base::`[[`
[17:03:36.577]             `+` <- base::`+`
[17:03:36.577]             `<<-` <- base::`<<-`
[17:03:36.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.577]                   3L)]
[17:03:36.577]             }
[17:03:36.577]             function(cond) {
[17:03:36.577]                 is_error <- inherits(cond, "error")
[17:03:36.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.577]                   NULL)
[17:03:36.577]                 if (is_error) {
[17:03:36.577]                   sessionInformation <- function() {
[17:03:36.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.577]                       search = base::search(), system = base::Sys.info())
[17:03:36.577]                   }
[17:03:36.577]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.577]                     cond$call), session = sessionInformation(), 
[17:03:36.577]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.577]                   signalCondition(cond)
[17:03:36.577]                 }
[17:03:36.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.577]                 "immediateCondition"))) {
[17:03:36.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.577]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.577]                   if (TRUE && !signal) {
[17:03:36.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.577]                     {
[17:03:36.577]                       inherits <- base::inherits
[17:03:36.577]                       invokeRestart <- base::invokeRestart
[17:03:36.577]                       is.null <- base::is.null
[17:03:36.577]                       muffled <- FALSE
[17:03:36.577]                       if (inherits(cond, "message")) {
[17:03:36.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.577]                         if (muffled) 
[17:03:36.577]                           invokeRestart("muffleMessage")
[17:03:36.577]                       }
[17:03:36.577]                       else if (inherits(cond, "warning")) {
[17:03:36.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.577]                         if (muffled) 
[17:03:36.577]                           invokeRestart("muffleWarning")
[17:03:36.577]                       }
[17:03:36.577]                       else if (inherits(cond, "condition")) {
[17:03:36.577]                         if (!is.null(pattern)) {
[17:03:36.577]                           computeRestarts <- base::computeRestarts
[17:03:36.577]                           grepl <- base::grepl
[17:03:36.577]                           restarts <- computeRestarts(cond)
[17:03:36.577]                           for (restart in restarts) {
[17:03:36.577]                             name <- restart$name
[17:03:36.577]                             if (is.null(name)) 
[17:03:36.577]                               next
[17:03:36.577]                             if (!grepl(pattern, name)) 
[17:03:36.577]                               next
[17:03:36.577]                             invokeRestart(restart)
[17:03:36.577]                             muffled <- TRUE
[17:03:36.577]                             break
[17:03:36.577]                           }
[17:03:36.577]                         }
[17:03:36.577]                       }
[17:03:36.577]                       invisible(muffled)
[17:03:36.577]                     }
[17:03:36.577]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.577]                   }
[17:03:36.577]                 }
[17:03:36.577]                 else {
[17:03:36.577]                   if (TRUE) {
[17:03:36.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.577]                     {
[17:03:36.577]                       inherits <- base::inherits
[17:03:36.577]                       invokeRestart <- base::invokeRestart
[17:03:36.577]                       is.null <- base::is.null
[17:03:36.577]                       muffled <- FALSE
[17:03:36.577]                       if (inherits(cond, "message")) {
[17:03:36.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.577]                         if (muffled) 
[17:03:36.577]                           invokeRestart("muffleMessage")
[17:03:36.577]                       }
[17:03:36.577]                       else if (inherits(cond, "warning")) {
[17:03:36.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.577]                         if (muffled) 
[17:03:36.577]                           invokeRestart("muffleWarning")
[17:03:36.577]                       }
[17:03:36.577]                       else if (inherits(cond, "condition")) {
[17:03:36.577]                         if (!is.null(pattern)) {
[17:03:36.577]                           computeRestarts <- base::computeRestarts
[17:03:36.577]                           grepl <- base::grepl
[17:03:36.577]                           restarts <- computeRestarts(cond)
[17:03:36.577]                           for (restart in restarts) {
[17:03:36.577]                             name <- restart$name
[17:03:36.577]                             if (is.null(name)) 
[17:03:36.577]                               next
[17:03:36.577]                             if (!grepl(pattern, name)) 
[17:03:36.577]                               next
[17:03:36.577]                             invokeRestart(restart)
[17:03:36.577]                             muffled <- TRUE
[17:03:36.577]                             break
[17:03:36.577]                           }
[17:03:36.577]                         }
[17:03:36.577]                       }
[17:03:36.577]                       invisible(muffled)
[17:03:36.577]                     }
[17:03:36.577]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.577]                   }
[17:03:36.577]                 }
[17:03:36.577]             }
[17:03:36.577]         }))
[17:03:36.577]     }, error = function(ex) {
[17:03:36.577]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.577]                 ...future.rng), started = ...future.startTime, 
[17:03:36.577]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.577]             version = "1.8"), class = "FutureResult")
[17:03:36.577]     }, finally = {
[17:03:36.577]         if (!identical(...future.workdir, getwd())) 
[17:03:36.577]             setwd(...future.workdir)
[17:03:36.577]         {
[17:03:36.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.577]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.577]             }
[17:03:36.577]             base::options(...future.oldOptions)
[17:03:36.577]             if (.Platform$OS.type == "windows") {
[17:03:36.577]                 old_names <- names(...future.oldEnvVars)
[17:03:36.577]                 envs <- base::Sys.getenv()
[17:03:36.577]                 names <- names(envs)
[17:03:36.577]                 common <- intersect(names, old_names)
[17:03:36.577]                 added <- setdiff(names, old_names)
[17:03:36.577]                 removed <- setdiff(old_names, names)
[17:03:36.577]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.577]                   envs[common]]
[17:03:36.577]                 NAMES <- toupper(changed)
[17:03:36.577]                 args <- list()
[17:03:36.577]                 for (kk in seq_along(NAMES)) {
[17:03:36.577]                   name <- changed[[kk]]
[17:03:36.577]                   NAME <- NAMES[[kk]]
[17:03:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.577]                     next
[17:03:36.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.577]                 }
[17:03:36.577]                 NAMES <- toupper(added)
[17:03:36.577]                 for (kk in seq_along(NAMES)) {
[17:03:36.577]                   name <- added[[kk]]
[17:03:36.577]                   NAME <- NAMES[[kk]]
[17:03:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.577]                     next
[17:03:36.577]                   args[[name]] <- ""
[17:03:36.577]                 }
[17:03:36.577]                 NAMES <- toupper(removed)
[17:03:36.577]                 for (kk in seq_along(NAMES)) {
[17:03:36.577]                   name <- removed[[kk]]
[17:03:36.577]                   NAME <- NAMES[[kk]]
[17:03:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.577]                     next
[17:03:36.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.577]                 }
[17:03:36.577]                 if (length(args) > 0) 
[17:03:36.577]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.577]             }
[17:03:36.577]             else {
[17:03:36.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.577]             }
[17:03:36.577]             {
[17:03:36.577]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.577]                   0L) {
[17:03:36.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.577]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.577]                   base::options(opts)
[17:03:36.577]                 }
[17:03:36.577]                 {
[17:03:36.577]                   {
[17:03:36.577]                     NULL
[17:03:36.577]                     RNGkind("Mersenne-Twister")
[17:03:36.577]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.577]                       inherits = FALSE)
[17:03:36.577]                   }
[17:03:36.577]                   options(future.plan = NULL)
[17:03:36.577]                   if (is.na(NA_character_)) 
[17:03:36.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.577]                     .init = FALSE)
[17:03:36.577]                 }
[17:03:36.577]             }
[17:03:36.577]         }
[17:03:36.577]     })
[17:03:36.577]     if (TRUE) {
[17:03:36.577]         base::sink(type = "output", split = FALSE)
[17:03:36.577]         if (TRUE) {
[17:03:36.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.577]         }
[17:03:36.577]         else {
[17:03:36.577]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.577]         }
[17:03:36.577]         base::close(...future.stdout)
[17:03:36.577]         ...future.stdout <- NULL
[17:03:36.577]     }
[17:03:36.577]     ...future.result$conditions <- ...future.conditions
[17:03:36.577]     ...future.result$finished <- base::Sys.time()
[17:03:36.577]     ...future.result
[17:03:36.577] }
[17:03:36.579] plan(): Setting new future strategy stack:
[17:03:36.579] List of future strategies:
[17:03:36.579] 1. sequential:
[17:03:36.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.579]    - tweaked: FALSE
[17:03:36.579]    - call: NULL
[17:03:36.582] plan(): nbrOfWorkers() = 1
[17:03:36.583] plan(): Setting new future strategy stack:
[17:03:36.583] List of future strategies:
[17:03:36.583] 1. sequential:
[17:03:36.583]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.583]    - tweaked: FALSE
[17:03:36.583]    - call: plan(strategy)
[17:03:36.583] plan(): nbrOfWorkers() = 1
[17:03:36.583] SequentialFuture started (and completed)
[17:03:36.584] - Launch lazy future ... done
[17:03:36.584] run() for ‘SequentialFuture’ ... done
[17:03:36.584] resolved() for ‘SequentialFuture’ ...
[17:03:36.584] - state: ‘finished’
[17:03:36.584] - run: TRUE
[17:03:36.584] - result: ‘FutureResult’
[17:03:36.584] resolved() for ‘SequentialFuture’ ... done
[17:03:36.584] Future #1
[17:03:36.584]  length: 2 (resolved future 1)
[17:03:36.585] resolved() for ‘SequentialFuture’ ...
[17:03:36.585] - state: ‘finished’
[17:03:36.585] - run: TRUE
[17:03:36.585] - result: ‘FutureResult’
[17:03:36.585] resolved() for ‘SequentialFuture’ ... done
[17:03:36.585] Future #2
[17:03:36.585]  length: 1 (resolved future 2)
[17:03:36.585]  length: 0 (resolved future 3)
[17:03:36.585] resolve() on list ... DONE
[17:03:36.585] resolved() for ‘SequentialFuture’ ...
[17:03:36.585] - state: ‘finished’
[17:03:36.586] - run: TRUE
[17:03:36.586] - result: ‘FutureResult’
[17:03:36.586] resolved() for ‘SequentialFuture’ ... done
[17:03:36.586] resolved() for ‘SequentialFuture’ ...
[17:03:36.586] - state: ‘finished’
[17:03:36.586] - run: TRUE
[17:03:36.586] - result: ‘FutureResult’
[17:03:36.586] resolved() for ‘SequentialFuture’ ... done
[17:03:36.586] getGlobalsAndPackages() ...
[17:03:36.586] Searching for globals...
[17:03:36.587] 
[17:03:36.587] Searching for globals ... DONE
[17:03:36.587] - globals: [0] <none>
[17:03:36.587] getGlobalsAndPackages() ... DONE
[17:03:36.587] getGlobalsAndPackages() ...
[17:03:36.587] Searching for globals...
[17:03:36.588] 
[17:03:36.588] Searching for globals ... DONE
[17:03:36.588] - globals: [0] <none>
[17:03:36.588] getGlobalsAndPackages() ... DONE
[17:03:36.588] resolve() on list ...
[17:03:36.588]  recursive: 0
[17:03:36.588]  length: 3
[17:03:36.588]  elements: ‘a’, ‘b’, ‘’
[17:03:36.588] run() for ‘Future’ ...
[17:03:36.589] - state: ‘created’
[17:03:36.589] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.589] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.589]   - Field: ‘label’
[17:03:36.589]   - Field: ‘local’
[17:03:36.589]   - Field: ‘owner’
[17:03:36.589]   - Field: ‘envir’
[17:03:36.590]   - Field: ‘packages’
[17:03:36.590]   - Field: ‘gc’
[17:03:36.590]   - Field: ‘conditions’
[17:03:36.590]   - Field: ‘expr’
[17:03:36.590]   - Field: ‘uuid’
[17:03:36.590]   - Field: ‘seed’
[17:03:36.590]   - Field: ‘version’
[17:03:36.590]   - Field: ‘result’
[17:03:36.590]   - Field: ‘asynchronous’
[17:03:36.590]   - Field: ‘calls’
[17:03:36.590]   - Field: ‘globals’
[17:03:36.591]   - Field: ‘stdout’
[17:03:36.591]   - Field: ‘earlySignal’
[17:03:36.591]   - Field: ‘lazy’
[17:03:36.591]   - Field: ‘state’
[17:03:36.591] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.591] - Launch lazy future ...
[17:03:36.591] Packages needed by the future expression (n = 0): <none>
[17:03:36.591] Packages needed by future strategies (n = 0): <none>
[17:03:36.592] {
[17:03:36.592]     {
[17:03:36.592]         {
[17:03:36.592]             ...future.startTime <- base::Sys.time()
[17:03:36.592]             {
[17:03:36.592]                 {
[17:03:36.592]                   {
[17:03:36.592]                     base::local({
[17:03:36.592]                       has_future <- base::requireNamespace("future", 
[17:03:36.592]                         quietly = TRUE)
[17:03:36.592]                       if (has_future) {
[17:03:36.592]                         ns <- base::getNamespace("future")
[17:03:36.592]                         version <- ns[[".package"]][["version"]]
[17:03:36.592]                         if (is.null(version)) 
[17:03:36.592]                           version <- utils::packageVersion("future")
[17:03:36.592]                       }
[17:03:36.592]                       else {
[17:03:36.592]                         version <- NULL
[17:03:36.592]                       }
[17:03:36.592]                       if (!has_future || version < "1.8.0") {
[17:03:36.592]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.592]                           "", base::R.version$version.string), 
[17:03:36.592]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.592]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.592]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.592]                             "release", "version")], collapse = " "), 
[17:03:36.592]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.592]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.592]                           info)
[17:03:36.592]                         info <- base::paste(info, collapse = "; ")
[17:03:36.592]                         if (!has_future) {
[17:03:36.592]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.592]                             info)
[17:03:36.592]                         }
[17:03:36.592]                         else {
[17:03:36.592]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.592]                             info, version)
[17:03:36.592]                         }
[17:03:36.592]                         base::stop(msg)
[17:03:36.592]                       }
[17:03:36.592]                     })
[17:03:36.592]                   }
[17:03:36.592]                   ...future.strategy.old <- future::plan("list")
[17:03:36.592]                   options(future.plan = NULL)
[17:03:36.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.592]                 }
[17:03:36.592]                 ...future.workdir <- getwd()
[17:03:36.592]             }
[17:03:36.592]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.592]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.592]         }
[17:03:36.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.592]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.592]             base::names(...future.oldOptions))
[17:03:36.592]     }
[17:03:36.592]     if (FALSE) {
[17:03:36.592]     }
[17:03:36.592]     else {
[17:03:36.592]         if (TRUE) {
[17:03:36.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.592]                 open = "w")
[17:03:36.592]         }
[17:03:36.592]         else {
[17:03:36.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.592]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.592]         }
[17:03:36.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.592]             base::sink(type = "output", split = FALSE)
[17:03:36.592]             base::close(...future.stdout)
[17:03:36.592]         }, add = TRUE)
[17:03:36.592]     }
[17:03:36.592]     ...future.frame <- base::sys.nframe()
[17:03:36.592]     ...future.conditions <- base::list()
[17:03:36.592]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.592]     if (FALSE) {
[17:03:36.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.592]     }
[17:03:36.592]     ...future.result <- base::tryCatch({
[17:03:36.592]         base::withCallingHandlers({
[17:03:36.592]             ...future.value <- base::withVisible(base::local(1))
[17:03:36.592]             future::FutureResult(value = ...future.value$value, 
[17:03:36.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.592]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.592]                     ...future.globalenv.names))
[17:03:36.592]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.592]         }, condition = base::local({
[17:03:36.592]             c <- base::c
[17:03:36.592]             inherits <- base::inherits
[17:03:36.592]             invokeRestart <- base::invokeRestart
[17:03:36.592]             length <- base::length
[17:03:36.592]             list <- base::list
[17:03:36.592]             seq.int <- base::seq.int
[17:03:36.592]             signalCondition <- base::signalCondition
[17:03:36.592]             sys.calls <- base::sys.calls
[17:03:36.592]             `[[` <- base::`[[`
[17:03:36.592]             `+` <- base::`+`
[17:03:36.592]             `<<-` <- base::`<<-`
[17:03:36.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.592]                   3L)]
[17:03:36.592]             }
[17:03:36.592]             function(cond) {
[17:03:36.592]                 is_error <- inherits(cond, "error")
[17:03:36.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.592]                   NULL)
[17:03:36.592]                 if (is_error) {
[17:03:36.592]                   sessionInformation <- function() {
[17:03:36.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.592]                       search = base::search(), system = base::Sys.info())
[17:03:36.592]                   }
[17:03:36.592]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.592]                     cond$call), session = sessionInformation(), 
[17:03:36.592]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.592]                   signalCondition(cond)
[17:03:36.592]                 }
[17:03:36.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.592]                 "immediateCondition"))) {
[17:03:36.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.592]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.592]                   if (TRUE && !signal) {
[17:03:36.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.592]                     {
[17:03:36.592]                       inherits <- base::inherits
[17:03:36.592]                       invokeRestart <- base::invokeRestart
[17:03:36.592]                       is.null <- base::is.null
[17:03:36.592]                       muffled <- FALSE
[17:03:36.592]                       if (inherits(cond, "message")) {
[17:03:36.592]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.592]                         if (muffled) 
[17:03:36.592]                           invokeRestart("muffleMessage")
[17:03:36.592]                       }
[17:03:36.592]                       else if (inherits(cond, "warning")) {
[17:03:36.592]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.592]                         if (muffled) 
[17:03:36.592]                           invokeRestart("muffleWarning")
[17:03:36.592]                       }
[17:03:36.592]                       else if (inherits(cond, "condition")) {
[17:03:36.592]                         if (!is.null(pattern)) {
[17:03:36.592]                           computeRestarts <- base::computeRestarts
[17:03:36.592]                           grepl <- base::grepl
[17:03:36.592]                           restarts <- computeRestarts(cond)
[17:03:36.592]                           for (restart in restarts) {
[17:03:36.592]                             name <- restart$name
[17:03:36.592]                             if (is.null(name)) 
[17:03:36.592]                               next
[17:03:36.592]                             if (!grepl(pattern, name)) 
[17:03:36.592]                               next
[17:03:36.592]                             invokeRestart(restart)
[17:03:36.592]                             muffled <- TRUE
[17:03:36.592]                             break
[17:03:36.592]                           }
[17:03:36.592]                         }
[17:03:36.592]                       }
[17:03:36.592]                       invisible(muffled)
[17:03:36.592]                     }
[17:03:36.592]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.592]                   }
[17:03:36.592]                 }
[17:03:36.592]                 else {
[17:03:36.592]                   if (TRUE) {
[17:03:36.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.592]                     {
[17:03:36.592]                       inherits <- base::inherits
[17:03:36.592]                       invokeRestart <- base::invokeRestart
[17:03:36.592]                       is.null <- base::is.null
[17:03:36.592]                       muffled <- FALSE
[17:03:36.592]                       if (inherits(cond, "message")) {
[17:03:36.592]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.592]                         if (muffled) 
[17:03:36.592]                           invokeRestart("muffleMessage")
[17:03:36.592]                       }
[17:03:36.592]                       else if (inherits(cond, "warning")) {
[17:03:36.592]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.592]                         if (muffled) 
[17:03:36.592]                           invokeRestart("muffleWarning")
[17:03:36.592]                       }
[17:03:36.592]                       else if (inherits(cond, "condition")) {
[17:03:36.592]                         if (!is.null(pattern)) {
[17:03:36.592]                           computeRestarts <- base::computeRestarts
[17:03:36.592]                           grepl <- base::grepl
[17:03:36.592]                           restarts <- computeRestarts(cond)
[17:03:36.592]                           for (restart in restarts) {
[17:03:36.592]                             name <- restart$name
[17:03:36.592]                             if (is.null(name)) 
[17:03:36.592]                               next
[17:03:36.592]                             if (!grepl(pattern, name)) 
[17:03:36.592]                               next
[17:03:36.592]                             invokeRestart(restart)
[17:03:36.592]                             muffled <- TRUE
[17:03:36.592]                             break
[17:03:36.592]                           }
[17:03:36.592]                         }
[17:03:36.592]                       }
[17:03:36.592]                       invisible(muffled)
[17:03:36.592]                     }
[17:03:36.592]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.592]                   }
[17:03:36.592]                 }
[17:03:36.592]             }
[17:03:36.592]         }))
[17:03:36.592]     }, error = function(ex) {
[17:03:36.592]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.592]                 ...future.rng), started = ...future.startTime, 
[17:03:36.592]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.592]             version = "1.8"), class = "FutureResult")
[17:03:36.592]     }, finally = {
[17:03:36.592]         if (!identical(...future.workdir, getwd())) 
[17:03:36.592]             setwd(...future.workdir)
[17:03:36.592]         {
[17:03:36.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.592]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.592]             }
[17:03:36.592]             base::options(...future.oldOptions)
[17:03:36.592]             if (.Platform$OS.type == "windows") {
[17:03:36.592]                 old_names <- names(...future.oldEnvVars)
[17:03:36.592]                 envs <- base::Sys.getenv()
[17:03:36.592]                 names <- names(envs)
[17:03:36.592]                 common <- intersect(names, old_names)
[17:03:36.592]                 added <- setdiff(names, old_names)
[17:03:36.592]                 removed <- setdiff(old_names, names)
[17:03:36.592]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.592]                   envs[common]]
[17:03:36.592]                 NAMES <- toupper(changed)
[17:03:36.592]                 args <- list()
[17:03:36.592]                 for (kk in seq_along(NAMES)) {
[17:03:36.592]                   name <- changed[[kk]]
[17:03:36.592]                   NAME <- NAMES[[kk]]
[17:03:36.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.592]                     next
[17:03:36.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.592]                 }
[17:03:36.592]                 NAMES <- toupper(added)
[17:03:36.592]                 for (kk in seq_along(NAMES)) {
[17:03:36.592]                   name <- added[[kk]]
[17:03:36.592]                   NAME <- NAMES[[kk]]
[17:03:36.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.592]                     next
[17:03:36.592]                   args[[name]] <- ""
[17:03:36.592]                 }
[17:03:36.592]                 NAMES <- toupper(removed)
[17:03:36.592]                 for (kk in seq_along(NAMES)) {
[17:03:36.592]                   name <- removed[[kk]]
[17:03:36.592]                   NAME <- NAMES[[kk]]
[17:03:36.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.592]                     next
[17:03:36.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.592]                 }
[17:03:36.592]                 if (length(args) > 0) 
[17:03:36.592]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.592]             }
[17:03:36.592]             else {
[17:03:36.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.592]             }
[17:03:36.592]             {
[17:03:36.592]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.592]                   0L) {
[17:03:36.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.592]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.592]                   base::options(opts)
[17:03:36.592]                 }
[17:03:36.592]                 {
[17:03:36.592]                   {
[17:03:36.592]                     NULL
[17:03:36.592]                     RNGkind("Mersenne-Twister")
[17:03:36.592]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.592]                       inherits = FALSE)
[17:03:36.592]                   }
[17:03:36.592]                   options(future.plan = NULL)
[17:03:36.592]                   if (is.na(NA_character_)) 
[17:03:36.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.592]                     .init = FALSE)
[17:03:36.592]                 }
[17:03:36.592]             }
[17:03:36.592]         }
[17:03:36.592]     })
[17:03:36.592]     if (TRUE) {
[17:03:36.592]         base::sink(type = "output", split = FALSE)
[17:03:36.592]         if (TRUE) {
[17:03:36.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.592]         }
[17:03:36.592]         else {
[17:03:36.592]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.592]         }
[17:03:36.592]         base::close(...future.stdout)
[17:03:36.592]         ...future.stdout <- NULL
[17:03:36.592]     }
[17:03:36.592]     ...future.result$conditions <- ...future.conditions
[17:03:36.592]     ...future.result$finished <- base::Sys.time()
[17:03:36.592]     ...future.result
[17:03:36.592] }
[17:03:36.593] plan(): Setting new future strategy stack:
[17:03:36.594] List of future strategies:
[17:03:36.594] 1. sequential:
[17:03:36.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.594]    - tweaked: FALSE
[17:03:36.594]    - call: NULL
[17:03:36.594] plan(): nbrOfWorkers() = 1
[17:03:36.595] plan(): Setting new future strategy stack:
[17:03:36.595] List of future strategies:
[17:03:36.595] 1. sequential:
[17:03:36.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.595]    - tweaked: FALSE
[17:03:36.595]    - call: plan(strategy)
[17:03:36.595] plan(): nbrOfWorkers() = 1
[17:03:36.595] SequentialFuture started (and completed)
[17:03:36.596] - Launch lazy future ... done
[17:03:36.596] run() for ‘SequentialFuture’ ... done
[17:03:36.596] resolved() for ‘SequentialFuture’ ...
[17:03:36.596] - state: ‘finished’
[17:03:36.596] - run: TRUE
[17:03:36.596] - result: ‘FutureResult’
[17:03:36.596] resolved() for ‘SequentialFuture’ ... done
[17:03:36.596] Future #1
[17:03:36.596]  length: 2 (resolved future 1)
[17:03:36.596] run() for ‘Future’ ...
[17:03:36.597] - state: ‘created’
[17:03:36.597] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.597] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.597]   - Field: ‘label’
[17:03:36.597]   - Field: ‘local’
[17:03:36.597]   - Field: ‘owner’
[17:03:36.597]   - Field: ‘envir’
[17:03:36.598]   - Field: ‘packages’
[17:03:36.598]   - Field: ‘gc’
[17:03:36.598]   - Field: ‘conditions’
[17:03:36.598]   - Field: ‘expr’
[17:03:36.598]   - Field: ‘uuid’
[17:03:36.598]   - Field: ‘seed’
[17:03:36.598]   - Field: ‘version’
[17:03:36.598]   - Field: ‘result’
[17:03:36.598]   - Field: ‘asynchronous’
[17:03:36.598]   - Field: ‘calls’
[17:03:36.598]   - Field: ‘globals’
[17:03:36.599]   - Field: ‘stdout’
[17:03:36.599]   - Field: ‘earlySignal’
[17:03:36.599]   - Field: ‘lazy’
[17:03:36.599]   - Field: ‘state’
[17:03:36.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.599] - Launch lazy future ...
[17:03:36.599] Packages needed by the future expression (n = 0): <none>
[17:03:36.599] Packages needed by future strategies (n = 0): <none>
[17:03:36.600] {
[17:03:36.600]     {
[17:03:36.600]         {
[17:03:36.600]             ...future.startTime <- base::Sys.time()
[17:03:36.600]             {
[17:03:36.600]                 {
[17:03:36.600]                   {
[17:03:36.600]                     base::local({
[17:03:36.600]                       has_future <- base::requireNamespace("future", 
[17:03:36.600]                         quietly = TRUE)
[17:03:36.600]                       if (has_future) {
[17:03:36.600]                         ns <- base::getNamespace("future")
[17:03:36.600]                         version <- ns[[".package"]][["version"]]
[17:03:36.600]                         if (is.null(version)) 
[17:03:36.600]                           version <- utils::packageVersion("future")
[17:03:36.600]                       }
[17:03:36.600]                       else {
[17:03:36.600]                         version <- NULL
[17:03:36.600]                       }
[17:03:36.600]                       if (!has_future || version < "1.8.0") {
[17:03:36.600]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.600]                           "", base::R.version$version.string), 
[17:03:36.600]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.600]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.600]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.600]                             "release", "version")], collapse = " "), 
[17:03:36.600]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.600]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.600]                           info)
[17:03:36.600]                         info <- base::paste(info, collapse = "; ")
[17:03:36.600]                         if (!has_future) {
[17:03:36.600]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.600]                             info)
[17:03:36.600]                         }
[17:03:36.600]                         else {
[17:03:36.600]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.600]                             info, version)
[17:03:36.600]                         }
[17:03:36.600]                         base::stop(msg)
[17:03:36.600]                       }
[17:03:36.600]                     })
[17:03:36.600]                   }
[17:03:36.600]                   ...future.strategy.old <- future::plan("list")
[17:03:36.600]                   options(future.plan = NULL)
[17:03:36.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.600]                 }
[17:03:36.600]                 ...future.workdir <- getwd()
[17:03:36.600]             }
[17:03:36.600]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.600]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.600]         }
[17:03:36.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.600]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.600]             base::names(...future.oldOptions))
[17:03:36.600]     }
[17:03:36.600]     if (FALSE) {
[17:03:36.600]     }
[17:03:36.600]     else {
[17:03:36.600]         if (TRUE) {
[17:03:36.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.600]                 open = "w")
[17:03:36.600]         }
[17:03:36.600]         else {
[17:03:36.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.600]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.600]         }
[17:03:36.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.600]             base::sink(type = "output", split = FALSE)
[17:03:36.600]             base::close(...future.stdout)
[17:03:36.600]         }, add = TRUE)
[17:03:36.600]     }
[17:03:36.600]     ...future.frame <- base::sys.nframe()
[17:03:36.600]     ...future.conditions <- base::list()
[17:03:36.600]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.600]     if (FALSE) {
[17:03:36.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.600]     }
[17:03:36.600]     ...future.result <- base::tryCatch({
[17:03:36.600]         base::withCallingHandlers({
[17:03:36.600]             ...future.value <- base::withVisible(base::local(2))
[17:03:36.600]             future::FutureResult(value = ...future.value$value, 
[17:03:36.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.600]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.600]                     ...future.globalenv.names))
[17:03:36.600]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.600]         }, condition = base::local({
[17:03:36.600]             c <- base::c
[17:03:36.600]             inherits <- base::inherits
[17:03:36.600]             invokeRestart <- base::invokeRestart
[17:03:36.600]             length <- base::length
[17:03:36.600]             list <- base::list
[17:03:36.600]             seq.int <- base::seq.int
[17:03:36.600]             signalCondition <- base::signalCondition
[17:03:36.600]             sys.calls <- base::sys.calls
[17:03:36.600]             `[[` <- base::`[[`
[17:03:36.600]             `+` <- base::`+`
[17:03:36.600]             `<<-` <- base::`<<-`
[17:03:36.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.600]                   3L)]
[17:03:36.600]             }
[17:03:36.600]             function(cond) {
[17:03:36.600]                 is_error <- inherits(cond, "error")
[17:03:36.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.600]                   NULL)
[17:03:36.600]                 if (is_error) {
[17:03:36.600]                   sessionInformation <- function() {
[17:03:36.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.600]                       search = base::search(), system = base::Sys.info())
[17:03:36.600]                   }
[17:03:36.600]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.600]                     cond$call), session = sessionInformation(), 
[17:03:36.600]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.600]                   signalCondition(cond)
[17:03:36.600]                 }
[17:03:36.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.600]                 "immediateCondition"))) {
[17:03:36.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.600]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.600]                   if (TRUE && !signal) {
[17:03:36.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.600]                     {
[17:03:36.600]                       inherits <- base::inherits
[17:03:36.600]                       invokeRestart <- base::invokeRestart
[17:03:36.600]                       is.null <- base::is.null
[17:03:36.600]                       muffled <- FALSE
[17:03:36.600]                       if (inherits(cond, "message")) {
[17:03:36.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.600]                         if (muffled) 
[17:03:36.600]                           invokeRestart("muffleMessage")
[17:03:36.600]                       }
[17:03:36.600]                       else if (inherits(cond, "warning")) {
[17:03:36.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.600]                         if (muffled) 
[17:03:36.600]                           invokeRestart("muffleWarning")
[17:03:36.600]                       }
[17:03:36.600]                       else if (inherits(cond, "condition")) {
[17:03:36.600]                         if (!is.null(pattern)) {
[17:03:36.600]                           computeRestarts <- base::computeRestarts
[17:03:36.600]                           grepl <- base::grepl
[17:03:36.600]                           restarts <- computeRestarts(cond)
[17:03:36.600]                           for (restart in restarts) {
[17:03:36.600]                             name <- restart$name
[17:03:36.600]                             if (is.null(name)) 
[17:03:36.600]                               next
[17:03:36.600]                             if (!grepl(pattern, name)) 
[17:03:36.600]                               next
[17:03:36.600]                             invokeRestart(restart)
[17:03:36.600]                             muffled <- TRUE
[17:03:36.600]                             break
[17:03:36.600]                           }
[17:03:36.600]                         }
[17:03:36.600]                       }
[17:03:36.600]                       invisible(muffled)
[17:03:36.600]                     }
[17:03:36.600]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.600]                   }
[17:03:36.600]                 }
[17:03:36.600]                 else {
[17:03:36.600]                   if (TRUE) {
[17:03:36.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.600]                     {
[17:03:36.600]                       inherits <- base::inherits
[17:03:36.600]                       invokeRestart <- base::invokeRestart
[17:03:36.600]                       is.null <- base::is.null
[17:03:36.600]                       muffled <- FALSE
[17:03:36.600]                       if (inherits(cond, "message")) {
[17:03:36.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.600]                         if (muffled) 
[17:03:36.600]                           invokeRestart("muffleMessage")
[17:03:36.600]                       }
[17:03:36.600]                       else if (inherits(cond, "warning")) {
[17:03:36.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.600]                         if (muffled) 
[17:03:36.600]                           invokeRestart("muffleWarning")
[17:03:36.600]                       }
[17:03:36.600]                       else if (inherits(cond, "condition")) {
[17:03:36.600]                         if (!is.null(pattern)) {
[17:03:36.600]                           computeRestarts <- base::computeRestarts
[17:03:36.600]                           grepl <- base::grepl
[17:03:36.600]                           restarts <- computeRestarts(cond)
[17:03:36.600]                           for (restart in restarts) {
[17:03:36.600]                             name <- restart$name
[17:03:36.600]                             if (is.null(name)) 
[17:03:36.600]                               next
[17:03:36.600]                             if (!grepl(pattern, name)) 
[17:03:36.600]                               next
[17:03:36.600]                             invokeRestart(restart)
[17:03:36.600]                             muffled <- TRUE
[17:03:36.600]                             break
[17:03:36.600]                           }
[17:03:36.600]                         }
[17:03:36.600]                       }
[17:03:36.600]                       invisible(muffled)
[17:03:36.600]                     }
[17:03:36.600]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.600]                   }
[17:03:36.600]                 }
[17:03:36.600]             }
[17:03:36.600]         }))
[17:03:36.600]     }, error = function(ex) {
[17:03:36.600]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.600]                 ...future.rng), started = ...future.startTime, 
[17:03:36.600]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.600]             version = "1.8"), class = "FutureResult")
[17:03:36.600]     }, finally = {
[17:03:36.600]         if (!identical(...future.workdir, getwd())) 
[17:03:36.600]             setwd(...future.workdir)
[17:03:36.600]         {
[17:03:36.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.600]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.600]             }
[17:03:36.600]             base::options(...future.oldOptions)
[17:03:36.600]             if (.Platform$OS.type == "windows") {
[17:03:36.600]                 old_names <- names(...future.oldEnvVars)
[17:03:36.600]                 envs <- base::Sys.getenv()
[17:03:36.600]                 names <- names(envs)
[17:03:36.600]                 common <- intersect(names, old_names)
[17:03:36.600]                 added <- setdiff(names, old_names)
[17:03:36.600]                 removed <- setdiff(old_names, names)
[17:03:36.600]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.600]                   envs[common]]
[17:03:36.600]                 NAMES <- toupper(changed)
[17:03:36.600]                 args <- list()
[17:03:36.600]                 for (kk in seq_along(NAMES)) {
[17:03:36.600]                   name <- changed[[kk]]
[17:03:36.600]                   NAME <- NAMES[[kk]]
[17:03:36.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.600]                     next
[17:03:36.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.600]                 }
[17:03:36.600]                 NAMES <- toupper(added)
[17:03:36.600]                 for (kk in seq_along(NAMES)) {
[17:03:36.600]                   name <- added[[kk]]
[17:03:36.600]                   NAME <- NAMES[[kk]]
[17:03:36.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.600]                     next
[17:03:36.600]                   args[[name]] <- ""
[17:03:36.600]                 }
[17:03:36.600]                 NAMES <- toupper(removed)
[17:03:36.600]                 for (kk in seq_along(NAMES)) {
[17:03:36.600]                   name <- removed[[kk]]
[17:03:36.600]                   NAME <- NAMES[[kk]]
[17:03:36.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.600]                     next
[17:03:36.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.600]                 }
[17:03:36.600]                 if (length(args) > 0) 
[17:03:36.600]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.600]             }
[17:03:36.600]             else {
[17:03:36.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.600]             }
[17:03:36.600]             {
[17:03:36.600]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.600]                   0L) {
[17:03:36.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.600]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.600]                   base::options(opts)
[17:03:36.600]                 }
[17:03:36.600]                 {
[17:03:36.600]                   {
[17:03:36.600]                     NULL
[17:03:36.600]                     RNGkind("Mersenne-Twister")
[17:03:36.600]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.600]                       inherits = FALSE)
[17:03:36.600]                   }
[17:03:36.600]                   options(future.plan = NULL)
[17:03:36.600]                   if (is.na(NA_character_)) 
[17:03:36.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.600]                     .init = FALSE)
[17:03:36.600]                 }
[17:03:36.600]             }
[17:03:36.600]         }
[17:03:36.600]     })
[17:03:36.600]     if (TRUE) {
[17:03:36.600]         base::sink(type = "output", split = FALSE)
[17:03:36.600]         if (TRUE) {
[17:03:36.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.600]         }
[17:03:36.600]         else {
[17:03:36.600]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.600]         }
[17:03:36.600]         base::close(...future.stdout)
[17:03:36.600]         ...future.stdout <- NULL
[17:03:36.600]     }
[17:03:36.600]     ...future.result$conditions <- ...future.conditions
[17:03:36.600]     ...future.result$finished <- base::Sys.time()
[17:03:36.600]     ...future.result
[17:03:36.600] }
[17:03:36.601] plan(): Setting new future strategy stack:
[17:03:36.602] List of future strategies:
[17:03:36.602] 1. sequential:
[17:03:36.602]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.602]    - tweaked: FALSE
[17:03:36.602]    - call: NULL
[17:03:36.602] plan(): nbrOfWorkers() = 1
[17:03:36.603] plan(): Setting new future strategy stack:
[17:03:36.603] List of future strategies:
[17:03:36.603] 1. sequential:
[17:03:36.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.603]    - tweaked: FALSE
[17:03:36.603]    - call: plan(strategy)
[17:03:36.603] plan(): nbrOfWorkers() = 1
[17:03:36.603] SequentialFuture started (and completed)
[17:03:36.604] - Launch lazy future ... done
[17:03:36.604] run() for ‘SequentialFuture’ ... done
[17:03:36.604] resolved() for ‘SequentialFuture’ ...
[17:03:36.604] - state: ‘finished’
[17:03:36.604] - run: TRUE
[17:03:36.604] - result: ‘FutureResult’
[17:03:36.604] resolved() for ‘SequentialFuture’ ... done
[17:03:36.604] Future #2
[17:03:36.604]  length: 1 (resolved future 2)
[17:03:36.604]  length: 0 (resolved future 3)
[17:03:36.605] resolve() on list ... DONE
[17:03:36.605] resolved() for ‘SequentialFuture’ ...
[17:03:36.605] - state: ‘finished’
[17:03:36.605] - run: TRUE
[17:03:36.605] - result: ‘FutureResult’
[17:03:36.605] resolved() for ‘SequentialFuture’ ... done
[17:03:36.605] resolved() for ‘SequentialFuture’ ...
[17:03:36.605] - state: ‘finished’
[17:03:36.605] - run: TRUE
[17:03:36.605] - result: ‘FutureResult’
[17:03:36.605] resolved() for ‘SequentialFuture’ ... done
[17:03:36.606] getGlobalsAndPackages() ...
[17:03:36.606] Searching for globals...
[17:03:36.606] 
[17:03:36.606] Searching for globals ... DONE
[17:03:36.606] - globals: [0] <none>
[17:03:36.606] getGlobalsAndPackages() ... DONE
[17:03:36.606] run() for ‘Future’ ...
[17:03:36.607] - state: ‘created’
[17:03:36.607] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.607] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.607]   - Field: ‘label’
[17:03:36.607]   - Field: ‘local’
[17:03:36.607]   - Field: ‘owner’
[17:03:36.607]   - Field: ‘envir’
[17:03:36.608]   - Field: ‘packages’
[17:03:36.608]   - Field: ‘gc’
[17:03:36.608]   - Field: ‘conditions’
[17:03:36.608]   - Field: ‘expr’
[17:03:36.608]   - Field: ‘uuid’
[17:03:36.608]   - Field: ‘seed’
[17:03:36.608]   - Field: ‘version’
[17:03:36.608]   - Field: ‘result’
[17:03:36.608]   - Field: ‘asynchronous’
[17:03:36.608]   - Field: ‘calls’
[17:03:36.608]   - Field: ‘globals’
[17:03:36.609]   - Field: ‘stdout’
[17:03:36.609]   - Field: ‘earlySignal’
[17:03:36.609]   - Field: ‘lazy’
[17:03:36.609]   - Field: ‘state’
[17:03:36.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.609] - Launch lazy future ...
[17:03:36.609] Packages needed by the future expression (n = 0): <none>
[17:03:36.609] Packages needed by future strategies (n = 0): <none>
[17:03:36.610] {
[17:03:36.610]     {
[17:03:36.610]         {
[17:03:36.610]             ...future.startTime <- base::Sys.time()
[17:03:36.610]             {
[17:03:36.610]                 {
[17:03:36.610]                   {
[17:03:36.610]                     base::local({
[17:03:36.610]                       has_future <- base::requireNamespace("future", 
[17:03:36.610]                         quietly = TRUE)
[17:03:36.610]                       if (has_future) {
[17:03:36.610]                         ns <- base::getNamespace("future")
[17:03:36.610]                         version <- ns[[".package"]][["version"]]
[17:03:36.610]                         if (is.null(version)) 
[17:03:36.610]                           version <- utils::packageVersion("future")
[17:03:36.610]                       }
[17:03:36.610]                       else {
[17:03:36.610]                         version <- NULL
[17:03:36.610]                       }
[17:03:36.610]                       if (!has_future || version < "1.8.0") {
[17:03:36.610]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.610]                           "", base::R.version$version.string), 
[17:03:36.610]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.610]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.610]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.610]                             "release", "version")], collapse = " "), 
[17:03:36.610]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.610]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.610]                           info)
[17:03:36.610]                         info <- base::paste(info, collapse = "; ")
[17:03:36.610]                         if (!has_future) {
[17:03:36.610]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.610]                             info)
[17:03:36.610]                         }
[17:03:36.610]                         else {
[17:03:36.610]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.610]                             info, version)
[17:03:36.610]                         }
[17:03:36.610]                         base::stop(msg)
[17:03:36.610]                       }
[17:03:36.610]                     })
[17:03:36.610]                   }
[17:03:36.610]                   ...future.strategy.old <- future::plan("list")
[17:03:36.610]                   options(future.plan = NULL)
[17:03:36.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.610]                 }
[17:03:36.610]                 ...future.workdir <- getwd()
[17:03:36.610]             }
[17:03:36.610]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.610]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.610]         }
[17:03:36.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.610]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.610]             base::names(...future.oldOptions))
[17:03:36.610]     }
[17:03:36.610]     if (FALSE) {
[17:03:36.610]     }
[17:03:36.610]     else {
[17:03:36.610]         if (TRUE) {
[17:03:36.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.610]                 open = "w")
[17:03:36.610]         }
[17:03:36.610]         else {
[17:03:36.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.610]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.610]         }
[17:03:36.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.610]             base::sink(type = "output", split = FALSE)
[17:03:36.610]             base::close(...future.stdout)
[17:03:36.610]         }, add = TRUE)
[17:03:36.610]     }
[17:03:36.610]     ...future.frame <- base::sys.nframe()
[17:03:36.610]     ...future.conditions <- base::list()
[17:03:36.610]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.610]     if (FALSE) {
[17:03:36.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.610]     }
[17:03:36.610]     ...future.result <- base::tryCatch({
[17:03:36.610]         base::withCallingHandlers({
[17:03:36.610]             ...future.value <- base::withVisible(base::local(1))
[17:03:36.610]             future::FutureResult(value = ...future.value$value, 
[17:03:36.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.610]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.610]                     ...future.globalenv.names))
[17:03:36.610]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.610]         }, condition = base::local({
[17:03:36.610]             c <- base::c
[17:03:36.610]             inherits <- base::inherits
[17:03:36.610]             invokeRestart <- base::invokeRestart
[17:03:36.610]             length <- base::length
[17:03:36.610]             list <- base::list
[17:03:36.610]             seq.int <- base::seq.int
[17:03:36.610]             signalCondition <- base::signalCondition
[17:03:36.610]             sys.calls <- base::sys.calls
[17:03:36.610]             `[[` <- base::`[[`
[17:03:36.610]             `+` <- base::`+`
[17:03:36.610]             `<<-` <- base::`<<-`
[17:03:36.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.610]                   3L)]
[17:03:36.610]             }
[17:03:36.610]             function(cond) {
[17:03:36.610]                 is_error <- inherits(cond, "error")
[17:03:36.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.610]                   NULL)
[17:03:36.610]                 if (is_error) {
[17:03:36.610]                   sessionInformation <- function() {
[17:03:36.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.610]                       search = base::search(), system = base::Sys.info())
[17:03:36.610]                   }
[17:03:36.610]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.610]                     cond$call), session = sessionInformation(), 
[17:03:36.610]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.610]                   signalCondition(cond)
[17:03:36.610]                 }
[17:03:36.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.610]                 "immediateCondition"))) {
[17:03:36.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.610]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.610]                   if (TRUE && !signal) {
[17:03:36.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.610]                     {
[17:03:36.610]                       inherits <- base::inherits
[17:03:36.610]                       invokeRestart <- base::invokeRestart
[17:03:36.610]                       is.null <- base::is.null
[17:03:36.610]                       muffled <- FALSE
[17:03:36.610]                       if (inherits(cond, "message")) {
[17:03:36.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.610]                         if (muffled) 
[17:03:36.610]                           invokeRestart("muffleMessage")
[17:03:36.610]                       }
[17:03:36.610]                       else if (inherits(cond, "warning")) {
[17:03:36.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.610]                         if (muffled) 
[17:03:36.610]                           invokeRestart("muffleWarning")
[17:03:36.610]                       }
[17:03:36.610]                       else if (inherits(cond, "condition")) {
[17:03:36.610]                         if (!is.null(pattern)) {
[17:03:36.610]                           computeRestarts <- base::computeRestarts
[17:03:36.610]                           grepl <- base::grepl
[17:03:36.610]                           restarts <- computeRestarts(cond)
[17:03:36.610]                           for (restart in restarts) {
[17:03:36.610]                             name <- restart$name
[17:03:36.610]                             if (is.null(name)) 
[17:03:36.610]                               next
[17:03:36.610]                             if (!grepl(pattern, name)) 
[17:03:36.610]                               next
[17:03:36.610]                             invokeRestart(restart)
[17:03:36.610]                             muffled <- TRUE
[17:03:36.610]                             break
[17:03:36.610]                           }
[17:03:36.610]                         }
[17:03:36.610]                       }
[17:03:36.610]                       invisible(muffled)
[17:03:36.610]                     }
[17:03:36.610]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.610]                   }
[17:03:36.610]                 }
[17:03:36.610]                 else {
[17:03:36.610]                   if (TRUE) {
[17:03:36.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.610]                     {
[17:03:36.610]                       inherits <- base::inherits
[17:03:36.610]                       invokeRestart <- base::invokeRestart
[17:03:36.610]                       is.null <- base::is.null
[17:03:36.610]                       muffled <- FALSE
[17:03:36.610]                       if (inherits(cond, "message")) {
[17:03:36.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.610]                         if (muffled) 
[17:03:36.610]                           invokeRestart("muffleMessage")
[17:03:36.610]                       }
[17:03:36.610]                       else if (inherits(cond, "warning")) {
[17:03:36.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.610]                         if (muffled) 
[17:03:36.610]                           invokeRestart("muffleWarning")
[17:03:36.610]                       }
[17:03:36.610]                       else if (inherits(cond, "condition")) {
[17:03:36.610]                         if (!is.null(pattern)) {
[17:03:36.610]                           computeRestarts <- base::computeRestarts
[17:03:36.610]                           grepl <- base::grepl
[17:03:36.610]                           restarts <- computeRestarts(cond)
[17:03:36.610]                           for (restart in restarts) {
[17:03:36.610]                             name <- restart$name
[17:03:36.610]                             if (is.null(name)) 
[17:03:36.610]                               next
[17:03:36.610]                             if (!grepl(pattern, name)) 
[17:03:36.610]                               next
[17:03:36.610]                             invokeRestart(restart)
[17:03:36.610]                             muffled <- TRUE
[17:03:36.610]                             break
[17:03:36.610]                           }
[17:03:36.610]                         }
[17:03:36.610]                       }
[17:03:36.610]                       invisible(muffled)
[17:03:36.610]                     }
[17:03:36.610]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.610]                   }
[17:03:36.610]                 }
[17:03:36.610]             }
[17:03:36.610]         }))
[17:03:36.610]     }, error = function(ex) {
[17:03:36.610]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.610]                 ...future.rng), started = ...future.startTime, 
[17:03:36.610]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.610]             version = "1.8"), class = "FutureResult")
[17:03:36.610]     }, finally = {
[17:03:36.610]         if (!identical(...future.workdir, getwd())) 
[17:03:36.610]             setwd(...future.workdir)
[17:03:36.610]         {
[17:03:36.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.610]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.610]             }
[17:03:36.610]             base::options(...future.oldOptions)
[17:03:36.610]             if (.Platform$OS.type == "windows") {
[17:03:36.610]                 old_names <- names(...future.oldEnvVars)
[17:03:36.610]                 envs <- base::Sys.getenv()
[17:03:36.610]                 names <- names(envs)
[17:03:36.610]                 common <- intersect(names, old_names)
[17:03:36.610]                 added <- setdiff(names, old_names)
[17:03:36.610]                 removed <- setdiff(old_names, names)
[17:03:36.610]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.610]                   envs[common]]
[17:03:36.610]                 NAMES <- toupper(changed)
[17:03:36.610]                 args <- list()
[17:03:36.610]                 for (kk in seq_along(NAMES)) {
[17:03:36.610]                   name <- changed[[kk]]
[17:03:36.610]                   NAME <- NAMES[[kk]]
[17:03:36.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.610]                     next
[17:03:36.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.610]                 }
[17:03:36.610]                 NAMES <- toupper(added)
[17:03:36.610]                 for (kk in seq_along(NAMES)) {
[17:03:36.610]                   name <- added[[kk]]
[17:03:36.610]                   NAME <- NAMES[[kk]]
[17:03:36.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.610]                     next
[17:03:36.610]                   args[[name]] <- ""
[17:03:36.610]                 }
[17:03:36.610]                 NAMES <- toupper(removed)
[17:03:36.610]                 for (kk in seq_along(NAMES)) {
[17:03:36.610]                   name <- removed[[kk]]
[17:03:36.610]                   NAME <- NAMES[[kk]]
[17:03:36.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.610]                     next
[17:03:36.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.610]                 }
[17:03:36.610]                 if (length(args) > 0) 
[17:03:36.610]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.610]             }
[17:03:36.610]             else {
[17:03:36.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.610]             }
[17:03:36.610]             {
[17:03:36.610]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.610]                   0L) {
[17:03:36.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.610]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.610]                   base::options(opts)
[17:03:36.610]                 }
[17:03:36.610]                 {
[17:03:36.610]                   {
[17:03:36.610]                     NULL
[17:03:36.610]                     RNGkind("Mersenne-Twister")
[17:03:36.610]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.610]                       inherits = FALSE)
[17:03:36.610]                   }
[17:03:36.610]                   options(future.plan = NULL)
[17:03:36.610]                   if (is.na(NA_character_)) 
[17:03:36.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.610]                     .init = FALSE)
[17:03:36.610]                 }
[17:03:36.610]             }
[17:03:36.610]         }
[17:03:36.610]     })
[17:03:36.610]     if (TRUE) {
[17:03:36.610]         base::sink(type = "output", split = FALSE)
[17:03:36.610]         if (TRUE) {
[17:03:36.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.610]         }
[17:03:36.610]         else {
[17:03:36.610]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.610]         }
[17:03:36.610]         base::close(...future.stdout)
[17:03:36.610]         ...future.stdout <- NULL
[17:03:36.610]     }
[17:03:36.610]     ...future.result$conditions <- ...future.conditions
[17:03:36.610]     ...future.result$finished <- base::Sys.time()
[17:03:36.610]     ...future.result
[17:03:36.610] }
[17:03:36.611] plan(): Setting new future strategy stack:
[17:03:36.611] List of future strategies:
[17:03:36.611] 1. sequential:
[17:03:36.611]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.611]    - tweaked: FALSE
[17:03:36.611]    - call: NULL
[17:03:36.612] plan(): nbrOfWorkers() = 1
[17:03:36.613] plan(): Setting new future strategy stack:
[17:03:36.613] List of future strategies:
[17:03:36.613] 1. sequential:
[17:03:36.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.613]    - tweaked: FALSE
[17:03:36.613]    - call: plan(strategy)
[17:03:36.613] plan(): nbrOfWorkers() = 1
[17:03:36.613] SequentialFuture started (and completed)
[17:03:36.613] - Launch lazy future ... done
[17:03:36.614] run() for ‘SequentialFuture’ ... done
[17:03:36.614] getGlobalsAndPackages() ...
[17:03:36.614] Searching for globals...
[17:03:36.621] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:03:36.621] Searching for globals ... DONE
[17:03:36.621] Resolving globals: FALSE
[17:03:36.621] 
[17:03:36.621] 
[17:03:36.621] getGlobalsAndPackages() ... DONE
[17:03:36.622] run() for ‘Future’ ...
[17:03:36.622] - state: ‘created’
[17:03:36.622] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:36.622] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:36.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:36.622]   - Field: ‘label’
[17:03:36.623]   - Field: ‘local’
[17:03:36.623]   - Field: ‘owner’
[17:03:36.623]   - Field: ‘envir’
[17:03:36.623]   - Field: ‘packages’
[17:03:36.623]   - Field: ‘gc’
[17:03:36.623]   - Field: ‘conditions’
[17:03:36.623]   - Field: ‘expr’
[17:03:36.623]   - Field: ‘uuid’
[17:03:36.623]   - Field: ‘seed’
[17:03:36.623]   - Field: ‘version’
[17:03:36.623]   - Field: ‘result’
[17:03:36.624]   - Field: ‘asynchronous’
[17:03:36.624]   - Field: ‘calls’
[17:03:36.624]   - Field: ‘globals’
[17:03:36.624]   - Field: ‘stdout’
[17:03:36.624]   - Field: ‘earlySignal’
[17:03:36.624]   - Field: ‘lazy’
[17:03:36.624]   - Field: ‘state’
[17:03:36.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:36.624] - Launch lazy future ...
[17:03:36.624] Packages needed by the future expression (n = 0): <none>
[17:03:36.625] Packages needed by future strategies (n = 0): <none>
[17:03:36.625] {
[17:03:36.625]     {
[17:03:36.625]         {
[17:03:36.625]             ...future.startTime <- base::Sys.time()
[17:03:36.625]             {
[17:03:36.625]                 {
[17:03:36.625]                   {
[17:03:36.625]                     base::local({
[17:03:36.625]                       has_future <- base::requireNamespace("future", 
[17:03:36.625]                         quietly = TRUE)
[17:03:36.625]                       if (has_future) {
[17:03:36.625]                         ns <- base::getNamespace("future")
[17:03:36.625]                         version <- ns[[".package"]][["version"]]
[17:03:36.625]                         if (is.null(version)) 
[17:03:36.625]                           version <- utils::packageVersion("future")
[17:03:36.625]                       }
[17:03:36.625]                       else {
[17:03:36.625]                         version <- NULL
[17:03:36.625]                       }
[17:03:36.625]                       if (!has_future || version < "1.8.0") {
[17:03:36.625]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:36.625]                           "", base::R.version$version.string), 
[17:03:36.625]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:36.625]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:36.625]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:36.625]                             "release", "version")], collapse = " "), 
[17:03:36.625]                           hostname = base::Sys.info()[["nodename"]])
[17:03:36.625]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:36.625]                           info)
[17:03:36.625]                         info <- base::paste(info, collapse = "; ")
[17:03:36.625]                         if (!has_future) {
[17:03:36.625]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:36.625]                             info)
[17:03:36.625]                         }
[17:03:36.625]                         else {
[17:03:36.625]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:36.625]                             info, version)
[17:03:36.625]                         }
[17:03:36.625]                         base::stop(msg)
[17:03:36.625]                       }
[17:03:36.625]                     })
[17:03:36.625]                   }
[17:03:36.625]                   ...future.strategy.old <- future::plan("list")
[17:03:36.625]                   options(future.plan = NULL)
[17:03:36.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:36.625]                 }
[17:03:36.625]                 ...future.workdir <- getwd()
[17:03:36.625]             }
[17:03:36.625]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:36.625]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:36.625]         }
[17:03:36.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:36.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:36.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:36.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:36.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:36.625]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:36.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:36.625]             base::names(...future.oldOptions))
[17:03:36.625]     }
[17:03:36.625]     if (FALSE) {
[17:03:36.625]     }
[17:03:36.625]     else {
[17:03:36.625]         if (TRUE) {
[17:03:36.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:36.625]                 open = "w")
[17:03:36.625]         }
[17:03:36.625]         else {
[17:03:36.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:36.625]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:36.625]         }
[17:03:36.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:36.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:36.625]             base::sink(type = "output", split = FALSE)
[17:03:36.625]             base::close(...future.stdout)
[17:03:36.625]         }, add = TRUE)
[17:03:36.625]     }
[17:03:36.625]     ...future.frame <- base::sys.nframe()
[17:03:36.625]     ...future.conditions <- base::list()
[17:03:36.625]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:36.625]     if (FALSE) {
[17:03:36.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:36.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:36.625]     }
[17:03:36.625]     ...future.result <- base::tryCatch({
[17:03:36.625]         base::withCallingHandlers({
[17:03:36.625]             ...future.value <- base::withVisible(base::local({
[17:03:36.625]                 Sys.sleep(0.5)
[17:03:36.625]                 2
[17:03:36.625]             }))
[17:03:36.625]             future::FutureResult(value = ...future.value$value, 
[17:03:36.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.625]                   ...future.rng), globalenv = if (FALSE) 
[17:03:36.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:36.625]                     ...future.globalenv.names))
[17:03:36.625]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:36.625]         }, condition = base::local({
[17:03:36.625]             c <- base::c
[17:03:36.625]             inherits <- base::inherits
[17:03:36.625]             invokeRestart <- base::invokeRestart
[17:03:36.625]             length <- base::length
[17:03:36.625]             list <- base::list
[17:03:36.625]             seq.int <- base::seq.int
[17:03:36.625]             signalCondition <- base::signalCondition
[17:03:36.625]             sys.calls <- base::sys.calls
[17:03:36.625]             `[[` <- base::`[[`
[17:03:36.625]             `+` <- base::`+`
[17:03:36.625]             `<<-` <- base::`<<-`
[17:03:36.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:36.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:36.625]                   3L)]
[17:03:36.625]             }
[17:03:36.625]             function(cond) {
[17:03:36.625]                 is_error <- inherits(cond, "error")
[17:03:36.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:36.625]                   NULL)
[17:03:36.625]                 if (is_error) {
[17:03:36.625]                   sessionInformation <- function() {
[17:03:36.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:36.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:36.625]                       search = base::search(), system = base::Sys.info())
[17:03:36.625]                   }
[17:03:36.625]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:36.625]                     cond$call), session = sessionInformation(), 
[17:03:36.625]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:36.625]                   signalCondition(cond)
[17:03:36.625]                 }
[17:03:36.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:36.625]                 "immediateCondition"))) {
[17:03:36.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:36.625]                   ...future.conditions[[length(...future.conditions) + 
[17:03:36.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:36.625]                   if (TRUE && !signal) {
[17:03:36.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.625]                     {
[17:03:36.625]                       inherits <- base::inherits
[17:03:36.625]                       invokeRestart <- base::invokeRestart
[17:03:36.625]                       is.null <- base::is.null
[17:03:36.625]                       muffled <- FALSE
[17:03:36.625]                       if (inherits(cond, "message")) {
[17:03:36.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.625]                         if (muffled) 
[17:03:36.625]                           invokeRestart("muffleMessage")
[17:03:36.625]                       }
[17:03:36.625]                       else if (inherits(cond, "warning")) {
[17:03:36.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.625]                         if (muffled) 
[17:03:36.625]                           invokeRestart("muffleWarning")
[17:03:36.625]                       }
[17:03:36.625]                       else if (inherits(cond, "condition")) {
[17:03:36.625]                         if (!is.null(pattern)) {
[17:03:36.625]                           computeRestarts <- base::computeRestarts
[17:03:36.625]                           grepl <- base::grepl
[17:03:36.625]                           restarts <- computeRestarts(cond)
[17:03:36.625]                           for (restart in restarts) {
[17:03:36.625]                             name <- restart$name
[17:03:36.625]                             if (is.null(name)) 
[17:03:36.625]                               next
[17:03:36.625]                             if (!grepl(pattern, name)) 
[17:03:36.625]                               next
[17:03:36.625]                             invokeRestart(restart)
[17:03:36.625]                             muffled <- TRUE
[17:03:36.625]                             break
[17:03:36.625]                           }
[17:03:36.625]                         }
[17:03:36.625]                       }
[17:03:36.625]                       invisible(muffled)
[17:03:36.625]                     }
[17:03:36.625]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.625]                   }
[17:03:36.625]                 }
[17:03:36.625]                 else {
[17:03:36.625]                   if (TRUE) {
[17:03:36.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:36.625]                     {
[17:03:36.625]                       inherits <- base::inherits
[17:03:36.625]                       invokeRestart <- base::invokeRestart
[17:03:36.625]                       is.null <- base::is.null
[17:03:36.625]                       muffled <- FALSE
[17:03:36.625]                       if (inherits(cond, "message")) {
[17:03:36.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:36.625]                         if (muffled) 
[17:03:36.625]                           invokeRestart("muffleMessage")
[17:03:36.625]                       }
[17:03:36.625]                       else if (inherits(cond, "warning")) {
[17:03:36.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:36.625]                         if (muffled) 
[17:03:36.625]                           invokeRestart("muffleWarning")
[17:03:36.625]                       }
[17:03:36.625]                       else if (inherits(cond, "condition")) {
[17:03:36.625]                         if (!is.null(pattern)) {
[17:03:36.625]                           computeRestarts <- base::computeRestarts
[17:03:36.625]                           grepl <- base::grepl
[17:03:36.625]                           restarts <- computeRestarts(cond)
[17:03:36.625]                           for (restart in restarts) {
[17:03:36.625]                             name <- restart$name
[17:03:36.625]                             if (is.null(name)) 
[17:03:36.625]                               next
[17:03:36.625]                             if (!grepl(pattern, name)) 
[17:03:36.625]                               next
[17:03:36.625]                             invokeRestart(restart)
[17:03:36.625]                             muffled <- TRUE
[17:03:36.625]                             break
[17:03:36.625]                           }
[17:03:36.625]                         }
[17:03:36.625]                       }
[17:03:36.625]                       invisible(muffled)
[17:03:36.625]                     }
[17:03:36.625]                     muffleCondition(cond, pattern = "^muffle")
[17:03:36.625]                   }
[17:03:36.625]                 }
[17:03:36.625]             }
[17:03:36.625]         }))
[17:03:36.625]     }, error = function(ex) {
[17:03:36.625]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:36.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:36.625]                 ...future.rng), started = ...future.startTime, 
[17:03:36.625]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:36.625]             version = "1.8"), class = "FutureResult")
[17:03:36.625]     }, finally = {
[17:03:36.625]         if (!identical(...future.workdir, getwd())) 
[17:03:36.625]             setwd(...future.workdir)
[17:03:36.625]         {
[17:03:36.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:36.625]                 ...future.oldOptions$nwarnings <- NULL
[17:03:36.625]             }
[17:03:36.625]             base::options(...future.oldOptions)
[17:03:36.625]             if (.Platform$OS.type == "windows") {
[17:03:36.625]                 old_names <- names(...future.oldEnvVars)
[17:03:36.625]                 envs <- base::Sys.getenv()
[17:03:36.625]                 names <- names(envs)
[17:03:36.625]                 common <- intersect(names, old_names)
[17:03:36.625]                 added <- setdiff(names, old_names)
[17:03:36.625]                 removed <- setdiff(old_names, names)
[17:03:36.625]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:36.625]                   envs[common]]
[17:03:36.625]                 NAMES <- toupper(changed)
[17:03:36.625]                 args <- list()
[17:03:36.625]                 for (kk in seq_along(NAMES)) {
[17:03:36.625]                   name <- changed[[kk]]
[17:03:36.625]                   NAME <- NAMES[[kk]]
[17:03:36.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.625]                     next
[17:03:36.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.625]                 }
[17:03:36.625]                 NAMES <- toupper(added)
[17:03:36.625]                 for (kk in seq_along(NAMES)) {
[17:03:36.625]                   name <- added[[kk]]
[17:03:36.625]                   NAME <- NAMES[[kk]]
[17:03:36.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.625]                     next
[17:03:36.625]                   args[[name]] <- ""
[17:03:36.625]                 }
[17:03:36.625]                 NAMES <- toupper(removed)
[17:03:36.625]                 for (kk in seq_along(NAMES)) {
[17:03:36.625]                   name <- removed[[kk]]
[17:03:36.625]                   NAME <- NAMES[[kk]]
[17:03:36.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:36.625]                     next
[17:03:36.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:36.625]                 }
[17:03:36.625]                 if (length(args) > 0) 
[17:03:36.625]                   base::do.call(base::Sys.setenv, args = args)
[17:03:36.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:36.625]             }
[17:03:36.625]             else {
[17:03:36.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:36.625]             }
[17:03:36.625]             {
[17:03:36.625]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:36.625]                   0L) {
[17:03:36.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:36.625]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:36.625]                   base::options(opts)
[17:03:36.625]                 }
[17:03:36.625]                 {
[17:03:36.625]                   {
[17:03:36.625]                     NULL
[17:03:36.625]                     RNGkind("Mersenne-Twister")
[17:03:36.625]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:36.625]                       inherits = FALSE)
[17:03:36.625]                   }
[17:03:36.625]                   options(future.plan = NULL)
[17:03:36.625]                   if (is.na(NA_character_)) 
[17:03:36.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:36.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:36.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:36.625]                     .init = FALSE)
[17:03:36.625]                 }
[17:03:36.625]             }
[17:03:36.625]         }
[17:03:36.625]     })
[17:03:36.625]     if (TRUE) {
[17:03:36.625]         base::sink(type = "output", split = FALSE)
[17:03:36.625]         if (TRUE) {
[17:03:36.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:36.625]         }
[17:03:36.625]         else {
[17:03:36.625]             ...future.result["stdout"] <- base::list(NULL)
[17:03:36.625]         }
[17:03:36.625]         base::close(...future.stdout)
[17:03:36.625]         ...future.stdout <- NULL
[17:03:36.625]     }
[17:03:36.625]     ...future.result$conditions <- ...future.conditions
[17:03:36.625]     ...future.result$finished <- base::Sys.time()
[17:03:36.625]     ...future.result
[17:03:36.625] }
[17:03:36.627] plan(): Setting new future strategy stack:
[17:03:36.627] List of future strategies:
[17:03:36.627] 1. sequential:
[17:03:36.627]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:36.627]    - tweaked: FALSE
[17:03:36.627]    - call: NULL
[17:03:36.627] plan(): nbrOfWorkers() = 1
[17:03:37.129] plan(): Setting new future strategy stack:
[17:03:37.129] List of future strategies:
[17:03:37.129] 1. sequential:
[17:03:37.129]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.129]    - tweaked: FALSE
[17:03:37.129]    - call: plan(strategy)
[17:03:37.130] plan(): nbrOfWorkers() = 1
[17:03:37.130] SequentialFuture started (and completed)
[17:03:37.130] - Launch lazy future ... done
[17:03:37.130] run() for ‘SequentialFuture’ ... done
[17:03:37.131] resolve() on list ...
[17:03:37.131]  recursive: 0
[17:03:37.131]  length: 1
[17:03:37.131] 
[17:03:37.131] resolved() for ‘SequentialFuture’ ...
[17:03:37.131] - state: ‘finished’
[17:03:37.131] - run: TRUE
[17:03:37.131] - result: ‘FutureResult’
[17:03:37.131] resolved() for ‘SequentialFuture’ ... done
[17:03:37.132] Future #1
[17:03:37.132]  length: 0 (resolved future 1)
[17:03:37.132] resolve() on list ... DONE
[17:03:37.132] resolved() for ‘SequentialFuture’ ...
[17:03:37.132] - state: ‘finished’
[17:03:37.132] - run: TRUE
[17:03:37.132] - result: ‘FutureResult’
[17:03:37.132] resolved() for ‘SequentialFuture’ ... done
[17:03:37.132] resolve() on list ...
[17:03:37.132]  recursive: 0
[17:03:37.133]  length: 1
[17:03:37.133] 
[17:03:37.133] resolved() for ‘SequentialFuture’ ...
[17:03:37.133] - state: ‘finished’
[17:03:37.133] - run: TRUE
[17:03:37.133] - result: ‘FutureResult’
[17:03:37.133] resolved() for ‘SequentialFuture’ ... done
[17:03:37.133] Future #1
[17:03:37.133]  length: 0 (resolved future 1)
[17:03:37.133] resolve() on list ... DONE
[17:03:37.133] resolved() for ‘SequentialFuture’ ...
[17:03:37.134] - state: ‘finished’
[17:03:37.134] - run: TRUE
[17:03:37.134] - result: ‘FutureResult’
[17:03:37.134] resolved() for ‘SequentialFuture’ ... done
[17:03:37.134] resolve() on list ...
[17:03:37.134]  recursive: 0
[17:03:37.134]  length: 1
[17:03:37.134] 
[17:03:37.134]  length: 0 (resolved future 1)
[17:03:37.134] resolve() on list ... DONE
[17:03:37.135] resolve() on list ...
[17:03:37.135]  recursive: 0
[17:03:37.135]  length: 4
[17:03:37.135] 
[17:03:37.135] resolved() for ‘SequentialFuture’ ...
[17:03:37.135] - state: ‘finished’
[17:03:37.135] - run: TRUE
[17:03:37.135] - result: ‘FutureResult’
[17:03:37.135] resolved() for ‘SequentialFuture’ ... done
[17:03:37.135] Future #1
[17:03:37.135]  length: 3 (resolved future 1)
[17:03:37.136] resolved() for ‘SequentialFuture’ ...
[17:03:37.136] - state: ‘finished’
[17:03:37.136] - run: TRUE
[17:03:37.136] - result: ‘FutureResult’
[17:03:37.136] resolved() for ‘SequentialFuture’ ... done
[17:03:37.136] Future #2
[17:03:37.136]  length: 2 (resolved future 2)
[17:03:37.136]  length: 1 (resolved future 3)
[17:03:37.136]  length: 0 (resolved future 4)
[17:03:37.136] resolve() on list ... DONE
[17:03:37.137] resolve() on list ...
[17:03:37.137]  recursive: 0
[17:03:37.137]  length: 4
[17:03:37.137] 
[17:03:37.137] resolved() for ‘SequentialFuture’ ...
[17:03:37.137] - state: ‘finished’
[17:03:37.137] - run: TRUE
[17:03:37.137] - result: ‘FutureResult’
[17:03:37.137] resolved() for ‘SequentialFuture’ ... done
[17:03:37.137] Future #1
[17:03:37.137]  length: 3 (resolved future 1)
[17:03:37.138] resolved() for ‘SequentialFuture’ ...
[17:03:37.138] - state: ‘finished’
[17:03:37.138] - run: TRUE
[17:03:37.138] - result: ‘FutureResult’
[17:03:37.138] resolved() for ‘SequentialFuture’ ... done
[17:03:37.138] Future #2
[17:03:37.138]  length: 2 (resolved future 2)
[17:03:37.138]  length: 1 (resolved future 3)
[17:03:37.138]  length: 0 (resolved future 4)
[17:03:37.138] resolve() on list ... DONE
[17:03:37.139] resolve() on list ...
[17:03:37.139]  recursive: 0
[17:03:37.139]  length: 1
[17:03:37.139] 
[17:03:37.139]  length: 0 (resolved future 1)
[17:03:37.139] resolve() on list ... DONE
[17:03:37.139] getGlobalsAndPackages() ...
[17:03:37.139] Searching for globals...
[17:03:37.140] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:37.140] Searching for globals ... DONE
[17:03:37.141] Resolving globals: FALSE
[17:03:37.141] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:37.142] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:37.142] - globals: [1] ‘kk’
[17:03:37.142] 
[17:03:37.142] getGlobalsAndPackages() ... DONE
[17:03:37.142] run() for ‘Future’ ...
[17:03:37.142] - state: ‘created’
[17:03:37.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.143] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.143]   - Field: ‘label’
[17:03:37.143]   - Field: ‘local’
[17:03:37.143]   - Field: ‘owner’
[17:03:37.143]   - Field: ‘envir’
[17:03:37.143]   - Field: ‘packages’
[17:03:37.143]   - Field: ‘gc’
[17:03:37.144]   - Field: ‘conditions’
[17:03:37.144]   - Field: ‘expr’
[17:03:37.144]   - Field: ‘uuid’
[17:03:37.144]   - Field: ‘seed’
[17:03:37.144]   - Field: ‘version’
[17:03:37.144]   - Field: ‘result’
[17:03:37.144]   - Field: ‘asynchronous’
[17:03:37.144]   - Field: ‘calls’
[17:03:37.144]   - Field: ‘globals’
[17:03:37.144]   - Field: ‘stdout’
[17:03:37.144]   - Field: ‘earlySignal’
[17:03:37.145]   - Field: ‘lazy’
[17:03:37.145]   - Field: ‘state’
[17:03:37.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.145] - Launch lazy future ...
[17:03:37.145] Packages needed by the future expression (n = 0): <none>
[17:03:37.145] Packages needed by future strategies (n = 0): <none>
[17:03:37.146] {
[17:03:37.146]     {
[17:03:37.146]         {
[17:03:37.146]             ...future.startTime <- base::Sys.time()
[17:03:37.146]             {
[17:03:37.146]                 {
[17:03:37.146]                   {
[17:03:37.146]                     base::local({
[17:03:37.146]                       has_future <- base::requireNamespace("future", 
[17:03:37.146]                         quietly = TRUE)
[17:03:37.146]                       if (has_future) {
[17:03:37.146]                         ns <- base::getNamespace("future")
[17:03:37.146]                         version <- ns[[".package"]][["version"]]
[17:03:37.146]                         if (is.null(version)) 
[17:03:37.146]                           version <- utils::packageVersion("future")
[17:03:37.146]                       }
[17:03:37.146]                       else {
[17:03:37.146]                         version <- NULL
[17:03:37.146]                       }
[17:03:37.146]                       if (!has_future || version < "1.8.0") {
[17:03:37.146]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.146]                           "", base::R.version$version.string), 
[17:03:37.146]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.146]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.146]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.146]                             "release", "version")], collapse = " "), 
[17:03:37.146]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.146]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.146]                           info)
[17:03:37.146]                         info <- base::paste(info, collapse = "; ")
[17:03:37.146]                         if (!has_future) {
[17:03:37.146]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.146]                             info)
[17:03:37.146]                         }
[17:03:37.146]                         else {
[17:03:37.146]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.146]                             info, version)
[17:03:37.146]                         }
[17:03:37.146]                         base::stop(msg)
[17:03:37.146]                       }
[17:03:37.146]                     })
[17:03:37.146]                   }
[17:03:37.146]                   ...future.strategy.old <- future::plan("list")
[17:03:37.146]                   options(future.plan = NULL)
[17:03:37.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.146]                 }
[17:03:37.146]                 ...future.workdir <- getwd()
[17:03:37.146]             }
[17:03:37.146]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.146]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.146]         }
[17:03:37.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.146]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.146]             base::names(...future.oldOptions))
[17:03:37.146]     }
[17:03:37.146]     if (FALSE) {
[17:03:37.146]     }
[17:03:37.146]     else {
[17:03:37.146]         if (TRUE) {
[17:03:37.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.146]                 open = "w")
[17:03:37.146]         }
[17:03:37.146]         else {
[17:03:37.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.146]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.146]         }
[17:03:37.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.146]             base::sink(type = "output", split = FALSE)
[17:03:37.146]             base::close(...future.stdout)
[17:03:37.146]         }, add = TRUE)
[17:03:37.146]     }
[17:03:37.146]     ...future.frame <- base::sys.nframe()
[17:03:37.146]     ...future.conditions <- base::list()
[17:03:37.146]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.146]     if (FALSE) {
[17:03:37.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.146]     }
[17:03:37.146]     ...future.result <- base::tryCatch({
[17:03:37.146]         base::withCallingHandlers({
[17:03:37.146]             ...future.value <- base::withVisible(base::local({
[17:03:37.146]                 Sys.sleep(0.1)
[17:03:37.146]                 kk
[17:03:37.146]             }))
[17:03:37.146]             future::FutureResult(value = ...future.value$value, 
[17:03:37.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.146]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.146]                     ...future.globalenv.names))
[17:03:37.146]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.146]         }, condition = base::local({
[17:03:37.146]             c <- base::c
[17:03:37.146]             inherits <- base::inherits
[17:03:37.146]             invokeRestart <- base::invokeRestart
[17:03:37.146]             length <- base::length
[17:03:37.146]             list <- base::list
[17:03:37.146]             seq.int <- base::seq.int
[17:03:37.146]             signalCondition <- base::signalCondition
[17:03:37.146]             sys.calls <- base::sys.calls
[17:03:37.146]             `[[` <- base::`[[`
[17:03:37.146]             `+` <- base::`+`
[17:03:37.146]             `<<-` <- base::`<<-`
[17:03:37.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.146]                   3L)]
[17:03:37.146]             }
[17:03:37.146]             function(cond) {
[17:03:37.146]                 is_error <- inherits(cond, "error")
[17:03:37.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.146]                   NULL)
[17:03:37.146]                 if (is_error) {
[17:03:37.146]                   sessionInformation <- function() {
[17:03:37.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.146]                       search = base::search(), system = base::Sys.info())
[17:03:37.146]                   }
[17:03:37.146]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.146]                     cond$call), session = sessionInformation(), 
[17:03:37.146]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.146]                   signalCondition(cond)
[17:03:37.146]                 }
[17:03:37.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.146]                 "immediateCondition"))) {
[17:03:37.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.146]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.146]                   if (TRUE && !signal) {
[17:03:37.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.146]                     {
[17:03:37.146]                       inherits <- base::inherits
[17:03:37.146]                       invokeRestart <- base::invokeRestart
[17:03:37.146]                       is.null <- base::is.null
[17:03:37.146]                       muffled <- FALSE
[17:03:37.146]                       if (inherits(cond, "message")) {
[17:03:37.146]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.146]                         if (muffled) 
[17:03:37.146]                           invokeRestart("muffleMessage")
[17:03:37.146]                       }
[17:03:37.146]                       else if (inherits(cond, "warning")) {
[17:03:37.146]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.146]                         if (muffled) 
[17:03:37.146]                           invokeRestart("muffleWarning")
[17:03:37.146]                       }
[17:03:37.146]                       else if (inherits(cond, "condition")) {
[17:03:37.146]                         if (!is.null(pattern)) {
[17:03:37.146]                           computeRestarts <- base::computeRestarts
[17:03:37.146]                           grepl <- base::grepl
[17:03:37.146]                           restarts <- computeRestarts(cond)
[17:03:37.146]                           for (restart in restarts) {
[17:03:37.146]                             name <- restart$name
[17:03:37.146]                             if (is.null(name)) 
[17:03:37.146]                               next
[17:03:37.146]                             if (!grepl(pattern, name)) 
[17:03:37.146]                               next
[17:03:37.146]                             invokeRestart(restart)
[17:03:37.146]                             muffled <- TRUE
[17:03:37.146]                             break
[17:03:37.146]                           }
[17:03:37.146]                         }
[17:03:37.146]                       }
[17:03:37.146]                       invisible(muffled)
[17:03:37.146]                     }
[17:03:37.146]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.146]                   }
[17:03:37.146]                 }
[17:03:37.146]                 else {
[17:03:37.146]                   if (TRUE) {
[17:03:37.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.146]                     {
[17:03:37.146]                       inherits <- base::inherits
[17:03:37.146]                       invokeRestart <- base::invokeRestart
[17:03:37.146]                       is.null <- base::is.null
[17:03:37.146]                       muffled <- FALSE
[17:03:37.146]                       if (inherits(cond, "message")) {
[17:03:37.146]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.146]                         if (muffled) 
[17:03:37.146]                           invokeRestart("muffleMessage")
[17:03:37.146]                       }
[17:03:37.146]                       else if (inherits(cond, "warning")) {
[17:03:37.146]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.146]                         if (muffled) 
[17:03:37.146]                           invokeRestart("muffleWarning")
[17:03:37.146]                       }
[17:03:37.146]                       else if (inherits(cond, "condition")) {
[17:03:37.146]                         if (!is.null(pattern)) {
[17:03:37.146]                           computeRestarts <- base::computeRestarts
[17:03:37.146]                           grepl <- base::grepl
[17:03:37.146]                           restarts <- computeRestarts(cond)
[17:03:37.146]                           for (restart in restarts) {
[17:03:37.146]                             name <- restart$name
[17:03:37.146]                             if (is.null(name)) 
[17:03:37.146]                               next
[17:03:37.146]                             if (!grepl(pattern, name)) 
[17:03:37.146]                               next
[17:03:37.146]                             invokeRestart(restart)
[17:03:37.146]                             muffled <- TRUE
[17:03:37.146]                             break
[17:03:37.146]                           }
[17:03:37.146]                         }
[17:03:37.146]                       }
[17:03:37.146]                       invisible(muffled)
[17:03:37.146]                     }
[17:03:37.146]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.146]                   }
[17:03:37.146]                 }
[17:03:37.146]             }
[17:03:37.146]         }))
[17:03:37.146]     }, error = function(ex) {
[17:03:37.146]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.146]                 ...future.rng), started = ...future.startTime, 
[17:03:37.146]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.146]             version = "1.8"), class = "FutureResult")
[17:03:37.146]     }, finally = {
[17:03:37.146]         if (!identical(...future.workdir, getwd())) 
[17:03:37.146]             setwd(...future.workdir)
[17:03:37.146]         {
[17:03:37.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.146]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.146]             }
[17:03:37.146]             base::options(...future.oldOptions)
[17:03:37.146]             if (.Platform$OS.type == "windows") {
[17:03:37.146]                 old_names <- names(...future.oldEnvVars)
[17:03:37.146]                 envs <- base::Sys.getenv()
[17:03:37.146]                 names <- names(envs)
[17:03:37.146]                 common <- intersect(names, old_names)
[17:03:37.146]                 added <- setdiff(names, old_names)
[17:03:37.146]                 removed <- setdiff(old_names, names)
[17:03:37.146]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.146]                   envs[common]]
[17:03:37.146]                 NAMES <- toupper(changed)
[17:03:37.146]                 args <- list()
[17:03:37.146]                 for (kk in seq_along(NAMES)) {
[17:03:37.146]                   name <- changed[[kk]]
[17:03:37.146]                   NAME <- NAMES[[kk]]
[17:03:37.146]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.146]                     next
[17:03:37.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.146]                 }
[17:03:37.146]                 NAMES <- toupper(added)
[17:03:37.146]                 for (kk in seq_along(NAMES)) {
[17:03:37.146]                   name <- added[[kk]]
[17:03:37.146]                   NAME <- NAMES[[kk]]
[17:03:37.146]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.146]                     next
[17:03:37.146]                   args[[name]] <- ""
[17:03:37.146]                 }
[17:03:37.146]                 NAMES <- toupper(removed)
[17:03:37.146]                 for (kk in seq_along(NAMES)) {
[17:03:37.146]                   name <- removed[[kk]]
[17:03:37.146]                   NAME <- NAMES[[kk]]
[17:03:37.146]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.146]                     next
[17:03:37.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.146]                 }
[17:03:37.146]                 if (length(args) > 0) 
[17:03:37.146]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.146]             }
[17:03:37.146]             else {
[17:03:37.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.146]             }
[17:03:37.146]             {
[17:03:37.146]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.146]                   0L) {
[17:03:37.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.146]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.146]                   base::options(opts)
[17:03:37.146]                 }
[17:03:37.146]                 {
[17:03:37.146]                   {
[17:03:37.146]                     NULL
[17:03:37.146]                     RNGkind("Mersenne-Twister")
[17:03:37.146]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.146]                       inherits = FALSE)
[17:03:37.146]                   }
[17:03:37.146]                   options(future.plan = NULL)
[17:03:37.146]                   if (is.na(NA_character_)) 
[17:03:37.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.146]                     .init = FALSE)
[17:03:37.146]                 }
[17:03:37.146]             }
[17:03:37.146]         }
[17:03:37.146]     })
[17:03:37.146]     if (TRUE) {
[17:03:37.146]         base::sink(type = "output", split = FALSE)
[17:03:37.146]         if (TRUE) {
[17:03:37.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.146]         }
[17:03:37.146]         else {
[17:03:37.146]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.146]         }
[17:03:37.146]         base::close(...future.stdout)
[17:03:37.146]         ...future.stdout <- NULL
[17:03:37.146]     }
[17:03:37.146]     ...future.result$conditions <- ...future.conditions
[17:03:37.146]     ...future.result$finished <- base::Sys.time()
[17:03:37.146]     ...future.result
[17:03:37.146] }
[17:03:37.147] assign_globals() ...
[17:03:37.147] List of 1
[17:03:37.147]  $ kk: int 1
[17:03:37.147]  - attr(*, "where")=List of 1
[17:03:37.147]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:37.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:37.147]  - attr(*, "resolved")= logi FALSE
[17:03:37.147]  - attr(*, "total_size")= num 56
[17:03:37.147]  - attr(*, "already-done")= logi TRUE
[17:03:37.154] - copied ‘kk’ to environment
[17:03:37.155] assign_globals() ... done
[17:03:37.155] plan(): Setting new future strategy stack:
[17:03:37.155] List of future strategies:
[17:03:37.155] 1. sequential:
[17:03:37.155]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.155]    - tweaked: FALSE
[17:03:37.155]    - call: NULL
[17:03:37.155] plan(): nbrOfWorkers() = 1
[17:03:37.257] plan(): Setting new future strategy stack:
[17:03:37.257] List of future strategies:
[17:03:37.257] 1. sequential:
[17:03:37.257]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.257]    - tweaked: FALSE
[17:03:37.257]    - call: plan(strategy)
[17:03:37.257] plan(): nbrOfWorkers() = 1
[17:03:37.257] SequentialFuture started (and completed)
[17:03:37.258] - Launch lazy future ... done
[17:03:37.258] run() for ‘SequentialFuture’ ... done
[17:03:37.258] getGlobalsAndPackages() ...
[17:03:37.258] Searching for globals...
[17:03:37.259] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:37.259] Searching for globals ... DONE
[17:03:37.259] Resolving globals: FALSE
[17:03:37.260] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:37.260] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:37.260] - globals: [1] ‘kk’
[17:03:37.260] 
[17:03:37.260] getGlobalsAndPackages() ... DONE
[17:03:37.261] run() for ‘Future’ ...
[17:03:37.261] - state: ‘created’
[17:03:37.261] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.261] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.261]   - Field: ‘label’
[17:03:37.261]   - Field: ‘local’
[17:03:37.261]   - Field: ‘owner’
[17:03:37.262]   - Field: ‘envir’
[17:03:37.262]   - Field: ‘packages’
[17:03:37.262]   - Field: ‘gc’
[17:03:37.262]   - Field: ‘conditions’
[17:03:37.262]   - Field: ‘expr’
[17:03:37.262]   - Field: ‘uuid’
[17:03:37.262]   - Field: ‘seed’
[17:03:37.262]   - Field: ‘version’
[17:03:37.262]   - Field: ‘result’
[17:03:37.262]   - Field: ‘asynchronous’
[17:03:37.262]   - Field: ‘calls’
[17:03:37.263]   - Field: ‘globals’
[17:03:37.263]   - Field: ‘stdout’
[17:03:37.263]   - Field: ‘earlySignal’
[17:03:37.263]   - Field: ‘lazy’
[17:03:37.263]   - Field: ‘state’
[17:03:37.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.263] - Launch lazy future ...
[17:03:37.263] Packages needed by the future expression (n = 0): <none>
[17:03:37.263] Packages needed by future strategies (n = 0): <none>
[17:03:37.264] {
[17:03:37.264]     {
[17:03:37.264]         {
[17:03:37.264]             ...future.startTime <- base::Sys.time()
[17:03:37.264]             {
[17:03:37.264]                 {
[17:03:37.264]                   {
[17:03:37.264]                     base::local({
[17:03:37.264]                       has_future <- base::requireNamespace("future", 
[17:03:37.264]                         quietly = TRUE)
[17:03:37.264]                       if (has_future) {
[17:03:37.264]                         ns <- base::getNamespace("future")
[17:03:37.264]                         version <- ns[[".package"]][["version"]]
[17:03:37.264]                         if (is.null(version)) 
[17:03:37.264]                           version <- utils::packageVersion("future")
[17:03:37.264]                       }
[17:03:37.264]                       else {
[17:03:37.264]                         version <- NULL
[17:03:37.264]                       }
[17:03:37.264]                       if (!has_future || version < "1.8.0") {
[17:03:37.264]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.264]                           "", base::R.version$version.string), 
[17:03:37.264]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.264]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.264]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.264]                             "release", "version")], collapse = " "), 
[17:03:37.264]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.264]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.264]                           info)
[17:03:37.264]                         info <- base::paste(info, collapse = "; ")
[17:03:37.264]                         if (!has_future) {
[17:03:37.264]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.264]                             info)
[17:03:37.264]                         }
[17:03:37.264]                         else {
[17:03:37.264]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.264]                             info, version)
[17:03:37.264]                         }
[17:03:37.264]                         base::stop(msg)
[17:03:37.264]                       }
[17:03:37.264]                     })
[17:03:37.264]                   }
[17:03:37.264]                   ...future.strategy.old <- future::plan("list")
[17:03:37.264]                   options(future.plan = NULL)
[17:03:37.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.264]                 }
[17:03:37.264]                 ...future.workdir <- getwd()
[17:03:37.264]             }
[17:03:37.264]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.264]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.264]         }
[17:03:37.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.264]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.264]             base::names(...future.oldOptions))
[17:03:37.264]     }
[17:03:37.264]     if (FALSE) {
[17:03:37.264]     }
[17:03:37.264]     else {
[17:03:37.264]         if (TRUE) {
[17:03:37.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.264]                 open = "w")
[17:03:37.264]         }
[17:03:37.264]         else {
[17:03:37.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.264]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.264]         }
[17:03:37.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.264]             base::sink(type = "output", split = FALSE)
[17:03:37.264]             base::close(...future.stdout)
[17:03:37.264]         }, add = TRUE)
[17:03:37.264]     }
[17:03:37.264]     ...future.frame <- base::sys.nframe()
[17:03:37.264]     ...future.conditions <- base::list()
[17:03:37.264]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.264]     if (FALSE) {
[17:03:37.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.264]     }
[17:03:37.264]     ...future.result <- base::tryCatch({
[17:03:37.264]         base::withCallingHandlers({
[17:03:37.264]             ...future.value <- base::withVisible(base::local({
[17:03:37.264]                 Sys.sleep(0.1)
[17:03:37.264]                 kk
[17:03:37.264]             }))
[17:03:37.264]             future::FutureResult(value = ...future.value$value, 
[17:03:37.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.264]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.264]                     ...future.globalenv.names))
[17:03:37.264]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.264]         }, condition = base::local({
[17:03:37.264]             c <- base::c
[17:03:37.264]             inherits <- base::inherits
[17:03:37.264]             invokeRestart <- base::invokeRestart
[17:03:37.264]             length <- base::length
[17:03:37.264]             list <- base::list
[17:03:37.264]             seq.int <- base::seq.int
[17:03:37.264]             signalCondition <- base::signalCondition
[17:03:37.264]             sys.calls <- base::sys.calls
[17:03:37.264]             `[[` <- base::`[[`
[17:03:37.264]             `+` <- base::`+`
[17:03:37.264]             `<<-` <- base::`<<-`
[17:03:37.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.264]                   3L)]
[17:03:37.264]             }
[17:03:37.264]             function(cond) {
[17:03:37.264]                 is_error <- inherits(cond, "error")
[17:03:37.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.264]                   NULL)
[17:03:37.264]                 if (is_error) {
[17:03:37.264]                   sessionInformation <- function() {
[17:03:37.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.264]                       search = base::search(), system = base::Sys.info())
[17:03:37.264]                   }
[17:03:37.264]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.264]                     cond$call), session = sessionInformation(), 
[17:03:37.264]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.264]                   signalCondition(cond)
[17:03:37.264]                 }
[17:03:37.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.264]                 "immediateCondition"))) {
[17:03:37.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.264]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.264]                   if (TRUE && !signal) {
[17:03:37.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.264]                     {
[17:03:37.264]                       inherits <- base::inherits
[17:03:37.264]                       invokeRestart <- base::invokeRestart
[17:03:37.264]                       is.null <- base::is.null
[17:03:37.264]                       muffled <- FALSE
[17:03:37.264]                       if (inherits(cond, "message")) {
[17:03:37.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.264]                         if (muffled) 
[17:03:37.264]                           invokeRestart("muffleMessage")
[17:03:37.264]                       }
[17:03:37.264]                       else if (inherits(cond, "warning")) {
[17:03:37.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.264]                         if (muffled) 
[17:03:37.264]                           invokeRestart("muffleWarning")
[17:03:37.264]                       }
[17:03:37.264]                       else if (inherits(cond, "condition")) {
[17:03:37.264]                         if (!is.null(pattern)) {
[17:03:37.264]                           computeRestarts <- base::computeRestarts
[17:03:37.264]                           grepl <- base::grepl
[17:03:37.264]                           restarts <- computeRestarts(cond)
[17:03:37.264]                           for (restart in restarts) {
[17:03:37.264]                             name <- restart$name
[17:03:37.264]                             if (is.null(name)) 
[17:03:37.264]                               next
[17:03:37.264]                             if (!grepl(pattern, name)) 
[17:03:37.264]                               next
[17:03:37.264]                             invokeRestart(restart)
[17:03:37.264]                             muffled <- TRUE
[17:03:37.264]                             break
[17:03:37.264]                           }
[17:03:37.264]                         }
[17:03:37.264]                       }
[17:03:37.264]                       invisible(muffled)
[17:03:37.264]                     }
[17:03:37.264]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.264]                   }
[17:03:37.264]                 }
[17:03:37.264]                 else {
[17:03:37.264]                   if (TRUE) {
[17:03:37.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.264]                     {
[17:03:37.264]                       inherits <- base::inherits
[17:03:37.264]                       invokeRestart <- base::invokeRestart
[17:03:37.264]                       is.null <- base::is.null
[17:03:37.264]                       muffled <- FALSE
[17:03:37.264]                       if (inherits(cond, "message")) {
[17:03:37.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.264]                         if (muffled) 
[17:03:37.264]                           invokeRestart("muffleMessage")
[17:03:37.264]                       }
[17:03:37.264]                       else if (inherits(cond, "warning")) {
[17:03:37.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.264]                         if (muffled) 
[17:03:37.264]                           invokeRestart("muffleWarning")
[17:03:37.264]                       }
[17:03:37.264]                       else if (inherits(cond, "condition")) {
[17:03:37.264]                         if (!is.null(pattern)) {
[17:03:37.264]                           computeRestarts <- base::computeRestarts
[17:03:37.264]                           grepl <- base::grepl
[17:03:37.264]                           restarts <- computeRestarts(cond)
[17:03:37.264]                           for (restart in restarts) {
[17:03:37.264]                             name <- restart$name
[17:03:37.264]                             if (is.null(name)) 
[17:03:37.264]                               next
[17:03:37.264]                             if (!grepl(pattern, name)) 
[17:03:37.264]                               next
[17:03:37.264]                             invokeRestart(restart)
[17:03:37.264]                             muffled <- TRUE
[17:03:37.264]                             break
[17:03:37.264]                           }
[17:03:37.264]                         }
[17:03:37.264]                       }
[17:03:37.264]                       invisible(muffled)
[17:03:37.264]                     }
[17:03:37.264]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.264]                   }
[17:03:37.264]                 }
[17:03:37.264]             }
[17:03:37.264]         }))
[17:03:37.264]     }, error = function(ex) {
[17:03:37.264]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.264]                 ...future.rng), started = ...future.startTime, 
[17:03:37.264]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.264]             version = "1.8"), class = "FutureResult")
[17:03:37.264]     }, finally = {
[17:03:37.264]         if (!identical(...future.workdir, getwd())) 
[17:03:37.264]             setwd(...future.workdir)
[17:03:37.264]         {
[17:03:37.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.264]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.264]             }
[17:03:37.264]             base::options(...future.oldOptions)
[17:03:37.264]             if (.Platform$OS.type == "windows") {
[17:03:37.264]                 old_names <- names(...future.oldEnvVars)
[17:03:37.264]                 envs <- base::Sys.getenv()
[17:03:37.264]                 names <- names(envs)
[17:03:37.264]                 common <- intersect(names, old_names)
[17:03:37.264]                 added <- setdiff(names, old_names)
[17:03:37.264]                 removed <- setdiff(old_names, names)
[17:03:37.264]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.264]                   envs[common]]
[17:03:37.264]                 NAMES <- toupper(changed)
[17:03:37.264]                 args <- list()
[17:03:37.264]                 for (kk in seq_along(NAMES)) {
[17:03:37.264]                   name <- changed[[kk]]
[17:03:37.264]                   NAME <- NAMES[[kk]]
[17:03:37.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.264]                     next
[17:03:37.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.264]                 }
[17:03:37.264]                 NAMES <- toupper(added)
[17:03:37.264]                 for (kk in seq_along(NAMES)) {
[17:03:37.264]                   name <- added[[kk]]
[17:03:37.264]                   NAME <- NAMES[[kk]]
[17:03:37.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.264]                     next
[17:03:37.264]                   args[[name]] <- ""
[17:03:37.264]                 }
[17:03:37.264]                 NAMES <- toupper(removed)
[17:03:37.264]                 for (kk in seq_along(NAMES)) {
[17:03:37.264]                   name <- removed[[kk]]
[17:03:37.264]                   NAME <- NAMES[[kk]]
[17:03:37.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.264]                     next
[17:03:37.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.264]                 }
[17:03:37.264]                 if (length(args) > 0) 
[17:03:37.264]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.264]             }
[17:03:37.264]             else {
[17:03:37.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.264]             }
[17:03:37.264]             {
[17:03:37.264]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.264]                   0L) {
[17:03:37.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.264]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.264]                   base::options(opts)
[17:03:37.264]                 }
[17:03:37.264]                 {
[17:03:37.264]                   {
[17:03:37.264]                     NULL
[17:03:37.264]                     RNGkind("Mersenne-Twister")
[17:03:37.264]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.264]                       inherits = FALSE)
[17:03:37.264]                   }
[17:03:37.264]                   options(future.plan = NULL)
[17:03:37.264]                   if (is.na(NA_character_)) 
[17:03:37.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.264]                     .init = FALSE)
[17:03:37.264]                 }
[17:03:37.264]             }
[17:03:37.264]         }
[17:03:37.264]     })
[17:03:37.264]     if (TRUE) {
[17:03:37.264]         base::sink(type = "output", split = FALSE)
[17:03:37.264]         if (TRUE) {
[17:03:37.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.264]         }
[17:03:37.264]         else {
[17:03:37.264]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.264]         }
[17:03:37.264]         base::close(...future.stdout)
[17:03:37.264]         ...future.stdout <- NULL
[17:03:37.264]     }
[17:03:37.264]     ...future.result$conditions <- ...future.conditions
[17:03:37.264]     ...future.result$finished <- base::Sys.time()
[17:03:37.264]     ...future.result
[17:03:37.264] }
[17:03:37.265] assign_globals() ...
[17:03:37.266] List of 1
[17:03:37.266]  $ kk: int 2
[17:03:37.266]  - attr(*, "where")=List of 1
[17:03:37.266]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:37.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:37.266]  - attr(*, "resolved")= logi FALSE
[17:03:37.266]  - attr(*, "total_size")= num 56
[17:03:37.266]  - attr(*, "already-done")= logi TRUE
[17:03:37.268] - copied ‘kk’ to environment
[17:03:37.268] assign_globals() ... done
[17:03:37.268] plan(): Setting new future strategy stack:
[17:03:37.268] List of future strategies:
[17:03:37.268] 1. sequential:
[17:03:37.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.268]    - tweaked: FALSE
[17:03:37.268]    - call: NULL
[17:03:37.269] plan(): nbrOfWorkers() = 1
[17:03:37.370] plan(): Setting new future strategy stack:
[17:03:37.370] List of future strategies:
[17:03:37.370] 1. sequential:
[17:03:37.370]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.370]    - tweaked: FALSE
[17:03:37.370]    - call: plan(strategy)
[17:03:37.371] plan(): nbrOfWorkers() = 1
[17:03:37.371] SequentialFuture started (and completed)
[17:03:37.371] - Launch lazy future ... done
[17:03:37.371] run() for ‘SequentialFuture’ ... done
[17:03:37.371] getGlobalsAndPackages() ...
[17:03:37.371] Searching for globals...
[17:03:37.373] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:37.373] Searching for globals ... DONE
[17:03:37.373] Resolving globals: FALSE
[17:03:37.373] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:37.373] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:37.374] - globals: [1] ‘kk’
[17:03:37.374] 
[17:03:37.374] getGlobalsAndPackages() ... DONE
[17:03:37.374] run() for ‘Future’ ...
[17:03:37.374] - state: ‘created’
[17:03:37.374] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.375] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.375]   - Field: ‘label’
[17:03:37.375]   - Field: ‘local’
[17:03:37.375]   - Field: ‘owner’
[17:03:37.375]   - Field: ‘envir’
[17:03:37.375]   - Field: ‘packages’
[17:03:37.375]   - Field: ‘gc’
[17:03:37.375]   - Field: ‘conditions’
[17:03:37.375]   - Field: ‘expr’
[17:03:37.376]   - Field: ‘uuid’
[17:03:37.376]   - Field: ‘seed’
[17:03:37.376]   - Field: ‘version’
[17:03:37.376]   - Field: ‘result’
[17:03:37.376]   - Field: ‘asynchronous’
[17:03:37.376]   - Field: ‘calls’
[17:03:37.376]   - Field: ‘globals’
[17:03:37.376]   - Field: ‘stdout’
[17:03:37.376]   - Field: ‘earlySignal’
[17:03:37.376]   - Field: ‘lazy’
[17:03:37.376]   - Field: ‘state’
[17:03:37.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.377] - Launch lazy future ...
[17:03:37.377] Packages needed by the future expression (n = 0): <none>
[17:03:37.377] Packages needed by future strategies (n = 0): <none>
[17:03:37.377] {
[17:03:37.377]     {
[17:03:37.377]         {
[17:03:37.377]             ...future.startTime <- base::Sys.time()
[17:03:37.377]             {
[17:03:37.377]                 {
[17:03:37.377]                   {
[17:03:37.377]                     base::local({
[17:03:37.377]                       has_future <- base::requireNamespace("future", 
[17:03:37.377]                         quietly = TRUE)
[17:03:37.377]                       if (has_future) {
[17:03:37.377]                         ns <- base::getNamespace("future")
[17:03:37.377]                         version <- ns[[".package"]][["version"]]
[17:03:37.377]                         if (is.null(version)) 
[17:03:37.377]                           version <- utils::packageVersion("future")
[17:03:37.377]                       }
[17:03:37.377]                       else {
[17:03:37.377]                         version <- NULL
[17:03:37.377]                       }
[17:03:37.377]                       if (!has_future || version < "1.8.0") {
[17:03:37.377]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.377]                           "", base::R.version$version.string), 
[17:03:37.377]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.377]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.377]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.377]                             "release", "version")], collapse = " "), 
[17:03:37.377]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.377]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.377]                           info)
[17:03:37.377]                         info <- base::paste(info, collapse = "; ")
[17:03:37.377]                         if (!has_future) {
[17:03:37.377]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.377]                             info)
[17:03:37.377]                         }
[17:03:37.377]                         else {
[17:03:37.377]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.377]                             info, version)
[17:03:37.377]                         }
[17:03:37.377]                         base::stop(msg)
[17:03:37.377]                       }
[17:03:37.377]                     })
[17:03:37.377]                   }
[17:03:37.377]                   ...future.strategy.old <- future::plan("list")
[17:03:37.377]                   options(future.plan = NULL)
[17:03:37.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.377]                 }
[17:03:37.377]                 ...future.workdir <- getwd()
[17:03:37.377]             }
[17:03:37.377]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.377]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.377]         }
[17:03:37.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.377]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.377]             base::names(...future.oldOptions))
[17:03:37.377]     }
[17:03:37.377]     if (FALSE) {
[17:03:37.377]     }
[17:03:37.377]     else {
[17:03:37.377]         if (TRUE) {
[17:03:37.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.377]                 open = "w")
[17:03:37.377]         }
[17:03:37.377]         else {
[17:03:37.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.377]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.377]         }
[17:03:37.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.377]             base::sink(type = "output", split = FALSE)
[17:03:37.377]             base::close(...future.stdout)
[17:03:37.377]         }, add = TRUE)
[17:03:37.377]     }
[17:03:37.377]     ...future.frame <- base::sys.nframe()
[17:03:37.377]     ...future.conditions <- base::list()
[17:03:37.377]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.377]     if (FALSE) {
[17:03:37.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.377]     }
[17:03:37.377]     ...future.result <- base::tryCatch({
[17:03:37.377]         base::withCallingHandlers({
[17:03:37.377]             ...future.value <- base::withVisible(base::local({
[17:03:37.377]                 Sys.sleep(0.1)
[17:03:37.377]                 kk
[17:03:37.377]             }))
[17:03:37.377]             future::FutureResult(value = ...future.value$value, 
[17:03:37.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.377]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.377]                     ...future.globalenv.names))
[17:03:37.377]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.377]         }, condition = base::local({
[17:03:37.377]             c <- base::c
[17:03:37.377]             inherits <- base::inherits
[17:03:37.377]             invokeRestart <- base::invokeRestart
[17:03:37.377]             length <- base::length
[17:03:37.377]             list <- base::list
[17:03:37.377]             seq.int <- base::seq.int
[17:03:37.377]             signalCondition <- base::signalCondition
[17:03:37.377]             sys.calls <- base::sys.calls
[17:03:37.377]             `[[` <- base::`[[`
[17:03:37.377]             `+` <- base::`+`
[17:03:37.377]             `<<-` <- base::`<<-`
[17:03:37.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.377]                   3L)]
[17:03:37.377]             }
[17:03:37.377]             function(cond) {
[17:03:37.377]                 is_error <- inherits(cond, "error")
[17:03:37.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.377]                   NULL)
[17:03:37.377]                 if (is_error) {
[17:03:37.377]                   sessionInformation <- function() {
[17:03:37.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.377]                       search = base::search(), system = base::Sys.info())
[17:03:37.377]                   }
[17:03:37.377]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.377]                     cond$call), session = sessionInformation(), 
[17:03:37.377]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.377]                   signalCondition(cond)
[17:03:37.377]                 }
[17:03:37.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.377]                 "immediateCondition"))) {
[17:03:37.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.377]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.377]                   if (TRUE && !signal) {
[17:03:37.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.377]                     {
[17:03:37.377]                       inherits <- base::inherits
[17:03:37.377]                       invokeRestart <- base::invokeRestart
[17:03:37.377]                       is.null <- base::is.null
[17:03:37.377]                       muffled <- FALSE
[17:03:37.377]                       if (inherits(cond, "message")) {
[17:03:37.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.377]                         if (muffled) 
[17:03:37.377]                           invokeRestart("muffleMessage")
[17:03:37.377]                       }
[17:03:37.377]                       else if (inherits(cond, "warning")) {
[17:03:37.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.377]                         if (muffled) 
[17:03:37.377]                           invokeRestart("muffleWarning")
[17:03:37.377]                       }
[17:03:37.377]                       else if (inherits(cond, "condition")) {
[17:03:37.377]                         if (!is.null(pattern)) {
[17:03:37.377]                           computeRestarts <- base::computeRestarts
[17:03:37.377]                           grepl <- base::grepl
[17:03:37.377]                           restarts <- computeRestarts(cond)
[17:03:37.377]                           for (restart in restarts) {
[17:03:37.377]                             name <- restart$name
[17:03:37.377]                             if (is.null(name)) 
[17:03:37.377]                               next
[17:03:37.377]                             if (!grepl(pattern, name)) 
[17:03:37.377]                               next
[17:03:37.377]                             invokeRestart(restart)
[17:03:37.377]                             muffled <- TRUE
[17:03:37.377]                             break
[17:03:37.377]                           }
[17:03:37.377]                         }
[17:03:37.377]                       }
[17:03:37.377]                       invisible(muffled)
[17:03:37.377]                     }
[17:03:37.377]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.377]                   }
[17:03:37.377]                 }
[17:03:37.377]                 else {
[17:03:37.377]                   if (TRUE) {
[17:03:37.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.377]                     {
[17:03:37.377]                       inherits <- base::inherits
[17:03:37.377]                       invokeRestart <- base::invokeRestart
[17:03:37.377]                       is.null <- base::is.null
[17:03:37.377]                       muffled <- FALSE
[17:03:37.377]                       if (inherits(cond, "message")) {
[17:03:37.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.377]                         if (muffled) 
[17:03:37.377]                           invokeRestart("muffleMessage")
[17:03:37.377]                       }
[17:03:37.377]                       else if (inherits(cond, "warning")) {
[17:03:37.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.377]                         if (muffled) 
[17:03:37.377]                           invokeRestart("muffleWarning")
[17:03:37.377]                       }
[17:03:37.377]                       else if (inherits(cond, "condition")) {
[17:03:37.377]                         if (!is.null(pattern)) {
[17:03:37.377]                           computeRestarts <- base::computeRestarts
[17:03:37.377]                           grepl <- base::grepl
[17:03:37.377]                           restarts <- computeRestarts(cond)
[17:03:37.377]                           for (restart in restarts) {
[17:03:37.377]                             name <- restart$name
[17:03:37.377]                             if (is.null(name)) 
[17:03:37.377]                               next
[17:03:37.377]                             if (!grepl(pattern, name)) 
[17:03:37.377]                               next
[17:03:37.377]                             invokeRestart(restart)
[17:03:37.377]                             muffled <- TRUE
[17:03:37.377]                             break
[17:03:37.377]                           }
[17:03:37.377]                         }
[17:03:37.377]                       }
[17:03:37.377]                       invisible(muffled)
[17:03:37.377]                     }
[17:03:37.377]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.377]                   }
[17:03:37.377]                 }
[17:03:37.377]             }
[17:03:37.377]         }))
[17:03:37.377]     }, error = function(ex) {
[17:03:37.377]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.377]                 ...future.rng), started = ...future.startTime, 
[17:03:37.377]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.377]             version = "1.8"), class = "FutureResult")
[17:03:37.377]     }, finally = {
[17:03:37.377]         if (!identical(...future.workdir, getwd())) 
[17:03:37.377]             setwd(...future.workdir)
[17:03:37.377]         {
[17:03:37.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.377]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.377]             }
[17:03:37.377]             base::options(...future.oldOptions)
[17:03:37.377]             if (.Platform$OS.type == "windows") {
[17:03:37.377]                 old_names <- names(...future.oldEnvVars)
[17:03:37.377]                 envs <- base::Sys.getenv()
[17:03:37.377]                 names <- names(envs)
[17:03:37.377]                 common <- intersect(names, old_names)
[17:03:37.377]                 added <- setdiff(names, old_names)
[17:03:37.377]                 removed <- setdiff(old_names, names)
[17:03:37.377]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.377]                   envs[common]]
[17:03:37.377]                 NAMES <- toupper(changed)
[17:03:37.377]                 args <- list()
[17:03:37.377]                 for (kk in seq_along(NAMES)) {
[17:03:37.377]                   name <- changed[[kk]]
[17:03:37.377]                   NAME <- NAMES[[kk]]
[17:03:37.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.377]                     next
[17:03:37.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.377]                 }
[17:03:37.377]                 NAMES <- toupper(added)
[17:03:37.377]                 for (kk in seq_along(NAMES)) {
[17:03:37.377]                   name <- added[[kk]]
[17:03:37.377]                   NAME <- NAMES[[kk]]
[17:03:37.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.377]                     next
[17:03:37.377]                   args[[name]] <- ""
[17:03:37.377]                 }
[17:03:37.377]                 NAMES <- toupper(removed)
[17:03:37.377]                 for (kk in seq_along(NAMES)) {
[17:03:37.377]                   name <- removed[[kk]]
[17:03:37.377]                   NAME <- NAMES[[kk]]
[17:03:37.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.377]                     next
[17:03:37.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.377]                 }
[17:03:37.377]                 if (length(args) > 0) 
[17:03:37.377]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.377]             }
[17:03:37.377]             else {
[17:03:37.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.377]             }
[17:03:37.377]             {
[17:03:37.377]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.377]                   0L) {
[17:03:37.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.377]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.377]                   base::options(opts)
[17:03:37.377]                 }
[17:03:37.377]                 {
[17:03:37.377]                   {
[17:03:37.377]                     NULL
[17:03:37.377]                     RNGkind("Mersenne-Twister")
[17:03:37.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.377]                       inherits = FALSE)
[17:03:37.377]                   }
[17:03:37.377]                   options(future.plan = NULL)
[17:03:37.377]                   if (is.na(NA_character_)) 
[17:03:37.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.377]                     .init = FALSE)
[17:03:37.377]                 }
[17:03:37.377]             }
[17:03:37.377]         }
[17:03:37.377]     })
[17:03:37.377]     if (TRUE) {
[17:03:37.377]         base::sink(type = "output", split = FALSE)
[17:03:37.377]         if (TRUE) {
[17:03:37.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.377]         }
[17:03:37.377]         else {
[17:03:37.377]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.377]         }
[17:03:37.377]         base::close(...future.stdout)
[17:03:37.377]         ...future.stdout <- NULL
[17:03:37.377]     }
[17:03:37.377]     ...future.result$conditions <- ...future.conditions
[17:03:37.377]     ...future.result$finished <- base::Sys.time()
[17:03:37.377]     ...future.result
[17:03:37.377] }
[17:03:37.379] assign_globals() ...
[17:03:37.379] List of 1
[17:03:37.379]  $ kk: int 3
[17:03:37.379]  - attr(*, "where")=List of 1
[17:03:37.379]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:37.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:37.379]  - attr(*, "resolved")= logi FALSE
[17:03:37.379]  - attr(*, "total_size")= num 56
[17:03:37.379]  - attr(*, "already-done")= logi TRUE
[17:03:37.382] - copied ‘kk’ to environment
[17:03:37.382] assign_globals() ... done
[17:03:37.382] plan(): Setting new future strategy stack:
[17:03:37.382] List of future strategies:
[17:03:37.382] 1. sequential:
[17:03:37.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.382]    - tweaked: FALSE
[17:03:37.382]    - call: NULL
[17:03:37.382] plan(): nbrOfWorkers() = 1
[17:03:37.486] plan(): Setting new future strategy stack:
[17:03:37.486] List of future strategies:
[17:03:37.486] 1. sequential:
[17:03:37.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.486]    - tweaked: FALSE
[17:03:37.486]    - call: plan(strategy)
[17:03:37.486] plan(): nbrOfWorkers() = 1
[17:03:37.486] SequentialFuture started (and completed)
[17:03:37.487] - Launch lazy future ... done
[17:03:37.487] run() for ‘SequentialFuture’ ... done
[17:03:37.487] resolve() on list ...
[17:03:37.487]  recursive: 0
[17:03:37.487]  length: 3
[17:03:37.487] 
[17:03:37.487] resolved() for ‘SequentialFuture’ ...
[17:03:37.487] - state: ‘finished’
[17:03:37.487] - run: TRUE
[17:03:37.488] - result: ‘FutureResult’
[17:03:37.488] resolved() for ‘SequentialFuture’ ... done
[17:03:37.488] Future #1
[17:03:37.488]  length: 2 (resolved future 1)
[17:03:37.488] resolved() for ‘SequentialFuture’ ...
[17:03:37.488] - state: ‘finished’
[17:03:37.488] - run: TRUE
[17:03:37.488] - result: ‘FutureResult’
[17:03:37.488] resolved() for ‘SequentialFuture’ ... done
[17:03:37.488] Future #2
[17:03:37.488]  length: 1 (resolved future 2)
[17:03:37.489] resolved() for ‘SequentialFuture’ ...
[17:03:37.489] - state: ‘finished’
[17:03:37.489] - run: TRUE
[17:03:37.489] - result: ‘FutureResult’
[17:03:37.489] resolved() for ‘SequentialFuture’ ... done
[17:03:37.489] Future #3
[17:03:37.489]  length: 0 (resolved future 3)
[17:03:37.489] resolve() on list ... DONE
[17:03:37.489] getGlobalsAndPackages() ...
[17:03:37.489] Searching for globals...
[17:03:37.490] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:37.490] Searching for globals ... DONE
[17:03:37.491] Resolving globals: FALSE
[17:03:37.491] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:37.491] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:37.491] - globals: [1] ‘kk’
[17:03:37.492] 
[17:03:37.492] getGlobalsAndPackages() ... DONE
[17:03:37.492] getGlobalsAndPackages() ...
[17:03:37.492] Searching for globals...
[17:03:37.493] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:37.493] Searching for globals ... DONE
[17:03:37.493] Resolving globals: FALSE
[17:03:37.493] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:37.494] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:37.494] - globals: [1] ‘kk’
[17:03:37.494] 
[17:03:37.494] getGlobalsAndPackages() ... DONE
[17:03:37.494] getGlobalsAndPackages() ...
[17:03:37.494] Searching for globals...
[17:03:37.495] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:37.495] Searching for globals ... DONE
[17:03:37.495] Resolving globals: FALSE
[17:03:37.496] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:37.496] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:37.496] - globals: [1] ‘kk’
[17:03:37.496] 
[17:03:37.496] getGlobalsAndPackages() ... DONE
[17:03:37.497] resolve() on list ...
[17:03:37.497]  recursive: 0
[17:03:37.497]  length: 3
[17:03:37.497] 
[17:03:37.497] run() for ‘Future’ ...
[17:03:37.497] - state: ‘created’
[17:03:37.497] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.497] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.498]   - Field: ‘label’
[17:03:37.498]   - Field: ‘local’
[17:03:37.498]   - Field: ‘owner’
[17:03:37.498]   - Field: ‘envir’
[17:03:37.498]   - Field: ‘packages’
[17:03:37.498]   - Field: ‘gc’
[17:03:37.498]   - Field: ‘conditions’
[17:03:37.498]   - Field: ‘expr’
[17:03:37.498]   - Field: ‘uuid’
[17:03:37.498]   - Field: ‘seed’
[17:03:37.498]   - Field: ‘version’
[17:03:37.499]   - Field: ‘result’
[17:03:37.499]   - Field: ‘asynchronous’
[17:03:37.499]   - Field: ‘calls’
[17:03:37.499]   - Field: ‘globals’
[17:03:37.499]   - Field: ‘stdout’
[17:03:37.499]   - Field: ‘earlySignal’
[17:03:37.499]   - Field: ‘lazy’
[17:03:37.499]   - Field: ‘state’
[17:03:37.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.499] - Launch lazy future ...
[17:03:37.500] Packages needed by the future expression (n = 0): <none>
[17:03:37.500] Packages needed by future strategies (n = 0): <none>
[17:03:37.500] {
[17:03:37.500]     {
[17:03:37.500]         {
[17:03:37.500]             ...future.startTime <- base::Sys.time()
[17:03:37.500]             {
[17:03:37.500]                 {
[17:03:37.500]                   {
[17:03:37.500]                     base::local({
[17:03:37.500]                       has_future <- base::requireNamespace("future", 
[17:03:37.500]                         quietly = TRUE)
[17:03:37.500]                       if (has_future) {
[17:03:37.500]                         ns <- base::getNamespace("future")
[17:03:37.500]                         version <- ns[[".package"]][["version"]]
[17:03:37.500]                         if (is.null(version)) 
[17:03:37.500]                           version <- utils::packageVersion("future")
[17:03:37.500]                       }
[17:03:37.500]                       else {
[17:03:37.500]                         version <- NULL
[17:03:37.500]                       }
[17:03:37.500]                       if (!has_future || version < "1.8.0") {
[17:03:37.500]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.500]                           "", base::R.version$version.string), 
[17:03:37.500]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.500]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.500]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.500]                             "release", "version")], collapse = " "), 
[17:03:37.500]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.500]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.500]                           info)
[17:03:37.500]                         info <- base::paste(info, collapse = "; ")
[17:03:37.500]                         if (!has_future) {
[17:03:37.500]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.500]                             info)
[17:03:37.500]                         }
[17:03:37.500]                         else {
[17:03:37.500]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.500]                             info, version)
[17:03:37.500]                         }
[17:03:37.500]                         base::stop(msg)
[17:03:37.500]                       }
[17:03:37.500]                     })
[17:03:37.500]                   }
[17:03:37.500]                   ...future.strategy.old <- future::plan("list")
[17:03:37.500]                   options(future.plan = NULL)
[17:03:37.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.500]                 }
[17:03:37.500]                 ...future.workdir <- getwd()
[17:03:37.500]             }
[17:03:37.500]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.500]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.500]         }
[17:03:37.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.500]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.500]             base::names(...future.oldOptions))
[17:03:37.500]     }
[17:03:37.500]     if (FALSE) {
[17:03:37.500]     }
[17:03:37.500]     else {
[17:03:37.500]         if (TRUE) {
[17:03:37.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.500]                 open = "w")
[17:03:37.500]         }
[17:03:37.500]         else {
[17:03:37.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.500]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.500]         }
[17:03:37.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.500]             base::sink(type = "output", split = FALSE)
[17:03:37.500]             base::close(...future.stdout)
[17:03:37.500]         }, add = TRUE)
[17:03:37.500]     }
[17:03:37.500]     ...future.frame <- base::sys.nframe()
[17:03:37.500]     ...future.conditions <- base::list()
[17:03:37.500]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.500]     if (FALSE) {
[17:03:37.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.500]     }
[17:03:37.500]     ...future.result <- base::tryCatch({
[17:03:37.500]         base::withCallingHandlers({
[17:03:37.500]             ...future.value <- base::withVisible(base::local({
[17:03:37.500]                 Sys.sleep(0.1)
[17:03:37.500]                 kk
[17:03:37.500]             }))
[17:03:37.500]             future::FutureResult(value = ...future.value$value, 
[17:03:37.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.500]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.500]                     ...future.globalenv.names))
[17:03:37.500]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.500]         }, condition = base::local({
[17:03:37.500]             c <- base::c
[17:03:37.500]             inherits <- base::inherits
[17:03:37.500]             invokeRestart <- base::invokeRestart
[17:03:37.500]             length <- base::length
[17:03:37.500]             list <- base::list
[17:03:37.500]             seq.int <- base::seq.int
[17:03:37.500]             signalCondition <- base::signalCondition
[17:03:37.500]             sys.calls <- base::sys.calls
[17:03:37.500]             `[[` <- base::`[[`
[17:03:37.500]             `+` <- base::`+`
[17:03:37.500]             `<<-` <- base::`<<-`
[17:03:37.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.500]                   3L)]
[17:03:37.500]             }
[17:03:37.500]             function(cond) {
[17:03:37.500]                 is_error <- inherits(cond, "error")
[17:03:37.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.500]                   NULL)
[17:03:37.500]                 if (is_error) {
[17:03:37.500]                   sessionInformation <- function() {
[17:03:37.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.500]                       search = base::search(), system = base::Sys.info())
[17:03:37.500]                   }
[17:03:37.500]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.500]                     cond$call), session = sessionInformation(), 
[17:03:37.500]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.500]                   signalCondition(cond)
[17:03:37.500]                 }
[17:03:37.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.500]                 "immediateCondition"))) {
[17:03:37.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.500]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.500]                   if (TRUE && !signal) {
[17:03:37.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.500]                     {
[17:03:37.500]                       inherits <- base::inherits
[17:03:37.500]                       invokeRestart <- base::invokeRestart
[17:03:37.500]                       is.null <- base::is.null
[17:03:37.500]                       muffled <- FALSE
[17:03:37.500]                       if (inherits(cond, "message")) {
[17:03:37.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.500]                         if (muffled) 
[17:03:37.500]                           invokeRestart("muffleMessage")
[17:03:37.500]                       }
[17:03:37.500]                       else if (inherits(cond, "warning")) {
[17:03:37.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.500]                         if (muffled) 
[17:03:37.500]                           invokeRestart("muffleWarning")
[17:03:37.500]                       }
[17:03:37.500]                       else if (inherits(cond, "condition")) {
[17:03:37.500]                         if (!is.null(pattern)) {
[17:03:37.500]                           computeRestarts <- base::computeRestarts
[17:03:37.500]                           grepl <- base::grepl
[17:03:37.500]                           restarts <- computeRestarts(cond)
[17:03:37.500]                           for (restart in restarts) {
[17:03:37.500]                             name <- restart$name
[17:03:37.500]                             if (is.null(name)) 
[17:03:37.500]                               next
[17:03:37.500]                             if (!grepl(pattern, name)) 
[17:03:37.500]                               next
[17:03:37.500]                             invokeRestart(restart)
[17:03:37.500]                             muffled <- TRUE
[17:03:37.500]                             break
[17:03:37.500]                           }
[17:03:37.500]                         }
[17:03:37.500]                       }
[17:03:37.500]                       invisible(muffled)
[17:03:37.500]                     }
[17:03:37.500]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.500]                   }
[17:03:37.500]                 }
[17:03:37.500]                 else {
[17:03:37.500]                   if (TRUE) {
[17:03:37.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.500]                     {
[17:03:37.500]                       inherits <- base::inherits
[17:03:37.500]                       invokeRestart <- base::invokeRestart
[17:03:37.500]                       is.null <- base::is.null
[17:03:37.500]                       muffled <- FALSE
[17:03:37.500]                       if (inherits(cond, "message")) {
[17:03:37.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.500]                         if (muffled) 
[17:03:37.500]                           invokeRestart("muffleMessage")
[17:03:37.500]                       }
[17:03:37.500]                       else if (inherits(cond, "warning")) {
[17:03:37.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.500]                         if (muffled) 
[17:03:37.500]                           invokeRestart("muffleWarning")
[17:03:37.500]                       }
[17:03:37.500]                       else if (inherits(cond, "condition")) {
[17:03:37.500]                         if (!is.null(pattern)) {
[17:03:37.500]                           computeRestarts <- base::computeRestarts
[17:03:37.500]                           grepl <- base::grepl
[17:03:37.500]                           restarts <- computeRestarts(cond)
[17:03:37.500]                           for (restart in restarts) {
[17:03:37.500]                             name <- restart$name
[17:03:37.500]                             if (is.null(name)) 
[17:03:37.500]                               next
[17:03:37.500]                             if (!grepl(pattern, name)) 
[17:03:37.500]                               next
[17:03:37.500]                             invokeRestart(restart)
[17:03:37.500]                             muffled <- TRUE
[17:03:37.500]                             break
[17:03:37.500]                           }
[17:03:37.500]                         }
[17:03:37.500]                       }
[17:03:37.500]                       invisible(muffled)
[17:03:37.500]                     }
[17:03:37.500]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.500]                   }
[17:03:37.500]                 }
[17:03:37.500]             }
[17:03:37.500]         }))
[17:03:37.500]     }, error = function(ex) {
[17:03:37.500]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.500]                 ...future.rng), started = ...future.startTime, 
[17:03:37.500]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.500]             version = "1.8"), class = "FutureResult")
[17:03:37.500]     }, finally = {
[17:03:37.500]         if (!identical(...future.workdir, getwd())) 
[17:03:37.500]             setwd(...future.workdir)
[17:03:37.500]         {
[17:03:37.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.500]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.500]             }
[17:03:37.500]             base::options(...future.oldOptions)
[17:03:37.500]             if (.Platform$OS.type == "windows") {
[17:03:37.500]                 old_names <- names(...future.oldEnvVars)
[17:03:37.500]                 envs <- base::Sys.getenv()
[17:03:37.500]                 names <- names(envs)
[17:03:37.500]                 common <- intersect(names, old_names)
[17:03:37.500]                 added <- setdiff(names, old_names)
[17:03:37.500]                 removed <- setdiff(old_names, names)
[17:03:37.500]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.500]                   envs[common]]
[17:03:37.500]                 NAMES <- toupper(changed)
[17:03:37.500]                 args <- list()
[17:03:37.500]                 for (kk in seq_along(NAMES)) {
[17:03:37.500]                   name <- changed[[kk]]
[17:03:37.500]                   NAME <- NAMES[[kk]]
[17:03:37.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.500]                     next
[17:03:37.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.500]                 }
[17:03:37.500]                 NAMES <- toupper(added)
[17:03:37.500]                 for (kk in seq_along(NAMES)) {
[17:03:37.500]                   name <- added[[kk]]
[17:03:37.500]                   NAME <- NAMES[[kk]]
[17:03:37.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.500]                     next
[17:03:37.500]                   args[[name]] <- ""
[17:03:37.500]                 }
[17:03:37.500]                 NAMES <- toupper(removed)
[17:03:37.500]                 for (kk in seq_along(NAMES)) {
[17:03:37.500]                   name <- removed[[kk]]
[17:03:37.500]                   NAME <- NAMES[[kk]]
[17:03:37.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.500]                     next
[17:03:37.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.500]                 }
[17:03:37.500]                 if (length(args) > 0) 
[17:03:37.500]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.500]             }
[17:03:37.500]             else {
[17:03:37.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.500]             }
[17:03:37.500]             {
[17:03:37.500]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.500]                   0L) {
[17:03:37.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.500]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.500]                   base::options(opts)
[17:03:37.500]                 }
[17:03:37.500]                 {
[17:03:37.500]                   {
[17:03:37.500]                     NULL
[17:03:37.500]                     RNGkind("Mersenne-Twister")
[17:03:37.500]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.500]                       inherits = FALSE)
[17:03:37.500]                   }
[17:03:37.500]                   options(future.plan = NULL)
[17:03:37.500]                   if (is.na(NA_character_)) 
[17:03:37.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.500]                     .init = FALSE)
[17:03:37.500]                 }
[17:03:37.500]             }
[17:03:37.500]         }
[17:03:37.500]     })
[17:03:37.500]     if (TRUE) {
[17:03:37.500]         base::sink(type = "output", split = FALSE)
[17:03:37.500]         if (TRUE) {
[17:03:37.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.500]         }
[17:03:37.500]         else {
[17:03:37.500]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.500]         }
[17:03:37.500]         base::close(...future.stdout)
[17:03:37.500]         ...future.stdout <- NULL
[17:03:37.500]     }
[17:03:37.500]     ...future.result$conditions <- ...future.conditions
[17:03:37.500]     ...future.result$finished <- base::Sys.time()
[17:03:37.500]     ...future.result
[17:03:37.500] }
[17:03:37.502] assign_globals() ...
[17:03:37.502] List of 1
[17:03:37.502]  $ kk: int 1
[17:03:37.502]  - attr(*, "where")=List of 1
[17:03:37.502]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:37.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:37.502]  - attr(*, "resolved")= logi FALSE
[17:03:37.502]  - attr(*, "total_size")= num 56
[17:03:37.502]  - attr(*, "already-done")= logi TRUE
[17:03:37.504] - copied ‘kk’ to environment
[17:03:37.504] assign_globals() ... done
[17:03:37.505] plan(): Setting new future strategy stack:
[17:03:37.505] List of future strategies:
[17:03:37.505] 1. sequential:
[17:03:37.505]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.505]    - tweaked: FALSE
[17:03:37.505]    - call: NULL
[17:03:37.505] plan(): nbrOfWorkers() = 1
[17:03:37.606] plan(): Setting new future strategy stack:
[17:03:37.606] List of future strategies:
[17:03:37.606] 1. sequential:
[17:03:37.606]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.606]    - tweaked: FALSE
[17:03:37.606]    - call: plan(strategy)
[17:03:37.607] plan(): nbrOfWorkers() = 1
[17:03:37.607] SequentialFuture started (and completed)
[17:03:37.607] - Launch lazy future ... done
[17:03:37.607] run() for ‘SequentialFuture’ ... done
[17:03:37.608] resolved() for ‘SequentialFuture’ ...
[17:03:37.608] - state: ‘finished’
[17:03:37.608] - run: TRUE
[17:03:37.608] - result: ‘FutureResult’
[17:03:37.608] resolved() for ‘SequentialFuture’ ... done
[17:03:37.608] Future #1
[17:03:37.608]  length: 2 (resolved future 1)
[17:03:37.608] run() for ‘Future’ ...
[17:03:37.608] - state: ‘created’
[17:03:37.608] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.609] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.609]   - Field: ‘label’
[17:03:37.609]   - Field: ‘local’
[17:03:37.609]   - Field: ‘owner’
[17:03:37.609]   - Field: ‘envir’
[17:03:37.609]   - Field: ‘packages’
[17:03:37.609]   - Field: ‘gc’
[17:03:37.610]   - Field: ‘conditions’
[17:03:37.610]   - Field: ‘expr’
[17:03:37.610]   - Field: ‘uuid’
[17:03:37.610]   - Field: ‘seed’
[17:03:37.610]   - Field: ‘version’
[17:03:37.610]   - Field: ‘result’
[17:03:37.610]   - Field: ‘asynchronous’
[17:03:37.610]   - Field: ‘calls’
[17:03:37.610]   - Field: ‘globals’
[17:03:37.610]   - Field: ‘stdout’
[17:03:37.610]   - Field: ‘earlySignal’
[17:03:37.611]   - Field: ‘lazy’
[17:03:37.611]   - Field: ‘state’
[17:03:37.611] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.611] - Launch lazy future ...
[17:03:37.611] Packages needed by the future expression (n = 0): <none>
[17:03:37.611] Packages needed by future strategies (n = 0): <none>
[17:03:37.612] {
[17:03:37.612]     {
[17:03:37.612]         {
[17:03:37.612]             ...future.startTime <- base::Sys.time()
[17:03:37.612]             {
[17:03:37.612]                 {
[17:03:37.612]                   {
[17:03:37.612]                     base::local({
[17:03:37.612]                       has_future <- base::requireNamespace("future", 
[17:03:37.612]                         quietly = TRUE)
[17:03:37.612]                       if (has_future) {
[17:03:37.612]                         ns <- base::getNamespace("future")
[17:03:37.612]                         version <- ns[[".package"]][["version"]]
[17:03:37.612]                         if (is.null(version)) 
[17:03:37.612]                           version <- utils::packageVersion("future")
[17:03:37.612]                       }
[17:03:37.612]                       else {
[17:03:37.612]                         version <- NULL
[17:03:37.612]                       }
[17:03:37.612]                       if (!has_future || version < "1.8.0") {
[17:03:37.612]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.612]                           "", base::R.version$version.string), 
[17:03:37.612]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.612]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.612]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.612]                             "release", "version")], collapse = " "), 
[17:03:37.612]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.612]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.612]                           info)
[17:03:37.612]                         info <- base::paste(info, collapse = "; ")
[17:03:37.612]                         if (!has_future) {
[17:03:37.612]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.612]                             info)
[17:03:37.612]                         }
[17:03:37.612]                         else {
[17:03:37.612]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.612]                             info, version)
[17:03:37.612]                         }
[17:03:37.612]                         base::stop(msg)
[17:03:37.612]                       }
[17:03:37.612]                     })
[17:03:37.612]                   }
[17:03:37.612]                   ...future.strategy.old <- future::plan("list")
[17:03:37.612]                   options(future.plan = NULL)
[17:03:37.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.612]                 }
[17:03:37.612]                 ...future.workdir <- getwd()
[17:03:37.612]             }
[17:03:37.612]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.612]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.612]         }
[17:03:37.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.612]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.612]             base::names(...future.oldOptions))
[17:03:37.612]     }
[17:03:37.612]     if (FALSE) {
[17:03:37.612]     }
[17:03:37.612]     else {
[17:03:37.612]         if (TRUE) {
[17:03:37.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.612]                 open = "w")
[17:03:37.612]         }
[17:03:37.612]         else {
[17:03:37.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.612]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.612]         }
[17:03:37.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.612]             base::sink(type = "output", split = FALSE)
[17:03:37.612]             base::close(...future.stdout)
[17:03:37.612]         }, add = TRUE)
[17:03:37.612]     }
[17:03:37.612]     ...future.frame <- base::sys.nframe()
[17:03:37.612]     ...future.conditions <- base::list()
[17:03:37.612]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.612]     if (FALSE) {
[17:03:37.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.612]     }
[17:03:37.612]     ...future.result <- base::tryCatch({
[17:03:37.612]         base::withCallingHandlers({
[17:03:37.612]             ...future.value <- base::withVisible(base::local({
[17:03:37.612]                 Sys.sleep(0.1)
[17:03:37.612]                 kk
[17:03:37.612]             }))
[17:03:37.612]             future::FutureResult(value = ...future.value$value, 
[17:03:37.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.612]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.612]                     ...future.globalenv.names))
[17:03:37.612]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.612]         }, condition = base::local({
[17:03:37.612]             c <- base::c
[17:03:37.612]             inherits <- base::inherits
[17:03:37.612]             invokeRestart <- base::invokeRestart
[17:03:37.612]             length <- base::length
[17:03:37.612]             list <- base::list
[17:03:37.612]             seq.int <- base::seq.int
[17:03:37.612]             signalCondition <- base::signalCondition
[17:03:37.612]             sys.calls <- base::sys.calls
[17:03:37.612]             `[[` <- base::`[[`
[17:03:37.612]             `+` <- base::`+`
[17:03:37.612]             `<<-` <- base::`<<-`
[17:03:37.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.612]                   3L)]
[17:03:37.612]             }
[17:03:37.612]             function(cond) {
[17:03:37.612]                 is_error <- inherits(cond, "error")
[17:03:37.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.612]                   NULL)
[17:03:37.612]                 if (is_error) {
[17:03:37.612]                   sessionInformation <- function() {
[17:03:37.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.612]                       search = base::search(), system = base::Sys.info())
[17:03:37.612]                   }
[17:03:37.612]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.612]                     cond$call), session = sessionInformation(), 
[17:03:37.612]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.612]                   signalCondition(cond)
[17:03:37.612]                 }
[17:03:37.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.612]                 "immediateCondition"))) {
[17:03:37.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.612]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.612]                   if (TRUE && !signal) {
[17:03:37.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.612]                     {
[17:03:37.612]                       inherits <- base::inherits
[17:03:37.612]                       invokeRestart <- base::invokeRestart
[17:03:37.612]                       is.null <- base::is.null
[17:03:37.612]                       muffled <- FALSE
[17:03:37.612]                       if (inherits(cond, "message")) {
[17:03:37.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.612]                         if (muffled) 
[17:03:37.612]                           invokeRestart("muffleMessage")
[17:03:37.612]                       }
[17:03:37.612]                       else if (inherits(cond, "warning")) {
[17:03:37.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.612]                         if (muffled) 
[17:03:37.612]                           invokeRestart("muffleWarning")
[17:03:37.612]                       }
[17:03:37.612]                       else if (inherits(cond, "condition")) {
[17:03:37.612]                         if (!is.null(pattern)) {
[17:03:37.612]                           computeRestarts <- base::computeRestarts
[17:03:37.612]                           grepl <- base::grepl
[17:03:37.612]                           restarts <- computeRestarts(cond)
[17:03:37.612]                           for (restart in restarts) {
[17:03:37.612]                             name <- restart$name
[17:03:37.612]                             if (is.null(name)) 
[17:03:37.612]                               next
[17:03:37.612]                             if (!grepl(pattern, name)) 
[17:03:37.612]                               next
[17:03:37.612]                             invokeRestart(restart)
[17:03:37.612]                             muffled <- TRUE
[17:03:37.612]                             break
[17:03:37.612]                           }
[17:03:37.612]                         }
[17:03:37.612]                       }
[17:03:37.612]                       invisible(muffled)
[17:03:37.612]                     }
[17:03:37.612]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.612]                   }
[17:03:37.612]                 }
[17:03:37.612]                 else {
[17:03:37.612]                   if (TRUE) {
[17:03:37.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.612]                     {
[17:03:37.612]                       inherits <- base::inherits
[17:03:37.612]                       invokeRestart <- base::invokeRestart
[17:03:37.612]                       is.null <- base::is.null
[17:03:37.612]                       muffled <- FALSE
[17:03:37.612]                       if (inherits(cond, "message")) {
[17:03:37.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.612]                         if (muffled) 
[17:03:37.612]                           invokeRestart("muffleMessage")
[17:03:37.612]                       }
[17:03:37.612]                       else if (inherits(cond, "warning")) {
[17:03:37.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.612]                         if (muffled) 
[17:03:37.612]                           invokeRestart("muffleWarning")
[17:03:37.612]                       }
[17:03:37.612]                       else if (inherits(cond, "condition")) {
[17:03:37.612]                         if (!is.null(pattern)) {
[17:03:37.612]                           computeRestarts <- base::computeRestarts
[17:03:37.612]                           grepl <- base::grepl
[17:03:37.612]                           restarts <- computeRestarts(cond)
[17:03:37.612]                           for (restart in restarts) {
[17:03:37.612]                             name <- restart$name
[17:03:37.612]                             if (is.null(name)) 
[17:03:37.612]                               next
[17:03:37.612]                             if (!grepl(pattern, name)) 
[17:03:37.612]                               next
[17:03:37.612]                             invokeRestart(restart)
[17:03:37.612]                             muffled <- TRUE
[17:03:37.612]                             break
[17:03:37.612]                           }
[17:03:37.612]                         }
[17:03:37.612]                       }
[17:03:37.612]                       invisible(muffled)
[17:03:37.612]                     }
[17:03:37.612]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.612]                   }
[17:03:37.612]                 }
[17:03:37.612]             }
[17:03:37.612]         }))
[17:03:37.612]     }, error = function(ex) {
[17:03:37.612]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.612]                 ...future.rng), started = ...future.startTime, 
[17:03:37.612]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.612]             version = "1.8"), class = "FutureResult")
[17:03:37.612]     }, finally = {
[17:03:37.612]         if (!identical(...future.workdir, getwd())) 
[17:03:37.612]             setwd(...future.workdir)
[17:03:37.612]         {
[17:03:37.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.612]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.612]             }
[17:03:37.612]             base::options(...future.oldOptions)
[17:03:37.612]             if (.Platform$OS.type == "windows") {
[17:03:37.612]                 old_names <- names(...future.oldEnvVars)
[17:03:37.612]                 envs <- base::Sys.getenv()
[17:03:37.612]                 names <- names(envs)
[17:03:37.612]                 common <- intersect(names, old_names)
[17:03:37.612]                 added <- setdiff(names, old_names)
[17:03:37.612]                 removed <- setdiff(old_names, names)
[17:03:37.612]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.612]                   envs[common]]
[17:03:37.612]                 NAMES <- toupper(changed)
[17:03:37.612]                 args <- list()
[17:03:37.612]                 for (kk in seq_along(NAMES)) {
[17:03:37.612]                   name <- changed[[kk]]
[17:03:37.612]                   NAME <- NAMES[[kk]]
[17:03:37.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.612]                     next
[17:03:37.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.612]                 }
[17:03:37.612]                 NAMES <- toupper(added)
[17:03:37.612]                 for (kk in seq_along(NAMES)) {
[17:03:37.612]                   name <- added[[kk]]
[17:03:37.612]                   NAME <- NAMES[[kk]]
[17:03:37.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.612]                     next
[17:03:37.612]                   args[[name]] <- ""
[17:03:37.612]                 }
[17:03:37.612]                 NAMES <- toupper(removed)
[17:03:37.612]                 for (kk in seq_along(NAMES)) {
[17:03:37.612]                   name <- removed[[kk]]
[17:03:37.612]                   NAME <- NAMES[[kk]]
[17:03:37.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.612]                     next
[17:03:37.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.612]                 }
[17:03:37.612]                 if (length(args) > 0) 
[17:03:37.612]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.612]             }
[17:03:37.612]             else {
[17:03:37.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.612]             }
[17:03:37.612]             {
[17:03:37.612]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.612]                   0L) {
[17:03:37.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.612]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.612]                   base::options(opts)
[17:03:37.612]                 }
[17:03:37.612]                 {
[17:03:37.612]                   {
[17:03:37.612]                     NULL
[17:03:37.612]                     RNGkind("Mersenne-Twister")
[17:03:37.612]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.612]                       inherits = FALSE)
[17:03:37.612]                   }
[17:03:37.612]                   options(future.plan = NULL)
[17:03:37.612]                   if (is.na(NA_character_)) 
[17:03:37.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.612]                     .init = FALSE)
[17:03:37.612]                 }
[17:03:37.612]             }
[17:03:37.612]         }
[17:03:37.612]     })
[17:03:37.612]     if (TRUE) {
[17:03:37.612]         base::sink(type = "output", split = FALSE)
[17:03:37.612]         if (TRUE) {
[17:03:37.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.612]         }
[17:03:37.612]         else {
[17:03:37.612]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.612]         }
[17:03:37.612]         base::close(...future.stdout)
[17:03:37.612]         ...future.stdout <- NULL
[17:03:37.612]     }
[17:03:37.612]     ...future.result$conditions <- ...future.conditions
[17:03:37.612]     ...future.result$finished <- base::Sys.time()
[17:03:37.612]     ...future.result
[17:03:37.612] }
[17:03:37.613] assign_globals() ...
[17:03:37.613] List of 1
[17:03:37.613]  $ kk: int 2
[17:03:37.613]  - attr(*, "where")=List of 1
[17:03:37.613]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:37.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:37.613]  - attr(*, "resolved")= logi FALSE
[17:03:37.613]  - attr(*, "total_size")= num 56
[17:03:37.613]  - attr(*, "already-done")= logi TRUE
[17:03:37.618] - copied ‘kk’ to environment
[17:03:37.618] assign_globals() ... done
[17:03:37.618] plan(): Setting new future strategy stack:
[17:03:37.618] List of future strategies:
[17:03:37.618] 1. sequential:
[17:03:37.618]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.618]    - tweaked: FALSE
[17:03:37.618]    - call: NULL
[17:03:37.619] plan(): nbrOfWorkers() = 1
[17:03:37.720] plan(): Setting new future strategy stack:
[17:03:37.720] List of future strategies:
[17:03:37.720] 1. sequential:
[17:03:37.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.720]    - tweaked: FALSE
[17:03:37.720]    - call: plan(strategy)
[17:03:37.721] plan(): nbrOfWorkers() = 1
[17:03:37.721] SequentialFuture started (and completed)
[17:03:37.721] - Launch lazy future ... done
[17:03:37.721] run() for ‘SequentialFuture’ ... done
[17:03:37.721] resolved() for ‘SequentialFuture’ ...
[17:03:37.722] - state: ‘finished’
[17:03:37.722] - run: TRUE
[17:03:37.722] - result: ‘FutureResult’
[17:03:37.722] resolved() for ‘SequentialFuture’ ... done
[17:03:37.722] Future #2
[17:03:37.722]  length: 1 (resolved future 2)
[17:03:37.722] run() for ‘Future’ ...
[17:03:37.722] - state: ‘created’
[17:03:37.722] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.723] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.723] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.723]   - Field: ‘label’
[17:03:37.723]   - Field: ‘local’
[17:03:37.723]   - Field: ‘owner’
[17:03:37.723]   - Field: ‘envir’
[17:03:37.723]   - Field: ‘packages’
[17:03:37.723]   - Field: ‘gc’
[17:03:37.723]   - Field: ‘conditions’
[17:03:37.724]   - Field: ‘expr’
[17:03:37.724]   - Field: ‘uuid’
[17:03:37.724]   - Field: ‘seed’
[17:03:37.724]   - Field: ‘version’
[17:03:37.724]   - Field: ‘result’
[17:03:37.724]   - Field: ‘asynchronous’
[17:03:37.724]   - Field: ‘calls’
[17:03:37.724]   - Field: ‘globals’
[17:03:37.724]   - Field: ‘stdout’
[17:03:37.724]   - Field: ‘earlySignal’
[17:03:37.724]   - Field: ‘lazy’
[17:03:37.725]   - Field: ‘state’
[17:03:37.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.725] - Launch lazy future ...
[17:03:37.725] Packages needed by the future expression (n = 0): <none>
[17:03:37.725] Packages needed by future strategies (n = 0): <none>
[17:03:37.725] {
[17:03:37.725]     {
[17:03:37.725]         {
[17:03:37.725]             ...future.startTime <- base::Sys.time()
[17:03:37.725]             {
[17:03:37.725]                 {
[17:03:37.725]                   {
[17:03:37.725]                     base::local({
[17:03:37.725]                       has_future <- base::requireNamespace("future", 
[17:03:37.725]                         quietly = TRUE)
[17:03:37.725]                       if (has_future) {
[17:03:37.725]                         ns <- base::getNamespace("future")
[17:03:37.725]                         version <- ns[[".package"]][["version"]]
[17:03:37.725]                         if (is.null(version)) 
[17:03:37.725]                           version <- utils::packageVersion("future")
[17:03:37.725]                       }
[17:03:37.725]                       else {
[17:03:37.725]                         version <- NULL
[17:03:37.725]                       }
[17:03:37.725]                       if (!has_future || version < "1.8.0") {
[17:03:37.725]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.725]                           "", base::R.version$version.string), 
[17:03:37.725]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.725]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.725]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.725]                             "release", "version")], collapse = " "), 
[17:03:37.725]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.725]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.725]                           info)
[17:03:37.725]                         info <- base::paste(info, collapse = "; ")
[17:03:37.725]                         if (!has_future) {
[17:03:37.725]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.725]                             info)
[17:03:37.725]                         }
[17:03:37.725]                         else {
[17:03:37.725]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.725]                             info, version)
[17:03:37.725]                         }
[17:03:37.725]                         base::stop(msg)
[17:03:37.725]                       }
[17:03:37.725]                     })
[17:03:37.725]                   }
[17:03:37.725]                   ...future.strategy.old <- future::plan("list")
[17:03:37.725]                   options(future.plan = NULL)
[17:03:37.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.725]                 }
[17:03:37.725]                 ...future.workdir <- getwd()
[17:03:37.725]             }
[17:03:37.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.725]         }
[17:03:37.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.725]             base::names(...future.oldOptions))
[17:03:37.725]     }
[17:03:37.725]     if (FALSE) {
[17:03:37.725]     }
[17:03:37.725]     else {
[17:03:37.725]         if (TRUE) {
[17:03:37.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.725]                 open = "w")
[17:03:37.725]         }
[17:03:37.725]         else {
[17:03:37.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.725]         }
[17:03:37.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.725]             base::sink(type = "output", split = FALSE)
[17:03:37.725]             base::close(...future.stdout)
[17:03:37.725]         }, add = TRUE)
[17:03:37.725]     }
[17:03:37.725]     ...future.frame <- base::sys.nframe()
[17:03:37.725]     ...future.conditions <- base::list()
[17:03:37.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.725]     if (FALSE) {
[17:03:37.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.725]     }
[17:03:37.725]     ...future.result <- base::tryCatch({
[17:03:37.725]         base::withCallingHandlers({
[17:03:37.725]             ...future.value <- base::withVisible(base::local({
[17:03:37.725]                 Sys.sleep(0.1)
[17:03:37.725]                 kk
[17:03:37.725]             }))
[17:03:37.725]             future::FutureResult(value = ...future.value$value, 
[17:03:37.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.725]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.725]                     ...future.globalenv.names))
[17:03:37.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.725]         }, condition = base::local({
[17:03:37.725]             c <- base::c
[17:03:37.725]             inherits <- base::inherits
[17:03:37.725]             invokeRestart <- base::invokeRestart
[17:03:37.725]             length <- base::length
[17:03:37.725]             list <- base::list
[17:03:37.725]             seq.int <- base::seq.int
[17:03:37.725]             signalCondition <- base::signalCondition
[17:03:37.725]             sys.calls <- base::sys.calls
[17:03:37.725]             `[[` <- base::`[[`
[17:03:37.725]             `+` <- base::`+`
[17:03:37.725]             `<<-` <- base::`<<-`
[17:03:37.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.725]                   3L)]
[17:03:37.725]             }
[17:03:37.725]             function(cond) {
[17:03:37.725]                 is_error <- inherits(cond, "error")
[17:03:37.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.725]                   NULL)
[17:03:37.725]                 if (is_error) {
[17:03:37.725]                   sessionInformation <- function() {
[17:03:37.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.725]                       search = base::search(), system = base::Sys.info())
[17:03:37.725]                   }
[17:03:37.725]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.725]                     cond$call), session = sessionInformation(), 
[17:03:37.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.725]                   signalCondition(cond)
[17:03:37.725]                 }
[17:03:37.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.725]                 "immediateCondition"))) {
[17:03:37.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.725]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.725]                   if (TRUE && !signal) {
[17:03:37.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.725]                     {
[17:03:37.725]                       inherits <- base::inherits
[17:03:37.725]                       invokeRestart <- base::invokeRestart
[17:03:37.725]                       is.null <- base::is.null
[17:03:37.725]                       muffled <- FALSE
[17:03:37.725]                       if (inherits(cond, "message")) {
[17:03:37.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.725]                         if (muffled) 
[17:03:37.725]                           invokeRestart("muffleMessage")
[17:03:37.725]                       }
[17:03:37.725]                       else if (inherits(cond, "warning")) {
[17:03:37.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.725]                         if (muffled) 
[17:03:37.725]                           invokeRestart("muffleWarning")
[17:03:37.725]                       }
[17:03:37.725]                       else if (inherits(cond, "condition")) {
[17:03:37.725]                         if (!is.null(pattern)) {
[17:03:37.725]                           computeRestarts <- base::computeRestarts
[17:03:37.725]                           grepl <- base::grepl
[17:03:37.725]                           restarts <- computeRestarts(cond)
[17:03:37.725]                           for (restart in restarts) {
[17:03:37.725]                             name <- restart$name
[17:03:37.725]                             if (is.null(name)) 
[17:03:37.725]                               next
[17:03:37.725]                             if (!grepl(pattern, name)) 
[17:03:37.725]                               next
[17:03:37.725]                             invokeRestart(restart)
[17:03:37.725]                             muffled <- TRUE
[17:03:37.725]                             break
[17:03:37.725]                           }
[17:03:37.725]                         }
[17:03:37.725]                       }
[17:03:37.725]                       invisible(muffled)
[17:03:37.725]                     }
[17:03:37.725]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.725]                   }
[17:03:37.725]                 }
[17:03:37.725]                 else {
[17:03:37.725]                   if (TRUE) {
[17:03:37.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.725]                     {
[17:03:37.725]                       inherits <- base::inherits
[17:03:37.725]                       invokeRestart <- base::invokeRestart
[17:03:37.725]                       is.null <- base::is.null
[17:03:37.725]                       muffled <- FALSE
[17:03:37.725]                       if (inherits(cond, "message")) {
[17:03:37.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.725]                         if (muffled) 
[17:03:37.725]                           invokeRestart("muffleMessage")
[17:03:37.725]                       }
[17:03:37.725]                       else if (inherits(cond, "warning")) {
[17:03:37.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.725]                         if (muffled) 
[17:03:37.725]                           invokeRestart("muffleWarning")
[17:03:37.725]                       }
[17:03:37.725]                       else if (inherits(cond, "condition")) {
[17:03:37.725]                         if (!is.null(pattern)) {
[17:03:37.725]                           computeRestarts <- base::computeRestarts
[17:03:37.725]                           grepl <- base::grepl
[17:03:37.725]                           restarts <- computeRestarts(cond)
[17:03:37.725]                           for (restart in restarts) {
[17:03:37.725]                             name <- restart$name
[17:03:37.725]                             if (is.null(name)) 
[17:03:37.725]                               next
[17:03:37.725]                             if (!grepl(pattern, name)) 
[17:03:37.725]                               next
[17:03:37.725]                             invokeRestart(restart)
[17:03:37.725]                             muffled <- TRUE
[17:03:37.725]                             break
[17:03:37.725]                           }
[17:03:37.725]                         }
[17:03:37.725]                       }
[17:03:37.725]                       invisible(muffled)
[17:03:37.725]                     }
[17:03:37.725]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.725]                   }
[17:03:37.725]                 }
[17:03:37.725]             }
[17:03:37.725]         }))
[17:03:37.725]     }, error = function(ex) {
[17:03:37.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.725]                 ...future.rng), started = ...future.startTime, 
[17:03:37.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.725]             version = "1.8"), class = "FutureResult")
[17:03:37.725]     }, finally = {
[17:03:37.725]         if (!identical(...future.workdir, getwd())) 
[17:03:37.725]             setwd(...future.workdir)
[17:03:37.725]         {
[17:03:37.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.725]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.725]             }
[17:03:37.725]             base::options(...future.oldOptions)
[17:03:37.725]             if (.Platform$OS.type == "windows") {
[17:03:37.725]                 old_names <- names(...future.oldEnvVars)
[17:03:37.725]                 envs <- base::Sys.getenv()
[17:03:37.725]                 names <- names(envs)
[17:03:37.725]                 common <- intersect(names, old_names)
[17:03:37.725]                 added <- setdiff(names, old_names)
[17:03:37.725]                 removed <- setdiff(old_names, names)
[17:03:37.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.725]                   envs[common]]
[17:03:37.725]                 NAMES <- toupper(changed)
[17:03:37.725]                 args <- list()
[17:03:37.725]                 for (kk in seq_along(NAMES)) {
[17:03:37.725]                   name <- changed[[kk]]
[17:03:37.725]                   NAME <- NAMES[[kk]]
[17:03:37.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.725]                     next
[17:03:37.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.725]                 }
[17:03:37.725]                 NAMES <- toupper(added)
[17:03:37.725]                 for (kk in seq_along(NAMES)) {
[17:03:37.725]                   name <- added[[kk]]
[17:03:37.725]                   NAME <- NAMES[[kk]]
[17:03:37.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.725]                     next
[17:03:37.725]                   args[[name]] <- ""
[17:03:37.725]                 }
[17:03:37.725]                 NAMES <- toupper(removed)
[17:03:37.725]                 for (kk in seq_along(NAMES)) {
[17:03:37.725]                   name <- removed[[kk]]
[17:03:37.725]                   NAME <- NAMES[[kk]]
[17:03:37.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.725]                     next
[17:03:37.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.725]                 }
[17:03:37.725]                 if (length(args) > 0) 
[17:03:37.725]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.725]             }
[17:03:37.725]             else {
[17:03:37.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.725]             }
[17:03:37.725]             {
[17:03:37.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.725]                   0L) {
[17:03:37.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.725]                   base::options(opts)
[17:03:37.725]                 }
[17:03:37.725]                 {
[17:03:37.725]                   {
[17:03:37.725]                     NULL
[17:03:37.725]                     RNGkind("Mersenne-Twister")
[17:03:37.725]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.725]                       inherits = FALSE)
[17:03:37.725]                   }
[17:03:37.725]                   options(future.plan = NULL)
[17:03:37.725]                   if (is.na(NA_character_)) 
[17:03:37.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.725]                     .init = FALSE)
[17:03:37.725]                 }
[17:03:37.725]             }
[17:03:37.725]         }
[17:03:37.725]     })
[17:03:37.725]     if (TRUE) {
[17:03:37.725]         base::sink(type = "output", split = FALSE)
[17:03:37.725]         if (TRUE) {
[17:03:37.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.725]         }
[17:03:37.725]         else {
[17:03:37.725]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.725]         }
[17:03:37.725]         base::close(...future.stdout)
[17:03:37.725]         ...future.stdout <- NULL
[17:03:37.725]     }
[17:03:37.725]     ...future.result$conditions <- ...future.conditions
[17:03:37.725]     ...future.result$finished <- base::Sys.time()
[17:03:37.725]     ...future.result
[17:03:37.725] }
[17:03:37.727] assign_globals() ...
[17:03:37.727] List of 1
[17:03:37.727]  $ kk: int 3
[17:03:37.727]  - attr(*, "where")=List of 1
[17:03:37.727]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:37.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:37.727]  - attr(*, "resolved")= logi FALSE
[17:03:37.727]  - attr(*, "total_size")= num 56
[17:03:37.727]  - attr(*, "already-done")= logi TRUE
[17:03:37.730] - copied ‘kk’ to environment
[17:03:37.730] assign_globals() ... done
[17:03:37.730] plan(): Setting new future strategy stack:
[17:03:37.730] List of future strategies:
[17:03:37.730] 1. sequential:
[17:03:37.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.730]    - tweaked: FALSE
[17:03:37.730]    - call: NULL
[17:03:37.730] plan(): nbrOfWorkers() = 1
[17:03:37.832] plan(): Setting new future strategy stack:
[17:03:37.832] List of future strategies:
[17:03:37.832] 1. sequential:
[17:03:37.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.832]    - tweaked: FALSE
[17:03:37.832]    - call: plan(strategy)
[17:03:37.832] plan(): nbrOfWorkers() = 1
[17:03:37.833] SequentialFuture started (and completed)
[17:03:37.833] - Launch lazy future ... done
[17:03:37.833] run() for ‘SequentialFuture’ ... done
[17:03:37.833] resolved() for ‘SequentialFuture’ ...
[17:03:37.833] - state: ‘finished’
[17:03:37.833] - run: TRUE
[17:03:37.833] - result: ‘FutureResult’
[17:03:37.833] resolved() for ‘SequentialFuture’ ... done
[17:03:37.833] Future #3
[17:03:37.834]  length: 0 (resolved future 3)
[17:03:37.834] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:03:37.835] resolve() on environment ...
[17:03:37.835]  recursive: 0
[17:03:37.836]  elements: [2] ‘a’, ‘b’
[17:03:37.836]  length: 1 (resolved future 1)
[17:03:37.836]  length: 0 (resolved future 2)
[17:03:37.836] resolve() on environment ... DONE
[17:03:37.836] getGlobalsAndPackages() ...
[17:03:37.837] Searching for globals...
[17:03:37.837] 
[17:03:37.837] Searching for globals ... DONE
[17:03:37.837] - globals: [0] <none>
[17:03:37.837] getGlobalsAndPackages() ... DONE
[17:03:37.837] run() for ‘Future’ ...
[17:03:37.838] - state: ‘created’
[17:03:37.838] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.838] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.838]   - Field: ‘label’
[17:03:37.838]   - Field: ‘local’
[17:03:37.838]   - Field: ‘owner’
[17:03:37.838]   - Field: ‘envir’
[17:03:37.838]   - Field: ‘packages’
[17:03:37.839]   - Field: ‘gc’
[17:03:37.839]   - Field: ‘conditions’
[17:03:37.839]   - Field: ‘expr’
[17:03:37.839]   - Field: ‘uuid’
[17:03:37.839]   - Field: ‘seed’
[17:03:37.839]   - Field: ‘version’
[17:03:37.839]   - Field: ‘result’
[17:03:37.839]   - Field: ‘asynchronous’
[17:03:37.839]   - Field: ‘calls’
[17:03:37.839]   - Field: ‘globals’
[17:03:37.839]   - Field: ‘stdout’
[17:03:37.840]   - Field: ‘earlySignal’
[17:03:37.840]   - Field: ‘lazy’
[17:03:37.840]   - Field: ‘state’
[17:03:37.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.840] - Launch lazy future ...
[17:03:37.840] Packages needed by the future expression (n = 0): <none>
[17:03:37.840] Packages needed by future strategies (n = 0): <none>
[17:03:37.841] {
[17:03:37.841]     {
[17:03:37.841]         {
[17:03:37.841]             ...future.startTime <- base::Sys.time()
[17:03:37.841]             {
[17:03:37.841]                 {
[17:03:37.841]                   {
[17:03:37.841]                     base::local({
[17:03:37.841]                       has_future <- base::requireNamespace("future", 
[17:03:37.841]                         quietly = TRUE)
[17:03:37.841]                       if (has_future) {
[17:03:37.841]                         ns <- base::getNamespace("future")
[17:03:37.841]                         version <- ns[[".package"]][["version"]]
[17:03:37.841]                         if (is.null(version)) 
[17:03:37.841]                           version <- utils::packageVersion("future")
[17:03:37.841]                       }
[17:03:37.841]                       else {
[17:03:37.841]                         version <- NULL
[17:03:37.841]                       }
[17:03:37.841]                       if (!has_future || version < "1.8.0") {
[17:03:37.841]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.841]                           "", base::R.version$version.string), 
[17:03:37.841]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.841]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.841]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.841]                             "release", "version")], collapse = " "), 
[17:03:37.841]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.841]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.841]                           info)
[17:03:37.841]                         info <- base::paste(info, collapse = "; ")
[17:03:37.841]                         if (!has_future) {
[17:03:37.841]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.841]                             info)
[17:03:37.841]                         }
[17:03:37.841]                         else {
[17:03:37.841]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.841]                             info, version)
[17:03:37.841]                         }
[17:03:37.841]                         base::stop(msg)
[17:03:37.841]                       }
[17:03:37.841]                     })
[17:03:37.841]                   }
[17:03:37.841]                   ...future.strategy.old <- future::plan("list")
[17:03:37.841]                   options(future.plan = NULL)
[17:03:37.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.841]                 }
[17:03:37.841]                 ...future.workdir <- getwd()
[17:03:37.841]             }
[17:03:37.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.841]         }
[17:03:37.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.841]             base::names(...future.oldOptions))
[17:03:37.841]     }
[17:03:37.841]     if (FALSE) {
[17:03:37.841]     }
[17:03:37.841]     else {
[17:03:37.841]         if (TRUE) {
[17:03:37.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.841]                 open = "w")
[17:03:37.841]         }
[17:03:37.841]         else {
[17:03:37.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.841]         }
[17:03:37.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.841]             base::sink(type = "output", split = FALSE)
[17:03:37.841]             base::close(...future.stdout)
[17:03:37.841]         }, add = TRUE)
[17:03:37.841]     }
[17:03:37.841]     ...future.frame <- base::sys.nframe()
[17:03:37.841]     ...future.conditions <- base::list()
[17:03:37.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.841]     if (FALSE) {
[17:03:37.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.841]     }
[17:03:37.841]     ...future.result <- base::tryCatch({
[17:03:37.841]         base::withCallingHandlers({
[17:03:37.841]             ...future.value <- base::withVisible(base::local(1))
[17:03:37.841]             future::FutureResult(value = ...future.value$value, 
[17:03:37.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.841]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.841]                     ...future.globalenv.names))
[17:03:37.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.841]         }, condition = base::local({
[17:03:37.841]             c <- base::c
[17:03:37.841]             inherits <- base::inherits
[17:03:37.841]             invokeRestart <- base::invokeRestart
[17:03:37.841]             length <- base::length
[17:03:37.841]             list <- base::list
[17:03:37.841]             seq.int <- base::seq.int
[17:03:37.841]             signalCondition <- base::signalCondition
[17:03:37.841]             sys.calls <- base::sys.calls
[17:03:37.841]             `[[` <- base::`[[`
[17:03:37.841]             `+` <- base::`+`
[17:03:37.841]             `<<-` <- base::`<<-`
[17:03:37.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.841]                   3L)]
[17:03:37.841]             }
[17:03:37.841]             function(cond) {
[17:03:37.841]                 is_error <- inherits(cond, "error")
[17:03:37.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.841]                   NULL)
[17:03:37.841]                 if (is_error) {
[17:03:37.841]                   sessionInformation <- function() {
[17:03:37.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.841]                       search = base::search(), system = base::Sys.info())
[17:03:37.841]                   }
[17:03:37.841]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.841]                     cond$call), session = sessionInformation(), 
[17:03:37.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.841]                   signalCondition(cond)
[17:03:37.841]                 }
[17:03:37.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.841]                 "immediateCondition"))) {
[17:03:37.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.841]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.841]                   if (TRUE && !signal) {
[17:03:37.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.841]                     {
[17:03:37.841]                       inherits <- base::inherits
[17:03:37.841]                       invokeRestart <- base::invokeRestart
[17:03:37.841]                       is.null <- base::is.null
[17:03:37.841]                       muffled <- FALSE
[17:03:37.841]                       if (inherits(cond, "message")) {
[17:03:37.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.841]                         if (muffled) 
[17:03:37.841]                           invokeRestart("muffleMessage")
[17:03:37.841]                       }
[17:03:37.841]                       else if (inherits(cond, "warning")) {
[17:03:37.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.841]                         if (muffled) 
[17:03:37.841]                           invokeRestart("muffleWarning")
[17:03:37.841]                       }
[17:03:37.841]                       else if (inherits(cond, "condition")) {
[17:03:37.841]                         if (!is.null(pattern)) {
[17:03:37.841]                           computeRestarts <- base::computeRestarts
[17:03:37.841]                           grepl <- base::grepl
[17:03:37.841]                           restarts <- computeRestarts(cond)
[17:03:37.841]                           for (restart in restarts) {
[17:03:37.841]                             name <- restart$name
[17:03:37.841]                             if (is.null(name)) 
[17:03:37.841]                               next
[17:03:37.841]                             if (!grepl(pattern, name)) 
[17:03:37.841]                               next
[17:03:37.841]                             invokeRestart(restart)
[17:03:37.841]                             muffled <- TRUE
[17:03:37.841]                             break
[17:03:37.841]                           }
[17:03:37.841]                         }
[17:03:37.841]                       }
[17:03:37.841]                       invisible(muffled)
[17:03:37.841]                     }
[17:03:37.841]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.841]                   }
[17:03:37.841]                 }
[17:03:37.841]                 else {
[17:03:37.841]                   if (TRUE) {
[17:03:37.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.841]                     {
[17:03:37.841]                       inherits <- base::inherits
[17:03:37.841]                       invokeRestart <- base::invokeRestart
[17:03:37.841]                       is.null <- base::is.null
[17:03:37.841]                       muffled <- FALSE
[17:03:37.841]                       if (inherits(cond, "message")) {
[17:03:37.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.841]                         if (muffled) 
[17:03:37.841]                           invokeRestart("muffleMessage")
[17:03:37.841]                       }
[17:03:37.841]                       else if (inherits(cond, "warning")) {
[17:03:37.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.841]                         if (muffled) 
[17:03:37.841]                           invokeRestart("muffleWarning")
[17:03:37.841]                       }
[17:03:37.841]                       else if (inherits(cond, "condition")) {
[17:03:37.841]                         if (!is.null(pattern)) {
[17:03:37.841]                           computeRestarts <- base::computeRestarts
[17:03:37.841]                           grepl <- base::grepl
[17:03:37.841]                           restarts <- computeRestarts(cond)
[17:03:37.841]                           for (restart in restarts) {
[17:03:37.841]                             name <- restart$name
[17:03:37.841]                             if (is.null(name)) 
[17:03:37.841]                               next
[17:03:37.841]                             if (!grepl(pattern, name)) 
[17:03:37.841]                               next
[17:03:37.841]                             invokeRestart(restart)
[17:03:37.841]                             muffled <- TRUE
[17:03:37.841]                             break
[17:03:37.841]                           }
[17:03:37.841]                         }
[17:03:37.841]                       }
[17:03:37.841]                       invisible(muffled)
[17:03:37.841]                     }
[17:03:37.841]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.841]                   }
[17:03:37.841]                 }
[17:03:37.841]             }
[17:03:37.841]         }))
[17:03:37.841]     }, error = function(ex) {
[17:03:37.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.841]                 ...future.rng), started = ...future.startTime, 
[17:03:37.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.841]             version = "1.8"), class = "FutureResult")
[17:03:37.841]     }, finally = {
[17:03:37.841]         if (!identical(...future.workdir, getwd())) 
[17:03:37.841]             setwd(...future.workdir)
[17:03:37.841]         {
[17:03:37.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.841]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.841]             }
[17:03:37.841]             base::options(...future.oldOptions)
[17:03:37.841]             if (.Platform$OS.type == "windows") {
[17:03:37.841]                 old_names <- names(...future.oldEnvVars)
[17:03:37.841]                 envs <- base::Sys.getenv()
[17:03:37.841]                 names <- names(envs)
[17:03:37.841]                 common <- intersect(names, old_names)
[17:03:37.841]                 added <- setdiff(names, old_names)
[17:03:37.841]                 removed <- setdiff(old_names, names)
[17:03:37.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.841]                   envs[common]]
[17:03:37.841]                 NAMES <- toupper(changed)
[17:03:37.841]                 args <- list()
[17:03:37.841]                 for (kk in seq_along(NAMES)) {
[17:03:37.841]                   name <- changed[[kk]]
[17:03:37.841]                   NAME <- NAMES[[kk]]
[17:03:37.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.841]                     next
[17:03:37.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.841]                 }
[17:03:37.841]                 NAMES <- toupper(added)
[17:03:37.841]                 for (kk in seq_along(NAMES)) {
[17:03:37.841]                   name <- added[[kk]]
[17:03:37.841]                   NAME <- NAMES[[kk]]
[17:03:37.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.841]                     next
[17:03:37.841]                   args[[name]] <- ""
[17:03:37.841]                 }
[17:03:37.841]                 NAMES <- toupper(removed)
[17:03:37.841]                 for (kk in seq_along(NAMES)) {
[17:03:37.841]                   name <- removed[[kk]]
[17:03:37.841]                   NAME <- NAMES[[kk]]
[17:03:37.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.841]                     next
[17:03:37.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.841]                 }
[17:03:37.841]                 if (length(args) > 0) 
[17:03:37.841]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.841]             }
[17:03:37.841]             else {
[17:03:37.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.841]             }
[17:03:37.841]             {
[17:03:37.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.841]                   0L) {
[17:03:37.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.841]                   base::options(opts)
[17:03:37.841]                 }
[17:03:37.841]                 {
[17:03:37.841]                   {
[17:03:37.841]                     NULL
[17:03:37.841]                     RNGkind("Mersenne-Twister")
[17:03:37.841]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.841]                       inherits = FALSE)
[17:03:37.841]                   }
[17:03:37.841]                   options(future.plan = NULL)
[17:03:37.841]                   if (is.na(NA_character_)) 
[17:03:37.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.841]                     .init = FALSE)
[17:03:37.841]                 }
[17:03:37.841]             }
[17:03:37.841]         }
[17:03:37.841]     })
[17:03:37.841]     if (TRUE) {
[17:03:37.841]         base::sink(type = "output", split = FALSE)
[17:03:37.841]         if (TRUE) {
[17:03:37.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.841]         }
[17:03:37.841]         else {
[17:03:37.841]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.841]         }
[17:03:37.841]         base::close(...future.stdout)
[17:03:37.841]         ...future.stdout <- NULL
[17:03:37.841]     }
[17:03:37.841]     ...future.result$conditions <- ...future.conditions
[17:03:37.841]     ...future.result$finished <- base::Sys.time()
[17:03:37.841]     ...future.result
[17:03:37.841] }
[17:03:37.842] plan(): Setting new future strategy stack:
[17:03:37.843] List of future strategies:
[17:03:37.843] 1. sequential:
[17:03:37.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.843]    - tweaked: FALSE
[17:03:37.843]    - call: NULL
[17:03:37.843] plan(): nbrOfWorkers() = 1
[17:03:37.844] plan(): Setting new future strategy stack:
[17:03:37.844] List of future strategies:
[17:03:37.844] 1. sequential:
[17:03:37.844]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.844]    - tweaked: FALSE
[17:03:37.844]    - call: plan(strategy)
[17:03:37.844] plan(): nbrOfWorkers() = 1
[17:03:37.844] SequentialFuture started (and completed)
[17:03:37.845] - Launch lazy future ... done
[17:03:37.845] run() for ‘SequentialFuture’ ... done
[17:03:37.845] getGlobalsAndPackages() ...
[17:03:37.845] Searching for globals...
[17:03:37.845] 
[17:03:37.845] Searching for globals ... DONE
[17:03:37.845] - globals: [0] <none>
[17:03:37.845] getGlobalsAndPackages() ... DONE
[17:03:37.846] run() for ‘Future’ ...
[17:03:37.846] - state: ‘created’
[17:03:37.846] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.846] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.846] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.846]   - Field: ‘label’
[17:03:37.848]   - Field: ‘local’
[17:03:37.849]   - Field: ‘owner’
[17:03:37.849]   - Field: ‘envir’
[17:03:37.849]   - Field: ‘packages’
[17:03:37.849]   - Field: ‘gc’
[17:03:37.849]   - Field: ‘conditions’
[17:03:37.849]   - Field: ‘expr’
[17:03:37.849]   - Field: ‘uuid’
[17:03:37.849]   - Field: ‘seed’
[17:03:37.849]   - Field: ‘version’
[17:03:37.849]   - Field: ‘result’
[17:03:37.849]   - Field: ‘asynchronous’
[17:03:37.850]   - Field: ‘calls’
[17:03:37.850]   - Field: ‘globals’
[17:03:37.850]   - Field: ‘stdout’
[17:03:37.850]   - Field: ‘earlySignal’
[17:03:37.850]   - Field: ‘lazy’
[17:03:37.850]   - Field: ‘state’
[17:03:37.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.850] - Launch lazy future ...
[17:03:37.850] Packages needed by the future expression (n = 0): <none>
[17:03:37.851] Packages needed by future strategies (n = 0): <none>
[17:03:37.851] {
[17:03:37.851]     {
[17:03:37.851]         {
[17:03:37.851]             ...future.startTime <- base::Sys.time()
[17:03:37.851]             {
[17:03:37.851]                 {
[17:03:37.851]                   {
[17:03:37.851]                     base::local({
[17:03:37.851]                       has_future <- base::requireNamespace("future", 
[17:03:37.851]                         quietly = TRUE)
[17:03:37.851]                       if (has_future) {
[17:03:37.851]                         ns <- base::getNamespace("future")
[17:03:37.851]                         version <- ns[[".package"]][["version"]]
[17:03:37.851]                         if (is.null(version)) 
[17:03:37.851]                           version <- utils::packageVersion("future")
[17:03:37.851]                       }
[17:03:37.851]                       else {
[17:03:37.851]                         version <- NULL
[17:03:37.851]                       }
[17:03:37.851]                       if (!has_future || version < "1.8.0") {
[17:03:37.851]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.851]                           "", base::R.version$version.string), 
[17:03:37.851]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.851]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.851]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.851]                             "release", "version")], collapse = " "), 
[17:03:37.851]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.851]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.851]                           info)
[17:03:37.851]                         info <- base::paste(info, collapse = "; ")
[17:03:37.851]                         if (!has_future) {
[17:03:37.851]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.851]                             info)
[17:03:37.851]                         }
[17:03:37.851]                         else {
[17:03:37.851]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.851]                             info, version)
[17:03:37.851]                         }
[17:03:37.851]                         base::stop(msg)
[17:03:37.851]                       }
[17:03:37.851]                     })
[17:03:37.851]                   }
[17:03:37.851]                   ...future.strategy.old <- future::plan("list")
[17:03:37.851]                   options(future.plan = NULL)
[17:03:37.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.851]                 }
[17:03:37.851]                 ...future.workdir <- getwd()
[17:03:37.851]             }
[17:03:37.851]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.851]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.851]         }
[17:03:37.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.851]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.851]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.851]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.851]             base::names(...future.oldOptions))
[17:03:37.851]     }
[17:03:37.851]     if (FALSE) {
[17:03:37.851]     }
[17:03:37.851]     else {
[17:03:37.851]         if (TRUE) {
[17:03:37.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.851]                 open = "w")
[17:03:37.851]         }
[17:03:37.851]         else {
[17:03:37.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.851]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.851]         }
[17:03:37.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.851]             base::sink(type = "output", split = FALSE)
[17:03:37.851]             base::close(...future.stdout)
[17:03:37.851]         }, add = TRUE)
[17:03:37.851]     }
[17:03:37.851]     ...future.frame <- base::sys.nframe()
[17:03:37.851]     ...future.conditions <- base::list()
[17:03:37.851]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.851]     if (FALSE) {
[17:03:37.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.851]     }
[17:03:37.851]     ...future.result <- base::tryCatch({
[17:03:37.851]         base::withCallingHandlers({
[17:03:37.851]             ...future.value <- base::withVisible(base::local(2))
[17:03:37.851]             future::FutureResult(value = ...future.value$value, 
[17:03:37.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.851]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.851]                     ...future.globalenv.names))
[17:03:37.851]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.851]         }, condition = base::local({
[17:03:37.851]             c <- base::c
[17:03:37.851]             inherits <- base::inherits
[17:03:37.851]             invokeRestart <- base::invokeRestart
[17:03:37.851]             length <- base::length
[17:03:37.851]             list <- base::list
[17:03:37.851]             seq.int <- base::seq.int
[17:03:37.851]             signalCondition <- base::signalCondition
[17:03:37.851]             sys.calls <- base::sys.calls
[17:03:37.851]             `[[` <- base::`[[`
[17:03:37.851]             `+` <- base::`+`
[17:03:37.851]             `<<-` <- base::`<<-`
[17:03:37.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.851]                   3L)]
[17:03:37.851]             }
[17:03:37.851]             function(cond) {
[17:03:37.851]                 is_error <- inherits(cond, "error")
[17:03:37.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.851]                   NULL)
[17:03:37.851]                 if (is_error) {
[17:03:37.851]                   sessionInformation <- function() {
[17:03:37.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.851]                       search = base::search(), system = base::Sys.info())
[17:03:37.851]                   }
[17:03:37.851]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.851]                     cond$call), session = sessionInformation(), 
[17:03:37.851]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.851]                   signalCondition(cond)
[17:03:37.851]                 }
[17:03:37.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.851]                 "immediateCondition"))) {
[17:03:37.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.851]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.851]                   if (TRUE && !signal) {
[17:03:37.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.851]                     {
[17:03:37.851]                       inherits <- base::inherits
[17:03:37.851]                       invokeRestart <- base::invokeRestart
[17:03:37.851]                       is.null <- base::is.null
[17:03:37.851]                       muffled <- FALSE
[17:03:37.851]                       if (inherits(cond, "message")) {
[17:03:37.851]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.851]                         if (muffled) 
[17:03:37.851]                           invokeRestart("muffleMessage")
[17:03:37.851]                       }
[17:03:37.851]                       else if (inherits(cond, "warning")) {
[17:03:37.851]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.851]                         if (muffled) 
[17:03:37.851]                           invokeRestart("muffleWarning")
[17:03:37.851]                       }
[17:03:37.851]                       else if (inherits(cond, "condition")) {
[17:03:37.851]                         if (!is.null(pattern)) {
[17:03:37.851]                           computeRestarts <- base::computeRestarts
[17:03:37.851]                           grepl <- base::grepl
[17:03:37.851]                           restarts <- computeRestarts(cond)
[17:03:37.851]                           for (restart in restarts) {
[17:03:37.851]                             name <- restart$name
[17:03:37.851]                             if (is.null(name)) 
[17:03:37.851]                               next
[17:03:37.851]                             if (!grepl(pattern, name)) 
[17:03:37.851]                               next
[17:03:37.851]                             invokeRestart(restart)
[17:03:37.851]                             muffled <- TRUE
[17:03:37.851]                             break
[17:03:37.851]                           }
[17:03:37.851]                         }
[17:03:37.851]                       }
[17:03:37.851]                       invisible(muffled)
[17:03:37.851]                     }
[17:03:37.851]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.851]                   }
[17:03:37.851]                 }
[17:03:37.851]                 else {
[17:03:37.851]                   if (TRUE) {
[17:03:37.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.851]                     {
[17:03:37.851]                       inherits <- base::inherits
[17:03:37.851]                       invokeRestart <- base::invokeRestart
[17:03:37.851]                       is.null <- base::is.null
[17:03:37.851]                       muffled <- FALSE
[17:03:37.851]                       if (inherits(cond, "message")) {
[17:03:37.851]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.851]                         if (muffled) 
[17:03:37.851]                           invokeRestart("muffleMessage")
[17:03:37.851]                       }
[17:03:37.851]                       else if (inherits(cond, "warning")) {
[17:03:37.851]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.851]                         if (muffled) 
[17:03:37.851]                           invokeRestart("muffleWarning")
[17:03:37.851]                       }
[17:03:37.851]                       else if (inherits(cond, "condition")) {
[17:03:37.851]                         if (!is.null(pattern)) {
[17:03:37.851]                           computeRestarts <- base::computeRestarts
[17:03:37.851]                           grepl <- base::grepl
[17:03:37.851]                           restarts <- computeRestarts(cond)
[17:03:37.851]                           for (restart in restarts) {
[17:03:37.851]                             name <- restart$name
[17:03:37.851]                             if (is.null(name)) 
[17:03:37.851]                               next
[17:03:37.851]                             if (!grepl(pattern, name)) 
[17:03:37.851]                               next
[17:03:37.851]                             invokeRestart(restart)
[17:03:37.851]                             muffled <- TRUE
[17:03:37.851]                             break
[17:03:37.851]                           }
[17:03:37.851]                         }
[17:03:37.851]                       }
[17:03:37.851]                       invisible(muffled)
[17:03:37.851]                     }
[17:03:37.851]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.851]                   }
[17:03:37.851]                 }
[17:03:37.851]             }
[17:03:37.851]         }))
[17:03:37.851]     }, error = function(ex) {
[17:03:37.851]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.851]                 ...future.rng), started = ...future.startTime, 
[17:03:37.851]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.851]             version = "1.8"), class = "FutureResult")
[17:03:37.851]     }, finally = {
[17:03:37.851]         if (!identical(...future.workdir, getwd())) 
[17:03:37.851]             setwd(...future.workdir)
[17:03:37.851]         {
[17:03:37.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.851]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.851]             }
[17:03:37.851]             base::options(...future.oldOptions)
[17:03:37.851]             if (.Platform$OS.type == "windows") {
[17:03:37.851]                 old_names <- names(...future.oldEnvVars)
[17:03:37.851]                 envs <- base::Sys.getenv()
[17:03:37.851]                 names <- names(envs)
[17:03:37.851]                 common <- intersect(names, old_names)
[17:03:37.851]                 added <- setdiff(names, old_names)
[17:03:37.851]                 removed <- setdiff(old_names, names)
[17:03:37.851]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.851]                   envs[common]]
[17:03:37.851]                 NAMES <- toupper(changed)
[17:03:37.851]                 args <- list()
[17:03:37.851]                 for (kk in seq_along(NAMES)) {
[17:03:37.851]                   name <- changed[[kk]]
[17:03:37.851]                   NAME <- NAMES[[kk]]
[17:03:37.851]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.851]                     next
[17:03:37.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.851]                 }
[17:03:37.851]                 NAMES <- toupper(added)
[17:03:37.851]                 for (kk in seq_along(NAMES)) {
[17:03:37.851]                   name <- added[[kk]]
[17:03:37.851]                   NAME <- NAMES[[kk]]
[17:03:37.851]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.851]                     next
[17:03:37.851]                   args[[name]] <- ""
[17:03:37.851]                 }
[17:03:37.851]                 NAMES <- toupper(removed)
[17:03:37.851]                 for (kk in seq_along(NAMES)) {
[17:03:37.851]                   name <- removed[[kk]]
[17:03:37.851]                   NAME <- NAMES[[kk]]
[17:03:37.851]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.851]                     next
[17:03:37.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.851]                 }
[17:03:37.851]                 if (length(args) > 0) 
[17:03:37.851]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.851]             }
[17:03:37.851]             else {
[17:03:37.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.851]             }
[17:03:37.851]             {
[17:03:37.851]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.851]                   0L) {
[17:03:37.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.851]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.851]                   base::options(opts)
[17:03:37.851]                 }
[17:03:37.851]                 {
[17:03:37.851]                   {
[17:03:37.851]                     NULL
[17:03:37.851]                     RNGkind("Mersenne-Twister")
[17:03:37.851]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.851]                       inherits = FALSE)
[17:03:37.851]                   }
[17:03:37.851]                   options(future.plan = NULL)
[17:03:37.851]                   if (is.na(NA_character_)) 
[17:03:37.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.851]                     .init = FALSE)
[17:03:37.851]                 }
[17:03:37.851]             }
[17:03:37.851]         }
[17:03:37.851]     })
[17:03:37.851]     if (TRUE) {
[17:03:37.851]         base::sink(type = "output", split = FALSE)
[17:03:37.851]         if (TRUE) {
[17:03:37.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.851]         }
[17:03:37.851]         else {
[17:03:37.851]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.851]         }
[17:03:37.851]         base::close(...future.stdout)
[17:03:37.851]         ...future.stdout <- NULL
[17:03:37.851]     }
[17:03:37.851]     ...future.result$conditions <- ...future.conditions
[17:03:37.851]     ...future.result$finished <- base::Sys.time()
[17:03:37.851]     ...future.result
[17:03:37.851] }
[17:03:37.853] plan(): Setting new future strategy stack:
[17:03:37.853] List of future strategies:
[17:03:37.853] 1. sequential:
[17:03:37.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.853]    - tweaked: FALSE
[17:03:37.853]    - call: NULL
[17:03:37.853] plan(): nbrOfWorkers() = 1
[17:03:37.854] plan(): Setting new future strategy stack:
[17:03:37.854] List of future strategies:
[17:03:37.854] 1. sequential:
[17:03:37.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.854]    - tweaked: FALSE
[17:03:37.854]    - call: plan(strategy)
[17:03:37.854] plan(): nbrOfWorkers() = 1
[17:03:37.855] SequentialFuture started (and completed)
[17:03:37.855] - Launch lazy future ... done
[17:03:37.855] run() for ‘SequentialFuture’ ... done
[17:03:37.855] resolve() on environment ...
[17:03:37.855]  recursive: 0
[17:03:37.856]  elements: [3] ‘a’, ‘b’, ‘c’
[17:03:37.856] resolved() for ‘SequentialFuture’ ...
[17:03:37.856] - state: ‘finished’
[17:03:37.856] - run: TRUE
[17:03:37.856] - result: ‘FutureResult’
[17:03:37.856] resolved() for ‘SequentialFuture’ ... done
[17:03:37.856] Future #1
[17:03:37.857]  length: 2 (resolved future 1)
[17:03:37.857] resolved() for ‘SequentialFuture’ ...
[17:03:37.857] - state: ‘finished’
[17:03:37.857] - run: TRUE
[17:03:37.857] - result: ‘FutureResult’
[17:03:37.857] resolved() for ‘SequentialFuture’ ... done
[17:03:37.857] Future #2
[17:03:37.857]  length: 1 (resolved future 2)
[17:03:37.857]  length: 0 (resolved future 3)
[17:03:37.857] resolve() on environment ... DONE
[17:03:37.857] resolved() for ‘SequentialFuture’ ...
[17:03:37.858] - state: ‘finished’
[17:03:37.858] - run: TRUE
[17:03:37.858] - result: ‘FutureResult’
[17:03:37.858] resolved() for ‘SequentialFuture’ ... done
[17:03:37.858] resolved() for ‘SequentialFuture’ ...
[17:03:37.858] - state: ‘finished’
[17:03:37.858] - run: TRUE
[17:03:37.858] - result: ‘FutureResult’
[17:03:37.858] resolved() for ‘SequentialFuture’ ... done
[17:03:37.859] getGlobalsAndPackages() ...
[17:03:37.859] Searching for globals...
[17:03:37.860] - globals found: [1] ‘{’
[17:03:37.860] Searching for globals ... DONE
[17:03:37.860] Resolving globals: FALSE
[17:03:37.860] 
[17:03:37.860] 
[17:03:37.860] getGlobalsAndPackages() ... DONE
[17:03:37.861] run() for ‘Future’ ...
[17:03:37.861] - state: ‘created’
[17:03:37.861] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.861] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.861]   - Field: ‘label’
[17:03:37.861]   - Field: ‘local’
[17:03:37.861]   - Field: ‘owner’
[17:03:37.862]   - Field: ‘envir’
[17:03:37.862]   - Field: ‘packages’
[17:03:37.862]   - Field: ‘gc’
[17:03:37.862]   - Field: ‘conditions’
[17:03:37.862]   - Field: ‘expr’
[17:03:37.862]   - Field: ‘uuid’
[17:03:37.862]   - Field: ‘seed’
[17:03:37.862]   - Field: ‘version’
[17:03:37.862]   - Field: ‘result’
[17:03:37.862]   - Field: ‘asynchronous’
[17:03:37.862]   - Field: ‘calls’
[17:03:37.863]   - Field: ‘globals’
[17:03:37.863]   - Field: ‘stdout’
[17:03:37.863]   - Field: ‘earlySignal’
[17:03:37.863]   - Field: ‘lazy’
[17:03:37.863]   - Field: ‘state’
[17:03:37.863] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.863] - Launch lazy future ...
[17:03:37.863] Packages needed by the future expression (n = 0): <none>
[17:03:37.863] Packages needed by future strategies (n = 0): <none>
[17:03:37.864] {
[17:03:37.864]     {
[17:03:37.864]         {
[17:03:37.864]             ...future.startTime <- base::Sys.time()
[17:03:37.864]             {
[17:03:37.864]                 {
[17:03:37.864]                   {
[17:03:37.864]                     base::local({
[17:03:37.864]                       has_future <- base::requireNamespace("future", 
[17:03:37.864]                         quietly = TRUE)
[17:03:37.864]                       if (has_future) {
[17:03:37.864]                         ns <- base::getNamespace("future")
[17:03:37.864]                         version <- ns[[".package"]][["version"]]
[17:03:37.864]                         if (is.null(version)) 
[17:03:37.864]                           version <- utils::packageVersion("future")
[17:03:37.864]                       }
[17:03:37.864]                       else {
[17:03:37.864]                         version <- NULL
[17:03:37.864]                       }
[17:03:37.864]                       if (!has_future || version < "1.8.0") {
[17:03:37.864]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.864]                           "", base::R.version$version.string), 
[17:03:37.864]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.864]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.864]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.864]                             "release", "version")], collapse = " "), 
[17:03:37.864]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.864]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.864]                           info)
[17:03:37.864]                         info <- base::paste(info, collapse = "; ")
[17:03:37.864]                         if (!has_future) {
[17:03:37.864]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.864]                             info)
[17:03:37.864]                         }
[17:03:37.864]                         else {
[17:03:37.864]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.864]                             info, version)
[17:03:37.864]                         }
[17:03:37.864]                         base::stop(msg)
[17:03:37.864]                       }
[17:03:37.864]                     })
[17:03:37.864]                   }
[17:03:37.864]                   ...future.strategy.old <- future::plan("list")
[17:03:37.864]                   options(future.plan = NULL)
[17:03:37.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.864]                 }
[17:03:37.864]                 ...future.workdir <- getwd()
[17:03:37.864]             }
[17:03:37.864]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.864]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.864]         }
[17:03:37.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.864]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.864]             base::names(...future.oldOptions))
[17:03:37.864]     }
[17:03:37.864]     if (FALSE) {
[17:03:37.864]     }
[17:03:37.864]     else {
[17:03:37.864]         if (TRUE) {
[17:03:37.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.864]                 open = "w")
[17:03:37.864]         }
[17:03:37.864]         else {
[17:03:37.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.864]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.864]         }
[17:03:37.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.864]             base::sink(type = "output", split = FALSE)
[17:03:37.864]             base::close(...future.stdout)
[17:03:37.864]         }, add = TRUE)
[17:03:37.864]     }
[17:03:37.864]     ...future.frame <- base::sys.nframe()
[17:03:37.864]     ...future.conditions <- base::list()
[17:03:37.864]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.864]     if (FALSE) {
[17:03:37.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.864]     }
[17:03:37.864]     ...future.result <- base::tryCatch({
[17:03:37.864]         base::withCallingHandlers({
[17:03:37.864]             ...future.value <- base::withVisible(base::local({
[17:03:37.864]                 1
[17:03:37.864]             }))
[17:03:37.864]             future::FutureResult(value = ...future.value$value, 
[17:03:37.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.864]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.864]                     ...future.globalenv.names))
[17:03:37.864]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.864]         }, condition = base::local({
[17:03:37.864]             c <- base::c
[17:03:37.864]             inherits <- base::inherits
[17:03:37.864]             invokeRestart <- base::invokeRestart
[17:03:37.864]             length <- base::length
[17:03:37.864]             list <- base::list
[17:03:37.864]             seq.int <- base::seq.int
[17:03:37.864]             signalCondition <- base::signalCondition
[17:03:37.864]             sys.calls <- base::sys.calls
[17:03:37.864]             `[[` <- base::`[[`
[17:03:37.864]             `+` <- base::`+`
[17:03:37.864]             `<<-` <- base::`<<-`
[17:03:37.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.864]                   3L)]
[17:03:37.864]             }
[17:03:37.864]             function(cond) {
[17:03:37.864]                 is_error <- inherits(cond, "error")
[17:03:37.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.864]                   NULL)
[17:03:37.864]                 if (is_error) {
[17:03:37.864]                   sessionInformation <- function() {
[17:03:37.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.864]                       search = base::search(), system = base::Sys.info())
[17:03:37.864]                   }
[17:03:37.864]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.864]                     cond$call), session = sessionInformation(), 
[17:03:37.864]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.864]                   signalCondition(cond)
[17:03:37.864]                 }
[17:03:37.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.864]                 "immediateCondition"))) {
[17:03:37.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.864]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.864]                   if (TRUE && !signal) {
[17:03:37.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.864]                     {
[17:03:37.864]                       inherits <- base::inherits
[17:03:37.864]                       invokeRestart <- base::invokeRestart
[17:03:37.864]                       is.null <- base::is.null
[17:03:37.864]                       muffled <- FALSE
[17:03:37.864]                       if (inherits(cond, "message")) {
[17:03:37.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.864]                         if (muffled) 
[17:03:37.864]                           invokeRestart("muffleMessage")
[17:03:37.864]                       }
[17:03:37.864]                       else if (inherits(cond, "warning")) {
[17:03:37.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.864]                         if (muffled) 
[17:03:37.864]                           invokeRestart("muffleWarning")
[17:03:37.864]                       }
[17:03:37.864]                       else if (inherits(cond, "condition")) {
[17:03:37.864]                         if (!is.null(pattern)) {
[17:03:37.864]                           computeRestarts <- base::computeRestarts
[17:03:37.864]                           grepl <- base::grepl
[17:03:37.864]                           restarts <- computeRestarts(cond)
[17:03:37.864]                           for (restart in restarts) {
[17:03:37.864]                             name <- restart$name
[17:03:37.864]                             if (is.null(name)) 
[17:03:37.864]                               next
[17:03:37.864]                             if (!grepl(pattern, name)) 
[17:03:37.864]                               next
[17:03:37.864]                             invokeRestart(restart)
[17:03:37.864]                             muffled <- TRUE
[17:03:37.864]                             break
[17:03:37.864]                           }
[17:03:37.864]                         }
[17:03:37.864]                       }
[17:03:37.864]                       invisible(muffled)
[17:03:37.864]                     }
[17:03:37.864]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.864]                   }
[17:03:37.864]                 }
[17:03:37.864]                 else {
[17:03:37.864]                   if (TRUE) {
[17:03:37.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.864]                     {
[17:03:37.864]                       inherits <- base::inherits
[17:03:37.864]                       invokeRestart <- base::invokeRestart
[17:03:37.864]                       is.null <- base::is.null
[17:03:37.864]                       muffled <- FALSE
[17:03:37.864]                       if (inherits(cond, "message")) {
[17:03:37.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.864]                         if (muffled) 
[17:03:37.864]                           invokeRestart("muffleMessage")
[17:03:37.864]                       }
[17:03:37.864]                       else if (inherits(cond, "warning")) {
[17:03:37.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.864]                         if (muffled) 
[17:03:37.864]                           invokeRestart("muffleWarning")
[17:03:37.864]                       }
[17:03:37.864]                       else if (inherits(cond, "condition")) {
[17:03:37.864]                         if (!is.null(pattern)) {
[17:03:37.864]                           computeRestarts <- base::computeRestarts
[17:03:37.864]                           grepl <- base::grepl
[17:03:37.864]                           restarts <- computeRestarts(cond)
[17:03:37.864]                           for (restart in restarts) {
[17:03:37.864]                             name <- restart$name
[17:03:37.864]                             if (is.null(name)) 
[17:03:37.864]                               next
[17:03:37.864]                             if (!grepl(pattern, name)) 
[17:03:37.864]                               next
[17:03:37.864]                             invokeRestart(restart)
[17:03:37.864]                             muffled <- TRUE
[17:03:37.864]                             break
[17:03:37.864]                           }
[17:03:37.864]                         }
[17:03:37.864]                       }
[17:03:37.864]                       invisible(muffled)
[17:03:37.864]                     }
[17:03:37.864]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.864]                   }
[17:03:37.864]                 }
[17:03:37.864]             }
[17:03:37.864]         }))
[17:03:37.864]     }, error = function(ex) {
[17:03:37.864]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.864]                 ...future.rng), started = ...future.startTime, 
[17:03:37.864]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.864]             version = "1.8"), class = "FutureResult")
[17:03:37.864]     }, finally = {
[17:03:37.864]         if (!identical(...future.workdir, getwd())) 
[17:03:37.864]             setwd(...future.workdir)
[17:03:37.864]         {
[17:03:37.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.864]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.864]             }
[17:03:37.864]             base::options(...future.oldOptions)
[17:03:37.864]             if (.Platform$OS.type == "windows") {
[17:03:37.864]                 old_names <- names(...future.oldEnvVars)
[17:03:37.864]                 envs <- base::Sys.getenv()
[17:03:37.864]                 names <- names(envs)
[17:03:37.864]                 common <- intersect(names, old_names)
[17:03:37.864]                 added <- setdiff(names, old_names)
[17:03:37.864]                 removed <- setdiff(old_names, names)
[17:03:37.864]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.864]                   envs[common]]
[17:03:37.864]                 NAMES <- toupper(changed)
[17:03:37.864]                 args <- list()
[17:03:37.864]                 for (kk in seq_along(NAMES)) {
[17:03:37.864]                   name <- changed[[kk]]
[17:03:37.864]                   NAME <- NAMES[[kk]]
[17:03:37.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.864]                     next
[17:03:37.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.864]                 }
[17:03:37.864]                 NAMES <- toupper(added)
[17:03:37.864]                 for (kk in seq_along(NAMES)) {
[17:03:37.864]                   name <- added[[kk]]
[17:03:37.864]                   NAME <- NAMES[[kk]]
[17:03:37.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.864]                     next
[17:03:37.864]                   args[[name]] <- ""
[17:03:37.864]                 }
[17:03:37.864]                 NAMES <- toupper(removed)
[17:03:37.864]                 for (kk in seq_along(NAMES)) {
[17:03:37.864]                   name <- removed[[kk]]
[17:03:37.864]                   NAME <- NAMES[[kk]]
[17:03:37.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.864]                     next
[17:03:37.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.864]                 }
[17:03:37.864]                 if (length(args) > 0) 
[17:03:37.864]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.864]             }
[17:03:37.864]             else {
[17:03:37.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.864]             }
[17:03:37.864]             {
[17:03:37.864]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.864]                   0L) {
[17:03:37.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.864]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.864]                   base::options(opts)
[17:03:37.864]                 }
[17:03:37.864]                 {
[17:03:37.864]                   {
[17:03:37.864]                     NULL
[17:03:37.864]                     RNGkind("Mersenne-Twister")
[17:03:37.864]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.864]                       inherits = FALSE)
[17:03:37.864]                   }
[17:03:37.864]                   options(future.plan = NULL)
[17:03:37.864]                   if (is.na(NA_character_)) 
[17:03:37.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.864]                     .init = FALSE)
[17:03:37.864]                 }
[17:03:37.864]             }
[17:03:37.864]         }
[17:03:37.864]     })
[17:03:37.864]     if (TRUE) {
[17:03:37.864]         base::sink(type = "output", split = FALSE)
[17:03:37.864]         if (TRUE) {
[17:03:37.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.864]         }
[17:03:37.864]         else {
[17:03:37.864]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.864]         }
[17:03:37.864]         base::close(...future.stdout)
[17:03:37.864]         ...future.stdout <- NULL
[17:03:37.864]     }
[17:03:37.864]     ...future.result$conditions <- ...future.conditions
[17:03:37.864]     ...future.result$finished <- base::Sys.time()
[17:03:37.864]     ...future.result
[17:03:37.864] }
[17:03:37.865] plan(): Setting new future strategy stack:
[17:03:37.866] List of future strategies:
[17:03:37.866] 1. sequential:
[17:03:37.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.866]    - tweaked: FALSE
[17:03:37.866]    - call: NULL
[17:03:37.866] plan(): nbrOfWorkers() = 1
[17:03:37.867] plan(): Setting new future strategy stack:
[17:03:37.867] List of future strategies:
[17:03:37.867] 1. sequential:
[17:03:37.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.867]    - tweaked: FALSE
[17:03:37.867]    - call: plan(strategy)
[17:03:37.867] plan(): nbrOfWorkers() = 1
[17:03:37.867] SequentialFuture started (and completed)
[17:03:37.867] - Launch lazy future ... done
[17:03:37.868] run() for ‘SequentialFuture’ ... done
[17:03:37.868] getGlobalsAndPackages() ...
[17:03:37.868] Searching for globals...
[17:03:37.868] - globals found: [1] ‘{’
[17:03:37.869] Searching for globals ... DONE
[17:03:37.869] Resolving globals: FALSE
[17:03:37.869] 
[17:03:37.869] 
[17:03:37.869] getGlobalsAndPackages() ... DONE
[17:03:37.869] run() for ‘Future’ ...
[17:03:37.869] - state: ‘created’
[17:03:37.870] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.870] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.870]   - Field: ‘label’
[17:03:37.870]   - Field: ‘local’
[17:03:37.870]   - Field: ‘owner’
[17:03:37.870]   - Field: ‘envir’
[17:03:37.870]   - Field: ‘packages’
[17:03:37.870]   - Field: ‘gc’
[17:03:37.871]   - Field: ‘conditions’
[17:03:37.871]   - Field: ‘expr’
[17:03:37.871]   - Field: ‘uuid’
[17:03:37.871]   - Field: ‘seed’
[17:03:37.871]   - Field: ‘version’
[17:03:37.871]   - Field: ‘result’
[17:03:37.871]   - Field: ‘asynchronous’
[17:03:37.871]   - Field: ‘calls’
[17:03:37.871]   - Field: ‘globals’
[17:03:37.871]   - Field: ‘stdout’
[17:03:37.871]   - Field: ‘earlySignal’
[17:03:37.872]   - Field: ‘lazy’
[17:03:37.872]   - Field: ‘state’
[17:03:37.872] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.872] - Launch lazy future ...
[17:03:37.872] Packages needed by the future expression (n = 0): <none>
[17:03:37.872] Packages needed by future strategies (n = 0): <none>
[17:03:37.872] {
[17:03:37.872]     {
[17:03:37.872]         {
[17:03:37.872]             ...future.startTime <- base::Sys.time()
[17:03:37.872]             {
[17:03:37.872]                 {
[17:03:37.872]                   {
[17:03:37.872]                     base::local({
[17:03:37.872]                       has_future <- base::requireNamespace("future", 
[17:03:37.872]                         quietly = TRUE)
[17:03:37.872]                       if (has_future) {
[17:03:37.872]                         ns <- base::getNamespace("future")
[17:03:37.872]                         version <- ns[[".package"]][["version"]]
[17:03:37.872]                         if (is.null(version)) 
[17:03:37.872]                           version <- utils::packageVersion("future")
[17:03:37.872]                       }
[17:03:37.872]                       else {
[17:03:37.872]                         version <- NULL
[17:03:37.872]                       }
[17:03:37.872]                       if (!has_future || version < "1.8.0") {
[17:03:37.872]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.872]                           "", base::R.version$version.string), 
[17:03:37.872]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.872]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.872]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.872]                             "release", "version")], collapse = " "), 
[17:03:37.872]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.872]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.872]                           info)
[17:03:37.872]                         info <- base::paste(info, collapse = "; ")
[17:03:37.872]                         if (!has_future) {
[17:03:37.872]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.872]                             info)
[17:03:37.872]                         }
[17:03:37.872]                         else {
[17:03:37.872]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.872]                             info, version)
[17:03:37.872]                         }
[17:03:37.872]                         base::stop(msg)
[17:03:37.872]                       }
[17:03:37.872]                     })
[17:03:37.872]                   }
[17:03:37.872]                   ...future.strategy.old <- future::plan("list")
[17:03:37.872]                   options(future.plan = NULL)
[17:03:37.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.872]                 }
[17:03:37.872]                 ...future.workdir <- getwd()
[17:03:37.872]             }
[17:03:37.872]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.872]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.872]         }
[17:03:37.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.872]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.872]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.872]             base::names(...future.oldOptions))
[17:03:37.872]     }
[17:03:37.872]     if (FALSE) {
[17:03:37.872]     }
[17:03:37.872]     else {
[17:03:37.872]         if (TRUE) {
[17:03:37.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.872]                 open = "w")
[17:03:37.872]         }
[17:03:37.872]         else {
[17:03:37.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.872]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.872]         }
[17:03:37.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.872]             base::sink(type = "output", split = FALSE)
[17:03:37.872]             base::close(...future.stdout)
[17:03:37.872]         }, add = TRUE)
[17:03:37.872]     }
[17:03:37.872]     ...future.frame <- base::sys.nframe()
[17:03:37.872]     ...future.conditions <- base::list()
[17:03:37.872]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.872]     if (FALSE) {
[17:03:37.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.872]     }
[17:03:37.872]     ...future.result <- base::tryCatch({
[17:03:37.872]         base::withCallingHandlers({
[17:03:37.872]             ...future.value <- base::withVisible(base::local({
[17:03:37.872]                 2
[17:03:37.872]             }))
[17:03:37.872]             future::FutureResult(value = ...future.value$value, 
[17:03:37.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.872]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.872]                     ...future.globalenv.names))
[17:03:37.872]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.872]         }, condition = base::local({
[17:03:37.872]             c <- base::c
[17:03:37.872]             inherits <- base::inherits
[17:03:37.872]             invokeRestart <- base::invokeRestart
[17:03:37.872]             length <- base::length
[17:03:37.872]             list <- base::list
[17:03:37.872]             seq.int <- base::seq.int
[17:03:37.872]             signalCondition <- base::signalCondition
[17:03:37.872]             sys.calls <- base::sys.calls
[17:03:37.872]             `[[` <- base::`[[`
[17:03:37.872]             `+` <- base::`+`
[17:03:37.872]             `<<-` <- base::`<<-`
[17:03:37.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.872]                   3L)]
[17:03:37.872]             }
[17:03:37.872]             function(cond) {
[17:03:37.872]                 is_error <- inherits(cond, "error")
[17:03:37.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.872]                   NULL)
[17:03:37.872]                 if (is_error) {
[17:03:37.872]                   sessionInformation <- function() {
[17:03:37.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.872]                       search = base::search(), system = base::Sys.info())
[17:03:37.872]                   }
[17:03:37.872]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.872]                     cond$call), session = sessionInformation(), 
[17:03:37.872]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.872]                   signalCondition(cond)
[17:03:37.872]                 }
[17:03:37.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.872]                 "immediateCondition"))) {
[17:03:37.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.872]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.872]                   if (TRUE && !signal) {
[17:03:37.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.872]                     {
[17:03:37.872]                       inherits <- base::inherits
[17:03:37.872]                       invokeRestart <- base::invokeRestart
[17:03:37.872]                       is.null <- base::is.null
[17:03:37.872]                       muffled <- FALSE
[17:03:37.872]                       if (inherits(cond, "message")) {
[17:03:37.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.872]                         if (muffled) 
[17:03:37.872]                           invokeRestart("muffleMessage")
[17:03:37.872]                       }
[17:03:37.872]                       else if (inherits(cond, "warning")) {
[17:03:37.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.872]                         if (muffled) 
[17:03:37.872]                           invokeRestart("muffleWarning")
[17:03:37.872]                       }
[17:03:37.872]                       else if (inherits(cond, "condition")) {
[17:03:37.872]                         if (!is.null(pattern)) {
[17:03:37.872]                           computeRestarts <- base::computeRestarts
[17:03:37.872]                           grepl <- base::grepl
[17:03:37.872]                           restarts <- computeRestarts(cond)
[17:03:37.872]                           for (restart in restarts) {
[17:03:37.872]                             name <- restart$name
[17:03:37.872]                             if (is.null(name)) 
[17:03:37.872]                               next
[17:03:37.872]                             if (!grepl(pattern, name)) 
[17:03:37.872]                               next
[17:03:37.872]                             invokeRestart(restart)
[17:03:37.872]                             muffled <- TRUE
[17:03:37.872]                             break
[17:03:37.872]                           }
[17:03:37.872]                         }
[17:03:37.872]                       }
[17:03:37.872]                       invisible(muffled)
[17:03:37.872]                     }
[17:03:37.872]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.872]                   }
[17:03:37.872]                 }
[17:03:37.872]                 else {
[17:03:37.872]                   if (TRUE) {
[17:03:37.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.872]                     {
[17:03:37.872]                       inherits <- base::inherits
[17:03:37.872]                       invokeRestart <- base::invokeRestart
[17:03:37.872]                       is.null <- base::is.null
[17:03:37.872]                       muffled <- FALSE
[17:03:37.872]                       if (inherits(cond, "message")) {
[17:03:37.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.872]                         if (muffled) 
[17:03:37.872]                           invokeRestart("muffleMessage")
[17:03:37.872]                       }
[17:03:37.872]                       else if (inherits(cond, "warning")) {
[17:03:37.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.872]                         if (muffled) 
[17:03:37.872]                           invokeRestart("muffleWarning")
[17:03:37.872]                       }
[17:03:37.872]                       else if (inherits(cond, "condition")) {
[17:03:37.872]                         if (!is.null(pattern)) {
[17:03:37.872]                           computeRestarts <- base::computeRestarts
[17:03:37.872]                           grepl <- base::grepl
[17:03:37.872]                           restarts <- computeRestarts(cond)
[17:03:37.872]                           for (restart in restarts) {
[17:03:37.872]                             name <- restart$name
[17:03:37.872]                             if (is.null(name)) 
[17:03:37.872]                               next
[17:03:37.872]                             if (!grepl(pattern, name)) 
[17:03:37.872]                               next
[17:03:37.872]                             invokeRestart(restart)
[17:03:37.872]                             muffled <- TRUE
[17:03:37.872]                             break
[17:03:37.872]                           }
[17:03:37.872]                         }
[17:03:37.872]                       }
[17:03:37.872]                       invisible(muffled)
[17:03:37.872]                     }
[17:03:37.872]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.872]                   }
[17:03:37.872]                 }
[17:03:37.872]             }
[17:03:37.872]         }))
[17:03:37.872]     }, error = function(ex) {
[17:03:37.872]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.872]                 ...future.rng), started = ...future.startTime, 
[17:03:37.872]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.872]             version = "1.8"), class = "FutureResult")
[17:03:37.872]     }, finally = {
[17:03:37.872]         if (!identical(...future.workdir, getwd())) 
[17:03:37.872]             setwd(...future.workdir)
[17:03:37.872]         {
[17:03:37.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.872]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.872]             }
[17:03:37.872]             base::options(...future.oldOptions)
[17:03:37.872]             if (.Platform$OS.type == "windows") {
[17:03:37.872]                 old_names <- names(...future.oldEnvVars)
[17:03:37.872]                 envs <- base::Sys.getenv()
[17:03:37.872]                 names <- names(envs)
[17:03:37.872]                 common <- intersect(names, old_names)
[17:03:37.872]                 added <- setdiff(names, old_names)
[17:03:37.872]                 removed <- setdiff(old_names, names)
[17:03:37.872]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.872]                   envs[common]]
[17:03:37.872]                 NAMES <- toupper(changed)
[17:03:37.872]                 args <- list()
[17:03:37.872]                 for (kk in seq_along(NAMES)) {
[17:03:37.872]                   name <- changed[[kk]]
[17:03:37.872]                   NAME <- NAMES[[kk]]
[17:03:37.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.872]                     next
[17:03:37.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.872]                 }
[17:03:37.872]                 NAMES <- toupper(added)
[17:03:37.872]                 for (kk in seq_along(NAMES)) {
[17:03:37.872]                   name <- added[[kk]]
[17:03:37.872]                   NAME <- NAMES[[kk]]
[17:03:37.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.872]                     next
[17:03:37.872]                   args[[name]] <- ""
[17:03:37.872]                 }
[17:03:37.872]                 NAMES <- toupper(removed)
[17:03:37.872]                 for (kk in seq_along(NAMES)) {
[17:03:37.872]                   name <- removed[[kk]]
[17:03:37.872]                   NAME <- NAMES[[kk]]
[17:03:37.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.872]                     next
[17:03:37.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.872]                 }
[17:03:37.872]                 if (length(args) > 0) 
[17:03:37.872]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.872]             }
[17:03:37.872]             else {
[17:03:37.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.872]             }
[17:03:37.872]             {
[17:03:37.872]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.872]                   0L) {
[17:03:37.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.872]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.872]                   base::options(opts)
[17:03:37.872]                 }
[17:03:37.872]                 {
[17:03:37.872]                   {
[17:03:37.872]                     NULL
[17:03:37.872]                     RNGkind("Mersenne-Twister")
[17:03:37.872]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.872]                       inherits = FALSE)
[17:03:37.872]                   }
[17:03:37.872]                   options(future.plan = NULL)
[17:03:37.872]                   if (is.na(NA_character_)) 
[17:03:37.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.872]                     .init = FALSE)
[17:03:37.872]                 }
[17:03:37.872]             }
[17:03:37.872]         }
[17:03:37.872]     })
[17:03:37.872]     if (TRUE) {
[17:03:37.872]         base::sink(type = "output", split = FALSE)
[17:03:37.872]         if (TRUE) {
[17:03:37.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.872]         }
[17:03:37.872]         else {
[17:03:37.872]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.872]         }
[17:03:37.872]         base::close(...future.stdout)
[17:03:37.872]         ...future.stdout <- NULL
[17:03:37.872]     }
[17:03:37.872]     ...future.result$conditions <- ...future.conditions
[17:03:37.872]     ...future.result$finished <- base::Sys.time()
[17:03:37.872]     ...future.result
[17:03:37.872] }
[17:03:37.874] plan(): Setting new future strategy stack:
[17:03:37.874] List of future strategies:
[17:03:37.874] 1. sequential:
[17:03:37.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.874]    - tweaked: FALSE
[17:03:37.874]    - call: NULL
[17:03:37.875] plan(): nbrOfWorkers() = 1
[17:03:37.875] plan(): Setting new future strategy stack:
[17:03:37.876] List of future strategies:
[17:03:37.876] 1. sequential:
[17:03:37.876]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.876]    - tweaked: FALSE
[17:03:37.876]    - call: plan(strategy)
[17:03:37.876] plan(): nbrOfWorkers() = 1
[17:03:37.876] SequentialFuture started (and completed)
[17:03:37.876] - Launch lazy future ... done
[17:03:37.876] run() for ‘SequentialFuture’ ... done
[17:03:37.879] resolve() on environment ...
[17:03:37.879]  recursive: 0
[17:03:37.879]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:03:37.879] resolved() for ‘SequentialFuture’ ...
[17:03:37.880] - state: ‘finished’
[17:03:37.880] - run: TRUE
[17:03:37.880] - result: ‘FutureResult’
[17:03:37.880] resolved() for ‘SequentialFuture’ ... done
[17:03:37.880] Future #1
[17:03:37.880]  length: 2 (resolved future 1)
[17:03:37.880] resolved() for ‘SequentialFuture’ ...
[17:03:37.880] - state: ‘finished’
[17:03:37.880] - run: TRUE
[17:03:37.880] - result: ‘FutureResult’
[17:03:37.881] resolved() for ‘SequentialFuture’ ... done
[17:03:37.881] Future #2
[17:03:37.881]  length: 1 (resolved future 2)
[17:03:37.881]  length: 0 (resolved future 3)
[17:03:37.881] resolve() on environment ... DONE
[17:03:37.881] getGlobalsAndPackages() ...
[17:03:37.881] Searching for globals...
[17:03:37.882] - globals found: [1] ‘{’
[17:03:37.882] Searching for globals ... DONE
[17:03:37.882] Resolving globals: FALSE
[17:03:37.882] 
[17:03:37.882] 
[17:03:37.883] getGlobalsAndPackages() ... DONE
[17:03:37.883] run() for ‘Future’ ...
[17:03:37.883] - state: ‘created’
[17:03:37.883] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.883] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.883]   - Field: ‘label’
[17:03:37.884]   - Field: ‘local’
[17:03:37.884]   - Field: ‘owner’
[17:03:37.884]   - Field: ‘envir’
[17:03:37.884]   - Field: ‘packages’
[17:03:37.884]   - Field: ‘gc’
[17:03:37.884]   - Field: ‘conditions’
[17:03:37.884]   - Field: ‘expr’
[17:03:37.884]   - Field: ‘uuid’
[17:03:37.884]   - Field: ‘seed’
[17:03:37.884]   - Field: ‘version’
[17:03:37.884]   - Field: ‘result’
[17:03:37.885]   - Field: ‘asynchronous’
[17:03:37.885]   - Field: ‘calls’
[17:03:37.885]   - Field: ‘globals’
[17:03:37.885]   - Field: ‘stdout’
[17:03:37.885]   - Field: ‘earlySignal’
[17:03:37.885]   - Field: ‘lazy’
[17:03:37.885]   - Field: ‘state’
[17:03:37.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.885] - Launch lazy future ...
[17:03:37.885] Packages needed by the future expression (n = 0): <none>
[17:03:37.886] Packages needed by future strategies (n = 0): <none>
[17:03:37.886] {
[17:03:37.886]     {
[17:03:37.886]         {
[17:03:37.886]             ...future.startTime <- base::Sys.time()
[17:03:37.886]             {
[17:03:37.886]                 {
[17:03:37.886]                   {
[17:03:37.886]                     base::local({
[17:03:37.886]                       has_future <- base::requireNamespace("future", 
[17:03:37.886]                         quietly = TRUE)
[17:03:37.886]                       if (has_future) {
[17:03:37.886]                         ns <- base::getNamespace("future")
[17:03:37.886]                         version <- ns[[".package"]][["version"]]
[17:03:37.886]                         if (is.null(version)) 
[17:03:37.886]                           version <- utils::packageVersion("future")
[17:03:37.886]                       }
[17:03:37.886]                       else {
[17:03:37.886]                         version <- NULL
[17:03:37.886]                       }
[17:03:37.886]                       if (!has_future || version < "1.8.0") {
[17:03:37.886]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.886]                           "", base::R.version$version.string), 
[17:03:37.886]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.886]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.886]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.886]                             "release", "version")], collapse = " "), 
[17:03:37.886]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.886]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.886]                           info)
[17:03:37.886]                         info <- base::paste(info, collapse = "; ")
[17:03:37.886]                         if (!has_future) {
[17:03:37.886]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.886]                             info)
[17:03:37.886]                         }
[17:03:37.886]                         else {
[17:03:37.886]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.886]                             info, version)
[17:03:37.886]                         }
[17:03:37.886]                         base::stop(msg)
[17:03:37.886]                       }
[17:03:37.886]                     })
[17:03:37.886]                   }
[17:03:37.886]                   ...future.strategy.old <- future::plan("list")
[17:03:37.886]                   options(future.plan = NULL)
[17:03:37.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.886]                 }
[17:03:37.886]                 ...future.workdir <- getwd()
[17:03:37.886]             }
[17:03:37.886]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.886]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.886]         }
[17:03:37.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.886]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.886]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.886]             base::names(...future.oldOptions))
[17:03:37.886]     }
[17:03:37.886]     if (FALSE) {
[17:03:37.886]     }
[17:03:37.886]     else {
[17:03:37.886]         if (TRUE) {
[17:03:37.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.886]                 open = "w")
[17:03:37.886]         }
[17:03:37.886]         else {
[17:03:37.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.886]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.886]         }
[17:03:37.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.886]             base::sink(type = "output", split = FALSE)
[17:03:37.886]             base::close(...future.stdout)
[17:03:37.886]         }, add = TRUE)
[17:03:37.886]     }
[17:03:37.886]     ...future.frame <- base::sys.nframe()
[17:03:37.886]     ...future.conditions <- base::list()
[17:03:37.886]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.886]     if (FALSE) {
[17:03:37.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.886]     }
[17:03:37.886]     ...future.result <- base::tryCatch({
[17:03:37.886]         base::withCallingHandlers({
[17:03:37.886]             ...future.value <- base::withVisible(base::local({
[17:03:37.886]                 1
[17:03:37.886]             }))
[17:03:37.886]             future::FutureResult(value = ...future.value$value, 
[17:03:37.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.886]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.886]                     ...future.globalenv.names))
[17:03:37.886]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.886]         }, condition = base::local({
[17:03:37.886]             c <- base::c
[17:03:37.886]             inherits <- base::inherits
[17:03:37.886]             invokeRestart <- base::invokeRestart
[17:03:37.886]             length <- base::length
[17:03:37.886]             list <- base::list
[17:03:37.886]             seq.int <- base::seq.int
[17:03:37.886]             signalCondition <- base::signalCondition
[17:03:37.886]             sys.calls <- base::sys.calls
[17:03:37.886]             `[[` <- base::`[[`
[17:03:37.886]             `+` <- base::`+`
[17:03:37.886]             `<<-` <- base::`<<-`
[17:03:37.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.886]                   3L)]
[17:03:37.886]             }
[17:03:37.886]             function(cond) {
[17:03:37.886]                 is_error <- inherits(cond, "error")
[17:03:37.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.886]                   NULL)
[17:03:37.886]                 if (is_error) {
[17:03:37.886]                   sessionInformation <- function() {
[17:03:37.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.886]                       search = base::search(), system = base::Sys.info())
[17:03:37.886]                   }
[17:03:37.886]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.886]                     cond$call), session = sessionInformation(), 
[17:03:37.886]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.886]                   signalCondition(cond)
[17:03:37.886]                 }
[17:03:37.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.886]                 "immediateCondition"))) {
[17:03:37.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.886]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.886]                   if (TRUE && !signal) {
[17:03:37.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.886]                     {
[17:03:37.886]                       inherits <- base::inherits
[17:03:37.886]                       invokeRestart <- base::invokeRestart
[17:03:37.886]                       is.null <- base::is.null
[17:03:37.886]                       muffled <- FALSE
[17:03:37.886]                       if (inherits(cond, "message")) {
[17:03:37.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.886]                         if (muffled) 
[17:03:37.886]                           invokeRestart("muffleMessage")
[17:03:37.886]                       }
[17:03:37.886]                       else if (inherits(cond, "warning")) {
[17:03:37.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.886]                         if (muffled) 
[17:03:37.886]                           invokeRestart("muffleWarning")
[17:03:37.886]                       }
[17:03:37.886]                       else if (inherits(cond, "condition")) {
[17:03:37.886]                         if (!is.null(pattern)) {
[17:03:37.886]                           computeRestarts <- base::computeRestarts
[17:03:37.886]                           grepl <- base::grepl
[17:03:37.886]                           restarts <- computeRestarts(cond)
[17:03:37.886]                           for (restart in restarts) {
[17:03:37.886]                             name <- restart$name
[17:03:37.886]                             if (is.null(name)) 
[17:03:37.886]                               next
[17:03:37.886]                             if (!grepl(pattern, name)) 
[17:03:37.886]                               next
[17:03:37.886]                             invokeRestart(restart)
[17:03:37.886]                             muffled <- TRUE
[17:03:37.886]                             break
[17:03:37.886]                           }
[17:03:37.886]                         }
[17:03:37.886]                       }
[17:03:37.886]                       invisible(muffled)
[17:03:37.886]                     }
[17:03:37.886]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.886]                   }
[17:03:37.886]                 }
[17:03:37.886]                 else {
[17:03:37.886]                   if (TRUE) {
[17:03:37.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.886]                     {
[17:03:37.886]                       inherits <- base::inherits
[17:03:37.886]                       invokeRestart <- base::invokeRestart
[17:03:37.886]                       is.null <- base::is.null
[17:03:37.886]                       muffled <- FALSE
[17:03:37.886]                       if (inherits(cond, "message")) {
[17:03:37.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.886]                         if (muffled) 
[17:03:37.886]                           invokeRestart("muffleMessage")
[17:03:37.886]                       }
[17:03:37.886]                       else if (inherits(cond, "warning")) {
[17:03:37.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.886]                         if (muffled) 
[17:03:37.886]                           invokeRestart("muffleWarning")
[17:03:37.886]                       }
[17:03:37.886]                       else if (inherits(cond, "condition")) {
[17:03:37.886]                         if (!is.null(pattern)) {
[17:03:37.886]                           computeRestarts <- base::computeRestarts
[17:03:37.886]                           grepl <- base::grepl
[17:03:37.886]                           restarts <- computeRestarts(cond)
[17:03:37.886]                           for (restart in restarts) {
[17:03:37.886]                             name <- restart$name
[17:03:37.886]                             if (is.null(name)) 
[17:03:37.886]                               next
[17:03:37.886]                             if (!grepl(pattern, name)) 
[17:03:37.886]                               next
[17:03:37.886]                             invokeRestart(restart)
[17:03:37.886]                             muffled <- TRUE
[17:03:37.886]                             break
[17:03:37.886]                           }
[17:03:37.886]                         }
[17:03:37.886]                       }
[17:03:37.886]                       invisible(muffled)
[17:03:37.886]                     }
[17:03:37.886]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.886]                   }
[17:03:37.886]                 }
[17:03:37.886]             }
[17:03:37.886]         }))
[17:03:37.886]     }, error = function(ex) {
[17:03:37.886]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.886]                 ...future.rng), started = ...future.startTime, 
[17:03:37.886]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.886]             version = "1.8"), class = "FutureResult")
[17:03:37.886]     }, finally = {
[17:03:37.886]         if (!identical(...future.workdir, getwd())) 
[17:03:37.886]             setwd(...future.workdir)
[17:03:37.886]         {
[17:03:37.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.886]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.886]             }
[17:03:37.886]             base::options(...future.oldOptions)
[17:03:37.886]             if (.Platform$OS.type == "windows") {
[17:03:37.886]                 old_names <- names(...future.oldEnvVars)
[17:03:37.886]                 envs <- base::Sys.getenv()
[17:03:37.886]                 names <- names(envs)
[17:03:37.886]                 common <- intersect(names, old_names)
[17:03:37.886]                 added <- setdiff(names, old_names)
[17:03:37.886]                 removed <- setdiff(old_names, names)
[17:03:37.886]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.886]                   envs[common]]
[17:03:37.886]                 NAMES <- toupper(changed)
[17:03:37.886]                 args <- list()
[17:03:37.886]                 for (kk in seq_along(NAMES)) {
[17:03:37.886]                   name <- changed[[kk]]
[17:03:37.886]                   NAME <- NAMES[[kk]]
[17:03:37.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.886]                     next
[17:03:37.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.886]                 }
[17:03:37.886]                 NAMES <- toupper(added)
[17:03:37.886]                 for (kk in seq_along(NAMES)) {
[17:03:37.886]                   name <- added[[kk]]
[17:03:37.886]                   NAME <- NAMES[[kk]]
[17:03:37.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.886]                     next
[17:03:37.886]                   args[[name]] <- ""
[17:03:37.886]                 }
[17:03:37.886]                 NAMES <- toupper(removed)
[17:03:37.886]                 for (kk in seq_along(NAMES)) {
[17:03:37.886]                   name <- removed[[kk]]
[17:03:37.886]                   NAME <- NAMES[[kk]]
[17:03:37.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.886]                     next
[17:03:37.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.886]                 }
[17:03:37.886]                 if (length(args) > 0) 
[17:03:37.886]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.886]             }
[17:03:37.886]             else {
[17:03:37.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.886]             }
[17:03:37.886]             {
[17:03:37.886]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.886]                   0L) {
[17:03:37.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.886]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.886]                   base::options(opts)
[17:03:37.886]                 }
[17:03:37.886]                 {
[17:03:37.886]                   {
[17:03:37.886]                     NULL
[17:03:37.886]                     RNGkind("Mersenne-Twister")
[17:03:37.886]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.886]                       inherits = FALSE)
[17:03:37.886]                   }
[17:03:37.886]                   options(future.plan = NULL)
[17:03:37.886]                   if (is.na(NA_character_)) 
[17:03:37.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.886]                     .init = FALSE)
[17:03:37.886]                 }
[17:03:37.886]             }
[17:03:37.886]         }
[17:03:37.886]     })
[17:03:37.886]     if (TRUE) {
[17:03:37.886]         base::sink(type = "output", split = FALSE)
[17:03:37.886]         if (TRUE) {
[17:03:37.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.886]         }
[17:03:37.886]         else {
[17:03:37.886]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.886]         }
[17:03:37.886]         base::close(...future.stdout)
[17:03:37.886]         ...future.stdout <- NULL
[17:03:37.886]     }
[17:03:37.886]     ...future.result$conditions <- ...future.conditions
[17:03:37.886]     ...future.result$finished <- base::Sys.time()
[17:03:37.886]     ...future.result
[17:03:37.886] }
[17:03:37.888] plan(): Setting new future strategy stack:
[17:03:37.888] List of future strategies:
[17:03:37.888] 1. sequential:
[17:03:37.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.888]    - tweaked: FALSE
[17:03:37.888]    - call: NULL
[17:03:37.888] plan(): nbrOfWorkers() = 1
[17:03:37.889] plan(): Setting new future strategy stack:
[17:03:37.889] List of future strategies:
[17:03:37.889] 1. sequential:
[17:03:37.889]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.889]    - tweaked: FALSE
[17:03:37.889]    - call: plan(strategy)
[17:03:37.889] plan(): nbrOfWorkers() = 1
[17:03:37.890] SequentialFuture started (and completed)
[17:03:37.890] - Launch lazy future ... done
[17:03:37.890] run() for ‘SequentialFuture’ ... done
[17:03:37.890] getGlobalsAndPackages() ...
[17:03:37.890] Searching for globals...
[17:03:37.891] - globals found: [1] ‘{’
[17:03:37.891] Searching for globals ... DONE
[17:03:37.891] Resolving globals: FALSE
[17:03:37.891] 
[17:03:37.891] 
[17:03:37.891] getGlobalsAndPackages() ... DONE
[17:03:37.892] run() for ‘Future’ ...
[17:03:37.892] - state: ‘created’
[17:03:37.892] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.892] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.892]   - Field: ‘label’
[17:03:37.892]   - Field: ‘local’
[17:03:37.892]   - Field: ‘owner’
[17:03:37.893]   - Field: ‘envir’
[17:03:37.893]   - Field: ‘packages’
[17:03:37.893]   - Field: ‘gc’
[17:03:37.893]   - Field: ‘conditions’
[17:03:37.893]   - Field: ‘expr’
[17:03:37.893]   - Field: ‘uuid’
[17:03:37.893]   - Field: ‘seed’
[17:03:37.893]   - Field: ‘version’
[17:03:37.893]   - Field: ‘result’
[17:03:37.893]   - Field: ‘asynchronous’
[17:03:37.893]   - Field: ‘calls’
[17:03:37.893]   - Field: ‘globals’
[17:03:37.894]   - Field: ‘stdout’
[17:03:37.894]   - Field: ‘earlySignal’
[17:03:37.894]   - Field: ‘lazy’
[17:03:37.894]   - Field: ‘state’
[17:03:37.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.894] - Launch lazy future ...
[17:03:37.894] Packages needed by the future expression (n = 0): <none>
[17:03:37.894] Packages needed by future strategies (n = 0): <none>
[17:03:37.895] {
[17:03:37.895]     {
[17:03:37.895]         {
[17:03:37.895]             ...future.startTime <- base::Sys.time()
[17:03:37.895]             {
[17:03:37.895]                 {
[17:03:37.895]                   {
[17:03:37.895]                     base::local({
[17:03:37.895]                       has_future <- base::requireNamespace("future", 
[17:03:37.895]                         quietly = TRUE)
[17:03:37.895]                       if (has_future) {
[17:03:37.895]                         ns <- base::getNamespace("future")
[17:03:37.895]                         version <- ns[[".package"]][["version"]]
[17:03:37.895]                         if (is.null(version)) 
[17:03:37.895]                           version <- utils::packageVersion("future")
[17:03:37.895]                       }
[17:03:37.895]                       else {
[17:03:37.895]                         version <- NULL
[17:03:37.895]                       }
[17:03:37.895]                       if (!has_future || version < "1.8.0") {
[17:03:37.895]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.895]                           "", base::R.version$version.string), 
[17:03:37.895]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.895]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.895]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.895]                             "release", "version")], collapse = " "), 
[17:03:37.895]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.895]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.895]                           info)
[17:03:37.895]                         info <- base::paste(info, collapse = "; ")
[17:03:37.895]                         if (!has_future) {
[17:03:37.895]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.895]                             info)
[17:03:37.895]                         }
[17:03:37.895]                         else {
[17:03:37.895]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.895]                             info, version)
[17:03:37.895]                         }
[17:03:37.895]                         base::stop(msg)
[17:03:37.895]                       }
[17:03:37.895]                     })
[17:03:37.895]                   }
[17:03:37.895]                   ...future.strategy.old <- future::plan("list")
[17:03:37.895]                   options(future.plan = NULL)
[17:03:37.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.895]                 }
[17:03:37.895]                 ...future.workdir <- getwd()
[17:03:37.895]             }
[17:03:37.895]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.895]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.895]         }
[17:03:37.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.895]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.895]             base::names(...future.oldOptions))
[17:03:37.895]     }
[17:03:37.895]     if (FALSE) {
[17:03:37.895]     }
[17:03:37.895]     else {
[17:03:37.895]         if (TRUE) {
[17:03:37.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.895]                 open = "w")
[17:03:37.895]         }
[17:03:37.895]         else {
[17:03:37.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.895]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.895]         }
[17:03:37.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.895]             base::sink(type = "output", split = FALSE)
[17:03:37.895]             base::close(...future.stdout)
[17:03:37.895]         }, add = TRUE)
[17:03:37.895]     }
[17:03:37.895]     ...future.frame <- base::sys.nframe()
[17:03:37.895]     ...future.conditions <- base::list()
[17:03:37.895]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.895]     if (FALSE) {
[17:03:37.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.895]     }
[17:03:37.895]     ...future.result <- base::tryCatch({
[17:03:37.895]         base::withCallingHandlers({
[17:03:37.895]             ...future.value <- base::withVisible(base::local({
[17:03:37.895]                 2
[17:03:37.895]             }))
[17:03:37.895]             future::FutureResult(value = ...future.value$value, 
[17:03:37.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.895]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.895]                     ...future.globalenv.names))
[17:03:37.895]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.895]         }, condition = base::local({
[17:03:37.895]             c <- base::c
[17:03:37.895]             inherits <- base::inherits
[17:03:37.895]             invokeRestart <- base::invokeRestart
[17:03:37.895]             length <- base::length
[17:03:37.895]             list <- base::list
[17:03:37.895]             seq.int <- base::seq.int
[17:03:37.895]             signalCondition <- base::signalCondition
[17:03:37.895]             sys.calls <- base::sys.calls
[17:03:37.895]             `[[` <- base::`[[`
[17:03:37.895]             `+` <- base::`+`
[17:03:37.895]             `<<-` <- base::`<<-`
[17:03:37.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.895]                   3L)]
[17:03:37.895]             }
[17:03:37.895]             function(cond) {
[17:03:37.895]                 is_error <- inherits(cond, "error")
[17:03:37.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.895]                   NULL)
[17:03:37.895]                 if (is_error) {
[17:03:37.895]                   sessionInformation <- function() {
[17:03:37.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.895]                       search = base::search(), system = base::Sys.info())
[17:03:37.895]                   }
[17:03:37.895]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.895]                     cond$call), session = sessionInformation(), 
[17:03:37.895]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.895]                   signalCondition(cond)
[17:03:37.895]                 }
[17:03:37.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.895]                 "immediateCondition"))) {
[17:03:37.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.895]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.895]                   if (TRUE && !signal) {
[17:03:37.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.895]                     {
[17:03:37.895]                       inherits <- base::inherits
[17:03:37.895]                       invokeRestart <- base::invokeRestart
[17:03:37.895]                       is.null <- base::is.null
[17:03:37.895]                       muffled <- FALSE
[17:03:37.895]                       if (inherits(cond, "message")) {
[17:03:37.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.895]                         if (muffled) 
[17:03:37.895]                           invokeRestart("muffleMessage")
[17:03:37.895]                       }
[17:03:37.895]                       else if (inherits(cond, "warning")) {
[17:03:37.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.895]                         if (muffled) 
[17:03:37.895]                           invokeRestart("muffleWarning")
[17:03:37.895]                       }
[17:03:37.895]                       else if (inherits(cond, "condition")) {
[17:03:37.895]                         if (!is.null(pattern)) {
[17:03:37.895]                           computeRestarts <- base::computeRestarts
[17:03:37.895]                           grepl <- base::grepl
[17:03:37.895]                           restarts <- computeRestarts(cond)
[17:03:37.895]                           for (restart in restarts) {
[17:03:37.895]                             name <- restart$name
[17:03:37.895]                             if (is.null(name)) 
[17:03:37.895]                               next
[17:03:37.895]                             if (!grepl(pattern, name)) 
[17:03:37.895]                               next
[17:03:37.895]                             invokeRestart(restart)
[17:03:37.895]                             muffled <- TRUE
[17:03:37.895]                             break
[17:03:37.895]                           }
[17:03:37.895]                         }
[17:03:37.895]                       }
[17:03:37.895]                       invisible(muffled)
[17:03:37.895]                     }
[17:03:37.895]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.895]                   }
[17:03:37.895]                 }
[17:03:37.895]                 else {
[17:03:37.895]                   if (TRUE) {
[17:03:37.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.895]                     {
[17:03:37.895]                       inherits <- base::inherits
[17:03:37.895]                       invokeRestart <- base::invokeRestart
[17:03:37.895]                       is.null <- base::is.null
[17:03:37.895]                       muffled <- FALSE
[17:03:37.895]                       if (inherits(cond, "message")) {
[17:03:37.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.895]                         if (muffled) 
[17:03:37.895]                           invokeRestart("muffleMessage")
[17:03:37.895]                       }
[17:03:37.895]                       else if (inherits(cond, "warning")) {
[17:03:37.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.895]                         if (muffled) 
[17:03:37.895]                           invokeRestart("muffleWarning")
[17:03:37.895]                       }
[17:03:37.895]                       else if (inherits(cond, "condition")) {
[17:03:37.895]                         if (!is.null(pattern)) {
[17:03:37.895]                           computeRestarts <- base::computeRestarts
[17:03:37.895]                           grepl <- base::grepl
[17:03:37.895]                           restarts <- computeRestarts(cond)
[17:03:37.895]                           for (restart in restarts) {
[17:03:37.895]                             name <- restart$name
[17:03:37.895]                             if (is.null(name)) 
[17:03:37.895]                               next
[17:03:37.895]                             if (!grepl(pattern, name)) 
[17:03:37.895]                               next
[17:03:37.895]                             invokeRestart(restart)
[17:03:37.895]                             muffled <- TRUE
[17:03:37.895]                             break
[17:03:37.895]                           }
[17:03:37.895]                         }
[17:03:37.895]                       }
[17:03:37.895]                       invisible(muffled)
[17:03:37.895]                     }
[17:03:37.895]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.895]                   }
[17:03:37.895]                 }
[17:03:37.895]             }
[17:03:37.895]         }))
[17:03:37.895]     }, error = function(ex) {
[17:03:37.895]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.895]                 ...future.rng), started = ...future.startTime, 
[17:03:37.895]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.895]             version = "1.8"), class = "FutureResult")
[17:03:37.895]     }, finally = {
[17:03:37.895]         if (!identical(...future.workdir, getwd())) 
[17:03:37.895]             setwd(...future.workdir)
[17:03:37.895]         {
[17:03:37.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.895]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.895]             }
[17:03:37.895]             base::options(...future.oldOptions)
[17:03:37.895]             if (.Platform$OS.type == "windows") {
[17:03:37.895]                 old_names <- names(...future.oldEnvVars)
[17:03:37.895]                 envs <- base::Sys.getenv()
[17:03:37.895]                 names <- names(envs)
[17:03:37.895]                 common <- intersect(names, old_names)
[17:03:37.895]                 added <- setdiff(names, old_names)
[17:03:37.895]                 removed <- setdiff(old_names, names)
[17:03:37.895]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.895]                   envs[common]]
[17:03:37.895]                 NAMES <- toupper(changed)
[17:03:37.895]                 args <- list()
[17:03:37.895]                 for (kk in seq_along(NAMES)) {
[17:03:37.895]                   name <- changed[[kk]]
[17:03:37.895]                   NAME <- NAMES[[kk]]
[17:03:37.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.895]                     next
[17:03:37.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.895]                 }
[17:03:37.895]                 NAMES <- toupper(added)
[17:03:37.895]                 for (kk in seq_along(NAMES)) {
[17:03:37.895]                   name <- added[[kk]]
[17:03:37.895]                   NAME <- NAMES[[kk]]
[17:03:37.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.895]                     next
[17:03:37.895]                   args[[name]] <- ""
[17:03:37.895]                 }
[17:03:37.895]                 NAMES <- toupper(removed)
[17:03:37.895]                 for (kk in seq_along(NAMES)) {
[17:03:37.895]                   name <- removed[[kk]]
[17:03:37.895]                   NAME <- NAMES[[kk]]
[17:03:37.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.895]                     next
[17:03:37.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.895]                 }
[17:03:37.895]                 if (length(args) > 0) 
[17:03:37.895]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.895]             }
[17:03:37.895]             else {
[17:03:37.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.895]             }
[17:03:37.895]             {
[17:03:37.895]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.895]                   0L) {
[17:03:37.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.895]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.895]                   base::options(opts)
[17:03:37.895]                 }
[17:03:37.895]                 {
[17:03:37.895]                   {
[17:03:37.895]                     NULL
[17:03:37.895]                     RNGkind("Mersenne-Twister")
[17:03:37.895]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.895]                       inherits = FALSE)
[17:03:37.895]                   }
[17:03:37.895]                   options(future.plan = NULL)
[17:03:37.895]                   if (is.na(NA_character_)) 
[17:03:37.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.895]                     .init = FALSE)
[17:03:37.895]                 }
[17:03:37.895]             }
[17:03:37.895]         }
[17:03:37.895]     })
[17:03:37.895]     if (TRUE) {
[17:03:37.895]         base::sink(type = "output", split = FALSE)
[17:03:37.895]         if (TRUE) {
[17:03:37.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.895]         }
[17:03:37.895]         else {
[17:03:37.895]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.895]         }
[17:03:37.895]         base::close(...future.stdout)
[17:03:37.895]         ...future.stdout <- NULL
[17:03:37.895]     }
[17:03:37.895]     ...future.result$conditions <- ...future.conditions
[17:03:37.895]     ...future.result$finished <- base::Sys.time()
[17:03:37.895]     ...future.result
[17:03:37.895] }
[17:03:37.896] plan(): Setting new future strategy stack:
[17:03:37.897] List of future strategies:
[17:03:37.897] 1. sequential:
[17:03:37.897]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.897]    - tweaked: FALSE
[17:03:37.897]    - call: NULL
[17:03:37.897] plan(): nbrOfWorkers() = 1
[17:03:37.898] plan(): Setting new future strategy stack:
[17:03:37.898] List of future strategies:
[17:03:37.898] 1. sequential:
[17:03:37.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.898]    - tweaked: FALSE
[17:03:37.898]    - call: plan(strategy)
[17:03:37.898] plan(): nbrOfWorkers() = 1
[17:03:37.898] SequentialFuture started (and completed)
[17:03:37.898] - Launch lazy future ... done
[17:03:37.898] run() for ‘SequentialFuture’ ... done
[17:03:37.899] resolve() on environment ...
[17:03:37.899]  recursive: 0
[17:03:37.900]  elements: [3] ‘a’
[17:03:37.900] resolved() for ‘SequentialFuture’ ...
[17:03:37.900] - state: ‘finished’
[17:03:37.900] - run: TRUE
[17:03:37.900] - result: ‘FutureResult’
[17:03:37.900] resolved() for ‘SequentialFuture’ ... done
[17:03:37.900] Future #1
[17:03:37.900]  length: 2 (resolved future 1)
[17:03:37.900] resolved() for ‘SequentialFuture’ ...
[17:03:37.900] - state: ‘finished’
[17:03:37.900] - run: TRUE
[17:03:37.901] - result: ‘FutureResult’
[17:03:37.901] resolved() for ‘SequentialFuture’ ... done
[17:03:37.901] Future #2
[17:03:37.901]  length: 1 (resolved future 2)
[17:03:37.901]  length: 0 (resolved future 3)
[17:03:37.901] resolve() on environment ... DONE
[17:03:37.901] resolved() for ‘SequentialFuture’ ...
[17:03:37.901] - state: ‘finished’
[17:03:37.901] - run: TRUE
[17:03:37.901] - result: ‘FutureResult’
[17:03:37.902] resolved() for ‘SequentialFuture’ ... done
[17:03:37.902] resolve() on environment ...
[17:03:37.902]  recursive: 0
[17:03:37.902]  elements: [3] ‘b’
[17:03:37.903] resolved() for ‘SequentialFuture’ ...
[17:03:37.903] - state: ‘finished’
[17:03:37.903] - run: TRUE
[17:03:37.903] - result: ‘FutureResult’
[17:03:37.903] resolved() for ‘SequentialFuture’ ... done
[17:03:37.903] Future #1
[17:03:37.903]  length: 2 (resolved future 1)
[17:03:37.903] resolved() for ‘SequentialFuture’ ...
[17:03:37.903] - state: ‘finished’
[17:03:37.903] - run: TRUE
[17:03:37.904] - result: ‘FutureResult’
[17:03:37.904] resolved() for ‘SequentialFuture’ ... done
[17:03:37.904] Future #2
[17:03:37.904]  length: 1 (resolved future 2)
[17:03:37.904]  length: 0 (resolved future 3)
[17:03:37.904] resolve() on environment ... DONE
[17:03:37.906] resolve() on environment ...
[17:03:37.906]  recursive: 0
[17:03:37.907]  elements: [3] ‘c’
[17:03:37.907] resolved() for ‘SequentialFuture’ ...
[17:03:37.907] - state: ‘finished’
[17:03:37.907] - run: TRUE
[17:03:37.907] - result: ‘FutureResult’
[17:03:37.907] resolved() for ‘SequentialFuture’ ... done
[17:03:37.908] Future #1
[17:03:37.908]  length: 2 (resolved future 1)
[17:03:37.908] resolved() for ‘SequentialFuture’ ...
[17:03:37.908] - state: ‘finished’
[17:03:37.908] - run: TRUE
[17:03:37.908] - result: ‘FutureResult’
[17:03:37.908] resolved() for ‘SequentialFuture’ ... done
[17:03:37.908] Future #2
[17:03:37.908]  length: 1 (resolved future 2)
[17:03:37.908]  length: 0 (resolved future 3)
[17:03:37.908] resolve() on environment ... DONE
[17:03:37.909] resolve() on environment ...
[17:03:37.909]  recursive: 0
[17:03:37.909]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:03:37.910] resolved() for ‘SequentialFuture’ ...
[17:03:37.910] - state: ‘finished’
[17:03:37.910] - run: TRUE
[17:03:37.910] - result: ‘FutureResult’
[17:03:37.910] resolved() for ‘SequentialFuture’ ... done
[17:03:37.910] Future #1
[17:03:37.910]  length: 2 (resolved future 1)
[17:03:37.911] resolved() for ‘SequentialFuture’ ...
[17:03:37.911] - state: ‘finished’
[17:03:37.911] - run: TRUE
[17:03:37.911] - result: ‘FutureResult’
[17:03:37.911] resolved() for ‘SequentialFuture’ ... done
[17:03:37.911] Future #2
[17:03:37.911]  length: 1 (resolved future 2)
[17:03:37.911]  length: 0 (resolved future 3)
[17:03:37.911] resolve() on environment ... DONE
[17:03:37.912] resolve() on environment ...
[17:03:37.912]  recursive: 99
[17:03:37.912]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:03:37.913] resolved() for ‘SequentialFuture’ ...
[17:03:37.913] - state: ‘finished’
[17:03:37.913] - run: TRUE
[17:03:37.913] - result: ‘FutureResult’
[17:03:37.913] resolved() for ‘SequentialFuture’ ... done
[17:03:37.913] Future #1
[17:03:37.913] resolved() for ‘SequentialFuture’ ...
[17:03:37.913] - state: ‘finished’
[17:03:37.913] - run: TRUE
[17:03:37.913] - result: ‘FutureResult’
[17:03:37.913] resolved() for ‘SequentialFuture’ ... done
[17:03:37.914] A SequentialFuture was resolved
[17:03:37.914]  length: 2 (resolved future 1)
[17:03:37.914] resolved() for ‘SequentialFuture’ ...
[17:03:37.914] - state: ‘finished’
[17:03:37.914] - run: TRUE
[17:03:37.914] - result: ‘FutureResult’
[17:03:37.914] resolved() for ‘SequentialFuture’ ... done
[17:03:37.914] Future #2
[17:03:37.914] resolved() for ‘SequentialFuture’ ...
[17:03:37.914] - state: ‘finished’
[17:03:37.915] - run: TRUE
[17:03:37.915] - result: ‘FutureResult’
[17:03:37.915] resolved() for ‘SequentialFuture’ ... done
[17:03:37.915] A SequentialFuture was resolved
[17:03:37.915]  length: 1 (resolved future 2)
[17:03:37.915]  length: 0 (resolved future 3)
[17:03:37.915] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:03:37.916] resolve() on list environment ...
[17:03:37.916]  recursive: 0
[17:03:37.917]  length: 2
[17:03:37.917]  elements: ‘a’, ‘b’
[17:03:37.917]  length: 1 (resolved future 1)
[17:03:37.917]  length: 0 (resolved future 2)
[17:03:37.918] resolve() on list environment ... DONE
[17:03:37.918] getGlobalsAndPackages() ...
[17:03:37.918] Searching for globals...
[17:03:37.918] 
[17:03:37.918] Searching for globals ... DONE
[17:03:37.918] - globals: [0] <none>
[17:03:37.918] getGlobalsAndPackages() ... DONE
[17:03:37.918] run() for ‘Future’ ...
[17:03:37.919] - state: ‘created’
[17:03:37.919] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.919] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.919]   - Field: ‘label’
[17:03:37.919]   - Field: ‘local’
[17:03:37.919]   - Field: ‘owner’
[17:03:37.919]   - Field: ‘envir’
[17:03:37.920]   - Field: ‘packages’
[17:03:37.920]   - Field: ‘gc’
[17:03:37.920]   - Field: ‘conditions’
[17:03:37.920]   - Field: ‘expr’
[17:03:37.920]   - Field: ‘uuid’
[17:03:37.920]   - Field: ‘seed’
[17:03:37.920]   - Field: ‘version’
[17:03:37.920]   - Field: ‘result’
[17:03:37.920]   - Field: ‘asynchronous’
[17:03:37.920]   - Field: ‘calls’
[17:03:37.920]   - Field: ‘globals’
[17:03:37.921]   - Field: ‘stdout’
[17:03:37.921]   - Field: ‘earlySignal’
[17:03:37.921]   - Field: ‘lazy’
[17:03:37.921]   - Field: ‘state’
[17:03:37.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.921] - Launch lazy future ...
[17:03:37.921] Packages needed by the future expression (n = 0): <none>
[17:03:37.921] Packages needed by future strategies (n = 0): <none>
[17:03:37.922] {
[17:03:37.922]     {
[17:03:37.922]         {
[17:03:37.922]             ...future.startTime <- base::Sys.time()
[17:03:37.922]             {
[17:03:37.922]                 {
[17:03:37.922]                   {
[17:03:37.922]                     base::local({
[17:03:37.922]                       has_future <- base::requireNamespace("future", 
[17:03:37.922]                         quietly = TRUE)
[17:03:37.922]                       if (has_future) {
[17:03:37.922]                         ns <- base::getNamespace("future")
[17:03:37.922]                         version <- ns[[".package"]][["version"]]
[17:03:37.922]                         if (is.null(version)) 
[17:03:37.922]                           version <- utils::packageVersion("future")
[17:03:37.922]                       }
[17:03:37.922]                       else {
[17:03:37.922]                         version <- NULL
[17:03:37.922]                       }
[17:03:37.922]                       if (!has_future || version < "1.8.0") {
[17:03:37.922]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.922]                           "", base::R.version$version.string), 
[17:03:37.922]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.922]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.922]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.922]                             "release", "version")], collapse = " "), 
[17:03:37.922]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.922]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.922]                           info)
[17:03:37.922]                         info <- base::paste(info, collapse = "; ")
[17:03:37.922]                         if (!has_future) {
[17:03:37.922]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.922]                             info)
[17:03:37.922]                         }
[17:03:37.922]                         else {
[17:03:37.922]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.922]                             info, version)
[17:03:37.922]                         }
[17:03:37.922]                         base::stop(msg)
[17:03:37.922]                       }
[17:03:37.922]                     })
[17:03:37.922]                   }
[17:03:37.922]                   ...future.strategy.old <- future::plan("list")
[17:03:37.922]                   options(future.plan = NULL)
[17:03:37.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.922]                 }
[17:03:37.922]                 ...future.workdir <- getwd()
[17:03:37.922]             }
[17:03:37.922]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.922]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.922]         }
[17:03:37.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.922]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.922]             base::names(...future.oldOptions))
[17:03:37.922]     }
[17:03:37.922]     if (FALSE) {
[17:03:37.922]     }
[17:03:37.922]     else {
[17:03:37.922]         if (TRUE) {
[17:03:37.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.922]                 open = "w")
[17:03:37.922]         }
[17:03:37.922]         else {
[17:03:37.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.922]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.922]         }
[17:03:37.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.922]             base::sink(type = "output", split = FALSE)
[17:03:37.922]             base::close(...future.stdout)
[17:03:37.922]         }, add = TRUE)
[17:03:37.922]     }
[17:03:37.922]     ...future.frame <- base::sys.nframe()
[17:03:37.922]     ...future.conditions <- base::list()
[17:03:37.922]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.922]     if (FALSE) {
[17:03:37.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.922]     }
[17:03:37.922]     ...future.result <- base::tryCatch({
[17:03:37.922]         base::withCallingHandlers({
[17:03:37.922]             ...future.value <- base::withVisible(base::local(1))
[17:03:37.922]             future::FutureResult(value = ...future.value$value, 
[17:03:37.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.922]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.922]                     ...future.globalenv.names))
[17:03:37.922]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.922]         }, condition = base::local({
[17:03:37.922]             c <- base::c
[17:03:37.922]             inherits <- base::inherits
[17:03:37.922]             invokeRestart <- base::invokeRestart
[17:03:37.922]             length <- base::length
[17:03:37.922]             list <- base::list
[17:03:37.922]             seq.int <- base::seq.int
[17:03:37.922]             signalCondition <- base::signalCondition
[17:03:37.922]             sys.calls <- base::sys.calls
[17:03:37.922]             `[[` <- base::`[[`
[17:03:37.922]             `+` <- base::`+`
[17:03:37.922]             `<<-` <- base::`<<-`
[17:03:37.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.922]                   3L)]
[17:03:37.922]             }
[17:03:37.922]             function(cond) {
[17:03:37.922]                 is_error <- inherits(cond, "error")
[17:03:37.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.922]                   NULL)
[17:03:37.922]                 if (is_error) {
[17:03:37.922]                   sessionInformation <- function() {
[17:03:37.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.922]                       search = base::search(), system = base::Sys.info())
[17:03:37.922]                   }
[17:03:37.922]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.922]                     cond$call), session = sessionInformation(), 
[17:03:37.922]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.922]                   signalCondition(cond)
[17:03:37.922]                 }
[17:03:37.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.922]                 "immediateCondition"))) {
[17:03:37.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.922]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.922]                   if (TRUE && !signal) {
[17:03:37.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.922]                     {
[17:03:37.922]                       inherits <- base::inherits
[17:03:37.922]                       invokeRestart <- base::invokeRestart
[17:03:37.922]                       is.null <- base::is.null
[17:03:37.922]                       muffled <- FALSE
[17:03:37.922]                       if (inherits(cond, "message")) {
[17:03:37.922]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.922]                         if (muffled) 
[17:03:37.922]                           invokeRestart("muffleMessage")
[17:03:37.922]                       }
[17:03:37.922]                       else if (inherits(cond, "warning")) {
[17:03:37.922]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.922]                         if (muffled) 
[17:03:37.922]                           invokeRestart("muffleWarning")
[17:03:37.922]                       }
[17:03:37.922]                       else if (inherits(cond, "condition")) {
[17:03:37.922]                         if (!is.null(pattern)) {
[17:03:37.922]                           computeRestarts <- base::computeRestarts
[17:03:37.922]                           grepl <- base::grepl
[17:03:37.922]                           restarts <- computeRestarts(cond)
[17:03:37.922]                           for (restart in restarts) {
[17:03:37.922]                             name <- restart$name
[17:03:37.922]                             if (is.null(name)) 
[17:03:37.922]                               next
[17:03:37.922]                             if (!grepl(pattern, name)) 
[17:03:37.922]                               next
[17:03:37.922]                             invokeRestart(restart)
[17:03:37.922]                             muffled <- TRUE
[17:03:37.922]                             break
[17:03:37.922]                           }
[17:03:37.922]                         }
[17:03:37.922]                       }
[17:03:37.922]                       invisible(muffled)
[17:03:37.922]                     }
[17:03:37.922]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.922]                   }
[17:03:37.922]                 }
[17:03:37.922]                 else {
[17:03:37.922]                   if (TRUE) {
[17:03:37.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.922]                     {
[17:03:37.922]                       inherits <- base::inherits
[17:03:37.922]                       invokeRestart <- base::invokeRestart
[17:03:37.922]                       is.null <- base::is.null
[17:03:37.922]                       muffled <- FALSE
[17:03:37.922]                       if (inherits(cond, "message")) {
[17:03:37.922]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.922]                         if (muffled) 
[17:03:37.922]                           invokeRestart("muffleMessage")
[17:03:37.922]                       }
[17:03:37.922]                       else if (inherits(cond, "warning")) {
[17:03:37.922]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.922]                         if (muffled) 
[17:03:37.922]                           invokeRestart("muffleWarning")
[17:03:37.922]                       }
[17:03:37.922]                       else if (inherits(cond, "condition")) {
[17:03:37.922]                         if (!is.null(pattern)) {
[17:03:37.922]                           computeRestarts <- base::computeRestarts
[17:03:37.922]                           grepl <- base::grepl
[17:03:37.922]                           restarts <- computeRestarts(cond)
[17:03:37.922]                           for (restart in restarts) {
[17:03:37.922]                             name <- restart$name
[17:03:37.922]                             if (is.null(name)) 
[17:03:37.922]                               next
[17:03:37.922]                             if (!grepl(pattern, name)) 
[17:03:37.922]                               next
[17:03:37.922]                             invokeRestart(restart)
[17:03:37.922]                             muffled <- TRUE
[17:03:37.922]                             break
[17:03:37.922]                           }
[17:03:37.922]                         }
[17:03:37.922]                       }
[17:03:37.922]                       invisible(muffled)
[17:03:37.922]                     }
[17:03:37.922]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.922]                   }
[17:03:37.922]                 }
[17:03:37.922]             }
[17:03:37.922]         }))
[17:03:37.922]     }, error = function(ex) {
[17:03:37.922]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.922]                 ...future.rng), started = ...future.startTime, 
[17:03:37.922]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.922]             version = "1.8"), class = "FutureResult")
[17:03:37.922]     }, finally = {
[17:03:37.922]         if (!identical(...future.workdir, getwd())) 
[17:03:37.922]             setwd(...future.workdir)
[17:03:37.922]         {
[17:03:37.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.922]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.922]             }
[17:03:37.922]             base::options(...future.oldOptions)
[17:03:37.922]             if (.Platform$OS.type == "windows") {
[17:03:37.922]                 old_names <- names(...future.oldEnvVars)
[17:03:37.922]                 envs <- base::Sys.getenv()
[17:03:37.922]                 names <- names(envs)
[17:03:37.922]                 common <- intersect(names, old_names)
[17:03:37.922]                 added <- setdiff(names, old_names)
[17:03:37.922]                 removed <- setdiff(old_names, names)
[17:03:37.922]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.922]                   envs[common]]
[17:03:37.922]                 NAMES <- toupper(changed)
[17:03:37.922]                 args <- list()
[17:03:37.922]                 for (kk in seq_along(NAMES)) {
[17:03:37.922]                   name <- changed[[kk]]
[17:03:37.922]                   NAME <- NAMES[[kk]]
[17:03:37.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.922]                     next
[17:03:37.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.922]                 }
[17:03:37.922]                 NAMES <- toupper(added)
[17:03:37.922]                 for (kk in seq_along(NAMES)) {
[17:03:37.922]                   name <- added[[kk]]
[17:03:37.922]                   NAME <- NAMES[[kk]]
[17:03:37.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.922]                     next
[17:03:37.922]                   args[[name]] <- ""
[17:03:37.922]                 }
[17:03:37.922]                 NAMES <- toupper(removed)
[17:03:37.922]                 for (kk in seq_along(NAMES)) {
[17:03:37.922]                   name <- removed[[kk]]
[17:03:37.922]                   NAME <- NAMES[[kk]]
[17:03:37.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.922]                     next
[17:03:37.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.922]                 }
[17:03:37.922]                 if (length(args) > 0) 
[17:03:37.922]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.922]             }
[17:03:37.922]             else {
[17:03:37.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.922]             }
[17:03:37.922]             {
[17:03:37.922]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.922]                   0L) {
[17:03:37.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.922]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.922]                   base::options(opts)
[17:03:37.922]                 }
[17:03:37.922]                 {
[17:03:37.922]                   {
[17:03:37.922]                     NULL
[17:03:37.922]                     RNGkind("Mersenne-Twister")
[17:03:37.922]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.922]                       inherits = FALSE)
[17:03:37.922]                   }
[17:03:37.922]                   options(future.plan = NULL)
[17:03:37.922]                   if (is.na(NA_character_)) 
[17:03:37.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.922]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.922]                     .init = FALSE)
[17:03:37.922]                 }
[17:03:37.922]             }
[17:03:37.922]         }
[17:03:37.922]     })
[17:03:37.922]     if (TRUE) {
[17:03:37.922]         base::sink(type = "output", split = FALSE)
[17:03:37.922]         if (TRUE) {
[17:03:37.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.922]         }
[17:03:37.922]         else {
[17:03:37.922]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.922]         }
[17:03:37.922]         base::close(...future.stdout)
[17:03:37.922]         ...future.stdout <- NULL
[17:03:37.922]     }
[17:03:37.922]     ...future.result$conditions <- ...future.conditions
[17:03:37.922]     ...future.result$finished <- base::Sys.time()
[17:03:37.922]     ...future.result
[17:03:37.922] }
[17:03:37.923] plan(): Setting new future strategy stack:
[17:03:37.924] List of future strategies:
[17:03:37.924] 1. sequential:
[17:03:37.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.924]    - tweaked: FALSE
[17:03:37.924]    - call: NULL
[17:03:37.924] plan(): nbrOfWorkers() = 1
[17:03:37.925] plan(): Setting new future strategy stack:
[17:03:37.925] List of future strategies:
[17:03:37.925] 1. sequential:
[17:03:37.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.925]    - tweaked: FALSE
[17:03:37.925]    - call: plan(strategy)
[17:03:37.925] plan(): nbrOfWorkers() = 1
[17:03:37.925] SequentialFuture started (and completed)
[17:03:37.925] - Launch lazy future ... done
[17:03:37.926] run() for ‘SequentialFuture’ ... done
[17:03:37.926] getGlobalsAndPackages() ...
[17:03:37.926] Searching for globals...
[17:03:37.926] 
[17:03:37.926] Searching for globals ... DONE
[17:03:37.926] - globals: [0] <none>
[17:03:37.926] getGlobalsAndPackages() ... DONE
[17:03:37.927] run() for ‘Future’ ...
[17:03:37.927] - state: ‘created’
[17:03:37.927] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.927] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.927] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.927]   - Field: ‘label’
[17:03:37.927]   - Field: ‘local’
[17:03:37.927]   - Field: ‘owner’
[17:03:37.927]   - Field: ‘envir’
[17:03:37.928]   - Field: ‘packages’
[17:03:37.928]   - Field: ‘gc’
[17:03:37.928]   - Field: ‘conditions’
[17:03:37.928]   - Field: ‘expr’
[17:03:37.928]   - Field: ‘uuid’
[17:03:37.928]   - Field: ‘seed’
[17:03:37.928]   - Field: ‘version’
[17:03:37.928]   - Field: ‘result’
[17:03:37.928]   - Field: ‘asynchronous’
[17:03:37.928]   - Field: ‘calls’
[17:03:37.928]   - Field: ‘globals’
[17:03:37.929]   - Field: ‘stdout’
[17:03:37.929]   - Field: ‘earlySignal’
[17:03:37.929]   - Field: ‘lazy’
[17:03:37.929]   - Field: ‘state’
[17:03:37.929] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.929] - Launch lazy future ...
[17:03:37.929] Packages needed by the future expression (n = 0): <none>
[17:03:37.929] Packages needed by future strategies (n = 0): <none>
[17:03:37.930] {
[17:03:37.930]     {
[17:03:37.930]         {
[17:03:37.930]             ...future.startTime <- base::Sys.time()
[17:03:37.930]             {
[17:03:37.930]                 {
[17:03:37.930]                   {
[17:03:37.930]                     base::local({
[17:03:37.930]                       has_future <- base::requireNamespace("future", 
[17:03:37.930]                         quietly = TRUE)
[17:03:37.930]                       if (has_future) {
[17:03:37.930]                         ns <- base::getNamespace("future")
[17:03:37.930]                         version <- ns[[".package"]][["version"]]
[17:03:37.930]                         if (is.null(version)) 
[17:03:37.930]                           version <- utils::packageVersion("future")
[17:03:37.930]                       }
[17:03:37.930]                       else {
[17:03:37.930]                         version <- NULL
[17:03:37.930]                       }
[17:03:37.930]                       if (!has_future || version < "1.8.0") {
[17:03:37.930]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.930]                           "", base::R.version$version.string), 
[17:03:37.930]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.930]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.930]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.930]                             "release", "version")], collapse = " "), 
[17:03:37.930]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.930]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.930]                           info)
[17:03:37.930]                         info <- base::paste(info, collapse = "; ")
[17:03:37.930]                         if (!has_future) {
[17:03:37.930]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.930]                             info)
[17:03:37.930]                         }
[17:03:37.930]                         else {
[17:03:37.930]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.930]                             info, version)
[17:03:37.930]                         }
[17:03:37.930]                         base::stop(msg)
[17:03:37.930]                       }
[17:03:37.930]                     })
[17:03:37.930]                   }
[17:03:37.930]                   ...future.strategy.old <- future::plan("list")
[17:03:37.930]                   options(future.plan = NULL)
[17:03:37.930]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.930]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.930]                 }
[17:03:37.930]                 ...future.workdir <- getwd()
[17:03:37.930]             }
[17:03:37.930]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.930]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.930]         }
[17:03:37.930]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.930]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.930]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.930]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.930]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.930]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.930]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.930]             base::names(...future.oldOptions))
[17:03:37.930]     }
[17:03:37.930]     if (FALSE) {
[17:03:37.930]     }
[17:03:37.930]     else {
[17:03:37.930]         if (TRUE) {
[17:03:37.930]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.930]                 open = "w")
[17:03:37.930]         }
[17:03:37.930]         else {
[17:03:37.930]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.930]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.930]         }
[17:03:37.930]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.930]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.930]             base::sink(type = "output", split = FALSE)
[17:03:37.930]             base::close(...future.stdout)
[17:03:37.930]         }, add = TRUE)
[17:03:37.930]     }
[17:03:37.930]     ...future.frame <- base::sys.nframe()
[17:03:37.930]     ...future.conditions <- base::list()
[17:03:37.930]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.930]     if (FALSE) {
[17:03:37.930]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.930]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.930]     }
[17:03:37.930]     ...future.result <- base::tryCatch({
[17:03:37.930]         base::withCallingHandlers({
[17:03:37.930]             ...future.value <- base::withVisible(base::local(2))
[17:03:37.930]             future::FutureResult(value = ...future.value$value, 
[17:03:37.930]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.930]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.930]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.930]                     ...future.globalenv.names))
[17:03:37.930]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.930]         }, condition = base::local({
[17:03:37.930]             c <- base::c
[17:03:37.930]             inherits <- base::inherits
[17:03:37.930]             invokeRestart <- base::invokeRestart
[17:03:37.930]             length <- base::length
[17:03:37.930]             list <- base::list
[17:03:37.930]             seq.int <- base::seq.int
[17:03:37.930]             signalCondition <- base::signalCondition
[17:03:37.930]             sys.calls <- base::sys.calls
[17:03:37.930]             `[[` <- base::`[[`
[17:03:37.930]             `+` <- base::`+`
[17:03:37.930]             `<<-` <- base::`<<-`
[17:03:37.930]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.930]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.930]                   3L)]
[17:03:37.930]             }
[17:03:37.930]             function(cond) {
[17:03:37.930]                 is_error <- inherits(cond, "error")
[17:03:37.930]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.930]                   NULL)
[17:03:37.930]                 if (is_error) {
[17:03:37.930]                   sessionInformation <- function() {
[17:03:37.930]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.930]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.930]                       search = base::search(), system = base::Sys.info())
[17:03:37.930]                   }
[17:03:37.930]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.930]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.930]                     cond$call), session = sessionInformation(), 
[17:03:37.930]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.930]                   signalCondition(cond)
[17:03:37.930]                 }
[17:03:37.930]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.930]                 "immediateCondition"))) {
[17:03:37.930]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.930]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.930]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.930]                   if (TRUE && !signal) {
[17:03:37.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.930]                     {
[17:03:37.930]                       inherits <- base::inherits
[17:03:37.930]                       invokeRestart <- base::invokeRestart
[17:03:37.930]                       is.null <- base::is.null
[17:03:37.930]                       muffled <- FALSE
[17:03:37.930]                       if (inherits(cond, "message")) {
[17:03:37.930]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.930]                         if (muffled) 
[17:03:37.930]                           invokeRestart("muffleMessage")
[17:03:37.930]                       }
[17:03:37.930]                       else if (inherits(cond, "warning")) {
[17:03:37.930]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.930]                         if (muffled) 
[17:03:37.930]                           invokeRestart("muffleWarning")
[17:03:37.930]                       }
[17:03:37.930]                       else if (inherits(cond, "condition")) {
[17:03:37.930]                         if (!is.null(pattern)) {
[17:03:37.930]                           computeRestarts <- base::computeRestarts
[17:03:37.930]                           grepl <- base::grepl
[17:03:37.930]                           restarts <- computeRestarts(cond)
[17:03:37.930]                           for (restart in restarts) {
[17:03:37.930]                             name <- restart$name
[17:03:37.930]                             if (is.null(name)) 
[17:03:37.930]                               next
[17:03:37.930]                             if (!grepl(pattern, name)) 
[17:03:37.930]                               next
[17:03:37.930]                             invokeRestart(restart)
[17:03:37.930]                             muffled <- TRUE
[17:03:37.930]                             break
[17:03:37.930]                           }
[17:03:37.930]                         }
[17:03:37.930]                       }
[17:03:37.930]                       invisible(muffled)
[17:03:37.930]                     }
[17:03:37.930]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.930]                   }
[17:03:37.930]                 }
[17:03:37.930]                 else {
[17:03:37.930]                   if (TRUE) {
[17:03:37.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.930]                     {
[17:03:37.930]                       inherits <- base::inherits
[17:03:37.930]                       invokeRestart <- base::invokeRestart
[17:03:37.930]                       is.null <- base::is.null
[17:03:37.930]                       muffled <- FALSE
[17:03:37.930]                       if (inherits(cond, "message")) {
[17:03:37.930]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.930]                         if (muffled) 
[17:03:37.930]                           invokeRestart("muffleMessage")
[17:03:37.930]                       }
[17:03:37.930]                       else if (inherits(cond, "warning")) {
[17:03:37.930]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.930]                         if (muffled) 
[17:03:37.930]                           invokeRestart("muffleWarning")
[17:03:37.930]                       }
[17:03:37.930]                       else if (inherits(cond, "condition")) {
[17:03:37.930]                         if (!is.null(pattern)) {
[17:03:37.930]                           computeRestarts <- base::computeRestarts
[17:03:37.930]                           grepl <- base::grepl
[17:03:37.930]                           restarts <- computeRestarts(cond)
[17:03:37.930]                           for (restart in restarts) {
[17:03:37.930]                             name <- restart$name
[17:03:37.930]                             if (is.null(name)) 
[17:03:37.930]                               next
[17:03:37.930]                             if (!grepl(pattern, name)) 
[17:03:37.930]                               next
[17:03:37.930]                             invokeRestart(restart)
[17:03:37.930]                             muffled <- TRUE
[17:03:37.930]                             break
[17:03:37.930]                           }
[17:03:37.930]                         }
[17:03:37.930]                       }
[17:03:37.930]                       invisible(muffled)
[17:03:37.930]                     }
[17:03:37.930]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.930]                   }
[17:03:37.930]                 }
[17:03:37.930]             }
[17:03:37.930]         }))
[17:03:37.930]     }, error = function(ex) {
[17:03:37.930]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.930]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.930]                 ...future.rng), started = ...future.startTime, 
[17:03:37.930]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.930]             version = "1.8"), class = "FutureResult")
[17:03:37.930]     }, finally = {
[17:03:37.930]         if (!identical(...future.workdir, getwd())) 
[17:03:37.930]             setwd(...future.workdir)
[17:03:37.930]         {
[17:03:37.930]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.930]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.930]             }
[17:03:37.930]             base::options(...future.oldOptions)
[17:03:37.930]             if (.Platform$OS.type == "windows") {
[17:03:37.930]                 old_names <- names(...future.oldEnvVars)
[17:03:37.930]                 envs <- base::Sys.getenv()
[17:03:37.930]                 names <- names(envs)
[17:03:37.930]                 common <- intersect(names, old_names)
[17:03:37.930]                 added <- setdiff(names, old_names)
[17:03:37.930]                 removed <- setdiff(old_names, names)
[17:03:37.930]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.930]                   envs[common]]
[17:03:37.930]                 NAMES <- toupper(changed)
[17:03:37.930]                 args <- list()
[17:03:37.930]                 for (kk in seq_along(NAMES)) {
[17:03:37.930]                   name <- changed[[kk]]
[17:03:37.930]                   NAME <- NAMES[[kk]]
[17:03:37.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.930]                     next
[17:03:37.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.930]                 }
[17:03:37.930]                 NAMES <- toupper(added)
[17:03:37.930]                 for (kk in seq_along(NAMES)) {
[17:03:37.930]                   name <- added[[kk]]
[17:03:37.930]                   NAME <- NAMES[[kk]]
[17:03:37.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.930]                     next
[17:03:37.930]                   args[[name]] <- ""
[17:03:37.930]                 }
[17:03:37.930]                 NAMES <- toupper(removed)
[17:03:37.930]                 for (kk in seq_along(NAMES)) {
[17:03:37.930]                   name <- removed[[kk]]
[17:03:37.930]                   NAME <- NAMES[[kk]]
[17:03:37.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.930]                     next
[17:03:37.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.930]                 }
[17:03:37.930]                 if (length(args) > 0) 
[17:03:37.930]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.930]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.930]             }
[17:03:37.930]             else {
[17:03:37.930]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.930]             }
[17:03:37.930]             {
[17:03:37.930]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.930]                   0L) {
[17:03:37.930]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.930]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.930]                   base::options(opts)
[17:03:37.930]                 }
[17:03:37.930]                 {
[17:03:37.930]                   {
[17:03:37.930]                     NULL
[17:03:37.930]                     RNGkind("Mersenne-Twister")
[17:03:37.930]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.930]                       inherits = FALSE)
[17:03:37.930]                   }
[17:03:37.930]                   options(future.plan = NULL)
[17:03:37.930]                   if (is.na(NA_character_)) 
[17:03:37.930]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.930]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.930]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.930]                     .init = FALSE)
[17:03:37.930]                 }
[17:03:37.930]             }
[17:03:37.930]         }
[17:03:37.930]     })
[17:03:37.930]     if (TRUE) {
[17:03:37.930]         base::sink(type = "output", split = FALSE)
[17:03:37.930]         if (TRUE) {
[17:03:37.930]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.930]         }
[17:03:37.930]         else {
[17:03:37.930]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.930]         }
[17:03:37.930]         base::close(...future.stdout)
[17:03:37.930]         ...future.stdout <- NULL
[17:03:37.930]     }
[17:03:37.930]     ...future.result$conditions <- ...future.conditions
[17:03:37.930]     ...future.result$finished <- base::Sys.time()
[17:03:37.930]     ...future.result
[17:03:37.930] }
[17:03:37.931] plan(): Setting new future strategy stack:
[17:03:37.932] List of future strategies:
[17:03:37.932] 1. sequential:
[17:03:37.932]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.932]    - tweaked: FALSE
[17:03:37.932]    - call: NULL
[17:03:37.932] plan(): nbrOfWorkers() = 1
[17:03:37.935] plan(): Setting new future strategy stack:
[17:03:37.935] List of future strategies:
[17:03:37.935] 1. sequential:
[17:03:37.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.935]    - tweaked: FALSE
[17:03:37.935]    - call: plan(strategy)
[17:03:37.935] plan(): nbrOfWorkers() = 1
[17:03:37.935] SequentialFuture started (and completed)
[17:03:37.935] - Launch lazy future ... done
[17:03:37.936] run() for ‘SequentialFuture’ ... done
[17:03:37.936] resolve() on list environment ...
[17:03:37.936]  recursive: 0
[17:03:37.937]  length: 3
[17:03:37.937]  elements: ‘a’, ‘b’, ‘c’
[17:03:37.937] resolved() for ‘SequentialFuture’ ...
[17:03:37.937] - state: ‘finished’
[17:03:37.937] - run: TRUE
[17:03:37.937] - result: ‘FutureResult’
[17:03:37.937] resolved() for ‘SequentialFuture’ ... done
[17:03:37.938] Future #1
[17:03:37.938]  length: 2 (resolved future 1)
[17:03:37.938] resolved() for ‘SequentialFuture’ ...
[17:03:37.938] - state: ‘finished’
[17:03:37.938] - run: TRUE
[17:03:37.938] - result: ‘FutureResult’
[17:03:37.938] resolved() for ‘SequentialFuture’ ... done
[17:03:37.938] Future #2
[17:03:37.938]  length: 1 (resolved future 2)
[17:03:37.938]  length: 0 (resolved future 3)
[17:03:37.939] resolve() on list environment ... DONE
[17:03:37.939] getGlobalsAndPackages() ...
[17:03:37.939] Searching for globals...
[17:03:37.940] - globals found: [1] ‘{’
[17:03:37.940] Searching for globals ... DONE
[17:03:37.940] Resolving globals: FALSE
[17:03:37.940] 
[17:03:37.940] 
[17:03:37.941] getGlobalsAndPackages() ... DONE
[17:03:37.941] run() for ‘Future’ ...
[17:03:37.941] - state: ‘created’
[17:03:37.941] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.941]   - Field: ‘label’
[17:03:37.942]   - Field: ‘local’
[17:03:37.942]   - Field: ‘owner’
[17:03:37.942]   - Field: ‘envir’
[17:03:37.942]   - Field: ‘packages’
[17:03:37.942]   - Field: ‘gc’
[17:03:37.942]   - Field: ‘conditions’
[17:03:37.942]   - Field: ‘expr’
[17:03:37.942]   - Field: ‘uuid’
[17:03:37.942]   - Field: ‘seed’
[17:03:37.942]   - Field: ‘version’
[17:03:37.942]   - Field: ‘result’
[17:03:37.943]   - Field: ‘asynchronous’
[17:03:37.943]   - Field: ‘calls’
[17:03:37.943]   - Field: ‘globals’
[17:03:37.943]   - Field: ‘stdout’
[17:03:37.943]   - Field: ‘earlySignal’
[17:03:37.943]   - Field: ‘lazy’
[17:03:37.943]   - Field: ‘state’
[17:03:37.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.943] - Launch lazy future ...
[17:03:37.943] Packages needed by the future expression (n = 0): <none>
[17:03:37.944] Packages needed by future strategies (n = 0): <none>
[17:03:37.944] {
[17:03:37.944]     {
[17:03:37.944]         {
[17:03:37.944]             ...future.startTime <- base::Sys.time()
[17:03:37.944]             {
[17:03:37.944]                 {
[17:03:37.944]                   {
[17:03:37.944]                     base::local({
[17:03:37.944]                       has_future <- base::requireNamespace("future", 
[17:03:37.944]                         quietly = TRUE)
[17:03:37.944]                       if (has_future) {
[17:03:37.944]                         ns <- base::getNamespace("future")
[17:03:37.944]                         version <- ns[[".package"]][["version"]]
[17:03:37.944]                         if (is.null(version)) 
[17:03:37.944]                           version <- utils::packageVersion("future")
[17:03:37.944]                       }
[17:03:37.944]                       else {
[17:03:37.944]                         version <- NULL
[17:03:37.944]                       }
[17:03:37.944]                       if (!has_future || version < "1.8.0") {
[17:03:37.944]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.944]                           "", base::R.version$version.string), 
[17:03:37.944]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.944]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.944]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.944]                             "release", "version")], collapse = " "), 
[17:03:37.944]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.944]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.944]                           info)
[17:03:37.944]                         info <- base::paste(info, collapse = "; ")
[17:03:37.944]                         if (!has_future) {
[17:03:37.944]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.944]                             info)
[17:03:37.944]                         }
[17:03:37.944]                         else {
[17:03:37.944]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.944]                             info, version)
[17:03:37.944]                         }
[17:03:37.944]                         base::stop(msg)
[17:03:37.944]                       }
[17:03:37.944]                     })
[17:03:37.944]                   }
[17:03:37.944]                   ...future.strategy.old <- future::plan("list")
[17:03:37.944]                   options(future.plan = NULL)
[17:03:37.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.944]                 }
[17:03:37.944]                 ...future.workdir <- getwd()
[17:03:37.944]             }
[17:03:37.944]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.944]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.944]         }
[17:03:37.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.944]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.944]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.944]             base::names(...future.oldOptions))
[17:03:37.944]     }
[17:03:37.944]     if (FALSE) {
[17:03:37.944]     }
[17:03:37.944]     else {
[17:03:37.944]         if (TRUE) {
[17:03:37.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.944]                 open = "w")
[17:03:37.944]         }
[17:03:37.944]         else {
[17:03:37.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.944]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.944]         }
[17:03:37.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.944]             base::sink(type = "output", split = FALSE)
[17:03:37.944]             base::close(...future.stdout)
[17:03:37.944]         }, add = TRUE)
[17:03:37.944]     }
[17:03:37.944]     ...future.frame <- base::sys.nframe()
[17:03:37.944]     ...future.conditions <- base::list()
[17:03:37.944]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.944]     if (FALSE) {
[17:03:37.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.944]     }
[17:03:37.944]     ...future.result <- base::tryCatch({
[17:03:37.944]         base::withCallingHandlers({
[17:03:37.944]             ...future.value <- base::withVisible(base::local({
[17:03:37.944]                 1
[17:03:37.944]             }))
[17:03:37.944]             future::FutureResult(value = ...future.value$value, 
[17:03:37.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.944]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.944]                     ...future.globalenv.names))
[17:03:37.944]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.944]         }, condition = base::local({
[17:03:37.944]             c <- base::c
[17:03:37.944]             inherits <- base::inherits
[17:03:37.944]             invokeRestart <- base::invokeRestart
[17:03:37.944]             length <- base::length
[17:03:37.944]             list <- base::list
[17:03:37.944]             seq.int <- base::seq.int
[17:03:37.944]             signalCondition <- base::signalCondition
[17:03:37.944]             sys.calls <- base::sys.calls
[17:03:37.944]             `[[` <- base::`[[`
[17:03:37.944]             `+` <- base::`+`
[17:03:37.944]             `<<-` <- base::`<<-`
[17:03:37.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.944]                   3L)]
[17:03:37.944]             }
[17:03:37.944]             function(cond) {
[17:03:37.944]                 is_error <- inherits(cond, "error")
[17:03:37.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.944]                   NULL)
[17:03:37.944]                 if (is_error) {
[17:03:37.944]                   sessionInformation <- function() {
[17:03:37.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.944]                       search = base::search(), system = base::Sys.info())
[17:03:37.944]                   }
[17:03:37.944]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.944]                     cond$call), session = sessionInformation(), 
[17:03:37.944]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.944]                   signalCondition(cond)
[17:03:37.944]                 }
[17:03:37.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.944]                 "immediateCondition"))) {
[17:03:37.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.944]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.944]                   if (TRUE && !signal) {
[17:03:37.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.944]                     {
[17:03:37.944]                       inherits <- base::inherits
[17:03:37.944]                       invokeRestart <- base::invokeRestart
[17:03:37.944]                       is.null <- base::is.null
[17:03:37.944]                       muffled <- FALSE
[17:03:37.944]                       if (inherits(cond, "message")) {
[17:03:37.944]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.944]                         if (muffled) 
[17:03:37.944]                           invokeRestart("muffleMessage")
[17:03:37.944]                       }
[17:03:37.944]                       else if (inherits(cond, "warning")) {
[17:03:37.944]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.944]                         if (muffled) 
[17:03:37.944]                           invokeRestart("muffleWarning")
[17:03:37.944]                       }
[17:03:37.944]                       else if (inherits(cond, "condition")) {
[17:03:37.944]                         if (!is.null(pattern)) {
[17:03:37.944]                           computeRestarts <- base::computeRestarts
[17:03:37.944]                           grepl <- base::grepl
[17:03:37.944]                           restarts <- computeRestarts(cond)
[17:03:37.944]                           for (restart in restarts) {
[17:03:37.944]                             name <- restart$name
[17:03:37.944]                             if (is.null(name)) 
[17:03:37.944]                               next
[17:03:37.944]                             if (!grepl(pattern, name)) 
[17:03:37.944]                               next
[17:03:37.944]                             invokeRestart(restart)
[17:03:37.944]                             muffled <- TRUE
[17:03:37.944]                             break
[17:03:37.944]                           }
[17:03:37.944]                         }
[17:03:37.944]                       }
[17:03:37.944]                       invisible(muffled)
[17:03:37.944]                     }
[17:03:37.944]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.944]                   }
[17:03:37.944]                 }
[17:03:37.944]                 else {
[17:03:37.944]                   if (TRUE) {
[17:03:37.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.944]                     {
[17:03:37.944]                       inherits <- base::inherits
[17:03:37.944]                       invokeRestart <- base::invokeRestart
[17:03:37.944]                       is.null <- base::is.null
[17:03:37.944]                       muffled <- FALSE
[17:03:37.944]                       if (inherits(cond, "message")) {
[17:03:37.944]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.944]                         if (muffled) 
[17:03:37.944]                           invokeRestart("muffleMessage")
[17:03:37.944]                       }
[17:03:37.944]                       else if (inherits(cond, "warning")) {
[17:03:37.944]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.944]                         if (muffled) 
[17:03:37.944]                           invokeRestart("muffleWarning")
[17:03:37.944]                       }
[17:03:37.944]                       else if (inherits(cond, "condition")) {
[17:03:37.944]                         if (!is.null(pattern)) {
[17:03:37.944]                           computeRestarts <- base::computeRestarts
[17:03:37.944]                           grepl <- base::grepl
[17:03:37.944]                           restarts <- computeRestarts(cond)
[17:03:37.944]                           for (restart in restarts) {
[17:03:37.944]                             name <- restart$name
[17:03:37.944]                             if (is.null(name)) 
[17:03:37.944]                               next
[17:03:37.944]                             if (!grepl(pattern, name)) 
[17:03:37.944]                               next
[17:03:37.944]                             invokeRestart(restart)
[17:03:37.944]                             muffled <- TRUE
[17:03:37.944]                             break
[17:03:37.944]                           }
[17:03:37.944]                         }
[17:03:37.944]                       }
[17:03:37.944]                       invisible(muffled)
[17:03:37.944]                     }
[17:03:37.944]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.944]                   }
[17:03:37.944]                 }
[17:03:37.944]             }
[17:03:37.944]         }))
[17:03:37.944]     }, error = function(ex) {
[17:03:37.944]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.944]                 ...future.rng), started = ...future.startTime, 
[17:03:37.944]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.944]             version = "1.8"), class = "FutureResult")
[17:03:37.944]     }, finally = {
[17:03:37.944]         if (!identical(...future.workdir, getwd())) 
[17:03:37.944]             setwd(...future.workdir)
[17:03:37.944]         {
[17:03:37.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.944]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.944]             }
[17:03:37.944]             base::options(...future.oldOptions)
[17:03:37.944]             if (.Platform$OS.type == "windows") {
[17:03:37.944]                 old_names <- names(...future.oldEnvVars)
[17:03:37.944]                 envs <- base::Sys.getenv()
[17:03:37.944]                 names <- names(envs)
[17:03:37.944]                 common <- intersect(names, old_names)
[17:03:37.944]                 added <- setdiff(names, old_names)
[17:03:37.944]                 removed <- setdiff(old_names, names)
[17:03:37.944]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.944]                   envs[common]]
[17:03:37.944]                 NAMES <- toupper(changed)
[17:03:37.944]                 args <- list()
[17:03:37.944]                 for (kk in seq_along(NAMES)) {
[17:03:37.944]                   name <- changed[[kk]]
[17:03:37.944]                   NAME <- NAMES[[kk]]
[17:03:37.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.944]                     next
[17:03:37.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.944]                 }
[17:03:37.944]                 NAMES <- toupper(added)
[17:03:37.944]                 for (kk in seq_along(NAMES)) {
[17:03:37.944]                   name <- added[[kk]]
[17:03:37.944]                   NAME <- NAMES[[kk]]
[17:03:37.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.944]                     next
[17:03:37.944]                   args[[name]] <- ""
[17:03:37.944]                 }
[17:03:37.944]                 NAMES <- toupper(removed)
[17:03:37.944]                 for (kk in seq_along(NAMES)) {
[17:03:37.944]                   name <- removed[[kk]]
[17:03:37.944]                   NAME <- NAMES[[kk]]
[17:03:37.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.944]                     next
[17:03:37.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.944]                 }
[17:03:37.944]                 if (length(args) > 0) 
[17:03:37.944]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.944]             }
[17:03:37.944]             else {
[17:03:37.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.944]             }
[17:03:37.944]             {
[17:03:37.944]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.944]                   0L) {
[17:03:37.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.944]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.944]                   base::options(opts)
[17:03:37.944]                 }
[17:03:37.944]                 {
[17:03:37.944]                   {
[17:03:37.944]                     NULL
[17:03:37.944]                     RNGkind("Mersenne-Twister")
[17:03:37.944]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.944]                       inherits = FALSE)
[17:03:37.944]                   }
[17:03:37.944]                   options(future.plan = NULL)
[17:03:37.944]                   if (is.na(NA_character_)) 
[17:03:37.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.944]                     .init = FALSE)
[17:03:37.944]                 }
[17:03:37.944]             }
[17:03:37.944]         }
[17:03:37.944]     })
[17:03:37.944]     if (TRUE) {
[17:03:37.944]         base::sink(type = "output", split = FALSE)
[17:03:37.944]         if (TRUE) {
[17:03:37.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.944]         }
[17:03:37.944]         else {
[17:03:37.944]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.944]         }
[17:03:37.944]         base::close(...future.stdout)
[17:03:37.944]         ...future.stdout <- NULL
[17:03:37.944]     }
[17:03:37.944]     ...future.result$conditions <- ...future.conditions
[17:03:37.944]     ...future.result$finished <- base::Sys.time()
[17:03:37.944]     ...future.result
[17:03:37.944] }
[17:03:37.946] plan(): Setting new future strategy stack:
[17:03:37.946] List of future strategies:
[17:03:37.946] 1. sequential:
[17:03:37.946]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.946]    - tweaked: FALSE
[17:03:37.946]    - call: NULL
[17:03:37.946] plan(): nbrOfWorkers() = 1
[17:03:37.947] plan(): Setting new future strategy stack:
[17:03:37.947] List of future strategies:
[17:03:37.947] 1. sequential:
[17:03:37.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.947]    - tweaked: FALSE
[17:03:37.947]    - call: plan(strategy)
[17:03:37.947] plan(): nbrOfWorkers() = 1
[17:03:37.948] SequentialFuture started (and completed)
[17:03:37.948] - Launch lazy future ... done
[17:03:37.948] run() for ‘SequentialFuture’ ... done
[17:03:37.948] getGlobalsAndPackages() ...
[17:03:37.948] Searching for globals...
[17:03:37.949] - globals found: [1] ‘{’
[17:03:37.949] Searching for globals ... DONE
[17:03:37.949] Resolving globals: FALSE
[17:03:37.949] 
[17:03:37.949] 
[17:03:37.949] getGlobalsAndPackages() ... DONE
[17:03:37.950] run() for ‘Future’ ...
[17:03:37.950] - state: ‘created’
[17:03:37.950] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.950] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.950]   - Field: ‘label’
[17:03:37.950]   - Field: ‘local’
[17:03:37.950]   - Field: ‘owner’
[17:03:37.951]   - Field: ‘envir’
[17:03:37.951]   - Field: ‘packages’
[17:03:37.951]   - Field: ‘gc’
[17:03:37.951]   - Field: ‘conditions’
[17:03:37.951]   - Field: ‘expr’
[17:03:37.951]   - Field: ‘uuid’
[17:03:37.951]   - Field: ‘seed’
[17:03:37.951]   - Field: ‘version’
[17:03:37.951]   - Field: ‘result’
[17:03:37.951]   - Field: ‘asynchronous’
[17:03:37.951]   - Field: ‘calls’
[17:03:37.952]   - Field: ‘globals’
[17:03:37.952]   - Field: ‘stdout’
[17:03:37.952]   - Field: ‘earlySignal’
[17:03:37.952]   - Field: ‘lazy’
[17:03:37.952]   - Field: ‘state’
[17:03:37.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.952] - Launch lazy future ...
[17:03:37.952] Packages needed by the future expression (n = 0): <none>
[17:03:37.952] Packages needed by future strategies (n = 0): <none>
[17:03:37.953] {
[17:03:37.953]     {
[17:03:37.953]         {
[17:03:37.953]             ...future.startTime <- base::Sys.time()
[17:03:37.953]             {
[17:03:37.953]                 {
[17:03:37.953]                   {
[17:03:37.953]                     base::local({
[17:03:37.953]                       has_future <- base::requireNamespace("future", 
[17:03:37.953]                         quietly = TRUE)
[17:03:37.953]                       if (has_future) {
[17:03:37.953]                         ns <- base::getNamespace("future")
[17:03:37.953]                         version <- ns[[".package"]][["version"]]
[17:03:37.953]                         if (is.null(version)) 
[17:03:37.953]                           version <- utils::packageVersion("future")
[17:03:37.953]                       }
[17:03:37.953]                       else {
[17:03:37.953]                         version <- NULL
[17:03:37.953]                       }
[17:03:37.953]                       if (!has_future || version < "1.8.0") {
[17:03:37.953]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.953]                           "", base::R.version$version.string), 
[17:03:37.953]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.953]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.953]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.953]                             "release", "version")], collapse = " "), 
[17:03:37.953]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.953]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.953]                           info)
[17:03:37.953]                         info <- base::paste(info, collapse = "; ")
[17:03:37.953]                         if (!has_future) {
[17:03:37.953]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.953]                             info)
[17:03:37.953]                         }
[17:03:37.953]                         else {
[17:03:37.953]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.953]                             info, version)
[17:03:37.953]                         }
[17:03:37.953]                         base::stop(msg)
[17:03:37.953]                       }
[17:03:37.953]                     })
[17:03:37.953]                   }
[17:03:37.953]                   ...future.strategy.old <- future::plan("list")
[17:03:37.953]                   options(future.plan = NULL)
[17:03:37.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.953]                 }
[17:03:37.953]                 ...future.workdir <- getwd()
[17:03:37.953]             }
[17:03:37.953]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.953]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.953]         }
[17:03:37.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.953]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.953]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.953]             base::names(...future.oldOptions))
[17:03:37.953]     }
[17:03:37.953]     if (FALSE) {
[17:03:37.953]     }
[17:03:37.953]     else {
[17:03:37.953]         if (TRUE) {
[17:03:37.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.953]                 open = "w")
[17:03:37.953]         }
[17:03:37.953]         else {
[17:03:37.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.953]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.953]         }
[17:03:37.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.953]             base::sink(type = "output", split = FALSE)
[17:03:37.953]             base::close(...future.stdout)
[17:03:37.953]         }, add = TRUE)
[17:03:37.953]     }
[17:03:37.953]     ...future.frame <- base::sys.nframe()
[17:03:37.953]     ...future.conditions <- base::list()
[17:03:37.953]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.953]     if (FALSE) {
[17:03:37.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.953]     }
[17:03:37.953]     ...future.result <- base::tryCatch({
[17:03:37.953]         base::withCallingHandlers({
[17:03:37.953]             ...future.value <- base::withVisible(base::local({
[17:03:37.953]                 2
[17:03:37.953]             }))
[17:03:37.953]             future::FutureResult(value = ...future.value$value, 
[17:03:37.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.953]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.953]                     ...future.globalenv.names))
[17:03:37.953]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.953]         }, condition = base::local({
[17:03:37.953]             c <- base::c
[17:03:37.953]             inherits <- base::inherits
[17:03:37.953]             invokeRestart <- base::invokeRestart
[17:03:37.953]             length <- base::length
[17:03:37.953]             list <- base::list
[17:03:37.953]             seq.int <- base::seq.int
[17:03:37.953]             signalCondition <- base::signalCondition
[17:03:37.953]             sys.calls <- base::sys.calls
[17:03:37.953]             `[[` <- base::`[[`
[17:03:37.953]             `+` <- base::`+`
[17:03:37.953]             `<<-` <- base::`<<-`
[17:03:37.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.953]                   3L)]
[17:03:37.953]             }
[17:03:37.953]             function(cond) {
[17:03:37.953]                 is_error <- inherits(cond, "error")
[17:03:37.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.953]                   NULL)
[17:03:37.953]                 if (is_error) {
[17:03:37.953]                   sessionInformation <- function() {
[17:03:37.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.953]                       search = base::search(), system = base::Sys.info())
[17:03:37.953]                   }
[17:03:37.953]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.953]                     cond$call), session = sessionInformation(), 
[17:03:37.953]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.953]                   signalCondition(cond)
[17:03:37.953]                 }
[17:03:37.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.953]                 "immediateCondition"))) {
[17:03:37.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.953]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.953]                   if (TRUE && !signal) {
[17:03:37.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.953]                     {
[17:03:37.953]                       inherits <- base::inherits
[17:03:37.953]                       invokeRestart <- base::invokeRestart
[17:03:37.953]                       is.null <- base::is.null
[17:03:37.953]                       muffled <- FALSE
[17:03:37.953]                       if (inherits(cond, "message")) {
[17:03:37.953]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.953]                         if (muffled) 
[17:03:37.953]                           invokeRestart("muffleMessage")
[17:03:37.953]                       }
[17:03:37.953]                       else if (inherits(cond, "warning")) {
[17:03:37.953]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.953]                         if (muffled) 
[17:03:37.953]                           invokeRestart("muffleWarning")
[17:03:37.953]                       }
[17:03:37.953]                       else if (inherits(cond, "condition")) {
[17:03:37.953]                         if (!is.null(pattern)) {
[17:03:37.953]                           computeRestarts <- base::computeRestarts
[17:03:37.953]                           grepl <- base::grepl
[17:03:37.953]                           restarts <- computeRestarts(cond)
[17:03:37.953]                           for (restart in restarts) {
[17:03:37.953]                             name <- restart$name
[17:03:37.953]                             if (is.null(name)) 
[17:03:37.953]                               next
[17:03:37.953]                             if (!grepl(pattern, name)) 
[17:03:37.953]                               next
[17:03:37.953]                             invokeRestart(restart)
[17:03:37.953]                             muffled <- TRUE
[17:03:37.953]                             break
[17:03:37.953]                           }
[17:03:37.953]                         }
[17:03:37.953]                       }
[17:03:37.953]                       invisible(muffled)
[17:03:37.953]                     }
[17:03:37.953]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.953]                   }
[17:03:37.953]                 }
[17:03:37.953]                 else {
[17:03:37.953]                   if (TRUE) {
[17:03:37.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.953]                     {
[17:03:37.953]                       inherits <- base::inherits
[17:03:37.953]                       invokeRestart <- base::invokeRestart
[17:03:37.953]                       is.null <- base::is.null
[17:03:37.953]                       muffled <- FALSE
[17:03:37.953]                       if (inherits(cond, "message")) {
[17:03:37.953]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.953]                         if (muffled) 
[17:03:37.953]                           invokeRestart("muffleMessage")
[17:03:37.953]                       }
[17:03:37.953]                       else if (inherits(cond, "warning")) {
[17:03:37.953]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.953]                         if (muffled) 
[17:03:37.953]                           invokeRestart("muffleWarning")
[17:03:37.953]                       }
[17:03:37.953]                       else if (inherits(cond, "condition")) {
[17:03:37.953]                         if (!is.null(pattern)) {
[17:03:37.953]                           computeRestarts <- base::computeRestarts
[17:03:37.953]                           grepl <- base::grepl
[17:03:37.953]                           restarts <- computeRestarts(cond)
[17:03:37.953]                           for (restart in restarts) {
[17:03:37.953]                             name <- restart$name
[17:03:37.953]                             if (is.null(name)) 
[17:03:37.953]                               next
[17:03:37.953]                             if (!grepl(pattern, name)) 
[17:03:37.953]                               next
[17:03:37.953]                             invokeRestart(restart)
[17:03:37.953]                             muffled <- TRUE
[17:03:37.953]                             break
[17:03:37.953]                           }
[17:03:37.953]                         }
[17:03:37.953]                       }
[17:03:37.953]                       invisible(muffled)
[17:03:37.953]                     }
[17:03:37.953]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.953]                   }
[17:03:37.953]                 }
[17:03:37.953]             }
[17:03:37.953]         }))
[17:03:37.953]     }, error = function(ex) {
[17:03:37.953]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.953]                 ...future.rng), started = ...future.startTime, 
[17:03:37.953]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.953]             version = "1.8"), class = "FutureResult")
[17:03:37.953]     }, finally = {
[17:03:37.953]         if (!identical(...future.workdir, getwd())) 
[17:03:37.953]             setwd(...future.workdir)
[17:03:37.953]         {
[17:03:37.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.953]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.953]             }
[17:03:37.953]             base::options(...future.oldOptions)
[17:03:37.953]             if (.Platform$OS.type == "windows") {
[17:03:37.953]                 old_names <- names(...future.oldEnvVars)
[17:03:37.953]                 envs <- base::Sys.getenv()
[17:03:37.953]                 names <- names(envs)
[17:03:37.953]                 common <- intersect(names, old_names)
[17:03:37.953]                 added <- setdiff(names, old_names)
[17:03:37.953]                 removed <- setdiff(old_names, names)
[17:03:37.953]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.953]                   envs[common]]
[17:03:37.953]                 NAMES <- toupper(changed)
[17:03:37.953]                 args <- list()
[17:03:37.953]                 for (kk in seq_along(NAMES)) {
[17:03:37.953]                   name <- changed[[kk]]
[17:03:37.953]                   NAME <- NAMES[[kk]]
[17:03:37.953]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.953]                     next
[17:03:37.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.953]                 }
[17:03:37.953]                 NAMES <- toupper(added)
[17:03:37.953]                 for (kk in seq_along(NAMES)) {
[17:03:37.953]                   name <- added[[kk]]
[17:03:37.953]                   NAME <- NAMES[[kk]]
[17:03:37.953]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.953]                     next
[17:03:37.953]                   args[[name]] <- ""
[17:03:37.953]                 }
[17:03:37.953]                 NAMES <- toupper(removed)
[17:03:37.953]                 for (kk in seq_along(NAMES)) {
[17:03:37.953]                   name <- removed[[kk]]
[17:03:37.953]                   NAME <- NAMES[[kk]]
[17:03:37.953]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.953]                     next
[17:03:37.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.953]                 }
[17:03:37.953]                 if (length(args) > 0) 
[17:03:37.953]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.953]             }
[17:03:37.953]             else {
[17:03:37.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.953]             }
[17:03:37.953]             {
[17:03:37.953]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.953]                   0L) {
[17:03:37.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.953]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.953]                   base::options(opts)
[17:03:37.953]                 }
[17:03:37.953]                 {
[17:03:37.953]                   {
[17:03:37.953]                     NULL
[17:03:37.953]                     RNGkind("Mersenne-Twister")
[17:03:37.953]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.953]                       inherits = FALSE)
[17:03:37.953]                   }
[17:03:37.953]                   options(future.plan = NULL)
[17:03:37.953]                   if (is.na(NA_character_)) 
[17:03:37.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.953]                     .init = FALSE)
[17:03:37.953]                 }
[17:03:37.953]             }
[17:03:37.953]         }
[17:03:37.953]     })
[17:03:37.953]     if (TRUE) {
[17:03:37.953]         base::sink(type = "output", split = FALSE)
[17:03:37.953]         if (TRUE) {
[17:03:37.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.953]         }
[17:03:37.953]         else {
[17:03:37.953]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.953]         }
[17:03:37.953]         base::close(...future.stdout)
[17:03:37.953]         ...future.stdout <- NULL
[17:03:37.953]     }
[17:03:37.953]     ...future.result$conditions <- ...future.conditions
[17:03:37.953]     ...future.result$finished <- base::Sys.time()
[17:03:37.953]     ...future.result
[17:03:37.953] }
[17:03:37.954] plan(): Setting new future strategy stack:
[17:03:37.955] List of future strategies:
[17:03:37.955] 1. sequential:
[17:03:37.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.955]    - tweaked: FALSE
[17:03:37.955]    - call: NULL
[17:03:37.955] plan(): nbrOfWorkers() = 1
[17:03:37.956] plan(): Setting new future strategy stack:
[17:03:37.956] List of future strategies:
[17:03:37.956] 1. sequential:
[17:03:37.956]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.956]    - tweaked: FALSE
[17:03:37.956]    - call: plan(strategy)
[17:03:37.956] plan(): nbrOfWorkers() = 1
[17:03:37.956] SequentialFuture started (and completed)
[17:03:37.956] - Launch lazy future ... done
[17:03:37.957] run() for ‘SequentialFuture’ ... done
[17:03:37.957] resolve() on list environment ...
[17:03:37.957]  recursive: 0
[17:03:37.958]  length: 3
[17:03:37.958]  elements: ‘a’, ‘b’, ‘c’
[17:03:37.958] resolved() for ‘SequentialFuture’ ...
[17:03:37.958] - state: ‘finished’
[17:03:37.958] - run: TRUE
[17:03:37.958] - result: ‘FutureResult’
[17:03:37.958] resolved() for ‘SequentialFuture’ ... done
[17:03:37.958] Future #1
[17:03:37.958]  length: 2 (resolved future 1)
[17:03:37.959] resolved() for ‘SequentialFuture’ ...
[17:03:37.959] - state: ‘finished’
[17:03:37.959] - run: TRUE
[17:03:37.959] - result: ‘FutureResult’
[17:03:37.959] resolved() for ‘SequentialFuture’ ... done
[17:03:37.959] Future #2
[17:03:37.959]  length: 1 (resolved future 2)
[17:03:37.959]  length: 0 (resolved future 3)
[17:03:37.959] resolve() on list environment ... DONE
[17:03:37.962] getGlobalsAndPackages() ...
[17:03:37.962] Searching for globals...
[17:03:37.962] - globals found: [1] ‘{’
[17:03:37.962] Searching for globals ... DONE
[17:03:37.963] Resolving globals: FALSE
[17:03:37.963] 
[17:03:37.963] 
[17:03:37.963] getGlobalsAndPackages() ... DONE
[17:03:37.963] run() for ‘Future’ ...
[17:03:37.963] - state: ‘created’
[17:03:37.963] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.964]   - Field: ‘label’
[17:03:37.964]   - Field: ‘local’
[17:03:37.964]   - Field: ‘owner’
[17:03:37.964]   - Field: ‘envir’
[17:03:37.964]   - Field: ‘packages’
[17:03:37.964]   - Field: ‘gc’
[17:03:37.965]   - Field: ‘conditions’
[17:03:37.965]   - Field: ‘expr’
[17:03:37.965]   - Field: ‘uuid’
[17:03:37.965]   - Field: ‘seed’
[17:03:37.965]   - Field: ‘version’
[17:03:37.965]   - Field: ‘result’
[17:03:37.965]   - Field: ‘asynchronous’
[17:03:37.965]   - Field: ‘calls’
[17:03:37.965]   - Field: ‘globals’
[17:03:37.965]   - Field: ‘stdout’
[17:03:37.965]   - Field: ‘earlySignal’
[17:03:37.965]   - Field: ‘lazy’
[17:03:37.966]   - Field: ‘state’
[17:03:37.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.966] - Launch lazy future ...
[17:03:37.966] Packages needed by the future expression (n = 0): <none>
[17:03:37.966] Packages needed by future strategies (n = 0): <none>
[17:03:37.966] {
[17:03:37.966]     {
[17:03:37.966]         {
[17:03:37.966]             ...future.startTime <- base::Sys.time()
[17:03:37.966]             {
[17:03:37.966]                 {
[17:03:37.966]                   {
[17:03:37.966]                     base::local({
[17:03:37.966]                       has_future <- base::requireNamespace("future", 
[17:03:37.966]                         quietly = TRUE)
[17:03:37.966]                       if (has_future) {
[17:03:37.966]                         ns <- base::getNamespace("future")
[17:03:37.966]                         version <- ns[[".package"]][["version"]]
[17:03:37.966]                         if (is.null(version)) 
[17:03:37.966]                           version <- utils::packageVersion("future")
[17:03:37.966]                       }
[17:03:37.966]                       else {
[17:03:37.966]                         version <- NULL
[17:03:37.966]                       }
[17:03:37.966]                       if (!has_future || version < "1.8.0") {
[17:03:37.966]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.966]                           "", base::R.version$version.string), 
[17:03:37.966]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.966]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.966]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.966]                             "release", "version")], collapse = " "), 
[17:03:37.966]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.966]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.966]                           info)
[17:03:37.966]                         info <- base::paste(info, collapse = "; ")
[17:03:37.966]                         if (!has_future) {
[17:03:37.966]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.966]                             info)
[17:03:37.966]                         }
[17:03:37.966]                         else {
[17:03:37.966]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.966]                             info, version)
[17:03:37.966]                         }
[17:03:37.966]                         base::stop(msg)
[17:03:37.966]                       }
[17:03:37.966]                     })
[17:03:37.966]                   }
[17:03:37.966]                   ...future.strategy.old <- future::plan("list")
[17:03:37.966]                   options(future.plan = NULL)
[17:03:37.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.966]                 }
[17:03:37.966]                 ...future.workdir <- getwd()
[17:03:37.966]             }
[17:03:37.966]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.966]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.966]         }
[17:03:37.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.966]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.966]             base::names(...future.oldOptions))
[17:03:37.966]     }
[17:03:37.966]     if (FALSE) {
[17:03:37.966]     }
[17:03:37.966]     else {
[17:03:37.966]         if (TRUE) {
[17:03:37.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.966]                 open = "w")
[17:03:37.966]         }
[17:03:37.966]         else {
[17:03:37.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.966]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.966]         }
[17:03:37.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.966]             base::sink(type = "output", split = FALSE)
[17:03:37.966]             base::close(...future.stdout)
[17:03:37.966]         }, add = TRUE)
[17:03:37.966]     }
[17:03:37.966]     ...future.frame <- base::sys.nframe()
[17:03:37.966]     ...future.conditions <- base::list()
[17:03:37.966]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.966]     if (FALSE) {
[17:03:37.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.966]     }
[17:03:37.966]     ...future.result <- base::tryCatch({
[17:03:37.966]         base::withCallingHandlers({
[17:03:37.966]             ...future.value <- base::withVisible(base::local({
[17:03:37.966]                 1
[17:03:37.966]             }))
[17:03:37.966]             future::FutureResult(value = ...future.value$value, 
[17:03:37.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.966]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.966]                     ...future.globalenv.names))
[17:03:37.966]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.966]         }, condition = base::local({
[17:03:37.966]             c <- base::c
[17:03:37.966]             inherits <- base::inherits
[17:03:37.966]             invokeRestart <- base::invokeRestart
[17:03:37.966]             length <- base::length
[17:03:37.966]             list <- base::list
[17:03:37.966]             seq.int <- base::seq.int
[17:03:37.966]             signalCondition <- base::signalCondition
[17:03:37.966]             sys.calls <- base::sys.calls
[17:03:37.966]             `[[` <- base::`[[`
[17:03:37.966]             `+` <- base::`+`
[17:03:37.966]             `<<-` <- base::`<<-`
[17:03:37.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.966]                   3L)]
[17:03:37.966]             }
[17:03:37.966]             function(cond) {
[17:03:37.966]                 is_error <- inherits(cond, "error")
[17:03:37.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.966]                   NULL)
[17:03:37.966]                 if (is_error) {
[17:03:37.966]                   sessionInformation <- function() {
[17:03:37.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.966]                       search = base::search(), system = base::Sys.info())
[17:03:37.966]                   }
[17:03:37.966]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.966]                     cond$call), session = sessionInformation(), 
[17:03:37.966]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.966]                   signalCondition(cond)
[17:03:37.966]                 }
[17:03:37.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.966]                 "immediateCondition"))) {
[17:03:37.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.966]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.966]                   if (TRUE && !signal) {
[17:03:37.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.966]                     {
[17:03:37.966]                       inherits <- base::inherits
[17:03:37.966]                       invokeRestart <- base::invokeRestart
[17:03:37.966]                       is.null <- base::is.null
[17:03:37.966]                       muffled <- FALSE
[17:03:37.966]                       if (inherits(cond, "message")) {
[17:03:37.966]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.966]                         if (muffled) 
[17:03:37.966]                           invokeRestart("muffleMessage")
[17:03:37.966]                       }
[17:03:37.966]                       else if (inherits(cond, "warning")) {
[17:03:37.966]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.966]                         if (muffled) 
[17:03:37.966]                           invokeRestart("muffleWarning")
[17:03:37.966]                       }
[17:03:37.966]                       else if (inherits(cond, "condition")) {
[17:03:37.966]                         if (!is.null(pattern)) {
[17:03:37.966]                           computeRestarts <- base::computeRestarts
[17:03:37.966]                           grepl <- base::grepl
[17:03:37.966]                           restarts <- computeRestarts(cond)
[17:03:37.966]                           for (restart in restarts) {
[17:03:37.966]                             name <- restart$name
[17:03:37.966]                             if (is.null(name)) 
[17:03:37.966]                               next
[17:03:37.966]                             if (!grepl(pattern, name)) 
[17:03:37.966]                               next
[17:03:37.966]                             invokeRestart(restart)
[17:03:37.966]                             muffled <- TRUE
[17:03:37.966]                             break
[17:03:37.966]                           }
[17:03:37.966]                         }
[17:03:37.966]                       }
[17:03:37.966]                       invisible(muffled)
[17:03:37.966]                     }
[17:03:37.966]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.966]                   }
[17:03:37.966]                 }
[17:03:37.966]                 else {
[17:03:37.966]                   if (TRUE) {
[17:03:37.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.966]                     {
[17:03:37.966]                       inherits <- base::inherits
[17:03:37.966]                       invokeRestart <- base::invokeRestart
[17:03:37.966]                       is.null <- base::is.null
[17:03:37.966]                       muffled <- FALSE
[17:03:37.966]                       if (inherits(cond, "message")) {
[17:03:37.966]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.966]                         if (muffled) 
[17:03:37.966]                           invokeRestart("muffleMessage")
[17:03:37.966]                       }
[17:03:37.966]                       else if (inherits(cond, "warning")) {
[17:03:37.966]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.966]                         if (muffled) 
[17:03:37.966]                           invokeRestart("muffleWarning")
[17:03:37.966]                       }
[17:03:37.966]                       else if (inherits(cond, "condition")) {
[17:03:37.966]                         if (!is.null(pattern)) {
[17:03:37.966]                           computeRestarts <- base::computeRestarts
[17:03:37.966]                           grepl <- base::grepl
[17:03:37.966]                           restarts <- computeRestarts(cond)
[17:03:37.966]                           for (restart in restarts) {
[17:03:37.966]                             name <- restart$name
[17:03:37.966]                             if (is.null(name)) 
[17:03:37.966]                               next
[17:03:37.966]                             if (!grepl(pattern, name)) 
[17:03:37.966]                               next
[17:03:37.966]                             invokeRestart(restart)
[17:03:37.966]                             muffled <- TRUE
[17:03:37.966]                             break
[17:03:37.966]                           }
[17:03:37.966]                         }
[17:03:37.966]                       }
[17:03:37.966]                       invisible(muffled)
[17:03:37.966]                     }
[17:03:37.966]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.966]                   }
[17:03:37.966]                 }
[17:03:37.966]             }
[17:03:37.966]         }))
[17:03:37.966]     }, error = function(ex) {
[17:03:37.966]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.966]                 ...future.rng), started = ...future.startTime, 
[17:03:37.966]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.966]             version = "1.8"), class = "FutureResult")
[17:03:37.966]     }, finally = {
[17:03:37.966]         if (!identical(...future.workdir, getwd())) 
[17:03:37.966]             setwd(...future.workdir)
[17:03:37.966]         {
[17:03:37.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.966]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.966]             }
[17:03:37.966]             base::options(...future.oldOptions)
[17:03:37.966]             if (.Platform$OS.type == "windows") {
[17:03:37.966]                 old_names <- names(...future.oldEnvVars)
[17:03:37.966]                 envs <- base::Sys.getenv()
[17:03:37.966]                 names <- names(envs)
[17:03:37.966]                 common <- intersect(names, old_names)
[17:03:37.966]                 added <- setdiff(names, old_names)
[17:03:37.966]                 removed <- setdiff(old_names, names)
[17:03:37.966]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.966]                   envs[common]]
[17:03:37.966]                 NAMES <- toupper(changed)
[17:03:37.966]                 args <- list()
[17:03:37.966]                 for (kk in seq_along(NAMES)) {
[17:03:37.966]                   name <- changed[[kk]]
[17:03:37.966]                   NAME <- NAMES[[kk]]
[17:03:37.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.966]                     next
[17:03:37.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.966]                 }
[17:03:37.966]                 NAMES <- toupper(added)
[17:03:37.966]                 for (kk in seq_along(NAMES)) {
[17:03:37.966]                   name <- added[[kk]]
[17:03:37.966]                   NAME <- NAMES[[kk]]
[17:03:37.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.966]                     next
[17:03:37.966]                   args[[name]] <- ""
[17:03:37.966]                 }
[17:03:37.966]                 NAMES <- toupper(removed)
[17:03:37.966]                 for (kk in seq_along(NAMES)) {
[17:03:37.966]                   name <- removed[[kk]]
[17:03:37.966]                   NAME <- NAMES[[kk]]
[17:03:37.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.966]                     next
[17:03:37.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.966]                 }
[17:03:37.966]                 if (length(args) > 0) 
[17:03:37.966]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.966]             }
[17:03:37.966]             else {
[17:03:37.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.966]             }
[17:03:37.966]             {
[17:03:37.966]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.966]                   0L) {
[17:03:37.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.966]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.966]                   base::options(opts)
[17:03:37.966]                 }
[17:03:37.966]                 {
[17:03:37.966]                   {
[17:03:37.966]                     NULL
[17:03:37.966]                     RNGkind("Mersenne-Twister")
[17:03:37.966]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.966]                       inherits = FALSE)
[17:03:37.966]                   }
[17:03:37.966]                   options(future.plan = NULL)
[17:03:37.966]                   if (is.na(NA_character_)) 
[17:03:37.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.966]                     .init = FALSE)
[17:03:37.966]                 }
[17:03:37.966]             }
[17:03:37.966]         }
[17:03:37.966]     })
[17:03:37.966]     if (TRUE) {
[17:03:37.966]         base::sink(type = "output", split = FALSE)
[17:03:37.966]         if (TRUE) {
[17:03:37.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.966]         }
[17:03:37.966]         else {
[17:03:37.966]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.966]         }
[17:03:37.966]         base::close(...future.stdout)
[17:03:37.966]         ...future.stdout <- NULL
[17:03:37.966]     }
[17:03:37.966]     ...future.result$conditions <- ...future.conditions
[17:03:37.966]     ...future.result$finished <- base::Sys.time()
[17:03:37.966]     ...future.result
[17:03:37.966] }
[17:03:37.968] plan(): Setting new future strategy stack:
[17:03:37.969] List of future strategies:
[17:03:37.969] 1. sequential:
[17:03:37.969]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.969]    - tweaked: FALSE
[17:03:37.969]    - call: NULL
[17:03:37.969] plan(): nbrOfWorkers() = 1
[17:03:37.970] plan(): Setting new future strategy stack:
[17:03:37.970] List of future strategies:
[17:03:37.970] 1. sequential:
[17:03:37.970]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.970]    - tweaked: FALSE
[17:03:37.970]    - call: plan(strategy)
[17:03:37.971] plan(): nbrOfWorkers() = 1
[17:03:37.971] SequentialFuture started (and completed)
[17:03:37.971] - Launch lazy future ... done
[17:03:37.971] run() for ‘SequentialFuture’ ... done
[17:03:37.971] getGlobalsAndPackages() ...
[17:03:37.971] Searching for globals...
[17:03:37.972] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:03:37.972] Searching for globals ... DONE
[17:03:37.972] Resolving globals: FALSE
[17:03:37.973] 
[17:03:37.973] 
[17:03:37.973] getGlobalsAndPackages() ... DONE
[17:03:37.973] run() for ‘Future’ ...
[17:03:37.973] - state: ‘created’
[17:03:37.973] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:37.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:37.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:37.974]   - Field: ‘label’
[17:03:37.974]   - Field: ‘local’
[17:03:37.974]   - Field: ‘owner’
[17:03:37.974]   - Field: ‘envir’
[17:03:37.974]   - Field: ‘packages’
[17:03:37.974]   - Field: ‘gc’
[17:03:37.974]   - Field: ‘conditions’
[17:03:37.975]   - Field: ‘expr’
[17:03:37.975]   - Field: ‘uuid’
[17:03:37.975]   - Field: ‘seed’
[17:03:37.975]   - Field: ‘version’
[17:03:37.975]   - Field: ‘result’
[17:03:37.975]   - Field: ‘asynchronous’
[17:03:37.975]   - Field: ‘calls’
[17:03:37.975]   - Field: ‘globals’
[17:03:37.975]   - Field: ‘stdout’
[17:03:37.975]   - Field: ‘earlySignal’
[17:03:37.975]   - Field: ‘lazy’
[17:03:37.976]   - Field: ‘state’
[17:03:37.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:37.976] - Launch lazy future ...
[17:03:37.976] Packages needed by the future expression (n = 0): <none>
[17:03:37.976] Packages needed by future strategies (n = 0): <none>
[17:03:37.976] {
[17:03:37.976]     {
[17:03:37.976]         {
[17:03:37.976]             ...future.startTime <- base::Sys.time()
[17:03:37.976]             {
[17:03:37.976]                 {
[17:03:37.976]                   {
[17:03:37.976]                     base::local({
[17:03:37.976]                       has_future <- base::requireNamespace("future", 
[17:03:37.976]                         quietly = TRUE)
[17:03:37.976]                       if (has_future) {
[17:03:37.976]                         ns <- base::getNamespace("future")
[17:03:37.976]                         version <- ns[[".package"]][["version"]]
[17:03:37.976]                         if (is.null(version)) 
[17:03:37.976]                           version <- utils::packageVersion("future")
[17:03:37.976]                       }
[17:03:37.976]                       else {
[17:03:37.976]                         version <- NULL
[17:03:37.976]                       }
[17:03:37.976]                       if (!has_future || version < "1.8.0") {
[17:03:37.976]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:37.976]                           "", base::R.version$version.string), 
[17:03:37.976]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:37.976]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:37.976]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:37.976]                             "release", "version")], collapse = " "), 
[17:03:37.976]                           hostname = base::Sys.info()[["nodename"]])
[17:03:37.976]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:37.976]                           info)
[17:03:37.976]                         info <- base::paste(info, collapse = "; ")
[17:03:37.976]                         if (!has_future) {
[17:03:37.976]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:37.976]                             info)
[17:03:37.976]                         }
[17:03:37.976]                         else {
[17:03:37.976]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:37.976]                             info, version)
[17:03:37.976]                         }
[17:03:37.976]                         base::stop(msg)
[17:03:37.976]                       }
[17:03:37.976]                     })
[17:03:37.976]                   }
[17:03:37.976]                   ...future.strategy.old <- future::plan("list")
[17:03:37.976]                   options(future.plan = NULL)
[17:03:37.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:37.976]                 }
[17:03:37.976]                 ...future.workdir <- getwd()
[17:03:37.976]             }
[17:03:37.976]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:37.976]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:37.976]         }
[17:03:37.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:37.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:37.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:37.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:37.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:37.976]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:37.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:37.976]             base::names(...future.oldOptions))
[17:03:37.976]     }
[17:03:37.976]     if (FALSE) {
[17:03:37.976]     }
[17:03:37.976]     else {
[17:03:37.976]         if (TRUE) {
[17:03:37.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:37.976]                 open = "w")
[17:03:37.976]         }
[17:03:37.976]         else {
[17:03:37.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:37.976]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:37.976]         }
[17:03:37.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:37.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:37.976]             base::sink(type = "output", split = FALSE)
[17:03:37.976]             base::close(...future.stdout)
[17:03:37.976]         }, add = TRUE)
[17:03:37.976]     }
[17:03:37.976]     ...future.frame <- base::sys.nframe()
[17:03:37.976]     ...future.conditions <- base::list()
[17:03:37.976]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:37.976]     if (FALSE) {
[17:03:37.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:37.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:37.976]     }
[17:03:37.976]     ...future.result <- base::tryCatch({
[17:03:37.976]         base::withCallingHandlers({
[17:03:37.976]             ...future.value <- base::withVisible(base::local({
[17:03:37.976]                 Sys.sleep(0.5)
[17:03:37.976]                 2
[17:03:37.976]             }))
[17:03:37.976]             future::FutureResult(value = ...future.value$value, 
[17:03:37.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.976]                   ...future.rng), globalenv = if (FALSE) 
[17:03:37.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:37.976]                     ...future.globalenv.names))
[17:03:37.976]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:37.976]         }, condition = base::local({
[17:03:37.976]             c <- base::c
[17:03:37.976]             inherits <- base::inherits
[17:03:37.976]             invokeRestart <- base::invokeRestart
[17:03:37.976]             length <- base::length
[17:03:37.976]             list <- base::list
[17:03:37.976]             seq.int <- base::seq.int
[17:03:37.976]             signalCondition <- base::signalCondition
[17:03:37.976]             sys.calls <- base::sys.calls
[17:03:37.976]             `[[` <- base::`[[`
[17:03:37.976]             `+` <- base::`+`
[17:03:37.976]             `<<-` <- base::`<<-`
[17:03:37.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:37.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:37.976]                   3L)]
[17:03:37.976]             }
[17:03:37.976]             function(cond) {
[17:03:37.976]                 is_error <- inherits(cond, "error")
[17:03:37.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:37.976]                   NULL)
[17:03:37.976]                 if (is_error) {
[17:03:37.976]                   sessionInformation <- function() {
[17:03:37.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:37.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:37.976]                       search = base::search(), system = base::Sys.info())
[17:03:37.976]                   }
[17:03:37.976]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:37.976]                     cond$call), session = sessionInformation(), 
[17:03:37.976]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:37.976]                   signalCondition(cond)
[17:03:37.976]                 }
[17:03:37.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:37.976]                 "immediateCondition"))) {
[17:03:37.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:37.976]                   ...future.conditions[[length(...future.conditions) + 
[17:03:37.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:37.976]                   if (TRUE && !signal) {
[17:03:37.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.976]                     {
[17:03:37.976]                       inherits <- base::inherits
[17:03:37.976]                       invokeRestart <- base::invokeRestart
[17:03:37.976]                       is.null <- base::is.null
[17:03:37.976]                       muffled <- FALSE
[17:03:37.976]                       if (inherits(cond, "message")) {
[17:03:37.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.976]                         if (muffled) 
[17:03:37.976]                           invokeRestart("muffleMessage")
[17:03:37.976]                       }
[17:03:37.976]                       else if (inherits(cond, "warning")) {
[17:03:37.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.976]                         if (muffled) 
[17:03:37.976]                           invokeRestart("muffleWarning")
[17:03:37.976]                       }
[17:03:37.976]                       else if (inherits(cond, "condition")) {
[17:03:37.976]                         if (!is.null(pattern)) {
[17:03:37.976]                           computeRestarts <- base::computeRestarts
[17:03:37.976]                           grepl <- base::grepl
[17:03:37.976]                           restarts <- computeRestarts(cond)
[17:03:37.976]                           for (restart in restarts) {
[17:03:37.976]                             name <- restart$name
[17:03:37.976]                             if (is.null(name)) 
[17:03:37.976]                               next
[17:03:37.976]                             if (!grepl(pattern, name)) 
[17:03:37.976]                               next
[17:03:37.976]                             invokeRestart(restart)
[17:03:37.976]                             muffled <- TRUE
[17:03:37.976]                             break
[17:03:37.976]                           }
[17:03:37.976]                         }
[17:03:37.976]                       }
[17:03:37.976]                       invisible(muffled)
[17:03:37.976]                     }
[17:03:37.976]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.976]                   }
[17:03:37.976]                 }
[17:03:37.976]                 else {
[17:03:37.976]                   if (TRUE) {
[17:03:37.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:37.976]                     {
[17:03:37.976]                       inherits <- base::inherits
[17:03:37.976]                       invokeRestart <- base::invokeRestart
[17:03:37.976]                       is.null <- base::is.null
[17:03:37.976]                       muffled <- FALSE
[17:03:37.976]                       if (inherits(cond, "message")) {
[17:03:37.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:37.976]                         if (muffled) 
[17:03:37.976]                           invokeRestart("muffleMessage")
[17:03:37.976]                       }
[17:03:37.976]                       else if (inherits(cond, "warning")) {
[17:03:37.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:37.976]                         if (muffled) 
[17:03:37.976]                           invokeRestart("muffleWarning")
[17:03:37.976]                       }
[17:03:37.976]                       else if (inherits(cond, "condition")) {
[17:03:37.976]                         if (!is.null(pattern)) {
[17:03:37.976]                           computeRestarts <- base::computeRestarts
[17:03:37.976]                           grepl <- base::grepl
[17:03:37.976]                           restarts <- computeRestarts(cond)
[17:03:37.976]                           for (restart in restarts) {
[17:03:37.976]                             name <- restart$name
[17:03:37.976]                             if (is.null(name)) 
[17:03:37.976]                               next
[17:03:37.976]                             if (!grepl(pattern, name)) 
[17:03:37.976]                               next
[17:03:37.976]                             invokeRestart(restart)
[17:03:37.976]                             muffled <- TRUE
[17:03:37.976]                             break
[17:03:37.976]                           }
[17:03:37.976]                         }
[17:03:37.976]                       }
[17:03:37.976]                       invisible(muffled)
[17:03:37.976]                     }
[17:03:37.976]                     muffleCondition(cond, pattern = "^muffle")
[17:03:37.976]                   }
[17:03:37.976]                 }
[17:03:37.976]             }
[17:03:37.976]         }))
[17:03:37.976]     }, error = function(ex) {
[17:03:37.976]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:37.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:37.976]                 ...future.rng), started = ...future.startTime, 
[17:03:37.976]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:37.976]             version = "1.8"), class = "FutureResult")
[17:03:37.976]     }, finally = {
[17:03:37.976]         if (!identical(...future.workdir, getwd())) 
[17:03:37.976]             setwd(...future.workdir)
[17:03:37.976]         {
[17:03:37.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:37.976]                 ...future.oldOptions$nwarnings <- NULL
[17:03:37.976]             }
[17:03:37.976]             base::options(...future.oldOptions)
[17:03:37.976]             if (.Platform$OS.type == "windows") {
[17:03:37.976]                 old_names <- names(...future.oldEnvVars)
[17:03:37.976]                 envs <- base::Sys.getenv()
[17:03:37.976]                 names <- names(envs)
[17:03:37.976]                 common <- intersect(names, old_names)
[17:03:37.976]                 added <- setdiff(names, old_names)
[17:03:37.976]                 removed <- setdiff(old_names, names)
[17:03:37.976]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:37.976]                   envs[common]]
[17:03:37.976]                 NAMES <- toupper(changed)
[17:03:37.976]                 args <- list()
[17:03:37.976]                 for (kk in seq_along(NAMES)) {
[17:03:37.976]                   name <- changed[[kk]]
[17:03:37.976]                   NAME <- NAMES[[kk]]
[17:03:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.976]                     next
[17:03:37.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.976]                 }
[17:03:37.976]                 NAMES <- toupper(added)
[17:03:37.976]                 for (kk in seq_along(NAMES)) {
[17:03:37.976]                   name <- added[[kk]]
[17:03:37.976]                   NAME <- NAMES[[kk]]
[17:03:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.976]                     next
[17:03:37.976]                   args[[name]] <- ""
[17:03:37.976]                 }
[17:03:37.976]                 NAMES <- toupper(removed)
[17:03:37.976]                 for (kk in seq_along(NAMES)) {
[17:03:37.976]                   name <- removed[[kk]]
[17:03:37.976]                   NAME <- NAMES[[kk]]
[17:03:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:37.976]                     next
[17:03:37.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:37.976]                 }
[17:03:37.976]                 if (length(args) > 0) 
[17:03:37.976]                   base::do.call(base::Sys.setenv, args = args)
[17:03:37.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:37.976]             }
[17:03:37.976]             else {
[17:03:37.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:37.976]             }
[17:03:37.976]             {
[17:03:37.976]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:37.976]                   0L) {
[17:03:37.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:37.976]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:37.976]                   base::options(opts)
[17:03:37.976]                 }
[17:03:37.976]                 {
[17:03:37.976]                   {
[17:03:37.976]                     NULL
[17:03:37.976]                     RNGkind("Mersenne-Twister")
[17:03:37.976]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:37.976]                       inherits = FALSE)
[17:03:37.976]                   }
[17:03:37.976]                   options(future.plan = NULL)
[17:03:37.976]                   if (is.na(NA_character_)) 
[17:03:37.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:37.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:37.976]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:37.976]                     .init = FALSE)
[17:03:37.976]                 }
[17:03:37.976]             }
[17:03:37.976]         }
[17:03:37.976]     })
[17:03:37.976]     if (TRUE) {
[17:03:37.976]         base::sink(type = "output", split = FALSE)
[17:03:37.976]         if (TRUE) {
[17:03:37.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:37.976]         }
[17:03:37.976]         else {
[17:03:37.976]             ...future.result["stdout"] <- base::list(NULL)
[17:03:37.976]         }
[17:03:37.976]         base::close(...future.stdout)
[17:03:37.976]         ...future.stdout <- NULL
[17:03:37.976]     }
[17:03:37.976]     ...future.result$conditions <- ...future.conditions
[17:03:37.976]     ...future.result$finished <- base::Sys.time()
[17:03:37.976]     ...future.result
[17:03:37.976] }
[17:03:37.978] plan(): Setting new future strategy stack:
[17:03:37.978] List of future strategies:
[17:03:37.978] 1. sequential:
[17:03:37.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:37.978]    - tweaked: FALSE
[17:03:37.978]    - call: NULL
[17:03:37.979] plan(): nbrOfWorkers() = 1
[17:03:38.480] plan(): Setting new future strategy stack:
[17:03:38.480] List of future strategies:
[17:03:38.480] 1. sequential:
[17:03:38.480]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.480]    - tweaked: FALSE
[17:03:38.480]    - call: plan(strategy)
[17:03:38.481] plan(): nbrOfWorkers() = 1
[17:03:38.481] SequentialFuture started (and completed)
[17:03:38.481] - Launch lazy future ... done
[17:03:38.481] run() for ‘SequentialFuture’ ... done
[17:03:38.482] getGlobalsAndPackages() ...
[17:03:38.482] Searching for globals...
[17:03:38.483] - globals found: [1] ‘{’
[17:03:38.483] Searching for globals ... DONE
[17:03:38.483] Resolving globals: FALSE
[17:03:38.483] 
[17:03:38.483] 
[17:03:38.483] getGlobalsAndPackages() ... DONE
[17:03:38.484] run() for ‘Future’ ...
[17:03:38.484] - state: ‘created’
[17:03:38.484] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:03:38.484] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:03:38.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:03:38.484]   - Field: ‘label’
[17:03:38.484]   - Field: ‘local’
[17:03:38.484]   - Field: ‘owner’
[17:03:38.485]   - Field: ‘envir’
[17:03:38.485]   - Field: ‘packages’
[17:03:38.485]   - Field: ‘gc’
[17:03:38.485]   - Field: ‘conditions’
[17:03:38.485]   - Field: ‘expr’
[17:03:38.485]   - Field: ‘uuid’
[17:03:38.485]   - Field: ‘seed’
[17:03:38.485]   - Field: ‘version’
[17:03:38.485]   - Field: ‘result’
[17:03:38.485]   - Field: ‘asynchronous’
[17:03:38.485]   - Field: ‘calls’
[17:03:38.486]   - Field: ‘globals’
[17:03:38.486]   - Field: ‘stdout’
[17:03:38.486]   - Field: ‘earlySignal’
[17:03:38.486]   - Field: ‘lazy’
[17:03:38.486]   - Field: ‘state’
[17:03:38.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:03:38.486] - Launch lazy future ...
[17:03:38.486] Packages needed by the future expression (n = 0): <none>
[17:03:38.486] Packages needed by future strategies (n = 0): <none>
[17:03:38.487] {
[17:03:38.487]     {
[17:03:38.487]         {
[17:03:38.487]             ...future.startTime <- base::Sys.time()
[17:03:38.487]             {
[17:03:38.487]                 {
[17:03:38.487]                   {
[17:03:38.487]                     base::local({
[17:03:38.487]                       has_future <- base::requireNamespace("future", 
[17:03:38.487]                         quietly = TRUE)
[17:03:38.487]                       if (has_future) {
[17:03:38.487]                         ns <- base::getNamespace("future")
[17:03:38.487]                         version <- ns[[".package"]][["version"]]
[17:03:38.487]                         if (is.null(version)) 
[17:03:38.487]                           version <- utils::packageVersion("future")
[17:03:38.487]                       }
[17:03:38.487]                       else {
[17:03:38.487]                         version <- NULL
[17:03:38.487]                       }
[17:03:38.487]                       if (!has_future || version < "1.8.0") {
[17:03:38.487]                         info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.487]                           "", base::R.version$version.string), 
[17:03:38.487]                           platform = base::sprintf("%s (%s-bit)", 
[17:03:38.487]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.487]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.487]                             "release", "version")], collapse = " "), 
[17:03:38.487]                           hostname = base::Sys.info()[["nodename"]])
[17:03:38.487]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.487]                           info)
[17:03:38.487]                         info <- base::paste(info, collapse = "; ")
[17:03:38.487]                         if (!has_future) {
[17:03:38.487]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.487]                             info)
[17:03:38.487]                         }
[17:03:38.487]                         else {
[17:03:38.487]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.487]                             info, version)
[17:03:38.487]                         }
[17:03:38.487]                         base::stop(msg)
[17:03:38.487]                       }
[17:03:38.487]                     })
[17:03:38.487]                   }
[17:03:38.487]                   ...future.strategy.old <- future::plan("list")
[17:03:38.487]                   options(future.plan = NULL)
[17:03:38.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.487]                 }
[17:03:38.487]                 ...future.workdir <- getwd()
[17:03:38.487]             }
[17:03:38.487]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.487]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.487]         }
[17:03:38.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.487]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.487]             base::names(...future.oldOptions))
[17:03:38.487]     }
[17:03:38.487]     if (FALSE) {
[17:03:38.487]     }
[17:03:38.487]     else {
[17:03:38.487]         if (TRUE) {
[17:03:38.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.487]                 open = "w")
[17:03:38.487]         }
[17:03:38.487]         else {
[17:03:38.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.487]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.487]         }
[17:03:38.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.487]             base::sink(type = "output", split = FALSE)
[17:03:38.487]             base::close(...future.stdout)
[17:03:38.487]         }, add = TRUE)
[17:03:38.487]     }
[17:03:38.487]     ...future.frame <- base::sys.nframe()
[17:03:38.487]     ...future.conditions <- base::list()
[17:03:38.487]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.487]     if (FALSE) {
[17:03:38.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.487]     }
[17:03:38.487]     ...future.result <- base::tryCatch({
[17:03:38.487]         base::withCallingHandlers({
[17:03:38.487]             ...future.value <- base::withVisible(base::local({
[17:03:38.487]                 3
[17:03:38.487]             }))
[17:03:38.487]             future::FutureResult(value = ...future.value$value, 
[17:03:38.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.487]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.487]                     ...future.globalenv.names))
[17:03:38.487]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.487]         }, condition = base::local({
[17:03:38.487]             c <- base::c
[17:03:38.487]             inherits <- base::inherits
[17:03:38.487]             invokeRestart <- base::invokeRestart
[17:03:38.487]             length <- base::length
[17:03:38.487]             list <- base::list
[17:03:38.487]             seq.int <- base::seq.int
[17:03:38.487]             signalCondition <- base::signalCondition
[17:03:38.487]             sys.calls <- base::sys.calls
[17:03:38.487]             `[[` <- base::`[[`
[17:03:38.487]             `+` <- base::`+`
[17:03:38.487]             `<<-` <- base::`<<-`
[17:03:38.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.487]                   3L)]
[17:03:38.487]             }
[17:03:38.487]             function(cond) {
[17:03:38.487]                 is_error <- inherits(cond, "error")
[17:03:38.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.487]                   NULL)
[17:03:38.487]                 if (is_error) {
[17:03:38.487]                   sessionInformation <- function() {
[17:03:38.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.487]                       search = base::search(), system = base::Sys.info())
[17:03:38.487]                   }
[17:03:38.487]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.487]                     cond$call), session = sessionInformation(), 
[17:03:38.487]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.487]                   signalCondition(cond)
[17:03:38.487]                 }
[17:03:38.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.487]                 "immediateCondition"))) {
[17:03:38.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.487]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.487]                   if (TRUE && !signal) {
[17:03:38.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.487]                     {
[17:03:38.487]                       inherits <- base::inherits
[17:03:38.487]                       invokeRestart <- base::invokeRestart
[17:03:38.487]                       is.null <- base::is.null
[17:03:38.487]                       muffled <- FALSE
[17:03:38.487]                       if (inherits(cond, "message")) {
[17:03:38.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.487]                         if (muffled) 
[17:03:38.487]                           invokeRestart("muffleMessage")
[17:03:38.487]                       }
[17:03:38.487]                       else if (inherits(cond, "warning")) {
[17:03:38.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.487]                         if (muffled) 
[17:03:38.487]                           invokeRestart("muffleWarning")
[17:03:38.487]                       }
[17:03:38.487]                       else if (inherits(cond, "condition")) {
[17:03:38.487]                         if (!is.null(pattern)) {
[17:03:38.487]                           computeRestarts <- base::computeRestarts
[17:03:38.487]                           grepl <- base::grepl
[17:03:38.487]                           restarts <- computeRestarts(cond)
[17:03:38.487]                           for (restart in restarts) {
[17:03:38.487]                             name <- restart$name
[17:03:38.487]                             if (is.null(name)) 
[17:03:38.487]                               next
[17:03:38.487]                             if (!grepl(pattern, name)) 
[17:03:38.487]                               next
[17:03:38.487]                             invokeRestart(restart)
[17:03:38.487]                             muffled <- TRUE
[17:03:38.487]                             break
[17:03:38.487]                           }
[17:03:38.487]                         }
[17:03:38.487]                       }
[17:03:38.487]                       invisible(muffled)
[17:03:38.487]                     }
[17:03:38.487]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.487]                   }
[17:03:38.487]                 }
[17:03:38.487]                 else {
[17:03:38.487]                   if (TRUE) {
[17:03:38.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.487]                     {
[17:03:38.487]                       inherits <- base::inherits
[17:03:38.487]                       invokeRestart <- base::invokeRestart
[17:03:38.487]                       is.null <- base::is.null
[17:03:38.487]                       muffled <- FALSE
[17:03:38.487]                       if (inherits(cond, "message")) {
[17:03:38.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.487]                         if (muffled) 
[17:03:38.487]                           invokeRestart("muffleMessage")
[17:03:38.487]                       }
[17:03:38.487]                       else if (inherits(cond, "warning")) {
[17:03:38.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.487]                         if (muffled) 
[17:03:38.487]                           invokeRestart("muffleWarning")
[17:03:38.487]                       }
[17:03:38.487]                       else if (inherits(cond, "condition")) {
[17:03:38.487]                         if (!is.null(pattern)) {
[17:03:38.487]                           computeRestarts <- base::computeRestarts
[17:03:38.487]                           grepl <- base::grepl
[17:03:38.487]                           restarts <- computeRestarts(cond)
[17:03:38.487]                           for (restart in restarts) {
[17:03:38.487]                             name <- restart$name
[17:03:38.487]                             if (is.null(name)) 
[17:03:38.487]                               next
[17:03:38.487]                             if (!grepl(pattern, name)) 
[17:03:38.487]                               next
[17:03:38.487]                             invokeRestart(restart)
[17:03:38.487]                             muffled <- TRUE
[17:03:38.487]                             break
[17:03:38.487]                           }
[17:03:38.487]                         }
[17:03:38.487]                       }
[17:03:38.487]                       invisible(muffled)
[17:03:38.487]                     }
[17:03:38.487]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.487]                   }
[17:03:38.487]                 }
[17:03:38.487]             }
[17:03:38.487]         }))
[17:03:38.487]     }, error = function(ex) {
[17:03:38.487]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.487]                 ...future.rng), started = ...future.startTime, 
[17:03:38.487]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.487]             version = "1.8"), class = "FutureResult")
[17:03:38.487]     }, finally = {
[17:03:38.487]         if (!identical(...future.workdir, getwd())) 
[17:03:38.487]             setwd(...future.workdir)
[17:03:38.487]         {
[17:03:38.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.487]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.487]             }
[17:03:38.487]             base::options(...future.oldOptions)
[17:03:38.487]             if (.Platform$OS.type == "windows") {
[17:03:38.487]                 old_names <- names(...future.oldEnvVars)
[17:03:38.487]                 envs <- base::Sys.getenv()
[17:03:38.487]                 names <- names(envs)
[17:03:38.487]                 common <- intersect(names, old_names)
[17:03:38.487]                 added <- setdiff(names, old_names)
[17:03:38.487]                 removed <- setdiff(old_names, names)
[17:03:38.487]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.487]                   envs[common]]
[17:03:38.487]                 NAMES <- toupper(changed)
[17:03:38.487]                 args <- list()
[17:03:38.487]                 for (kk in seq_along(NAMES)) {
[17:03:38.487]                   name <- changed[[kk]]
[17:03:38.487]                   NAME <- NAMES[[kk]]
[17:03:38.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.487]                     next
[17:03:38.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.487]                 }
[17:03:38.487]                 NAMES <- toupper(added)
[17:03:38.487]                 for (kk in seq_along(NAMES)) {
[17:03:38.487]                   name <- added[[kk]]
[17:03:38.487]                   NAME <- NAMES[[kk]]
[17:03:38.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.487]                     next
[17:03:38.487]                   args[[name]] <- ""
[17:03:38.487]                 }
[17:03:38.487]                 NAMES <- toupper(removed)
[17:03:38.487]                 for (kk in seq_along(NAMES)) {
[17:03:38.487]                   name <- removed[[kk]]
[17:03:38.487]                   NAME <- NAMES[[kk]]
[17:03:38.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.487]                     next
[17:03:38.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.487]                 }
[17:03:38.487]                 if (length(args) > 0) 
[17:03:38.487]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.487]             }
[17:03:38.487]             else {
[17:03:38.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.487]             }
[17:03:38.487]             {
[17:03:38.487]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.487]                   0L) {
[17:03:38.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.487]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.487]                   base::options(opts)
[17:03:38.487]                 }
[17:03:38.487]                 {
[17:03:38.487]                   {
[17:03:38.487]                     NULL
[17:03:38.487]                     RNGkind("Mersenne-Twister")
[17:03:38.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:03:38.487]                       inherits = FALSE)
[17:03:38.487]                   }
[17:03:38.487]                   options(future.plan = NULL)
[17:03:38.487]                   if (is.na(NA_character_)) 
[17:03:38.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.487]                     .init = FALSE)
[17:03:38.487]                 }
[17:03:38.487]             }
[17:03:38.487]         }
[17:03:38.487]     })
[17:03:38.487]     if (TRUE) {
[17:03:38.487]         base::sink(type = "output", split = FALSE)
[17:03:38.487]         if (TRUE) {
[17:03:38.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.487]         }
[17:03:38.487]         else {
[17:03:38.487]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.487]         }
[17:03:38.487]         base::close(...future.stdout)
[17:03:38.487]         ...future.stdout <- NULL
[17:03:38.487]     }
[17:03:38.487]     ...future.result$conditions <- ...future.conditions
[17:03:38.487]     ...future.result$finished <- base::Sys.time()
[17:03:38.487]     ...future.result
[17:03:38.487] }
[17:03:38.489] plan(): Setting new future strategy stack:
[17:03:38.489] List of future strategies:
[17:03:38.489] 1. sequential:
[17:03:38.489]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.489]    - tweaked: FALSE
[17:03:38.489]    - call: NULL
[17:03:38.489] plan(): nbrOfWorkers() = 1
[17:03:38.490] plan(): Setting new future strategy stack:
[17:03:38.490] List of future strategies:
[17:03:38.490] 1. sequential:
[17:03:38.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.490]    - tweaked: FALSE
[17:03:38.490]    - call: plan(strategy)
[17:03:38.491] plan(): nbrOfWorkers() = 1
[17:03:38.491] SequentialFuture started (and completed)
[17:03:38.491] - Launch lazy future ... done
[17:03:38.493] run() for ‘SequentialFuture’ ... done
[17:03:38.494] resolve() on list environment ...
[17:03:38.494]  recursive: 0
[17:03:38.495]  length: 4
[17:03:38.495]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:38.495] resolved() for ‘SequentialFuture’ ...
[17:03:38.495] - state: ‘finished’
[17:03:38.495] - run: TRUE
[17:03:38.495] - result: ‘FutureResult’
[17:03:38.495] resolved() for ‘SequentialFuture’ ... done
[17:03:38.496] Future #1
[17:03:38.496]  length: 3 (resolved future 1)
[17:03:38.496] resolved() for ‘SequentialFuture’ ...
[17:03:38.496] - state: ‘finished’
[17:03:38.496] - run: TRUE
[17:03:38.496] - result: ‘FutureResult’
[17:03:38.496] resolved() for ‘SequentialFuture’ ... done
[17:03:38.496] Future #2
[17:03:38.496]  length: 2 (resolved future 2)
[17:03:38.496] resolved() for ‘SequentialFuture’ ...
[17:03:38.496] - state: ‘finished’
[17:03:38.497] - run: TRUE
[17:03:38.497] - result: ‘FutureResult’
[17:03:38.497] resolved() for ‘SequentialFuture’ ... done
[17:03:38.497] Future #3
[17:03:38.497]  length: 1 (resolved future 3)
[17:03:38.497]  length: 0 (resolved future 4)
[17:03:38.497] resolve() on list environment ... DONE
[17:03:38.498] resolved() for ‘SequentialFuture’ ...
[17:03:38.498] - state: ‘finished’
[17:03:38.498] - run: TRUE
[17:03:38.498] - result: ‘FutureResult’
[17:03:38.498] resolved() for ‘SequentialFuture’ ... done
[17:03:38.498] resolve() on list environment ...
[17:03:38.498]  recursive: 0
[17:03:38.499]  length: 4
[17:03:38.499]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:38.499] resolved() for ‘SequentialFuture’ ...
[17:03:38.499] - state: ‘finished’
[17:03:38.499] - run: TRUE
[17:03:38.499] - result: ‘FutureResult’
[17:03:38.499] resolved() for ‘SequentialFuture’ ... done
[17:03:38.499] Future #1
[17:03:38.500]  length: 3 (resolved future 1)
[17:03:38.500] resolved() for ‘SequentialFuture’ ...
[17:03:38.500] - state: ‘finished’
[17:03:38.500] - run: TRUE
[17:03:38.500] - result: ‘FutureResult’
[17:03:38.500] resolved() for ‘SequentialFuture’ ... done
[17:03:38.500] Future #2
[17:03:38.500]  length: 2 (resolved future 2)
[17:03:38.500] resolved() for ‘SequentialFuture’ ...
[17:03:38.500] - state: ‘finished’
[17:03:38.500] - run: TRUE
[17:03:38.501] - result: ‘FutureResult’
[17:03:38.501] resolved() for ‘SequentialFuture’ ... done
[17:03:38.501] Future #3
[17:03:38.501]  length: 1 (resolved future 3)
[17:03:38.501]  length: 0 (resolved future 4)
[17:03:38.501] resolve() on list environment ... DONE
[17:03:38.502] resolve() on list environment ...
[17:03:38.502]  recursive: 0
[17:03:38.502]  length: 4
[17:03:38.502]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:38.502] resolved() for ‘SequentialFuture’ ...
[17:03:38.503] - state: ‘finished’
[17:03:38.503] - run: TRUE
[17:03:38.503] - result: ‘FutureResult’
[17:03:38.503] resolved() for ‘SequentialFuture’ ... done
[17:03:38.503] Future #1
[17:03:38.503]  length: 3 (resolved future 1)
[17:03:38.503] resolved() for ‘SequentialFuture’ ...
[17:03:38.503] - state: ‘finished’
[17:03:38.503] - run: TRUE
[17:03:38.503] - result: ‘FutureResult’
[17:03:38.504] resolved() for ‘SequentialFuture’ ... done
[17:03:38.504] Future #2
[17:03:38.504]  length: 2 (resolved future 2)
[17:03:38.504] resolved() for ‘SequentialFuture’ ...
[17:03:38.504] - state: ‘finished’
[17:03:38.504] - run: TRUE
[17:03:38.504] - result: ‘FutureResult’
[17:03:38.504] resolved() for ‘SequentialFuture’ ... done
[17:03:38.504] Future #3
[17:03:38.504]  length: 1 (resolved future 3)
[17:03:38.504]  length: 0 (resolved future 4)
[17:03:38.505] resolve() on list environment ... DONE
[17:03:38.505] resolve() on list environment ...
[17:03:38.505]  recursive: 0
[17:03:38.506]  length: 4
[17:03:38.506]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:38.506] resolved() for ‘SequentialFuture’ ...
[17:03:38.506] - state: ‘finished’
[17:03:38.506] - run: TRUE
[17:03:38.506] - result: ‘FutureResult’
[17:03:38.506] resolved() for ‘SequentialFuture’ ... done
[17:03:38.506] Future #1
[17:03:38.506]  length: 3 (resolved future 1)
[17:03:38.507] resolved() for ‘SequentialFuture’ ...
[17:03:38.507] - state: ‘finished’
[17:03:38.507] - run: TRUE
[17:03:38.507] - result: ‘FutureResult’
[17:03:38.507] resolved() for ‘SequentialFuture’ ... done
[17:03:38.507] Future #2
[17:03:38.507]  length: 2 (resolved future 2)
[17:03:38.507] resolved() for ‘SequentialFuture’ ...
[17:03:38.507] - state: ‘finished’
[17:03:38.507] - run: TRUE
[17:03:38.508] - result: ‘FutureResult’
[17:03:38.508] resolved() for ‘SequentialFuture’ ... done
[17:03:38.508] Future #3
[17:03:38.508]  length: 1 (resolved future 3)
[17:03:38.508]  length: 0 (resolved future 4)
[17:03:38.508] resolve() on list environment ... DONE
[17:03:38.508] resolve() on list environment ...
[17:03:38.509]  recursive: 0
[17:03:38.509]  length: 4
[17:03:38.509]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:38.509] resolved() for ‘SequentialFuture’ ...
[17:03:38.509] - state: ‘finished’
[17:03:38.509] - run: TRUE
[17:03:38.510] - result: ‘FutureResult’
[17:03:38.510] resolved() for ‘SequentialFuture’ ... done
[17:03:38.510] Future #1
[17:03:38.510]  length: 3 (resolved future 1)
[17:03:38.510] resolved() for ‘SequentialFuture’ ...
[17:03:38.510] - state: ‘finished’
[17:03:38.510] - run: TRUE
[17:03:38.510] - result: ‘FutureResult’
[17:03:38.510] resolved() for ‘SequentialFuture’ ... done
[17:03:38.510] Future #2
[17:03:38.511]  length: 2 (resolved future 2)
[17:03:38.511] resolved() for ‘SequentialFuture’ ...
[17:03:38.511] - state: ‘finished’
[17:03:38.511] - run: TRUE
[17:03:38.511] - result: ‘FutureResult’
[17:03:38.511] resolved() for ‘SequentialFuture’ ... done
[17:03:38.511] Future #3
[17:03:38.511]  length: 1 (resolved future 3)
[17:03:38.512]  length: 0 (resolved future 4)
[17:03:38.512] resolve() on list environment ... DONE
[17:03:38.512] resolve() on list environment ...
[17:03:38.512]  recursive: 99
[17:03:38.513]  length: 4
[17:03:38.513]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:38.513] resolved() for ‘SequentialFuture’ ...
[17:03:38.513] - state: ‘finished’
[17:03:38.513] - run: TRUE
[17:03:38.513] - result: ‘FutureResult’
[17:03:38.513] resolved() for ‘SequentialFuture’ ... done
[17:03:38.513] Future #1
[17:03:38.514] resolved() for ‘SequentialFuture’ ...
[17:03:38.516] - state: ‘finished’
[17:03:38.516] - run: TRUE
[17:03:38.516] - result: ‘FutureResult’
[17:03:38.516] resolved() for ‘SequentialFuture’ ... done
[17:03:38.516] A SequentialFuture was resolved
[17:03:38.516]  length: 3 (resolved future 1)
[17:03:38.516] resolved() for ‘SequentialFuture’ ...
[17:03:38.516] - state: ‘finished’
[17:03:38.516] - run: TRUE
[17:03:38.517] - result: ‘FutureResult’
[17:03:38.517] resolved() for ‘SequentialFuture’ ... done
[17:03:38.517] Future #2
[17:03:38.517] resolved() for ‘SequentialFuture’ ...
[17:03:38.517] - state: ‘finished’
[17:03:38.517] - run: TRUE
[17:03:38.517] - result: ‘FutureResult’
[17:03:38.517] resolved() for ‘SequentialFuture’ ... done
[17:03:38.517] A SequentialFuture was resolved
[17:03:38.517]  length: 2 (resolved future 2)
[17:03:38.518] resolved() for ‘SequentialFuture’ ...
[17:03:38.518] - state: ‘finished’
[17:03:38.518] - run: TRUE
[17:03:38.518] - result: ‘FutureResult’
[17:03:38.518] resolved() for ‘SequentialFuture’ ... done
[17:03:38.518] Future #3
[17:03:38.518] resolved() for ‘SequentialFuture’ ...
[17:03:38.518] - state: ‘finished’
[17:03:38.518] - run: TRUE
[17:03:38.518] - result: ‘FutureResult’
[17:03:38.519] resolved() for ‘SequentialFuture’ ... done
[17:03:38.519] A SequentialFuture was resolved
[17:03:38.519]  length: 1 (resolved future 3)
[17:03:38.519]  length: 0 (resolved future 4)
[17:03:38.519] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[17:03:38.520] plan(): Setting new future strategy stack:
[17:03:38.520] List of future strategies:
[17:03:38.520] 1. multicore:
[17:03:38.520]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.520]    - tweaked: FALSE
[17:03:38.520]    - call: plan(strategy)
[17:03:38.524] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[17:03:38.524] resolve() on list ...
[17:03:38.524]  recursive: 0
[17:03:38.524]  length: 2
[17:03:38.524]  elements: ‘a’, ‘b’
[17:03:38.524]  length: 1 (resolved future 1)
[17:03:38.524]  length: 0 (resolved future 2)
[17:03:38.525] resolve() on list ... DONE
[17:03:38.525] getGlobalsAndPackages() ...
[17:03:38.525] Searching for globals...
[17:03:38.525] 
[17:03:38.525] Searching for globals ... DONE
[17:03:38.525] - globals: [0] <none>
[17:03:38.525] getGlobalsAndPackages() ... DONE
[17:03:38.526] run() for ‘Future’ ...
[17:03:38.526] - state: ‘created’
[17:03:38.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.529] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.530]   - Field: ‘label’
[17:03:38.530]   - Field: ‘local’
[17:03:38.530]   - Field: ‘owner’
[17:03:38.530]   - Field: ‘envir’
[17:03:38.530]   - Field: ‘workers’
[17:03:38.530]   - Field: ‘packages’
[17:03:38.530]   - Field: ‘gc’
[17:03:38.530]   - Field: ‘job’
[17:03:38.530]   - Field: ‘conditions’
[17:03:38.530]   - Field: ‘expr’
[17:03:38.531]   - Field: ‘uuid’
[17:03:38.531]   - Field: ‘seed’
[17:03:38.531]   - Field: ‘version’
[17:03:38.531]   - Field: ‘result’
[17:03:38.531]   - Field: ‘asynchronous’
[17:03:38.531]   - Field: ‘calls’
[17:03:38.531]   - Field: ‘globals’
[17:03:38.531]   - Field: ‘stdout’
[17:03:38.531]   - Field: ‘earlySignal’
[17:03:38.531]   - Field: ‘lazy’
[17:03:38.532]   - Field: ‘state’
[17:03:38.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.532] - Launch lazy future ...
[17:03:38.533] Packages needed by the future expression (n = 0): <none>
[17:03:38.533] Packages needed by future strategies (n = 0): <none>
[17:03:38.533] {
[17:03:38.533]     {
[17:03:38.533]         {
[17:03:38.533]             ...future.startTime <- base::Sys.time()
[17:03:38.533]             {
[17:03:38.533]                 {
[17:03:38.533]                   {
[17:03:38.533]                     {
[17:03:38.533]                       base::local({
[17:03:38.533]                         has_future <- base::requireNamespace("future", 
[17:03:38.533]                           quietly = TRUE)
[17:03:38.533]                         if (has_future) {
[17:03:38.533]                           ns <- base::getNamespace("future")
[17:03:38.533]                           version <- ns[[".package"]][["version"]]
[17:03:38.533]                           if (is.null(version)) 
[17:03:38.533]                             version <- utils::packageVersion("future")
[17:03:38.533]                         }
[17:03:38.533]                         else {
[17:03:38.533]                           version <- NULL
[17:03:38.533]                         }
[17:03:38.533]                         if (!has_future || version < "1.8.0") {
[17:03:38.533]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.533]                             "", base::R.version$version.string), 
[17:03:38.533]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.533]                               "release", "version")], collapse = " "), 
[17:03:38.533]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.533]                             info)
[17:03:38.533]                           info <- base::paste(info, collapse = "; ")
[17:03:38.533]                           if (!has_future) {
[17:03:38.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.533]                               info)
[17:03:38.533]                           }
[17:03:38.533]                           else {
[17:03:38.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.533]                               info, version)
[17:03:38.533]                           }
[17:03:38.533]                           base::stop(msg)
[17:03:38.533]                         }
[17:03:38.533]                       })
[17:03:38.533]                     }
[17:03:38.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.533]                     base::options(mc.cores = 1L)
[17:03:38.533]                   }
[17:03:38.533]                   ...future.strategy.old <- future::plan("list")
[17:03:38.533]                   options(future.plan = NULL)
[17:03:38.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.533]                 }
[17:03:38.533]                 ...future.workdir <- getwd()
[17:03:38.533]             }
[17:03:38.533]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.533]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.533]         }
[17:03:38.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.533]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.533]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.533]             base::names(...future.oldOptions))
[17:03:38.533]     }
[17:03:38.533]     if (FALSE) {
[17:03:38.533]     }
[17:03:38.533]     else {
[17:03:38.533]         if (TRUE) {
[17:03:38.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.533]                 open = "w")
[17:03:38.533]         }
[17:03:38.533]         else {
[17:03:38.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.533]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.533]         }
[17:03:38.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.533]             base::sink(type = "output", split = FALSE)
[17:03:38.533]             base::close(...future.stdout)
[17:03:38.533]         }, add = TRUE)
[17:03:38.533]     }
[17:03:38.533]     ...future.frame <- base::sys.nframe()
[17:03:38.533]     ...future.conditions <- base::list()
[17:03:38.533]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.533]     if (FALSE) {
[17:03:38.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.533]     }
[17:03:38.533]     ...future.result <- base::tryCatch({
[17:03:38.533]         base::withCallingHandlers({
[17:03:38.533]             ...future.value <- base::withVisible(base::local({
[17:03:38.533]                 withCallingHandlers({
[17:03:38.533]                   1
[17:03:38.533]                 }, immediateCondition = function(cond) {
[17:03:38.533]                   save_rds <- function (object, pathname, ...) 
[17:03:38.533]                   {
[17:03:38.533]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.533]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.533]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.533]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.533]                         fi_tmp[["mtime"]])
[17:03:38.533]                     }
[17:03:38.533]                     tryCatch({
[17:03:38.533]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.533]                     }, error = function(ex) {
[17:03:38.533]                       msg <- conditionMessage(ex)
[17:03:38.533]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.533]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.533]                         fi_tmp[["mtime"]], msg)
[17:03:38.533]                       ex$message <- msg
[17:03:38.533]                       stop(ex)
[17:03:38.533]                     })
[17:03:38.533]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.533]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.533]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.533]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.533]                       fi <- file.info(pathname)
[17:03:38.533]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.533]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.533]                         fi[["size"]], fi[["mtime"]])
[17:03:38.533]                       stop(msg)
[17:03:38.533]                     }
[17:03:38.533]                     invisible(pathname)
[17:03:38.533]                   }
[17:03:38.533]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.533]                     rootPath = tempdir()) 
[17:03:38.533]                   {
[17:03:38.533]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.533]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.533]                       tmpdir = path, fileext = ".rds")
[17:03:38.533]                     save_rds(obj, file)
[17:03:38.533]                   }
[17:03:38.533]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.533]                   {
[17:03:38.533]                     inherits <- base::inherits
[17:03:38.533]                     invokeRestart <- base::invokeRestart
[17:03:38.533]                     is.null <- base::is.null
[17:03:38.533]                     muffled <- FALSE
[17:03:38.533]                     if (inherits(cond, "message")) {
[17:03:38.533]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.533]                       if (muffled) 
[17:03:38.533]                         invokeRestart("muffleMessage")
[17:03:38.533]                     }
[17:03:38.533]                     else if (inherits(cond, "warning")) {
[17:03:38.533]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.533]                       if (muffled) 
[17:03:38.533]                         invokeRestart("muffleWarning")
[17:03:38.533]                     }
[17:03:38.533]                     else if (inherits(cond, "condition")) {
[17:03:38.533]                       if (!is.null(pattern)) {
[17:03:38.533]                         computeRestarts <- base::computeRestarts
[17:03:38.533]                         grepl <- base::grepl
[17:03:38.533]                         restarts <- computeRestarts(cond)
[17:03:38.533]                         for (restart in restarts) {
[17:03:38.533]                           name <- restart$name
[17:03:38.533]                           if (is.null(name)) 
[17:03:38.533]                             next
[17:03:38.533]                           if (!grepl(pattern, name)) 
[17:03:38.533]                             next
[17:03:38.533]                           invokeRestart(restart)
[17:03:38.533]                           muffled <- TRUE
[17:03:38.533]                           break
[17:03:38.533]                         }
[17:03:38.533]                       }
[17:03:38.533]                     }
[17:03:38.533]                     invisible(muffled)
[17:03:38.533]                   }
[17:03:38.533]                   muffleCondition(cond)
[17:03:38.533]                 })
[17:03:38.533]             }))
[17:03:38.533]             future::FutureResult(value = ...future.value$value, 
[17:03:38.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.533]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.533]                     ...future.globalenv.names))
[17:03:38.533]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.533]         }, condition = base::local({
[17:03:38.533]             c <- base::c
[17:03:38.533]             inherits <- base::inherits
[17:03:38.533]             invokeRestart <- base::invokeRestart
[17:03:38.533]             length <- base::length
[17:03:38.533]             list <- base::list
[17:03:38.533]             seq.int <- base::seq.int
[17:03:38.533]             signalCondition <- base::signalCondition
[17:03:38.533]             sys.calls <- base::sys.calls
[17:03:38.533]             `[[` <- base::`[[`
[17:03:38.533]             `+` <- base::`+`
[17:03:38.533]             `<<-` <- base::`<<-`
[17:03:38.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.533]                   3L)]
[17:03:38.533]             }
[17:03:38.533]             function(cond) {
[17:03:38.533]                 is_error <- inherits(cond, "error")
[17:03:38.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.533]                   NULL)
[17:03:38.533]                 if (is_error) {
[17:03:38.533]                   sessionInformation <- function() {
[17:03:38.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.533]                       search = base::search(), system = base::Sys.info())
[17:03:38.533]                   }
[17:03:38.533]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.533]                     cond$call), session = sessionInformation(), 
[17:03:38.533]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.533]                   signalCondition(cond)
[17:03:38.533]                 }
[17:03:38.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.533]                 "immediateCondition"))) {
[17:03:38.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.533]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.533]                   if (TRUE && !signal) {
[17:03:38.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.533]                     {
[17:03:38.533]                       inherits <- base::inherits
[17:03:38.533]                       invokeRestart <- base::invokeRestart
[17:03:38.533]                       is.null <- base::is.null
[17:03:38.533]                       muffled <- FALSE
[17:03:38.533]                       if (inherits(cond, "message")) {
[17:03:38.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.533]                         if (muffled) 
[17:03:38.533]                           invokeRestart("muffleMessage")
[17:03:38.533]                       }
[17:03:38.533]                       else if (inherits(cond, "warning")) {
[17:03:38.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.533]                         if (muffled) 
[17:03:38.533]                           invokeRestart("muffleWarning")
[17:03:38.533]                       }
[17:03:38.533]                       else if (inherits(cond, "condition")) {
[17:03:38.533]                         if (!is.null(pattern)) {
[17:03:38.533]                           computeRestarts <- base::computeRestarts
[17:03:38.533]                           grepl <- base::grepl
[17:03:38.533]                           restarts <- computeRestarts(cond)
[17:03:38.533]                           for (restart in restarts) {
[17:03:38.533]                             name <- restart$name
[17:03:38.533]                             if (is.null(name)) 
[17:03:38.533]                               next
[17:03:38.533]                             if (!grepl(pattern, name)) 
[17:03:38.533]                               next
[17:03:38.533]                             invokeRestart(restart)
[17:03:38.533]                             muffled <- TRUE
[17:03:38.533]                             break
[17:03:38.533]                           }
[17:03:38.533]                         }
[17:03:38.533]                       }
[17:03:38.533]                       invisible(muffled)
[17:03:38.533]                     }
[17:03:38.533]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.533]                   }
[17:03:38.533]                 }
[17:03:38.533]                 else {
[17:03:38.533]                   if (TRUE) {
[17:03:38.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.533]                     {
[17:03:38.533]                       inherits <- base::inherits
[17:03:38.533]                       invokeRestart <- base::invokeRestart
[17:03:38.533]                       is.null <- base::is.null
[17:03:38.533]                       muffled <- FALSE
[17:03:38.533]                       if (inherits(cond, "message")) {
[17:03:38.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.533]                         if (muffled) 
[17:03:38.533]                           invokeRestart("muffleMessage")
[17:03:38.533]                       }
[17:03:38.533]                       else if (inherits(cond, "warning")) {
[17:03:38.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.533]                         if (muffled) 
[17:03:38.533]                           invokeRestart("muffleWarning")
[17:03:38.533]                       }
[17:03:38.533]                       else if (inherits(cond, "condition")) {
[17:03:38.533]                         if (!is.null(pattern)) {
[17:03:38.533]                           computeRestarts <- base::computeRestarts
[17:03:38.533]                           grepl <- base::grepl
[17:03:38.533]                           restarts <- computeRestarts(cond)
[17:03:38.533]                           for (restart in restarts) {
[17:03:38.533]                             name <- restart$name
[17:03:38.533]                             if (is.null(name)) 
[17:03:38.533]                               next
[17:03:38.533]                             if (!grepl(pattern, name)) 
[17:03:38.533]                               next
[17:03:38.533]                             invokeRestart(restart)
[17:03:38.533]                             muffled <- TRUE
[17:03:38.533]                             break
[17:03:38.533]                           }
[17:03:38.533]                         }
[17:03:38.533]                       }
[17:03:38.533]                       invisible(muffled)
[17:03:38.533]                     }
[17:03:38.533]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.533]                   }
[17:03:38.533]                 }
[17:03:38.533]             }
[17:03:38.533]         }))
[17:03:38.533]     }, error = function(ex) {
[17:03:38.533]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.533]                 ...future.rng), started = ...future.startTime, 
[17:03:38.533]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.533]             version = "1.8"), class = "FutureResult")
[17:03:38.533]     }, finally = {
[17:03:38.533]         if (!identical(...future.workdir, getwd())) 
[17:03:38.533]             setwd(...future.workdir)
[17:03:38.533]         {
[17:03:38.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.533]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.533]             }
[17:03:38.533]             base::options(...future.oldOptions)
[17:03:38.533]             if (.Platform$OS.type == "windows") {
[17:03:38.533]                 old_names <- names(...future.oldEnvVars)
[17:03:38.533]                 envs <- base::Sys.getenv()
[17:03:38.533]                 names <- names(envs)
[17:03:38.533]                 common <- intersect(names, old_names)
[17:03:38.533]                 added <- setdiff(names, old_names)
[17:03:38.533]                 removed <- setdiff(old_names, names)
[17:03:38.533]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.533]                   envs[common]]
[17:03:38.533]                 NAMES <- toupper(changed)
[17:03:38.533]                 args <- list()
[17:03:38.533]                 for (kk in seq_along(NAMES)) {
[17:03:38.533]                   name <- changed[[kk]]
[17:03:38.533]                   NAME <- NAMES[[kk]]
[17:03:38.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.533]                     next
[17:03:38.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.533]                 }
[17:03:38.533]                 NAMES <- toupper(added)
[17:03:38.533]                 for (kk in seq_along(NAMES)) {
[17:03:38.533]                   name <- added[[kk]]
[17:03:38.533]                   NAME <- NAMES[[kk]]
[17:03:38.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.533]                     next
[17:03:38.533]                   args[[name]] <- ""
[17:03:38.533]                 }
[17:03:38.533]                 NAMES <- toupper(removed)
[17:03:38.533]                 for (kk in seq_along(NAMES)) {
[17:03:38.533]                   name <- removed[[kk]]
[17:03:38.533]                   NAME <- NAMES[[kk]]
[17:03:38.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.533]                     next
[17:03:38.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.533]                 }
[17:03:38.533]                 if (length(args) > 0) 
[17:03:38.533]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.533]             }
[17:03:38.533]             else {
[17:03:38.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.533]             }
[17:03:38.533]             {
[17:03:38.533]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.533]                   0L) {
[17:03:38.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.533]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.533]                   base::options(opts)
[17:03:38.533]                 }
[17:03:38.533]                 {
[17:03:38.533]                   {
[17:03:38.533]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.533]                     NULL
[17:03:38.533]                   }
[17:03:38.533]                   options(future.plan = NULL)
[17:03:38.533]                   if (is.na(NA_character_)) 
[17:03:38.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.533]                     .init = FALSE)
[17:03:38.533]                 }
[17:03:38.533]             }
[17:03:38.533]         }
[17:03:38.533]     })
[17:03:38.533]     if (TRUE) {
[17:03:38.533]         base::sink(type = "output", split = FALSE)
[17:03:38.533]         if (TRUE) {
[17:03:38.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.533]         }
[17:03:38.533]         else {
[17:03:38.533]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.533]         }
[17:03:38.533]         base::close(...future.stdout)
[17:03:38.533]         ...future.stdout <- NULL
[17:03:38.533]     }
[17:03:38.533]     ...future.result$conditions <- ...future.conditions
[17:03:38.533]     ...future.result$finished <- base::Sys.time()
[17:03:38.533]     ...future.result
[17:03:38.533] }
[17:03:38.536] requestCore(): workers = 2
[17:03:38.539] MulticoreFuture started
[17:03:38.539] - Launch lazy future ... done
[17:03:38.539] plan(): Setting new future strategy stack:
[17:03:38.539] run() for ‘MulticoreFuture’ ... done
[17:03:38.540] getGlobalsAndPackages() ...
[17:03:38.540] Searching for globals...
[17:03:38.539] List of future strategies:
[17:03:38.539] 1. sequential:
[17:03:38.539]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.539]    - tweaked: FALSE
[17:03:38.539]    - call: NULL
[17:03:38.541] plan(): nbrOfWorkers() = 1
[17:03:38.541] 
[17:03:38.541] Searching for globals ... DONE
[17:03:38.541] - globals: [0] <none>
[17:03:38.542] getGlobalsAndPackages() ... DONE
[17:03:38.542] run() for ‘Future’ ...
[17:03:38.542] - state: ‘created’
[17:03:38.542] plan(): Setting new future strategy stack:
[17:03:38.543] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.543] List of future strategies:
[17:03:38.543] 1. multicore:
[17:03:38.543]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.543]    - tweaked: FALSE
[17:03:38.543]    - call: plan(strategy)
[17:03:38.547] plan(): nbrOfWorkers() = 2
[17:03:38.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.548]   - Field: ‘label’
[17:03:38.548]   - Field: ‘local’
[17:03:38.548]   - Field: ‘owner’
[17:03:38.548]   - Field: ‘envir’
[17:03:38.549]   - Field: ‘workers’
[17:03:38.549]   - Field: ‘packages’
[17:03:38.549]   - Field: ‘gc’
[17:03:38.549]   - Field: ‘job’
[17:03:38.549]   - Field: ‘conditions’
[17:03:38.549]   - Field: ‘expr’
[17:03:38.549]   - Field: ‘uuid’
[17:03:38.550]   - Field: ‘seed’
[17:03:38.550]   - Field: ‘version’
[17:03:38.550]   - Field: ‘result’
[17:03:38.550]   - Field: ‘asynchronous’
[17:03:38.550]   - Field: ‘calls’
[17:03:38.550]   - Field: ‘globals’
[17:03:38.550]   - Field: ‘stdout’
[17:03:38.551]   - Field: ‘earlySignal’
[17:03:38.551]   - Field: ‘lazy’
[17:03:38.551]   - Field: ‘state’
[17:03:38.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.551] - Launch lazy future ...
[17:03:38.552] Packages needed by the future expression (n = 0): <none>
[17:03:38.552] Packages needed by future strategies (n = 0): <none>
[17:03:38.552] {
[17:03:38.552]     {
[17:03:38.552]         {
[17:03:38.552]             ...future.startTime <- base::Sys.time()
[17:03:38.552]             {
[17:03:38.552]                 {
[17:03:38.552]                   {
[17:03:38.552]                     {
[17:03:38.552]                       base::local({
[17:03:38.552]                         has_future <- base::requireNamespace("future", 
[17:03:38.552]                           quietly = TRUE)
[17:03:38.552]                         if (has_future) {
[17:03:38.552]                           ns <- base::getNamespace("future")
[17:03:38.552]                           version <- ns[[".package"]][["version"]]
[17:03:38.552]                           if (is.null(version)) 
[17:03:38.552]                             version <- utils::packageVersion("future")
[17:03:38.552]                         }
[17:03:38.552]                         else {
[17:03:38.552]                           version <- NULL
[17:03:38.552]                         }
[17:03:38.552]                         if (!has_future || version < "1.8.0") {
[17:03:38.552]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.552]                             "", base::R.version$version.string), 
[17:03:38.552]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.552]                               "release", "version")], collapse = " "), 
[17:03:38.552]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.552]                             info)
[17:03:38.552]                           info <- base::paste(info, collapse = "; ")
[17:03:38.552]                           if (!has_future) {
[17:03:38.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.552]                               info)
[17:03:38.552]                           }
[17:03:38.552]                           else {
[17:03:38.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.552]                               info, version)
[17:03:38.552]                           }
[17:03:38.552]                           base::stop(msg)
[17:03:38.552]                         }
[17:03:38.552]                       })
[17:03:38.552]                     }
[17:03:38.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.552]                     base::options(mc.cores = 1L)
[17:03:38.552]                   }
[17:03:38.552]                   ...future.strategy.old <- future::plan("list")
[17:03:38.552]                   options(future.plan = NULL)
[17:03:38.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.552]                 }
[17:03:38.552]                 ...future.workdir <- getwd()
[17:03:38.552]             }
[17:03:38.552]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.552]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.552]         }
[17:03:38.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.552]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.552]             base::names(...future.oldOptions))
[17:03:38.552]     }
[17:03:38.552]     if (FALSE) {
[17:03:38.552]     }
[17:03:38.552]     else {
[17:03:38.552]         if (TRUE) {
[17:03:38.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.552]                 open = "w")
[17:03:38.552]         }
[17:03:38.552]         else {
[17:03:38.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.552]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.552]         }
[17:03:38.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.552]             base::sink(type = "output", split = FALSE)
[17:03:38.552]             base::close(...future.stdout)
[17:03:38.552]         }, add = TRUE)
[17:03:38.552]     }
[17:03:38.552]     ...future.frame <- base::sys.nframe()
[17:03:38.552]     ...future.conditions <- base::list()
[17:03:38.552]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.552]     if (FALSE) {
[17:03:38.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.552]     }
[17:03:38.552]     ...future.result <- base::tryCatch({
[17:03:38.552]         base::withCallingHandlers({
[17:03:38.552]             ...future.value <- base::withVisible(base::local({
[17:03:38.552]                 withCallingHandlers({
[17:03:38.552]                   2
[17:03:38.552]                 }, immediateCondition = function(cond) {
[17:03:38.552]                   save_rds <- function (object, pathname, ...) 
[17:03:38.552]                   {
[17:03:38.552]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.552]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.552]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.552]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.552]                         fi_tmp[["mtime"]])
[17:03:38.552]                     }
[17:03:38.552]                     tryCatch({
[17:03:38.552]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.552]                     }, error = function(ex) {
[17:03:38.552]                       msg <- conditionMessage(ex)
[17:03:38.552]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.552]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.552]                         fi_tmp[["mtime"]], msg)
[17:03:38.552]                       ex$message <- msg
[17:03:38.552]                       stop(ex)
[17:03:38.552]                     })
[17:03:38.552]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.552]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.552]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.552]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.552]                       fi <- file.info(pathname)
[17:03:38.552]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.552]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.552]                         fi[["size"]], fi[["mtime"]])
[17:03:38.552]                       stop(msg)
[17:03:38.552]                     }
[17:03:38.552]                     invisible(pathname)
[17:03:38.552]                   }
[17:03:38.552]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.552]                     rootPath = tempdir()) 
[17:03:38.552]                   {
[17:03:38.552]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.552]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.552]                       tmpdir = path, fileext = ".rds")
[17:03:38.552]                     save_rds(obj, file)
[17:03:38.552]                   }
[17:03:38.552]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.552]                   {
[17:03:38.552]                     inherits <- base::inherits
[17:03:38.552]                     invokeRestart <- base::invokeRestart
[17:03:38.552]                     is.null <- base::is.null
[17:03:38.552]                     muffled <- FALSE
[17:03:38.552]                     if (inherits(cond, "message")) {
[17:03:38.552]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.552]                       if (muffled) 
[17:03:38.552]                         invokeRestart("muffleMessage")
[17:03:38.552]                     }
[17:03:38.552]                     else if (inherits(cond, "warning")) {
[17:03:38.552]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.552]                       if (muffled) 
[17:03:38.552]                         invokeRestart("muffleWarning")
[17:03:38.552]                     }
[17:03:38.552]                     else if (inherits(cond, "condition")) {
[17:03:38.552]                       if (!is.null(pattern)) {
[17:03:38.552]                         computeRestarts <- base::computeRestarts
[17:03:38.552]                         grepl <- base::grepl
[17:03:38.552]                         restarts <- computeRestarts(cond)
[17:03:38.552]                         for (restart in restarts) {
[17:03:38.552]                           name <- restart$name
[17:03:38.552]                           if (is.null(name)) 
[17:03:38.552]                             next
[17:03:38.552]                           if (!grepl(pattern, name)) 
[17:03:38.552]                             next
[17:03:38.552]                           invokeRestart(restart)
[17:03:38.552]                           muffled <- TRUE
[17:03:38.552]                           break
[17:03:38.552]                         }
[17:03:38.552]                       }
[17:03:38.552]                     }
[17:03:38.552]                     invisible(muffled)
[17:03:38.552]                   }
[17:03:38.552]                   muffleCondition(cond)
[17:03:38.552]                 })
[17:03:38.552]             }))
[17:03:38.552]             future::FutureResult(value = ...future.value$value, 
[17:03:38.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.552]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.552]                     ...future.globalenv.names))
[17:03:38.552]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.552]         }, condition = base::local({
[17:03:38.552]             c <- base::c
[17:03:38.552]             inherits <- base::inherits
[17:03:38.552]             invokeRestart <- base::invokeRestart
[17:03:38.552]             length <- base::length
[17:03:38.552]             list <- base::list
[17:03:38.552]             seq.int <- base::seq.int
[17:03:38.552]             signalCondition <- base::signalCondition
[17:03:38.552]             sys.calls <- base::sys.calls
[17:03:38.552]             `[[` <- base::`[[`
[17:03:38.552]             `+` <- base::`+`
[17:03:38.552]             `<<-` <- base::`<<-`
[17:03:38.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.552]                   3L)]
[17:03:38.552]             }
[17:03:38.552]             function(cond) {
[17:03:38.552]                 is_error <- inherits(cond, "error")
[17:03:38.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.552]                   NULL)
[17:03:38.552]                 if (is_error) {
[17:03:38.552]                   sessionInformation <- function() {
[17:03:38.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.552]                       search = base::search(), system = base::Sys.info())
[17:03:38.552]                   }
[17:03:38.552]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.552]                     cond$call), session = sessionInformation(), 
[17:03:38.552]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.552]                   signalCondition(cond)
[17:03:38.552]                 }
[17:03:38.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.552]                 "immediateCondition"))) {
[17:03:38.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.552]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.552]                   if (TRUE && !signal) {
[17:03:38.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.552]                     {
[17:03:38.552]                       inherits <- base::inherits
[17:03:38.552]                       invokeRestart <- base::invokeRestart
[17:03:38.552]                       is.null <- base::is.null
[17:03:38.552]                       muffled <- FALSE
[17:03:38.552]                       if (inherits(cond, "message")) {
[17:03:38.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.552]                         if (muffled) 
[17:03:38.552]                           invokeRestart("muffleMessage")
[17:03:38.552]                       }
[17:03:38.552]                       else if (inherits(cond, "warning")) {
[17:03:38.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.552]                         if (muffled) 
[17:03:38.552]                           invokeRestart("muffleWarning")
[17:03:38.552]                       }
[17:03:38.552]                       else if (inherits(cond, "condition")) {
[17:03:38.552]                         if (!is.null(pattern)) {
[17:03:38.552]                           computeRestarts <- base::computeRestarts
[17:03:38.552]                           grepl <- base::grepl
[17:03:38.552]                           restarts <- computeRestarts(cond)
[17:03:38.552]                           for (restart in restarts) {
[17:03:38.552]                             name <- restart$name
[17:03:38.552]                             if (is.null(name)) 
[17:03:38.552]                               next
[17:03:38.552]                             if (!grepl(pattern, name)) 
[17:03:38.552]                               next
[17:03:38.552]                             invokeRestart(restart)
[17:03:38.552]                             muffled <- TRUE
[17:03:38.552]                             break
[17:03:38.552]                           }
[17:03:38.552]                         }
[17:03:38.552]                       }
[17:03:38.552]                       invisible(muffled)
[17:03:38.552]                     }
[17:03:38.552]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.552]                   }
[17:03:38.552]                 }
[17:03:38.552]                 else {
[17:03:38.552]                   if (TRUE) {
[17:03:38.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.552]                     {
[17:03:38.552]                       inherits <- base::inherits
[17:03:38.552]                       invokeRestart <- base::invokeRestart
[17:03:38.552]                       is.null <- base::is.null
[17:03:38.552]                       muffled <- FALSE
[17:03:38.552]                       if (inherits(cond, "message")) {
[17:03:38.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.552]                         if (muffled) 
[17:03:38.552]                           invokeRestart("muffleMessage")
[17:03:38.552]                       }
[17:03:38.552]                       else if (inherits(cond, "warning")) {
[17:03:38.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.552]                         if (muffled) 
[17:03:38.552]                           invokeRestart("muffleWarning")
[17:03:38.552]                       }
[17:03:38.552]                       else if (inherits(cond, "condition")) {
[17:03:38.552]                         if (!is.null(pattern)) {
[17:03:38.552]                           computeRestarts <- base::computeRestarts
[17:03:38.552]                           grepl <- base::grepl
[17:03:38.552]                           restarts <- computeRestarts(cond)
[17:03:38.552]                           for (restart in restarts) {
[17:03:38.552]                             name <- restart$name
[17:03:38.552]                             if (is.null(name)) 
[17:03:38.552]                               next
[17:03:38.552]                             if (!grepl(pattern, name)) 
[17:03:38.552]                               next
[17:03:38.552]                             invokeRestart(restart)
[17:03:38.552]                             muffled <- TRUE
[17:03:38.552]                             break
[17:03:38.552]                           }
[17:03:38.552]                         }
[17:03:38.552]                       }
[17:03:38.552]                       invisible(muffled)
[17:03:38.552]                     }
[17:03:38.552]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.552]                   }
[17:03:38.552]                 }
[17:03:38.552]             }
[17:03:38.552]         }))
[17:03:38.552]     }, error = function(ex) {
[17:03:38.552]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.552]                 ...future.rng), started = ...future.startTime, 
[17:03:38.552]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.552]             version = "1.8"), class = "FutureResult")
[17:03:38.552]     }, finally = {
[17:03:38.552]         if (!identical(...future.workdir, getwd())) 
[17:03:38.552]             setwd(...future.workdir)
[17:03:38.552]         {
[17:03:38.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.552]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.552]             }
[17:03:38.552]             base::options(...future.oldOptions)
[17:03:38.552]             if (.Platform$OS.type == "windows") {
[17:03:38.552]                 old_names <- names(...future.oldEnvVars)
[17:03:38.552]                 envs <- base::Sys.getenv()
[17:03:38.552]                 names <- names(envs)
[17:03:38.552]                 common <- intersect(names, old_names)
[17:03:38.552]                 added <- setdiff(names, old_names)
[17:03:38.552]                 removed <- setdiff(old_names, names)
[17:03:38.552]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.552]                   envs[common]]
[17:03:38.552]                 NAMES <- toupper(changed)
[17:03:38.552]                 args <- list()
[17:03:38.552]                 for (kk in seq_along(NAMES)) {
[17:03:38.552]                   name <- changed[[kk]]
[17:03:38.552]                   NAME <- NAMES[[kk]]
[17:03:38.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.552]                     next
[17:03:38.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.552]                 }
[17:03:38.552]                 NAMES <- toupper(added)
[17:03:38.552]                 for (kk in seq_along(NAMES)) {
[17:03:38.552]                   name <- added[[kk]]
[17:03:38.552]                   NAME <- NAMES[[kk]]
[17:03:38.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.552]                     next
[17:03:38.552]                   args[[name]] <- ""
[17:03:38.552]                 }
[17:03:38.552]                 NAMES <- toupper(removed)
[17:03:38.552]                 for (kk in seq_along(NAMES)) {
[17:03:38.552]                   name <- removed[[kk]]
[17:03:38.552]                   NAME <- NAMES[[kk]]
[17:03:38.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.552]                     next
[17:03:38.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.552]                 }
[17:03:38.552]                 if (length(args) > 0) 
[17:03:38.552]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.552]             }
[17:03:38.552]             else {
[17:03:38.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.552]             }
[17:03:38.552]             {
[17:03:38.552]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.552]                   0L) {
[17:03:38.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.552]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.552]                   base::options(opts)
[17:03:38.552]                 }
[17:03:38.552]                 {
[17:03:38.552]                   {
[17:03:38.552]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.552]                     NULL
[17:03:38.552]                   }
[17:03:38.552]                   options(future.plan = NULL)
[17:03:38.552]                   if (is.na(NA_character_)) 
[17:03:38.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.552]                     .init = FALSE)
[17:03:38.552]                 }
[17:03:38.552]             }
[17:03:38.552]         }
[17:03:38.552]     })
[17:03:38.552]     if (TRUE) {
[17:03:38.552]         base::sink(type = "output", split = FALSE)
[17:03:38.552]         if (TRUE) {
[17:03:38.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.552]         }
[17:03:38.552]         else {
[17:03:38.552]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.552]         }
[17:03:38.552]         base::close(...future.stdout)
[17:03:38.552]         ...future.stdout <- NULL
[17:03:38.552]     }
[17:03:38.552]     ...future.result$conditions <- ...future.conditions
[17:03:38.552]     ...future.result$finished <- base::Sys.time()
[17:03:38.552]     ...future.result
[17:03:38.552] }
[17:03:38.556] requestCore(): workers = 2
[17:03:38.562] MulticoreFuture started
[17:03:38.562] - Launch lazy future ... done
[17:03:38.562] run() for ‘MulticoreFuture’ ... done
[17:03:38.562] resolve() on list ...
[17:03:38.563]  recursive: 0
[17:03:38.563] plan(): Setting new future strategy stack:
[17:03:38.563]  length: 3
[17:03:38.563]  elements: ‘a’, ‘b’, ‘’
[17:03:38.563] List of future strategies:
[17:03:38.563] 1. sequential:
[17:03:38.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.563]    - tweaked: FALSE
[17:03:38.563]    - call: NULL
[17:03:38.564] plan(): nbrOfWorkers() = 1
[17:03:38.613] Future #1
[17:03:38.613]  length: 2 (resolved future 1)
[17:03:38.613] plan(): Setting new future strategy stack:
[17:03:38.613] List of future strategies:
[17:03:38.613] 1. multicore:
[17:03:38.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.613]    - tweaked: FALSE
[17:03:38.613]    - call: plan(strategy)
[17:03:38.617] plan(): nbrOfWorkers() = 2
[17:03:38.617] Future #2
[17:03:38.617]  length: 1 (resolved future 2)
[17:03:38.618]  length: 0 (resolved future 3)
[17:03:38.618] resolve() on list ... DONE
[17:03:38.618] getGlobalsAndPackages() ...
[17:03:38.618] Searching for globals...
[17:03:38.619] 
[17:03:38.619] Searching for globals ... DONE
[17:03:38.619] - globals: [0] <none>
[17:03:38.619] getGlobalsAndPackages() ... DONE
[17:03:38.619] getGlobalsAndPackages() ...
[17:03:38.619] Searching for globals...
[17:03:38.620] 
[17:03:38.620] Searching for globals ... DONE
[17:03:38.620] - globals: [0] <none>
[17:03:38.620] getGlobalsAndPackages() ... DONE
[17:03:38.620] run() for ‘Future’ ...
[17:03:38.620] - state: ‘created’
[17:03:38.620] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.624] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.624]   - Field: ‘label’
[17:03:38.624]   - Field: ‘local’
[17:03:38.625]   - Field: ‘owner’
[17:03:38.625]   - Field: ‘envir’
[17:03:38.625]   - Field: ‘workers’
[17:03:38.625]   - Field: ‘packages’
[17:03:38.625]   - Field: ‘gc’
[17:03:38.625]   - Field: ‘job’
[17:03:38.625]   - Field: ‘conditions’
[17:03:38.625]   - Field: ‘expr’
[17:03:38.625]   - Field: ‘uuid’
[17:03:38.625]   - Field: ‘seed’
[17:03:38.625]   - Field: ‘version’
[17:03:38.626]   - Field: ‘result’
[17:03:38.626]   - Field: ‘asynchronous’
[17:03:38.626]   - Field: ‘calls’
[17:03:38.626]   - Field: ‘globals’
[17:03:38.626]   - Field: ‘stdout’
[17:03:38.626]   - Field: ‘earlySignal’
[17:03:38.626]   - Field: ‘lazy’
[17:03:38.626]   - Field: ‘state’
[17:03:38.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.626] - Launch lazy future ...
[17:03:38.627] Packages needed by the future expression (n = 0): <none>
[17:03:38.627] Packages needed by future strategies (n = 0): <none>
[17:03:38.627] {
[17:03:38.627]     {
[17:03:38.627]         {
[17:03:38.627]             ...future.startTime <- base::Sys.time()
[17:03:38.627]             {
[17:03:38.627]                 {
[17:03:38.627]                   {
[17:03:38.627]                     {
[17:03:38.627]                       base::local({
[17:03:38.627]                         has_future <- base::requireNamespace("future", 
[17:03:38.627]                           quietly = TRUE)
[17:03:38.627]                         if (has_future) {
[17:03:38.627]                           ns <- base::getNamespace("future")
[17:03:38.627]                           version <- ns[[".package"]][["version"]]
[17:03:38.627]                           if (is.null(version)) 
[17:03:38.627]                             version <- utils::packageVersion("future")
[17:03:38.627]                         }
[17:03:38.627]                         else {
[17:03:38.627]                           version <- NULL
[17:03:38.627]                         }
[17:03:38.627]                         if (!has_future || version < "1.8.0") {
[17:03:38.627]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.627]                             "", base::R.version$version.string), 
[17:03:38.627]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.627]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.627]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.627]                               "release", "version")], collapse = " "), 
[17:03:38.627]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.627]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.627]                             info)
[17:03:38.627]                           info <- base::paste(info, collapse = "; ")
[17:03:38.627]                           if (!has_future) {
[17:03:38.627]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.627]                               info)
[17:03:38.627]                           }
[17:03:38.627]                           else {
[17:03:38.627]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.627]                               info, version)
[17:03:38.627]                           }
[17:03:38.627]                           base::stop(msg)
[17:03:38.627]                         }
[17:03:38.627]                       })
[17:03:38.627]                     }
[17:03:38.627]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.627]                     base::options(mc.cores = 1L)
[17:03:38.627]                   }
[17:03:38.627]                   ...future.strategy.old <- future::plan("list")
[17:03:38.627]                   options(future.plan = NULL)
[17:03:38.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.627]                 }
[17:03:38.627]                 ...future.workdir <- getwd()
[17:03:38.627]             }
[17:03:38.627]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.627]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.627]         }
[17:03:38.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.627]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.627]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.627]             base::names(...future.oldOptions))
[17:03:38.627]     }
[17:03:38.627]     if (FALSE) {
[17:03:38.627]     }
[17:03:38.627]     else {
[17:03:38.627]         if (TRUE) {
[17:03:38.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.627]                 open = "w")
[17:03:38.627]         }
[17:03:38.627]         else {
[17:03:38.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.627]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.627]         }
[17:03:38.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.627]             base::sink(type = "output", split = FALSE)
[17:03:38.627]             base::close(...future.stdout)
[17:03:38.627]         }, add = TRUE)
[17:03:38.627]     }
[17:03:38.627]     ...future.frame <- base::sys.nframe()
[17:03:38.627]     ...future.conditions <- base::list()
[17:03:38.627]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.627]     if (FALSE) {
[17:03:38.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.627]     }
[17:03:38.627]     ...future.result <- base::tryCatch({
[17:03:38.627]         base::withCallingHandlers({
[17:03:38.627]             ...future.value <- base::withVisible(base::local({
[17:03:38.627]                 withCallingHandlers({
[17:03:38.627]                   2
[17:03:38.627]                 }, immediateCondition = function(cond) {
[17:03:38.627]                   save_rds <- function (object, pathname, ...) 
[17:03:38.627]                   {
[17:03:38.627]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.627]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.627]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.627]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.627]                         fi_tmp[["mtime"]])
[17:03:38.627]                     }
[17:03:38.627]                     tryCatch({
[17:03:38.627]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.627]                     }, error = function(ex) {
[17:03:38.627]                       msg <- conditionMessage(ex)
[17:03:38.627]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.627]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.627]                         fi_tmp[["mtime"]], msg)
[17:03:38.627]                       ex$message <- msg
[17:03:38.627]                       stop(ex)
[17:03:38.627]                     })
[17:03:38.627]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.627]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.627]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.627]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.627]                       fi <- file.info(pathname)
[17:03:38.627]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.627]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.627]                         fi[["size"]], fi[["mtime"]])
[17:03:38.627]                       stop(msg)
[17:03:38.627]                     }
[17:03:38.627]                     invisible(pathname)
[17:03:38.627]                   }
[17:03:38.627]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.627]                     rootPath = tempdir()) 
[17:03:38.627]                   {
[17:03:38.627]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.627]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.627]                       tmpdir = path, fileext = ".rds")
[17:03:38.627]                     save_rds(obj, file)
[17:03:38.627]                   }
[17:03:38.627]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.627]                   {
[17:03:38.627]                     inherits <- base::inherits
[17:03:38.627]                     invokeRestart <- base::invokeRestart
[17:03:38.627]                     is.null <- base::is.null
[17:03:38.627]                     muffled <- FALSE
[17:03:38.627]                     if (inherits(cond, "message")) {
[17:03:38.627]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.627]                       if (muffled) 
[17:03:38.627]                         invokeRestart("muffleMessage")
[17:03:38.627]                     }
[17:03:38.627]                     else if (inherits(cond, "warning")) {
[17:03:38.627]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.627]                       if (muffled) 
[17:03:38.627]                         invokeRestart("muffleWarning")
[17:03:38.627]                     }
[17:03:38.627]                     else if (inherits(cond, "condition")) {
[17:03:38.627]                       if (!is.null(pattern)) {
[17:03:38.627]                         computeRestarts <- base::computeRestarts
[17:03:38.627]                         grepl <- base::grepl
[17:03:38.627]                         restarts <- computeRestarts(cond)
[17:03:38.627]                         for (restart in restarts) {
[17:03:38.627]                           name <- restart$name
[17:03:38.627]                           if (is.null(name)) 
[17:03:38.627]                             next
[17:03:38.627]                           if (!grepl(pattern, name)) 
[17:03:38.627]                             next
[17:03:38.627]                           invokeRestart(restart)
[17:03:38.627]                           muffled <- TRUE
[17:03:38.627]                           break
[17:03:38.627]                         }
[17:03:38.627]                       }
[17:03:38.627]                     }
[17:03:38.627]                     invisible(muffled)
[17:03:38.627]                   }
[17:03:38.627]                   muffleCondition(cond)
[17:03:38.627]                 })
[17:03:38.627]             }))
[17:03:38.627]             future::FutureResult(value = ...future.value$value, 
[17:03:38.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.627]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.627]                     ...future.globalenv.names))
[17:03:38.627]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.627]         }, condition = base::local({
[17:03:38.627]             c <- base::c
[17:03:38.627]             inherits <- base::inherits
[17:03:38.627]             invokeRestart <- base::invokeRestart
[17:03:38.627]             length <- base::length
[17:03:38.627]             list <- base::list
[17:03:38.627]             seq.int <- base::seq.int
[17:03:38.627]             signalCondition <- base::signalCondition
[17:03:38.627]             sys.calls <- base::sys.calls
[17:03:38.627]             `[[` <- base::`[[`
[17:03:38.627]             `+` <- base::`+`
[17:03:38.627]             `<<-` <- base::`<<-`
[17:03:38.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.627]                   3L)]
[17:03:38.627]             }
[17:03:38.627]             function(cond) {
[17:03:38.627]                 is_error <- inherits(cond, "error")
[17:03:38.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.627]                   NULL)
[17:03:38.627]                 if (is_error) {
[17:03:38.627]                   sessionInformation <- function() {
[17:03:38.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.627]                       search = base::search(), system = base::Sys.info())
[17:03:38.627]                   }
[17:03:38.627]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.627]                     cond$call), session = sessionInformation(), 
[17:03:38.627]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.627]                   signalCondition(cond)
[17:03:38.627]                 }
[17:03:38.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.627]                 "immediateCondition"))) {
[17:03:38.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.627]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.627]                   if (TRUE && !signal) {
[17:03:38.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.627]                     {
[17:03:38.627]                       inherits <- base::inherits
[17:03:38.627]                       invokeRestart <- base::invokeRestart
[17:03:38.627]                       is.null <- base::is.null
[17:03:38.627]                       muffled <- FALSE
[17:03:38.627]                       if (inherits(cond, "message")) {
[17:03:38.627]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.627]                         if (muffled) 
[17:03:38.627]                           invokeRestart("muffleMessage")
[17:03:38.627]                       }
[17:03:38.627]                       else if (inherits(cond, "warning")) {
[17:03:38.627]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.627]                         if (muffled) 
[17:03:38.627]                           invokeRestart("muffleWarning")
[17:03:38.627]                       }
[17:03:38.627]                       else if (inherits(cond, "condition")) {
[17:03:38.627]                         if (!is.null(pattern)) {
[17:03:38.627]                           computeRestarts <- base::computeRestarts
[17:03:38.627]                           grepl <- base::grepl
[17:03:38.627]                           restarts <- computeRestarts(cond)
[17:03:38.627]                           for (restart in restarts) {
[17:03:38.627]                             name <- restart$name
[17:03:38.627]                             if (is.null(name)) 
[17:03:38.627]                               next
[17:03:38.627]                             if (!grepl(pattern, name)) 
[17:03:38.627]                               next
[17:03:38.627]                             invokeRestart(restart)
[17:03:38.627]                             muffled <- TRUE
[17:03:38.627]                             break
[17:03:38.627]                           }
[17:03:38.627]                         }
[17:03:38.627]                       }
[17:03:38.627]                       invisible(muffled)
[17:03:38.627]                     }
[17:03:38.627]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.627]                   }
[17:03:38.627]                 }
[17:03:38.627]                 else {
[17:03:38.627]                   if (TRUE) {
[17:03:38.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.627]                     {
[17:03:38.627]                       inherits <- base::inherits
[17:03:38.627]                       invokeRestart <- base::invokeRestart
[17:03:38.627]                       is.null <- base::is.null
[17:03:38.627]                       muffled <- FALSE
[17:03:38.627]                       if (inherits(cond, "message")) {
[17:03:38.627]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.627]                         if (muffled) 
[17:03:38.627]                           invokeRestart("muffleMessage")
[17:03:38.627]                       }
[17:03:38.627]                       else if (inherits(cond, "warning")) {
[17:03:38.627]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.627]                         if (muffled) 
[17:03:38.627]                           invokeRestart("muffleWarning")
[17:03:38.627]                       }
[17:03:38.627]                       else if (inherits(cond, "condition")) {
[17:03:38.627]                         if (!is.null(pattern)) {
[17:03:38.627]                           computeRestarts <- base::computeRestarts
[17:03:38.627]                           grepl <- base::grepl
[17:03:38.627]                           restarts <- computeRestarts(cond)
[17:03:38.627]                           for (restart in restarts) {
[17:03:38.627]                             name <- restart$name
[17:03:38.627]                             if (is.null(name)) 
[17:03:38.627]                               next
[17:03:38.627]                             if (!grepl(pattern, name)) 
[17:03:38.627]                               next
[17:03:38.627]                             invokeRestart(restart)
[17:03:38.627]                             muffled <- TRUE
[17:03:38.627]                             break
[17:03:38.627]                           }
[17:03:38.627]                         }
[17:03:38.627]                       }
[17:03:38.627]                       invisible(muffled)
[17:03:38.627]                     }
[17:03:38.627]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.627]                   }
[17:03:38.627]                 }
[17:03:38.627]             }
[17:03:38.627]         }))
[17:03:38.627]     }, error = function(ex) {
[17:03:38.627]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.627]                 ...future.rng), started = ...future.startTime, 
[17:03:38.627]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.627]             version = "1.8"), class = "FutureResult")
[17:03:38.627]     }, finally = {
[17:03:38.627]         if (!identical(...future.workdir, getwd())) 
[17:03:38.627]             setwd(...future.workdir)
[17:03:38.627]         {
[17:03:38.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.627]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.627]             }
[17:03:38.627]             base::options(...future.oldOptions)
[17:03:38.627]             if (.Platform$OS.type == "windows") {
[17:03:38.627]                 old_names <- names(...future.oldEnvVars)
[17:03:38.627]                 envs <- base::Sys.getenv()
[17:03:38.627]                 names <- names(envs)
[17:03:38.627]                 common <- intersect(names, old_names)
[17:03:38.627]                 added <- setdiff(names, old_names)
[17:03:38.627]                 removed <- setdiff(old_names, names)
[17:03:38.627]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.627]                   envs[common]]
[17:03:38.627]                 NAMES <- toupper(changed)
[17:03:38.627]                 args <- list()
[17:03:38.627]                 for (kk in seq_along(NAMES)) {
[17:03:38.627]                   name <- changed[[kk]]
[17:03:38.627]                   NAME <- NAMES[[kk]]
[17:03:38.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.627]                     next
[17:03:38.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.627]                 }
[17:03:38.627]                 NAMES <- toupper(added)
[17:03:38.627]                 for (kk in seq_along(NAMES)) {
[17:03:38.627]                   name <- added[[kk]]
[17:03:38.627]                   NAME <- NAMES[[kk]]
[17:03:38.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.627]                     next
[17:03:38.627]                   args[[name]] <- ""
[17:03:38.627]                 }
[17:03:38.627]                 NAMES <- toupper(removed)
[17:03:38.627]                 for (kk in seq_along(NAMES)) {
[17:03:38.627]                   name <- removed[[kk]]
[17:03:38.627]                   NAME <- NAMES[[kk]]
[17:03:38.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.627]                     next
[17:03:38.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.627]                 }
[17:03:38.627]                 if (length(args) > 0) 
[17:03:38.627]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.627]             }
[17:03:38.627]             else {
[17:03:38.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.627]             }
[17:03:38.627]             {
[17:03:38.627]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.627]                   0L) {
[17:03:38.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.627]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.627]                   base::options(opts)
[17:03:38.627]                 }
[17:03:38.627]                 {
[17:03:38.627]                   {
[17:03:38.627]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.627]                     NULL
[17:03:38.627]                   }
[17:03:38.627]                   options(future.plan = NULL)
[17:03:38.627]                   if (is.na(NA_character_)) 
[17:03:38.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.627]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.627]                     .init = FALSE)
[17:03:38.627]                 }
[17:03:38.627]             }
[17:03:38.627]         }
[17:03:38.627]     })
[17:03:38.627]     if (TRUE) {
[17:03:38.627]         base::sink(type = "output", split = FALSE)
[17:03:38.627]         if (TRUE) {
[17:03:38.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.627]         }
[17:03:38.627]         else {
[17:03:38.627]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.627]         }
[17:03:38.627]         base::close(...future.stdout)
[17:03:38.627]         ...future.stdout <- NULL
[17:03:38.627]     }
[17:03:38.627]     ...future.result$conditions <- ...future.conditions
[17:03:38.627]     ...future.result$finished <- base::Sys.time()
[17:03:38.627]     ...future.result
[17:03:38.627] }
[17:03:38.630] requestCore(): workers = 2
[17:03:38.630] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:38.641] result() for MulticoreFuture ...
[17:03:38.642] result() for MulticoreFuture ...
[17:03:38.642] result() for MulticoreFuture ... done
[17:03:38.642] result() for MulticoreFuture ... done
[17:03:38.642] result() for MulticoreFuture ...
[17:03:38.643] result() for MulticoreFuture ... done
[17:03:38.645] MulticoreFuture started
[17:03:38.646] - Launch lazy future ... done
[17:03:38.646] run() for ‘MulticoreFuture’ ... done
[17:03:38.647] resolve() on list ...
[17:03:38.647] plan(): Setting new future strategy stack:
[17:03:38.647]  recursive: 0
[17:03:38.647]  length: 3
[17:03:38.647]  elements: ‘a’, ‘b’, ‘’
[17:03:38.648] run() for ‘Future’ ...
[17:03:38.648] - state: ‘created’
[17:03:38.647] List of future strategies:
[17:03:38.647] 1. sequential:
[17:03:38.647]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.647]    - tweaked: FALSE
[17:03:38.647]    - call: NULL
[17:03:38.648] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.649] plan(): nbrOfWorkers() = 1
[17:03:38.651] plan(): Setting new future strategy stack:
[17:03:38.651] List of future strategies:
[17:03:38.651] 1. multicore:
[17:03:38.651]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.651]    - tweaked: FALSE
[17:03:38.651]    - call: plan(strategy)
[17:03:38.655] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.655]   - Field: ‘label’
[17:03:38.655]   - Field: ‘local’
[17:03:38.656]   - Field: ‘owner’
[17:03:38.656]   - Field: ‘envir’
[17:03:38.656]   - Field: ‘workers’
[17:03:38.656]   - Field: ‘packages’
[17:03:38.657] plan(): nbrOfWorkers() = 2
[17:03:38.657]   - Field: ‘gc’
[17:03:38.657]   - Field: ‘job’
[17:03:38.657]   - Field: ‘conditions’
[17:03:38.657]   - Field: ‘expr’
[17:03:38.657]   - Field: ‘uuid’
[17:03:38.658]   - Field: ‘seed’
[17:03:38.658]   - Field: ‘version’
[17:03:38.658]   - Field: ‘result’
[17:03:38.658]   - Field: ‘asynchronous’
[17:03:38.658]   - Field: ‘calls’
[17:03:38.658]   - Field: ‘globals’
[17:03:38.658]   - Field: ‘stdout’
[17:03:38.659]   - Field: ‘earlySignal’
[17:03:38.659]   - Field: ‘lazy’
[17:03:38.659]   - Field: ‘state’
[17:03:38.659] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.659] - Launch lazy future ...
[17:03:38.660] Packages needed by the future expression (n = 0): <none>
[17:03:38.660] Packages needed by future strategies (n = 0): <none>
[17:03:38.661] {
[17:03:38.661]     {
[17:03:38.661]         {
[17:03:38.661]             ...future.startTime <- base::Sys.time()
[17:03:38.661]             {
[17:03:38.661]                 {
[17:03:38.661]                   {
[17:03:38.661]                     {
[17:03:38.661]                       base::local({
[17:03:38.661]                         has_future <- base::requireNamespace("future", 
[17:03:38.661]                           quietly = TRUE)
[17:03:38.661]                         if (has_future) {
[17:03:38.661]                           ns <- base::getNamespace("future")
[17:03:38.661]                           version <- ns[[".package"]][["version"]]
[17:03:38.661]                           if (is.null(version)) 
[17:03:38.661]                             version <- utils::packageVersion("future")
[17:03:38.661]                         }
[17:03:38.661]                         else {
[17:03:38.661]                           version <- NULL
[17:03:38.661]                         }
[17:03:38.661]                         if (!has_future || version < "1.8.0") {
[17:03:38.661]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.661]                             "", base::R.version$version.string), 
[17:03:38.661]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.661]                               "release", "version")], collapse = " "), 
[17:03:38.661]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.661]                             info)
[17:03:38.661]                           info <- base::paste(info, collapse = "; ")
[17:03:38.661]                           if (!has_future) {
[17:03:38.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.661]                               info)
[17:03:38.661]                           }
[17:03:38.661]                           else {
[17:03:38.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.661]                               info, version)
[17:03:38.661]                           }
[17:03:38.661]                           base::stop(msg)
[17:03:38.661]                         }
[17:03:38.661]                       })
[17:03:38.661]                     }
[17:03:38.661]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.661]                     base::options(mc.cores = 1L)
[17:03:38.661]                   }
[17:03:38.661]                   ...future.strategy.old <- future::plan("list")
[17:03:38.661]                   options(future.plan = NULL)
[17:03:38.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.661]                 }
[17:03:38.661]                 ...future.workdir <- getwd()
[17:03:38.661]             }
[17:03:38.661]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.661]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.661]         }
[17:03:38.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.661]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.661]             base::names(...future.oldOptions))
[17:03:38.661]     }
[17:03:38.661]     if (FALSE) {
[17:03:38.661]     }
[17:03:38.661]     else {
[17:03:38.661]         if (TRUE) {
[17:03:38.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.661]                 open = "w")
[17:03:38.661]         }
[17:03:38.661]         else {
[17:03:38.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.661]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.661]         }
[17:03:38.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.661]             base::sink(type = "output", split = FALSE)
[17:03:38.661]             base::close(...future.stdout)
[17:03:38.661]         }, add = TRUE)
[17:03:38.661]     }
[17:03:38.661]     ...future.frame <- base::sys.nframe()
[17:03:38.661]     ...future.conditions <- base::list()
[17:03:38.661]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.661]     if (FALSE) {
[17:03:38.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.661]     }
[17:03:38.661]     ...future.result <- base::tryCatch({
[17:03:38.661]         base::withCallingHandlers({
[17:03:38.661]             ...future.value <- base::withVisible(base::local({
[17:03:38.661]                 withCallingHandlers({
[17:03:38.661]                   1
[17:03:38.661]                 }, immediateCondition = function(cond) {
[17:03:38.661]                   save_rds <- function (object, pathname, ...) 
[17:03:38.661]                   {
[17:03:38.661]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.661]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.661]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.661]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.661]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.661]                         fi_tmp[["mtime"]])
[17:03:38.661]                     }
[17:03:38.661]                     tryCatch({
[17:03:38.661]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.661]                     }, error = function(ex) {
[17:03:38.661]                       msg <- conditionMessage(ex)
[17:03:38.661]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.661]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.661]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.661]                         fi_tmp[["mtime"]], msg)
[17:03:38.661]                       ex$message <- msg
[17:03:38.661]                       stop(ex)
[17:03:38.661]                     })
[17:03:38.661]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.661]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.661]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.661]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.661]                       fi <- file.info(pathname)
[17:03:38.661]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.661]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.661]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.661]                         fi[["size"]], fi[["mtime"]])
[17:03:38.661]                       stop(msg)
[17:03:38.661]                     }
[17:03:38.661]                     invisible(pathname)
[17:03:38.661]                   }
[17:03:38.661]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.661]                     rootPath = tempdir()) 
[17:03:38.661]                   {
[17:03:38.661]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.661]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.661]                       tmpdir = path, fileext = ".rds")
[17:03:38.661]                     save_rds(obj, file)
[17:03:38.661]                   }
[17:03:38.661]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.661]                   {
[17:03:38.661]                     inherits <- base::inherits
[17:03:38.661]                     invokeRestart <- base::invokeRestart
[17:03:38.661]                     is.null <- base::is.null
[17:03:38.661]                     muffled <- FALSE
[17:03:38.661]                     if (inherits(cond, "message")) {
[17:03:38.661]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.661]                       if (muffled) 
[17:03:38.661]                         invokeRestart("muffleMessage")
[17:03:38.661]                     }
[17:03:38.661]                     else if (inherits(cond, "warning")) {
[17:03:38.661]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.661]                       if (muffled) 
[17:03:38.661]                         invokeRestart("muffleWarning")
[17:03:38.661]                     }
[17:03:38.661]                     else if (inherits(cond, "condition")) {
[17:03:38.661]                       if (!is.null(pattern)) {
[17:03:38.661]                         computeRestarts <- base::computeRestarts
[17:03:38.661]                         grepl <- base::grepl
[17:03:38.661]                         restarts <- computeRestarts(cond)
[17:03:38.661]                         for (restart in restarts) {
[17:03:38.661]                           name <- restart$name
[17:03:38.661]                           if (is.null(name)) 
[17:03:38.661]                             next
[17:03:38.661]                           if (!grepl(pattern, name)) 
[17:03:38.661]                             next
[17:03:38.661]                           invokeRestart(restart)
[17:03:38.661]                           muffled <- TRUE
[17:03:38.661]                           break
[17:03:38.661]                         }
[17:03:38.661]                       }
[17:03:38.661]                     }
[17:03:38.661]                     invisible(muffled)
[17:03:38.661]                   }
[17:03:38.661]                   muffleCondition(cond)
[17:03:38.661]                 })
[17:03:38.661]             }))
[17:03:38.661]             future::FutureResult(value = ...future.value$value, 
[17:03:38.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.661]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.661]                     ...future.globalenv.names))
[17:03:38.661]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.661]         }, condition = base::local({
[17:03:38.661]             c <- base::c
[17:03:38.661]             inherits <- base::inherits
[17:03:38.661]             invokeRestart <- base::invokeRestart
[17:03:38.661]             length <- base::length
[17:03:38.661]             list <- base::list
[17:03:38.661]             seq.int <- base::seq.int
[17:03:38.661]             signalCondition <- base::signalCondition
[17:03:38.661]             sys.calls <- base::sys.calls
[17:03:38.661]             `[[` <- base::`[[`
[17:03:38.661]             `+` <- base::`+`
[17:03:38.661]             `<<-` <- base::`<<-`
[17:03:38.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.661]                   3L)]
[17:03:38.661]             }
[17:03:38.661]             function(cond) {
[17:03:38.661]                 is_error <- inherits(cond, "error")
[17:03:38.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.661]                   NULL)
[17:03:38.661]                 if (is_error) {
[17:03:38.661]                   sessionInformation <- function() {
[17:03:38.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.661]                       search = base::search(), system = base::Sys.info())
[17:03:38.661]                   }
[17:03:38.661]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.661]                     cond$call), session = sessionInformation(), 
[17:03:38.661]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.661]                   signalCondition(cond)
[17:03:38.661]                 }
[17:03:38.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.661]                 "immediateCondition"))) {
[17:03:38.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.661]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.661]                   if (TRUE && !signal) {
[17:03:38.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.661]                     {
[17:03:38.661]                       inherits <- base::inherits
[17:03:38.661]                       invokeRestart <- base::invokeRestart
[17:03:38.661]                       is.null <- base::is.null
[17:03:38.661]                       muffled <- FALSE
[17:03:38.661]                       if (inherits(cond, "message")) {
[17:03:38.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.661]                         if (muffled) 
[17:03:38.661]                           invokeRestart("muffleMessage")
[17:03:38.661]                       }
[17:03:38.661]                       else if (inherits(cond, "warning")) {
[17:03:38.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.661]                         if (muffled) 
[17:03:38.661]                           invokeRestart("muffleWarning")
[17:03:38.661]                       }
[17:03:38.661]                       else if (inherits(cond, "condition")) {
[17:03:38.661]                         if (!is.null(pattern)) {
[17:03:38.661]                           computeRestarts <- base::computeRestarts
[17:03:38.661]                           grepl <- base::grepl
[17:03:38.661]                           restarts <- computeRestarts(cond)
[17:03:38.661]                           for (restart in restarts) {
[17:03:38.661]                             name <- restart$name
[17:03:38.661]                             if (is.null(name)) 
[17:03:38.661]                               next
[17:03:38.661]                             if (!grepl(pattern, name)) 
[17:03:38.661]                               next
[17:03:38.661]                             invokeRestart(restart)
[17:03:38.661]                             muffled <- TRUE
[17:03:38.661]                             break
[17:03:38.661]                           }
[17:03:38.661]                         }
[17:03:38.661]                       }
[17:03:38.661]                       invisible(muffled)
[17:03:38.661]                     }
[17:03:38.661]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.661]                   }
[17:03:38.661]                 }
[17:03:38.661]                 else {
[17:03:38.661]                   if (TRUE) {
[17:03:38.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.661]                     {
[17:03:38.661]                       inherits <- base::inherits
[17:03:38.661]                       invokeRestart <- base::invokeRestart
[17:03:38.661]                       is.null <- base::is.null
[17:03:38.661]                       muffled <- FALSE
[17:03:38.661]                       if (inherits(cond, "message")) {
[17:03:38.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.661]                         if (muffled) 
[17:03:38.661]                           invokeRestart("muffleMessage")
[17:03:38.661]                       }
[17:03:38.661]                       else if (inherits(cond, "warning")) {
[17:03:38.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.661]                         if (muffled) 
[17:03:38.661]                           invokeRestart("muffleWarning")
[17:03:38.661]                       }
[17:03:38.661]                       else if (inherits(cond, "condition")) {
[17:03:38.661]                         if (!is.null(pattern)) {
[17:03:38.661]                           computeRestarts <- base::computeRestarts
[17:03:38.661]                           grepl <- base::grepl
[17:03:38.661]                           restarts <- computeRestarts(cond)
[17:03:38.661]                           for (restart in restarts) {
[17:03:38.661]                             name <- restart$name
[17:03:38.661]                             if (is.null(name)) 
[17:03:38.661]                               next
[17:03:38.661]                             if (!grepl(pattern, name)) 
[17:03:38.661]                               next
[17:03:38.661]                             invokeRestart(restart)
[17:03:38.661]                             muffled <- TRUE
[17:03:38.661]                             break
[17:03:38.661]                           }
[17:03:38.661]                         }
[17:03:38.661]                       }
[17:03:38.661]                       invisible(muffled)
[17:03:38.661]                     }
[17:03:38.661]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.661]                   }
[17:03:38.661]                 }
[17:03:38.661]             }
[17:03:38.661]         }))
[17:03:38.661]     }, error = function(ex) {
[17:03:38.661]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.661]                 ...future.rng), started = ...future.startTime, 
[17:03:38.661]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.661]             version = "1.8"), class = "FutureResult")
[17:03:38.661]     }, finally = {
[17:03:38.661]         if (!identical(...future.workdir, getwd())) 
[17:03:38.661]             setwd(...future.workdir)
[17:03:38.661]         {
[17:03:38.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.661]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.661]             }
[17:03:38.661]             base::options(...future.oldOptions)
[17:03:38.661]             if (.Platform$OS.type == "windows") {
[17:03:38.661]                 old_names <- names(...future.oldEnvVars)
[17:03:38.661]                 envs <- base::Sys.getenv()
[17:03:38.661]                 names <- names(envs)
[17:03:38.661]                 common <- intersect(names, old_names)
[17:03:38.661]                 added <- setdiff(names, old_names)
[17:03:38.661]                 removed <- setdiff(old_names, names)
[17:03:38.661]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.661]                   envs[common]]
[17:03:38.661]                 NAMES <- toupper(changed)
[17:03:38.661]                 args <- list()
[17:03:38.661]                 for (kk in seq_along(NAMES)) {
[17:03:38.661]                   name <- changed[[kk]]
[17:03:38.661]                   NAME <- NAMES[[kk]]
[17:03:38.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.661]                     next
[17:03:38.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.661]                 }
[17:03:38.661]                 NAMES <- toupper(added)
[17:03:38.661]                 for (kk in seq_along(NAMES)) {
[17:03:38.661]                   name <- added[[kk]]
[17:03:38.661]                   NAME <- NAMES[[kk]]
[17:03:38.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.661]                     next
[17:03:38.661]                   args[[name]] <- ""
[17:03:38.661]                 }
[17:03:38.661]                 NAMES <- toupper(removed)
[17:03:38.661]                 for (kk in seq_along(NAMES)) {
[17:03:38.661]                   name <- removed[[kk]]
[17:03:38.661]                   NAME <- NAMES[[kk]]
[17:03:38.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.661]                     next
[17:03:38.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.661]                 }
[17:03:38.661]                 if (length(args) > 0) 
[17:03:38.661]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.661]             }
[17:03:38.661]             else {
[17:03:38.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.661]             }
[17:03:38.661]             {
[17:03:38.661]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.661]                   0L) {
[17:03:38.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.661]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.661]                   base::options(opts)
[17:03:38.661]                 }
[17:03:38.661]                 {
[17:03:38.661]                   {
[17:03:38.661]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.661]                     NULL
[17:03:38.661]                   }
[17:03:38.661]                   options(future.plan = NULL)
[17:03:38.661]                   if (is.na(NA_character_)) 
[17:03:38.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.661]                     .init = FALSE)
[17:03:38.661]                 }
[17:03:38.661]             }
[17:03:38.661]         }
[17:03:38.661]     })
[17:03:38.661]     if (TRUE) {
[17:03:38.661]         base::sink(type = "output", split = FALSE)
[17:03:38.661]         if (TRUE) {
[17:03:38.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.661]         }
[17:03:38.661]         else {
[17:03:38.661]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.661]         }
[17:03:38.661]         base::close(...future.stdout)
[17:03:38.661]         ...future.stdout <- NULL
[17:03:38.661]     }
[17:03:38.661]     ...future.result$conditions <- ...future.conditions
[17:03:38.661]     ...future.result$finished <- base::Sys.time()
[17:03:38.661]     ...future.result
[17:03:38.661] }
[17:03:38.664] requestCore(): workers = 2
[17:03:38.664] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:38.691] result() for MulticoreFuture ...
[17:03:38.692] result() for MulticoreFuture ...
[17:03:38.693] result() for MulticoreFuture ... done
[17:03:38.693] result() for MulticoreFuture ... done
[17:03:38.693] result() for MulticoreFuture ...
[17:03:38.693] result() for MulticoreFuture ... done
[17:03:38.696] MulticoreFuture started
[17:03:38.697] - Launch lazy future ... done
[17:03:38.697] run() for ‘MulticoreFuture’ ... done
[17:03:38.698] plan(): Setting new future strategy stack:
[17:03:38.698] List of future strategies:
[17:03:38.698] 1. sequential:
[17:03:38.698]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.698]    - tweaked: FALSE
[17:03:38.698]    - call: NULL
[17:03:38.699] plan(): nbrOfWorkers() = 1
[17:03:38.702] plan(): Setting new future strategy stack:
[17:03:38.702] List of future strategies:
[17:03:38.702] 1. multicore:
[17:03:38.702]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.702]    - tweaked: FALSE
[17:03:38.702]    - call: plan(strategy)
[17:03:38.708] plan(): nbrOfWorkers() = 2
[17:03:38.709] Future #2
[17:03:38.709]  length: 2 (resolved future 2)
[17:03:38.709]  length: 1 (resolved future 3)
[17:03:38.720] Future #1
[17:03:38.720]  length: 0 (resolved future 1)
[17:03:38.720] resolve() on list ... DONE
[17:03:38.721] getGlobalsAndPackages() ...
[17:03:38.721] Searching for globals...
[17:03:38.722] 
[17:03:38.722] Searching for globals ... DONE
[17:03:38.722] - globals: [0] <none>
[17:03:38.722] getGlobalsAndPackages() ... DONE
[17:03:38.723] getGlobalsAndPackages() ...
[17:03:38.723] Searching for globals...
[17:03:38.723] 
[17:03:38.724] Searching for globals ... DONE
[17:03:38.724] - globals: [0] <none>
[17:03:38.724] getGlobalsAndPackages() ... DONE
[17:03:38.724] resolve() on list ...
[17:03:38.724]  recursive: 0
[17:03:38.725]  length: 3
[17:03:38.725]  elements: ‘a’, ‘b’, ‘’
[17:03:38.725] run() for ‘Future’ ...
[17:03:38.725] - state: ‘created’
[17:03:38.725] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.730] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.730]   - Field: ‘label’
[17:03:38.731]   - Field: ‘local’
[17:03:38.731]   - Field: ‘owner’
[17:03:38.731]   - Field: ‘envir’
[17:03:38.731]   - Field: ‘workers’
[17:03:38.731]   - Field: ‘packages’
[17:03:38.731]   - Field: ‘gc’
[17:03:38.732]   - Field: ‘job’
[17:03:38.732]   - Field: ‘conditions’
[17:03:38.732]   - Field: ‘expr’
[17:03:38.732]   - Field: ‘uuid’
[17:03:38.732]   - Field: ‘seed’
[17:03:38.732]   - Field: ‘version’
[17:03:38.732]   - Field: ‘result’
[17:03:38.733]   - Field: ‘asynchronous’
[17:03:38.733]   - Field: ‘calls’
[17:03:38.733]   - Field: ‘globals’
[17:03:38.733]   - Field: ‘stdout’
[17:03:38.733]   - Field: ‘earlySignal’
[17:03:38.733]   - Field: ‘lazy’
[17:03:38.733]   - Field: ‘state’
[17:03:38.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.734] - Launch lazy future ...
[17:03:38.734] Packages needed by the future expression (n = 0): <none>
[17:03:38.734] Packages needed by future strategies (n = 0): <none>
[17:03:38.735] {
[17:03:38.735]     {
[17:03:38.735]         {
[17:03:38.735]             ...future.startTime <- base::Sys.time()
[17:03:38.735]             {
[17:03:38.735]                 {
[17:03:38.735]                   {
[17:03:38.735]                     {
[17:03:38.735]                       base::local({
[17:03:38.735]                         has_future <- base::requireNamespace("future", 
[17:03:38.735]                           quietly = TRUE)
[17:03:38.735]                         if (has_future) {
[17:03:38.735]                           ns <- base::getNamespace("future")
[17:03:38.735]                           version <- ns[[".package"]][["version"]]
[17:03:38.735]                           if (is.null(version)) 
[17:03:38.735]                             version <- utils::packageVersion("future")
[17:03:38.735]                         }
[17:03:38.735]                         else {
[17:03:38.735]                           version <- NULL
[17:03:38.735]                         }
[17:03:38.735]                         if (!has_future || version < "1.8.0") {
[17:03:38.735]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.735]                             "", base::R.version$version.string), 
[17:03:38.735]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.735]                               "release", "version")], collapse = " "), 
[17:03:38.735]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.735]                             info)
[17:03:38.735]                           info <- base::paste(info, collapse = "; ")
[17:03:38.735]                           if (!has_future) {
[17:03:38.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.735]                               info)
[17:03:38.735]                           }
[17:03:38.735]                           else {
[17:03:38.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.735]                               info, version)
[17:03:38.735]                           }
[17:03:38.735]                           base::stop(msg)
[17:03:38.735]                         }
[17:03:38.735]                       })
[17:03:38.735]                     }
[17:03:38.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.735]                     base::options(mc.cores = 1L)
[17:03:38.735]                   }
[17:03:38.735]                   ...future.strategy.old <- future::plan("list")
[17:03:38.735]                   options(future.plan = NULL)
[17:03:38.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.735]                 }
[17:03:38.735]                 ...future.workdir <- getwd()
[17:03:38.735]             }
[17:03:38.735]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.735]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.735]         }
[17:03:38.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.735]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.735]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.735]             base::names(...future.oldOptions))
[17:03:38.735]     }
[17:03:38.735]     if (FALSE) {
[17:03:38.735]     }
[17:03:38.735]     else {
[17:03:38.735]         if (TRUE) {
[17:03:38.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.735]                 open = "w")
[17:03:38.735]         }
[17:03:38.735]         else {
[17:03:38.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.735]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.735]         }
[17:03:38.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.735]             base::sink(type = "output", split = FALSE)
[17:03:38.735]             base::close(...future.stdout)
[17:03:38.735]         }, add = TRUE)
[17:03:38.735]     }
[17:03:38.735]     ...future.frame <- base::sys.nframe()
[17:03:38.735]     ...future.conditions <- base::list()
[17:03:38.735]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.735]     if (FALSE) {
[17:03:38.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.735]     }
[17:03:38.735]     ...future.result <- base::tryCatch({
[17:03:38.735]         base::withCallingHandlers({
[17:03:38.735]             ...future.value <- base::withVisible(base::local({
[17:03:38.735]                 withCallingHandlers({
[17:03:38.735]                   1
[17:03:38.735]                 }, immediateCondition = function(cond) {
[17:03:38.735]                   save_rds <- function (object, pathname, ...) 
[17:03:38.735]                   {
[17:03:38.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.735]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.735]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.735]                         fi_tmp[["mtime"]])
[17:03:38.735]                     }
[17:03:38.735]                     tryCatch({
[17:03:38.735]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.735]                     }, error = function(ex) {
[17:03:38.735]                       msg <- conditionMessage(ex)
[17:03:38.735]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.735]                         fi_tmp[["mtime"]], msg)
[17:03:38.735]                       ex$message <- msg
[17:03:38.735]                       stop(ex)
[17:03:38.735]                     })
[17:03:38.735]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.735]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.735]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.735]                       fi <- file.info(pathname)
[17:03:38.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.735]                         fi[["size"]], fi[["mtime"]])
[17:03:38.735]                       stop(msg)
[17:03:38.735]                     }
[17:03:38.735]                     invisible(pathname)
[17:03:38.735]                   }
[17:03:38.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.735]                     rootPath = tempdir()) 
[17:03:38.735]                   {
[17:03:38.735]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.735]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.735]                       tmpdir = path, fileext = ".rds")
[17:03:38.735]                     save_rds(obj, file)
[17:03:38.735]                   }
[17:03:38.735]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.735]                   {
[17:03:38.735]                     inherits <- base::inherits
[17:03:38.735]                     invokeRestart <- base::invokeRestart
[17:03:38.735]                     is.null <- base::is.null
[17:03:38.735]                     muffled <- FALSE
[17:03:38.735]                     if (inherits(cond, "message")) {
[17:03:38.735]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.735]                       if (muffled) 
[17:03:38.735]                         invokeRestart("muffleMessage")
[17:03:38.735]                     }
[17:03:38.735]                     else if (inherits(cond, "warning")) {
[17:03:38.735]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.735]                       if (muffled) 
[17:03:38.735]                         invokeRestart("muffleWarning")
[17:03:38.735]                     }
[17:03:38.735]                     else if (inherits(cond, "condition")) {
[17:03:38.735]                       if (!is.null(pattern)) {
[17:03:38.735]                         computeRestarts <- base::computeRestarts
[17:03:38.735]                         grepl <- base::grepl
[17:03:38.735]                         restarts <- computeRestarts(cond)
[17:03:38.735]                         for (restart in restarts) {
[17:03:38.735]                           name <- restart$name
[17:03:38.735]                           if (is.null(name)) 
[17:03:38.735]                             next
[17:03:38.735]                           if (!grepl(pattern, name)) 
[17:03:38.735]                             next
[17:03:38.735]                           invokeRestart(restart)
[17:03:38.735]                           muffled <- TRUE
[17:03:38.735]                           break
[17:03:38.735]                         }
[17:03:38.735]                       }
[17:03:38.735]                     }
[17:03:38.735]                     invisible(muffled)
[17:03:38.735]                   }
[17:03:38.735]                   muffleCondition(cond)
[17:03:38.735]                 })
[17:03:38.735]             }))
[17:03:38.735]             future::FutureResult(value = ...future.value$value, 
[17:03:38.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.735]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.735]                     ...future.globalenv.names))
[17:03:38.735]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.735]         }, condition = base::local({
[17:03:38.735]             c <- base::c
[17:03:38.735]             inherits <- base::inherits
[17:03:38.735]             invokeRestart <- base::invokeRestart
[17:03:38.735]             length <- base::length
[17:03:38.735]             list <- base::list
[17:03:38.735]             seq.int <- base::seq.int
[17:03:38.735]             signalCondition <- base::signalCondition
[17:03:38.735]             sys.calls <- base::sys.calls
[17:03:38.735]             `[[` <- base::`[[`
[17:03:38.735]             `+` <- base::`+`
[17:03:38.735]             `<<-` <- base::`<<-`
[17:03:38.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.735]                   3L)]
[17:03:38.735]             }
[17:03:38.735]             function(cond) {
[17:03:38.735]                 is_error <- inherits(cond, "error")
[17:03:38.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.735]                   NULL)
[17:03:38.735]                 if (is_error) {
[17:03:38.735]                   sessionInformation <- function() {
[17:03:38.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.735]                       search = base::search(), system = base::Sys.info())
[17:03:38.735]                   }
[17:03:38.735]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.735]                     cond$call), session = sessionInformation(), 
[17:03:38.735]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.735]                   signalCondition(cond)
[17:03:38.735]                 }
[17:03:38.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.735]                 "immediateCondition"))) {
[17:03:38.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.735]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.735]                   if (TRUE && !signal) {
[17:03:38.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.735]                     {
[17:03:38.735]                       inherits <- base::inherits
[17:03:38.735]                       invokeRestart <- base::invokeRestart
[17:03:38.735]                       is.null <- base::is.null
[17:03:38.735]                       muffled <- FALSE
[17:03:38.735]                       if (inherits(cond, "message")) {
[17:03:38.735]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.735]                         if (muffled) 
[17:03:38.735]                           invokeRestart("muffleMessage")
[17:03:38.735]                       }
[17:03:38.735]                       else if (inherits(cond, "warning")) {
[17:03:38.735]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.735]                         if (muffled) 
[17:03:38.735]                           invokeRestart("muffleWarning")
[17:03:38.735]                       }
[17:03:38.735]                       else if (inherits(cond, "condition")) {
[17:03:38.735]                         if (!is.null(pattern)) {
[17:03:38.735]                           computeRestarts <- base::computeRestarts
[17:03:38.735]                           grepl <- base::grepl
[17:03:38.735]                           restarts <- computeRestarts(cond)
[17:03:38.735]                           for (restart in restarts) {
[17:03:38.735]                             name <- restart$name
[17:03:38.735]                             if (is.null(name)) 
[17:03:38.735]                               next
[17:03:38.735]                             if (!grepl(pattern, name)) 
[17:03:38.735]                               next
[17:03:38.735]                             invokeRestart(restart)
[17:03:38.735]                             muffled <- TRUE
[17:03:38.735]                             break
[17:03:38.735]                           }
[17:03:38.735]                         }
[17:03:38.735]                       }
[17:03:38.735]                       invisible(muffled)
[17:03:38.735]                     }
[17:03:38.735]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.735]                   }
[17:03:38.735]                 }
[17:03:38.735]                 else {
[17:03:38.735]                   if (TRUE) {
[17:03:38.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.735]                     {
[17:03:38.735]                       inherits <- base::inherits
[17:03:38.735]                       invokeRestart <- base::invokeRestart
[17:03:38.735]                       is.null <- base::is.null
[17:03:38.735]                       muffled <- FALSE
[17:03:38.735]                       if (inherits(cond, "message")) {
[17:03:38.735]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.735]                         if (muffled) 
[17:03:38.735]                           invokeRestart("muffleMessage")
[17:03:38.735]                       }
[17:03:38.735]                       else if (inherits(cond, "warning")) {
[17:03:38.735]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.735]                         if (muffled) 
[17:03:38.735]                           invokeRestart("muffleWarning")
[17:03:38.735]                       }
[17:03:38.735]                       else if (inherits(cond, "condition")) {
[17:03:38.735]                         if (!is.null(pattern)) {
[17:03:38.735]                           computeRestarts <- base::computeRestarts
[17:03:38.735]                           grepl <- base::grepl
[17:03:38.735]                           restarts <- computeRestarts(cond)
[17:03:38.735]                           for (restart in restarts) {
[17:03:38.735]                             name <- restart$name
[17:03:38.735]                             if (is.null(name)) 
[17:03:38.735]                               next
[17:03:38.735]                             if (!grepl(pattern, name)) 
[17:03:38.735]                               next
[17:03:38.735]                             invokeRestart(restart)
[17:03:38.735]                             muffled <- TRUE
[17:03:38.735]                             break
[17:03:38.735]                           }
[17:03:38.735]                         }
[17:03:38.735]                       }
[17:03:38.735]                       invisible(muffled)
[17:03:38.735]                     }
[17:03:38.735]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.735]                   }
[17:03:38.735]                 }
[17:03:38.735]             }
[17:03:38.735]         }))
[17:03:38.735]     }, error = function(ex) {
[17:03:38.735]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.735]                 ...future.rng), started = ...future.startTime, 
[17:03:38.735]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.735]             version = "1.8"), class = "FutureResult")
[17:03:38.735]     }, finally = {
[17:03:38.735]         if (!identical(...future.workdir, getwd())) 
[17:03:38.735]             setwd(...future.workdir)
[17:03:38.735]         {
[17:03:38.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.735]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.735]             }
[17:03:38.735]             base::options(...future.oldOptions)
[17:03:38.735]             if (.Platform$OS.type == "windows") {
[17:03:38.735]                 old_names <- names(...future.oldEnvVars)
[17:03:38.735]                 envs <- base::Sys.getenv()
[17:03:38.735]                 names <- names(envs)
[17:03:38.735]                 common <- intersect(names, old_names)
[17:03:38.735]                 added <- setdiff(names, old_names)
[17:03:38.735]                 removed <- setdiff(old_names, names)
[17:03:38.735]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.735]                   envs[common]]
[17:03:38.735]                 NAMES <- toupper(changed)
[17:03:38.735]                 args <- list()
[17:03:38.735]                 for (kk in seq_along(NAMES)) {
[17:03:38.735]                   name <- changed[[kk]]
[17:03:38.735]                   NAME <- NAMES[[kk]]
[17:03:38.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.735]                     next
[17:03:38.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.735]                 }
[17:03:38.735]                 NAMES <- toupper(added)
[17:03:38.735]                 for (kk in seq_along(NAMES)) {
[17:03:38.735]                   name <- added[[kk]]
[17:03:38.735]                   NAME <- NAMES[[kk]]
[17:03:38.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.735]                     next
[17:03:38.735]                   args[[name]] <- ""
[17:03:38.735]                 }
[17:03:38.735]                 NAMES <- toupper(removed)
[17:03:38.735]                 for (kk in seq_along(NAMES)) {
[17:03:38.735]                   name <- removed[[kk]]
[17:03:38.735]                   NAME <- NAMES[[kk]]
[17:03:38.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.735]                     next
[17:03:38.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.735]                 }
[17:03:38.735]                 if (length(args) > 0) 
[17:03:38.735]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.735]             }
[17:03:38.735]             else {
[17:03:38.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.735]             }
[17:03:38.735]             {
[17:03:38.735]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.735]                   0L) {
[17:03:38.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.735]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.735]                   base::options(opts)
[17:03:38.735]                 }
[17:03:38.735]                 {
[17:03:38.735]                   {
[17:03:38.735]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.735]                     NULL
[17:03:38.735]                   }
[17:03:38.735]                   options(future.plan = NULL)
[17:03:38.735]                   if (is.na(NA_character_)) 
[17:03:38.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.735]                     .init = FALSE)
[17:03:38.735]                 }
[17:03:38.735]             }
[17:03:38.735]         }
[17:03:38.735]     })
[17:03:38.735]     if (TRUE) {
[17:03:38.735]         base::sink(type = "output", split = FALSE)
[17:03:38.735]         if (TRUE) {
[17:03:38.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.735]         }
[17:03:38.735]         else {
[17:03:38.735]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.735]         }
[17:03:38.735]         base::close(...future.stdout)
[17:03:38.735]         ...future.stdout <- NULL
[17:03:38.735]     }
[17:03:38.735]     ...future.result$conditions <- ...future.conditions
[17:03:38.735]     ...future.result$finished <- base::Sys.time()
[17:03:38.735]     ...future.result
[17:03:38.735] }
[17:03:38.738] requestCore(): workers = 2
[17:03:38.739] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:38.749] result() for MulticoreFuture ...
[17:03:38.750] result() for MulticoreFuture ...
[17:03:38.750] result() for MulticoreFuture ... done
[17:03:38.751] result() for MulticoreFuture ... done
[17:03:38.751] result() for MulticoreFuture ...
[17:03:38.751] result() for MulticoreFuture ... done
[17:03:38.754] MulticoreFuture started
[17:03:38.755] - Launch lazy future ... done
[17:03:38.755] run() for ‘MulticoreFuture’ ... done
[17:03:38.755] plan(): Setting new future strategy stack:
[17:03:38.756] List of future strategies:
[17:03:38.756] 1. sequential:
[17:03:38.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.756]    - tweaked: FALSE
[17:03:38.756]    - call: NULL
[17:03:38.757] plan(): nbrOfWorkers() = 1
[17:03:38.759] plan(): Setting new future strategy stack:
[17:03:38.759] List of future strategies:
[17:03:38.759] 1. multicore:
[17:03:38.759]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.759]    - tweaked: FALSE
[17:03:38.759]    - call: plan(strategy)
[17:03:38.764] plan(): nbrOfWorkers() = 2
[17:03:38.765] Future #1
[17:03:38.765]  length: 2 (resolved future 1)
[17:03:38.765] run() for ‘Future’ ...
[17:03:38.766] - state: ‘created’
[17:03:38.766] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.770] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.771] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.771]   - Field: ‘label’
[17:03:38.771]   - Field: ‘local’
[17:03:38.771]   - Field: ‘owner’
[17:03:38.771]   - Field: ‘envir’
[17:03:38.771]   - Field: ‘workers’
[17:03:38.772]   - Field: ‘packages’
[17:03:38.772]   - Field: ‘gc’
[17:03:38.772]   - Field: ‘job’
[17:03:38.772]   - Field: ‘conditions’
[17:03:38.772]   - Field: ‘expr’
[17:03:38.772]   - Field: ‘uuid’
[17:03:38.772]   - Field: ‘seed’
[17:03:38.773]   - Field: ‘version’
[17:03:38.773]   - Field: ‘result’
[17:03:38.773]   - Field: ‘asynchronous’
[17:03:38.773]   - Field: ‘calls’
[17:03:38.773]   - Field: ‘globals’
[17:03:38.773]   - Field: ‘stdout’
[17:03:38.773]   - Field: ‘earlySignal’
[17:03:38.774]   - Field: ‘lazy’
[17:03:38.774]   - Field: ‘state’
[17:03:38.774] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.774] - Launch lazy future ...
[17:03:38.775] Packages needed by the future expression (n = 0): <none>
[17:03:38.775] Packages needed by future strategies (n = 0): <none>
[17:03:38.775] {
[17:03:38.775]     {
[17:03:38.775]         {
[17:03:38.775]             ...future.startTime <- base::Sys.time()
[17:03:38.775]             {
[17:03:38.775]                 {
[17:03:38.775]                   {
[17:03:38.775]                     {
[17:03:38.775]                       base::local({
[17:03:38.775]                         has_future <- base::requireNamespace("future", 
[17:03:38.775]                           quietly = TRUE)
[17:03:38.775]                         if (has_future) {
[17:03:38.775]                           ns <- base::getNamespace("future")
[17:03:38.775]                           version <- ns[[".package"]][["version"]]
[17:03:38.775]                           if (is.null(version)) 
[17:03:38.775]                             version <- utils::packageVersion("future")
[17:03:38.775]                         }
[17:03:38.775]                         else {
[17:03:38.775]                           version <- NULL
[17:03:38.775]                         }
[17:03:38.775]                         if (!has_future || version < "1.8.0") {
[17:03:38.775]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.775]                             "", base::R.version$version.string), 
[17:03:38.775]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.775]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.775]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.775]                               "release", "version")], collapse = " "), 
[17:03:38.775]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.775]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.775]                             info)
[17:03:38.775]                           info <- base::paste(info, collapse = "; ")
[17:03:38.775]                           if (!has_future) {
[17:03:38.775]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.775]                               info)
[17:03:38.775]                           }
[17:03:38.775]                           else {
[17:03:38.775]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.775]                               info, version)
[17:03:38.775]                           }
[17:03:38.775]                           base::stop(msg)
[17:03:38.775]                         }
[17:03:38.775]                       })
[17:03:38.775]                     }
[17:03:38.775]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.775]                     base::options(mc.cores = 1L)
[17:03:38.775]                   }
[17:03:38.775]                   ...future.strategy.old <- future::plan("list")
[17:03:38.775]                   options(future.plan = NULL)
[17:03:38.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.775]                 }
[17:03:38.775]                 ...future.workdir <- getwd()
[17:03:38.775]             }
[17:03:38.775]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.775]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.775]         }
[17:03:38.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.775]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.775]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.775]             base::names(...future.oldOptions))
[17:03:38.775]     }
[17:03:38.775]     if (FALSE) {
[17:03:38.775]     }
[17:03:38.775]     else {
[17:03:38.775]         if (TRUE) {
[17:03:38.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.775]                 open = "w")
[17:03:38.775]         }
[17:03:38.775]         else {
[17:03:38.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.775]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.775]         }
[17:03:38.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.775]             base::sink(type = "output", split = FALSE)
[17:03:38.775]             base::close(...future.stdout)
[17:03:38.775]         }, add = TRUE)
[17:03:38.775]     }
[17:03:38.775]     ...future.frame <- base::sys.nframe()
[17:03:38.775]     ...future.conditions <- base::list()
[17:03:38.775]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.775]     if (FALSE) {
[17:03:38.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.775]     }
[17:03:38.775]     ...future.result <- base::tryCatch({
[17:03:38.775]         base::withCallingHandlers({
[17:03:38.775]             ...future.value <- base::withVisible(base::local({
[17:03:38.775]                 withCallingHandlers({
[17:03:38.775]                   2
[17:03:38.775]                 }, immediateCondition = function(cond) {
[17:03:38.775]                   save_rds <- function (object, pathname, ...) 
[17:03:38.775]                   {
[17:03:38.775]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.775]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.775]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.775]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.775]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.775]                         fi_tmp[["mtime"]])
[17:03:38.775]                     }
[17:03:38.775]                     tryCatch({
[17:03:38.775]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.775]                     }, error = function(ex) {
[17:03:38.775]                       msg <- conditionMessage(ex)
[17:03:38.775]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.775]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.775]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.775]                         fi_tmp[["mtime"]], msg)
[17:03:38.775]                       ex$message <- msg
[17:03:38.775]                       stop(ex)
[17:03:38.775]                     })
[17:03:38.775]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.775]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.775]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.775]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.775]                       fi <- file.info(pathname)
[17:03:38.775]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.775]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.775]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.775]                         fi[["size"]], fi[["mtime"]])
[17:03:38.775]                       stop(msg)
[17:03:38.775]                     }
[17:03:38.775]                     invisible(pathname)
[17:03:38.775]                   }
[17:03:38.775]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.775]                     rootPath = tempdir()) 
[17:03:38.775]                   {
[17:03:38.775]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.775]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.775]                       tmpdir = path, fileext = ".rds")
[17:03:38.775]                     save_rds(obj, file)
[17:03:38.775]                   }
[17:03:38.775]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.775]                   {
[17:03:38.775]                     inherits <- base::inherits
[17:03:38.775]                     invokeRestart <- base::invokeRestart
[17:03:38.775]                     is.null <- base::is.null
[17:03:38.775]                     muffled <- FALSE
[17:03:38.775]                     if (inherits(cond, "message")) {
[17:03:38.775]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.775]                       if (muffled) 
[17:03:38.775]                         invokeRestart("muffleMessage")
[17:03:38.775]                     }
[17:03:38.775]                     else if (inherits(cond, "warning")) {
[17:03:38.775]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.775]                       if (muffled) 
[17:03:38.775]                         invokeRestart("muffleWarning")
[17:03:38.775]                     }
[17:03:38.775]                     else if (inherits(cond, "condition")) {
[17:03:38.775]                       if (!is.null(pattern)) {
[17:03:38.775]                         computeRestarts <- base::computeRestarts
[17:03:38.775]                         grepl <- base::grepl
[17:03:38.775]                         restarts <- computeRestarts(cond)
[17:03:38.775]                         for (restart in restarts) {
[17:03:38.775]                           name <- restart$name
[17:03:38.775]                           if (is.null(name)) 
[17:03:38.775]                             next
[17:03:38.775]                           if (!grepl(pattern, name)) 
[17:03:38.775]                             next
[17:03:38.775]                           invokeRestart(restart)
[17:03:38.775]                           muffled <- TRUE
[17:03:38.775]                           break
[17:03:38.775]                         }
[17:03:38.775]                       }
[17:03:38.775]                     }
[17:03:38.775]                     invisible(muffled)
[17:03:38.775]                   }
[17:03:38.775]                   muffleCondition(cond)
[17:03:38.775]                 })
[17:03:38.775]             }))
[17:03:38.775]             future::FutureResult(value = ...future.value$value, 
[17:03:38.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.775]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.775]                     ...future.globalenv.names))
[17:03:38.775]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.775]         }, condition = base::local({
[17:03:38.775]             c <- base::c
[17:03:38.775]             inherits <- base::inherits
[17:03:38.775]             invokeRestart <- base::invokeRestart
[17:03:38.775]             length <- base::length
[17:03:38.775]             list <- base::list
[17:03:38.775]             seq.int <- base::seq.int
[17:03:38.775]             signalCondition <- base::signalCondition
[17:03:38.775]             sys.calls <- base::sys.calls
[17:03:38.775]             `[[` <- base::`[[`
[17:03:38.775]             `+` <- base::`+`
[17:03:38.775]             `<<-` <- base::`<<-`
[17:03:38.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.775]                   3L)]
[17:03:38.775]             }
[17:03:38.775]             function(cond) {
[17:03:38.775]                 is_error <- inherits(cond, "error")
[17:03:38.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.775]                   NULL)
[17:03:38.775]                 if (is_error) {
[17:03:38.775]                   sessionInformation <- function() {
[17:03:38.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.775]                       search = base::search(), system = base::Sys.info())
[17:03:38.775]                   }
[17:03:38.775]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.775]                     cond$call), session = sessionInformation(), 
[17:03:38.775]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.775]                   signalCondition(cond)
[17:03:38.775]                 }
[17:03:38.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.775]                 "immediateCondition"))) {
[17:03:38.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.775]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.775]                   if (TRUE && !signal) {
[17:03:38.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.775]                     {
[17:03:38.775]                       inherits <- base::inherits
[17:03:38.775]                       invokeRestart <- base::invokeRestart
[17:03:38.775]                       is.null <- base::is.null
[17:03:38.775]                       muffled <- FALSE
[17:03:38.775]                       if (inherits(cond, "message")) {
[17:03:38.775]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.775]                         if (muffled) 
[17:03:38.775]                           invokeRestart("muffleMessage")
[17:03:38.775]                       }
[17:03:38.775]                       else if (inherits(cond, "warning")) {
[17:03:38.775]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.775]                         if (muffled) 
[17:03:38.775]                           invokeRestart("muffleWarning")
[17:03:38.775]                       }
[17:03:38.775]                       else if (inherits(cond, "condition")) {
[17:03:38.775]                         if (!is.null(pattern)) {
[17:03:38.775]                           computeRestarts <- base::computeRestarts
[17:03:38.775]                           grepl <- base::grepl
[17:03:38.775]                           restarts <- computeRestarts(cond)
[17:03:38.775]                           for (restart in restarts) {
[17:03:38.775]                             name <- restart$name
[17:03:38.775]                             if (is.null(name)) 
[17:03:38.775]                               next
[17:03:38.775]                             if (!grepl(pattern, name)) 
[17:03:38.775]                               next
[17:03:38.775]                             invokeRestart(restart)
[17:03:38.775]                             muffled <- TRUE
[17:03:38.775]                             break
[17:03:38.775]                           }
[17:03:38.775]                         }
[17:03:38.775]                       }
[17:03:38.775]                       invisible(muffled)
[17:03:38.775]                     }
[17:03:38.775]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.775]                   }
[17:03:38.775]                 }
[17:03:38.775]                 else {
[17:03:38.775]                   if (TRUE) {
[17:03:38.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.775]                     {
[17:03:38.775]                       inherits <- base::inherits
[17:03:38.775]                       invokeRestart <- base::invokeRestart
[17:03:38.775]                       is.null <- base::is.null
[17:03:38.775]                       muffled <- FALSE
[17:03:38.775]                       if (inherits(cond, "message")) {
[17:03:38.775]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.775]                         if (muffled) 
[17:03:38.775]                           invokeRestart("muffleMessage")
[17:03:38.775]                       }
[17:03:38.775]                       else if (inherits(cond, "warning")) {
[17:03:38.775]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.775]                         if (muffled) 
[17:03:38.775]                           invokeRestart("muffleWarning")
[17:03:38.775]                       }
[17:03:38.775]                       else if (inherits(cond, "condition")) {
[17:03:38.775]                         if (!is.null(pattern)) {
[17:03:38.775]                           computeRestarts <- base::computeRestarts
[17:03:38.775]                           grepl <- base::grepl
[17:03:38.775]                           restarts <- computeRestarts(cond)
[17:03:38.775]                           for (restart in restarts) {
[17:03:38.775]                             name <- restart$name
[17:03:38.775]                             if (is.null(name)) 
[17:03:38.775]                               next
[17:03:38.775]                             if (!grepl(pattern, name)) 
[17:03:38.775]                               next
[17:03:38.775]                             invokeRestart(restart)
[17:03:38.775]                             muffled <- TRUE
[17:03:38.775]                             break
[17:03:38.775]                           }
[17:03:38.775]                         }
[17:03:38.775]                       }
[17:03:38.775]                       invisible(muffled)
[17:03:38.775]                     }
[17:03:38.775]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.775]                   }
[17:03:38.775]                 }
[17:03:38.775]             }
[17:03:38.775]         }))
[17:03:38.775]     }, error = function(ex) {
[17:03:38.775]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.775]                 ...future.rng), started = ...future.startTime, 
[17:03:38.775]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.775]             version = "1.8"), class = "FutureResult")
[17:03:38.775]     }, finally = {
[17:03:38.775]         if (!identical(...future.workdir, getwd())) 
[17:03:38.775]             setwd(...future.workdir)
[17:03:38.775]         {
[17:03:38.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.775]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.775]             }
[17:03:38.775]             base::options(...future.oldOptions)
[17:03:38.775]             if (.Platform$OS.type == "windows") {
[17:03:38.775]                 old_names <- names(...future.oldEnvVars)
[17:03:38.775]                 envs <- base::Sys.getenv()
[17:03:38.775]                 names <- names(envs)
[17:03:38.775]                 common <- intersect(names, old_names)
[17:03:38.775]                 added <- setdiff(names, old_names)
[17:03:38.775]                 removed <- setdiff(old_names, names)
[17:03:38.775]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.775]                   envs[common]]
[17:03:38.775]                 NAMES <- toupper(changed)
[17:03:38.775]                 args <- list()
[17:03:38.775]                 for (kk in seq_along(NAMES)) {
[17:03:38.775]                   name <- changed[[kk]]
[17:03:38.775]                   NAME <- NAMES[[kk]]
[17:03:38.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.775]                     next
[17:03:38.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.775]                 }
[17:03:38.775]                 NAMES <- toupper(added)
[17:03:38.775]                 for (kk in seq_along(NAMES)) {
[17:03:38.775]                   name <- added[[kk]]
[17:03:38.775]                   NAME <- NAMES[[kk]]
[17:03:38.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.775]                     next
[17:03:38.775]                   args[[name]] <- ""
[17:03:38.775]                 }
[17:03:38.775]                 NAMES <- toupper(removed)
[17:03:38.775]                 for (kk in seq_along(NAMES)) {
[17:03:38.775]                   name <- removed[[kk]]
[17:03:38.775]                   NAME <- NAMES[[kk]]
[17:03:38.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.775]                     next
[17:03:38.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.775]                 }
[17:03:38.775]                 if (length(args) > 0) 
[17:03:38.775]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.775]             }
[17:03:38.775]             else {
[17:03:38.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.775]             }
[17:03:38.775]             {
[17:03:38.775]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.775]                   0L) {
[17:03:38.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.775]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.775]                   base::options(opts)
[17:03:38.775]                 }
[17:03:38.775]                 {
[17:03:38.775]                   {
[17:03:38.775]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.775]                     NULL
[17:03:38.775]                   }
[17:03:38.775]                   options(future.plan = NULL)
[17:03:38.775]                   if (is.na(NA_character_)) 
[17:03:38.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.775]                     .init = FALSE)
[17:03:38.775]                 }
[17:03:38.775]             }
[17:03:38.775]         }
[17:03:38.775]     })
[17:03:38.775]     if (TRUE) {
[17:03:38.775]         base::sink(type = "output", split = FALSE)
[17:03:38.775]         if (TRUE) {
[17:03:38.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.775]         }
[17:03:38.775]         else {
[17:03:38.775]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.775]         }
[17:03:38.775]         base::close(...future.stdout)
[17:03:38.775]         ...future.stdout <- NULL
[17:03:38.775]     }
[17:03:38.775]     ...future.result$conditions <- ...future.conditions
[17:03:38.775]     ...future.result$finished <- base::Sys.time()
[17:03:38.775]     ...future.result
[17:03:38.775] }
[17:03:38.779] requestCore(): workers = 2
[17:03:38.779] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:38.790] result() for MulticoreFuture ...
[17:03:38.791] result() for MulticoreFuture ...
[17:03:38.791] result() for MulticoreFuture ... done
[17:03:38.791] result() for MulticoreFuture ... done
[17:03:38.792] result() for MulticoreFuture ...
[17:03:38.792] result() for MulticoreFuture ... done
[17:03:38.795] MulticoreFuture started
[17:03:38.795] - Launch lazy future ... done
[17:03:38.795] run() for ‘MulticoreFuture’ ... done
[17:03:38.796] plan(): Setting new future strategy stack:
[17:03:38.796] List of future strategies:
[17:03:38.796] 1. sequential:
[17:03:38.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.796]    - tweaked: FALSE
[17:03:38.796]    - call: NULL
[17:03:38.797] plan(): nbrOfWorkers() = 1
[17:03:38.799] plan(): Setting new future strategy stack:
[17:03:38.799] List of future strategies:
[17:03:38.799] 1. multicore:
[17:03:38.799]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.799]    - tweaked: FALSE
[17:03:38.799]    - call: plan(strategy)
[17:03:38.804] plan(): nbrOfWorkers() = 2
[17:03:38.805] Future #2
[17:03:38.805]  length: 1 (resolved future 2)
[17:03:38.805]  length: 0 (resolved future 3)
[17:03:38.806] resolve() on list ... DONE
[17:03:38.806] getGlobalsAndPackages() ...
[17:03:38.806] Searching for globals...
[17:03:38.807] 
[17:03:38.807] Searching for globals ... DONE
[17:03:38.807] - globals: [0] <none>
[17:03:38.808] getGlobalsAndPackages() ... DONE
[17:03:38.808] run() for ‘Future’ ...
[17:03:38.808] - state: ‘created’
[17:03:38.808] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.813] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.813] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.813]   - Field: ‘label’
[17:03:38.813]   - Field: ‘local’
[17:03:38.814]   - Field: ‘owner’
[17:03:38.814]   - Field: ‘envir’
[17:03:38.814]   - Field: ‘workers’
[17:03:38.814]   - Field: ‘packages’
[17:03:38.814]   - Field: ‘gc’
[17:03:38.814]   - Field: ‘job’
[17:03:38.814]   - Field: ‘conditions’
[17:03:38.815]   - Field: ‘expr’
[17:03:38.815]   - Field: ‘uuid’
[17:03:38.815]   - Field: ‘seed’
[17:03:38.815]   - Field: ‘version’
[17:03:38.815]   - Field: ‘result’
[17:03:38.815]   - Field: ‘asynchronous’
[17:03:38.815]   - Field: ‘calls’
[17:03:38.816]   - Field: ‘globals’
[17:03:38.816]   - Field: ‘stdout’
[17:03:38.816]   - Field: ‘earlySignal’
[17:03:38.816]   - Field: ‘lazy’
[17:03:38.816]   - Field: ‘state’
[17:03:38.816] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.817] - Launch lazy future ...
[17:03:38.817] Packages needed by the future expression (n = 0): <none>
[17:03:38.817] Packages needed by future strategies (n = 0): <none>
[17:03:38.823] {
[17:03:38.823]     {
[17:03:38.823]         {
[17:03:38.823]             ...future.startTime <- base::Sys.time()
[17:03:38.823]             {
[17:03:38.823]                 {
[17:03:38.823]                   {
[17:03:38.823]                     {
[17:03:38.823]                       base::local({
[17:03:38.823]                         has_future <- base::requireNamespace("future", 
[17:03:38.823]                           quietly = TRUE)
[17:03:38.823]                         if (has_future) {
[17:03:38.823]                           ns <- base::getNamespace("future")
[17:03:38.823]                           version <- ns[[".package"]][["version"]]
[17:03:38.823]                           if (is.null(version)) 
[17:03:38.823]                             version <- utils::packageVersion("future")
[17:03:38.823]                         }
[17:03:38.823]                         else {
[17:03:38.823]                           version <- NULL
[17:03:38.823]                         }
[17:03:38.823]                         if (!has_future || version < "1.8.0") {
[17:03:38.823]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.823]                             "", base::R.version$version.string), 
[17:03:38.823]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.823]                               "release", "version")], collapse = " "), 
[17:03:38.823]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.823]                             info)
[17:03:38.823]                           info <- base::paste(info, collapse = "; ")
[17:03:38.823]                           if (!has_future) {
[17:03:38.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.823]                               info)
[17:03:38.823]                           }
[17:03:38.823]                           else {
[17:03:38.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.823]                               info, version)
[17:03:38.823]                           }
[17:03:38.823]                           base::stop(msg)
[17:03:38.823]                         }
[17:03:38.823]                       })
[17:03:38.823]                     }
[17:03:38.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.823]                     base::options(mc.cores = 1L)
[17:03:38.823]                   }
[17:03:38.823]                   ...future.strategy.old <- future::plan("list")
[17:03:38.823]                   options(future.plan = NULL)
[17:03:38.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.823]                 }
[17:03:38.823]                 ...future.workdir <- getwd()
[17:03:38.823]             }
[17:03:38.823]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.823]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.823]         }
[17:03:38.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.823]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.823]             base::names(...future.oldOptions))
[17:03:38.823]     }
[17:03:38.823]     if (FALSE) {
[17:03:38.823]     }
[17:03:38.823]     else {
[17:03:38.823]         if (TRUE) {
[17:03:38.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.823]                 open = "w")
[17:03:38.823]         }
[17:03:38.823]         else {
[17:03:38.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.823]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.823]         }
[17:03:38.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.823]             base::sink(type = "output", split = FALSE)
[17:03:38.823]             base::close(...future.stdout)
[17:03:38.823]         }, add = TRUE)
[17:03:38.823]     }
[17:03:38.823]     ...future.frame <- base::sys.nframe()
[17:03:38.823]     ...future.conditions <- base::list()
[17:03:38.823]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.823]     if (FALSE) {
[17:03:38.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.823]     }
[17:03:38.823]     ...future.result <- base::tryCatch({
[17:03:38.823]         base::withCallingHandlers({
[17:03:38.823]             ...future.value <- base::withVisible(base::local({
[17:03:38.823]                 withCallingHandlers({
[17:03:38.823]                   1
[17:03:38.823]                 }, immediateCondition = function(cond) {
[17:03:38.823]                   save_rds <- function (object, pathname, ...) 
[17:03:38.823]                   {
[17:03:38.823]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.823]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.823]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.823]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.823]                         fi_tmp[["mtime"]])
[17:03:38.823]                     }
[17:03:38.823]                     tryCatch({
[17:03:38.823]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.823]                     }, error = function(ex) {
[17:03:38.823]                       msg <- conditionMessage(ex)
[17:03:38.823]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.823]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.823]                         fi_tmp[["mtime"]], msg)
[17:03:38.823]                       ex$message <- msg
[17:03:38.823]                       stop(ex)
[17:03:38.823]                     })
[17:03:38.823]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.823]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.823]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.823]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.823]                       fi <- file.info(pathname)
[17:03:38.823]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.823]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.823]                         fi[["size"]], fi[["mtime"]])
[17:03:38.823]                       stop(msg)
[17:03:38.823]                     }
[17:03:38.823]                     invisible(pathname)
[17:03:38.823]                   }
[17:03:38.823]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.823]                     rootPath = tempdir()) 
[17:03:38.823]                   {
[17:03:38.823]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.823]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.823]                       tmpdir = path, fileext = ".rds")
[17:03:38.823]                     save_rds(obj, file)
[17:03:38.823]                   }
[17:03:38.823]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.823]                   {
[17:03:38.823]                     inherits <- base::inherits
[17:03:38.823]                     invokeRestart <- base::invokeRestart
[17:03:38.823]                     is.null <- base::is.null
[17:03:38.823]                     muffled <- FALSE
[17:03:38.823]                     if (inherits(cond, "message")) {
[17:03:38.823]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.823]                       if (muffled) 
[17:03:38.823]                         invokeRestart("muffleMessage")
[17:03:38.823]                     }
[17:03:38.823]                     else if (inherits(cond, "warning")) {
[17:03:38.823]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.823]                       if (muffled) 
[17:03:38.823]                         invokeRestart("muffleWarning")
[17:03:38.823]                     }
[17:03:38.823]                     else if (inherits(cond, "condition")) {
[17:03:38.823]                       if (!is.null(pattern)) {
[17:03:38.823]                         computeRestarts <- base::computeRestarts
[17:03:38.823]                         grepl <- base::grepl
[17:03:38.823]                         restarts <- computeRestarts(cond)
[17:03:38.823]                         for (restart in restarts) {
[17:03:38.823]                           name <- restart$name
[17:03:38.823]                           if (is.null(name)) 
[17:03:38.823]                             next
[17:03:38.823]                           if (!grepl(pattern, name)) 
[17:03:38.823]                             next
[17:03:38.823]                           invokeRestart(restart)
[17:03:38.823]                           muffled <- TRUE
[17:03:38.823]                           break
[17:03:38.823]                         }
[17:03:38.823]                       }
[17:03:38.823]                     }
[17:03:38.823]                     invisible(muffled)
[17:03:38.823]                   }
[17:03:38.823]                   muffleCondition(cond)
[17:03:38.823]                 })
[17:03:38.823]             }))
[17:03:38.823]             future::FutureResult(value = ...future.value$value, 
[17:03:38.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.823]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.823]                     ...future.globalenv.names))
[17:03:38.823]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.823]         }, condition = base::local({
[17:03:38.823]             c <- base::c
[17:03:38.823]             inherits <- base::inherits
[17:03:38.823]             invokeRestart <- base::invokeRestart
[17:03:38.823]             length <- base::length
[17:03:38.823]             list <- base::list
[17:03:38.823]             seq.int <- base::seq.int
[17:03:38.823]             signalCondition <- base::signalCondition
[17:03:38.823]             sys.calls <- base::sys.calls
[17:03:38.823]             `[[` <- base::`[[`
[17:03:38.823]             `+` <- base::`+`
[17:03:38.823]             `<<-` <- base::`<<-`
[17:03:38.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.823]                   3L)]
[17:03:38.823]             }
[17:03:38.823]             function(cond) {
[17:03:38.823]                 is_error <- inherits(cond, "error")
[17:03:38.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.823]                   NULL)
[17:03:38.823]                 if (is_error) {
[17:03:38.823]                   sessionInformation <- function() {
[17:03:38.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.823]                       search = base::search(), system = base::Sys.info())
[17:03:38.823]                   }
[17:03:38.823]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.823]                     cond$call), session = sessionInformation(), 
[17:03:38.823]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.823]                   signalCondition(cond)
[17:03:38.823]                 }
[17:03:38.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.823]                 "immediateCondition"))) {
[17:03:38.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.823]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.823]                   if (TRUE && !signal) {
[17:03:38.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.823]                     {
[17:03:38.823]                       inherits <- base::inherits
[17:03:38.823]                       invokeRestart <- base::invokeRestart
[17:03:38.823]                       is.null <- base::is.null
[17:03:38.823]                       muffled <- FALSE
[17:03:38.823]                       if (inherits(cond, "message")) {
[17:03:38.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.823]                         if (muffled) 
[17:03:38.823]                           invokeRestart("muffleMessage")
[17:03:38.823]                       }
[17:03:38.823]                       else if (inherits(cond, "warning")) {
[17:03:38.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.823]                         if (muffled) 
[17:03:38.823]                           invokeRestart("muffleWarning")
[17:03:38.823]                       }
[17:03:38.823]                       else if (inherits(cond, "condition")) {
[17:03:38.823]                         if (!is.null(pattern)) {
[17:03:38.823]                           computeRestarts <- base::computeRestarts
[17:03:38.823]                           grepl <- base::grepl
[17:03:38.823]                           restarts <- computeRestarts(cond)
[17:03:38.823]                           for (restart in restarts) {
[17:03:38.823]                             name <- restart$name
[17:03:38.823]                             if (is.null(name)) 
[17:03:38.823]                               next
[17:03:38.823]                             if (!grepl(pattern, name)) 
[17:03:38.823]                               next
[17:03:38.823]                             invokeRestart(restart)
[17:03:38.823]                             muffled <- TRUE
[17:03:38.823]                             break
[17:03:38.823]                           }
[17:03:38.823]                         }
[17:03:38.823]                       }
[17:03:38.823]                       invisible(muffled)
[17:03:38.823]                     }
[17:03:38.823]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.823]                   }
[17:03:38.823]                 }
[17:03:38.823]                 else {
[17:03:38.823]                   if (TRUE) {
[17:03:38.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.823]                     {
[17:03:38.823]                       inherits <- base::inherits
[17:03:38.823]                       invokeRestart <- base::invokeRestart
[17:03:38.823]                       is.null <- base::is.null
[17:03:38.823]                       muffled <- FALSE
[17:03:38.823]                       if (inherits(cond, "message")) {
[17:03:38.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.823]                         if (muffled) 
[17:03:38.823]                           invokeRestart("muffleMessage")
[17:03:38.823]                       }
[17:03:38.823]                       else if (inherits(cond, "warning")) {
[17:03:38.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.823]                         if (muffled) 
[17:03:38.823]                           invokeRestart("muffleWarning")
[17:03:38.823]                       }
[17:03:38.823]                       else if (inherits(cond, "condition")) {
[17:03:38.823]                         if (!is.null(pattern)) {
[17:03:38.823]                           computeRestarts <- base::computeRestarts
[17:03:38.823]                           grepl <- base::grepl
[17:03:38.823]                           restarts <- computeRestarts(cond)
[17:03:38.823]                           for (restart in restarts) {
[17:03:38.823]                             name <- restart$name
[17:03:38.823]                             if (is.null(name)) 
[17:03:38.823]                               next
[17:03:38.823]                             if (!grepl(pattern, name)) 
[17:03:38.823]                               next
[17:03:38.823]                             invokeRestart(restart)
[17:03:38.823]                             muffled <- TRUE
[17:03:38.823]                             break
[17:03:38.823]                           }
[17:03:38.823]                         }
[17:03:38.823]                       }
[17:03:38.823]                       invisible(muffled)
[17:03:38.823]                     }
[17:03:38.823]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.823]                   }
[17:03:38.823]                 }
[17:03:38.823]             }
[17:03:38.823]         }))
[17:03:38.823]     }, error = function(ex) {
[17:03:38.823]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.823]                 ...future.rng), started = ...future.startTime, 
[17:03:38.823]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.823]             version = "1.8"), class = "FutureResult")
[17:03:38.823]     }, finally = {
[17:03:38.823]         if (!identical(...future.workdir, getwd())) 
[17:03:38.823]             setwd(...future.workdir)
[17:03:38.823]         {
[17:03:38.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.823]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.823]             }
[17:03:38.823]             base::options(...future.oldOptions)
[17:03:38.823]             if (.Platform$OS.type == "windows") {
[17:03:38.823]                 old_names <- names(...future.oldEnvVars)
[17:03:38.823]                 envs <- base::Sys.getenv()
[17:03:38.823]                 names <- names(envs)
[17:03:38.823]                 common <- intersect(names, old_names)
[17:03:38.823]                 added <- setdiff(names, old_names)
[17:03:38.823]                 removed <- setdiff(old_names, names)
[17:03:38.823]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.823]                   envs[common]]
[17:03:38.823]                 NAMES <- toupper(changed)
[17:03:38.823]                 args <- list()
[17:03:38.823]                 for (kk in seq_along(NAMES)) {
[17:03:38.823]                   name <- changed[[kk]]
[17:03:38.823]                   NAME <- NAMES[[kk]]
[17:03:38.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.823]                     next
[17:03:38.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.823]                 }
[17:03:38.823]                 NAMES <- toupper(added)
[17:03:38.823]                 for (kk in seq_along(NAMES)) {
[17:03:38.823]                   name <- added[[kk]]
[17:03:38.823]                   NAME <- NAMES[[kk]]
[17:03:38.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.823]                     next
[17:03:38.823]                   args[[name]] <- ""
[17:03:38.823]                 }
[17:03:38.823]                 NAMES <- toupper(removed)
[17:03:38.823]                 for (kk in seq_along(NAMES)) {
[17:03:38.823]                   name <- removed[[kk]]
[17:03:38.823]                   NAME <- NAMES[[kk]]
[17:03:38.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.823]                     next
[17:03:38.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.823]                 }
[17:03:38.823]                 if (length(args) > 0) 
[17:03:38.823]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.823]             }
[17:03:38.823]             else {
[17:03:38.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.823]             }
[17:03:38.823]             {
[17:03:38.823]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.823]                   0L) {
[17:03:38.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.823]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.823]                   base::options(opts)
[17:03:38.823]                 }
[17:03:38.823]                 {
[17:03:38.823]                   {
[17:03:38.823]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.823]                     NULL
[17:03:38.823]                   }
[17:03:38.823]                   options(future.plan = NULL)
[17:03:38.823]                   if (is.na(NA_character_)) 
[17:03:38.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.823]                     .init = FALSE)
[17:03:38.823]                 }
[17:03:38.823]             }
[17:03:38.823]         }
[17:03:38.823]     })
[17:03:38.823]     if (TRUE) {
[17:03:38.823]         base::sink(type = "output", split = FALSE)
[17:03:38.823]         if (TRUE) {
[17:03:38.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.823]         }
[17:03:38.823]         else {
[17:03:38.823]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.823]         }
[17:03:38.823]         base::close(...future.stdout)
[17:03:38.823]         ...future.stdout <- NULL
[17:03:38.823]     }
[17:03:38.823]     ...future.result$conditions <- ...future.conditions
[17:03:38.823]     ...future.result$finished <- base::Sys.time()
[17:03:38.823]     ...future.result
[17:03:38.823] }
[17:03:38.826] requestCore(): workers = 2
[17:03:38.827] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:38.837] result() for MulticoreFuture ...
[17:03:38.839] result() for MulticoreFuture ...
[17:03:38.839] result() for MulticoreFuture ... done
[17:03:38.839] result() for MulticoreFuture ... done
[17:03:38.840] result() for MulticoreFuture ...
[17:03:38.840] result() for MulticoreFuture ... done
[17:03:38.842] MulticoreFuture started
[17:03:38.842] - Launch lazy future ... done
[17:03:38.843] run() for ‘MulticoreFuture’ ... done
[17:03:38.843] plan(): Setting new future strategy stack:
[17:03:38.843] getGlobalsAndPackages() ...
[17:03:38.844] Searching for globals...
[17:03:38.843] List of future strategies:
[17:03:38.843] 1. sequential:
[17:03:38.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.843]    - tweaked: FALSE
[17:03:38.843]    - call: NULL
[17:03:38.845] plan(): nbrOfWorkers() = 1
[17:03:38.847] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:03:38.847] Searching for globals ... DONE
[17:03:38.847] Resolving globals: FALSE
[17:03:38.847] plan(): Setting new future strategy stack:
[17:03:38.848] 
[17:03:38.848] 
[17:03:38.847] List of future strategies:
[17:03:38.847] 1. multicore:
[17:03:38.847]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:38.847]    - tweaked: FALSE
[17:03:38.847]    - call: plan(strategy)
[17:03:38.848] getGlobalsAndPackages() ... DONE
[17:03:38.849] run() for ‘Future’ ...
[17:03:38.849] - state: ‘created’
[17:03:38.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:38.853] plan(): nbrOfWorkers() = 2
[17:03:38.854] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:38.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:38.854]   - Field: ‘label’
[17:03:38.854]   - Field: ‘local’
[17:03:38.854]   - Field: ‘owner’
[17:03:38.855]   - Field: ‘envir’
[17:03:38.855]   - Field: ‘workers’
[17:03:38.855]   - Field: ‘packages’
[17:03:38.855]   - Field: ‘gc’
[17:03:38.855]   - Field: ‘job’
[17:03:38.855]   - Field: ‘conditions’
[17:03:38.856]   - Field: ‘expr’
[17:03:38.856]   - Field: ‘uuid’
[17:03:38.856]   - Field: ‘seed’
[17:03:38.856]   - Field: ‘version’
[17:03:38.856]   - Field: ‘result’
[17:03:38.856]   - Field: ‘asynchronous’
[17:03:38.856]   - Field: ‘calls’
[17:03:38.857]   - Field: ‘globals’
[17:03:38.857]   - Field: ‘stdout’
[17:03:38.857]   - Field: ‘earlySignal’
[17:03:38.857]   - Field: ‘lazy’
[17:03:38.857]   - Field: ‘state’
[17:03:38.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:38.857] - Launch lazy future ...
[17:03:38.858] Packages needed by the future expression (n = 0): <none>
[17:03:38.858] Packages needed by future strategies (n = 0): <none>
[17:03:38.859] {
[17:03:38.859]     {
[17:03:38.859]         {
[17:03:38.859]             ...future.startTime <- base::Sys.time()
[17:03:38.859]             {
[17:03:38.859]                 {
[17:03:38.859]                   {
[17:03:38.859]                     {
[17:03:38.859]                       base::local({
[17:03:38.859]                         has_future <- base::requireNamespace("future", 
[17:03:38.859]                           quietly = TRUE)
[17:03:38.859]                         if (has_future) {
[17:03:38.859]                           ns <- base::getNamespace("future")
[17:03:38.859]                           version <- ns[[".package"]][["version"]]
[17:03:38.859]                           if (is.null(version)) 
[17:03:38.859]                             version <- utils::packageVersion("future")
[17:03:38.859]                         }
[17:03:38.859]                         else {
[17:03:38.859]                           version <- NULL
[17:03:38.859]                         }
[17:03:38.859]                         if (!has_future || version < "1.8.0") {
[17:03:38.859]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:38.859]                             "", base::R.version$version.string), 
[17:03:38.859]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:38.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:38.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:38.859]                               "release", "version")], collapse = " "), 
[17:03:38.859]                             hostname = base::Sys.info()[["nodename"]])
[17:03:38.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:38.859]                             info)
[17:03:38.859]                           info <- base::paste(info, collapse = "; ")
[17:03:38.859]                           if (!has_future) {
[17:03:38.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:38.859]                               info)
[17:03:38.859]                           }
[17:03:38.859]                           else {
[17:03:38.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:38.859]                               info, version)
[17:03:38.859]                           }
[17:03:38.859]                           base::stop(msg)
[17:03:38.859]                         }
[17:03:38.859]                       })
[17:03:38.859]                     }
[17:03:38.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:38.859]                     base::options(mc.cores = 1L)
[17:03:38.859]                   }
[17:03:38.859]                   ...future.strategy.old <- future::plan("list")
[17:03:38.859]                   options(future.plan = NULL)
[17:03:38.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:38.859]                 }
[17:03:38.859]                 ...future.workdir <- getwd()
[17:03:38.859]             }
[17:03:38.859]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:38.859]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:38.859]         }
[17:03:38.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:38.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:38.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:38.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:38.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:38.859]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:38.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:38.859]             base::names(...future.oldOptions))
[17:03:38.859]     }
[17:03:38.859]     if (FALSE) {
[17:03:38.859]     }
[17:03:38.859]     else {
[17:03:38.859]         if (TRUE) {
[17:03:38.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:38.859]                 open = "w")
[17:03:38.859]         }
[17:03:38.859]         else {
[17:03:38.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:38.859]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:38.859]         }
[17:03:38.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:38.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:38.859]             base::sink(type = "output", split = FALSE)
[17:03:38.859]             base::close(...future.stdout)
[17:03:38.859]         }, add = TRUE)
[17:03:38.859]     }
[17:03:38.859]     ...future.frame <- base::sys.nframe()
[17:03:38.859]     ...future.conditions <- base::list()
[17:03:38.859]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:38.859]     if (FALSE) {
[17:03:38.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:38.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:38.859]     }
[17:03:38.859]     ...future.result <- base::tryCatch({
[17:03:38.859]         base::withCallingHandlers({
[17:03:38.859]             ...future.value <- base::withVisible(base::local({
[17:03:38.859]                 withCallingHandlers({
[17:03:38.859]                   {
[17:03:38.859]                     Sys.sleep(0.5)
[17:03:38.859]                     2
[17:03:38.859]                   }
[17:03:38.859]                 }, immediateCondition = function(cond) {
[17:03:38.859]                   save_rds <- function (object, pathname, ...) 
[17:03:38.859]                   {
[17:03:38.859]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:38.859]                     if (file_test("-f", pathname_tmp)) {
[17:03:38.859]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.859]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:38.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.859]                         fi_tmp[["mtime"]])
[17:03:38.859]                     }
[17:03:38.859]                     tryCatch({
[17:03:38.859]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:38.859]                     }, error = function(ex) {
[17:03:38.859]                       msg <- conditionMessage(ex)
[17:03:38.859]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.859]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:38.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.859]                         fi_tmp[["mtime"]], msg)
[17:03:38.859]                       ex$message <- msg
[17:03:38.859]                       stop(ex)
[17:03:38.859]                     })
[17:03:38.859]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:38.859]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:38.859]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:38.859]                       fi_tmp <- file.info(pathname_tmp)
[17:03:38.859]                       fi <- file.info(pathname)
[17:03:38.859]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:38.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:38.859]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:38.859]                         fi[["size"]], fi[["mtime"]])
[17:03:38.859]                       stop(msg)
[17:03:38.859]                     }
[17:03:38.859]                     invisible(pathname)
[17:03:38.859]                   }
[17:03:38.859]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:38.859]                     rootPath = tempdir()) 
[17:03:38.859]                   {
[17:03:38.859]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:38.859]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:38.859]                       tmpdir = path, fileext = ".rds")
[17:03:38.859]                     save_rds(obj, file)
[17:03:38.859]                   }
[17:03:38.859]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:38.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.859]                   {
[17:03:38.859]                     inherits <- base::inherits
[17:03:38.859]                     invokeRestart <- base::invokeRestart
[17:03:38.859]                     is.null <- base::is.null
[17:03:38.859]                     muffled <- FALSE
[17:03:38.859]                     if (inherits(cond, "message")) {
[17:03:38.859]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:38.859]                       if (muffled) 
[17:03:38.859]                         invokeRestart("muffleMessage")
[17:03:38.859]                     }
[17:03:38.859]                     else if (inherits(cond, "warning")) {
[17:03:38.859]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:38.859]                       if (muffled) 
[17:03:38.859]                         invokeRestart("muffleWarning")
[17:03:38.859]                     }
[17:03:38.859]                     else if (inherits(cond, "condition")) {
[17:03:38.859]                       if (!is.null(pattern)) {
[17:03:38.859]                         computeRestarts <- base::computeRestarts
[17:03:38.859]                         grepl <- base::grepl
[17:03:38.859]                         restarts <- computeRestarts(cond)
[17:03:38.859]                         for (restart in restarts) {
[17:03:38.859]                           name <- restart$name
[17:03:38.859]                           if (is.null(name)) 
[17:03:38.859]                             next
[17:03:38.859]                           if (!grepl(pattern, name)) 
[17:03:38.859]                             next
[17:03:38.859]                           invokeRestart(restart)
[17:03:38.859]                           muffled <- TRUE
[17:03:38.859]                           break
[17:03:38.859]                         }
[17:03:38.859]                       }
[17:03:38.859]                     }
[17:03:38.859]                     invisible(muffled)
[17:03:38.859]                   }
[17:03:38.859]                   muffleCondition(cond)
[17:03:38.859]                 })
[17:03:38.859]             }))
[17:03:38.859]             future::FutureResult(value = ...future.value$value, 
[17:03:38.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.859]                   ...future.rng), globalenv = if (FALSE) 
[17:03:38.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:38.859]                     ...future.globalenv.names))
[17:03:38.859]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:38.859]         }, condition = base::local({
[17:03:38.859]             c <- base::c
[17:03:38.859]             inherits <- base::inherits
[17:03:38.859]             invokeRestart <- base::invokeRestart
[17:03:38.859]             length <- base::length
[17:03:38.859]             list <- base::list
[17:03:38.859]             seq.int <- base::seq.int
[17:03:38.859]             signalCondition <- base::signalCondition
[17:03:38.859]             sys.calls <- base::sys.calls
[17:03:38.859]             `[[` <- base::`[[`
[17:03:38.859]             `+` <- base::`+`
[17:03:38.859]             `<<-` <- base::`<<-`
[17:03:38.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:38.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:38.859]                   3L)]
[17:03:38.859]             }
[17:03:38.859]             function(cond) {
[17:03:38.859]                 is_error <- inherits(cond, "error")
[17:03:38.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:38.859]                   NULL)
[17:03:38.859]                 if (is_error) {
[17:03:38.859]                   sessionInformation <- function() {
[17:03:38.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:38.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:38.859]                       search = base::search(), system = base::Sys.info())
[17:03:38.859]                   }
[17:03:38.859]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:38.859]                     cond$call), session = sessionInformation(), 
[17:03:38.859]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:38.859]                   signalCondition(cond)
[17:03:38.859]                 }
[17:03:38.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:38.859]                 "immediateCondition"))) {
[17:03:38.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:38.859]                   ...future.conditions[[length(...future.conditions) + 
[17:03:38.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:38.859]                   if (TRUE && !signal) {
[17:03:38.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.859]                     {
[17:03:38.859]                       inherits <- base::inherits
[17:03:38.859]                       invokeRestart <- base::invokeRestart
[17:03:38.859]                       is.null <- base::is.null
[17:03:38.859]                       muffled <- FALSE
[17:03:38.859]                       if (inherits(cond, "message")) {
[17:03:38.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.859]                         if (muffled) 
[17:03:38.859]                           invokeRestart("muffleMessage")
[17:03:38.859]                       }
[17:03:38.859]                       else if (inherits(cond, "warning")) {
[17:03:38.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.859]                         if (muffled) 
[17:03:38.859]                           invokeRestart("muffleWarning")
[17:03:38.859]                       }
[17:03:38.859]                       else if (inherits(cond, "condition")) {
[17:03:38.859]                         if (!is.null(pattern)) {
[17:03:38.859]                           computeRestarts <- base::computeRestarts
[17:03:38.859]                           grepl <- base::grepl
[17:03:38.859]                           restarts <- computeRestarts(cond)
[17:03:38.859]                           for (restart in restarts) {
[17:03:38.859]                             name <- restart$name
[17:03:38.859]                             if (is.null(name)) 
[17:03:38.859]                               next
[17:03:38.859]                             if (!grepl(pattern, name)) 
[17:03:38.859]                               next
[17:03:38.859]                             invokeRestart(restart)
[17:03:38.859]                             muffled <- TRUE
[17:03:38.859]                             break
[17:03:38.859]                           }
[17:03:38.859]                         }
[17:03:38.859]                       }
[17:03:38.859]                       invisible(muffled)
[17:03:38.859]                     }
[17:03:38.859]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.859]                   }
[17:03:38.859]                 }
[17:03:38.859]                 else {
[17:03:38.859]                   if (TRUE) {
[17:03:38.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:38.859]                     {
[17:03:38.859]                       inherits <- base::inherits
[17:03:38.859]                       invokeRestart <- base::invokeRestart
[17:03:38.859]                       is.null <- base::is.null
[17:03:38.859]                       muffled <- FALSE
[17:03:38.859]                       if (inherits(cond, "message")) {
[17:03:38.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:38.859]                         if (muffled) 
[17:03:38.859]                           invokeRestart("muffleMessage")
[17:03:38.859]                       }
[17:03:38.859]                       else if (inherits(cond, "warning")) {
[17:03:38.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:38.859]                         if (muffled) 
[17:03:38.859]                           invokeRestart("muffleWarning")
[17:03:38.859]                       }
[17:03:38.859]                       else if (inherits(cond, "condition")) {
[17:03:38.859]                         if (!is.null(pattern)) {
[17:03:38.859]                           computeRestarts <- base::computeRestarts
[17:03:38.859]                           grepl <- base::grepl
[17:03:38.859]                           restarts <- computeRestarts(cond)
[17:03:38.859]                           for (restart in restarts) {
[17:03:38.859]                             name <- restart$name
[17:03:38.859]                             if (is.null(name)) 
[17:03:38.859]                               next
[17:03:38.859]                             if (!grepl(pattern, name)) 
[17:03:38.859]                               next
[17:03:38.859]                             invokeRestart(restart)
[17:03:38.859]                             muffled <- TRUE
[17:03:38.859]                             break
[17:03:38.859]                           }
[17:03:38.859]                         }
[17:03:38.859]                       }
[17:03:38.859]                       invisible(muffled)
[17:03:38.859]                     }
[17:03:38.859]                     muffleCondition(cond, pattern = "^muffle")
[17:03:38.859]                   }
[17:03:38.859]                 }
[17:03:38.859]             }
[17:03:38.859]         }))
[17:03:38.859]     }, error = function(ex) {
[17:03:38.859]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:38.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:38.859]                 ...future.rng), started = ...future.startTime, 
[17:03:38.859]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:38.859]             version = "1.8"), class = "FutureResult")
[17:03:38.859]     }, finally = {
[17:03:38.859]         if (!identical(...future.workdir, getwd())) 
[17:03:38.859]             setwd(...future.workdir)
[17:03:38.859]         {
[17:03:38.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:38.859]                 ...future.oldOptions$nwarnings <- NULL
[17:03:38.859]             }
[17:03:38.859]             base::options(...future.oldOptions)
[17:03:38.859]             if (.Platform$OS.type == "windows") {
[17:03:38.859]                 old_names <- names(...future.oldEnvVars)
[17:03:38.859]                 envs <- base::Sys.getenv()
[17:03:38.859]                 names <- names(envs)
[17:03:38.859]                 common <- intersect(names, old_names)
[17:03:38.859]                 added <- setdiff(names, old_names)
[17:03:38.859]                 removed <- setdiff(old_names, names)
[17:03:38.859]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:38.859]                   envs[common]]
[17:03:38.859]                 NAMES <- toupper(changed)
[17:03:38.859]                 args <- list()
[17:03:38.859]                 for (kk in seq_along(NAMES)) {
[17:03:38.859]                   name <- changed[[kk]]
[17:03:38.859]                   NAME <- NAMES[[kk]]
[17:03:38.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.859]                     next
[17:03:38.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.859]                 }
[17:03:38.859]                 NAMES <- toupper(added)
[17:03:38.859]                 for (kk in seq_along(NAMES)) {
[17:03:38.859]                   name <- added[[kk]]
[17:03:38.859]                   NAME <- NAMES[[kk]]
[17:03:38.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.859]                     next
[17:03:38.859]                   args[[name]] <- ""
[17:03:38.859]                 }
[17:03:38.859]                 NAMES <- toupper(removed)
[17:03:38.859]                 for (kk in seq_along(NAMES)) {
[17:03:38.859]                   name <- removed[[kk]]
[17:03:38.859]                   NAME <- NAMES[[kk]]
[17:03:38.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:38.859]                     next
[17:03:38.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:38.859]                 }
[17:03:38.859]                 if (length(args) > 0) 
[17:03:38.859]                   base::do.call(base::Sys.setenv, args = args)
[17:03:38.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:38.859]             }
[17:03:38.859]             else {
[17:03:38.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:38.859]             }
[17:03:38.859]             {
[17:03:38.859]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:38.859]                   0L) {
[17:03:38.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:38.859]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:38.859]                   base::options(opts)
[17:03:38.859]                 }
[17:03:38.859]                 {
[17:03:38.859]                   {
[17:03:38.859]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:38.859]                     NULL
[17:03:38.859]                   }
[17:03:38.859]                   options(future.plan = NULL)
[17:03:38.859]                   if (is.na(NA_character_)) 
[17:03:38.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:38.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:38.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:38.859]                     .init = FALSE)
[17:03:38.859]                 }
[17:03:38.859]             }
[17:03:38.859]         }
[17:03:38.859]     })
[17:03:38.859]     if (TRUE) {
[17:03:38.859]         base::sink(type = "output", split = FALSE)
[17:03:38.859]         if (TRUE) {
[17:03:38.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:38.859]         }
[17:03:38.859]         else {
[17:03:38.859]             ...future.result["stdout"] <- base::list(NULL)
[17:03:38.859]         }
[17:03:38.859]         base::close(...future.stdout)
[17:03:38.859]         ...future.stdout <- NULL
[17:03:38.859]     }
[17:03:38.859]     ...future.result$conditions <- ...future.conditions
[17:03:38.859]     ...future.result$finished <- base::Sys.time()
[17:03:38.859]     ...future.result
[17:03:38.859] }
[17:03:38.862] requestCore(): workers = 2
[17:03:38.863] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:38.873] result() for MulticoreFuture ...
[17:03:38.874] result() for MulticoreFuture ...
[17:03:38.874] result() for MulticoreFuture ... done
[17:03:38.875] result() for MulticoreFuture ... done
[17:03:38.875] result() for MulticoreFuture ...
[17:03:38.875] result() for MulticoreFuture ... done
[17:03:38.878] MulticoreFuture started
[17:03:38.879] - Launch lazy future ... done
[17:03:38.879] run() for ‘MulticoreFuture’ ... done
[17:03:38.879] plan(): Setting new future strategy stack:
[17:03:38.880] resolve() on list ...
[17:03:38.880]  recursive: 0
[17:03:38.880]  length: 1
[17:03:38.880] 
[17:03:38.880] List of future strategies:
[17:03:38.880] 1. sequential:
[17:03:38.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:38.880]    - tweaked: FALSE
[17:03:38.880]    - call: NULL
[17:03:38.881] Future #1
[17:03:38.881] plan(): nbrOfWorkers() = 1
[17:03:38.881]  length: 0 (resolved future 1)
[17:03:38.881] resolve() on list ... DONE
[17:03:38.882] resolve() on list ...
[17:03:38.882]  recursive: 0
[17:03:38.882]  length: 1
[17:03:38.882] 
[17:03:39.384] plan(): Setting new future strategy stack:
[17:03:39.384] List of future strategies:
[17:03:39.384] 1. multicore:
[17:03:39.384]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:39.384]    - tweaked: FALSE
[17:03:39.384]    - call: plan(strategy)
[17:03:39.389] plan(): nbrOfWorkers() = 2
[17:03:39.393] Future #1
[17:03:39.393]  length: 0 (resolved future 1)
[17:03:39.394] resolve() on list ... DONE
[17:03:39.394] resolve() on list ...
[17:03:39.394]  recursive: 0
[17:03:39.394]  length: 1
[17:03:39.395] 
[17:03:39.395]  length: 0 (resolved future 1)
[17:03:39.395] resolve() on list ... DONE
[17:03:39.395] resolve() on list ...
[17:03:39.395]  recursive: 0
[17:03:39.395]  length: 4
[17:03:39.396] 
[17:03:39.396] Future #1
[17:03:39.396]  length: 3 (resolved future 1)
[17:03:39.396] Future #2
[17:03:39.397]  length: 2 (resolved future 2)
[17:03:39.397]  length: 1 (resolved future 3)
[17:03:39.397]  length: 0 (resolved future 4)
[17:03:39.397] resolve() on list ... DONE
[17:03:39.397] resolve() on list ...
[17:03:39.397]  recursive: 0
[17:03:39.398]  length: 4
[17:03:39.398] 
[17:03:39.398] Future #1
[17:03:39.398]  length: 3 (resolved future 1)
[17:03:39.398] Future #2
[17:03:39.399]  length: 2 (resolved future 2)
[17:03:39.399]  length: 1 (resolved future 3)
[17:03:39.399]  length: 0 (resolved future 4)
[17:03:39.399] resolve() on list ... DONE
[17:03:39.399] resolve() on list ...
[17:03:39.400]  recursive: 0
[17:03:39.400]  length: 1
[17:03:39.400] 
[17:03:39.400]  length: 0 (resolved future 1)
[17:03:39.400] resolve() on list ... DONE
[17:03:39.400] getGlobalsAndPackages() ...
[17:03:39.400] Searching for globals...
[17:03:39.402] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:39.403] Searching for globals ... DONE
[17:03:39.403] Resolving globals: FALSE
[17:03:39.403] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:39.404] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:39.404] - globals: [1] ‘kk’
[17:03:39.404] 
[17:03:39.404] getGlobalsAndPackages() ... DONE
[17:03:39.405] run() for ‘Future’ ...
[17:03:39.405] - state: ‘created’
[17:03:39.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:39.410] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:39.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:39.410]   - Field: ‘label’
[17:03:39.410]   - Field: ‘local’
[17:03:39.410]   - Field: ‘owner’
[17:03:39.410]   - Field: ‘envir’
[17:03:39.411]   - Field: ‘workers’
[17:03:39.411]   - Field: ‘packages’
[17:03:39.411]   - Field: ‘gc’
[17:03:39.411]   - Field: ‘job’
[17:03:39.411]   - Field: ‘conditions’
[17:03:39.411]   - Field: ‘expr’
[17:03:39.411]   - Field: ‘uuid’
[17:03:39.412]   - Field: ‘seed’
[17:03:39.412]   - Field: ‘version’
[17:03:39.412]   - Field: ‘result’
[17:03:39.412]   - Field: ‘asynchronous’
[17:03:39.415]   - Field: ‘calls’
[17:03:39.416]   - Field: ‘globals’
[17:03:39.416]   - Field: ‘stdout’
[17:03:39.416]   - Field: ‘earlySignal’
[17:03:39.416]   - Field: ‘lazy’
[17:03:39.417]   - Field: ‘state’
[17:03:39.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:39.417] - Launch lazy future ...
[17:03:39.418] Packages needed by the future expression (n = 0): <none>
[17:03:39.418] Packages needed by future strategies (n = 0): <none>
[17:03:39.419] {
[17:03:39.419]     {
[17:03:39.419]         {
[17:03:39.419]             ...future.startTime <- base::Sys.time()
[17:03:39.419]             {
[17:03:39.419]                 {
[17:03:39.419]                   {
[17:03:39.419]                     {
[17:03:39.419]                       base::local({
[17:03:39.419]                         has_future <- base::requireNamespace("future", 
[17:03:39.419]                           quietly = TRUE)
[17:03:39.419]                         if (has_future) {
[17:03:39.419]                           ns <- base::getNamespace("future")
[17:03:39.419]                           version <- ns[[".package"]][["version"]]
[17:03:39.419]                           if (is.null(version)) 
[17:03:39.419]                             version <- utils::packageVersion("future")
[17:03:39.419]                         }
[17:03:39.419]                         else {
[17:03:39.419]                           version <- NULL
[17:03:39.419]                         }
[17:03:39.419]                         if (!has_future || version < "1.8.0") {
[17:03:39.419]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:39.419]                             "", base::R.version$version.string), 
[17:03:39.419]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:39.419]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:39.419]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:39.419]                               "release", "version")], collapse = " "), 
[17:03:39.419]                             hostname = base::Sys.info()[["nodename"]])
[17:03:39.419]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:39.419]                             info)
[17:03:39.419]                           info <- base::paste(info, collapse = "; ")
[17:03:39.419]                           if (!has_future) {
[17:03:39.419]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:39.419]                               info)
[17:03:39.419]                           }
[17:03:39.419]                           else {
[17:03:39.419]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:39.419]                               info, version)
[17:03:39.419]                           }
[17:03:39.419]                           base::stop(msg)
[17:03:39.419]                         }
[17:03:39.419]                       })
[17:03:39.419]                     }
[17:03:39.419]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:39.419]                     base::options(mc.cores = 1L)
[17:03:39.419]                   }
[17:03:39.419]                   ...future.strategy.old <- future::plan("list")
[17:03:39.419]                   options(future.plan = NULL)
[17:03:39.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:39.419]                 }
[17:03:39.419]                 ...future.workdir <- getwd()
[17:03:39.419]             }
[17:03:39.419]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:39.419]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:39.419]         }
[17:03:39.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:39.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:39.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:39.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:39.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:39.419]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:39.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:39.419]             base::names(...future.oldOptions))
[17:03:39.419]     }
[17:03:39.419]     if (FALSE) {
[17:03:39.419]     }
[17:03:39.419]     else {
[17:03:39.419]         if (TRUE) {
[17:03:39.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:39.419]                 open = "w")
[17:03:39.419]         }
[17:03:39.419]         else {
[17:03:39.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:39.419]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:39.419]         }
[17:03:39.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:39.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:39.419]             base::sink(type = "output", split = FALSE)
[17:03:39.419]             base::close(...future.stdout)
[17:03:39.419]         }, add = TRUE)
[17:03:39.419]     }
[17:03:39.419]     ...future.frame <- base::sys.nframe()
[17:03:39.419]     ...future.conditions <- base::list()
[17:03:39.419]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:39.419]     if (FALSE) {
[17:03:39.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:39.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:39.419]     }
[17:03:39.419]     ...future.result <- base::tryCatch({
[17:03:39.419]         base::withCallingHandlers({
[17:03:39.419]             ...future.value <- base::withVisible(base::local({
[17:03:39.419]                 withCallingHandlers({
[17:03:39.419]                   {
[17:03:39.419]                     Sys.sleep(0.1)
[17:03:39.419]                     kk
[17:03:39.419]                   }
[17:03:39.419]                 }, immediateCondition = function(cond) {
[17:03:39.419]                   save_rds <- function (object, pathname, ...) 
[17:03:39.419]                   {
[17:03:39.419]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:39.419]                     if (file_test("-f", pathname_tmp)) {
[17:03:39.419]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.419]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:39.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.419]                         fi_tmp[["mtime"]])
[17:03:39.419]                     }
[17:03:39.419]                     tryCatch({
[17:03:39.419]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:39.419]                     }, error = function(ex) {
[17:03:39.419]                       msg <- conditionMessage(ex)
[17:03:39.419]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.419]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:39.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.419]                         fi_tmp[["mtime"]], msg)
[17:03:39.419]                       ex$message <- msg
[17:03:39.419]                       stop(ex)
[17:03:39.419]                     })
[17:03:39.419]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:39.419]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:39.419]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:39.419]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.419]                       fi <- file.info(pathname)
[17:03:39.419]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:39.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.419]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:39.419]                         fi[["size"]], fi[["mtime"]])
[17:03:39.419]                       stop(msg)
[17:03:39.419]                     }
[17:03:39.419]                     invisible(pathname)
[17:03:39.419]                   }
[17:03:39.419]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:39.419]                     rootPath = tempdir()) 
[17:03:39.419]                   {
[17:03:39.419]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:39.419]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:39.419]                       tmpdir = path, fileext = ".rds")
[17:03:39.419]                     save_rds(obj, file)
[17:03:39.419]                   }
[17:03:39.419]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:39.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.419]                   {
[17:03:39.419]                     inherits <- base::inherits
[17:03:39.419]                     invokeRestart <- base::invokeRestart
[17:03:39.419]                     is.null <- base::is.null
[17:03:39.419]                     muffled <- FALSE
[17:03:39.419]                     if (inherits(cond, "message")) {
[17:03:39.419]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:39.419]                       if (muffled) 
[17:03:39.419]                         invokeRestart("muffleMessage")
[17:03:39.419]                     }
[17:03:39.419]                     else if (inherits(cond, "warning")) {
[17:03:39.419]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:39.419]                       if (muffled) 
[17:03:39.419]                         invokeRestart("muffleWarning")
[17:03:39.419]                     }
[17:03:39.419]                     else if (inherits(cond, "condition")) {
[17:03:39.419]                       if (!is.null(pattern)) {
[17:03:39.419]                         computeRestarts <- base::computeRestarts
[17:03:39.419]                         grepl <- base::grepl
[17:03:39.419]                         restarts <- computeRestarts(cond)
[17:03:39.419]                         for (restart in restarts) {
[17:03:39.419]                           name <- restart$name
[17:03:39.419]                           if (is.null(name)) 
[17:03:39.419]                             next
[17:03:39.419]                           if (!grepl(pattern, name)) 
[17:03:39.419]                             next
[17:03:39.419]                           invokeRestart(restart)
[17:03:39.419]                           muffled <- TRUE
[17:03:39.419]                           break
[17:03:39.419]                         }
[17:03:39.419]                       }
[17:03:39.419]                     }
[17:03:39.419]                     invisible(muffled)
[17:03:39.419]                   }
[17:03:39.419]                   muffleCondition(cond)
[17:03:39.419]                 })
[17:03:39.419]             }))
[17:03:39.419]             future::FutureResult(value = ...future.value$value, 
[17:03:39.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.419]                   ...future.rng), globalenv = if (FALSE) 
[17:03:39.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:39.419]                     ...future.globalenv.names))
[17:03:39.419]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:39.419]         }, condition = base::local({
[17:03:39.419]             c <- base::c
[17:03:39.419]             inherits <- base::inherits
[17:03:39.419]             invokeRestart <- base::invokeRestart
[17:03:39.419]             length <- base::length
[17:03:39.419]             list <- base::list
[17:03:39.419]             seq.int <- base::seq.int
[17:03:39.419]             signalCondition <- base::signalCondition
[17:03:39.419]             sys.calls <- base::sys.calls
[17:03:39.419]             `[[` <- base::`[[`
[17:03:39.419]             `+` <- base::`+`
[17:03:39.419]             `<<-` <- base::`<<-`
[17:03:39.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:39.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:39.419]                   3L)]
[17:03:39.419]             }
[17:03:39.419]             function(cond) {
[17:03:39.419]                 is_error <- inherits(cond, "error")
[17:03:39.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:39.419]                   NULL)
[17:03:39.419]                 if (is_error) {
[17:03:39.419]                   sessionInformation <- function() {
[17:03:39.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:39.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:39.419]                       search = base::search(), system = base::Sys.info())
[17:03:39.419]                   }
[17:03:39.419]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:39.419]                     cond$call), session = sessionInformation(), 
[17:03:39.419]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:39.419]                   signalCondition(cond)
[17:03:39.419]                 }
[17:03:39.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:39.419]                 "immediateCondition"))) {
[17:03:39.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:39.419]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:39.419]                   if (TRUE && !signal) {
[17:03:39.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.419]                     {
[17:03:39.419]                       inherits <- base::inherits
[17:03:39.419]                       invokeRestart <- base::invokeRestart
[17:03:39.419]                       is.null <- base::is.null
[17:03:39.419]                       muffled <- FALSE
[17:03:39.419]                       if (inherits(cond, "message")) {
[17:03:39.419]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.419]                         if (muffled) 
[17:03:39.419]                           invokeRestart("muffleMessage")
[17:03:39.419]                       }
[17:03:39.419]                       else if (inherits(cond, "warning")) {
[17:03:39.419]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.419]                         if (muffled) 
[17:03:39.419]                           invokeRestart("muffleWarning")
[17:03:39.419]                       }
[17:03:39.419]                       else if (inherits(cond, "condition")) {
[17:03:39.419]                         if (!is.null(pattern)) {
[17:03:39.419]                           computeRestarts <- base::computeRestarts
[17:03:39.419]                           grepl <- base::grepl
[17:03:39.419]                           restarts <- computeRestarts(cond)
[17:03:39.419]                           for (restart in restarts) {
[17:03:39.419]                             name <- restart$name
[17:03:39.419]                             if (is.null(name)) 
[17:03:39.419]                               next
[17:03:39.419]                             if (!grepl(pattern, name)) 
[17:03:39.419]                               next
[17:03:39.419]                             invokeRestart(restart)
[17:03:39.419]                             muffled <- TRUE
[17:03:39.419]                             break
[17:03:39.419]                           }
[17:03:39.419]                         }
[17:03:39.419]                       }
[17:03:39.419]                       invisible(muffled)
[17:03:39.419]                     }
[17:03:39.419]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.419]                   }
[17:03:39.419]                 }
[17:03:39.419]                 else {
[17:03:39.419]                   if (TRUE) {
[17:03:39.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.419]                     {
[17:03:39.419]                       inherits <- base::inherits
[17:03:39.419]                       invokeRestart <- base::invokeRestart
[17:03:39.419]                       is.null <- base::is.null
[17:03:39.419]                       muffled <- FALSE
[17:03:39.419]                       if (inherits(cond, "message")) {
[17:03:39.419]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.419]                         if (muffled) 
[17:03:39.419]                           invokeRestart("muffleMessage")
[17:03:39.419]                       }
[17:03:39.419]                       else if (inherits(cond, "warning")) {
[17:03:39.419]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.419]                         if (muffled) 
[17:03:39.419]                           invokeRestart("muffleWarning")
[17:03:39.419]                       }
[17:03:39.419]                       else if (inherits(cond, "condition")) {
[17:03:39.419]                         if (!is.null(pattern)) {
[17:03:39.419]                           computeRestarts <- base::computeRestarts
[17:03:39.419]                           grepl <- base::grepl
[17:03:39.419]                           restarts <- computeRestarts(cond)
[17:03:39.419]                           for (restart in restarts) {
[17:03:39.419]                             name <- restart$name
[17:03:39.419]                             if (is.null(name)) 
[17:03:39.419]                               next
[17:03:39.419]                             if (!grepl(pattern, name)) 
[17:03:39.419]                               next
[17:03:39.419]                             invokeRestart(restart)
[17:03:39.419]                             muffled <- TRUE
[17:03:39.419]                             break
[17:03:39.419]                           }
[17:03:39.419]                         }
[17:03:39.419]                       }
[17:03:39.419]                       invisible(muffled)
[17:03:39.419]                     }
[17:03:39.419]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.419]                   }
[17:03:39.419]                 }
[17:03:39.419]             }
[17:03:39.419]         }))
[17:03:39.419]     }, error = function(ex) {
[17:03:39.419]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:39.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.419]                 ...future.rng), started = ...future.startTime, 
[17:03:39.419]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:39.419]             version = "1.8"), class = "FutureResult")
[17:03:39.419]     }, finally = {
[17:03:39.419]         if (!identical(...future.workdir, getwd())) 
[17:03:39.419]             setwd(...future.workdir)
[17:03:39.419]         {
[17:03:39.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:39.419]                 ...future.oldOptions$nwarnings <- NULL
[17:03:39.419]             }
[17:03:39.419]             base::options(...future.oldOptions)
[17:03:39.419]             if (.Platform$OS.type == "windows") {
[17:03:39.419]                 old_names <- names(...future.oldEnvVars)
[17:03:39.419]                 envs <- base::Sys.getenv()
[17:03:39.419]                 names <- names(envs)
[17:03:39.419]                 common <- intersect(names, old_names)
[17:03:39.419]                 added <- setdiff(names, old_names)
[17:03:39.419]                 removed <- setdiff(old_names, names)
[17:03:39.419]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:39.419]                   envs[common]]
[17:03:39.419]                 NAMES <- toupper(changed)
[17:03:39.419]                 args <- list()
[17:03:39.419]                 for (kk in seq_along(NAMES)) {
[17:03:39.419]                   name <- changed[[kk]]
[17:03:39.419]                   NAME <- NAMES[[kk]]
[17:03:39.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.419]                     next
[17:03:39.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.419]                 }
[17:03:39.419]                 NAMES <- toupper(added)
[17:03:39.419]                 for (kk in seq_along(NAMES)) {
[17:03:39.419]                   name <- added[[kk]]
[17:03:39.419]                   NAME <- NAMES[[kk]]
[17:03:39.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.419]                     next
[17:03:39.419]                   args[[name]] <- ""
[17:03:39.419]                 }
[17:03:39.419]                 NAMES <- toupper(removed)
[17:03:39.419]                 for (kk in seq_along(NAMES)) {
[17:03:39.419]                   name <- removed[[kk]]
[17:03:39.419]                   NAME <- NAMES[[kk]]
[17:03:39.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.419]                     next
[17:03:39.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.419]                 }
[17:03:39.419]                 if (length(args) > 0) 
[17:03:39.419]                   base::do.call(base::Sys.setenv, args = args)
[17:03:39.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:39.419]             }
[17:03:39.419]             else {
[17:03:39.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:39.419]             }
[17:03:39.419]             {
[17:03:39.419]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:39.419]                   0L) {
[17:03:39.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:39.419]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:39.419]                   base::options(opts)
[17:03:39.419]                 }
[17:03:39.419]                 {
[17:03:39.419]                   {
[17:03:39.419]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:39.419]                     NULL
[17:03:39.419]                   }
[17:03:39.419]                   options(future.plan = NULL)
[17:03:39.419]                   if (is.na(NA_character_)) 
[17:03:39.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:39.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:39.419]                     .init = FALSE)
[17:03:39.419]                 }
[17:03:39.419]             }
[17:03:39.419]         }
[17:03:39.419]     })
[17:03:39.419]     if (TRUE) {
[17:03:39.419]         base::sink(type = "output", split = FALSE)
[17:03:39.419]         if (TRUE) {
[17:03:39.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:39.419]         }
[17:03:39.419]         else {
[17:03:39.419]             ...future.result["stdout"] <- base::list(NULL)
[17:03:39.419]         }
[17:03:39.419]         base::close(...future.stdout)
[17:03:39.419]         ...future.stdout <- NULL
[17:03:39.419]     }
[17:03:39.419]     ...future.result$conditions <- ...future.conditions
[17:03:39.419]     ...future.result$finished <- base::Sys.time()
[17:03:39.419]     ...future.result
[17:03:39.419] }
[17:03:39.421] assign_globals() ...
[17:03:39.422] List of 1
[17:03:39.422]  $ kk: int 1
[17:03:39.422]  - attr(*, "where")=List of 1
[17:03:39.422]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:39.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:39.422]  - attr(*, "resolved")= logi FALSE
[17:03:39.422]  - attr(*, "total_size")= num 56
[17:03:39.422]  - attr(*, "already-done")= logi TRUE
[17:03:39.425] - copied ‘kk’ to environment
[17:03:39.426] assign_globals() ... done
[17:03:39.426] requestCore(): workers = 2
[17:03:39.426] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:39.437] result() for MulticoreFuture ...
[17:03:39.437] result() for MulticoreFuture ...
[17:03:39.438] result() for MulticoreFuture ... done
[17:03:39.438] result() for MulticoreFuture ... done
[17:03:39.438] result() for MulticoreFuture ...
[17:03:39.438] result() for MulticoreFuture ... done
[17:03:39.440] MulticoreFuture started
[17:03:39.441] - Launch lazy future ... done
[17:03:39.441] run() for ‘MulticoreFuture’ ... done
[17:03:39.442] getGlobalsAndPackages() ...
[17:03:39.442] plan(): Setting new future strategy stack:
[17:03:39.442] Searching for globals...
[17:03:39.442] List of future strategies:
[17:03:39.442] 1. sequential:
[17:03:39.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:39.442]    - tweaked: FALSE
[17:03:39.442]    - call: NULL
[17:03:39.444] plan(): nbrOfWorkers() = 1
[17:03:39.445] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:39.445] Searching for globals ... DONE
[17:03:39.446] Resolving globals: FALSE
[17:03:39.446] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:39.447] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:39.447] - globals: [1] ‘kk’
[17:03:39.448] 
[17:03:39.448] getGlobalsAndPackages() ... DONE
[17:03:39.448] run() for ‘Future’ ...
[17:03:39.448] - state: ‘created’
[17:03:39.449] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:39.454] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:39.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:39.454]   - Field: ‘label’
[17:03:39.454]   - Field: ‘local’
[17:03:39.454]   - Field: ‘owner’
[17:03:39.455]   - Field: ‘envir’
[17:03:39.455]   - Field: ‘workers’
[17:03:39.455]   - Field: ‘packages’
[17:03:39.455]   - Field: ‘gc’
[17:03:39.455]   - Field: ‘job’
[17:03:39.455]   - Field: ‘conditions’
[17:03:39.456]   - Field: ‘expr’
[17:03:39.456]   - Field: ‘uuid’
[17:03:39.456]   - Field: ‘seed’
[17:03:39.456]   - Field: ‘version’
[17:03:39.456]   - Field: ‘result’
[17:03:39.456]   - Field: ‘asynchronous’
[17:03:39.456]   - Field: ‘calls’
[17:03:39.456]   - Field: ‘globals’
[17:03:39.457]   - Field: ‘stdout’
[17:03:39.457]   - Field: ‘earlySignal’
[17:03:39.457]   - Field: ‘lazy’
[17:03:39.457]   - Field: ‘state’
[17:03:39.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:39.457] - Launch lazy future ...
[17:03:39.458] Packages needed by the future expression (n = 0): <none>
[17:03:39.458] Packages needed by future strategies (n = 0): <none>
[17:03:39.459] {
[17:03:39.459]     {
[17:03:39.459]         {
[17:03:39.459]             ...future.startTime <- base::Sys.time()
[17:03:39.459]             {
[17:03:39.459]                 {
[17:03:39.459]                   {
[17:03:39.459]                     {
[17:03:39.459]                       base::local({
[17:03:39.459]                         has_future <- base::requireNamespace("future", 
[17:03:39.459]                           quietly = TRUE)
[17:03:39.459]                         if (has_future) {
[17:03:39.459]                           ns <- base::getNamespace("future")
[17:03:39.459]                           version <- ns[[".package"]][["version"]]
[17:03:39.459]                           if (is.null(version)) 
[17:03:39.459]                             version <- utils::packageVersion("future")
[17:03:39.459]                         }
[17:03:39.459]                         else {
[17:03:39.459]                           version <- NULL
[17:03:39.459]                         }
[17:03:39.459]                         if (!has_future || version < "1.8.0") {
[17:03:39.459]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:39.459]                             "", base::R.version$version.string), 
[17:03:39.459]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:39.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:39.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:39.459]                               "release", "version")], collapse = " "), 
[17:03:39.459]                             hostname = base::Sys.info()[["nodename"]])
[17:03:39.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:39.459]                             info)
[17:03:39.459]                           info <- base::paste(info, collapse = "; ")
[17:03:39.459]                           if (!has_future) {
[17:03:39.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:39.459]                               info)
[17:03:39.459]                           }
[17:03:39.459]                           else {
[17:03:39.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:39.459]                               info, version)
[17:03:39.459]                           }
[17:03:39.459]                           base::stop(msg)
[17:03:39.459]                         }
[17:03:39.459]                       })
[17:03:39.459]                     }
[17:03:39.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:39.459]                     base::options(mc.cores = 1L)
[17:03:39.459]                   }
[17:03:39.459]                   ...future.strategy.old <- future::plan("list")
[17:03:39.459]                   options(future.plan = NULL)
[17:03:39.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:39.459]                 }
[17:03:39.459]                 ...future.workdir <- getwd()
[17:03:39.459]             }
[17:03:39.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:39.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:39.459]         }
[17:03:39.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:39.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:39.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:39.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:39.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:39.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:39.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:39.459]             base::names(...future.oldOptions))
[17:03:39.459]     }
[17:03:39.459]     if (FALSE) {
[17:03:39.459]     }
[17:03:39.459]     else {
[17:03:39.459]         if (TRUE) {
[17:03:39.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:39.459]                 open = "w")
[17:03:39.459]         }
[17:03:39.459]         else {
[17:03:39.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:39.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:39.459]         }
[17:03:39.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:39.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:39.459]             base::sink(type = "output", split = FALSE)
[17:03:39.459]             base::close(...future.stdout)
[17:03:39.459]         }, add = TRUE)
[17:03:39.459]     }
[17:03:39.459]     ...future.frame <- base::sys.nframe()
[17:03:39.459]     ...future.conditions <- base::list()
[17:03:39.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:39.459]     if (FALSE) {
[17:03:39.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:39.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:39.459]     }
[17:03:39.459]     ...future.result <- base::tryCatch({
[17:03:39.459]         base::withCallingHandlers({
[17:03:39.459]             ...future.value <- base::withVisible(base::local({
[17:03:39.459]                 withCallingHandlers({
[17:03:39.459]                   {
[17:03:39.459]                     Sys.sleep(0.1)
[17:03:39.459]                     kk
[17:03:39.459]                   }
[17:03:39.459]                 }, immediateCondition = function(cond) {
[17:03:39.459]                   save_rds <- function (object, pathname, ...) 
[17:03:39.459]                   {
[17:03:39.459]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:39.459]                     if (file_test("-f", pathname_tmp)) {
[17:03:39.459]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.459]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:39.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.459]                         fi_tmp[["mtime"]])
[17:03:39.459]                     }
[17:03:39.459]                     tryCatch({
[17:03:39.459]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:39.459]                     }, error = function(ex) {
[17:03:39.459]                       msg <- conditionMessage(ex)
[17:03:39.459]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.459]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:39.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.459]                         fi_tmp[["mtime"]], msg)
[17:03:39.459]                       ex$message <- msg
[17:03:39.459]                       stop(ex)
[17:03:39.459]                     })
[17:03:39.459]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:39.459]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:39.459]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:39.459]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.459]                       fi <- file.info(pathname)
[17:03:39.459]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:39.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.459]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:39.459]                         fi[["size"]], fi[["mtime"]])
[17:03:39.459]                       stop(msg)
[17:03:39.459]                     }
[17:03:39.459]                     invisible(pathname)
[17:03:39.459]                   }
[17:03:39.459]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:39.459]                     rootPath = tempdir()) 
[17:03:39.459]                   {
[17:03:39.459]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:39.459]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:39.459]                       tmpdir = path, fileext = ".rds")
[17:03:39.459]                     save_rds(obj, file)
[17:03:39.459]                   }
[17:03:39.459]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:39.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.459]                   {
[17:03:39.459]                     inherits <- base::inherits
[17:03:39.459]                     invokeRestart <- base::invokeRestart
[17:03:39.459]                     is.null <- base::is.null
[17:03:39.459]                     muffled <- FALSE
[17:03:39.459]                     if (inherits(cond, "message")) {
[17:03:39.459]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:39.459]                       if (muffled) 
[17:03:39.459]                         invokeRestart("muffleMessage")
[17:03:39.459]                     }
[17:03:39.459]                     else if (inherits(cond, "warning")) {
[17:03:39.459]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:39.459]                       if (muffled) 
[17:03:39.459]                         invokeRestart("muffleWarning")
[17:03:39.459]                     }
[17:03:39.459]                     else if (inherits(cond, "condition")) {
[17:03:39.459]                       if (!is.null(pattern)) {
[17:03:39.459]                         computeRestarts <- base::computeRestarts
[17:03:39.459]                         grepl <- base::grepl
[17:03:39.459]                         restarts <- computeRestarts(cond)
[17:03:39.459]                         for (restart in restarts) {
[17:03:39.459]                           name <- restart$name
[17:03:39.459]                           if (is.null(name)) 
[17:03:39.459]                             next
[17:03:39.459]                           if (!grepl(pattern, name)) 
[17:03:39.459]                             next
[17:03:39.459]                           invokeRestart(restart)
[17:03:39.459]                           muffled <- TRUE
[17:03:39.459]                           break
[17:03:39.459]                         }
[17:03:39.459]                       }
[17:03:39.459]                     }
[17:03:39.459]                     invisible(muffled)
[17:03:39.459]                   }
[17:03:39.459]                   muffleCondition(cond)
[17:03:39.459]                 })
[17:03:39.459]             }))
[17:03:39.459]             future::FutureResult(value = ...future.value$value, 
[17:03:39.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.459]                   ...future.rng), globalenv = if (FALSE) 
[17:03:39.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:39.459]                     ...future.globalenv.names))
[17:03:39.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:39.459]         }, condition = base::local({
[17:03:39.459]             c <- base::c
[17:03:39.459]             inherits <- base::inherits
[17:03:39.459]             invokeRestart <- base::invokeRestart
[17:03:39.459]             length <- base::length
[17:03:39.459]             list <- base::list
[17:03:39.459]             seq.int <- base::seq.int
[17:03:39.459]             signalCondition <- base::signalCondition
[17:03:39.459]             sys.calls <- base::sys.calls
[17:03:39.459]             `[[` <- base::`[[`
[17:03:39.459]             `+` <- base::`+`
[17:03:39.459]             `<<-` <- base::`<<-`
[17:03:39.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:39.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:39.459]                   3L)]
[17:03:39.459]             }
[17:03:39.459]             function(cond) {
[17:03:39.459]                 is_error <- inherits(cond, "error")
[17:03:39.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:39.459]                   NULL)
[17:03:39.459]                 if (is_error) {
[17:03:39.459]                   sessionInformation <- function() {
[17:03:39.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:39.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:39.459]                       search = base::search(), system = base::Sys.info())
[17:03:39.459]                   }
[17:03:39.459]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:39.459]                     cond$call), session = sessionInformation(), 
[17:03:39.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:39.459]                   signalCondition(cond)
[17:03:39.459]                 }
[17:03:39.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:39.459]                 "immediateCondition"))) {
[17:03:39.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:39.459]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:39.459]                   if (TRUE && !signal) {
[17:03:39.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.459]                     {
[17:03:39.459]                       inherits <- base::inherits
[17:03:39.459]                       invokeRestart <- base::invokeRestart
[17:03:39.459]                       is.null <- base::is.null
[17:03:39.459]                       muffled <- FALSE
[17:03:39.459]                       if (inherits(cond, "message")) {
[17:03:39.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.459]                         if (muffled) 
[17:03:39.459]                           invokeRestart("muffleMessage")
[17:03:39.459]                       }
[17:03:39.459]                       else if (inherits(cond, "warning")) {
[17:03:39.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.459]                         if (muffled) 
[17:03:39.459]                           invokeRestart("muffleWarning")
[17:03:39.459]                       }
[17:03:39.459]                       else if (inherits(cond, "condition")) {
[17:03:39.459]                         if (!is.null(pattern)) {
[17:03:39.459]                           computeRestarts <- base::computeRestarts
[17:03:39.459]                           grepl <- base::grepl
[17:03:39.459]                           restarts <- computeRestarts(cond)
[17:03:39.459]                           for (restart in restarts) {
[17:03:39.459]                             name <- restart$name
[17:03:39.459]                             if (is.null(name)) 
[17:03:39.459]                               next
[17:03:39.459]                             if (!grepl(pattern, name)) 
[17:03:39.459]                               next
[17:03:39.459]                             invokeRestart(restart)
[17:03:39.459]                             muffled <- TRUE
[17:03:39.459]                             break
[17:03:39.459]                           }
[17:03:39.459]                         }
[17:03:39.459]                       }
[17:03:39.459]                       invisible(muffled)
[17:03:39.459]                     }
[17:03:39.459]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.459]                   }
[17:03:39.459]                 }
[17:03:39.459]                 else {
[17:03:39.459]                   if (TRUE) {
[17:03:39.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.459]                     {
[17:03:39.459]                       inherits <- base::inherits
[17:03:39.459]                       invokeRestart <- base::invokeRestart
[17:03:39.459]                       is.null <- base::is.null
[17:03:39.459]                       muffled <- FALSE
[17:03:39.459]                       if (inherits(cond, "message")) {
[17:03:39.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.459]                         if (muffled) 
[17:03:39.459]                           invokeRestart("muffleMessage")
[17:03:39.459]                       }
[17:03:39.459]                       else if (inherits(cond, "warning")) {
[17:03:39.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.459]                         if (muffled) 
[17:03:39.459]                           invokeRestart("muffleWarning")
[17:03:39.459]                       }
[17:03:39.459]                       else if (inherits(cond, "condition")) {
[17:03:39.459]                         if (!is.null(pattern)) {
[17:03:39.459]                           computeRestarts <- base::computeRestarts
[17:03:39.459]                           grepl <- base::grepl
[17:03:39.459]                           restarts <- computeRestarts(cond)
[17:03:39.459]                           for (restart in restarts) {
[17:03:39.459]                             name <- restart$name
[17:03:39.459]                             if (is.null(name)) 
[17:03:39.459]                               next
[17:03:39.459]                             if (!grepl(pattern, name)) 
[17:03:39.459]                               next
[17:03:39.459]                             invokeRestart(restart)
[17:03:39.459]                             muffled <- TRUE
[17:03:39.459]                             break
[17:03:39.459]                           }
[17:03:39.459]                         }
[17:03:39.459]                       }
[17:03:39.459]                       invisible(muffled)
[17:03:39.459]                     }
[17:03:39.459]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.459]                   }
[17:03:39.459]                 }
[17:03:39.459]             }
[17:03:39.459]         }))
[17:03:39.459]     }, error = function(ex) {
[17:03:39.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:39.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.459]                 ...future.rng), started = ...future.startTime, 
[17:03:39.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:39.459]             version = "1.8"), class = "FutureResult")
[17:03:39.459]     }, finally = {
[17:03:39.459]         if (!identical(...future.workdir, getwd())) 
[17:03:39.459]             setwd(...future.workdir)
[17:03:39.459]         {
[17:03:39.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:39.459]                 ...future.oldOptions$nwarnings <- NULL
[17:03:39.459]             }
[17:03:39.459]             base::options(...future.oldOptions)
[17:03:39.459]             if (.Platform$OS.type == "windows") {
[17:03:39.459]                 old_names <- names(...future.oldEnvVars)
[17:03:39.459]                 envs <- base::Sys.getenv()
[17:03:39.459]                 names <- names(envs)
[17:03:39.459]                 common <- intersect(names, old_names)
[17:03:39.459]                 added <- setdiff(names, old_names)
[17:03:39.459]                 removed <- setdiff(old_names, names)
[17:03:39.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:39.459]                   envs[common]]
[17:03:39.459]                 NAMES <- toupper(changed)
[17:03:39.459]                 args <- list()
[17:03:39.459]                 for (kk in seq_along(NAMES)) {
[17:03:39.459]                   name <- changed[[kk]]
[17:03:39.459]                   NAME <- NAMES[[kk]]
[17:03:39.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.459]                     next
[17:03:39.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.459]                 }
[17:03:39.459]                 NAMES <- toupper(added)
[17:03:39.459]                 for (kk in seq_along(NAMES)) {
[17:03:39.459]                   name <- added[[kk]]
[17:03:39.459]                   NAME <- NAMES[[kk]]
[17:03:39.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.459]                     next
[17:03:39.459]                   args[[name]] <- ""
[17:03:39.459]                 }
[17:03:39.459]                 NAMES <- toupper(removed)
[17:03:39.459]                 for (kk in seq_along(NAMES)) {
[17:03:39.459]                   name <- removed[[kk]]
[17:03:39.459]                   NAME <- NAMES[[kk]]
[17:03:39.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.459]                     next
[17:03:39.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.459]                 }
[17:03:39.459]                 if (length(args) > 0) 
[17:03:39.459]                   base::do.call(base::Sys.setenv, args = args)
[17:03:39.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:39.459]             }
[17:03:39.459]             else {
[17:03:39.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:39.459]             }
[17:03:39.459]             {
[17:03:39.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:39.459]                   0L) {
[17:03:39.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:39.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:39.459]                   base::options(opts)
[17:03:39.459]                 }
[17:03:39.459]                 {
[17:03:39.459]                   {
[17:03:39.459]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:39.459]                     NULL
[17:03:39.459]                   }
[17:03:39.459]                   options(future.plan = NULL)
[17:03:39.459]                   if (is.na(NA_character_)) 
[17:03:39.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:39.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:39.459]                     .init = FALSE)
[17:03:39.459]                 }
[17:03:39.459]             }
[17:03:39.459]         }
[17:03:39.459]     })
[17:03:39.459]     if (TRUE) {
[17:03:39.459]         base::sink(type = "output", split = FALSE)
[17:03:39.459]         if (TRUE) {
[17:03:39.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:39.459]         }
[17:03:39.459]         else {
[17:03:39.459]             ...future.result["stdout"] <- base::list(NULL)
[17:03:39.459]         }
[17:03:39.459]         base::close(...future.stdout)
[17:03:39.459]         ...future.stdout <- NULL
[17:03:39.459]     }
[17:03:39.459]     ...future.result$conditions <- ...future.conditions
[17:03:39.459]     ...future.result$finished <- base::Sys.time()
[17:03:39.459]     ...future.result
[17:03:39.459] }
[17:03:39.462] assign_globals() ...
[17:03:39.462] List of 1
[17:03:39.462]  $ kk: int 2
[17:03:39.462]  - attr(*, "where")=List of 1
[17:03:39.462]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:39.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:39.462]  - attr(*, "resolved")= logi FALSE
[17:03:39.462]  - attr(*, "total_size")= num 56
[17:03:39.462]  - attr(*, "already-done")= logi TRUE
[17:03:39.466] - copied ‘kk’ to environment
[17:03:39.467] assign_globals() ... done
[17:03:39.467] requestCore(): workers = 2
[17:03:39.467] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:39.478] result() for MulticoreFuture ...
[17:03:39.479] result() for MulticoreFuture ...
[17:03:39.479] result() for MulticoreFuture ... done
[17:03:39.479] result() for MulticoreFuture ... done
[17:03:39.479] result() for MulticoreFuture ...
[17:03:39.479] result() for MulticoreFuture ... done
[17:03:39.482] MulticoreFuture started
[17:03:39.482] - Launch lazy future ... done
[17:03:39.483] run() for ‘MulticoreFuture’ ... done
[17:03:39.483] getGlobalsAndPackages() ...
[17:03:39.483] Searching for globals...
[17:03:39.483] plan(): Setting new future strategy stack:
[17:03:39.484] List of future strategies:
[17:03:39.484] 1. sequential:
[17:03:39.484]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:39.484]    - tweaked: FALSE
[17:03:39.484]    - call: NULL
[17:03:39.485] plan(): nbrOfWorkers() = 1
[17:03:39.487] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:39.487] Searching for globals ... DONE
[17:03:39.487] Resolving globals: FALSE
[17:03:39.488] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:39.489] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:39.489] - globals: [1] ‘kk’
[17:03:39.489] 
[17:03:39.489] getGlobalsAndPackages() ... DONE
[17:03:39.490] run() for ‘Future’ ...
[17:03:39.490] - state: ‘created’
[17:03:39.490] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:39.495] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:39.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:39.496]   - Field: ‘label’
[17:03:39.496]   - Field: ‘local’
[17:03:39.496]   - Field: ‘owner’
[17:03:39.496]   - Field: ‘envir’
[17:03:39.496]   - Field: ‘workers’
[17:03:39.497]   - Field: ‘packages’
[17:03:39.497]   - Field: ‘gc’
[17:03:39.497]   - Field: ‘job’
[17:03:39.497]   - Field: ‘conditions’
[17:03:39.497]   - Field: ‘expr’
[17:03:39.497]   - Field: ‘uuid’
[17:03:39.498]   - Field: ‘seed’
[17:03:39.498]   - Field: ‘version’
[17:03:39.498]   - Field: ‘result’
[17:03:39.498]   - Field: ‘asynchronous’
[17:03:39.498]   - Field: ‘calls’
[17:03:39.502]   - Field: ‘globals’
[17:03:39.502]   - Field: ‘stdout’
[17:03:39.503]   - Field: ‘earlySignal’
[17:03:39.503]   - Field: ‘lazy’
[17:03:39.504]   - Field: ‘state’
[17:03:39.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:39.504] - Launch lazy future ...
[17:03:39.505] Packages needed by the future expression (n = 0): <none>
[17:03:39.505] Packages needed by future strategies (n = 0): <none>
[17:03:39.507] {
[17:03:39.507]     {
[17:03:39.507]         {
[17:03:39.507]             ...future.startTime <- base::Sys.time()
[17:03:39.507]             {
[17:03:39.507]                 {
[17:03:39.507]                   {
[17:03:39.507]                     {
[17:03:39.507]                       base::local({
[17:03:39.507]                         has_future <- base::requireNamespace("future", 
[17:03:39.507]                           quietly = TRUE)
[17:03:39.507]                         if (has_future) {
[17:03:39.507]                           ns <- base::getNamespace("future")
[17:03:39.507]                           version <- ns[[".package"]][["version"]]
[17:03:39.507]                           if (is.null(version)) 
[17:03:39.507]                             version <- utils::packageVersion("future")
[17:03:39.507]                         }
[17:03:39.507]                         else {
[17:03:39.507]                           version <- NULL
[17:03:39.507]                         }
[17:03:39.507]                         if (!has_future || version < "1.8.0") {
[17:03:39.507]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:39.507]                             "", base::R.version$version.string), 
[17:03:39.507]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:39.507]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:39.507]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:39.507]                               "release", "version")], collapse = " "), 
[17:03:39.507]                             hostname = base::Sys.info()[["nodename"]])
[17:03:39.507]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:39.507]                             info)
[17:03:39.507]                           info <- base::paste(info, collapse = "; ")
[17:03:39.507]                           if (!has_future) {
[17:03:39.507]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:39.507]                               info)
[17:03:39.507]                           }
[17:03:39.507]                           else {
[17:03:39.507]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:39.507]                               info, version)
[17:03:39.507]                           }
[17:03:39.507]                           base::stop(msg)
[17:03:39.507]                         }
[17:03:39.507]                       })
[17:03:39.507]                     }
[17:03:39.507]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:39.507]                     base::options(mc.cores = 1L)
[17:03:39.507]                   }
[17:03:39.507]                   ...future.strategy.old <- future::plan("list")
[17:03:39.507]                   options(future.plan = NULL)
[17:03:39.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:39.507]                 }
[17:03:39.507]                 ...future.workdir <- getwd()
[17:03:39.507]             }
[17:03:39.507]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:39.507]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:39.507]         }
[17:03:39.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:39.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:39.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:39.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:39.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:39.507]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:39.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:39.507]             base::names(...future.oldOptions))
[17:03:39.507]     }
[17:03:39.507]     if (FALSE) {
[17:03:39.507]     }
[17:03:39.507]     else {
[17:03:39.507]         if (TRUE) {
[17:03:39.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:39.507]                 open = "w")
[17:03:39.507]         }
[17:03:39.507]         else {
[17:03:39.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:39.507]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:39.507]         }
[17:03:39.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:39.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:39.507]             base::sink(type = "output", split = FALSE)
[17:03:39.507]             base::close(...future.stdout)
[17:03:39.507]         }, add = TRUE)
[17:03:39.507]     }
[17:03:39.507]     ...future.frame <- base::sys.nframe()
[17:03:39.507]     ...future.conditions <- base::list()
[17:03:39.507]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:39.507]     if (FALSE) {
[17:03:39.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:39.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:39.507]     }
[17:03:39.507]     ...future.result <- base::tryCatch({
[17:03:39.507]         base::withCallingHandlers({
[17:03:39.507]             ...future.value <- base::withVisible(base::local({
[17:03:39.507]                 withCallingHandlers({
[17:03:39.507]                   {
[17:03:39.507]                     Sys.sleep(0.1)
[17:03:39.507]                     kk
[17:03:39.507]                   }
[17:03:39.507]                 }, immediateCondition = function(cond) {
[17:03:39.507]                   save_rds <- function (object, pathname, ...) 
[17:03:39.507]                   {
[17:03:39.507]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:39.507]                     if (file_test("-f", pathname_tmp)) {
[17:03:39.507]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.507]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:39.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.507]                         fi_tmp[["mtime"]])
[17:03:39.507]                     }
[17:03:39.507]                     tryCatch({
[17:03:39.507]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:39.507]                     }, error = function(ex) {
[17:03:39.507]                       msg <- conditionMessage(ex)
[17:03:39.507]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.507]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:39.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.507]                         fi_tmp[["mtime"]], msg)
[17:03:39.507]                       ex$message <- msg
[17:03:39.507]                       stop(ex)
[17:03:39.507]                     })
[17:03:39.507]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:39.507]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:39.507]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:39.507]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.507]                       fi <- file.info(pathname)
[17:03:39.507]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:39.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.507]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:39.507]                         fi[["size"]], fi[["mtime"]])
[17:03:39.507]                       stop(msg)
[17:03:39.507]                     }
[17:03:39.507]                     invisible(pathname)
[17:03:39.507]                   }
[17:03:39.507]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:39.507]                     rootPath = tempdir()) 
[17:03:39.507]                   {
[17:03:39.507]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:39.507]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:39.507]                       tmpdir = path, fileext = ".rds")
[17:03:39.507]                     save_rds(obj, file)
[17:03:39.507]                   }
[17:03:39.507]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:39.507]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.507]                   {
[17:03:39.507]                     inherits <- base::inherits
[17:03:39.507]                     invokeRestart <- base::invokeRestart
[17:03:39.507]                     is.null <- base::is.null
[17:03:39.507]                     muffled <- FALSE
[17:03:39.507]                     if (inherits(cond, "message")) {
[17:03:39.507]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:39.507]                       if (muffled) 
[17:03:39.507]                         invokeRestart("muffleMessage")
[17:03:39.507]                     }
[17:03:39.507]                     else if (inherits(cond, "warning")) {
[17:03:39.507]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:39.507]                       if (muffled) 
[17:03:39.507]                         invokeRestart("muffleWarning")
[17:03:39.507]                     }
[17:03:39.507]                     else if (inherits(cond, "condition")) {
[17:03:39.507]                       if (!is.null(pattern)) {
[17:03:39.507]                         computeRestarts <- base::computeRestarts
[17:03:39.507]                         grepl <- base::grepl
[17:03:39.507]                         restarts <- computeRestarts(cond)
[17:03:39.507]                         for (restart in restarts) {
[17:03:39.507]                           name <- restart$name
[17:03:39.507]                           if (is.null(name)) 
[17:03:39.507]                             next
[17:03:39.507]                           if (!grepl(pattern, name)) 
[17:03:39.507]                             next
[17:03:39.507]                           invokeRestart(restart)
[17:03:39.507]                           muffled <- TRUE
[17:03:39.507]                           break
[17:03:39.507]                         }
[17:03:39.507]                       }
[17:03:39.507]                     }
[17:03:39.507]                     invisible(muffled)
[17:03:39.507]                   }
[17:03:39.507]                   muffleCondition(cond)
[17:03:39.507]                 })
[17:03:39.507]             }))
[17:03:39.507]             future::FutureResult(value = ...future.value$value, 
[17:03:39.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.507]                   ...future.rng), globalenv = if (FALSE) 
[17:03:39.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:39.507]                     ...future.globalenv.names))
[17:03:39.507]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:39.507]         }, condition = base::local({
[17:03:39.507]             c <- base::c
[17:03:39.507]             inherits <- base::inherits
[17:03:39.507]             invokeRestart <- base::invokeRestart
[17:03:39.507]             length <- base::length
[17:03:39.507]             list <- base::list
[17:03:39.507]             seq.int <- base::seq.int
[17:03:39.507]             signalCondition <- base::signalCondition
[17:03:39.507]             sys.calls <- base::sys.calls
[17:03:39.507]             `[[` <- base::`[[`
[17:03:39.507]             `+` <- base::`+`
[17:03:39.507]             `<<-` <- base::`<<-`
[17:03:39.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:39.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:39.507]                   3L)]
[17:03:39.507]             }
[17:03:39.507]             function(cond) {
[17:03:39.507]                 is_error <- inherits(cond, "error")
[17:03:39.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:39.507]                   NULL)
[17:03:39.507]                 if (is_error) {
[17:03:39.507]                   sessionInformation <- function() {
[17:03:39.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:39.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:39.507]                       search = base::search(), system = base::Sys.info())
[17:03:39.507]                   }
[17:03:39.507]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:39.507]                     cond$call), session = sessionInformation(), 
[17:03:39.507]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:39.507]                   signalCondition(cond)
[17:03:39.507]                 }
[17:03:39.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:39.507]                 "immediateCondition"))) {
[17:03:39.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:39.507]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:39.507]                   if (TRUE && !signal) {
[17:03:39.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.507]                     {
[17:03:39.507]                       inherits <- base::inherits
[17:03:39.507]                       invokeRestart <- base::invokeRestart
[17:03:39.507]                       is.null <- base::is.null
[17:03:39.507]                       muffled <- FALSE
[17:03:39.507]                       if (inherits(cond, "message")) {
[17:03:39.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.507]                         if (muffled) 
[17:03:39.507]                           invokeRestart("muffleMessage")
[17:03:39.507]                       }
[17:03:39.507]                       else if (inherits(cond, "warning")) {
[17:03:39.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.507]                         if (muffled) 
[17:03:39.507]                           invokeRestart("muffleWarning")
[17:03:39.507]                       }
[17:03:39.507]                       else if (inherits(cond, "condition")) {
[17:03:39.507]                         if (!is.null(pattern)) {
[17:03:39.507]                           computeRestarts <- base::computeRestarts
[17:03:39.507]                           grepl <- base::grepl
[17:03:39.507]                           restarts <- computeRestarts(cond)
[17:03:39.507]                           for (restart in restarts) {
[17:03:39.507]                             name <- restart$name
[17:03:39.507]                             if (is.null(name)) 
[17:03:39.507]                               next
[17:03:39.507]                             if (!grepl(pattern, name)) 
[17:03:39.507]                               next
[17:03:39.507]                             invokeRestart(restart)
[17:03:39.507]                             muffled <- TRUE
[17:03:39.507]                             break
[17:03:39.507]                           }
[17:03:39.507]                         }
[17:03:39.507]                       }
[17:03:39.507]                       invisible(muffled)
[17:03:39.507]                     }
[17:03:39.507]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.507]                   }
[17:03:39.507]                 }
[17:03:39.507]                 else {
[17:03:39.507]                   if (TRUE) {
[17:03:39.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.507]                     {
[17:03:39.507]                       inherits <- base::inherits
[17:03:39.507]                       invokeRestart <- base::invokeRestart
[17:03:39.507]                       is.null <- base::is.null
[17:03:39.507]                       muffled <- FALSE
[17:03:39.507]                       if (inherits(cond, "message")) {
[17:03:39.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.507]                         if (muffled) 
[17:03:39.507]                           invokeRestart("muffleMessage")
[17:03:39.507]                       }
[17:03:39.507]                       else if (inherits(cond, "warning")) {
[17:03:39.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.507]                         if (muffled) 
[17:03:39.507]                           invokeRestart("muffleWarning")
[17:03:39.507]                       }
[17:03:39.507]                       else if (inherits(cond, "condition")) {
[17:03:39.507]                         if (!is.null(pattern)) {
[17:03:39.507]                           computeRestarts <- base::computeRestarts
[17:03:39.507]                           grepl <- base::grepl
[17:03:39.507]                           restarts <- computeRestarts(cond)
[17:03:39.507]                           for (restart in restarts) {
[17:03:39.507]                             name <- restart$name
[17:03:39.507]                             if (is.null(name)) 
[17:03:39.507]                               next
[17:03:39.507]                             if (!grepl(pattern, name)) 
[17:03:39.507]                               next
[17:03:39.507]                             invokeRestart(restart)
[17:03:39.507]                             muffled <- TRUE
[17:03:39.507]                             break
[17:03:39.507]                           }
[17:03:39.507]                         }
[17:03:39.507]                       }
[17:03:39.507]                       invisible(muffled)
[17:03:39.507]                     }
[17:03:39.507]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.507]                   }
[17:03:39.507]                 }
[17:03:39.507]             }
[17:03:39.507]         }))
[17:03:39.507]     }, error = function(ex) {
[17:03:39.507]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:39.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.507]                 ...future.rng), started = ...future.startTime, 
[17:03:39.507]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:39.507]             version = "1.8"), class = "FutureResult")
[17:03:39.507]     }, finally = {
[17:03:39.507]         if (!identical(...future.workdir, getwd())) 
[17:03:39.507]             setwd(...future.workdir)
[17:03:39.507]         {
[17:03:39.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:39.507]                 ...future.oldOptions$nwarnings <- NULL
[17:03:39.507]             }
[17:03:39.507]             base::options(...future.oldOptions)
[17:03:39.507]             if (.Platform$OS.type == "windows") {
[17:03:39.507]                 old_names <- names(...future.oldEnvVars)
[17:03:39.507]                 envs <- base::Sys.getenv()
[17:03:39.507]                 names <- names(envs)
[17:03:39.507]                 common <- intersect(names, old_names)
[17:03:39.507]                 added <- setdiff(names, old_names)
[17:03:39.507]                 removed <- setdiff(old_names, names)
[17:03:39.507]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:39.507]                   envs[common]]
[17:03:39.507]                 NAMES <- toupper(changed)
[17:03:39.507]                 args <- list()
[17:03:39.507]                 for (kk in seq_along(NAMES)) {
[17:03:39.507]                   name <- changed[[kk]]
[17:03:39.507]                   NAME <- NAMES[[kk]]
[17:03:39.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.507]                     next
[17:03:39.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.507]                 }
[17:03:39.507]                 NAMES <- toupper(added)
[17:03:39.507]                 for (kk in seq_along(NAMES)) {
[17:03:39.507]                   name <- added[[kk]]
[17:03:39.507]                   NAME <- NAMES[[kk]]
[17:03:39.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.507]                     next
[17:03:39.507]                   args[[name]] <- ""
[17:03:39.507]                 }
[17:03:39.507]                 NAMES <- toupper(removed)
[17:03:39.507]                 for (kk in seq_along(NAMES)) {
[17:03:39.507]                   name <- removed[[kk]]
[17:03:39.507]                   NAME <- NAMES[[kk]]
[17:03:39.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.507]                     next
[17:03:39.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.507]                 }
[17:03:39.507]                 if (length(args) > 0) 
[17:03:39.507]                   base::do.call(base::Sys.setenv, args = args)
[17:03:39.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:39.507]             }
[17:03:39.507]             else {
[17:03:39.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:39.507]             }
[17:03:39.507]             {
[17:03:39.507]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:39.507]                   0L) {
[17:03:39.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:39.507]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:39.507]                   base::options(opts)
[17:03:39.507]                 }
[17:03:39.507]                 {
[17:03:39.507]                   {
[17:03:39.507]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:39.507]                     NULL
[17:03:39.507]                   }
[17:03:39.507]                   options(future.plan = NULL)
[17:03:39.507]                   if (is.na(NA_character_)) 
[17:03:39.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:39.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:39.507]                     .init = FALSE)
[17:03:39.507]                 }
[17:03:39.507]             }
[17:03:39.507]         }
[17:03:39.507]     })
[17:03:39.507]     if (TRUE) {
[17:03:39.507]         base::sink(type = "output", split = FALSE)
[17:03:39.507]         if (TRUE) {
[17:03:39.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:39.507]         }
[17:03:39.507]         else {
[17:03:39.507]             ...future.result["stdout"] <- base::list(NULL)
[17:03:39.507]         }
[17:03:39.507]         base::close(...future.stdout)
[17:03:39.507]         ...future.stdout <- NULL
[17:03:39.507]     }
[17:03:39.507]     ...future.result$conditions <- ...future.conditions
[17:03:39.507]     ...future.result$finished <- base::Sys.time()
[17:03:39.507]     ...future.result
[17:03:39.507] }
[17:03:39.509] assign_globals() ...
[17:03:39.510] List of 1
[17:03:39.510]  $ kk: int 3
[17:03:39.510]  - attr(*, "where")=List of 1
[17:03:39.510]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:39.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:39.510]  - attr(*, "resolved")= logi FALSE
[17:03:39.510]  - attr(*, "total_size")= num 56
[17:03:39.510]  - attr(*, "already-done")= logi TRUE
[17:03:39.514] - copied ‘kk’ to environment
[17:03:39.514] assign_globals() ... done
[17:03:39.514] requestCore(): workers = 2
[17:03:39.515] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:39.546] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:03:39.547] plan(): Setting new future strategy stack:
[17:03:39.547] List of future strategies:
[17:03:39.547] 1. multicore:
[17:03:39.547]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:39.547]    - tweaked: FALSE
[17:03:39.547]    - call: plan(strategy)
[17:03:39.552] plan(): nbrOfWorkers() = 2
[17:03:39.557] result() for MulticoreFuture ...
[17:03:39.558] result() for MulticoreFuture ...
[17:03:39.558] result() for MulticoreFuture ... done
[17:03:39.558] result() for MulticoreFuture ... done
[17:03:39.559] result() for MulticoreFuture ...
[17:03:39.559] result() for MulticoreFuture ... done
[17:03:39.562] MulticoreFuture started
[17:03:39.562] - Launch lazy future ... done
[17:03:39.562] run() for ‘MulticoreFuture’ ... done
[17:03:39.563] resolve() on list ...
[17:03:39.563]  recursive: 0
[17:03:39.563] plan(): Setting new future strategy stack:
[17:03:39.563]  length: 3
[17:03:39.563] 
[17:03:39.564] Future #1
[17:03:39.564]  length: 2 (resolved future 1)
[17:03:39.563] List of future strategies:
[17:03:39.563] 1. sequential:
[17:03:39.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:39.563]    - tweaked: FALSE
[17:03:39.563]    - call: NULL
[17:03:39.564] plan(): nbrOfWorkers() = 1
[17:03:39.588] plan(): Setting new future strategy stack:
[17:03:39.588] List of future strategies:
[17:03:39.588] 1. multicore:
[17:03:39.588]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:39.588]    - tweaked: FALSE
[17:03:39.588]    - call: plan(strategy)
[17:03:39.593] plan(): nbrOfWorkers() = 2
[17:03:39.595] Future #2
[17:03:39.595]  length: 1 (resolved future 2)
[17:03:39.667] plan(): Setting new future strategy stack:
[17:03:39.667] List of future strategies:
[17:03:39.667] 1. multicore:
[17:03:39.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:39.667]    - tweaked: FALSE
[17:03:39.667]    - call: plan(strategy)
[17:03:39.673] plan(): nbrOfWorkers() = 2
[17:03:39.677] Future #3
[17:03:39.677]  length: 0 (resolved future 3)
[17:03:39.678] resolve() on list ... DONE
[17:03:39.678] getGlobalsAndPackages() ...
[17:03:39.678] Searching for globals...
[17:03:39.680] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:39.680] Searching for globals ... DONE
[17:03:39.681] Resolving globals: FALSE
[17:03:39.681] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:39.682] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:39.682] - globals: [1] ‘kk’
[17:03:39.682] 
[17:03:39.682] getGlobalsAndPackages() ... DONE
[17:03:39.683] getGlobalsAndPackages() ...
[17:03:39.683] Searching for globals...
[17:03:39.685] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:39.685] Searching for globals ... DONE
[17:03:39.685] Resolving globals: FALSE
[17:03:39.685] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:39.686] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:39.686] - globals: [1] ‘kk’
[17:03:39.686] 
[17:03:39.686] getGlobalsAndPackages() ... DONE
[17:03:39.687] getGlobalsAndPackages() ...
[17:03:39.687] Searching for globals...
[17:03:39.688] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:39.688] Searching for globals ... DONE
[17:03:39.689] Resolving globals: FALSE
[17:03:39.689] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:39.689] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:39.690] - globals: [1] ‘kk’
[17:03:39.690] 
[17:03:39.690] getGlobalsAndPackages() ... DONE
[17:03:39.690] resolve() on list ...
[17:03:39.690]  recursive: 0
[17:03:39.690]  length: 3
[17:03:39.691] 
[17:03:39.691] run() for ‘Future’ ...
[17:03:39.691] - state: ‘created’
[17:03:39.691] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:39.696] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:39.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:39.696]   - Field: ‘label’
[17:03:39.696]   - Field: ‘local’
[17:03:39.696]   - Field: ‘owner’
[17:03:39.696]   - Field: ‘envir’
[17:03:39.697]   - Field: ‘workers’
[17:03:39.697]   - Field: ‘packages’
[17:03:39.697]   - Field: ‘gc’
[17:03:39.697]   - Field: ‘job’
[17:03:39.697]   - Field: ‘conditions’
[17:03:39.697]   - Field: ‘expr’
[17:03:39.697]   - Field: ‘uuid’
[17:03:39.697]   - Field: ‘seed’
[17:03:39.698]   - Field: ‘version’
[17:03:39.698]   - Field: ‘result’
[17:03:39.698]   - Field: ‘asynchronous’
[17:03:39.698]   - Field: ‘calls’
[17:03:39.698]   - Field: ‘globals’
[17:03:39.698]   - Field: ‘stdout’
[17:03:39.698]   - Field: ‘earlySignal’
[17:03:39.699]   - Field: ‘lazy’
[17:03:39.699]   - Field: ‘state’
[17:03:39.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:39.699] - Launch lazy future ...
[17:03:39.699] Packages needed by the future expression (n = 0): <none>
[17:03:39.700] Packages needed by future strategies (n = 0): <none>
[17:03:39.700] {
[17:03:39.700]     {
[17:03:39.700]         {
[17:03:39.700]             ...future.startTime <- base::Sys.time()
[17:03:39.700]             {
[17:03:39.700]                 {
[17:03:39.700]                   {
[17:03:39.700]                     {
[17:03:39.700]                       base::local({
[17:03:39.700]                         has_future <- base::requireNamespace("future", 
[17:03:39.700]                           quietly = TRUE)
[17:03:39.700]                         if (has_future) {
[17:03:39.700]                           ns <- base::getNamespace("future")
[17:03:39.700]                           version <- ns[[".package"]][["version"]]
[17:03:39.700]                           if (is.null(version)) 
[17:03:39.700]                             version <- utils::packageVersion("future")
[17:03:39.700]                         }
[17:03:39.700]                         else {
[17:03:39.700]                           version <- NULL
[17:03:39.700]                         }
[17:03:39.700]                         if (!has_future || version < "1.8.0") {
[17:03:39.700]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:39.700]                             "", base::R.version$version.string), 
[17:03:39.700]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:39.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:39.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:39.700]                               "release", "version")], collapse = " "), 
[17:03:39.700]                             hostname = base::Sys.info()[["nodename"]])
[17:03:39.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:39.700]                             info)
[17:03:39.700]                           info <- base::paste(info, collapse = "; ")
[17:03:39.700]                           if (!has_future) {
[17:03:39.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:39.700]                               info)
[17:03:39.700]                           }
[17:03:39.700]                           else {
[17:03:39.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:39.700]                               info, version)
[17:03:39.700]                           }
[17:03:39.700]                           base::stop(msg)
[17:03:39.700]                         }
[17:03:39.700]                       })
[17:03:39.700]                     }
[17:03:39.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:39.700]                     base::options(mc.cores = 1L)
[17:03:39.700]                   }
[17:03:39.700]                   ...future.strategy.old <- future::plan("list")
[17:03:39.700]                   options(future.plan = NULL)
[17:03:39.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:39.700]                 }
[17:03:39.700]                 ...future.workdir <- getwd()
[17:03:39.700]             }
[17:03:39.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:39.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:39.700]         }
[17:03:39.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:39.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:39.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:39.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:39.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:39.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:39.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:39.700]             base::names(...future.oldOptions))
[17:03:39.700]     }
[17:03:39.700]     if (FALSE) {
[17:03:39.700]     }
[17:03:39.700]     else {
[17:03:39.700]         if (TRUE) {
[17:03:39.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:39.700]                 open = "w")
[17:03:39.700]         }
[17:03:39.700]         else {
[17:03:39.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:39.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:39.700]         }
[17:03:39.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:39.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:39.700]             base::sink(type = "output", split = FALSE)
[17:03:39.700]             base::close(...future.stdout)
[17:03:39.700]         }, add = TRUE)
[17:03:39.700]     }
[17:03:39.700]     ...future.frame <- base::sys.nframe()
[17:03:39.700]     ...future.conditions <- base::list()
[17:03:39.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:39.700]     if (FALSE) {
[17:03:39.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:39.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:39.700]     }
[17:03:39.700]     ...future.result <- base::tryCatch({
[17:03:39.700]         base::withCallingHandlers({
[17:03:39.700]             ...future.value <- base::withVisible(base::local({
[17:03:39.700]                 withCallingHandlers({
[17:03:39.700]                   {
[17:03:39.700]                     Sys.sleep(0.1)
[17:03:39.700]                     kk
[17:03:39.700]                   }
[17:03:39.700]                 }, immediateCondition = function(cond) {
[17:03:39.700]                   save_rds <- function (object, pathname, ...) 
[17:03:39.700]                   {
[17:03:39.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:39.700]                     if (file_test("-f", pathname_tmp)) {
[17:03:39.700]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:39.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.700]                         fi_tmp[["mtime"]])
[17:03:39.700]                     }
[17:03:39.700]                     tryCatch({
[17:03:39.700]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:39.700]                     }, error = function(ex) {
[17:03:39.700]                       msg <- conditionMessage(ex)
[17:03:39.700]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:39.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.700]                         fi_tmp[["mtime"]], msg)
[17:03:39.700]                       ex$message <- msg
[17:03:39.700]                       stop(ex)
[17:03:39.700]                     })
[17:03:39.700]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:39.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:39.700]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:39.700]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.700]                       fi <- file.info(pathname)
[17:03:39.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:39.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:39.700]                         fi[["size"]], fi[["mtime"]])
[17:03:39.700]                       stop(msg)
[17:03:39.700]                     }
[17:03:39.700]                     invisible(pathname)
[17:03:39.700]                   }
[17:03:39.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:39.700]                     rootPath = tempdir()) 
[17:03:39.700]                   {
[17:03:39.700]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:39.700]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:39.700]                       tmpdir = path, fileext = ".rds")
[17:03:39.700]                     save_rds(obj, file)
[17:03:39.700]                   }
[17:03:39.700]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:39.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.700]                   {
[17:03:39.700]                     inherits <- base::inherits
[17:03:39.700]                     invokeRestart <- base::invokeRestart
[17:03:39.700]                     is.null <- base::is.null
[17:03:39.700]                     muffled <- FALSE
[17:03:39.700]                     if (inherits(cond, "message")) {
[17:03:39.700]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:39.700]                       if (muffled) 
[17:03:39.700]                         invokeRestart("muffleMessage")
[17:03:39.700]                     }
[17:03:39.700]                     else if (inherits(cond, "warning")) {
[17:03:39.700]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:39.700]                       if (muffled) 
[17:03:39.700]                         invokeRestart("muffleWarning")
[17:03:39.700]                     }
[17:03:39.700]                     else if (inherits(cond, "condition")) {
[17:03:39.700]                       if (!is.null(pattern)) {
[17:03:39.700]                         computeRestarts <- base::computeRestarts
[17:03:39.700]                         grepl <- base::grepl
[17:03:39.700]                         restarts <- computeRestarts(cond)
[17:03:39.700]                         for (restart in restarts) {
[17:03:39.700]                           name <- restart$name
[17:03:39.700]                           if (is.null(name)) 
[17:03:39.700]                             next
[17:03:39.700]                           if (!grepl(pattern, name)) 
[17:03:39.700]                             next
[17:03:39.700]                           invokeRestart(restart)
[17:03:39.700]                           muffled <- TRUE
[17:03:39.700]                           break
[17:03:39.700]                         }
[17:03:39.700]                       }
[17:03:39.700]                     }
[17:03:39.700]                     invisible(muffled)
[17:03:39.700]                   }
[17:03:39.700]                   muffleCondition(cond)
[17:03:39.700]                 })
[17:03:39.700]             }))
[17:03:39.700]             future::FutureResult(value = ...future.value$value, 
[17:03:39.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.700]                   ...future.rng), globalenv = if (FALSE) 
[17:03:39.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:39.700]                     ...future.globalenv.names))
[17:03:39.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:39.700]         }, condition = base::local({
[17:03:39.700]             c <- base::c
[17:03:39.700]             inherits <- base::inherits
[17:03:39.700]             invokeRestart <- base::invokeRestart
[17:03:39.700]             length <- base::length
[17:03:39.700]             list <- base::list
[17:03:39.700]             seq.int <- base::seq.int
[17:03:39.700]             signalCondition <- base::signalCondition
[17:03:39.700]             sys.calls <- base::sys.calls
[17:03:39.700]             `[[` <- base::`[[`
[17:03:39.700]             `+` <- base::`+`
[17:03:39.700]             `<<-` <- base::`<<-`
[17:03:39.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:39.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:39.700]                   3L)]
[17:03:39.700]             }
[17:03:39.700]             function(cond) {
[17:03:39.700]                 is_error <- inherits(cond, "error")
[17:03:39.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:39.700]                   NULL)
[17:03:39.700]                 if (is_error) {
[17:03:39.700]                   sessionInformation <- function() {
[17:03:39.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:39.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:39.700]                       search = base::search(), system = base::Sys.info())
[17:03:39.700]                   }
[17:03:39.700]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:39.700]                     cond$call), session = sessionInformation(), 
[17:03:39.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:39.700]                   signalCondition(cond)
[17:03:39.700]                 }
[17:03:39.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:39.700]                 "immediateCondition"))) {
[17:03:39.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:39.700]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:39.700]                   if (TRUE && !signal) {
[17:03:39.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.700]                     {
[17:03:39.700]                       inherits <- base::inherits
[17:03:39.700]                       invokeRestart <- base::invokeRestart
[17:03:39.700]                       is.null <- base::is.null
[17:03:39.700]                       muffled <- FALSE
[17:03:39.700]                       if (inherits(cond, "message")) {
[17:03:39.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.700]                         if (muffled) 
[17:03:39.700]                           invokeRestart("muffleMessage")
[17:03:39.700]                       }
[17:03:39.700]                       else if (inherits(cond, "warning")) {
[17:03:39.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.700]                         if (muffled) 
[17:03:39.700]                           invokeRestart("muffleWarning")
[17:03:39.700]                       }
[17:03:39.700]                       else if (inherits(cond, "condition")) {
[17:03:39.700]                         if (!is.null(pattern)) {
[17:03:39.700]                           computeRestarts <- base::computeRestarts
[17:03:39.700]                           grepl <- base::grepl
[17:03:39.700]                           restarts <- computeRestarts(cond)
[17:03:39.700]                           for (restart in restarts) {
[17:03:39.700]                             name <- restart$name
[17:03:39.700]                             if (is.null(name)) 
[17:03:39.700]                               next
[17:03:39.700]                             if (!grepl(pattern, name)) 
[17:03:39.700]                               next
[17:03:39.700]                             invokeRestart(restart)
[17:03:39.700]                             muffled <- TRUE
[17:03:39.700]                             break
[17:03:39.700]                           }
[17:03:39.700]                         }
[17:03:39.700]                       }
[17:03:39.700]                       invisible(muffled)
[17:03:39.700]                     }
[17:03:39.700]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.700]                   }
[17:03:39.700]                 }
[17:03:39.700]                 else {
[17:03:39.700]                   if (TRUE) {
[17:03:39.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.700]                     {
[17:03:39.700]                       inherits <- base::inherits
[17:03:39.700]                       invokeRestart <- base::invokeRestart
[17:03:39.700]                       is.null <- base::is.null
[17:03:39.700]                       muffled <- FALSE
[17:03:39.700]                       if (inherits(cond, "message")) {
[17:03:39.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.700]                         if (muffled) 
[17:03:39.700]                           invokeRestart("muffleMessage")
[17:03:39.700]                       }
[17:03:39.700]                       else if (inherits(cond, "warning")) {
[17:03:39.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.700]                         if (muffled) 
[17:03:39.700]                           invokeRestart("muffleWarning")
[17:03:39.700]                       }
[17:03:39.700]                       else if (inherits(cond, "condition")) {
[17:03:39.700]                         if (!is.null(pattern)) {
[17:03:39.700]                           computeRestarts <- base::computeRestarts
[17:03:39.700]                           grepl <- base::grepl
[17:03:39.700]                           restarts <- computeRestarts(cond)
[17:03:39.700]                           for (restart in restarts) {
[17:03:39.700]                             name <- restart$name
[17:03:39.700]                             if (is.null(name)) 
[17:03:39.700]                               next
[17:03:39.700]                             if (!grepl(pattern, name)) 
[17:03:39.700]                               next
[17:03:39.700]                             invokeRestart(restart)
[17:03:39.700]                             muffled <- TRUE
[17:03:39.700]                             break
[17:03:39.700]                           }
[17:03:39.700]                         }
[17:03:39.700]                       }
[17:03:39.700]                       invisible(muffled)
[17:03:39.700]                     }
[17:03:39.700]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.700]                   }
[17:03:39.700]                 }
[17:03:39.700]             }
[17:03:39.700]         }))
[17:03:39.700]     }, error = function(ex) {
[17:03:39.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:39.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.700]                 ...future.rng), started = ...future.startTime, 
[17:03:39.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:39.700]             version = "1.8"), class = "FutureResult")
[17:03:39.700]     }, finally = {
[17:03:39.700]         if (!identical(...future.workdir, getwd())) 
[17:03:39.700]             setwd(...future.workdir)
[17:03:39.700]         {
[17:03:39.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:39.700]                 ...future.oldOptions$nwarnings <- NULL
[17:03:39.700]             }
[17:03:39.700]             base::options(...future.oldOptions)
[17:03:39.700]             if (.Platform$OS.type == "windows") {
[17:03:39.700]                 old_names <- names(...future.oldEnvVars)
[17:03:39.700]                 envs <- base::Sys.getenv()
[17:03:39.700]                 names <- names(envs)
[17:03:39.700]                 common <- intersect(names, old_names)
[17:03:39.700]                 added <- setdiff(names, old_names)
[17:03:39.700]                 removed <- setdiff(old_names, names)
[17:03:39.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:39.700]                   envs[common]]
[17:03:39.700]                 NAMES <- toupper(changed)
[17:03:39.700]                 args <- list()
[17:03:39.700]                 for (kk in seq_along(NAMES)) {
[17:03:39.700]                   name <- changed[[kk]]
[17:03:39.700]                   NAME <- NAMES[[kk]]
[17:03:39.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.700]                     next
[17:03:39.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.700]                 }
[17:03:39.700]                 NAMES <- toupper(added)
[17:03:39.700]                 for (kk in seq_along(NAMES)) {
[17:03:39.700]                   name <- added[[kk]]
[17:03:39.700]                   NAME <- NAMES[[kk]]
[17:03:39.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.700]                     next
[17:03:39.700]                   args[[name]] <- ""
[17:03:39.700]                 }
[17:03:39.700]                 NAMES <- toupper(removed)
[17:03:39.700]                 for (kk in seq_along(NAMES)) {
[17:03:39.700]                   name <- removed[[kk]]
[17:03:39.700]                   NAME <- NAMES[[kk]]
[17:03:39.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.700]                     next
[17:03:39.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.700]                 }
[17:03:39.700]                 if (length(args) > 0) 
[17:03:39.700]                   base::do.call(base::Sys.setenv, args = args)
[17:03:39.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:39.700]             }
[17:03:39.700]             else {
[17:03:39.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:39.700]             }
[17:03:39.700]             {
[17:03:39.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:39.700]                   0L) {
[17:03:39.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:39.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:39.700]                   base::options(opts)
[17:03:39.700]                 }
[17:03:39.700]                 {
[17:03:39.700]                   {
[17:03:39.700]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:39.700]                     NULL
[17:03:39.700]                   }
[17:03:39.700]                   options(future.plan = NULL)
[17:03:39.700]                   if (is.na(NA_character_)) 
[17:03:39.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:39.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:39.700]                     .init = FALSE)
[17:03:39.700]                 }
[17:03:39.700]             }
[17:03:39.700]         }
[17:03:39.700]     })
[17:03:39.700]     if (TRUE) {
[17:03:39.700]         base::sink(type = "output", split = FALSE)
[17:03:39.700]         if (TRUE) {
[17:03:39.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:39.700]         }
[17:03:39.700]         else {
[17:03:39.700]             ...future.result["stdout"] <- base::list(NULL)
[17:03:39.700]         }
[17:03:39.700]         base::close(...future.stdout)
[17:03:39.700]         ...future.stdout <- NULL
[17:03:39.700]     }
[17:03:39.700]     ...future.result$conditions <- ...future.conditions
[17:03:39.700]     ...future.result$finished <- base::Sys.time()
[17:03:39.700]     ...future.result
[17:03:39.700] }
[17:03:39.703] assign_globals() ...
[17:03:39.704] List of 1
[17:03:39.704]  $ kk: int 1
[17:03:39.704]  - attr(*, "where")=List of 1
[17:03:39.704]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:39.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:39.704]  - attr(*, "resolved")= logi FALSE
[17:03:39.704]  - attr(*, "total_size")= num 56
[17:03:39.704]  - attr(*, "already-done")= logi TRUE
[17:03:39.707] - copied ‘kk’ to environment
[17:03:39.707] assign_globals() ... done
[17:03:39.710] requestCore(): workers = 2
[17:03:39.711] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:39.721] result() for MulticoreFuture ...
[17:03:39.723] result() for MulticoreFuture ...
[17:03:39.723] result() for MulticoreFuture ... done
[17:03:39.723] result() for MulticoreFuture ... done
[17:03:39.723] result() for MulticoreFuture ...
[17:03:39.724] result() for MulticoreFuture ... done
[17:03:39.727] MulticoreFuture started
[17:03:39.727] - Launch lazy future ... done
[17:03:39.728] run() for ‘MulticoreFuture’ ... done
[17:03:39.728] plan(): Setting new future strategy stack:
[17:03:39.728] List of future strategies:
[17:03:39.728] 1. sequential:
[17:03:39.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:39.728]    - tweaked: FALSE
[17:03:39.728]    - call: NULL
[17:03:39.730] plan(): nbrOfWorkers() = 1
[17:03:39.739] run() for ‘Future’ ...
[17:03:39.739] - state: ‘created’
[17:03:39.739] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:39.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:39.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:39.746]   - Field: ‘label’
[17:03:39.746]   - Field: ‘local’
[17:03:39.747]   - Field: ‘owner’
[17:03:39.747]   - Field: ‘envir’
[17:03:39.747]   - Field: ‘workers’
[17:03:39.747]   - Field: ‘packages’
[17:03:39.747]   - Field: ‘gc’
[17:03:39.747]   - Field: ‘job’
[17:03:39.748]   - Field: ‘conditions’
[17:03:39.748]   - Field: ‘expr’
[17:03:39.748]   - Field: ‘uuid’
[17:03:39.748]   - Field: ‘seed’
[17:03:39.748]   - Field: ‘version’
[17:03:39.748]   - Field: ‘result’
[17:03:39.749]   - Field: ‘asynchronous’
[17:03:39.749]   - Field: ‘calls’
[17:03:39.749]   - Field: ‘globals’
[17:03:39.749]   - Field: ‘stdout’
[17:03:39.749]   - Field: ‘earlySignal’
[17:03:39.749]   - Field: ‘lazy’
[17:03:39.750]   - Field: ‘state’
[17:03:39.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:39.750] - Launch lazy future ...
[17:03:39.750] Packages needed by the future expression (n = 0): <none>
[17:03:39.751] Packages needed by future strategies (n = 0): <none>
[17:03:39.751] {
[17:03:39.751]     {
[17:03:39.751]         {
[17:03:39.751]             ...future.startTime <- base::Sys.time()
[17:03:39.751]             {
[17:03:39.751]                 {
[17:03:39.751]                   {
[17:03:39.751]                     {
[17:03:39.751]                       base::local({
[17:03:39.751]                         has_future <- base::requireNamespace("future", 
[17:03:39.751]                           quietly = TRUE)
[17:03:39.751]                         if (has_future) {
[17:03:39.751]                           ns <- base::getNamespace("future")
[17:03:39.751]                           version <- ns[[".package"]][["version"]]
[17:03:39.751]                           if (is.null(version)) 
[17:03:39.751]                             version <- utils::packageVersion("future")
[17:03:39.751]                         }
[17:03:39.751]                         else {
[17:03:39.751]                           version <- NULL
[17:03:39.751]                         }
[17:03:39.751]                         if (!has_future || version < "1.8.0") {
[17:03:39.751]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:39.751]                             "", base::R.version$version.string), 
[17:03:39.751]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:39.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:39.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:39.751]                               "release", "version")], collapse = " "), 
[17:03:39.751]                             hostname = base::Sys.info()[["nodename"]])
[17:03:39.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:39.751]                             info)
[17:03:39.751]                           info <- base::paste(info, collapse = "; ")
[17:03:39.751]                           if (!has_future) {
[17:03:39.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:39.751]                               info)
[17:03:39.751]                           }
[17:03:39.751]                           else {
[17:03:39.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:39.751]                               info, version)
[17:03:39.751]                           }
[17:03:39.751]                           base::stop(msg)
[17:03:39.751]                         }
[17:03:39.751]                       })
[17:03:39.751]                     }
[17:03:39.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:39.751]                     base::options(mc.cores = 1L)
[17:03:39.751]                   }
[17:03:39.751]                   ...future.strategy.old <- future::plan("list")
[17:03:39.751]                   options(future.plan = NULL)
[17:03:39.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:39.751]                 }
[17:03:39.751]                 ...future.workdir <- getwd()
[17:03:39.751]             }
[17:03:39.751]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:39.751]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:39.751]         }
[17:03:39.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:39.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:39.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:39.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:39.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:39.751]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:39.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:39.751]             base::names(...future.oldOptions))
[17:03:39.751]     }
[17:03:39.751]     if (FALSE) {
[17:03:39.751]     }
[17:03:39.751]     else {
[17:03:39.751]         if (TRUE) {
[17:03:39.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:39.751]                 open = "w")
[17:03:39.751]         }
[17:03:39.751]         else {
[17:03:39.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:39.751]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:39.751]         }
[17:03:39.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:39.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:39.751]             base::sink(type = "output", split = FALSE)
[17:03:39.751]             base::close(...future.stdout)
[17:03:39.751]         }, add = TRUE)
[17:03:39.751]     }
[17:03:39.751]     ...future.frame <- base::sys.nframe()
[17:03:39.751]     ...future.conditions <- base::list()
[17:03:39.751]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:39.751]     if (FALSE) {
[17:03:39.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:39.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:39.751]     }
[17:03:39.751]     ...future.result <- base::tryCatch({
[17:03:39.751]         base::withCallingHandlers({
[17:03:39.751]             ...future.value <- base::withVisible(base::local({
[17:03:39.751]                 withCallingHandlers({
[17:03:39.751]                   {
[17:03:39.751]                     Sys.sleep(0.1)
[17:03:39.751]                     kk
[17:03:39.751]                   }
[17:03:39.751]                 }, immediateCondition = function(cond) {
[17:03:39.751]                   save_rds <- function (object, pathname, ...) 
[17:03:39.751]                   {
[17:03:39.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:39.751]                     if (file_test("-f", pathname_tmp)) {
[17:03:39.751]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:39.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.751]                         fi_tmp[["mtime"]])
[17:03:39.751]                     }
[17:03:39.751]                     tryCatch({
[17:03:39.751]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:39.751]                     }, error = function(ex) {
[17:03:39.751]                       msg <- conditionMessage(ex)
[17:03:39.751]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:39.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.751]                         fi_tmp[["mtime"]], msg)
[17:03:39.751]                       ex$message <- msg
[17:03:39.751]                       stop(ex)
[17:03:39.751]                     })
[17:03:39.751]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:39.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:39.751]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:39.751]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.751]                       fi <- file.info(pathname)
[17:03:39.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:39.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:39.751]                         fi[["size"]], fi[["mtime"]])
[17:03:39.751]                       stop(msg)
[17:03:39.751]                     }
[17:03:39.751]                     invisible(pathname)
[17:03:39.751]                   }
[17:03:39.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:39.751]                     rootPath = tempdir()) 
[17:03:39.751]                   {
[17:03:39.751]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:39.751]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:39.751]                       tmpdir = path, fileext = ".rds")
[17:03:39.751]                     save_rds(obj, file)
[17:03:39.751]                   }
[17:03:39.751]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:39.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.751]                   {
[17:03:39.751]                     inherits <- base::inherits
[17:03:39.751]                     invokeRestart <- base::invokeRestart
[17:03:39.751]                     is.null <- base::is.null
[17:03:39.751]                     muffled <- FALSE
[17:03:39.751]                     if (inherits(cond, "message")) {
[17:03:39.751]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:39.751]                       if (muffled) 
[17:03:39.751]                         invokeRestart("muffleMessage")
[17:03:39.751]                     }
[17:03:39.751]                     else if (inherits(cond, "warning")) {
[17:03:39.751]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:39.751]                       if (muffled) 
[17:03:39.751]                         invokeRestart("muffleWarning")
[17:03:39.751]                     }
[17:03:39.751]                     else if (inherits(cond, "condition")) {
[17:03:39.751]                       if (!is.null(pattern)) {
[17:03:39.751]                         computeRestarts <- base::computeRestarts
[17:03:39.751]                         grepl <- base::grepl
[17:03:39.751]                         restarts <- computeRestarts(cond)
[17:03:39.751]                         for (restart in restarts) {
[17:03:39.751]                           name <- restart$name
[17:03:39.751]                           if (is.null(name)) 
[17:03:39.751]                             next
[17:03:39.751]                           if (!grepl(pattern, name)) 
[17:03:39.751]                             next
[17:03:39.751]                           invokeRestart(restart)
[17:03:39.751]                           muffled <- TRUE
[17:03:39.751]                           break
[17:03:39.751]                         }
[17:03:39.751]                       }
[17:03:39.751]                     }
[17:03:39.751]                     invisible(muffled)
[17:03:39.751]                   }
[17:03:39.751]                   muffleCondition(cond)
[17:03:39.751]                 })
[17:03:39.751]             }))
[17:03:39.751]             future::FutureResult(value = ...future.value$value, 
[17:03:39.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.751]                   ...future.rng), globalenv = if (FALSE) 
[17:03:39.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:39.751]                     ...future.globalenv.names))
[17:03:39.751]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:39.751]         }, condition = base::local({
[17:03:39.751]             c <- base::c
[17:03:39.751]             inherits <- base::inherits
[17:03:39.751]             invokeRestart <- base::invokeRestart
[17:03:39.751]             length <- base::length
[17:03:39.751]             list <- base::list
[17:03:39.751]             seq.int <- base::seq.int
[17:03:39.751]             signalCondition <- base::signalCondition
[17:03:39.751]             sys.calls <- base::sys.calls
[17:03:39.751]             `[[` <- base::`[[`
[17:03:39.751]             `+` <- base::`+`
[17:03:39.751]             `<<-` <- base::`<<-`
[17:03:39.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:39.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:39.751]                   3L)]
[17:03:39.751]             }
[17:03:39.751]             function(cond) {
[17:03:39.751]                 is_error <- inherits(cond, "error")
[17:03:39.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:39.751]                   NULL)
[17:03:39.751]                 if (is_error) {
[17:03:39.751]                   sessionInformation <- function() {
[17:03:39.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:39.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:39.751]                       search = base::search(), system = base::Sys.info())
[17:03:39.751]                   }
[17:03:39.751]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:39.751]                     cond$call), session = sessionInformation(), 
[17:03:39.751]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:39.751]                   signalCondition(cond)
[17:03:39.751]                 }
[17:03:39.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:39.751]                 "immediateCondition"))) {
[17:03:39.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:39.751]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:39.751]                   if (TRUE && !signal) {
[17:03:39.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.751]                     {
[17:03:39.751]                       inherits <- base::inherits
[17:03:39.751]                       invokeRestart <- base::invokeRestart
[17:03:39.751]                       is.null <- base::is.null
[17:03:39.751]                       muffled <- FALSE
[17:03:39.751]                       if (inherits(cond, "message")) {
[17:03:39.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.751]                         if (muffled) 
[17:03:39.751]                           invokeRestart("muffleMessage")
[17:03:39.751]                       }
[17:03:39.751]                       else if (inherits(cond, "warning")) {
[17:03:39.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.751]                         if (muffled) 
[17:03:39.751]                           invokeRestart("muffleWarning")
[17:03:39.751]                       }
[17:03:39.751]                       else if (inherits(cond, "condition")) {
[17:03:39.751]                         if (!is.null(pattern)) {
[17:03:39.751]                           computeRestarts <- base::computeRestarts
[17:03:39.751]                           grepl <- base::grepl
[17:03:39.751]                           restarts <- computeRestarts(cond)
[17:03:39.751]                           for (restart in restarts) {
[17:03:39.751]                             name <- restart$name
[17:03:39.751]                             if (is.null(name)) 
[17:03:39.751]                               next
[17:03:39.751]                             if (!grepl(pattern, name)) 
[17:03:39.751]                               next
[17:03:39.751]                             invokeRestart(restart)
[17:03:39.751]                             muffled <- TRUE
[17:03:39.751]                             break
[17:03:39.751]                           }
[17:03:39.751]                         }
[17:03:39.751]                       }
[17:03:39.751]                       invisible(muffled)
[17:03:39.751]                     }
[17:03:39.751]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.751]                   }
[17:03:39.751]                 }
[17:03:39.751]                 else {
[17:03:39.751]                   if (TRUE) {
[17:03:39.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.751]                     {
[17:03:39.751]                       inherits <- base::inherits
[17:03:39.751]                       invokeRestart <- base::invokeRestart
[17:03:39.751]                       is.null <- base::is.null
[17:03:39.751]                       muffled <- FALSE
[17:03:39.751]                       if (inherits(cond, "message")) {
[17:03:39.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.751]                         if (muffled) 
[17:03:39.751]                           invokeRestart("muffleMessage")
[17:03:39.751]                       }
[17:03:39.751]                       else if (inherits(cond, "warning")) {
[17:03:39.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.751]                         if (muffled) 
[17:03:39.751]                           invokeRestart("muffleWarning")
[17:03:39.751]                       }
[17:03:39.751]                       else if (inherits(cond, "condition")) {
[17:03:39.751]                         if (!is.null(pattern)) {
[17:03:39.751]                           computeRestarts <- base::computeRestarts
[17:03:39.751]                           grepl <- base::grepl
[17:03:39.751]                           restarts <- computeRestarts(cond)
[17:03:39.751]                           for (restart in restarts) {
[17:03:39.751]                             name <- restart$name
[17:03:39.751]                             if (is.null(name)) 
[17:03:39.751]                               next
[17:03:39.751]                             if (!grepl(pattern, name)) 
[17:03:39.751]                               next
[17:03:39.751]                             invokeRestart(restart)
[17:03:39.751]                             muffled <- TRUE
[17:03:39.751]                             break
[17:03:39.751]                           }
[17:03:39.751]                         }
[17:03:39.751]                       }
[17:03:39.751]                       invisible(muffled)
[17:03:39.751]                     }
[17:03:39.751]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.751]                   }
[17:03:39.751]                 }
[17:03:39.751]             }
[17:03:39.751]         }))
[17:03:39.751]     }, error = function(ex) {
[17:03:39.751]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:39.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.751]                 ...future.rng), started = ...future.startTime, 
[17:03:39.751]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:39.751]             version = "1.8"), class = "FutureResult")
[17:03:39.751]     }, finally = {
[17:03:39.751]         if (!identical(...future.workdir, getwd())) 
[17:03:39.751]             setwd(...future.workdir)
[17:03:39.751]         {
[17:03:39.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:39.751]                 ...future.oldOptions$nwarnings <- NULL
[17:03:39.751]             }
[17:03:39.751]             base::options(...future.oldOptions)
[17:03:39.751]             if (.Platform$OS.type == "windows") {
[17:03:39.751]                 old_names <- names(...future.oldEnvVars)
[17:03:39.751]                 envs <- base::Sys.getenv()
[17:03:39.751]                 names <- names(envs)
[17:03:39.751]                 common <- intersect(names, old_names)
[17:03:39.751]                 added <- setdiff(names, old_names)
[17:03:39.751]                 removed <- setdiff(old_names, names)
[17:03:39.751]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:39.751]                   envs[common]]
[17:03:39.751]                 NAMES <- toupper(changed)
[17:03:39.751]                 args <- list()
[17:03:39.751]                 for (kk in seq_along(NAMES)) {
[17:03:39.751]                   name <- changed[[kk]]
[17:03:39.751]                   NAME <- NAMES[[kk]]
[17:03:39.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.751]                     next
[17:03:39.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.751]                 }
[17:03:39.751]                 NAMES <- toupper(added)
[17:03:39.751]                 for (kk in seq_along(NAMES)) {
[17:03:39.751]                   name <- added[[kk]]
[17:03:39.751]                   NAME <- NAMES[[kk]]
[17:03:39.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.751]                     next
[17:03:39.751]                   args[[name]] <- ""
[17:03:39.751]                 }
[17:03:39.751]                 NAMES <- toupper(removed)
[17:03:39.751]                 for (kk in seq_along(NAMES)) {
[17:03:39.751]                   name <- removed[[kk]]
[17:03:39.751]                   NAME <- NAMES[[kk]]
[17:03:39.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.751]                     next
[17:03:39.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.751]                 }
[17:03:39.751]                 if (length(args) > 0) 
[17:03:39.751]                   base::do.call(base::Sys.setenv, args = args)
[17:03:39.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:39.751]             }
[17:03:39.751]             else {
[17:03:39.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:39.751]             }
[17:03:39.751]             {
[17:03:39.751]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:39.751]                   0L) {
[17:03:39.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:39.751]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:39.751]                   base::options(opts)
[17:03:39.751]                 }
[17:03:39.751]                 {
[17:03:39.751]                   {
[17:03:39.751]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:39.751]                     NULL
[17:03:39.751]                   }
[17:03:39.751]                   options(future.plan = NULL)
[17:03:39.751]                   if (is.na(NA_character_)) 
[17:03:39.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:39.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:39.751]                     .init = FALSE)
[17:03:39.751]                 }
[17:03:39.751]             }
[17:03:39.751]         }
[17:03:39.751]     })
[17:03:39.751]     if (TRUE) {
[17:03:39.751]         base::sink(type = "output", split = FALSE)
[17:03:39.751]         if (TRUE) {
[17:03:39.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:39.751]         }
[17:03:39.751]         else {
[17:03:39.751]             ...future.result["stdout"] <- base::list(NULL)
[17:03:39.751]         }
[17:03:39.751]         base::close(...future.stdout)
[17:03:39.751]         ...future.stdout <- NULL
[17:03:39.751]     }
[17:03:39.751]     ...future.result$conditions <- ...future.conditions
[17:03:39.751]     ...future.result$finished <- base::Sys.time()
[17:03:39.751]     ...future.result
[17:03:39.751] }
[17:03:39.755] assign_globals() ...
[17:03:39.755] List of 1
[17:03:39.755]  $ kk: int 2
[17:03:39.755]  - attr(*, "where")=List of 1
[17:03:39.755]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:39.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:39.755]  - attr(*, "resolved")= logi FALSE
[17:03:39.755]  - attr(*, "total_size")= num 56
[17:03:39.755]  - attr(*, "already-done")= logi TRUE
[17:03:39.759] - copied ‘kk’ to environment
[17:03:39.759] assign_globals() ... done
[17:03:39.759] requestCore(): workers = 2
[17:03:39.760] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:39.771] result() for MulticoreFuture ...
[17:03:39.771] result() for MulticoreFuture ...
[17:03:39.772] result() for MulticoreFuture ... done
[17:03:39.772] result() for MulticoreFuture ... done
[17:03:39.772] result() for MulticoreFuture ...
[17:03:39.772] result() for MulticoreFuture ... done
[17:03:39.774] MulticoreFuture started
[17:03:39.775] - Launch lazy future ... done
[17:03:39.775] run() for ‘MulticoreFuture’ ... done
[17:03:39.776] plan(): Setting new future strategy stack:
[17:03:39.776] List of future strategies:
[17:03:39.776] 1. sequential:
[17:03:39.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:39.776]    - tweaked: FALSE
[17:03:39.776]    - call: NULL
[17:03:39.777] plan(): nbrOfWorkers() = 1
[17:03:39.786] run() for ‘Future’ ...
[17:03:39.786] - state: ‘created’
[17:03:39.787] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:39.792] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:39.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:39.792]   - Field: ‘label’
[17:03:39.793]   - Field: ‘local’
[17:03:39.793]   - Field: ‘owner’
[17:03:39.793]   - Field: ‘envir’
[17:03:39.793]   - Field: ‘workers’
[17:03:39.793]   - Field: ‘packages’
[17:03:39.793]   - Field: ‘gc’
[17:03:39.793]   - Field: ‘job’
[17:03:39.794]   - Field: ‘conditions’
[17:03:39.794]   - Field: ‘expr’
[17:03:39.794]   - Field: ‘uuid’
[17:03:39.794]   - Field: ‘seed’
[17:03:39.794]   - Field: ‘version’
[17:03:39.794]   - Field: ‘result’
[17:03:39.794]   - Field: ‘asynchronous’
[17:03:39.795]   - Field: ‘calls’
[17:03:39.795]   - Field: ‘globals’
[17:03:39.795]   - Field: ‘stdout’
[17:03:39.795]   - Field: ‘earlySignal’
[17:03:39.795]   - Field: ‘lazy’
[17:03:39.795]   - Field: ‘state’
[17:03:39.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:39.796] - Launch lazy future ...
[17:03:39.796] Packages needed by the future expression (n = 0): <none>
[17:03:39.796] Packages needed by future strategies (n = 0): <none>
[17:03:39.797] {
[17:03:39.797]     {
[17:03:39.797]         {
[17:03:39.797]             ...future.startTime <- base::Sys.time()
[17:03:39.797]             {
[17:03:39.797]                 {
[17:03:39.797]                   {
[17:03:39.797]                     {
[17:03:39.797]                       base::local({
[17:03:39.797]                         has_future <- base::requireNamespace("future", 
[17:03:39.797]                           quietly = TRUE)
[17:03:39.797]                         if (has_future) {
[17:03:39.797]                           ns <- base::getNamespace("future")
[17:03:39.797]                           version <- ns[[".package"]][["version"]]
[17:03:39.797]                           if (is.null(version)) 
[17:03:39.797]                             version <- utils::packageVersion("future")
[17:03:39.797]                         }
[17:03:39.797]                         else {
[17:03:39.797]                           version <- NULL
[17:03:39.797]                         }
[17:03:39.797]                         if (!has_future || version < "1.8.0") {
[17:03:39.797]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:39.797]                             "", base::R.version$version.string), 
[17:03:39.797]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:39.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:39.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:39.797]                               "release", "version")], collapse = " "), 
[17:03:39.797]                             hostname = base::Sys.info()[["nodename"]])
[17:03:39.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:39.797]                             info)
[17:03:39.797]                           info <- base::paste(info, collapse = "; ")
[17:03:39.797]                           if (!has_future) {
[17:03:39.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:39.797]                               info)
[17:03:39.797]                           }
[17:03:39.797]                           else {
[17:03:39.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:39.797]                               info, version)
[17:03:39.797]                           }
[17:03:39.797]                           base::stop(msg)
[17:03:39.797]                         }
[17:03:39.797]                       })
[17:03:39.797]                     }
[17:03:39.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:39.797]                     base::options(mc.cores = 1L)
[17:03:39.797]                   }
[17:03:39.797]                   ...future.strategy.old <- future::plan("list")
[17:03:39.797]                   options(future.plan = NULL)
[17:03:39.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:39.797]                 }
[17:03:39.797]                 ...future.workdir <- getwd()
[17:03:39.797]             }
[17:03:39.797]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:39.797]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:39.797]         }
[17:03:39.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:39.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:39.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:39.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:39.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:39.797]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:39.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:39.797]             base::names(...future.oldOptions))
[17:03:39.797]     }
[17:03:39.797]     if (FALSE) {
[17:03:39.797]     }
[17:03:39.797]     else {
[17:03:39.797]         if (TRUE) {
[17:03:39.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:39.797]                 open = "w")
[17:03:39.797]         }
[17:03:39.797]         else {
[17:03:39.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:39.797]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:39.797]         }
[17:03:39.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:39.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:39.797]             base::sink(type = "output", split = FALSE)
[17:03:39.797]             base::close(...future.stdout)
[17:03:39.797]         }, add = TRUE)
[17:03:39.797]     }
[17:03:39.797]     ...future.frame <- base::sys.nframe()
[17:03:39.797]     ...future.conditions <- base::list()
[17:03:39.797]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:39.797]     if (FALSE) {
[17:03:39.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:39.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:39.797]     }
[17:03:39.797]     ...future.result <- base::tryCatch({
[17:03:39.797]         base::withCallingHandlers({
[17:03:39.797]             ...future.value <- base::withVisible(base::local({
[17:03:39.797]                 withCallingHandlers({
[17:03:39.797]                   {
[17:03:39.797]                     Sys.sleep(0.1)
[17:03:39.797]                     kk
[17:03:39.797]                   }
[17:03:39.797]                 }, immediateCondition = function(cond) {
[17:03:39.797]                   save_rds <- function (object, pathname, ...) 
[17:03:39.797]                   {
[17:03:39.797]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:39.797]                     if (file_test("-f", pathname_tmp)) {
[17:03:39.797]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.797]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:39.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.797]                         fi_tmp[["mtime"]])
[17:03:39.797]                     }
[17:03:39.797]                     tryCatch({
[17:03:39.797]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:39.797]                     }, error = function(ex) {
[17:03:39.797]                       msg <- conditionMessage(ex)
[17:03:39.797]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.797]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:39.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.797]                         fi_tmp[["mtime"]], msg)
[17:03:39.797]                       ex$message <- msg
[17:03:39.797]                       stop(ex)
[17:03:39.797]                     })
[17:03:39.797]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:39.797]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:39.797]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:39.797]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.797]                       fi <- file.info(pathname)
[17:03:39.797]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:39.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.797]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:39.797]                         fi[["size"]], fi[["mtime"]])
[17:03:39.797]                       stop(msg)
[17:03:39.797]                     }
[17:03:39.797]                     invisible(pathname)
[17:03:39.797]                   }
[17:03:39.797]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:39.797]                     rootPath = tempdir()) 
[17:03:39.797]                   {
[17:03:39.797]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:39.797]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:39.797]                       tmpdir = path, fileext = ".rds")
[17:03:39.797]                     save_rds(obj, file)
[17:03:39.797]                   }
[17:03:39.797]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:39.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.797]                   {
[17:03:39.797]                     inherits <- base::inherits
[17:03:39.797]                     invokeRestart <- base::invokeRestart
[17:03:39.797]                     is.null <- base::is.null
[17:03:39.797]                     muffled <- FALSE
[17:03:39.797]                     if (inherits(cond, "message")) {
[17:03:39.797]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:39.797]                       if (muffled) 
[17:03:39.797]                         invokeRestart("muffleMessage")
[17:03:39.797]                     }
[17:03:39.797]                     else if (inherits(cond, "warning")) {
[17:03:39.797]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:39.797]                       if (muffled) 
[17:03:39.797]                         invokeRestart("muffleWarning")
[17:03:39.797]                     }
[17:03:39.797]                     else if (inherits(cond, "condition")) {
[17:03:39.797]                       if (!is.null(pattern)) {
[17:03:39.797]                         computeRestarts <- base::computeRestarts
[17:03:39.797]                         grepl <- base::grepl
[17:03:39.797]                         restarts <- computeRestarts(cond)
[17:03:39.797]                         for (restart in restarts) {
[17:03:39.797]                           name <- restart$name
[17:03:39.797]                           if (is.null(name)) 
[17:03:39.797]                             next
[17:03:39.797]                           if (!grepl(pattern, name)) 
[17:03:39.797]                             next
[17:03:39.797]                           invokeRestart(restart)
[17:03:39.797]                           muffled <- TRUE
[17:03:39.797]                           break
[17:03:39.797]                         }
[17:03:39.797]                       }
[17:03:39.797]                     }
[17:03:39.797]                     invisible(muffled)
[17:03:39.797]                   }
[17:03:39.797]                   muffleCondition(cond)
[17:03:39.797]                 })
[17:03:39.797]             }))
[17:03:39.797]             future::FutureResult(value = ...future.value$value, 
[17:03:39.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.797]                   ...future.rng), globalenv = if (FALSE) 
[17:03:39.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:39.797]                     ...future.globalenv.names))
[17:03:39.797]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:39.797]         }, condition = base::local({
[17:03:39.797]             c <- base::c
[17:03:39.797]             inherits <- base::inherits
[17:03:39.797]             invokeRestart <- base::invokeRestart
[17:03:39.797]             length <- base::length
[17:03:39.797]             list <- base::list
[17:03:39.797]             seq.int <- base::seq.int
[17:03:39.797]             signalCondition <- base::signalCondition
[17:03:39.797]             sys.calls <- base::sys.calls
[17:03:39.797]             `[[` <- base::`[[`
[17:03:39.797]             `+` <- base::`+`
[17:03:39.797]             `<<-` <- base::`<<-`
[17:03:39.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:39.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:39.797]                   3L)]
[17:03:39.797]             }
[17:03:39.797]             function(cond) {
[17:03:39.797]                 is_error <- inherits(cond, "error")
[17:03:39.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:39.797]                   NULL)
[17:03:39.797]                 if (is_error) {
[17:03:39.797]                   sessionInformation <- function() {
[17:03:39.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:39.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:39.797]                       search = base::search(), system = base::Sys.info())
[17:03:39.797]                   }
[17:03:39.797]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:39.797]                     cond$call), session = sessionInformation(), 
[17:03:39.797]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:39.797]                   signalCondition(cond)
[17:03:39.797]                 }
[17:03:39.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:39.797]                 "immediateCondition"))) {
[17:03:39.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:39.797]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:39.797]                   if (TRUE && !signal) {
[17:03:39.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.797]                     {
[17:03:39.797]                       inherits <- base::inherits
[17:03:39.797]                       invokeRestart <- base::invokeRestart
[17:03:39.797]                       is.null <- base::is.null
[17:03:39.797]                       muffled <- FALSE
[17:03:39.797]                       if (inherits(cond, "message")) {
[17:03:39.797]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.797]                         if (muffled) 
[17:03:39.797]                           invokeRestart("muffleMessage")
[17:03:39.797]                       }
[17:03:39.797]                       else if (inherits(cond, "warning")) {
[17:03:39.797]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.797]                         if (muffled) 
[17:03:39.797]                           invokeRestart("muffleWarning")
[17:03:39.797]                       }
[17:03:39.797]                       else if (inherits(cond, "condition")) {
[17:03:39.797]                         if (!is.null(pattern)) {
[17:03:39.797]                           computeRestarts <- base::computeRestarts
[17:03:39.797]                           grepl <- base::grepl
[17:03:39.797]                           restarts <- computeRestarts(cond)
[17:03:39.797]                           for (restart in restarts) {
[17:03:39.797]                             name <- restart$name
[17:03:39.797]                             if (is.null(name)) 
[17:03:39.797]                               next
[17:03:39.797]                             if (!grepl(pattern, name)) 
[17:03:39.797]                               next
[17:03:39.797]                             invokeRestart(restart)
[17:03:39.797]                             muffled <- TRUE
[17:03:39.797]                             break
[17:03:39.797]                           }
[17:03:39.797]                         }
[17:03:39.797]                       }
[17:03:39.797]                       invisible(muffled)
[17:03:39.797]                     }
[17:03:39.797]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.797]                   }
[17:03:39.797]                 }
[17:03:39.797]                 else {
[17:03:39.797]                   if (TRUE) {
[17:03:39.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.797]                     {
[17:03:39.797]                       inherits <- base::inherits
[17:03:39.797]                       invokeRestart <- base::invokeRestart
[17:03:39.797]                       is.null <- base::is.null
[17:03:39.797]                       muffled <- FALSE
[17:03:39.797]                       if (inherits(cond, "message")) {
[17:03:39.797]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.797]                         if (muffled) 
[17:03:39.797]                           invokeRestart("muffleMessage")
[17:03:39.797]                       }
[17:03:39.797]                       else if (inherits(cond, "warning")) {
[17:03:39.797]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.797]                         if (muffled) 
[17:03:39.797]                           invokeRestart("muffleWarning")
[17:03:39.797]                       }
[17:03:39.797]                       else if (inherits(cond, "condition")) {
[17:03:39.797]                         if (!is.null(pattern)) {
[17:03:39.797]                           computeRestarts <- base::computeRestarts
[17:03:39.797]                           grepl <- base::grepl
[17:03:39.797]                           restarts <- computeRestarts(cond)
[17:03:39.797]                           for (restart in restarts) {
[17:03:39.797]                             name <- restart$name
[17:03:39.797]                             if (is.null(name)) 
[17:03:39.797]                               next
[17:03:39.797]                             if (!grepl(pattern, name)) 
[17:03:39.797]                               next
[17:03:39.797]                             invokeRestart(restart)
[17:03:39.797]                             muffled <- TRUE
[17:03:39.797]                             break
[17:03:39.797]                           }
[17:03:39.797]                         }
[17:03:39.797]                       }
[17:03:39.797]                       invisible(muffled)
[17:03:39.797]                     }
[17:03:39.797]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.797]                   }
[17:03:39.797]                 }
[17:03:39.797]             }
[17:03:39.797]         }))
[17:03:39.797]     }, error = function(ex) {
[17:03:39.797]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:39.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.797]                 ...future.rng), started = ...future.startTime, 
[17:03:39.797]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:39.797]             version = "1.8"), class = "FutureResult")
[17:03:39.797]     }, finally = {
[17:03:39.797]         if (!identical(...future.workdir, getwd())) 
[17:03:39.797]             setwd(...future.workdir)
[17:03:39.797]         {
[17:03:39.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:39.797]                 ...future.oldOptions$nwarnings <- NULL
[17:03:39.797]             }
[17:03:39.797]             base::options(...future.oldOptions)
[17:03:39.797]             if (.Platform$OS.type == "windows") {
[17:03:39.797]                 old_names <- names(...future.oldEnvVars)
[17:03:39.797]                 envs <- base::Sys.getenv()
[17:03:39.797]                 names <- names(envs)
[17:03:39.797]                 common <- intersect(names, old_names)
[17:03:39.797]                 added <- setdiff(names, old_names)
[17:03:39.797]                 removed <- setdiff(old_names, names)
[17:03:39.797]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:39.797]                   envs[common]]
[17:03:39.797]                 NAMES <- toupper(changed)
[17:03:39.797]                 args <- list()
[17:03:39.797]                 for (kk in seq_along(NAMES)) {
[17:03:39.797]                   name <- changed[[kk]]
[17:03:39.797]                   NAME <- NAMES[[kk]]
[17:03:39.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.797]                     next
[17:03:39.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.797]                 }
[17:03:39.797]                 NAMES <- toupper(added)
[17:03:39.797]                 for (kk in seq_along(NAMES)) {
[17:03:39.797]                   name <- added[[kk]]
[17:03:39.797]                   NAME <- NAMES[[kk]]
[17:03:39.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.797]                     next
[17:03:39.797]                   args[[name]] <- ""
[17:03:39.797]                 }
[17:03:39.797]                 NAMES <- toupper(removed)
[17:03:39.797]                 for (kk in seq_along(NAMES)) {
[17:03:39.797]                   name <- removed[[kk]]
[17:03:39.797]                   NAME <- NAMES[[kk]]
[17:03:39.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.797]                     next
[17:03:39.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.797]                 }
[17:03:39.797]                 if (length(args) > 0) 
[17:03:39.797]                   base::do.call(base::Sys.setenv, args = args)
[17:03:39.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:39.797]             }
[17:03:39.797]             else {
[17:03:39.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:39.797]             }
[17:03:39.797]             {
[17:03:39.797]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:39.797]                   0L) {
[17:03:39.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:39.797]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:39.797]                   base::options(opts)
[17:03:39.797]                 }
[17:03:39.797]                 {
[17:03:39.797]                   {
[17:03:39.797]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:39.797]                     NULL
[17:03:39.797]                   }
[17:03:39.797]                   options(future.plan = NULL)
[17:03:39.797]                   if (is.na(NA_character_)) 
[17:03:39.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:39.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:39.797]                     .init = FALSE)
[17:03:39.797]                 }
[17:03:39.797]             }
[17:03:39.797]         }
[17:03:39.797]     })
[17:03:39.797]     if (TRUE) {
[17:03:39.797]         base::sink(type = "output", split = FALSE)
[17:03:39.797]         if (TRUE) {
[17:03:39.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:39.797]         }
[17:03:39.797]         else {
[17:03:39.797]             ...future.result["stdout"] <- base::list(NULL)
[17:03:39.797]         }
[17:03:39.797]         base::close(...future.stdout)
[17:03:39.797]         ...future.stdout <- NULL
[17:03:39.797]     }
[17:03:39.797]     ...future.result$conditions <- ...future.conditions
[17:03:39.797]     ...future.result$finished <- base::Sys.time()
[17:03:39.797]     ...future.result
[17:03:39.797] }
[17:03:39.801] assign_globals() ...
[17:03:39.801] List of 1
[17:03:39.801]  $ kk: int 3
[17:03:39.801]  - attr(*, "where")=List of 1
[17:03:39.801]   ..$ kk:<environment: R_EmptyEnv> 
[17:03:39.801]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:03:39.801]  - attr(*, "resolved")= logi FALSE
[17:03:39.801]  - attr(*, "total_size")= num 56
[17:03:39.801]  - attr(*, "already-done")= logi TRUE
[17:03:39.805] - copied ‘kk’ to environment
[17:03:39.805] assign_globals() ... done
[17:03:39.805] requestCore(): workers = 2
[17:03:39.806] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:39.832] plan(): Setting new future strategy stack:
[17:03:39.833] List of future strategies:
[17:03:39.833] 1. multicore:
[17:03:39.833]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:39.833]    - tweaked: FALSE
[17:03:39.833]    - call: plan(strategy)
[17:03:39.837] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:03:39.837] plan(): nbrOfWorkers() = 2
[17:03:39.848] result() for MulticoreFuture ...
[17:03:39.849] result() for MulticoreFuture ...
[17:03:39.849] result() for MulticoreFuture ... done
[17:03:39.849] result() for MulticoreFuture ... done
[17:03:39.849] result() for MulticoreFuture ...
[17:03:39.849] result() for MulticoreFuture ... done
[17:03:39.852] MulticoreFuture started
[17:03:39.852] - Launch lazy future ... done
[17:03:39.853] run() for ‘MulticoreFuture’ ... done
[17:03:39.853] plan(): Setting new future strategy stack:
[17:03:39.853] List of future strategies:
[17:03:39.853] 1. sequential:
[17:03:39.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:39.853]    - tweaked: FALSE
[17:03:39.853]    - call: NULL
[17:03:39.854] plan(): nbrOfWorkers() = 1
[17:03:39.874] Future #1
[17:03:39.874]  length: 2 (resolved future 1)
[17:03:39.880] plan(): Setting new future strategy stack:
[17:03:39.880] List of future strategies:
[17:03:39.880] 1. multicore:
[17:03:39.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:39.880]    - tweaked: FALSE
[17:03:39.880]    - call: plan(strategy)
[17:03:39.884] plan(): nbrOfWorkers() = 2
[17:03:39.905] Future #2
[17:03:39.905]  length: 1 (resolved future 2)
[17:03:39.957] plan(): Setting new future strategy stack:
[17:03:39.957] List of future strategies:
[17:03:39.957] 1. multicore:
[17:03:39.957]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:39.957]    - tweaked: FALSE
[17:03:39.957]    - call: plan(strategy)
[17:03:39.963] plan(): nbrOfWorkers() = 2
[17:03:39.967] Future #3
[17:03:39.967]  length: 0 (resolved future 3)
[17:03:39.967] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:03:39.969] resolve() on environment ...
[17:03:39.969]  recursive: 0
[17:03:39.970]  elements: [2] ‘a’, ‘b’
[17:03:39.970]  length: 1 (resolved future 1)
[17:03:39.974]  length: 0 (resolved future 2)
[17:03:39.974] resolve() on environment ... DONE
[17:03:39.976] getGlobalsAndPackages() ...
[17:03:39.976] Searching for globals...
[17:03:39.978] 
[17:03:39.978] Searching for globals ... DONE
[17:03:39.978] - globals: [0] <none>
[17:03:39.978] getGlobalsAndPackages() ... DONE
[17:03:39.979] run() for ‘Future’ ...
[17:03:39.980] - state: ‘created’
[17:03:39.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:39.985] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:39.985] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:39.985]   - Field: ‘label’
[17:03:39.985]   - Field: ‘local’
[17:03:39.986]   - Field: ‘owner’
[17:03:39.986]   - Field: ‘envir’
[17:03:39.986]   - Field: ‘workers’
[17:03:39.986]   - Field: ‘packages’
[17:03:39.986]   - Field: ‘gc’
[17:03:39.987]   - Field: ‘job’
[17:03:39.987]   - Field: ‘conditions’
[17:03:39.987]   - Field: ‘expr’
[17:03:39.987]   - Field: ‘uuid’
[17:03:39.987]   - Field: ‘seed’
[17:03:39.987]   - Field: ‘version’
[17:03:39.987]   - Field: ‘result’
[17:03:39.988]   - Field: ‘asynchronous’
[17:03:39.988]   - Field: ‘calls’
[17:03:39.988]   - Field: ‘globals’
[17:03:39.988]   - Field: ‘stdout’
[17:03:39.988]   - Field: ‘earlySignal’
[17:03:39.988]   - Field: ‘lazy’
[17:03:39.988]   - Field: ‘state’
[17:03:39.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:39.989] - Launch lazy future ...
[17:03:39.989] Packages needed by the future expression (n = 0): <none>
[17:03:39.989] Packages needed by future strategies (n = 0): <none>
[17:03:39.990] {
[17:03:39.990]     {
[17:03:39.990]         {
[17:03:39.990]             ...future.startTime <- base::Sys.time()
[17:03:39.990]             {
[17:03:39.990]                 {
[17:03:39.990]                   {
[17:03:39.990]                     {
[17:03:39.990]                       base::local({
[17:03:39.990]                         has_future <- base::requireNamespace("future", 
[17:03:39.990]                           quietly = TRUE)
[17:03:39.990]                         if (has_future) {
[17:03:39.990]                           ns <- base::getNamespace("future")
[17:03:39.990]                           version <- ns[[".package"]][["version"]]
[17:03:39.990]                           if (is.null(version)) 
[17:03:39.990]                             version <- utils::packageVersion("future")
[17:03:39.990]                         }
[17:03:39.990]                         else {
[17:03:39.990]                           version <- NULL
[17:03:39.990]                         }
[17:03:39.990]                         if (!has_future || version < "1.8.0") {
[17:03:39.990]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:39.990]                             "", base::R.version$version.string), 
[17:03:39.990]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:39.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:39.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:39.990]                               "release", "version")], collapse = " "), 
[17:03:39.990]                             hostname = base::Sys.info()[["nodename"]])
[17:03:39.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:39.990]                             info)
[17:03:39.990]                           info <- base::paste(info, collapse = "; ")
[17:03:39.990]                           if (!has_future) {
[17:03:39.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:39.990]                               info)
[17:03:39.990]                           }
[17:03:39.990]                           else {
[17:03:39.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:39.990]                               info, version)
[17:03:39.990]                           }
[17:03:39.990]                           base::stop(msg)
[17:03:39.990]                         }
[17:03:39.990]                       })
[17:03:39.990]                     }
[17:03:39.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:39.990]                     base::options(mc.cores = 1L)
[17:03:39.990]                   }
[17:03:39.990]                   ...future.strategy.old <- future::plan("list")
[17:03:39.990]                   options(future.plan = NULL)
[17:03:39.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:39.990]                 }
[17:03:39.990]                 ...future.workdir <- getwd()
[17:03:39.990]             }
[17:03:39.990]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:39.990]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:39.990]         }
[17:03:39.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:39.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:39.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:39.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:39.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:39.990]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:39.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:39.990]             base::names(...future.oldOptions))
[17:03:39.990]     }
[17:03:39.990]     if (FALSE) {
[17:03:39.990]     }
[17:03:39.990]     else {
[17:03:39.990]         if (TRUE) {
[17:03:39.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:39.990]                 open = "w")
[17:03:39.990]         }
[17:03:39.990]         else {
[17:03:39.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:39.990]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:39.990]         }
[17:03:39.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:39.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:39.990]             base::sink(type = "output", split = FALSE)
[17:03:39.990]             base::close(...future.stdout)
[17:03:39.990]         }, add = TRUE)
[17:03:39.990]     }
[17:03:39.990]     ...future.frame <- base::sys.nframe()
[17:03:39.990]     ...future.conditions <- base::list()
[17:03:39.990]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:39.990]     if (FALSE) {
[17:03:39.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:39.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:39.990]     }
[17:03:39.990]     ...future.result <- base::tryCatch({
[17:03:39.990]         base::withCallingHandlers({
[17:03:39.990]             ...future.value <- base::withVisible(base::local({
[17:03:39.990]                 withCallingHandlers({
[17:03:39.990]                   1
[17:03:39.990]                 }, immediateCondition = function(cond) {
[17:03:39.990]                   save_rds <- function (object, pathname, ...) 
[17:03:39.990]                   {
[17:03:39.990]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:39.990]                     if (file_test("-f", pathname_tmp)) {
[17:03:39.990]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.990]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:39.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.990]                         fi_tmp[["mtime"]])
[17:03:39.990]                     }
[17:03:39.990]                     tryCatch({
[17:03:39.990]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:39.990]                     }, error = function(ex) {
[17:03:39.990]                       msg <- conditionMessage(ex)
[17:03:39.990]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.990]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:39.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.990]                         fi_tmp[["mtime"]], msg)
[17:03:39.990]                       ex$message <- msg
[17:03:39.990]                       stop(ex)
[17:03:39.990]                     })
[17:03:39.990]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:39.990]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:39.990]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:39.990]                       fi_tmp <- file.info(pathname_tmp)
[17:03:39.990]                       fi <- file.info(pathname)
[17:03:39.990]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:39.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:39.990]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:39.990]                         fi[["size"]], fi[["mtime"]])
[17:03:39.990]                       stop(msg)
[17:03:39.990]                     }
[17:03:39.990]                     invisible(pathname)
[17:03:39.990]                   }
[17:03:39.990]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:39.990]                     rootPath = tempdir()) 
[17:03:39.990]                   {
[17:03:39.990]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:39.990]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:39.990]                       tmpdir = path, fileext = ".rds")
[17:03:39.990]                     save_rds(obj, file)
[17:03:39.990]                   }
[17:03:39.990]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:39.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.990]                   {
[17:03:39.990]                     inherits <- base::inherits
[17:03:39.990]                     invokeRestart <- base::invokeRestart
[17:03:39.990]                     is.null <- base::is.null
[17:03:39.990]                     muffled <- FALSE
[17:03:39.990]                     if (inherits(cond, "message")) {
[17:03:39.990]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:39.990]                       if (muffled) 
[17:03:39.990]                         invokeRestart("muffleMessage")
[17:03:39.990]                     }
[17:03:39.990]                     else if (inherits(cond, "warning")) {
[17:03:39.990]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:39.990]                       if (muffled) 
[17:03:39.990]                         invokeRestart("muffleWarning")
[17:03:39.990]                     }
[17:03:39.990]                     else if (inherits(cond, "condition")) {
[17:03:39.990]                       if (!is.null(pattern)) {
[17:03:39.990]                         computeRestarts <- base::computeRestarts
[17:03:39.990]                         grepl <- base::grepl
[17:03:39.990]                         restarts <- computeRestarts(cond)
[17:03:39.990]                         for (restart in restarts) {
[17:03:39.990]                           name <- restart$name
[17:03:39.990]                           if (is.null(name)) 
[17:03:39.990]                             next
[17:03:39.990]                           if (!grepl(pattern, name)) 
[17:03:39.990]                             next
[17:03:39.990]                           invokeRestart(restart)
[17:03:39.990]                           muffled <- TRUE
[17:03:39.990]                           break
[17:03:39.990]                         }
[17:03:39.990]                       }
[17:03:39.990]                     }
[17:03:39.990]                     invisible(muffled)
[17:03:39.990]                   }
[17:03:39.990]                   muffleCondition(cond)
[17:03:39.990]                 })
[17:03:39.990]             }))
[17:03:39.990]             future::FutureResult(value = ...future.value$value, 
[17:03:39.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.990]                   ...future.rng), globalenv = if (FALSE) 
[17:03:39.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:39.990]                     ...future.globalenv.names))
[17:03:39.990]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:39.990]         }, condition = base::local({
[17:03:39.990]             c <- base::c
[17:03:39.990]             inherits <- base::inherits
[17:03:39.990]             invokeRestart <- base::invokeRestart
[17:03:39.990]             length <- base::length
[17:03:39.990]             list <- base::list
[17:03:39.990]             seq.int <- base::seq.int
[17:03:39.990]             signalCondition <- base::signalCondition
[17:03:39.990]             sys.calls <- base::sys.calls
[17:03:39.990]             `[[` <- base::`[[`
[17:03:39.990]             `+` <- base::`+`
[17:03:39.990]             `<<-` <- base::`<<-`
[17:03:39.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:39.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:39.990]                   3L)]
[17:03:39.990]             }
[17:03:39.990]             function(cond) {
[17:03:39.990]                 is_error <- inherits(cond, "error")
[17:03:39.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:39.990]                   NULL)
[17:03:39.990]                 if (is_error) {
[17:03:39.990]                   sessionInformation <- function() {
[17:03:39.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:39.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:39.990]                       search = base::search(), system = base::Sys.info())
[17:03:39.990]                   }
[17:03:39.990]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:39.990]                     cond$call), session = sessionInformation(), 
[17:03:39.990]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:39.990]                   signalCondition(cond)
[17:03:39.990]                 }
[17:03:39.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:39.990]                 "immediateCondition"))) {
[17:03:39.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:39.990]                   ...future.conditions[[length(...future.conditions) + 
[17:03:39.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:39.990]                   if (TRUE && !signal) {
[17:03:39.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.990]                     {
[17:03:39.990]                       inherits <- base::inherits
[17:03:39.990]                       invokeRestart <- base::invokeRestart
[17:03:39.990]                       is.null <- base::is.null
[17:03:39.990]                       muffled <- FALSE
[17:03:39.990]                       if (inherits(cond, "message")) {
[17:03:39.990]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.990]                         if (muffled) 
[17:03:39.990]                           invokeRestart("muffleMessage")
[17:03:39.990]                       }
[17:03:39.990]                       else if (inherits(cond, "warning")) {
[17:03:39.990]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.990]                         if (muffled) 
[17:03:39.990]                           invokeRestart("muffleWarning")
[17:03:39.990]                       }
[17:03:39.990]                       else if (inherits(cond, "condition")) {
[17:03:39.990]                         if (!is.null(pattern)) {
[17:03:39.990]                           computeRestarts <- base::computeRestarts
[17:03:39.990]                           grepl <- base::grepl
[17:03:39.990]                           restarts <- computeRestarts(cond)
[17:03:39.990]                           for (restart in restarts) {
[17:03:39.990]                             name <- restart$name
[17:03:39.990]                             if (is.null(name)) 
[17:03:39.990]                               next
[17:03:39.990]                             if (!grepl(pattern, name)) 
[17:03:39.990]                               next
[17:03:39.990]                             invokeRestart(restart)
[17:03:39.990]                             muffled <- TRUE
[17:03:39.990]                             break
[17:03:39.990]                           }
[17:03:39.990]                         }
[17:03:39.990]                       }
[17:03:39.990]                       invisible(muffled)
[17:03:39.990]                     }
[17:03:39.990]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.990]                   }
[17:03:39.990]                 }
[17:03:39.990]                 else {
[17:03:39.990]                   if (TRUE) {
[17:03:39.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:39.990]                     {
[17:03:39.990]                       inherits <- base::inherits
[17:03:39.990]                       invokeRestart <- base::invokeRestart
[17:03:39.990]                       is.null <- base::is.null
[17:03:39.990]                       muffled <- FALSE
[17:03:39.990]                       if (inherits(cond, "message")) {
[17:03:39.990]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:39.990]                         if (muffled) 
[17:03:39.990]                           invokeRestart("muffleMessage")
[17:03:39.990]                       }
[17:03:39.990]                       else if (inherits(cond, "warning")) {
[17:03:39.990]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:39.990]                         if (muffled) 
[17:03:39.990]                           invokeRestart("muffleWarning")
[17:03:39.990]                       }
[17:03:39.990]                       else if (inherits(cond, "condition")) {
[17:03:39.990]                         if (!is.null(pattern)) {
[17:03:39.990]                           computeRestarts <- base::computeRestarts
[17:03:39.990]                           grepl <- base::grepl
[17:03:39.990]                           restarts <- computeRestarts(cond)
[17:03:39.990]                           for (restart in restarts) {
[17:03:39.990]                             name <- restart$name
[17:03:39.990]                             if (is.null(name)) 
[17:03:39.990]                               next
[17:03:39.990]                             if (!grepl(pattern, name)) 
[17:03:39.990]                               next
[17:03:39.990]                             invokeRestart(restart)
[17:03:39.990]                             muffled <- TRUE
[17:03:39.990]                             break
[17:03:39.990]                           }
[17:03:39.990]                         }
[17:03:39.990]                       }
[17:03:39.990]                       invisible(muffled)
[17:03:39.990]                     }
[17:03:39.990]                     muffleCondition(cond, pattern = "^muffle")
[17:03:39.990]                   }
[17:03:39.990]                 }
[17:03:39.990]             }
[17:03:39.990]         }))
[17:03:39.990]     }, error = function(ex) {
[17:03:39.990]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:39.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:39.990]                 ...future.rng), started = ...future.startTime, 
[17:03:39.990]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:39.990]             version = "1.8"), class = "FutureResult")
[17:03:39.990]     }, finally = {
[17:03:39.990]         if (!identical(...future.workdir, getwd())) 
[17:03:39.990]             setwd(...future.workdir)
[17:03:39.990]         {
[17:03:39.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:39.990]                 ...future.oldOptions$nwarnings <- NULL
[17:03:39.990]             }
[17:03:39.990]             base::options(...future.oldOptions)
[17:03:39.990]             if (.Platform$OS.type == "windows") {
[17:03:39.990]                 old_names <- names(...future.oldEnvVars)
[17:03:39.990]                 envs <- base::Sys.getenv()
[17:03:39.990]                 names <- names(envs)
[17:03:39.990]                 common <- intersect(names, old_names)
[17:03:39.990]                 added <- setdiff(names, old_names)
[17:03:39.990]                 removed <- setdiff(old_names, names)
[17:03:39.990]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:39.990]                   envs[common]]
[17:03:39.990]                 NAMES <- toupper(changed)
[17:03:39.990]                 args <- list()
[17:03:39.990]                 for (kk in seq_along(NAMES)) {
[17:03:39.990]                   name <- changed[[kk]]
[17:03:39.990]                   NAME <- NAMES[[kk]]
[17:03:39.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.990]                     next
[17:03:39.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.990]                 }
[17:03:39.990]                 NAMES <- toupper(added)
[17:03:39.990]                 for (kk in seq_along(NAMES)) {
[17:03:39.990]                   name <- added[[kk]]
[17:03:39.990]                   NAME <- NAMES[[kk]]
[17:03:39.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.990]                     next
[17:03:39.990]                   args[[name]] <- ""
[17:03:39.990]                 }
[17:03:39.990]                 NAMES <- toupper(removed)
[17:03:39.990]                 for (kk in seq_along(NAMES)) {
[17:03:39.990]                   name <- removed[[kk]]
[17:03:39.990]                   NAME <- NAMES[[kk]]
[17:03:39.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:39.990]                     next
[17:03:39.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:39.990]                 }
[17:03:39.990]                 if (length(args) > 0) 
[17:03:39.990]                   base::do.call(base::Sys.setenv, args = args)
[17:03:39.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:39.990]             }
[17:03:39.990]             else {
[17:03:39.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:39.990]             }
[17:03:39.990]             {
[17:03:39.990]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:39.990]                   0L) {
[17:03:39.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:39.990]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:39.990]                   base::options(opts)
[17:03:39.990]                 }
[17:03:39.990]                 {
[17:03:39.990]                   {
[17:03:39.990]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:39.990]                     NULL
[17:03:39.990]                   }
[17:03:39.990]                   options(future.plan = NULL)
[17:03:39.990]                   if (is.na(NA_character_)) 
[17:03:39.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:39.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:39.990]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:39.990]                     .init = FALSE)
[17:03:39.990]                 }
[17:03:39.990]             }
[17:03:39.990]         }
[17:03:39.990]     })
[17:03:39.990]     if (TRUE) {
[17:03:39.990]         base::sink(type = "output", split = FALSE)
[17:03:39.990]         if (TRUE) {
[17:03:39.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:39.990]         }
[17:03:39.990]         else {
[17:03:39.990]             ...future.result["stdout"] <- base::list(NULL)
[17:03:39.990]         }
[17:03:39.990]         base::close(...future.stdout)
[17:03:39.990]         ...future.stdout <- NULL
[17:03:39.990]     }
[17:03:39.990]     ...future.result$conditions <- ...future.conditions
[17:03:39.990]     ...future.result$finished <- base::Sys.time()
[17:03:39.990]     ...future.result
[17:03:39.990] }
[17:03:39.993] requestCore(): workers = 2
[17:03:39.993] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.004] result() for MulticoreFuture ...
[17:03:40.004] result() for MulticoreFuture ...
[17:03:40.005] result() for MulticoreFuture ... done
[17:03:40.005] result() for MulticoreFuture ... done
[17:03:40.005] result() for MulticoreFuture ...
[17:03:40.005] result() for MulticoreFuture ... done
[17:03:40.008] MulticoreFuture started
[17:03:40.008] - Launch lazy future ... done
[17:03:40.009] run() for ‘MulticoreFuture’ ... done
[17:03:40.009] getGlobalsAndPackages() ...
[17:03:40.009] plan(): Setting new future strategy stack:
[17:03:40.009] Searching for globals...
[17:03:40.010] 
[17:03:40.009] List of future strategies:
[17:03:40.009] 1. sequential:
[17:03:40.009]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.009]    - tweaked: FALSE
[17:03:40.009]    - call: NULL
[17:03:40.010] Searching for globals ... DONE
[17:03:40.010] plan(): nbrOfWorkers() = 1
[17:03:40.010] - globals: [0] <none>
[17:03:40.010] getGlobalsAndPackages() ... DONE
[17:03:40.011] run() for ‘Future’ ...
[17:03:40.011] - state: ‘created’
[17:03:40.012] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.012] plan(): Setting new future strategy stack:
[17:03:40.012] List of future strategies:
[17:03:40.012] 1. multicore:
[17:03:40.012]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.012]    - tweaked: FALSE
[17:03:40.012]    - call: plan(strategy)
[17:03:40.017] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.017] plan(): nbrOfWorkers() = 2
[17:03:40.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.017]   - Field: ‘label’
[17:03:40.017]   - Field: ‘local’
[17:03:40.017]   - Field: ‘owner’
[17:03:40.017]   - Field: ‘envir’
[17:03:40.018]   - Field: ‘workers’
[17:03:40.018]   - Field: ‘packages’
[17:03:40.018]   - Field: ‘gc’
[17:03:40.018]   - Field: ‘job’
[17:03:40.018]   - Field: ‘conditions’
[17:03:40.018]   - Field: ‘expr’
[17:03:40.018]   - Field: ‘uuid’
[17:03:40.019]   - Field: ‘seed’
[17:03:40.019]   - Field: ‘version’
[17:03:40.019]   - Field: ‘result’
[17:03:40.019]   - Field: ‘asynchronous’
[17:03:40.019]   - Field: ‘calls’
[17:03:40.019]   - Field: ‘globals’
[17:03:40.019]   - Field: ‘stdout’
[17:03:40.020]   - Field: ‘earlySignal’
[17:03:40.020]   - Field: ‘lazy’
[17:03:40.020]   - Field: ‘state’
[17:03:40.020] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.020] - Launch lazy future ...
[17:03:40.021] Packages needed by the future expression (n = 0): <none>
[17:03:40.021] Packages needed by future strategies (n = 0): <none>
[17:03:40.022] {
[17:03:40.022]     {
[17:03:40.022]         {
[17:03:40.022]             ...future.startTime <- base::Sys.time()
[17:03:40.022]             {
[17:03:40.022]                 {
[17:03:40.022]                   {
[17:03:40.022]                     {
[17:03:40.022]                       base::local({
[17:03:40.022]                         has_future <- base::requireNamespace("future", 
[17:03:40.022]                           quietly = TRUE)
[17:03:40.022]                         if (has_future) {
[17:03:40.022]                           ns <- base::getNamespace("future")
[17:03:40.022]                           version <- ns[[".package"]][["version"]]
[17:03:40.022]                           if (is.null(version)) 
[17:03:40.022]                             version <- utils::packageVersion("future")
[17:03:40.022]                         }
[17:03:40.022]                         else {
[17:03:40.022]                           version <- NULL
[17:03:40.022]                         }
[17:03:40.022]                         if (!has_future || version < "1.8.0") {
[17:03:40.022]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.022]                             "", base::R.version$version.string), 
[17:03:40.022]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.022]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.022]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.022]                               "release", "version")], collapse = " "), 
[17:03:40.022]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.022]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.022]                             info)
[17:03:40.022]                           info <- base::paste(info, collapse = "; ")
[17:03:40.022]                           if (!has_future) {
[17:03:40.022]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.022]                               info)
[17:03:40.022]                           }
[17:03:40.022]                           else {
[17:03:40.022]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.022]                               info, version)
[17:03:40.022]                           }
[17:03:40.022]                           base::stop(msg)
[17:03:40.022]                         }
[17:03:40.022]                       })
[17:03:40.022]                     }
[17:03:40.022]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.022]                     base::options(mc.cores = 1L)
[17:03:40.022]                   }
[17:03:40.022]                   ...future.strategy.old <- future::plan("list")
[17:03:40.022]                   options(future.plan = NULL)
[17:03:40.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.022]                 }
[17:03:40.022]                 ...future.workdir <- getwd()
[17:03:40.022]             }
[17:03:40.022]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.022]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.022]         }
[17:03:40.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.022]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.022]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.022]             base::names(...future.oldOptions))
[17:03:40.022]     }
[17:03:40.022]     if (FALSE) {
[17:03:40.022]     }
[17:03:40.022]     else {
[17:03:40.022]         if (TRUE) {
[17:03:40.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.022]                 open = "w")
[17:03:40.022]         }
[17:03:40.022]         else {
[17:03:40.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.022]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.022]         }
[17:03:40.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.022]             base::sink(type = "output", split = FALSE)
[17:03:40.022]             base::close(...future.stdout)
[17:03:40.022]         }, add = TRUE)
[17:03:40.022]     }
[17:03:40.022]     ...future.frame <- base::sys.nframe()
[17:03:40.022]     ...future.conditions <- base::list()
[17:03:40.022]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.022]     if (FALSE) {
[17:03:40.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.022]     }
[17:03:40.022]     ...future.result <- base::tryCatch({
[17:03:40.022]         base::withCallingHandlers({
[17:03:40.022]             ...future.value <- base::withVisible(base::local({
[17:03:40.022]                 withCallingHandlers({
[17:03:40.022]                   2
[17:03:40.022]                 }, immediateCondition = function(cond) {
[17:03:40.022]                   save_rds <- function (object, pathname, ...) 
[17:03:40.022]                   {
[17:03:40.022]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.022]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.022]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.022]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.022]                         fi_tmp[["mtime"]])
[17:03:40.022]                     }
[17:03:40.022]                     tryCatch({
[17:03:40.022]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.022]                     }, error = function(ex) {
[17:03:40.022]                       msg <- conditionMessage(ex)
[17:03:40.022]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.022]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.022]                         fi_tmp[["mtime"]], msg)
[17:03:40.022]                       ex$message <- msg
[17:03:40.022]                       stop(ex)
[17:03:40.022]                     })
[17:03:40.022]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.022]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.022]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.022]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.022]                       fi <- file.info(pathname)
[17:03:40.022]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.022]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.022]                         fi[["size"]], fi[["mtime"]])
[17:03:40.022]                       stop(msg)
[17:03:40.022]                     }
[17:03:40.022]                     invisible(pathname)
[17:03:40.022]                   }
[17:03:40.022]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.022]                     rootPath = tempdir()) 
[17:03:40.022]                   {
[17:03:40.022]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.022]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.022]                       tmpdir = path, fileext = ".rds")
[17:03:40.022]                     save_rds(obj, file)
[17:03:40.022]                   }
[17:03:40.022]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.022]                   {
[17:03:40.022]                     inherits <- base::inherits
[17:03:40.022]                     invokeRestart <- base::invokeRestart
[17:03:40.022]                     is.null <- base::is.null
[17:03:40.022]                     muffled <- FALSE
[17:03:40.022]                     if (inherits(cond, "message")) {
[17:03:40.022]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.022]                       if (muffled) 
[17:03:40.022]                         invokeRestart("muffleMessage")
[17:03:40.022]                     }
[17:03:40.022]                     else if (inherits(cond, "warning")) {
[17:03:40.022]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.022]                       if (muffled) 
[17:03:40.022]                         invokeRestart("muffleWarning")
[17:03:40.022]                     }
[17:03:40.022]                     else if (inherits(cond, "condition")) {
[17:03:40.022]                       if (!is.null(pattern)) {
[17:03:40.022]                         computeRestarts <- base::computeRestarts
[17:03:40.022]                         grepl <- base::grepl
[17:03:40.022]                         restarts <- computeRestarts(cond)
[17:03:40.022]                         for (restart in restarts) {
[17:03:40.022]                           name <- restart$name
[17:03:40.022]                           if (is.null(name)) 
[17:03:40.022]                             next
[17:03:40.022]                           if (!grepl(pattern, name)) 
[17:03:40.022]                             next
[17:03:40.022]                           invokeRestart(restart)
[17:03:40.022]                           muffled <- TRUE
[17:03:40.022]                           break
[17:03:40.022]                         }
[17:03:40.022]                       }
[17:03:40.022]                     }
[17:03:40.022]                     invisible(muffled)
[17:03:40.022]                   }
[17:03:40.022]                   muffleCondition(cond)
[17:03:40.022]                 })
[17:03:40.022]             }))
[17:03:40.022]             future::FutureResult(value = ...future.value$value, 
[17:03:40.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.022]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.022]                     ...future.globalenv.names))
[17:03:40.022]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.022]         }, condition = base::local({
[17:03:40.022]             c <- base::c
[17:03:40.022]             inherits <- base::inherits
[17:03:40.022]             invokeRestart <- base::invokeRestart
[17:03:40.022]             length <- base::length
[17:03:40.022]             list <- base::list
[17:03:40.022]             seq.int <- base::seq.int
[17:03:40.022]             signalCondition <- base::signalCondition
[17:03:40.022]             sys.calls <- base::sys.calls
[17:03:40.022]             `[[` <- base::`[[`
[17:03:40.022]             `+` <- base::`+`
[17:03:40.022]             `<<-` <- base::`<<-`
[17:03:40.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.022]                   3L)]
[17:03:40.022]             }
[17:03:40.022]             function(cond) {
[17:03:40.022]                 is_error <- inherits(cond, "error")
[17:03:40.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.022]                   NULL)
[17:03:40.022]                 if (is_error) {
[17:03:40.022]                   sessionInformation <- function() {
[17:03:40.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.022]                       search = base::search(), system = base::Sys.info())
[17:03:40.022]                   }
[17:03:40.022]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.022]                     cond$call), session = sessionInformation(), 
[17:03:40.022]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.022]                   signalCondition(cond)
[17:03:40.022]                 }
[17:03:40.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.022]                 "immediateCondition"))) {
[17:03:40.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.022]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.022]                   if (TRUE && !signal) {
[17:03:40.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.022]                     {
[17:03:40.022]                       inherits <- base::inherits
[17:03:40.022]                       invokeRestart <- base::invokeRestart
[17:03:40.022]                       is.null <- base::is.null
[17:03:40.022]                       muffled <- FALSE
[17:03:40.022]                       if (inherits(cond, "message")) {
[17:03:40.022]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.022]                         if (muffled) 
[17:03:40.022]                           invokeRestart("muffleMessage")
[17:03:40.022]                       }
[17:03:40.022]                       else if (inherits(cond, "warning")) {
[17:03:40.022]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.022]                         if (muffled) 
[17:03:40.022]                           invokeRestart("muffleWarning")
[17:03:40.022]                       }
[17:03:40.022]                       else if (inherits(cond, "condition")) {
[17:03:40.022]                         if (!is.null(pattern)) {
[17:03:40.022]                           computeRestarts <- base::computeRestarts
[17:03:40.022]                           grepl <- base::grepl
[17:03:40.022]                           restarts <- computeRestarts(cond)
[17:03:40.022]                           for (restart in restarts) {
[17:03:40.022]                             name <- restart$name
[17:03:40.022]                             if (is.null(name)) 
[17:03:40.022]                               next
[17:03:40.022]                             if (!grepl(pattern, name)) 
[17:03:40.022]                               next
[17:03:40.022]                             invokeRestart(restart)
[17:03:40.022]                             muffled <- TRUE
[17:03:40.022]                             break
[17:03:40.022]                           }
[17:03:40.022]                         }
[17:03:40.022]                       }
[17:03:40.022]                       invisible(muffled)
[17:03:40.022]                     }
[17:03:40.022]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.022]                   }
[17:03:40.022]                 }
[17:03:40.022]                 else {
[17:03:40.022]                   if (TRUE) {
[17:03:40.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.022]                     {
[17:03:40.022]                       inherits <- base::inherits
[17:03:40.022]                       invokeRestart <- base::invokeRestart
[17:03:40.022]                       is.null <- base::is.null
[17:03:40.022]                       muffled <- FALSE
[17:03:40.022]                       if (inherits(cond, "message")) {
[17:03:40.022]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.022]                         if (muffled) 
[17:03:40.022]                           invokeRestart("muffleMessage")
[17:03:40.022]                       }
[17:03:40.022]                       else if (inherits(cond, "warning")) {
[17:03:40.022]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.022]                         if (muffled) 
[17:03:40.022]                           invokeRestart("muffleWarning")
[17:03:40.022]                       }
[17:03:40.022]                       else if (inherits(cond, "condition")) {
[17:03:40.022]                         if (!is.null(pattern)) {
[17:03:40.022]                           computeRestarts <- base::computeRestarts
[17:03:40.022]                           grepl <- base::grepl
[17:03:40.022]                           restarts <- computeRestarts(cond)
[17:03:40.022]                           for (restart in restarts) {
[17:03:40.022]                             name <- restart$name
[17:03:40.022]                             if (is.null(name)) 
[17:03:40.022]                               next
[17:03:40.022]                             if (!grepl(pattern, name)) 
[17:03:40.022]                               next
[17:03:40.022]                             invokeRestart(restart)
[17:03:40.022]                             muffled <- TRUE
[17:03:40.022]                             break
[17:03:40.022]                           }
[17:03:40.022]                         }
[17:03:40.022]                       }
[17:03:40.022]                       invisible(muffled)
[17:03:40.022]                     }
[17:03:40.022]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.022]                   }
[17:03:40.022]                 }
[17:03:40.022]             }
[17:03:40.022]         }))
[17:03:40.022]     }, error = function(ex) {
[17:03:40.022]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.022]                 ...future.rng), started = ...future.startTime, 
[17:03:40.022]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.022]             version = "1.8"), class = "FutureResult")
[17:03:40.022]     }, finally = {
[17:03:40.022]         if (!identical(...future.workdir, getwd())) 
[17:03:40.022]             setwd(...future.workdir)
[17:03:40.022]         {
[17:03:40.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.022]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.022]             }
[17:03:40.022]             base::options(...future.oldOptions)
[17:03:40.022]             if (.Platform$OS.type == "windows") {
[17:03:40.022]                 old_names <- names(...future.oldEnvVars)
[17:03:40.022]                 envs <- base::Sys.getenv()
[17:03:40.022]                 names <- names(envs)
[17:03:40.022]                 common <- intersect(names, old_names)
[17:03:40.022]                 added <- setdiff(names, old_names)
[17:03:40.022]                 removed <- setdiff(old_names, names)
[17:03:40.022]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.022]                   envs[common]]
[17:03:40.022]                 NAMES <- toupper(changed)
[17:03:40.022]                 args <- list()
[17:03:40.022]                 for (kk in seq_along(NAMES)) {
[17:03:40.022]                   name <- changed[[kk]]
[17:03:40.022]                   NAME <- NAMES[[kk]]
[17:03:40.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.022]                     next
[17:03:40.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.022]                 }
[17:03:40.022]                 NAMES <- toupper(added)
[17:03:40.022]                 for (kk in seq_along(NAMES)) {
[17:03:40.022]                   name <- added[[kk]]
[17:03:40.022]                   NAME <- NAMES[[kk]]
[17:03:40.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.022]                     next
[17:03:40.022]                   args[[name]] <- ""
[17:03:40.022]                 }
[17:03:40.022]                 NAMES <- toupper(removed)
[17:03:40.022]                 for (kk in seq_along(NAMES)) {
[17:03:40.022]                   name <- removed[[kk]]
[17:03:40.022]                   NAME <- NAMES[[kk]]
[17:03:40.022]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.022]                     next
[17:03:40.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.022]                 }
[17:03:40.022]                 if (length(args) > 0) 
[17:03:40.022]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.022]             }
[17:03:40.022]             else {
[17:03:40.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.022]             }
[17:03:40.022]             {
[17:03:40.022]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.022]                   0L) {
[17:03:40.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.022]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.022]                   base::options(opts)
[17:03:40.022]                 }
[17:03:40.022]                 {
[17:03:40.022]                   {
[17:03:40.022]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.022]                     NULL
[17:03:40.022]                   }
[17:03:40.022]                   options(future.plan = NULL)
[17:03:40.022]                   if (is.na(NA_character_)) 
[17:03:40.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.022]                     .init = FALSE)
[17:03:40.022]                 }
[17:03:40.022]             }
[17:03:40.022]         }
[17:03:40.022]     })
[17:03:40.022]     if (TRUE) {
[17:03:40.022]         base::sink(type = "output", split = FALSE)
[17:03:40.022]         if (TRUE) {
[17:03:40.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.022]         }
[17:03:40.022]         else {
[17:03:40.022]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.022]         }
[17:03:40.022]         base::close(...future.stdout)
[17:03:40.022]         ...future.stdout <- NULL
[17:03:40.022]     }
[17:03:40.022]     ...future.result$conditions <- ...future.conditions
[17:03:40.022]     ...future.result$finished <- base::Sys.time()
[17:03:40.022]     ...future.result
[17:03:40.022] }
[17:03:40.025] requestCore(): workers = 2
[17:03:40.025] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.036] result() for MulticoreFuture ...
[17:03:40.037] result() for MulticoreFuture ...
[17:03:40.037] result() for MulticoreFuture ... done
[17:03:40.037] result() for MulticoreFuture ... done
[17:03:40.038] result() for MulticoreFuture ...
[17:03:40.038] result() for MulticoreFuture ... done
[17:03:40.041] MulticoreFuture started
[17:03:40.041] - Launch lazy future ... done
[17:03:40.041] run() for ‘MulticoreFuture’ ... done
[17:03:40.042] plan(): Setting new future strategy stack:
[17:03:40.042] List of future strategies:
[17:03:40.042] 1. sequential:
[17:03:40.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.042]    - tweaked: FALSE
[17:03:40.042]    - call: NULL
[17:03:40.043] resolve() on environment ...
[17:03:40.043]  recursive: 0
[17:03:40.043] plan(): nbrOfWorkers() = 1
[17:03:40.044]  elements: [3] ‘a’, ‘b’, ‘c’
[17:03:40.045] Future #1
[17:03:40.045]  length: 2 (resolved future 1)
[17:03:40.045] plan(): Setting new future strategy stack:
[17:03:40.045] List of future strategies:
[17:03:40.045] 1. multicore:
[17:03:40.045]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.045]    - tweaked: FALSE
[17:03:40.045]    - call: plan(strategy)
[17:03:40.050] plan(): nbrOfWorkers() = 2
[17:03:40.051] Future #2
[17:03:40.051]  length: 1 (resolved future 2)
[17:03:40.051]  length: 0 (resolved future 3)
[17:03:40.051] resolve() on environment ... DONE
[17:03:40.053] getGlobalsAndPackages() ...
[17:03:40.053] Searching for globals...
[17:03:40.054] - globals found: [1] ‘{’
[17:03:40.054] Searching for globals ... DONE
[17:03:40.055] Resolving globals: FALSE
[17:03:40.055] 
[17:03:40.055] 
[17:03:40.055] getGlobalsAndPackages() ... DONE
[17:03:40.056] run() for ‘Future’ ...
[17:03:40.056] - state: ‘created’
[17:03:40.056] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.061] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.061]   - Field: ‘label’
[17:03:40.061]   - Field: ‘local’
[17:03:40.062]   - Field: ‘owner’
[17:03:40.062]   - Field: ‘envir’
[17:03:40.062]   - Field: ‘workers’
[17:03:40.062]   - Field: ‘packages’
[17:03:40.062]   - Field: ‘gc’
[17:03:40.062]   - Field: ‘job’
[17:03:40.062]   - Field: ‘conditions’
[17:03:40.063]   - Field: ‘expr’
[17:03:40.063]   - Field: ‘uuid’
[17:03:40.063]   - Field: ‘seed’
[17:03:40.063]   - Field: ‘version’
[17:03:40.063]   - Field: ‘result’
[17:03:40.063]   - Field: ‘asynchronous’
[17:03:40.063]   - Field: ‘calls’
[17:03:40.064]   - Field: ‘globals’
[17:03:40.064]   - Field: ‘stdout’
[17:03:40.064]   - Field: ‘earlySignal’
[17:03:40.064]   - Field: ‘lazy’
[17:03:40.064]   - Field: ‘state’
[17:03:40.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.065] - Launch lazy future ...
[17:03:40.069] Packages needed by the future expression (n = 0): <none>
[17:03:40.069] Packages needed by future strategies (n = 0): <none>
[17:03:40.071] {
[17:03:40.071]     {
[17:03:40.071]         {
[17:03:40.071]             ...future.startTime <- base::Sys.time()
[17:03:40.071]             {
[17:03:40.071]                 {
[17:03:40.071]                   {
[17:03:40.071]                     {
[17:03:40.071]                       base::local({
[17:03:40.071]                         has_future <- base::requireNamespace("future", 
[17:03:40.071]                           quietly = TRUE)
[17:03:40.071]                         if (has_future) {
[17:03:40.071]                           ns <- base::getNamespace("future")
[17:03:40.071]                           version <- ns[[".package"]][["version"]]
[17:03:40.071]                           if (is.null(version)) 
[17:03:40.071]                             version <- utils::packageVersion("future")
[17:03:40.071]                         }
[17:03:40.071]                         else {
[17:03:40.071]                           version <- NULL
[17:03:40.071]                         }
[17:03:40.071]                         if (!has_future || version < "1.8.0") {
[17:03:40.071]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.071]                             "", base::R.version$version.string), 
[17:03:40.071]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.071]                               "release", "version")], collapse = " "), 
[17:03:40.071]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.071]                             info)
[17:03:40.071]                           info <- base::paste(info, collapse = "; ")
[17:03:40.071]                           if (!has_future) {
[17:03:40.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.071]                               info)
[17:03:40.071]                           }
[17:03:40.071]                           else {
[17:03:40.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.071]                               info, version)
[17:03:40.071]                           }
[17:03:40.071]                           base::stop(msg)
[17:03:40.071]                         }
[17:03:40.071]                       })
[17:03:40.071]                     }
[17:03:40.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.071]                     base::options(mc.cores = 1L)
[17:03:40.071]                   }
[17:03:40.071]                   ...future.strategy.old <- future::plan("list")
[17:03:40.071]                   options(future.plan = NULL)
[17:03:40.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.071]                 }
[17:03:40.071]                 ...future.workdir <- getwd()
[17:03:40.071]             }
[17:03:40.071]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.071]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.071]         }
[17:03:40.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.071]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.071]             base::names(...future.oldOptions))
[17:03:40.071]     }
[17:03:40.071]     if (FALSE) {
[17:03:40.071]     }
[17:03:40.071]     else {
[17:03:40.071]         if (TRUE) {
[17:03:40.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.071]                 open = "w")
[17:03:40.071]         }
[17:03:40.071]         else {
[17:03:40.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.071]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.071]         }
[17:03:40.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.071]             base::sink(type = "output", split = FALSE)
[17:03:40.071]             base::close(...future.stdout)
[17:03:40.071]         }, add = TRUE)
[17:03:40.071]     }
[17:03:40.071]     ...future.frame <- base::sys.nframe()
[17:03:40.071]     ...future.conditions <- base::list()
[17:03:40.071]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.071]     if (FALSE) {
[17:03:40.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.071]     }
[17:03:40.071]     ...future.result <- base::tryCatch({
[17:03:40.071]         base::withCallingHandlers({
[17:03:40.071]             ...future.value <- base::withVisible(base::local({
[17:03:40.071]                 withCallingHandlers({
[17:03:40.071]                   {
[17:03:40.071]                     1
[17:03:40.071]                   }
[17:03:40.071]                 }, immediateCondition = function(cond) {
[17:03:40.071]                   save_rds <- function (object, pathname, ...) 
[17:03:40.071]                   {
[17:03:40.071]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.071]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.071]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.071]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.071]                         fi_tmp[["mtime"]])
[17:03:40.071]                     }
[17:03:40.071]                     tryCatch({
[17:03:40.071]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.071]                     }, error = function(ex) {
[17:03:40.071]                       msg <- conditionMessage(ex)
[17:03:40.071]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.071]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.071]                         fi_tmp[["mtime"]], msg)
[17:03:40.071]                       ex$message <- msg
[17:03:40.071]                       stop(ex)
[17:03:40.071]                     })
[17:03:40.071]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.071]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.071]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.071]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.071]                       fi <- file.info(pathname)
[17:03:40.071]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.071]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.071]                         fi[["size"]], fi[["mtime"]])
[17:03:40.071]                       stop(msg)
[17:03:40.071]                     }
[17:03:40.071]                     invisible(pathname)
[17:03:40.071]                   }
[17:03:40.071]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.071]                     rootPath = tempdir()) 
[17:03:40.071]                   {
[17:03:40.071]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.071]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.071]                       tmpdir = path, fileext = ".rds")
[17:03:40.071]                     save_rds(obj, file)
[17:03:40.071]                   }
[17:03:40.071]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.071]                   {
[17:03:40.071]                     inherits <- base::inherits
[17:03:40.071]                     invokeRestart <- base::invokeRestart
[17:03:40.071]                     is.null <- base::is.null
[17:03:40.071]                     muffled <- FALSE
[17:03:40.071]                     if (inherits(cond, "message")) {
[17:03:40.071]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.071]                       if (muffled) 
[17:03:40.071]                         invokeRestart("muffleMessage")
[17:03:40.071]                     }
[17:03:40.071]                     else if (inherits(cond, "warning")) {
[17:03:40.071]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.071]                       if (muffled) 
[17:03:40.071]                         invokeRestart("muffleWarning")
[17:03:40.071]                     }
[17:03:40.071]                     else if (inherits(cond, "condition")) {
[17:03:40.071]                       if (!is.null(pattern)) {
[17:03:40.071]                         computeRestarts <- base::computeRestarts
[17:03:40.071]                         grepl <- base::grepl
[17:03:40.071]                         restarts <- computeRestarts(cond)
[17:03:40.071]                         for (restart in restarts) {
[17:03:40.071]                           name <- restart$name
[17:03:40.071]                           if (is.null(name)) 
[17:03:40.071]                             next
[17:03:40.071]                           if (!grepl(pattern, name)) 
[17:03:40.071]                             next
[17:03:40.071]                           invokeRestart(restart)
[17:03:40.071]                           muffled <- TRUE
[17:03:40.071]                           break
[17:03:40.071]                         }
[17:03:40.071]                       }
[17:03:40.071]                     }
[17:03:40.071]                     invisible(muffled)
[17:03:40.071]                   }
[17:03:40.071]                   muffleCondition(cond)
[17:03:40.071]                 })
[17:03:40.071]             }))
[17:03:40.071]             future::FutureResult(value = ...future.value$value, 
[17:03:40.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.071]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.071]                     ...future.globalenv.names))
[17:03:40.071]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.071]         }, condition = base::local({
[17:03:40.071]             c <- base::c
[17:03:40.071]             inherits <- base::inherits
[17:03:40.071]             invokeRestart <- base::invokeRestart
[17:03:40.071]             length <- base::length
[17:03:40.071]             list <- base::list
[17:03:40.071]             seq.int <- base::seq.int
[17:03:40.071]             signalCondition <- base::signalCondition
[17:03:40.071]             sys.calls <- base::sys.calls
[17:03:40.071]             `[[` <- base::`[[`
[17:03:40.071]             `+` <- base::`+`
[17:03:40.071]             `<<-` <- base::`<<-`
[17:03:40.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.071]                   3L)]
[17:03:40.071]             }
[17:03:40.071]             function(cond) {
[17:03:40.071]                 is_error <- inherits(cond, "error")
[17:03:40.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.071]                   NULL)
[17:03:40.071]                 if (is_error) {
[17:03:40.071]                   sessionInformation <- function() {
[17:03:40.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.071]                       search = base::search(), system = base::Sys.info())
[17:03:40.071]                   }
[17:03:40.071]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.071]                     cond$call), session = sessionInformation(), 
[17:03:40.071]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.071]                   signalCondition(cond)
[17:03:40.071]                 }
[17:03:40.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.071]                 "immediateCondition"))) {
[17:03:40.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.071]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.071]                   if (TRUE && !signal) {
[17:03:40.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.071]                     {
[17:03:40.071]                       inherits <- base::inherits
[17:03:40.071]                       invokeRestart <- base::invokeRestart
[17:03:40.071]                       is.null <- base::is.null
[17:03:40.071]                       muffled <- FALSE
[17:03:40.071]                       if (inherits(cond, "message")) {
[17:03:40.071]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.071]                         if (muffled) 
[17:03:40.071]                           invokeRestart("muffleMessage")
[17:03:40.071]                       }
[17:03:40.071]                       else if (inherits(cond, "warning")) {
[17:03:40.071]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.071]                         if (muffled) 
[17:03:40.071]                           invokeRestart("muffleWarning")
[17:03:40.071]                       }
[17:03:40.071]                       else if (inherits(cond, "condition")) {
[17:03:40.071]                         if (!is.null(pattern)) {
[17:03:40.071]                           computeRestarts <- base::computeRestarts
[17:03:40.071]                           grepl <- base::grepl
[17:03:40.071]                           restarts <- computeRestarts(cond)
[17:03:40.071]                           for (restart in restarts) {
[17:03:40.071]                             name <- restart$name
[17:03:40.071]                             if (is.null(name)) 
[17:03:40.071]                               next
[17:03:40.071]                             if (!grepl(pattern, name)) 
[17:03:40.071]                               next
[17:03:40.071]                             invokeRestart(restart)
[17:03:40.071]                             muffled <- TRUE
[17:03:40.071]                             break
[17:03:40.071]                           }
[17:03:40.071]                         }
[17:03:40.071]                       }
[17:03:40.071]                       invisible(muffled)
[17:03:40.071]                     }
[17:03:40.071]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.071]                   }
[17:03:40.071]                 }
[17:03:40.071]                 else {
[17:03:40.071]                   if (TRUE) {
[17:03:40.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.071]                     {
[17:03:40.071]                       inherits <- base::inherits
[17:03:40.071]                       invokeRestart <- base::invokeRestart
[17:03:40.071]                       is.null <- base::is.null
[17:03:40.071]                       muffled <- FALSE
[17:03:40.071]                       if (inherits(cond, "message")) {
[17:03:40.071]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.071]                         if (muffled) 
[17:03:40.071]                           invokeRestart("muffleMessage")
[17:03:40.071]                       }
[17:03:40.071]                       else if (inherits(cond, "warning")) {
[17:03:40.071]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.071]                         if (muffled) 
[17:03:40.071]                           invokeRestart("muffleWarning")
[17:03:40.071]                       }
[17:03:40.071]                       else if (inherits(cond, "condition")) {
[17:03:40.071]                         if (!is.null(pattern)) {
[17:03:40.071]                           computeRestarts <- base::computeRestarts
[17:03:40.071]                           grepl <- base::grepl
[17:03:40.071]                           restarts <- computeRestarts(cond)
[17:03:40.071]                           for (restart in restarts) {
[17:03:40.071]                             name <- restart$name
[17:03:40.071]                             if (is.null(name)) 
[17:03:40.071]                               next
[17:03:40.071]                             if (!grepl(pattern, name)) 
[17:03:40.071]                               next
[17:03:40.071]                             invokeRestart(restart)
[17:03:40.071]                             muffled <- TRUE
[17:03:40.071]                             break
[17:03:40.071]                           }
[17:03:40.071]                         }
[17:03:40.071]                       }
[17:03:40.071]                       invisible(muffled)
[17:03:40.071]                     }
[17:03:40.071]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.071]                   }
[17:03:40.071]                 }
[17:03:40.071]             }
[17:03:40.071]         }))
[17:03:40.071]     }, error = function(ex) {
[17:03:40.071]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.071]                 ...future.rng), started = ...future.startTime, 
[17:03:40.071]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.071]             version = "1.8"), class = "FutureResult")
[17:03:40.071]     }, finally = {
[17:03:40.071]         if (!identical(...future.workdir, getwd())) 
[17:03:40.071]             setwd(...future.workdir)
[17:03:40.071]         {
[17:03:40.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.071]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.071]             }
[17:03:40.071]             base::options(...future.oldOptions)
[17:03:40.071]             if (.Platform$OS.type == "windows") {
[17:03:40.071]                 old_names <- names(...future.oldEnvVars)
[17:03:40.071]                 envs <- base::Sys.getenv()
[17:03:40.071]                 names <- names(envs)
[17:03:40.071]                 common <- intersect(names, old_names)
[17:03:40.071]                 added <- setdiff(names, old_names)
[17:03:40.071]                 removed <- setdiff(old_names, names)
[17:03:40.071]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.071]                   envs[common]]
[17:03:40.071]                 NAMES <- toupper(changed)
[17:03:40.071]                 args <- list()
[17:03:40.071]                 for (kk in seq_along(NAMES)) {
[17:03:40.071]                   name <- changed[[kk]]
[17:03:40.071]                   NAME <- NAMES[[kk]]
[17:03:40.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.071]                     next
[17:03:40.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.071]                 }
[17:03:40.071]                 NAMES <- toupper(added)
[17:03:40.071]                 for (kk in seq_along(NAMES)) {
[17:03:40.071]                   name <- added[[kk]]
[17:03:40.071]                   NAME <- NAMES[[kk]]
[17:03:40.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.071]                     next
[17:03:40.071]                   args[[name]] <- ""
[17:03:40.071]                 }
[17:03:40.071]                 NAMES <- toupper(removed)
[17:03:40.071]                 for (kk in seq_along(NAMES)) {
[17:03:40.071]                   name <- removed[[kk]]
[17:03:40.071]                   NAME <- NAMES[[kk]]
[17:03:40.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.071]                     next
[17:03:40.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.071]                 }
[17:03:40.071]                 if (length(args) > 0) 
[17:03:40.071]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.071]             }
[17:03:40.071]             else {
[17:03:40.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.071]             }
[17:03:40.071]             {
[17:03:40.071]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.071]                   0L) {
[17:03:40.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.071]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.071]                   base::options(opts)
[17:03:40.071]                 }
[17:03:40.071]                 {
[17:03:40.071]                   {
[17:03:40.071]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.071]                     NULL
[17:03:40.071]                   }
[17:03:40.071]                   options(future.plan = NULL)
[17:03:40.071]                   if (is.na(NA_character_)) 
[17:03:40.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.071]                     .init = FALSE)
[17:03:40.071]                 }
[17:03:40.071]             }
[17:03:40.071]         }
[17:03:40.071]     })
[17:03:40.071]     if (TRUE) {
[17:03:40.071]         base::sink(type = "output", split = FALSE)
[17:03:40.071]         if (TRUE) {
[17:03:40.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.071]         }
[17:03:40.071]         else {
[17:03:40.071]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.071]         }
[17:03:40.071]         base::close(...future.stdout)
[17:03:40.071]         ...future.stdout <- NULL
[17:03:40.071]     }
[17:03:40.071]     ...future.result$conditions <- ...future.conditions
[17:03:40.071]     ...future.result$finished <- base::Sys.time()
[17:03:40.071]     ...future.result
[17:03:40.071] }
[17:03:40.074] requestCore(): workers = 2
[17:03:40.074] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.085] result() for MulticoreFuture ...
[17:03:40.086] result() for MulticoreFuture ...
[17:03:40.087] result() for MulticoreFuture ... done
[17:03:40.087] result() for MulticoreFuture ... done
[17:03:40.087] result() for MulticoreFuture ...
[17:03:40.087] result() for MulticoreFuture ... done
[17:03:40.090] MulticoreFuture started
[17:03:40.090] - Launch lazy future ... done
[17:03:40.091] run() for ‘MulticoreFuture’ ... done
[17:03:40.091] plan(): Setting new future strategy stack:
[17:03:40.092] getGlobalsAndPackages() ...
[17:03:40.091] List of future strategies:
[17:03:40.091] 1. sequential:
[17:03:40.091]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.091]    - tweaked: FALSE
[17:03:40.091]    - call: NULL
[17:03:40.093] Searching for globals...
[17:03:40.093] plan(): nbrOfWorkers() = 1
[17:03:40.095] - globals found: [1] ‘{’
[17:03:40.095] Searching for globals ... DONE
[17:03:40.096] Resolving globals: FALSE
[17:03:40.096] plan(): Setting new future strategy stack:
[17:03:40.096] 
[17:03:40.097] 
[17:03:40.096] List of future strategies:
[17:03:40.096] 1. multicore:
[17:03:40.096]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.096]    - tweaked: FALSE
[17:03:40.096]    - call: plan(strategy)
[17:03:40.097] getGlobalsAndPackages() ... DONE
[17:03:40.098] run() for ‘Future’ ...
[17:03:40.098] - state: ‘created’
[17:03:40.098] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.103] plan(): nbrOfWorkers() = 2
[17:03:40.104] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.104]   - Field: ‘label’
[17:03:40.104]   - Field: ‘local’
[17:03:40.105]   - Field: ‘owner’
[17:03:40.105]   - Field: ‘envir’
[17:03:40.105]   - Field: ‘workers’
[17:03:40.105]   - Field: ‘packages’
[17:03:40.105]   - Field: ‘gc’
[17:03:40.105]   - Field: ‘job’
[17:03:40.105]   - Field: ‘conditions’
[17:03:40.106]   - Field: ‘expr’
[17:03:40.106]   - Field: ‘uuid’
[17:03:40.106]   - Field: ‘seed’
[17:03:40.106]   - Field: ‘version’
[17:03:40.106]   - Field: ‘result’
[17:03:40.106]   - Field: ‘asynchronous’
[17:03:40.106]   - Field: ‘calls’
[17:03:40.107]   - Field: ‘globals’
[17:03:40.107]   - Field: ‘stdout’
[17:03:40.107]   - Field: ‘earlySignal’
[17:03:40.107]   - Field: ‘lazy’
[17:03:40.107]   - Field: ‘state’
[17:03:40.107] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.108] - Launch lazy future ...
[17:03:40.108] Packages needed by the future expression (n = 0): <none>
[17:03:40.108] Packages needed by future strategies (n = 0): <none>
[17:03:40.109] {
[17:03:40.109]     {
[17:03:40.109]         {
[17:03:40.109]             ...future.startTime <- base::Sys.time()
[17:03:40.109]             {
[17:03:40.109]                 {
[17:03:40.109]                   {
[17:03:40.109]                     {
[17:03:40.109]                       base::local({
[17:03:40.109]                         has_future <- base::requireNamespace("future", 
[17:03:40.109]                           quietly = TRUE)
[17:03:40.109]                         if (has_future) {
[17:03:40.109]                           ns <- base::getNamespace("future")
[17:03:40.109]                           version <- ns[[".package"]][["version"]]
[17:03:40.109]                           if (is.null(version)) 
[17:03:40.109]                             version <- utils::packageVersion("future")
[17:03:40.109]                         }
[17:03:40.109]                         else {
[17:03:40.109]                           version <- NULL
[17:03:40.109]                         }
[17:03:40.109]                         if (!has_future || version < "1.8.0") {
[17:03:40.109]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.109]                             "", base::R.version$version.string), 
[17:03:40.109]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.109]                               "release", "version")], collapse = " "), 
[17:03:40.109]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.109]                             info)
[17:03:40.109]                           info <- base::paste(info, collapse = "; ")
[17:03:40.109]                           if (!has_future) {
[17:03:40.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.109]                               info)
[17:03:40.109]                           }
[17:03:40.109]                           else {
[17:03:40.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.109]                               info, version)
[17:03:40.109]                           }
[17:03:40.109]                           base::stop(msg)
[17:03:40.109]                         }
[17:03:40.109]                       })
[17:03:40.109]                     }
[17:03:40.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.109]                     base::options(mc.cores = 1L)
[17:03:40.109]                   }
[17:03:40.109]                   ...future.strategy.old <- future::plan("list")
[17:03:40.109]                   options(future.plan = NULL)
[17:03:40.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.109]                 }
[17:03:40.109]                 ...future.workdir <- getwd()
[17:03:40.109]             }
[17:03:40.109]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.109]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.109]         }
[17:03:40.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.109]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.109]             base::names(...future.oldOptions))
[17:03:40.109]     }
[17:03:40.109]     if (FALSE) {
[17:03:40.109]     }
[17:03:40.109]     else {
[17:03:40.109]         if (TRUE) {
[17:03:40.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.109]                 open = "w")
[17:03:40.109]         }
[17:03:40.109]         else {
[17:03:40.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.109]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.109]         }
[17:03:40.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.109]             base::sink(type = "output", split = FALSE)
[17:03:40.109]             base::close(...future.stdout)
[17:03:40.109]         }, add = TRUE)
[17:03:40.109]     }
[17:03:40.109]     ...future.frame <- base::sys.nframe()
[17:03:40.109]     ...future.conditions <- base::list()
[17:03:40.109]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.109]     if (FALSE) {
[17:03:40.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.109]     }
[17:03:40.109]     ...future.result <- base::tryCatch({
[17:03:40.109]         base::withCallingHandlers({
[17:03:40.109]             ...future.value <- base::withVisible(base::local({
[17:03:40.109]                 withCallingHandlers({
[17:03:40.109]                   {
[17:03:40.109]                     2
[17:03:40.109]                   }
[17:03:40.109]                 }, immediateCondition = function(cond) {
[17:03:40.109]                   save_rds <- function (object, pathname, ...) 
[17:03:40.109]                   {
[17:03:40.109]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.109]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.109]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.109]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.109]                         fi_tmp[["mtime"]])
[17:03:40.109]                     }
[17:03:40.109]                     tryCatch({
[17:03:40.109]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.109]                     }, error = function(ex) {
[17:03:40.109]                       msg <- conditionMessage(ex)
[17:03:40.109]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.109]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.109]                         fi_tmp[["mtime"]], msg)
[17:03:40.109]                       ex$message <- msg
[17:03:40.109]                       stop(ex)
[17:03:40.109]                     })
[17:03:40.109]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.109]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.109]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.109]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.109]                       fi <- file.info(pathname)
[17:03:40.109]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.109]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.109]                         fi[["size"]], fi[["mtime"]])
[17:03:40.109]                       stop(msg)
[17:03:40.109]                     }
[17:03:40.109]                     invisible(pathname)
[17:03:40.109]                   }
[17:03:40.109]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.109]                     rootPath = tempdir()) 
[17:03:40.109]                   {
[17:03:40.109]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.109]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.109]                       tmpdir = path, fileext = ".rds")
[17:03:40.109]                     save_rds(obj, file)
[17:03:40.109]                   }
[17:03:40.109]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.109]                   {
[17:03:40.109]                     inherits <- base::inherits
[17:03:40.109]                     invokeRestart <- base::invokeRestart
[17:03:40.109]                     is.null <- base::is.null
[17:03:40.109]                     muffled <- FALSE
[17:03:40.109]                     if (inherits(cond, "message")) {
[17:03:40.109]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.109]                       if (muffled) 
[17:03:40.109]                         invokeRestart("muffleMessage")
[17:03:40.109]                     }
[17:03:40.109]                     else if (inherits(cond, "warning")) {
[17:03:40.109]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.109]                       if (muffled) 
[17:03:40.109]                         invokeRestart("muffleWarning")
[17:03:40.109]                     }
[17:03:40.109]                     else if (inherits(cond, "condition")) {
[17:03:40.109]                       if (!is.null(pattern)) {
[17:03:40.109]                         computeRestarts <- base::computeRestarts
[17:03:40.109]                         grepl <- base::grepl
[17:03:40.109]                         restarts <- computeRestarts(cond)
[17:03:40.109]                         for (restart in restarts) {
[17:03:40.109]                           name <- restart$name
[17:03:40.109]                           if (is.null(name)) 
[17:03:40.109]                             next
[17:03:40.109]                           if (!grepl(pattern, name)) 
[17:03:40.109]                             next
[17:03:40.109]                           invokeRestart(restart)
[17:03:40.109]                           muffled <- TRUE
[17:03:40.109]                           break
[17:03:40.109]                         }
[17:03:40.109]                       }
[17:03:40.109]                     }
[17:03:40.109]                     invisible(muffled)
[17:03:40.109]                   }
[17:03:40.109]                   muffleCondition(cond)
[17:03:40.109]                 })
[17:03:40.109]             }))
[17:03:40.109]             future::FutureResult(value = ...future.value$value, 
[17:03:40.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.109]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.109]                     ...future.globalenv.names))
[17:03:40.109]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.109]         }, condition = base::local({
[17:03:40.109]             c <- base::c
[17:03:40.109]             inherits <- base::inherits
[17:03:40.109]             invokeRestart <- base::invokeRestart
[17:03:40.109]             length <- base::length
[17:03:40.109]             list <- base::list
[17:03:40.109]             seq.int <- base::seq.int
[17:03:40.109]             signalCondition <- base::signalCondition
[17:03:40.109]             sys.calls <- base::sys.calls
[17:03:40.109]             `[[` <- base::`[[`
[17:03:40.109]             `+` <- base::`+`
[17:03:40.109]             `<<-` <- base::`<<-`
[17:03:40.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.109]                   3L)]
[17:03:40.109]             }
[17:03:40.109]             function(cond) {
[17:03:40.109]                 is_error <- inherits(cond, "error")
[17:03:40.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.109]                   NULL)
[17:03:40.109]                 if (is_error) {
[17:03:40.109]                   sessionInformation <- function() {
[17:03:40.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.109]                       search = base::search(), system = base::Sys.info())
[17:03:40.109]                   }
[17:03:40.109]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.109]                     cond$call), session = sessionInformation(), 
[17:03:40.109]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.109]                   signalCondition(cond)
[17:03:40.109]                 }
[17:03:40.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.109]                 "immediateCondition"))) {
[17:03:40.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.109]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.109]                   if (TRUE && !signal) {
[17:03:40.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.109]                     {
[17:03:40.109]                       inherits <- base::inherits
[17:03:40.109]                       invokeRestart <- base::invokeRestart
[17:03:40.109]                       is.null <- base::is.null
[17:03:40.109]                       muffled <- FALSE
[17:03:40.109]                       if (inherits(cond, "message")) {
[17:03:40.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.109]                         if (muffled) 
[17:03:40.109]                           invokeRestart("muffleMessage")
[17:03:40.109]                       }
[17:03:40.109]                       else if (inherits(cond, "warning")) {
[17:03:40.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.109]                         if (muffled) 
[17:03:40.109]                           invokeRestart("muffleWarning")
[17:03:40.109]                       }
[17:03:40.109]                       else if (inherits(cond, "condition")) {
[17:03:40.109]                         if (!is.null(pattern)) {
[17:03:40.109]                           computeRestarts <- base::computeRestarts
[17:03:40.109]                           grepl <- base::grepl
[17:03:40.109]                           restarts <- computeRestarts(cond)
[17:03:40.109]                           for (restart in restarts) {
[17:03:40.109]                             name <- restart$name
[17:03:40.109]                             if (is.null(name)) 
[17:03:40.109]                               next
[17:03:40.109]                             if (!grepl(pattern, name)) 
[17:03:40.109]                               next
[17:03:40.109]                             invokeRestart(restart)
[17:03:40.109]                             muffled <- TRUE
[17:03:40.109]                             break
[17:03:40.109]                           }
[17:03:40.109]                         }
[17:03:40.109]                       }
[17:03:40.109]                       invisible(muffled)
[17:03:40.109]                     }
[17:03:40.109]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.109]                   }
[17:03:40.109]                 }
[17:03:40.109]                 else {
[17:03:40.109]                   if (TRUE) {
[17:03:40.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.109]                     {
[17:03:40.109]                       inherits <- base::inherits
[17:03:40.109]                       invokeRestart <- base::invokeRestart
[17:03:40.109]                       is.null <- base::is.null
[17:03:40.109]                       muffled <- FALSE
[17:03:40.109]                       if (inherits(cond, "message")) {
[17:03:40.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.109]                         if (muffled) 
[17:03:40.109]                           invokeRestart("muffleMessage")
[17:03:40.109]                       }
[17:03:40.109]                       else if (inherits(cond, "warning")) {
[17:03:40.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.109]                         if (muffled) 
[17:03:40.109]                           invokeRestart("muffleWarning")
[17:03:40.109]                       }
[17:03:40.109]                       else if (inherits(cond, "condition")) {
[17:03:40.109]                         if (!is.null(pattern)) {
[17:03:40.109]                           computeRestarts <- base::computeRestarts
[17:03:40.109]                           grepl <- base::grepl
[17:03:40.109]                           restarts <- computeRestarts(cond)
[17:03:40.109]                           for (restart in restarts) {
[17:03:40.109]                             name <- restart$name
[17:03:40.109]                             if (is.null(name)) 
[17:03:40.109]                               next
[17:03:40.109]                             if (!grepl(pattern, name)) 
[17:03:40.109]                               next
[17:03:40.109]                             invokeRestart(restart)
[17:03:40.109]                             muffled <- TRUE
[17:03:40.109]                             break
[17:03:40.109]                           }
[17:03:40.109]                         }
[17:03:40.109]                       }
[17:03:40.109]                       invisible(muffled)
[17:03:40.109]                     }
[17:03:40.109]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.109]                   }
[17:03:40.109]                 }
[17:03:40.109]             }
[17:03:40.109]         }))
[17:03:40.109]     }, error = function(ex) {
[17:03:40.109]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.109]                 ...future.rng), started = ...future.startTime, 
[17:03:40.109]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.109]             version = "1.8"), class = "FutureResult")
[17:03:40.109]     }, finally = {
[17:03:40.109]         if (!identical(...future.workdir, getwd())) 
[17:03:40.109]             setwd(...future.workdir)
[17:03:40.109]         {
[17:03:40.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.109]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.109]             }
[17:03:40.109]             base::options(...future.oldOptions)
[17:03:40.109]             if (.Platform$OS.type == "windows") {
[17:03:40.109]                 old_names <- names(...future.oldEnvVars)
[17:03:40.109]                 envs <- base::Sys.getenv()
[17:03:40.109]                 names <- names(envs)
[17:03:40.109]                 common <- intersect(names, old_names)
[17:03:40.109]                 added <- setdiff(names, old_names)
[17:03:40.109]                 removed <- setdiff(old_names, names)
[17:03:40.109]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.109]                   envs[common]]
[17:03:40.109]                 NAMES <- toupper(changed)
[17:03:40.109]                 args <- list()
[17:03:40.109]                 for (kk in seq_along(NAMES)) {
[17:03:40.109]                   name <- changed[[kk]]
[17:03:40.109]                   NAME <- NAMES[[kk]]
[17:03:40.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.109]                     next
[17:03:40.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.109]                 }
[17:03:40.109]                 NAMES <- toupper(added)
[17:03:40.109]                 for (kk in seq_along(NAMES)) {
[17:03:40.109]                   name <- added[[kk]]
[17:03:40.109]                   NAME <- NAMES[[kk]]
[17:03:40.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.109]                     next
[17:03:40.109]                   args[[name]] <- ""
[17:03:40.109]                 }
[17:03:40.109]                 NAMES <- toupper(removed)
[17:03:40.109]                 for (kk in seq_along(NAMES)) {
[17:03:40.109]                   name <- removed[[kk]]
[17:03:40.109]                   NAME <- NAMES[[kk]]
[17:03:40.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.109]                     next
[17:03:40.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.109]                 }
[17:03:40.109]                 if (length(args) > 0) 
[17:03:40.109]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.109]             }
[17:03:40.109]             else {
[17:03:40.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.109]             }
[17:03:40.109]             {
[17:03:40.109]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.109]                   0L) {
[17:03:40.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.109]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.109]                   base::options(opts)
[17:03:40.109]                 }
[17:03:40.109]                 {
[17:03:40.109]                   {
[17:03:40.109]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.109]                     NULL
[17:03:40.109]                   }
[17:03:40.109]                   options(future.plan = NULL)
[17:03:40.109]                   if (is.na(NA_character_)) 
[17:03:40.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.109]                     .init = FALSE)
[17:03:40.109]                 }
[17:03:40.109]             }
[17:03:40.109]         }
[17:03:40.109]     })
[17:03:40.109]     if (TRUE) {
[17:03:40.109]         base::sink(type = "output", split = FALSE)
[17:03:40.109]         if (TRUE) {
[17:03:40.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.109]         }
[17:03:40.109]         else {
[17:03:40.109]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.109]         }
[17:03:40.109]         base::close(...future.stdout)
[17:03:40.109]         ...future.stdout <- NULL
[17:03:40.109]     }
[17:03:40.109]     ...future.result$conditions <- ...future.conditions
[17:03:40.109]     ...future.result$finished <- base::Sys.time()
[17:03:40.109]     ...future.result
[17:03:40.109] }
[17:03:40.112] requestCore(): workers = 2
[17:03:40.113] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.124] result() for MulticoreFuture ...
[17:03:40.124] result() for MulticoreFuture ...
[17:03:40.125] result() for MulticoreFuture ... done
[17:03:40.125] result() for MulticoreFuture ... done
[17:03:40.125] result() for MulticoreFuture ...
[17:03:40.125] result() for MulticoreFuture ... done
[17:03:40.127] MulticoreFuture started
[17:03:40.128] - Launch lazy future ... done
[17:03:40.128] run() for ‘MulticoreFuture’ ... done
[17:03:40.129] plan(): Setting new future strategy stack:
[17:03:40.129] List of future strategies:
[17:03:40.129] 1. sequential:
[17:03:40.129]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.129]    - tweaked: FALSE
[17:03:40.129]    - call: NULL
[17:03:40.130] resolve() on environment ...
[17:03:40.130]  recursive: 0
[17:03:40.130] plan(): nbrOfWorkers() = 1
[17:03:40.131]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:03:40.132] Future #1
[17:03:40.133]  length: 2 (resolved future 1)
[17:03:40.133] plan(): Setting new future strategy stack:
[17:03:40.133] List of future strategies:
[17:03:40.133] 1. multicore:
[17:03:40.133]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.133]    - tweaked: FALSE
[17:03:40.133]    - call: plan(strategy)
[17:03:40.138] plan(): nbrOfWorkers() = 2
[17:03:40.139] Future #2
[17:03:40.139]  length: 1 (resolved future 2)
[17:03:40.139]  length: 0 (resolved future 3)
[17:03:40.139] resolve() on environment ... DONE
[17:03:40.140] getGlobalsAndPackages() ...
[17:03:40.140] Searching for globals...
[17:03:40.142] - globals found: [1] ‘{’
[17:03:40.142] Searching for globals ... DONE
[17:03:40.142] Resolving globals: FALSE
[17:03:40.143] 
[17:03:40.143] 
[17:03:40.143] getGlobalsAndPackages() ... DONE
[17:03:40.143] run() for ‘Future’ ...
[17:03:40.144] - state: ‘created’
[17:03:40.144] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.148] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.149] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.149]   - Field: ‘label’
[17:03:40.149]   - Field: ‘local’
[17:03:40.149]   - Field: ‘owner’
[17:03:40.149]   - Field: ‘envir’
[17:03:40.149]   - Field: ‘workers’
[17:03:40.150]   - Field: ‘packages’
[17:03:40.150]   - Field: ‘gc’
[17:03:40.150]   - Field: ‘job’
[17:03:40.150]   - Field: ‘conditions’
[17:03:40.150]   - Field: ‘expr’
[17:03:40.150]   - Field: ‘uuid’
[17:03:40.150]   - Field: ‘seed’
[17:03:40.151]   - Field: ‘version’
[17:03:40.151]   - Field: ‘result’
[17:03:40.151]   - Field: ‘asynchronous’
[17:03:40.151]   - Field: ‘calls’
[17:03:40.151]   - Field: ‘globals’
[17:03:40.151]   - Field: ‘stdout’
[17:03:40.151]   - Field: ‘earlySignal’
[17:03:40.152]   - Field: ‘lazy’
[17:03:40.152]   - Field: ‘state’
[17:03:40.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.152] - Launch lazy future ...
[17:03:40.152] Packages needed by the future expression (n = 0): <none>
[17:03:40.153] Packages needed by future strategies (n = 0): <none>
[17:03:40.153] {
[17:03:40.153]     {
[17:03:40.153]         {
[17:03:40.153]             ...future.startTime <- base::Sys.time()
[17:03:40.153]             {
[17:03:40.153]                 {
[17:03:40.153]                   {
[17:03:40.153]                     {
[17:03:40.153]                       base::local({
[17:03:40.153]                         has_future <- base::requireNamespace("future", 
[17:03:40.153]                           quietly = TRUE)
[17:03:40.153]                         if (has_future) {
[17:03:40.153]                           ns <- base::getNamespace("future")
[17:03:40.153]                           version <- ns[[".package"]][["version"]]
[17:03:40.153]                           if (is.null(version)) 
[17:03:40.153]                             version <- utils::packageVersion("future")
[17:03:40.153]                         }
[17:03:40.153]                         else {
[17:03:40.153]                           version <- NULL
[17:03:40.153]                         }
[17:03:40.153]                         if (!has_future || version < "1.8.0") {
[17:03:40.153]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.153]                             "", base::R.version$version.string), 
[17:03:40.153]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.153]                               "release", "version")], collapse = " "), 
[17:03:40.153]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.153]                             info)
[17:03:40.153]                           info <- base::paste(info, collapse = "; ")
[17:03:40.153]                           if (!has_future) {
[17:03:40.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.153]                               info)
[17:03:40.153]                           }
[17:03:40.153]                           else {
[17:03:40.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.153]                               info, version)
[17:03:40.153]                           }
[17:03:40.153]                           base::stop(msg)
[17:03:40.153]                         }
[17:03:40.153]                       })
[17:03:40.153]                     }
[17:03:40.153]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.153]                     base::options(mc.cores = 1L)
[17:03:40.153]                   }
[17:03:40.153]                   ...future.strategy.old <- future::plan("list")
[17:03:40.153]                   options(future.plan = NULL)
[17:03:40.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.153]                 }
[17:03:40.153]                 ...future.workdir <- getwd()
[17:03:40.153]             }
[17:03:40.153]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.153]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.153]         }
[17:03:40.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.153]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.153]             base::names(...future.oldOptions))
[17:03:40.153]     }
[17:03:40.153]     if (FALSE) {
[17:03:40.153]     }
[17:03:40.153]     else {
[17:03:40.153]         if (TRUE) {
[17:03:40.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.153]                 open = "w")
[17:03:40.153]         }
[17:03:40.153]         else {
[17:03:40.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.153]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.153]         }
[17:03:40.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.153]             base::sink(type = "output", split = FALSE)
[17:03:40.153]             base::close(...future.stdout)
[17:03:40.153]         }, add = TRUE)
[17:03:40.153]     }
[17:03:40.153]     ...future.frame <- base::sys.nframe()
[17:03:40.153]     ...future.conditions <- base::list()
[17:03:40.153]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.153]     if (FALSE) {
[17:03:40.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.153]     }
[17:03:40.153]     ...future.result <- base::tryCatch({
[17:03:40.153]         base::withCallingHandlers({
[17:03:40.153]             ...future.value <- base::withVisible(base::local({
[17:03:40.153]                 withCallingHandlers({
[17:03:40.153]                   {
[17:03:40.153]                     1
[17:03:40.153]                   }
[17:03:40.153]                 }, immediateCondition = function(cond) {
[17:03:40.153]                   save_rds <- function (object, pathname, ...) 
[17:03:40.153]                   {
[17:03:40.153]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.153]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.153]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.153]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.153]                         fi_tmp[["mtime"]])
[17:03:40.153]                     }
[17:03:40.153]                     tryCatch({
[17:03:40.153]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.153]                     }, error = function(ex) {
[17:03:40.153]                       msg <- conditionMessage(ex)
[17:03:40.153]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.153]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.153]                         fi_tmp[["mtime"]], msg)
[17:03:40.153]                       ex$message <- msg
[17:03:40.153]                       stop(ex)
[17:03:40.153]                     })
[17:03:40.153]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.153]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.153]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.153]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.153]                       fi <- file.info(pathname)
[17:03:40.153]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.153]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.153]                         fi[["size"]], fi[["mtime"]])
[17:03:40.153]                       stop(msg)
[17:03:40.153]                     }
[17:03:40.153]                     invisible(pathname)
[17:03:40.153]                   }
[17:03:40.153]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.153]                     rootPath = tempdir()) 
[17:03:40.153]                   {
[17:03:40.153]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.153]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.153]                       tmpdir = path, fileext = ".rds")
[17:03:40.153]                     save_rds(obj, file)
[17:03:40.153]                   }
[17:03:40.153]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.153]                   {
[17:03:40.153]                     inherits <- base::inherits
[17:03:40.153]                     invokeRestart <- base::invokeRestart
[17:03:40.153]                     is.null <- base::is.null
[17:03:40.153]                     muffled <- FALSE
[17:03:40.153]                     if (inherits(cond, "message")) {
[17:03:40.153]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.153]                       if (muffled) 
[17:03:40.153]                         invokeRestart("muffleMessage")
[17:03:40.153]                     }
[17:03:40.153]                     else if (inherits(cond, "warning")) {
[17:03:40.153]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.153]                       if (muffled) 
[17:03:40.153]                         invokeRestart("muffleWarning")
[17:03:40.153]                     }
[17:03:40.153]                     else if (inherits(cond, "condition")) {
[17:03:40.153]                       if (!is.null(pattern)) {
[17:03:40.153]                         computeRestarts <- base::computeRestarts
[17:03:40.153]                         grepl <- base::grepl
[17:03:40.153]                         restarts <- computeRestarts(cond)
[17:03:40.153]                         for (restart in restarts) {
[17:03:40.153]                           name <- restart$name
[17:03:40.153]                           if (is.null(name)) 
[17:03:40.153]                             next
[17:03:40.153]                           if (!grepl(pattern, name)) 
[17:03:40.153]                             next
[17:03:40.153]                           invokeRestart(restart)
[17:03:40.153]                           muffled <- TRUE
[17:03:40.153]                           break
[17:03:40.153]                         }
[17:03:40.153]                       }
[17:03:40.153]                     }
[17:03:40.153]                     invisible(muffled)
[17:03:40.153]                   }
[17:03:40.153]                   muffleCondition(cond)
[17:03:40.153]                 })
[17:03:40.153]             }))
[17:03:40.153]             future::FutureResult(value = ...future.value$value, 
[17:03:40.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.153]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.153]                     ...future.globalenv.names))
[17:03:40.153]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.153]         }, condition = base::local({
[17:03:40.153]             c <- base::c
[17:03:40.153]             inherits <- base::inherits
[17:03:40.153]             invokeRestart <- base::invokeRestart
[17:03:40.153]             length <- base::length
[17:03:40.153]             list <- base::list
[17:03:40.153]             seq.int <- base::seq.int
[17:03:40.153]             signalCondition <- base::signalCondition
[17:03:40.153]             sys.calls <- base::sys.calls
[17:03:40.153]             `[[` <- base::`[[`
[17:03:40.153]             `+` <- base::`+`
[17:03:40.153]             `<<-` <- base::`<<-`
[17:03:40.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.153]                   3L)]
[17:03:40.153]             }
[17:03:40.153]             function(cond) {
[17:03:40.153]                 is_error <- inherits(cond, "error")
[17:03:40.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.153]                   NULL)
[17:03:40.153]                 if (is_error) {
[17:03:40.153]                   sessionInformation <- function() {
[17:03:40.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.153]                       search = base::search(), system = base::Sys.info())
[17:03:40.153]                   }
[17:03:40.153]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.153]                     cond$call), session = sessionInformation(), 
[17:03:40.153]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.153]                   signalCondition(cond)
[17:03:40.153]                 }
[17:03:40.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.153]                 "immediateCondition"))) {
[17:03:40.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.153]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.153]                   if (TRUE && !signal) {
[17:03:40.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.153]                     {
[17:03:40.153]                       inherits <- base::inherits
[17:03:40.153]                       invokeRestart <- base::invokeRestart
[17:03:40.153]                       is.null <- base::is.null
[17:03:40.153]                       muffled <- FALSE
[17:03:40.153]                       if (inherits(cond, "message")) {
[17:03:40.153]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.153]                         if (muffled) 
[17:03:40.153]                           invokeRestart("muffleMessage")
[17:03:40.153]                       }
[17:03:40.153]                       else if (inherits(cond, "warning")) {
[17:03:40.153]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.153]                         if (muffled) 
[17:03:40.153]                           invokeRestart("muffleWarning")
[17:03:40.153]                       }
[17:03:40.153]                       else if (inherits(cond, "condition")) {
[17:03:40.153]                         if (!is.null(pattern)) {
[17:03:40.153]                           computeRestarts <- base::computeRestarts
[17:03:40.153]                           grepl <- base::grepl
[17:03:40.153]                           restarts <- computeRestarts(cond)
[17:03:40.153]                           for (restart in restarts) {
[17:03:40.153]                             name <- restart$name
[17:03:40.153]                             if (is.null(name)) 
[17:03:40.153]                               next
[17:03:40.153]                             if (!grepl(pattern, name)) 
[17:03:40.153]                               next
[17:03:40.153]                             invokeRestart(restart)
[17:03:40.153]                             muffled <- TRUE
[17:03:40.153]                             break
[17:03:40.153]                           }
[17:03:40.153]                         }
[17:03:40.153]                       }
[17:03:40.153]                       invisible(muffled)
[17:03:40.153]                     }
[17:03:40.153]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.153]                   }
[17:03:40.153]                 }
[17:03:40.153]                 else {
[17:03:40.153]                   if (TRUE) {
[17:03:40.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.153]                     {
[17:03:40.153]                       inherits <- base::inherits
[17:03:40.153]                       invokeRestart <- base::invokeRestart
[17:03:40.153]                       is.null <- base::is.null
[17:03:40.153]                       muffled <- FALSE
[17:03:40.153]                       if (inherits(cond, "message")) {
[17:03:40.153]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.153]                         if (muffled) 
[17:03:40.153]                           invokeRestart("muffleMessage")
[17:03:40.153]                       }
[17:03:40.153]                       else if (inherits(cond, "warning")) {
[17:03:40.153]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.153]                         if (muffled) 
[17:03:40.153]                           invokeRestart("muffleWarning")
[17:03:40.153]                       }
[17:03:40.153]                       else if (inherits(cond, "condition")) {
[17:03:40.153]                         if (!is.null(pattern)) {
[17:03:40.153]                           computeRestarts <- base::computeRestarts
[17:03:40.153]                           grepl <- base::grepl
[17:03:40.153]                           restarts <- computeRestarts(cond)
[17:03:40.153]                           for (restart in restarts) {
[17:03:40.153]                             name <- restart$name
[17:03:40.153]                             if (is.null(name)) 
[17:03:40.153]                               next
[17:03:40.153]                             if (!grepl(pattern, name)) 
[17:03:40.153]                               next
[17:03:40.153]                             invokeRestart(restart)
[17:03:40.153]                             muffled <- TRUE
[17:03:40.153]                             break
[17:03:40.153]                           }
[17:03:40.153]                         }
[17:03:40.153]                       }
[17:03:40.153]                       invisible(muffled)
[17:03:40.153]                     }
[17:03:40.153]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.153]                   }
[17:03:40.153]                 }
[17:03:40.153]             }
[17:03:40.153]         }))
[17:03:40.153]     }, error = function(ex) {
[17:03:40.153]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.153]                 ...future.rng), started = ...future.startTime, 
[17:03:40.153]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.153]             version = "1.8"), class = "FutureResult")
[17:03:40.153]     }, finally = {
[17:03:40.153]         if (!identical(...future.workdir, getwd())) 
[17:03:40.153]             setwd(...future.workdir)
[17:03:40.153]         {
[17:03:40.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.153]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.153]             }
[17:03:40.153]             base::options(...future.oldOptions)
[17:03:40.153]             if (.Platform$OS.type == "windows") {
[17:03:40.153]                 old_names <- names(...future.oldEnvVars)
[17:03:40.153]                 envs <- base::Sys.getenv()
[17:03:40.153]                 names <- names(envs)
[17:03:40.153]                 common <- intersect(names, old_names)
[17:03:40.153]                 added <- setdiff(names, old_names)
[17:03:40.153]                 removed <- setdiff(old_names, names)
[17:03:40.153]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.153]                   envs[common]]
[17:03:40.153]                 NAMES <- toupper(changed)
[17:03:40.153]                 args <- list()
[17:03:40.153]                 for (kk in seq_along(NAMES)) {
[17:03:40.153]                   name <- changed[[kk]]
[17:03:40.153]                   NAME <- NAMES[[kk]]
[17:03:40.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.153]                     next
[17:03:40.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.153]                 }
[17:03:40.153]                 NAMES <- toupper(added)
[17:03:40.153]                 for (kk in seq_along(NAMES)) {
[17:03:40.153]                   name <- added[[kk]]
[17:03:40.153]                   NAME <- NAMES[[kk]]
[17:03:40.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.153]                     next
[17:03:40.153]                   args[[name]] <- ""
[17:03:40.153]                 }
[17:03:40.153]                 NAMES <- toupper(removed)
[17:03:40.153]                 for (kk in seq_along(NAMES)) {
[17:03:40.153]                   name <- removed[[kk]]
[17:03:40.153]                   NAME <- NAMES[[kk]]
[17:03:40.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.153]                     next
[17:03:40.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.153]                 }
[17:03:40.153]                 if (length(args) > 0) 
[17:03:40.153]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.153]             }
[17:03:40.153]             else {
[17:03:40.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.153]             }
[17:03:40.153]             {
[17:03:40.153]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.153]                   0L) {
[17:03:40.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.153]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.153]                   base::options(opts)
[17:03:40.153]                 }
[17:03:40.153]                 {
[17:03:40.153]                   {
[17:03:40.153]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.153]                     NULL
[17:03:40.153]                   }
[17:03:40.153]                   options(future.plan = NULL)
[17:03:40.153]                   if (is.na(NA_character_)) 
[17:03:40.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.153]                     .init = FALSE)
[17:03:40.153]                 }
[17:03:40.153]             }
[17:03:40.153]         }
[17:03:40.153]     })
[17:03:40.153]     if (TRUE) {
[17:03:40.153]         base::sink(type = "output", split = FALSE)
[17:03:40.153]         if (TRUE) {
[17:03:40.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.153]         }
[17:03:40.153]         else {
[17:03:40.153]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.153]         }
[17:03:40.153]         base::close(...future.stdout)
[17:03:40.153]         ...future.stdout <- NULL
[17:03:40.153]     }
[17:03:40.153]     ...future.result$conditions <- ...future.conditions
[17:03:40.153]     ...future.result$finished <- base::Sys.time()
[17:03:40.153]     ...future.result
[17:03:40.153] }
[17:03:40.157] requestCore(): workers = 2
[17:03:40.157] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.168] result() for MulticoreFuture ...
[17:03:40.169] result() for MulticoreFuture ...
[17:03:40.169] result() for MulticoreFuture ... done
[17:03:40.169] result() for MulticoreFuture ... done
[17:03:40.169] result() for MulticoreFuture ...
[17:03:40.169] result() for MulticoreFuture ... done
[17:03:40.172] MulticoreFuture started
[17:03:40.172] - Launch lazy future ... done
[17:03:40.172] run() for ‘MulticoreFuture’ ... done
[17:03:40.173] plan(): Setting new future strategy stack:
[17:03:40.174] getGlobalsAndPackages() ...
[17:03:40.174] Searching for globals...
[17:03:40.173] List of future strategies:
[17:03:40.173] 1. sequential:
[17:03:40.173]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.173]    - tweaked: FALSE
[17:03:40.173]    - call: NULL
[17:03:40.175] plan(): nbrOfWorkers() = 1
[17:03:40.176] - globals found: [1] ‘{’
[17:03:40.176] Searching for globals ... DONE
[17:03:40.176] Resolving globals: FALSE
[17:03:40.177] 
[17:03:40.177] 
[17:03:40.178] getGlobalsAndPackages() ... DONE
[17:03:40.178] plan(): Setting new future strategy stack:
[17:03:40.178] List of future strategies:
[17:03:40.178] 1. multicore:
[17:03:40.178]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.178]    - tweaked: FALSE
[17:03:40.178]    - call: plan(strategy)
[17:03:40.184] run() for ‘Future’ ...
[17:03:40.184] - state: ‘created’
[17:03:40.185] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.189] plan(): nbrOfWorkers() = 2
[17:03:40.193] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.194]   - Field: ‘label’
[17:03:40.194]   - Field: ‘local’
[17:03:40.194]   - Field: ‘owner’
[17:03:40.194]   - Field: ‘envir’
[17:03:40.194]   - Field: ‘workers’
[17:03:40.194]   - Field: ‘packages’
[17:03:40.195]   - Field: ‘gc’
[17:03:40.195]   - Field: ‘job’
[17:03:40.195]   - Field: ‘conditions’
[17:03:40.195]   - Field: ‘expr’
[17:03:40.195]   - Field: ‘uuid’
[17:03:40.196]   - Field: ‘seed’
[17:03:40.196]   - Field: ‘version’
[17:03:40.196]   - Field: ‘result’
[17:03:40.196]   - Field: ‘asynchronous’
[17:03:40.196]   - Field: ‘calls’
[17:03:40.196]   - Field: ‘globals’
[17:03:40.196]   - Field: ‘stdout’
[17:03:40.197]   - Field: ‘earlySignal’
[17:03:40.197]   - Field: ‘lazy’
[17:03:40.197]   - Field: ‘state’
[17:03:40.197] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.197] - Launch lazy future ...
[17:03:40.198] Packages needed by the future expression (n = 0): <none>
[17:03:40.198] Packages needed by future strategies (n = 0): <none>
[17:03:40.199] {
[17:03:40.199]     {
[17:03:40.199]         {
[17:03:40.199]             ...future.startTime <- base::Sys.time()
[17:03:40.199]             {
[17:03:40.199]                 {
[17:03:40.199]                   {
[17:03:40.199]                     {
[17:03:40.199]                       base::local({
[17:03:40.199]                         has_future <- base::requireNamespace("future", 
[17:03:40.199]                           quietly = TRUE)
[17:03:40.199]                         if (has_future) {
[17:03:40.199]                           ns <- base::getNamespace("future")
[17:03:40.199]                           version <- ns[[".package"]][["version"]]
[17:03:40.199]                           if (is.null(version)) 
[17:03:40.199]                             version <- utils::packageVersion("future")
[17:03:40.199]                         }
[17:03:40.199]                         else {
[17:03:40.199]                           version <- NULL
[17:03:40.199]                         }
[17:03:40.199]                         if (!has_future || version < "1.8.0") {
[17:03:40.199]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.199]                             "", base::R.version$version.string), 
[17:03:40.199]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.199]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.199]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.199]                               "release", "version")], collapse = " "), 
[17:03:40.199]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.199]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.199]                             info)
[17:03:40.199]                           info <- base::paste(info, collapse = "; ")
[17:03:40.199]                           if (!has_future) {
[17:03:40.199]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.199]                               info)
[17:03:40.199]                           }
[17:03:40.199]                           else {
[17:03:40.199]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.199]                               info, version)
[17:03:40.199]                           }
[17:03:40.199]                           base::stop(msg)
[17:03:40.199]                         }
[17:03:40.199]                       })
[17:03:40.199]                     }
[17:03:40.199]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.199]                     base::options(mc.cores = 1L)
[17:03:40.199]                   }
[17:03:40.199]                   ...future.strategy.old <- future::plan("list")
[17:03:40.199]                   options(future.plan = NULL)
[17:03:40.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.199]                 }
[17:03:40.199]                 ...future.workdir <- getwd()
[17:03:40.199]             }
[17:03:40.199]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.199]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.199]         }
[17:03:40.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.199]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.199]             base::names(...future.oldOptions))
[17:03:40.199]     }
[17:03:40.199]     if (FALSE) {
[17:03:40.199]     }
[17:03:40.199]     else {
[17:03:40.199]         if (TRUE) {
[17:03:40.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.199]                 open = "w")
[17:03:40.199]         }
[17:03:40.199]         else {
[17:03:40.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.199]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.199]         }
[17:03:40.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.199]             base::sink(type = "output", split = FALSE)
[17:03:40.199]             base::close(...future.stdout)
[17:03:40.199]         }, add = TRUE)
[17:03:40.199]     }
[17:03:40.199]     ...future.frame <- base::sys.nframe()
[17:03:40.199]     ...future.conditions <- base::list()
[17:03:40.199]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.199]     if (FALSE) {
[17:03:40.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.199]     }
[17:03:40.199]     ...future.result <- base::tryCatch({
[17:03:40.199]         base::withCallingHandlers({
[17:03:40.199]             ...future.value <- base::withVisible(base::local({
[17:03:40.199]                 withCallingHandlers({
[17:03:40.199]                   {
[17:03:40.199]                     2
[17:03:40.199]                   }
[17:03:40.199]                 }, immediateCondition = function(cond) {
[17:03:40.199]                   save_rds <- function (object, pathname, ...) 
[17:03:40.199]                   {
[17:03:40.199]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.199]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.199]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.199]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.199]                         fi_tmp[["mtime"]])
[17:03:40.199]                     }
[17:03:40.199]                     tryCatch({
[17:03:40.199]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.199]                     }, error = function(ex) {
[17:03:40.199]                       msg <- conditionMessage(ex)
[17:03:40.199]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.199]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.199]                         fi_tmp[["mtime"]], msg)
[17:03:40.199]                       ex$message <- msg
[17:03:40.199]                       stop(ex)
[17:03:40.199]                     })
[17:03:40.199]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.199]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.199]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.199]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.199]                       fi <- file.info(pathname)
[17:03:40.199]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.199]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.199]                         fi[["size"]], fi[["mtime"]])
[17:03:40.199]                       stop(msg)
[17:03:40.199]                     }
[17:03:40.199]                     invisible(pathname)
[17:03:40.199]                   }
[17:03:40.199]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.199]                     rootPath = tempdir()) 
[17:03:40.199]                   {
[17:03:40.199]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.199]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.199]                       tmpdir = path, fileext = ".rds")
[17:03:40.199]                     save_rds(obj, file)
[17:03:40.199]                   }
[17:03:40.199]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.199]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.199]                   {
[17:03:40.199]                     inherits <- base::inherits
[17:03:40.199]                     invokeRestart <- base::invokeRestart
[17:03:40.199]                     is.null <- base::is.null
[17:03:40.199]                     muffled <- FALSE
[17:03:40.199]                     if (inherits(cond, "message")) {
[17:03:40.199]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.199]                       if (muffled) 
[17:03:40.199]                         invokeRestart("muffleMessage")
[17:03:40.199]                     }
[17:03:40.199]                     else if (inherits(cond, "warning")) {
[17:03:40.199]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.199]                       if (muffled) 
[17:03:40.199]                         invokeRestart("muffleWarning")
[17:03:40.199]                     }
[17:03:40.199]                     else if (inherits(cond, "condition")) {
[17:03:40.199]                       if (!is.null(pattern)) {
[17:03:40.199]                         computeRestarts <- base::computeRestarts
[17:03:40.199]                         grepl <- base::grepl
[17:03:40.199]                         restarts <- computeRestarts(cond)
[17:03:40.199]                         for (restart in restarts) {
[17:03:40.199]                           name <- restart$name
[17:03:40.199]                           if (is.null(name)) 
[17:03:40.199]                             next
[17:03:40.199]                           if (!grepl(pattern, name)) 
[17:03:40.199]                             next
[17:03:40.199]                           invokeRestart(restart)
[17:03:40.199]                           muffled <- TRUE
[17:03:40.199]                           break
[17:03:40.199]                         }
[17:03:40.199]                       }
[17:03:40.199]                     }
[17:03:40.199]                     invisible(muffled)
[17:03:40.199]                   }
[17:03:40.199]                   muffleCondition(cond)
[17:03:40.199]                 })
[17:03:40.199]             }))
[17:03:40.199]             future::FutureResult(value = ...future.value$value, 
[17:03:40.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.199]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.199]                     ...future.globalenv.names))
[17:03:40.199]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.199]         }, condition = base::local({
[17:03:40.199]             c <- base::c
[17:03:40.199]             inherits <- base::inherits
[17:03:40.199]             invokeRestart <- base::invokeRestart
[17:03:40.199]             length <- base::length
[17:03:40.199]             list <- base::list
[17:03:40.199]             seq.int <- base::seq.int
[17:03:40.199]             signalCondition <- base::signalCondition
[17:03:40.199]             sys.calls <- base::sys.calls
[17:03:40.199]             `[[` <- base::`[[`
[17:03:40.199]             `+` <- base::`+`
[17:03:40.199]             `<<-` <- base::`<<-`
[17:03:40.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.199]                   3L)]
[17:03:40.199]             }
[17:03:40.199]             function(cond) {
[17:03:40.199]                 is_error <- inherits(cond, "error")
[17:03:40.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.199]                   NULL)
[17:03:40.199]                 if (is_error) {
[17:03:40.199]                   sessionInformation <- function() {
[17:03:40.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.199]                       search = base::search(), system = base::Sys.info())
[17:03:40.199]                   }
[17:03:40.199]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.199]                     cond$call), session = sessionInformation(), 
[17:03:40.199]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.199]                   signalCondition(cond)
[17:03:40.199]                 }
[17:03:40.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.199]                 "immediateCondition"))) {
[17:03:40.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.199]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.199]                   if (TRUE && !signal) {
[17:03:40.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.199]                     {
[17:03:40.199]                       inherits <- base::inherits
[17:03:40.199]                       invokeRestart <- base::invokeRestart
[17:03:40.199]                       is.null <- base::is.null
[17:03:40.199]                       muffled <- FALSE
[17:03:40.199]                       if (inherits(cond, "message")) {
[17:03:40.199]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.199]                         if (muffled) 
[17:03:40.199]                           invokeRestart("muffleMessage")
[17:03:40.199]                       }
[17:03:40.199]                       else if (inherits(cond, "warning")) {
[17:03:40.199]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.199]                         if (muffled) 
[17:03:40.199]                           invokeRestart("muffleWarning")
[17:03:40.199]                       }
[17:03:40.199]                       else if (inherits(cond, "condition")) {
[17:03:40.199]                         if (!is.null(pattern)) {
[17:03:40.199]                           computeRestarts <- base::computeRestarts
[17:03:40.199]                           grepl <- base::grepl
[17:03:40.199]                           restarts <- computeRestarts(cond)
[17:03:40.199]                           for (restart in restarts) {
[17:03:40.199]                             name <- restart$name
[17:03:40.199]                             if (is.null(name)) 
[17:03:40.199]                               next
[17:03:40.199]                             if (!grepl(pattern, name)) 
[17:03:40.199]                               next
[17:03:40.199]                             invokeRestart(restart)
[17:03:40.199]                             muffled <- TRUE
[17:03:40.199]                             break
[17:03:40.199]                           }
[17:03:40.199]                         }
[17:03:40.199]                       }
[17:03:40.199]                       invisible(muffled)
[17:03:40.199]                     }
[17:03:40.199]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.199]                   }
[17:03:40.199]                 }
[17:03:40.199]                 else {
[17:03:40.199]                   if (TRUE) {
[17:03:40.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.199]                     {
[17:03:40.199]                       inherits <- base::inherits
[17:03:40.199]                       invokeRestart <- base::invokeRestart
[17:03:40.199]                       is.null <- base::is.null
[17:03:40.199]                       muffled <- FALSE
[17:03:40.199]                       if (inherits(cond, "message")) {
[17:03:40.199]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.199]                         if (muffled) 
[17:03:40.199]                           invokeRestart("muffleMessage")
[17:03:40.199]                       }
[17:03:40.199]                       else if (inherits(cond, "warning")) {
[17:03:40.199]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.199]                         if (muffled) 
[17:03:40.199]                           invokeRestart("muffleWarning")
[17:03:40.199]                       }
[17:03:40.199]                       else if (inherits(cond, "condition")) {
[17:03:40.199]                         if (!is.null(pattern)) {
[17:03:40.199]                           computeRestarts <- base::computeRestarts
[17:03:40.199]                           grepl <- base::grepl
[17:03:40.199]                           restarts <- computeRestarts(cond)
[17:03:40.199]                           for (restart in restarts) {
[17:03:40.199]                             name <- restart$name
[17:03:40.199]                             if (is.null(name)) 
[17:03:40.199]                               next
[17:03:40.199]                             if (!grepl(pattern, name)) 
[17:03:40.199]                               next
[17:03:40.199]                             invokeRestart(restart)
[17:03:40.199]                             muffled <- TRUE
[17:03:40.199]                             break
[17:03:40.199]                           }
[17:03:40.199]                         }
[17:03:40.199]                       }
[17:03:40.199]                       invisible(muffled)
[17:03:40.199]                     }
[17:03:40.199]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.199]                   }
[17:03:40.199]                 }
[17:03:40.199]             }
[17:03:40.199]         }))
[17:03:40.199]     }, error = function(ex) {
[17:03:40.199]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.199]                 ...future.rng), started = ...future.startTime, 
[17:03:40.199]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.199]             version = "1.8"), class = "FutureResult")
[17:03:40.199]     }, finally = {
[17:03:40.199]         if (!identical(...future.workdir, getwd())) 
[17:03:40.199]             setwd(...future.workdir)
[17:03:40.199]         {
[17:03:40.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.199]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.199]             }
[17:03:40.199]             base::options(...future.oldOptions)
[17:03:40.199]             if (.Platform$OS.type == "windows") {
[17:03:40.199]                 old_names <- names(...future.oldEnvVars)
[17:03:40.199]                 envs <- base::Sys.getenv()
[17:03:40.199]                 names <- names(envs)
[17:03:40.199]                 common <- intersect(names, old_names)
[17:03:40.199]                 added <- setdiff(names, old_names)
[17:03:40.199]                 removed <- setdiff(old_names, names)
[17:03:40.199]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.199]                   envs[common]]
[17:03:40.199]                 NAMES <- toupper(changed)
[17:03:40.199]                 args <- list()
[17:03:40.199]                 for (kk in seq_along(NAMES)) {
[17:03:40.199]                   name <- changed[[kk]]
[17:03:40.199]                   NAME <- NAMES[[kk]]
[17:03:40.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.199]                     next
[17:03:40.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.199]                 }
[17:03:40.199]                 NAMES <- toupper(added)
[17:03:40.199]                 for (kk in seq_along(NAMES)) {
[17:03:40.199]                   name <- added[[kk]]
[17:03:40.199]                   NAME <- NAMES[[kk]]
[17:03:40.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.199]                     next
[17:03:40.199]                   args[[name]] <- ""
[17:03:40.199]                 }
[17:03:40.199]                 NAMES <- toupper(removed)
[17:03:40.199]                 for (kk in seq_along(NAMES)) {
[17:03:40.199]                   name <- removed[[kk]]
[17:03:40.199]                   NAME <- NAMES[[kk]]
[17:03:40.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.199]                     next
[17:03:40.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.199]                 }
[17:03:40.199]                 if (length(args) > 0) 
[17:03:40.199]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.199]             }
[17:03:40.199]             else {
[17:03:40.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.199]             }
[17:03:40.199]             {
[17:03:40.199]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.199]                   0L) {
[17:03:40.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.199]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.199]                   base::options(opts)
[17:03:40.199]                 }
[17:03:40.199]                 {
[17:03:40.199]                   {
[17:03:40.199]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.199]                     NULL
[17:03:40.199]                   }
[17:03:40.199]                   options(future.plan = NULL)
[17:03:40.199]                   if (is.na(NA_character_)) 
[17:03:40.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.199]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.199]                     .init = FALSE)
[17:03:40.199]                 }
[17:03:40.199]             }
[17:03:40.199]         }
[17:03:40.199]     })
[17:03:40.199]     if (TRUE) {
[17:03:40.199]         base::sink(type = "output", split = FALSE)
[17:03:40.199]         if (TRUE) {
[17:03:40.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.199]         }
[17:03:40.199]         else {
[17:03:40.199]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.199]         }
[17:03:40.199]         base::close(...future.stdout)
[17:03:40.199]         ...future.stdout <- NULL
[17:03:40.199]     }
[17:03:40.199]     ...future.result$conditions <- ...future.conditions
[17:03:40.199]     ...future.result$finished <- base::Sys.time()
[17:03:40.199]     ...future.result
[17:03:40.199] }
[17:03:40.201] requestCore(): workers = 2
[17:03:40.202] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.212] result() for MulticoreFuture ...
[17:03:40.213] result() for MulticoreFuture ...
[17:03:40.213] result() for MulticoreFuture ... done
[17:03:40.213] result() for MulticoreFuture ... done
[17:03:40.214] result() for MulticoreFuture ...
[17:03:40.214] result() for MulticoreFuture ... done
[17:03:40.216] MulticoreFuture started
[17:03:40.217] - Launch lazy future ... done
[17:03:40.217] run() for ‘MulticoreFuture’ ... done
[17:03:40.218] plan(): Setting new future strategy stack:
[17:03:40.218] List of future strategies:
[17:03:40.218] 1. sequential:
[17:03:40.218]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.218]    - tweaked: FALSE
[17:03:40.218]    - call: NULL
[17:03:40.219] resolve() on environment ...
[17:03:40.219]  recursive: 0
[17:03:40.219] plan(): nbrOfWorkers() = 1
[17:03:40.220]  elements: [3] ‘a’
[17:03:40.221] Future #1
[17:03:40.222]  length: 2 (resolved future 1)
[17:03:40.222] plan(): Setting new future strategy stack:
[17:03:40.222] List of future strategies:
[17:03:40.222] 1. multicore:
[17:03:40.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.222]    - tweaked: FALSE
[17:03:40.222]    - call: plan(strategy)
[17:03:40.227] plan(): nbrOfWorkers() = 2
[17:03:40.228] Future #2
[17:03:40.228]  length: 1 (resolved future 2)
[17:03:40.228]  length: 0 (resolved future 3)
[17:03:40.228] resolve() on environment ... DONE
[17:03:40.229] resolve() on environment ...
[17:03:40.229]  recursive: 0
[17:03:40.230]  elements: [3] ‘b’
[17:03:40.230] Future #1
[17:03:40.231]  length: 2 (resolved future 1)
[17:03:40.231] Future #2
[17:03:40.231]  length: 1 (resolved future 2)
[17:03:40.231]  length: 0 (resolved future 3)
[17:03:40.231] resolve() on environment ... DONE
[17:03:40.232] resolve() on environment ...
[17:03:40.232]  recursive: 0
[17:03:40.233]  elements: [3] ‘c’
[17:03:40.233] Future #1
[17:03:40.233]  length: 2 (resolved future 1)
[17:03:40.234] Future #2
[17:03:40.234]  length: 1 (resolved future 2)
[17:03:40.234]  length: 0 (resolved future 3)
[17:03:40.234] resolve() on environment ... DONE
[17:03:40.235] resolve() on environment ...
[17:03:40.235]  recursive: 0
[17:03:40.236]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:03:40.236] Future #1
[17:03:40.236] result() for MulticoreFuture ...
[17:03:40.237] result() for MulticoreFuture ...
[17:03:40.237] result() for MulticoreFuture ... done
[17:03:40.237] result() for MulticoreFuture ... done
[17:03:40.238] result() for MulticoreFuture ...
[17:03:40.238] result() for MulticoreFuture ... done
[17:03:40.238]  length: 2 (resolved future 1)
[17:03:40.238] Future #2
[17:03:40.238] result() for MulticoreFuture ...
[17:03:40.239] result() for MulticoreFuture ...
[17:03:40.239] result() for MulticoreFuture ... done
[17:03:40.239] result() for MulticoreFuture ... done
[17:03:40.239] result() for MulticoreFuture ...
[17:03:40.240] result() for MulticoreFuture ... done
[17:03:40.240]  length: 1 (resolved future 2)
[17:03:40.240]  length: 0 (resolved future 3)
[17:03:40.240] resolve() on environment ... DONE
[17:03:40.241] resolve() on environment ...
[17:03:40.241]  recursive: 99
[17:03:40.241]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:03:40.242] Future #1
[17:03:40.242] result() for MulticoreFuture ...
[17:03:40.242] result() for MulticoreFuture ... done
[17:03:40.242] result() for MulticoreFuture ...
[17:03:40.242] result() for MulticoreFuture ... done
[17:03:40.242] A MulticoreFuture was resolved
[17:03:40.242]  length: 2 (resolved future 1)
[17:03:40.242] Future #2
[17:03:40.243] result() for MulticoreFuture ...
[17:03:40.243] result() for MulticoreFuture ... done
[17:03:40.243] result() for MulticoreFuture ...
[17:03:40.243] result() for MulticoreFuture ... done
[17:03:40.243] A MulticoreFuture was resolved
[17:03:40.243]  length: 1 (resolved future 2)
[17:03:40.243]  length: 0 (resolved future 3)
[17:03:40.243] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:03:40.244] resolve() on list environment ...
[17:03:40.244]  recursive: 0
[17:03:40.245]  length: 2
[17:03:40.245]  elements: ‘a’, ‘b’
[17:03:40.245]  length: 1 (resolved future 1)
[17:03:40.245]  length: 0 (resolved future 2)
[17:03:40.245] resolve() on list environment ... DONE
[17:03:40.246] getGlobalsAndPackages() ...
[17:03:40.246] Searching for globals...
[17:03:40.246] 
[17:03:40.246] Searching for globals ... DONE
[17:03:40.246] - globals: [0] <none>
[17:03:40.246] getGlobalsAndPackages() ... DONE
[17:03:40.247] run() for ‘Future’ ...
[17:03:40.247] - state: ‘created’
[17:03:40.247] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.251] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.251] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.251]   - Field: ‘label’
[17:03:40.252]   - Field: ‘local’
[17:03:40.252]   - Field: ‘owner’
[17:03:40.252]   - Field: ‘envir’
[17:03:40.254]   - Field: ‘workers’
[17:03:40.254]   - Field: ‘packages’
[17:03:40.254]   - Field: ‘gc’
[17:03:40.255]   - Field: ‘job’
[17:03:40.255]   - Field: ‘conditions’
[17:03:40.255]   - Field: ‘expr’
[17:03:40.255]   - Field: ‘uuid’
[17:03:40.255]   - Field: ‘seed’
[17:03:40.255]   - Field: ‘version’
[17:03:40.256]   - Field: ‘result’
[17:03:40.256]   - Field: ‘asynchronous’
[17:03:40.256]   - Field: ‘calls’
[17:03:40.256]   - Field: ‘globals’
[17:03:40.256]   - Field: ‘stdout’
[17:03:40.256]   - Field: ‘earlySignal’
[17:03:40.256]   - Field: ‘lazy’
[17:03:40.256]   - Field: ‘state’
[17:03:40.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.257] - Launch lazy future ...
[17:03:40.257] Packages needed by the future expression (n = 0): <none>
[17:03:40.257] Packages needed by future strategies (n = 0): <none>
[17:03:40.258] {
[17:03:40.258]     {
[17:03:40.258]         {
[17:03:40.258]             ...future.startTime <- base::Sys.time()
[17:03:40.258]             {
[17:03:40.258]                 {
[17:03:40.258]                   {
[17:03:40.258]                     {
[17:03:40.258]                       base::local({
[17:03:40.258]                         has_future <- base::requireNamespace("future", 
[17:03:40.258]                           quietly = TRUE)
[17:03:40.258]                         if (has_future) {
[17:03:40.258]                           ns <- base::getNamespace("future")
[17:03:40.258]                           version <- ns[[".package"]][["version"]]
[17:03:40.258]                           if (is.null(version)) 
[17:03:40.258]                             version <- utils::packageVersion("future")
[17:03:40.258]                         }
[17:03:40.258]                         else {
[17:03:40.258]                           version <- NULL
[17:03:40.258]                         }
[17:03:40.258]                         if (!has_future || version < "1.8.0") {
[17:03:40.258]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.258]                             "", base::R.version$version.string), 
[17:03:40.258]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.258]                               "release", "version")], collapse = " "), 
[17:03:40.258]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.258]                             info)
[17:03:40.258]                           info <- base::paste(info, collapse = "; ")
[17:03:40.258]                           if (!has_future) {
[17:03:40.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.258]                               info)
[17:03:40.258]                           }
[17:03:40.258]                           else {
[17:03:40.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.258]                               info, version)
[17:03:40.258]                           }
[17:03:40.258]                           base::stop(msg)
[17:03:40.258]                         }
[17:03:40.258]                       })
[17:03:40.258]                     }
[17:03:40.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.258]                     base::options(mc.cores = 1L)
[17:03:40.258]                   }
[17:03:40.258]                   ...future.strategy.old <- future::plan("list")
[17:03:40.258]                   options(future.plan = NULL)
[17:03:40.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.258]                 }
[17:03:40.258]                 ...future.workdir <- getwd()
[17:03:40.258]             }
[17:03:40.258]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.258]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.258]         }
[17:03:40.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.258]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.258]             base::names(...future.oldOptions))
[17:03:40.258]     }
[17:03:40.258]     if (FALSE) {
[17:03:40.258]     }
[17:03:40.258]     else {
[17:03:40.258]         if (TRUE) {
[17:03:40.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.258]                 open = "w")
[17:03:40.258]         }
[17:03:40.258]         else {
[17:03:40.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.258]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.258]         }
[17:03:40.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.258]             base::sink(type = "output", split = FALSE)
[17:03:40.258]             base::close(...future.stdout)
[17:03:40.258]         }, add = TRUE)
[17:03:40.258]     }
[17:03:40.258]     ...future.frame <- base::sys.nframe()
[17:03:40.258]     ...future.conditions <- base::list()
[17:03:40.258]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.258]     if (FALSE) {
[17:03:40.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.258]     }
[17:03:40.258]     ...future.result <- base::tryCatch({
[17:03:40.258]         base::withCallingHandlers({
[17:03:40.258]             ...future.value <- base::withVisible(base::local({
[17:03:40.258]                 withCallingHandlers({
[17:03:40.258]                   1
[17:03:40.258]                 }, immediateCondition = function(cond) {
[17:03:40.258]                   save_rds <- function (object, pathname, ...) 
[17:03:40.258]                   {
[17:03:40.258]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.258]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.258]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.258]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.258]                         fi_tmp[["mtime"]])
[17:03:40.258]                     }
[17:03:40.258]                     tryCatch({
[17:03:40.258]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.258]                     }, error = function(ex) {
[17:03:40.258]                       msg <- conditionMessage(ex)
[17:03:40.258]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.258]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.258]                         fi_tmp[["mtime"]], msg)
[17:03:40.258]                       ex$message <- msg
[17:03:40.258]                       stop(ex)
[17:03:40.258]                     })
[17:03:40.258]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.258]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.258]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.258]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.258]                       fi <- file.info(pathname)
[17:03:40.258]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.258]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.258]                         fi[["size"]], fi[["mtime"]])
[17:03:40.258]                       stop(msg)
[17:03:40.258]                     }
[17:03:40.258]                     invisible(pathname)
[17:03:40.258]                   }
[17:03:40.258]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.258]                     rootPath = tempdir()) 
[17:03:40.258]                   {
[17:03:40.258]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.258]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.258]                       tmpdir = path, fileext = ".rds")
[17:03:40.258]                     save_rds(obj, file)
[17:03:40.258]                   }
[17:03:40.258]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.258]                   {
[17:03:40.258]                     inherits <- base::inherits
[17:03:40.258]                     invokeRestart <- base::invokeRestart
[17:03:40.258]                     is.null <- base::is.null
[17:03:40.258]                     muffled <- FALSE
[17:03:40.258]                     if (inherits(cond, "message")) {
[17:03:40.258]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.258]                       if (muffled) 
[17:03:40.258]                         invokeRestart("muffleMessage")
[17:03:40.258]                     }
[17:03:40.258]                     else if (inherits(cond, "warning")) {
[17:03:40.258]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.258]                       if (muffled) 
[17:03:40.258]                         invokeRestart("muffleWarning")
[17:03:40.258]                     }
[17:03:40.258]                     else if (inherits(cond, "condition")) {
[17:03:40.258]                       if (!is.null(pattern)) {
[17:03:40.258]                         computeRestarts <- base::computeRestarts
[17:03:40.258]                         grepl <- base::grepl
[17:03:40.258]                         restarts <- computeRestarts(cond)
[17:03:40.258]                         for (restart in restarts) {
[17:03:40.258]                           name <- restart$name
[17:03:40.258]                           if (is.null(name)) 
[17:03:40.258]                             next
[17:03:40.258]                           if (!grepl(pattern, name)) 
[17:03:40.258]                             next
[17:03:40.258]                           invokeRestart(restart)
[17:03:40.258]                           muffled <- TRUE
[17:03:40.258]                           break
[17:03:40.258]                         }
[17:03:40.258]                       }
[17:03:40.258]                     }
[17:03:40.258]                     invisible(muffled)
[17:03:40.258]                   }
[17:03:40.258]                   muffleCondition(cond)
[17:03:40.258]                 })
[17:03:40.258]             }))
[17:03:40.258]             future::FutureResult(value = ...future.value$value, 
[17:03:40.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.258]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.258]                     ...future.globalenv.names))
[17:03:40.258]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.258]         }, condition = base::local({
[17:03:40.258]             c <- base::c
[17:03:40.258]             inherits <- base::inherits
[17:03:40.258]             invokeRestart <- base::invokeRestart
[17:03:40.258]             length <- base::length
[17:03:40.258]             list <- base::list
[17:03:40.258]             seq.int <- base::seq.int
[17:03:40.258]             signalCondition <- base::signalCondition
[17:03:40.258]             sys.calls <- base::sys.calls
[17:03:40.258]             `[[` <- base::`[[`
[17:03:40.258]             `+` <- base::`+`
[17:03:40.258]             `<<-` <- base::`<<-`
[17:03:40.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.258]                   3L)]
[17:03:40.258]             }
[17:03:40.258]             function(cond) {
[17:03:40.258]                 is_error <- inherits(cond, "error")
[17:03:40.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.258]                   NULL)
[17:03:40.258]                 if (is_error) {
[17:03:40.258]                   sessionInformation <- function() {
[17:03:40.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.258]                       search = base::search(), system = base::Sys.info())
[17:03:40.258]                   }
[17:03:40.258]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.258]                     cond$call), session = sessionInformation(), 
[17:03:40.258]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.258]                   signalCondition(cond)
[17:03:40.258]                 }
[17:03:40.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.258]                 "immediateCondition"))) {
[17:03:40.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.258]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.258]                   if (TRUE && !signal) {
[17:03:40.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.258]                     {
[17:03:40.258]                       inherits <- base::inherits
[17:03:40.258]                       invokeRestart <- base::invokeRestart
[17:03:40.258]                       is.null <- base::is.null
[17:03:40.258]                       muffled <- FALSE
[17:03:40.258]                       if (inherits(cond, "message")) {
[17:03:40.258]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.258]                         if (muffled) 
[17:03:40.258]                           invokeRestart("muffleMessage")
[17:03:40.258]                       }
[17:03:40.258]                       else if (inherits(cond, "warning")) {
[17:03:40.258]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.258]                         if (muffled) 
[17:03:40.258]                           invokeRestart("muffleWarning")
[17:03:40.258]                       }
[17:03:40.258]                       else if (inherits(cond, "condition")) {
[17:03:40.258]                         if (!is.null(pattern)) {
[17:03:40.258]                           computeRestarts <- base::computeRestarts
[17:03:40.258]                           grepl <- base::grepl
[17:03:40.258]                           restarts <- computeRestarts(cond)
[17:03:40.258]                           for (restart in restarts) {
[17:03:40.258]                             name <- restart$name
[17:03:40.258]                             if (is.null(name)) 
[17:03:40.258]                               next
[17:03:40.258]                             if (!grepl(pattern, name)) 
[17:03:40.258]                               next
[17:03:40.258]                             invokeRestart(restart)
[17:03:40.258]                             muffled <- TRUE
[17:03:40.258]                             break
[17:03:40.258]                           }
[17:03:40.258]                         }
[17:03:40.258]                       }
[17:03:40.258]                       invisible(muffled)
[17:03:40.258]                     }
[17:03:40.258]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.258]                   }
[17:03:40.258]                 }
[17:03:40.258]                 else {
[17:03:40.258]                   if (TRUE) {
[17:03:40.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.258]                     {
[17:03:40.258]                       inherits <- base::inherits
[17:03:40.258]                       invokeRestart <- base::invokeRestart
[17:03:40.258]                       is.null <- base::is.null
[17:03:40.258]                       muffled <- FALSE
[17:03:40.258]                       if (inherits(cond, "message")) {
[17:03:40.258]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.258]                         if (muffled) 
[17:03:40.258]                           invokeRestart("muffleMessage")
[17:03:40.258]                       }
[17:03:40.258]                       else if (inherits(cond, "warning")) {
[17:03:40.258]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.258]                         if (muffled) 
[17:03:40.258]                           invokeRestart("muffleWarning")
[17:03:40.258]                       }
[17:03:40.258]                       else if (inherits(cond, "condition")) {
[17:03:40.258]                         if (!is.null(pattern)) {
[17:03:40.258]                           computeRestarts <- base::computeRestarts
[17:03:40.258]                           grepl <- base::grepl
[17:03:40.258]                           restarts <- computeRestarts(cond)
[17:03:40.258]                           for (restart in restarts) {
[17:03:40.258]                             name <- restart$name
[17:03:40.258]                             if (is.null(name)) 
[17:03:40.258]                               next
[17:03:40.258]                             if (!grepl(pattern, name)) 
[17:03:40.258]                               next
[17:03:40.258]                             invokeRestart(restart)
[17:03:40.258]                             muffled <- TRUE
[17:03:40.258]                             break
[17:03:40.258]                           }
[17:03:40.258]                         }
[17:03:40.258]                       }
[17:03:40.258]                       invisible(muffled)
[17:03:40.258]                     }
[17:03:40.258]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.258]                   }
[17:03:40.258]                 }
[17:03:40.258]             }
[17:03:40.258]         }))
[17:03:40.258]     }, error = function(ex) {
[17:03:40.258]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.258]                 ...future.rng), started = ...future.startTime, 
[17:03:40.258]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.258]             version = "1.8"), class = "FutureResult")
[17:03:40.258]     }, finally = {
[17:03:40.258]         if (!identical(...future.workdir, getwd())) 
[17:03:40.258]             setwd(...future.workdir)
[17:03:40.258]         {
[17:03:40.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.258]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.258]             }
[17:03:40.258]             base::options(...future.oldOptions)
[17:03:40.258]             if (.Platform$OS.type == "windows") {
[17:03:40.258]                 old_names <- names(...future.oldEnvVars)
[17:03:40.258]                 envs <- base::Sys.getenv()
[17:03:40.258]                 names <- names(envs)
[17:03:40.258]                 common <- intersect(names, old_names)
[17:03:40.258]                 added <- setdiff(names, old_names)
[17:03:40.258]                 removed <- setdiff(old_names, names)
[17:03:40.258]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.258]                   envs[common]]
[17:03:40.258]                 NAMES <- toupper(changed)
[17:03:40.258]                 args <- list()
[17:03:40.258]                 for (kk in seq_along(NAMES)) {
[17:03:40.258]                   name <- changed[[kk]]
[17:03:40.258]                   NAME <- NAMES[[kk]]
[17:03:40.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.258]                     next
[17:03:40.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.258]                 }
[17:03:40.258]                 NAMES <- toupper(added)
[17:03:40.258]                 for (kk in seq_along(NAMES)) {
[17:03:40.258]                   name <- added[[kk]]
[17:03:40.258]                   NAME <- NAMES[[kk]]
[17:03:40.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.258]                     next
[17:03:40.258]                   args[[name]] <- ""
[17:03:40.258]                 }
[17:03:40.258]                 NAMES <- toupper(removed)
[17:03:40.258]                 for (kk in seq_along(NAMES)) {
[17:03:40.258]                   name <- removed[[kk]]
[17:03:40.258]                   NAME <- NAMES[[kk]]
[17:03:40.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.258]                     next
[17:03:40.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.258]                 }
[17:03:40.258]                 if (length(args) > 0) 
[17:03:40.258]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.258]             }
[17:03:40.258]             else {
[17:03:40.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.258]             }
[17:03:40.258]             {
[17:03:40.258]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.258]                   0L) {
[17:03:40.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.258]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.258]                   base::options(opts)
[17:03:40.258]                 }
[17:03:40.258]                 {
[17:03:40.258]                   {
[17:03:40.258]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.258]                     NULL
[17:03:40.258]                   }
[17:03:40.258]                   options(future.plan = NULL)
[17:03:40.258]                   if (is.na(NA_character_)) 
[17:03:40.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.258]                     .init = FALSE)
[17:03:40.258]                 }
[17:03:40.258]             }
[17:03:40.258]         }
[17:03:40.258]     })
[17:03:40.258]     if (TRUE) {
[17:03:40.258]         base::sink(type = "output", split = FALSE)
[17:03:40.258]         if (TRUE) {
[17:03:40.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.258]         }
[17:03:40.258]         else {
[17:03:40.258]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.258]         }
[17:03:40.258]         base::close(...future.stdout)
[17:03:40.258]         ...future.stdout <- NULL
[17:03:40.258]     }
[17:03:40.258]     ...future.result$conditions <- ...future.conditions
[17:03:40.258]     ...future.result$finished <- base::Sys.time()
[17:03:40.258]     ...future.result
[17:03:40.258] }
[17:03:40.260] requestCore(): workers = 2
[17:03:40.262] MulticoreFuture started
[17:03:40.263] - Launch lazy future ... done
[17:03:40.263] run() for ‘MulticoreFuture’ ... done
[17:03:40.263] plan(): Setting new future strategy stack:
[17:03:40.264] getGlobalsAndPackages() ...
[17:03:40.264] Searching for globals...
[17:03:40.264] List of future strategies:
[17:03:40.264] 1. sequential:
[17:03:40.264]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.264]    - tweaked: FALSE
[17:03:40.264]    - call: NULL
[17:03:40.265] plan(): nbrOfWorkers() = 1
[17:03:40.265] 
[17:03:40.265] Searching for globals ... DONE
[17:03:40.265] - globals: [0] <none>
[17:03:40.265] getGlobalsAndPackages() ... DONE
[17:03:40.266] run() for ‘Future’ ...
[17:03:40.266] - state: ‘created’
[17:03:40.266] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.267] plan(): Setting new future strategy stack:
[17:03:40.267] List of future strategies:
[17:03:40.267] 1. multicore:
[17:03:40.267]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.267]    - tweaked: FALSE
[17:03:40.267]    - call: plan(strategy)
[17:03:40.272] plan(): nbrOfWorkers() = 2
[17:03:40.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.273] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.273]   - Field: ‘label’
[17:03:40.273]   - Field: ‘local’
[17:03:40.273]   - Field: ‘owner’
[17:03:40.273]   - Field: ‘envir’
[17:03:40.273]   - Field: ‘workers’
[17:03:40.274]   - Field: ‘packages’
[17:03:40.274]   - Field: ‘gc’
[17:03:40.274]   - Field: ‘job’
[17:03:40.274]   - Field: ‘conditions’
[17:03:40.274]   - Field: ‘expr’
[17:03:40.274]   - Field: ‘uuid’
[17:03:40.275]   - Field: ‘seed’
[17:03:40.275]   - Field: ‘version’
[17:03:40.275]   - Field: ‘result’
[17:03:40.275]   - Field: ‘asynchronous’
[17:03:40.275]   - Field: ‘calls’
[17:03:40.275]   - Field: ‘globals’
[17:03:40.275]   - Field: ‘stdout’
[17:03:40.276]   - Field: ‘earlySignal’
[17:03:40.276]   - Field: ‘lazy’
[17:03:40.276]   - Field: ‘state’
[17:03:40.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.276] - Launch lazy future ...
[17:03:40.277] Packages needed by the future expression (n = 0): <none>
[17:03:40.277] Packages needed by future strategies (n = 0): <none>
[17:03:40.277] {
[17:03:40.277]     {
[17:03:40.277]         {
[17:03:40.277]             ...future.startTime <- base::Sys.time()
[17:03:40.277]             {
[17:03:40.277]                 {
[17:03:40.277]                   {
[17:03:40.277]                     {
[17:03:40.277]                       base::local({
[17:03:40.277]                         has_future <- base::requireNamespace("future", 
[17:03:40.277]                           quietly = TRUE)
[17:03:40.277]                         if (has_future) {
[17:03:40.277]                           ns <- base::getNamespace("future")
[17:03:40.277]                           version <- ns[[".package"]][["version"]]
[17:03:40.277]                           if (is.null(version)) 
[17:03:40.277]                             version <- utils::packageVersion("future")
[17:03:40.277]                         }
[17:03:40.277]                         else {
[17:03:40.277]                           version <- NULL
[17:03:40.277]                         }
[17:03:40.277]                         if (!has_future || version < "1.8.0") {
[17:03:40.277]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.277]                             "", base::R.version$version.string), 
[17:03:40.277]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.277]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.277]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.277]                               "release", "version")], collapse = " "), 
[17:03:40.277]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.277]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.277]                             info)
[17:03:40.277]                           info <- base::paste(info, collapse = "; ")
[17:03:40.277]                           if (!has_future) {
[17:03:40.277]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.277]                               info)
[17:03:40.277]                           }
[17:03:40.277]                           else {
[17:03:40.277]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.277]                               info, version)
[17:03:40.277]                           }
[17:03:40.277]                           base::stop(msg)
[17:03:40.277]                         }
[17:03:40.277]                       })
[17:03:40.277]                     }
[17:03:40.277]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.277]                     base::options(mc.cores = 1L)
[17:03:40.277]                   }
[17:03:40.277]                   ...future.strategy.old <- future::plan("list")
[17:03:40.277]                   options(future.plan = NULL)
[17:03:40.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.277]                 }
[17:03:40.277]                 ...future.workdir <- getwd()
[17:03:40.277]             }
[17:03:40.277]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.277]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.277]         }
[17:03:40.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.277]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.277]             base::names(...future.oldOptions))
[17:03:40.277]     }
[17:03:40.277]     if (FALSE) {
[17:03:40.277]     }
[17:03:40.277]     else {
[17:03:40.277]         if (TRUE) {
[17:03:40.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.277]                 open = "w")
[17:03:40.277]         }
[17:03:40.277]         else {
[17:03:40.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.277]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.277]         }
[17:03:40.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.277]             base::sink(type = "output", split = FALSE)
[17:03:40.277]             base::close(...future.stdout)
[17:03:40.277]         }, add = TRUE)
[17:03:40.277]     }
[17:03:40.277]     ...future.frame <- base::sys.nframe()
[17:03:40.277]     ...future.conditions <- base::list()
[17:03:40.277]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.277]     if (FALSE) {
[17:03:40.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.277]     }
[17:03:40.277]     ...future.result <- base::tryCatch({
[17:03:40.277]         base::withCallingHandlers({
[17:03:40.277]             ...future.value <- base::withVisible(base::local({
[17:03:40.277]                 withCallingHandlers({
[17:03:40.277]                   2
[17:03:40.277]                 }, immediateCondition = function(cond) {
[17:03:40.277]                   save_rds <- function (object, pathname, ...) 
[17:03:40.277]                   {
[17:03:40.277]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.277]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.277]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.277]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.277]                         fi_tmp[["mtime"]])
[17:03:40.277]                     }
[17:03:40.277]                     tryCatch({
[17:03:40.277]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.277]                     }, error = function(ex) {
[17:03:40.277]                       msg <- conditionMessage(ex)
[17:03:40.277]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.277]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.277]                         fi_tmp[["mtime"]], msg)
[17:03:40.277]                       ex$message <- msg
[17:03:40.277]                       stop(ex)
[17:03:40.277]                     })
[17:03:40.277]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.277]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.277]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.277]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.277]                       fi <- file.info(pathname)
[17:03:40.277]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.277]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.277]                         fi[["size"]], fi[["mtime"]])
[17:03:40.277]                       stop(msg)
[17:03:40.277]                     }
[17:03:40.277]                     invisible(pathname)
[17:03:40.277]                   }
[17:03:40.277]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.277]                     rootPath = tempdir()) 
[17:03:40.277]                   {
[17:03:40.277]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.277]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.277]                       tmpdir = path, fileext = ".rds")
[17:03:40.277]                     save_rds(obj, file)
[17:03:40.277]                   }
[17:03:40.277]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.277]                   {
[17:03:40.277]                     inherits <- base::inherits
[17:03:40.277]                     invokeRestart <- base::invokeRestart
[17:03:40.277]                     is.null <- base::is.null
[17:03:40.277]                     muffled <- FALSE
[17:03:40.277]                     if (inherits(cond, "message")) {
[17:03:40.277]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.277]                       if (muffled) 
[17:03:40.277]                         invokeRestart("muffleMessage")
[17:03:40.277]                     }
[17:03:40.277]                     else if (inherits(cond, "warning")) {
[17:03:40.277]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.277]                       if (muffled) 
[17:03:40.277]                         invokeRestart("muffleWarning")
[17:03:40.277]                     }
[17:03:40.277]                     else if (inherits(cond, "condition")) {
[17:03:40.277]                       if (!is.null(pattern)) {
[17:03:40.277]                         computeRestarts <- base::computeRestarts
[17:03:40.277]                         grepl <- base::grepl
[17:03:40.277]                         restarts <- computeRestarts(cond)
[17:03:40.277]                         for (restart in restarts) {
[17:03:40.277]                           name <- restart$name
[17:03:40.277]                           if (is.null(name)) 
[17:03:40.277]                             next
[17:03:40.277]                           if (!grepl(pattern, name)) 
[17:03:40.277]                             next
[17:03:40.277]                           invokeRestart(restart)
[17:03:40.277]                           muffled <- TRUE
[17:03:40.277]                           break
[17:03:40.277]                         }
[17:03:40.277]                       }
[17:03:40.277]                     }
[17:03:40.277]                     invisible(muffled)
[17:03:40.277]                   }
[17:03:40.277]                   muffleCondition(cond)
[17:03:40.277]                 })
[17:03:40.277]             }))
[17:03:40.277]             future::FutureResult(value = ...future.value$value, 
[17:03:40.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.277]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.277]                     ...future.globalenv.names))
[17:03:40.277]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.277]         }, condition = base::local({
[17:03:40.277]             c <- base::c
[17:03:40.277]             inherits <- base::inherits
[17:03:40.277]             invokeRestart <- base::invokeRestart
[17:03:40.277]             length <- base::length
[17:03:40.277]             list <- base::list
[17:03:40.277]             seq.int <- base::seq.int
[17:03:40.277]             signalCondition <- base::signalCondition
[17:03:40.277]             sys.calls <- base::sys.calls
[17:03:40.277]             `[[` <- base::`[[`
[17:03:40.277]             `+` <- base::`+`
[17:03:40.277]             `<<-` <- base::`<<-`
[17:03:40.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.277]                   3L)]
[17:03:40.277]             }
[17:03:40.277]             function(cond) {
[17:03:40.277]                 is_error <- inherits(cond, "error")
[17:03:40.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.277]                   NULL)
[17:03:40.277]                 if (is_error) {
[17:03:40.277]                   sessionInformation <- function() {
[17:03:40.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.277]                       search = base::search(), system = base::Sys.info())
[17:03:40.277]                   }
[17:03:40.277]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.277]                     cond$call), session = sessionInformation(), 
[17:03:40.277]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.277]                   signalCondition(cond)
[17:03:40.277]                 }
[17:03:40.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.277]                 "immediateCondition"))) {
[17:03:40.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.277]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.277]                   if (TRUE && !signal) {
[17:03:40.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.277]                     {
[17:03:40.277]                       inherits <- base::inherits
[17:03:40.277]                       invokeRestart <- base::invokeRestart
[17:03:40.277]                       is.null <- base::is.null
[17:03:40.277]                       muffled <- FALSE
[17:03:40.277]                       if (inherits(cond, "message")) {
[17:03:40.277]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.277]                         if (muffled) 
[17:03:40.277]                           invokeRestart("muffleMessage")
[17:03:40.277]                       }
[17:03:40.277]                       else if (inherits(cond, "warning")) {
[17:03:40.277]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.277]                         if (muffled) 
[17:03:40.277]                           invokeRestart("muffleWarning")
[17:03:40.277]                       }
[17:03:40.277]                       else if (inherits(cond, "condition")) {
[17:03:40.277]                         if (!is.null(pattern)) {
[17:03:40.277]                           computeRestarts <- base::computeRestarts
[17:03:40.277]                           grepl <- base::grepl
[17:03:40.277]                           restarts <- computeRestarts(cond)
[17:03:40.277]                           for (restart in restarts) {
[17:03:40.277]                             name <- restart$name
[17:03:40.277]                             if (is.null(name)) 
[17:03:40.277]                               next
[17:03:40.277]                             if (!grepl(pattern, name)) 
[17:03:40.277]                               next
[17:03:40.277]                             invokeRestart(restart)
[17:03:40.277]                             muffled <- TRUE
[17:03:40.277]                             break
[17:03:40.277]                           }
[17:03:40.277]                         }
[17:03:40.277]                       }
[17:03:40.277]                       invisible(muffled)
[17:03:40.277]                     }
[17:03:40.277]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.277]                   }
[17:03:40.277]                 }
[17:03:40.277]                 else {
[17:03:40.277]                   if (TRUE) {
[17:03:40.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.277]                     {
[17:03:40.277]                       inherits <- base::inherits
[17:03:40.277]                       invokeRestart <- base::invokeRestart
[17:03:40.277]                       is.null <- base::is.null
[17:03:40.277]                       muffled <- FALSE
[17:03:40.277]                       if (inherits(cond, "message")) {
[17:03:40.277]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.277]                         if (muffled) 
[17:03:40.277]                           invokeRestart("muffleMessage")
[17:03:40.277]                       }
[17:03:40.277]                       else if (inherits(cond, "warning")) {
[17:03:40.277]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.277]                         if (muffled) 
[17:03:40.277]                           invokeRestart("muffleWarning")
[17:03:40.277]                       }
[17:03:40.277]                       else if (inherits(cond, "condition")) {
[17:03:40.277]                         if (!is.null(pattern)) {
[17:03:40.277]                           computeRestarts <- base::computeRestarts
[17:03:40.277]                           grepl <- base::grepl
[17:03:40.277]                           restarts <- computeRestarts(cond)
[17:03:40.277]                           for (restart in restarts) {
[17:03:40.277]                             name <- restart$name
[17:03:40.277]                             if (is.null(name)) 
[17:03:40.277]                               next
[17:03:40.277]                             if (!grepl(pattern, name)) 
[17:03:40.277]                               next
[17:03:40.277]                             invokeRestart(restart)
[17:03:40.277]                             muffled <- TRUE
[17:03:40.277]                             break
[17:03:40.277]                           }
[17:03:40.277]                         }
[17:03:40.277]                       }
[17:03:40.277]                       invisible(muffled)
[17:03:40.277]                     }
[17:03:40.277]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.277]                   }
[17:03:40.277]                 }
[17:03:40.277]             }
[17:03:40.277]         }))
[17:03:40.277]     }, error = function(ex) {
[17:03:40.277]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.277]                 ...future.rng), started = ...future.startTime, 
[17:03:40.277]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.277]             version = "1.8"), class = "FutureResult")
[17:03:40.277]     }, finally = {
[17:03:40.277]         if (!identical(...future.workdir, getwd())) 
[17:03:40.277]             setwd(...future.workdir)
[17:03:40.277]         {
[17:03:40.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.277]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.277]             }
[17:03:40.277]             base::options(...future.oldOptions)
[17:03:40.277]             if (.Platform$OS.type == "windows") {
[17:03:40.277]                 old_names <- names(...future.oldEnvVars)
[17:03:40.277]                 envs <- base::Sys.getenv()
[17:03:40.277]                 names <- names(envs)
[17:03:40.277]                 common <- intersect(names, old_names)
[17:03:40.277]                 added <- setdiff(names, old_names)
[17:03:40.277]                 removed <- setdiff(old_names, names)
[17:03:40.277]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.277]                   envs[common]]
[17:03:40.277]                 NAMES <- toupper(changed)
[17:03:40.277]                 args <- list()
[17:03:40.277]                 for (kk in seq_along(NAMES)) {
[17:03:40.277]                   name <- changed[[kk]]
[17:03:40.277]                   NAME <- NAMES[[kk]]
[17:03:40.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.277]                     next
[17:03:40.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.277]                 }
[17:03:40.277]                 NAMES <- toupper(added)
[17:03:40.277]                 for (kk in seq_along(NAMES)) {
[17:03:40.277]                   name <- added[[kk]]
[17:03:40.277]                   NAME <- NAMES[[kk]]
[17:03:40.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.277]                     next
[17:03:40.277]                   args[[name]] <- ""
[17:03:40.277]                 }
[17:03:40.277]                 NAMES <- toupper(removed)
[17:03:40.277]                 for (kk in seq_along(NAMES)) {
[17:03:40.277]                   name <- removed[[kk]]
[17:03:40.277]                   NAME <- NAMES[[kk]]
[17:03:40.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.277]                     next
[17:03:40.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.277]                 }
[17:03:40.277]                 if (length(args) > 0) 
[17:03:40.277]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.277]             }
[17:03:40.277]             else {
[17:03:40.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.277]             }
[17:03:40.277]             {
[17:03:40.277]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.277]                   0L) {
[17:03:40.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.277]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.277]                   base::options(opts)
[17:03:40.277]                 }
[17:03:40.277]                 {
[17:03:40.277]                   {
[17:03:40.277]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.277]                     NULL
[17:03:40.277]                   }
[17:03:40.277]                   options(future.plan = NULL)
[17:03:40.277]                   if (is.na(NA_character_)) 
[17:03:40.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.277]                     .init = FALSE)
[17:03:40.277]                 }
[17:03:40.277]             }
[17:03:40.277]         }
[17:03:40.277]     })
[17:03:40.277]     if (TRUE) {
[17:03:40.277]         base::sink(type = "output", split = FALSE)
[17:03:40.277]         if (TRUE) {
[17:03:40.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.277]         }
[17:03:40.277]         else {
[17:03:40.277]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.277]         }
[17:03:40.277]         base::close(...future.stdout)
[17:03:40.277]         ...future.stdout <- NULL
[17:03:40.277]     }
[17:03:40.277]     ...future.result$conditions <- ...future.conditions
[17:03:40.277]     ...future.result$finished <- base::Sys.time()
[17:03:40.277]     ...future.result
[17:03:40.277] }
[17:03:40.281] requestCore(): workers = 2
[17:03:40.284] MulticoreFuture started
[17:03:40.284] - Launch lazy future ... done
[17:03:40.284] run() for ‘MulticoreFuture’ ... done
[17:03:40.285] plan(): Setting new future strategy stack:
[17:03:40.285] resolve() on list environment ...
[17:03:40.285] List of future strategies:
[17:03:40.285] 1. sequential:
[17:03:40.285]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.285]    - tweaked: FALSE
[17:03:40.285]    - call: NULL
[17:03:40.286]  recursive: 0
[17:03:40.286] plan(): nbrOfWorkers() = 1
[17:03:40.287]  length: 3
[17:03:40.287]  elements: ‘a’, ‘b’, ‘c’
[17:03:40.287] Future #1
[17:03:40.288]  length: 2 (resolved future 1)
[17:03:40.288] plan(): Setting new future strategy stack:
[17:03:40.288] List of future strategies:
[17:03:40.288] 1. multicore:
[17:03:40.288]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.288]    - tweaked: FALSE
[17:03:40.288]    - call: plan(strategy)
[17:03:40.293] plan(): nbrOfWorkers() = 2
[17:03:40.294] Future #2
[17:03:40.294]  length: 1 (resolved future 2)
[17:03:40.294]  length: 0 (resolved future 3)
[17:03:40.294] resolve() on list environment ... DONE
[17:03:40.295] getGlobalsAndPackages() ...
[17:03:40.296] Searching for globals...
[17:03:40.297] - globals found: [1] ‘{’
[17:03:40.297] Searching for globals ... DONE
[17:03:40.297] Resolving globals: FALSE
[17:03:40.298] 
[17:03:40.298] 
[17:03:40.298] getGlobalsAndPackages() ... DONE
[17:03:40.299] run() for ‘Future’ ...
[17:03:40.299] - state: ‘created’
[17:03:40.299] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.304] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.304]   - Field: ‘label’
[17:03:40.304]   - Field: ‘local’
[17:03:40.304]   - Field: ‘owner’
[17:03:40.305]   - Field: ‘envir’
[17:03:40.305]   - Field: ‘workers’
[17:03:40.305]   - Field: ‘packages’
[17:03:40.305]   - Field: ‘gc’
[17:03:40.305]   - Field: ‘job’
[17:03:40.305]   - Field: ‘conditions’
[17:03:40.305]   - Field: ‘expr’
[17:03:40.306]   - Field: ‘uuid’
[17:03:40.306]   - Field: ‘seed’
[17:03:40.306]   - Field: ‘version’
[17:03:40.306]   - Field: ‘result’
[17:03:40.306]   - Field: ‘asynchronous’
[17:03:40.306]   - Field: ‘calls’
[17:03:40.306]   - Field: ‘globals’
[17:03:40.307]   - Field: ‘stdout’
[17:03:40.307]   - Field: ‘earlySignal’
[17:03:40.307]   - Field: ‘lazy’
[17:03:40.307]   - Field: ‘state’
[17:03:40.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.307] - Launch lazy future ...
[17:03:40.308] Packages needed by the future expression (n = 0): <none>
[17:03:40.308] Packages needed by future strategies (n = 0): <none>
[17:03:40.309] {
[17:03:40.309]     {
[17:03:40.309]         {
[17:03:40.309]             ...future.startTime <- base::Sys.time()
[17:03:40.309]             {
[17:03:40.309]                 {
[17:03:40.309]                   {
[17:03:40.309]                     {
[17:03:40.309]                       base::local({
[17:03:40.309]                         has_future <- base::requireNamespace("future", 
[17:03:40.309]                           quietly = TRUE)
[17:03:40.309]                         if (has_future) {
[17:03:40.309]                           ns <- base::getNamespace("future")
[17:03:40.309]                           version <- ns[[".package"]][["version"]]
[17:03:40.309]                           if (is.null(version)) 
[17:03:40.309]                             version <- utils::packageVersion("future")
[17:03:40.309]                         }
[17:03:40.309]                         else {
[17:03:40.309]                           version <- NULL
[17:03:40.309]                         }
[17:03:40.309]                         if (!has_future || version < "1.8.0") {
[17:03:40.309]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.309]                             "", base::R.version$version.string), 
[17:03:40.309]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.309]                               "release", "version")], collapse = " "), 
[17:03:40.309]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.309]                             info)
[17:03:40.309]                           info <- base::paste(info, collapse = "; ")
[17:03:40.309]                           if (!has_future) {
[17:03:40.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.309]                               info)
[17:03:40.309]                           }
[17:03:40.309]                           else {
[17:03:40.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.309]                               info, version)
[17:03:40.309]                           }
[17:03:40.309]                           base::stop(msg)
[17:03:40.309]                         }
[17:03:40.309]                       })
[17:03:40.309]                     }
[17:03:40.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.309]                     base::options(mc.cores = 1L)
[17:03:40.309]                   }
[17:03:40.309]                   ...future.strategy.old <- future::plan("list")
[17:03:40.309]                   options(future.plan = NULL)
[17:03:40.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.309]                 }
[17:03:40.309]                 ...future.workdir <- getwd()
[17:03:40.309]             }
[17:03:40.309]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.309]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.309]         }
[17:03:40.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.309]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.309]             base::names(...future.oldOptions))
[17:03:40.309]     }
[17:03:40.309]     if (FALSE) {
[17:03:40.309]     }
[17:03:40.309]     else {
[17:03:40.309]         if (TRUE) {
[17:03:40.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.309]                 open = "w")
[17:03:40.309]         }
[17:03:40.309]         else {
[17:03:40.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.309]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.309]         }
[17:03:40.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.309]             base::sink(type = "output", split = FALSE)
[17:03:40.309]             base::close(...future.stdout)
[17:03:40.309]         }, add = TRUE)
[17:03:40.309]     }
[17:03:40.309]     ...future.frame <- base::sys.nframe()
[17:03:40.309]     ...future.conditions <- base::list()
[17:03:40.309]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.309]     if (FALSE) {
[17:03:40.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.309]     }
[17:03:40.309]     ...future.result <- base::tryCatch({
[17:03:40.309]         base::withCallingHandlers({
[17:03:40.309]             ...future.value <- base::withVisible(base::local({
[17:03:40.309]                 withCallingHandlers({
[17:03:40.309]                   {
[17:03:40.309]                     1
[17:03:40.309]                   }
[17:03:40.309]                 }, immediateCondition = function(cond) {
[17:03:40.309]                   save_rds <- function (object, pathname, ...) 
[17:03:40.309]                   {
[17:03:40.309]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.309]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.309]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.309]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.309]                         fi_tmp[["mtime"]])
[17:03:40.309]                     }
[17:03:40.309]                     tryCatch({
[17:03:40.309]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.309]                     }, error = function(ex) {
[17:03:40.309]                       msg <- conditionMessage(ex)
[17:03:40.309]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.309]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.309]                         fi_tmp[["mtime"]], msg)
[17:03:40.309]                       ex$message <- msg
[17:03:40.309]                       stop(ex)
[17:03:40.309]                     })
[17:03:40.309]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.309]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.309]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.309]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.309]                       fi <- file.info(pathname)
[17:03:40.309]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.309]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.309]                         fi[["size"]], fi[["mtime"]])
[17:03:40.309]                       stop(msg)
[17:03:40.309]                     }
[17:03:40.309]                     invisible(pathname)
[17:03:40.309]                   }
[17:03:40.309]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.309]                     rootPath = tempdir()) 
[17:03:40.309]                   {
[17:03:40.309]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.309]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.309]                       tmpdir = path, fileext = ".rds")
[17:03:40.309]                     save_rds(obj, file)
[17:03:40.309]                   }
[17:03:40.309]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.309]                   {
[17:03:40.309]                     inherits <- base::inherits
[17:03:40.309]                     invokeRestart <- base::invokeRestart
[17:03:40.309]                     is.null <- base::is.null
[17:03:40.309]                     muffled <- FALSE
[17:03:40.309]                     if (inherits(cond, "message")) {
[17:03:40.309]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.309]                       if (muffled) 
[17:03:40.309]                         invokeRestart("muffleMessage")
[17:03:40.309]                     }
[17:03:40.309]                     else if (inherits(cond, "warning")) {
[17:03:40.309]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.309]                       if (muffled) 
[17:03:40.309]                         invokeRestart("muffleWarning")
[17:03:40.309]                     }
[17:03:40.309]                     else if (inherits(cond, "condition")) {
[17:03:40.309]                       if (!is.null(pattern)) {
[17:03:40.309]                         computeRestarts <- base::computeRestarts
[17:03:40.309]                         grepl <- base::grepl
[17:03:40.309]                         restarts <- computeRestarts(cond)
[17:03:40.309]                         for (restart in restarts) {
[17:03:40.309]                           name <- restart$name
[17:03:40.309]                           if (is.null(name)) 
[17:03:40.309]                             next
[17:03:40.309]                           if (!grepl(pattern, name)) 
[17:03:40.309]                             next
[17:03:40.309]                           invokeRestart(restart)
[17:03:40.309]                           muffled <- TRUE
[17:03:40.309]                           break
[17:03:40.309]                         }
[17:03:40.309]                       }
[17:03:40.309]                     }
[17:03:40.309]                     invisible(muffled)
[17:03:40.309]                   }
[17:03:40.309]                   muffleCondition(cond)
[17:03:40.309]                 })
[17:03:40.309]             }))
[17:03:40.309]             future::FutureResult(value = ...future.value$value, 
[17:03:40.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.309]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.309]                     ...future.globalenv.names))
[17:03:40.309]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.309]         }, condition = base::local({
[17:03:40.309]             c <- base::c
[17:03:40.309]             inherits <- base::inherits
[17:03:40.309]             invokeRestart <- base::invokeRestart
[17:03:40.309]             length <- base::length
[17:03:40.309]             list <- base::list
[17:03:40.309]             seq.int <- base::seq.int
[17:03:40.309]             signalCondition <- base::signalCondition
[17:03:40.309]             sys.calls <- base::sys.calls
[17:03:40.309]             `[[` <- base::`[[`
[17:03:40.309]             `+` <- base::`+`
[17:03:40.309]             `<<-` <- base::`<<-`
[17:03:40.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.309]                   3L)]
[17:03:40.309]             }
[17:03:40.309]             function(cond) {
[17:03:40.309]                 is_error <- inherits(cond, "error")
[17:03:40.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.309]                   NULL)
[17:03:40.309]                 if (is_error) {
[17:03:40.309]                   sessionInformation <- function() {
[17:03:40.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.309]                       search = base::search(), system = base::Sys.info())
[17:03:40.309]                   }
[17:03:40.309]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.309]                     cond$call), session = sessionInformation(), 
[17:03:40.309]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.309]                   signalCondition(cond)
[17:03:40.309]                 }
[17:03:40.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.309]                 "immediateCondition"))) {
[17:03:40.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.309]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.309]                   if (TRUE && !signal) {
[17:03:40.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.309]                     {
[17:03:40.309]                       inherits <- base::inherits
[17:03:40.309]                       invokeRestart <- base::invokeRestart
[17:03:40.309]                       is.null <- base::is.null
[17:03:40.309]                       muffled <- FALSE
[17:03:40.309]                       if (inherits(cond, "message")) {
[17:03:40.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.309]                         if (muffled) 
[17:03:40.309]                           invokeRestart("muffleMessage")
[17:03:40.309]                       }
[17:03:40.309]                       else if (inherits(cond, "warning")) {
[17:03:40.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.309]                         if (muffled) 
[17:03:40.309]                           invokeRestart("muffleWarning")
[17:03:40.309]                       }
[17:03:40.309]                       else if (inherits(cond, "condition")) {
[17:03:40.309]                         if (!is.null(pattern)) {
[17:03:40.309]                           computeRestarts <- base::computeRestarts
[17:03:40.309]                           grepl <- base::grepl
[17:03:40.309]                           restarts <- computeRestarts(cond)
[17:03:40.309]                           for (restart in restarts) {
[17:03:40.309]                             name <- restart$name
[17:03:40.309]                             if (is.null(name)) 
[17:03:40.309]                               next
[17:03:40.309]                             if (!grepl(pattern, name)) 
[17:03:40.309]                               next
[17:03:40.309]                             invokeRestart(restart)
[17:03:40.309]                             muffled <- TRUE
[17:03:40.309]                             break
[17:03:40.309]                           }
[17:03:40.309]                         }
[17:03:40.309]                       }
[17:03:40.309]                       invisible(muffled)
[17:03:40.309]                     }
[17:03:40.309]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.309]                   }
[17:03:40.309]                 }
[17:03:40.309]                 else {
[17:03:40.309]                   if (TRUE) {
[17:03:40.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.309]                     {
[17:03:40.309]                       inherits <- base::inherits
[17:03:40.309]                       invokeRestart <- base::invokeRestart
[17:03:40.309]                       is.null <- base::is.null
[17:03:40.309]                       muffled <- FALSE
[17:03:40.309]                       if (inherits(cond, "message")) {
[17:03:40.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.309]                         if (muffled) 
[17:03:40.309]                           invokeRestart("muffleMessage")
[17:03:40.309]                       }
[17:03:40.309]                       else if (inherits(cond, "warning")) {
[17:03:40.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.309]                         if (muffled) 
[17:03:40.309]                           invokeRestart("muffleWarning")
[17:03:40.309]                       }
[17:03:40.309]                       else if (inherits(cond, "condition")) {
[17:03:40.309]                         if (!is.null(pattern)) {
[17:03:40.309]                           computeRestarts <- base::computeRestarts
[17:03:40.309]                           grepl <- base::grepl
[17:03:40.309]                           restarts <- computeRestarts(cond)
[17:03:40.309]                           for (restart in restarts) {
[17:03:40.309]                             name <- restart$name
[17:03:40.309]                             if (is.null(name)) 
[17:03:40.309]                               next
[17:03:40.309]                             if (!grepl(pattern, name)) 
[17:03:40.309]                               next
[17:03:40.309]                             invokeRestart(restart)
[17:03:40.309]                             muffled <- TRUE
[17:03:40.309]                             break
[17:03:40.309]                           }
[17:03:40.309]                         }
[17:03:40.309]                       }
[17:03:40.309]                       invisible(muffled)
[17:03:40.309]                     }
[17:03:40.309]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.309]                   }
[17:03:40.309]                 }
[17:03:40.309]             }
[17:03:40.309]         }))
[17:03:40.309]     }, error = function(ex) {
[17:03:40.309]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.309]                 ...future.rng), started = ...future.startTime, 
[17:03:40.309]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.309]             version = "1.8"), class = "FutureResult")
[17:03:40.309]     }, finally = {
[17:03:40.309]         if (!identical(...future.workdir, getwd())) 
[17:03:40.309]             setwd(...future.workdir)
[17:03:40.309]         {
[17:03:40.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.309]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.309]             }
[17:03:40.309]             base::options(...future.oldOptions)
[17:03:40.309]             if (.Platform$OS.type == "windows") {
[17:03:40.309]                 old_names <- names(...future.oldEnvVars)
[17:03:40.309]                 envs <- base::Sys.getenv()
[17:03:40.309]                 names <- names(envs)
[17:03:40.309]                 common <- intersect(names, old_names)
[17:03:40.309]                 added <- setdiff(names, old_names)
[17:03:40.309]                 removed <- setdiff(old_names, names)
[17:03:40.309]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.309]                   envs[common]]
[17:03:40.309]                 NAMES <- toupper(changed)
[17:03:40.309]                 args <- list()
[17:03:40.309]                 for (kk in seq_along(NAMES)) {
[17:03:40.309]                   name <- changed[[kk]]
[17:03:40.309]                   NAME <- NAMES[[kk]]
[17:03:40.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.309]                     next
[17:03:40.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.309]                 }
[17:03:40.309]                 NAMES <- toupper(added)
[17:03:40.309]                 for (kk in seq_along(NAMES)) {
[17:03:40.309]                   name <- added[[kk]]
[17:03:40.309]                   NAME <- NAMES[[kk]]
[17:03:40.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.309]                     next
[17:03:40.309]                   args[[name]] <- ""
[17:03:40.309]                 }
[17:03:40.309]                 NAMES <- toupper(removed)
[17:03:40.309]                 for (kk in seq_along(NAMES)) {
[17:03:40.309]                   name <- removed[[kk]]
[17:03:40.309]                   NAME <- NAMES[[kk]]
[17:03:40.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.309]                     next
[17:03:40.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.309]                 }
[17:03:40.309]                 if (length(args) > 0) 
[17:03:40.309]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.309]             }
[17:03:40.309]             else {
[17:03:40.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.309]             }
[17:03:40.309]             {
[17:03:40.309]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.309]                   0L) {
[17:03:40.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.309]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.309]                   base::options(opts)
[17:03:40.309]                 }
[17:03:40.309]                 {
[17:03:40.309]                   {
[17:03:40.309]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.309]                     NULL
[17:03:40.309]                   }
[17:03:40.309]                   options(future.plan = NULL)
[17:03:40.309]                   if (is.na(NA_character_)) 
[17:03:40.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.309]                     .init = FALSE)
[17:03:40.309]                 }
[17:03:40.309]             }
[17:03:40.309]         }
[17:03:40.309]     })
[17:03:40.309]     if (TRUE) {
[17:03:40.309]         base::sink(type = "output", split = FALSE)
[17:03:40.309]         if (TRUE) {
[17:03:40.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.309]         }
[17:03:40.309]         else {
[17:03:40.309]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.309]         }
[17:03:40.309]         base::close(...future.stdout)
[17:03:40.309]         ...future.stdout <- NULL
[17:03:40.309]     }
[17:03:40.309]     ...future.result$conditions <- ...future.conditions
[17:03:40.309]     ...future.result$finished <- base::Sys.time()
[17:03:40.309]     ...future.result
[17:03:40.309] }
[17:03:40.312] requestCore(): workers = 2
[17:03:40.312] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.323] result() for MulticoreFuture ...
[17:03:40.324] result() for MulticoreFuture ...
[17:03:40.324] result() for MulticoreFuture ... done
[17:03:40.324] result() for MulticoreFuture ... done
[17:03:40.325] result() for MulticoreFuture ...
[17:03:40.325] result() for MulticoreFuture ... done
[17:03:40.328] MulticoreFuture started
[17:03:40.328] - Launch lazy future ... done
[17:03:40.328] run() for ‘MulticoreFuture’ ... done
[17:03:40.329] plan(): Setting new future strategy stack:
[17:03:40.330] getGlobalsAndPackages() ...
[17:03:40.330] Searching for globals...
[17:03:40.329] List of future strategies:
[17:03:40.329] 1. sequential:
[17:03:40.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.329]    - tweaked: FALSE
[17:03:40.329]    - call: NULL
[17:03:40.331] plan(): nbrOfWorkers() = 1
[17:03:40.332] - globals found: [1] ‘{’
[17:03:40.332] Searching for globals ... DONE
[17:03:40.332] Resolving globals: FALSE
[17:03:40.333] 
[17:03:40.333] 
[17:03:40.333] getGlobalsAndPackages() ... DONE
[17:03:40.333] plan(): Setting new future strategy stack:
[17:03:40.333] run() for ‘Future’ ...
[17:03:40.334] - state: ‘created’
[17:03:40.334] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.334] List of future strategies:
[17:03:40.334] 1. multicore:
[17:03:40.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.334]    - tweaked: FALSE
[17:03:40.334]    - call: plan(strategy)
[17:03:40.346] plan(): nbrOfWorkers() = 2
[17:03:40.348] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.349] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.349]   - Field: ‘label’
[17:03:40.350]   - Field: ‘local’
[17:03:40.350]   - Field: ‘owner’
[17:03:40.350]   - Field: ‘envir’
[17:03:40.351]   - Field: ‘workers’
[17:03:40.351]   - Field: ‘packages’
[17:03:40.351]   - Field: ‘gc’
[17:03:40.351]   - Field: ‘job’
[17:03:40.352]   - Field: ‘conditions’
[17:03:40.352]   - Field: ‘expr’
[17:03:40.352]   - Field: ‘uuid’
[17:03:40.352]   - Field: ‘seed’
[17:03:40.353]   - Field: ‘version’
[17:03:40.353]   - Field: ‘result’
[17:03:40.353]   - Field: ‘asynchronous’
[17:03:40.353]   - Field: ‘calls’
[17:03:40.353]   - Field: ‘globals’
[17:03:40.353]   - Field: ‘stdout’
[17:03:40.354]   - Field: ‘earlySignal’
[17:03:40.354]   - Field: ‘lazy’
[17:03:40.354]   - Field: ‘state’
[17:03:40.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.354] - Launch lazy future ...
[17:03:40.355] Packages needed by the future expression (n = 0): <none>
[17:03:40.355] Packages needed by future strategies (n = 0): <none>
[17:03:40.356] {
[17:03:40.356]     {
[17:03:40.356]         {
[17:03:40.356]             ...future.startTime <- base::Sys.time()
[17:03:40.356]             {
[17:03:40.356]                 {
[17:03:40.356]                   {
[17:03:40.356]                     {
[17:03:40.356]                       base::local({
[17:03:40.356]                         has_future <- base::requireNamespace("future", 
[17:03:40.356]                           quietly = TRUE)
[17:03:40.356]                         if (has_future) {
[17:03:40.356]                           ns <- base::getNamespace("future")
[17:03:40.356]                           version <- ns[[".package"]][["version"]]
[17:03:40.356]                           if (is.null(version)) 
[17:03:40.356]                             version <- utils::packageVersion("future")
[17:03:40.356]                         }
[17:03:40.356]                         else {
[17:03:40.356]                           version <- NULL
[17:03:40.356]                         }
[17:03:40.356]                         if (!has_future || version < "1.8.0") {
[17:03:40.356]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.356]                             "", base::R.version$version.string), 
[17:03:40.356]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.356]                               "release", "version")], collapse = " "), 
[17:03:40.356]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.356]                             info)
[17:03:40.356]                           info <- base::paste(info, collapse = "; ")
[17:03:40.356]                           if (!has_future) {
[17:03:40.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.356]                               info)
[17:03:40.356]                           }
[17:03:40.356]                           else {
[17:03:40.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.356]                               info, version)
[17:03:40.356]                           }
[17:03:40.356]                           base::stop(msg)
[17:03:40.356]                         }
[17:03:40.356]                       })
[17:03:40.356]                     }
[17:03:40.356]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.356]                     base::options(mc.cores = 1L)
[17:03:40.356]                   }
[17:03:40.356]                   ...future.strategy.old <- future::plan("list")
[17:03:40.356]                   options(future.plan = NULL)
[17:03:40.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.356]                 }
[17:03:40.356]                 ...future.workdir <- getwd()
[17:03:40.356]             }
[17:03:40.356]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.356]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.356]         }
[17:03:40.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.356]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.356]             base::names(...future.oldOptions))
[17:03:40.356]     }
[17:03:40.356]     if (FALSE) {
[17:03:40.356]     }
[17:03:40.356]     else {
[17:03:40.356]         if (TRUE) {
[17:03:40.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.356]                 open = "w")
[17:03:40.356]         }
[17:03:40.356]         else {
[17:03:40.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.356]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.356]         }
[17:03:40.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.356]             base::sink(type = "output", split = FALSE)
[17:03:40.356]             base::close(...future.stdout)
[17:03:40.356]         }, add = TRUE)
[17:03:40.356]     }
[17:03:40.356]     ...future.frame <- base::sys.nframe()
[17:03:40.356]     ...future.conditions <- base::list()
[17:03:40.356]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.356]     if (FALSE) {
[17:03:40.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.356]     }
[17:03:40.356]     ...future.result <- base::tryCatch({
[17:03:40.356]         base::withCallingHandlers({
[17:03:40.356]             ...future.value <- base::withVisible(base::local({
[17:03:40.356]                 withCallingHandlers({
[17:03:40.356]                   {
[17:03:40.356]                     2
[17:03:40.356]                   }
[17:03:40.356]                 }, immediateCondition = function(cond) {
[17:03:40.356]                   save_rds <- function (object, pathname, ...) 
[17:03:40.356]                   {
[17:03:40.356]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.356]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.356]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.356]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.356]                         fi_tmp[["mtime"]])
[17:03:40.356]                     }
[17:03:40.356]                     tryCatch({
[17:03:40.356]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.356]                     }, error = function(ex) {
[17:03:40.356]                       msg <- conditionMessage(ex)
[17:03:40.356]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.356]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.356]                         fi_tmp[["mtime"]], msg)
[17:03:40.356]                       ex$message <- msg
[17:03:40.356]                       stop(ex)
[17:03:40.356]                     })
[17:03:40.356]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.356]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.356]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.356]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.356]                       fi <- file.info(pathname)
[17:03:40.356]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.356]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.356]                         fi[["size"]], fi[["mtime"]])
[17:03:40.356]                       stop(msg)
[17:03:40.356]                     }
[17:03:40.356]                     invisible(pathname)
[17:03:40.356]                   }
[17:03:40.356]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.356]                     rootPath = tempdir()) 
[17:03:40.356]                   {
[17:03:40.356]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.356]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.356]                       tmpdir = path, fileext = ".rds")
[17:03:40.356]                     save_rds(obj, file)
[17:03:40.356]                   }
[17:03:40.356]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.356]                   {
[17:03:40.356]                     inherits <- base::inherits
[17:03:40.356]                     invokeRestart <- base::invokeRestart
[17:03:40.356]                     is.null <- base::is.null
[17:03:40.356]                     muffled <- FALSE
[17:03:40.356]                     if (inherits(cond, "message")) {
[17:03:40.356]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.356]                       if (muffled) 
[17:03:40.356]                         invokeRestart("muffleMessage")
[17:03:40.356]                     }
[17:03:40.356]                     else if (inherits(cond, "warning")) {
[17:03:40.356]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.356]                       if (muffled) 
[17:03:40.356]                         invokeRestart("muffleWarning")
[17:03:40.356]                     }
[17:03:40.356]                     else if (inherits(cond, "condition")) {
[17:03:40.356]                       if (!is.null(pattern)) {
[17:03:40.356]                         computeRestarts <- base::computeRestarts
[17:03:40.356]                         grepl <- base::grepl
[17:03:40.356]                         restarts <- computeRestarts(cond)
[17:03:40.356]                         for (restart in restarts) {
[17:03:40.356]                           name <- restart$name
[17:03:40.356]                           if (is.null(name)) 
[17:03:40.356]                             next
[17:03:40.356]                           if (!grepl(pattern, name)) 
[17:03:40.356]                             next
[17:03:40.356]                           invokeRestart(restart)
[17:03:40.356]                           muffled <- TRUE
[17:03:40.356]                           break
[17:03:40.356]                         }
[17:03:40.356]                       }
[17:03:40.356]                     }
[17:03:40.356]                     invisible(muffled)
[17:03:40.356]                   }
[17:03:40.356]                   muffleCondition(cond)
[17:03:40.356]                 })
[17:03:40.356]             }))
[17:03:40.356]             future::FutureResult(value = ...future.value$value, 
[17:03:40.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.356]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.356]                     ...future.globalenv.names))
[17:03:40.356]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.356]         }, condition = base::local({
[17:03:40.356]             c <- base::c
[17:03:40.356]             inherits <- base::inherits
[17:03:40.356]             invokeRestart <- base::invokeRestart
[17:03:40.356]             length <- base::length
[17:03:40.356]             list <- base::list
[17:03:40.356]             seq.int <- base::seq.int
[17:03:40.356]             signalCondition <- base::signalCondition
[17:03:40.356]             sys.calls <- base::sys.calls
[17:03:40.356]             `[[` <- base::`[[`
[17:03:40.356]             `+` <- base::`+`
[17:03:40.356]             `<<-` <- base::`<<-`
[17:03:40.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.356]                   3L)]
[17:03:40.356]             }
[17:03:40.356]             function(cond) {
[17:03:40.356]                 is_error <- inherits(cond, "error")
[17:03:40.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.356]                   NULL)
[17:03:40.356]                 if (is_error) {
[17:03:40.356]                   sessionInformation <- function() {
[17:03:40.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.356]                       search = base::search(), system = base::Sys.info())
[17:03:40.356]                   }
[17:03:40.356]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.356]                     cond$call), session = sessionInformation(), 
[17:03:40.356]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.356]                   signalCondition(cond)
[17:03:40.356]                 }
[17:03:40.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.356]                 "immediateCondition"))) {
[17:03:40.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.356]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.356]                   if (TRUE && !signal) {
[17:03:40.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.356]                     {
[17:03:40.356]                       inherits <- base::inherits
[17:03:40.356]                       invokeRestart <- base::invokeRestart
[17:03:40.356]                       is.null <- base::is.null
[17:03:40.356]                       muffled <- FALSE
[17:03:40.356]                       if (inherits(cond, "message")) {
[17:03:40.356]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.356]                         if (muffled) 
[17:03:40.356]                           invokeRestart("muffleMessage")
[17:03:40.356]                       }
[17:03:40.356]                       else if (inherits(cond, "warning")) {
[17:03:40.356]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.356]                         if (muffled) 
[17:03:40.356]                           invokeRestart("muffleWarning")
[17:03:40.356]                       }
[17:03:40.356]                       else if (inherits(cond, "condition")) {
[17:03:40.356]                         if (!is.null(pattern)) {
[17:03:40.356]                           computeRestarts <- base::computeRestarts
[17:03:40.356]                           grepl <- base::grepl
[17:03:40.356]                           restarts <- computeRestarts(cond)
[17:03:40.356]                           for (restart in restarts) {
[17:03:40.356]                             name <- restart$name
[17:03:40.356]                             if (is.null(name)) 
[17:03:40.356]                               next
[17:03:40.356]                             if (!grepl(pattern, name)) 
[17:03:40.356]                               next
[17:03:40.356]                             invokeRestart(restart)
[17:03:40.356]                             muffled <- TRUE
[17:03:40.356]                             break
[17:03:40.356]                           }
[17:03:40.356]                         }
[17:03:40.356]                       }
[17:03:40.356]                       invisible(muffled)
[17:03:40.356]                     }
[17:03:40.356]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.356]                   }
[17:03:40.356]                 }
[17:03:40.356]                 else {
[17:03:40.356]                   if (TRUE) {
[17:03:40.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.356]                     {
[17:03:40.356]                       inherits <- base::inherits
[17:03:40.356]                       invokeRestart <- base::invokeRestart
[17:03:40.356]                       is.null <- base::is.null
[17:03:40.356]                       muffled <- FALSE
[17:03:40.356]                       if (inherits(cond, "message")) {
[17:03:40.356]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.356]                         if (muffled) 
[17:03:40.356]                           invokeRestart("muffleMessage")
[17:03:40.356]                       }
[17:03:40.356]                       else if (inherits(cond, "warning")) {
[17:03:40.356]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.356]                         if (muffled) 
[17:03:40.356]                           invokeRestart("muffleWarning")
[17:03:40.356]                       }
[17:03:40.356]                       else if (inherits(cond, "condition")) {
[17:03:40.356]                         if (!is.null(pattern)) {
[17:03:40.356]                           computeRestarts <- base::computeRestarts
[17:03:40.356]                           grepl <- base::grepl
[17:03:40.356]                           restarts <- computeRestarts(cond)
[17:03:40.356]                           for (restart in restarts) {
[17:03:40.356]                             name <- restart$name
[17:03:40.356]                             if (is.null(name)) 
[17:03:40.356]                               next
[17:03:40.356]                             if (!grepl(pattern, name)) 
[17:03:40.356]                               next
[17:03:40.356]                             invokeRestart(restart)
[17:03:40.356]                             muffled <- TRUE
[17:03:40.356]                             break
[17:03:40.356]                           }
[17:03:40.356]                         }
[17:03:40.356]                       }
[17:03:40.356]                       invisible(muffled)
[17:03:40.356]                     }
[17:03:40.356]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.356]                   }
[17:03:40.356]                 }
[17:03:40.356]             }
[17:03:40.356]         }))
[17:03:40.356]     }, error = function(ex) {
[17:03:40.356]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.356]                 ...future.rng), started = ...future.startTime, 
[17:03:40.356]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.356]             version = "1.8"), class = "FutureResult")
[17:03:40.356]     }, finally = {
[17:03:40.356]         if (!identical(...future.workdir, getwd())) 
[17:03:40.356]             setwd(...future.workdir)
[17:03:40.356]         {
[17:03:40.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.356]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.356]             }
[17:03:40.356]             base::options(...future.oldOptions)
[17:03:40.356]             if (.Platform$OS.type == "windows") {
[17:03:40.356]                 old_names <- names(...future.oldEnvVars)
[17:03:40.356]                 envs <- base::Sys.getenv()
[17:03:40.356]                 names <- names(envs)
[17:03:40.356]                 common <- intersect(names, old_names)
[17:03:40.356]                 added <- setdiff(names, old_names)
[17:03:40.356]                 removed <- setdiff(old_names, names)
[17:03:40.356]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.356]                   envs[common]]
[17:03:40.356]                 NAMES <- toupper(changed)
[17:03:40.356]                 args <- list()
[17:03:40.356]                 for (kk in seq_along(NAMES)) {
[17:03:40.356]                   name <- changed[[kk]]
[17:03:40.356]                   NAME <- NAMES[[kk]]
[17:03:40.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.356]                     next
[17:03:40.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.356]                 }
[17:03:40.356]                 NAMES <- toupper(added)
[17:03:40.356]                 for (kk in seq_along(NAMES)) {
[17:03:40.356]                   name <- added[[kk]]
[17:03:40.356]                   NAME <- NAMES[[kk]]
[17:03:40.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.356]                     next
[17:03:40.356]                   args[[name]] <- ""
[17:03:40.356]                 }
[17:03:40.356]                 NAMES <- toupper(removed)
[17:03:40.356]                 for (kk in seq_along(NAMES)) {
[17:03:40.356]                   name <- removed[[kk]]
[17:03:40.356]                   NAME <- NAMES[[kk]]
[17:03:40.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.356]                     next
[17:03:40.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.356]                 }
[17:03:40.356]                 if (length(args) > 0) 
[17:03:40.356]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.356]             }
[17:03:40.356]             else {
[17:03:40.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.356]             }
[17:03:40.356]             {
[17:03:40.356]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.356]                   0L) {
[17:03:40.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.356]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.356]                   base::options(opts)
[17:03:40.356]                 }
[17:03:40.356]                 {
[17:03:40.356]                   {
[17:03:40.356]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.356]                     NULL
[17:03:40.356]                   }
[17:03:40.356]                   options(future.plan = NULL)
[17:03:40.356]                   if (is.na(NA_character_)) 
[17:03:40.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.356]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.356]                     .init = FALSE)
[17:03:40.356]                 }
[17:03:40.356]             }
[17:03:40.356]         }
[17:03:40.356]     })
[17:03:40.356]     if (TRUE) {
[17:03:40.356]         base::sink(type = "output", split = FALSE)
[17:03:40.356]         if (TRUE) {
[17:03:40.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.356]         }
[17:03:40.356]         else {
[17:03:40.356]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.356]         }
[17:03:40.356]         base::close(...future.stdout)
[17:03:40.356]         ...future.stdout <- NULL
[17:03:40.356]     }
[17:03:40.356]     ...future.result$conditions <- ...future.conditions
[17:03:40.356]     ...future.result$finished <- base::Sys.time()
[17:03:40.356]     ...future.result
[17:03:40.356] }
[17:03:40.359] requestCore(): workers = 2
[17:03:40.359] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.370] result() for MulticoreFuture ...
[17:03:40.370] result() for MulticoreFuture ...
[17:03:40.371] result() for MulticoreFuture ... done
[17:03:40.371] result() for MulticoreFuture ... done
[17:03:40.371] result() for MulticoreFuture ...
[17:03:40.371] result() for MulticoreFuture ... done
[17:03:40.373] MulticoreFuture started
[17:03:40.374] - Launch lazy future ... done
[17:03:40.374] run() for ‘MulticoreFuture’ ... done
[17:03:40.375] plan(): Setting new future strategy stack:
[17:03:40.375] List of future strategies:
[17:03:40.375] 1. sequential:
[17:03:40.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.375]    - tweaked: FALSE
[17:03:40.375]    - call: NULL
[17:03:40.376] resolve() on list environment ...
[17:03:40.376]  recursive: 0
[17:03:40.377] plan(): nbrOfWorkers() = 1
[17:03:40.378]  length: 3
[17:03:40.378]  elements: ‘a’, ‘b’, ‘c’
[17:03:40.379] Future #1
[17:03:40.379]  length: 2 (resolved future 1)
[17:03:40.379] plan(): Setting new future strategy stack:
[17:03:40.380] List of future strategies:
[17:03:40.380] 1. multicore:
[17:03:40.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.380]    - tweaked: FALSE
[17:03:40.380]    - call: plan(strategy)
[17:03:40.385] plan(): nbrOfWorkers() = 2
[17:03:40.386] Future #2
[17:03:40.386]  length: 1 (resolved future 2)
[17:03:40.386]  length: 0 (resolved future 3)
[17:03:40.386] resolve() on list environment ... DONE
[17:03:40.387] getGlobalsAndPackages() ...
[17:03:40.387] Searching for globals...
[17:03:40.388] - globals found: [1] ‘{’
[17:03:40.389] Searching for globals ... DONE
[17:03:40.389] Resolving globals: FALSE
[17:03:40.389] 
[17:03:40.390] 
[17:03:40.390] getGlobalsAndPackages() ... DONE
[17:03:40.390] run() for ‘Future’ ...
[17:03:40.390] - state: ‘created’
[17:03:40.391] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.395] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.395]   - Field: ‘label’
[17:03:40.396]   - Field: ‘local’
[17:03:40.396]   - Field: ‘owner’
[17:03:40.396]   - Field: ‘envir’
[17:03:40.396]   - Field: ‘workers’
[17:03:40.396]   - Field: ‘packages’
[17:03:40.396]   - Field: ‘gc’
[17:03:40.397]   - Field: ‘job’
[17:03:40.397]   - Field: ‘conditions’
[17:03:40.397]   - Field: ‘expr’
[17:03:40.397]   - Field: ‘uuid’
[17:03:40.397]   - Field: ‘seed’
[17:03:40.397]   - Field: ‘version’
[17:03:40.397]   - Field: ‘result’
[17:03:40.398]   - Field: ‘asynchronous’
[17:03:40.398]   - Field: ‘calls’
[17:03:40.398]   - Field: ‘globals’
[17:03:40.398]   - Field: ‘stdout’
[17:03:40.398]   - Field: ‘earlySignal’
[17:03:40.398]   - Field: ‘lazy’
[17:03:40.398]   - Field: ‘state’
[17:03:40.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.399] - Launch lazy future ...
[17:03:40.399] Packages needed by the future expression (n = 0): <none>
[17:03:40.399] Packages needed by future strategies (n = 0): <none>
[17:03:40.400] {
[17:03:40.400]     {
[17:03:40.400]         {
[17:03:40.400]             ...future.startTime <- base::Sys.time()
[17:03:40.400]             {
[17:03:40.400]                 {
[17:03:40.400]                   {
[17:03:40.400]                     {
[17:03:40.400]                       base::local({
[17:03:40.400]                         has_future <- base::requireNamespace("future", 
[17:03:40.400]                           quietly = TRUE)
[17:03:40.400]                         if (has_future) {
[17:03:40.400]                           ns <- base::getNamespace("future")
[17:03:40.400]                           version <- ns[[".package"]][["version"]]
[17:03:40.400]                           if (is.null(version)) 
[17:03:40.400]                             version <- utils::packageVersion("future")
[17:03:40.400]                         }
[17:03:40.400]                         else {
[17:03:40.400]                           version <- NULL
[17:03:40.400]                         }
[17:03:40.400]                         if (!has_future || version < "1.8.0") {
[17:03:40.400]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.400]                             "", base::R.version$version.string), 
[17:03:40.400]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.400]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.400]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.400]                               "release", "version")], collapse = " "), 
[17:03:40.400]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.400]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.400]                             info)
[17:03:40.400]                           info <- base::paste(info, collapse = "; ")
[17:03:40.400]                           if (!has_future) {
[17:03:40.400]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.400]                               info)
[17:03:40.400]                           }
[17:03:40.400]                           else {
[17:03:40.400]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.400]                               info, version)
[17:03:40.400]                           }
[17:03:40.400]                           base::stop(msg)
[17:03:40.400]                         }
[17:03:40.400]                       })
[17:03:40.400]                     }
[17:03:40.400]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.400]                     base::options(mc.cores = 1L)
[17:03:40.400]                   }
[17:03:40.400]                   ...future.strategy.old <- future::plan("list")
[17:03:40.400]                   options(future.plan = NULL)
[17:03:40.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.400]                 }
[17:03:40.400]                 ...future.workdir <- getwd()
[17:03:40.400]             }
[17:03:40.400]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.400]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.400]         }
[17:03:40.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.400]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.400]             base::names(...future.oldOptions))
[17:03:40.400]     }
[17:03:40.400]     if (FALSE) {
[17:03:40.400]     }
[17:03:40.400]     else {
[17:03:40.400]         if (TRUE) {
[17:03:40.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.400]                 open = "w")
[17:03:40.400]         }
[17:03:40.400]         else {
[17:03:40.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.400]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.400]         }
[17:03:40.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.400]             base::sink(type = "output", split = FALSE)
[17:03:40.400]             base::close(...future.stdout)
[17:03:40.400]         }, add = TRUE)
[17:03:40.400]     }
[17:03:40.400]     ...future.frame <- base::sys.nframe()
[17:03:40.400]     ...future.conditions <- base::list()
[17:03:40.400]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.400]     if (FALSE) {
[17:03:40.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.400]     }
[17:03:40.400]     ...future.result <- base::tryCatch({
[17:03:40.400]         base::withCallingHandlers({
[17:03:40.400]             ...future.value <- base::withVisible(base::local({
[17:03:40.400]                 withCallingHandlers({
[17:03:40.400]                   {
[17:03:40.400]                     1
[17:03:40.400]                   }
[17:03:40.400]                 }, immediateCondition = function(cond) {
[17:03:40.400]                   save_rds <- function (object, pathname, ...) 
[17:03:40.400]                   {
[17:03:40.400]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.400]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.400]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.400]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.400]                         fi_tmp[["mtime"]])
[17:03:40.400]                     }
[17:03:40.400]                     tryCatch({
[17:03:40.400]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.400]                     }, error = function(ex) {
[17:03:40.400]                       msg <- conditionMessage(ex)
[17:03:40.400]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.400]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.400]                         fi_tmp[["mtime"]], msg)
[17:03:40.400]                       ex$message <- msg
[17:03:40.400]                       stop(ex)
[17:03:40.400]                     })
[17:03:40.400]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.400]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.400]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.400]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.400]                       fi <- file.info(pathname)
[17:03:40.400]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.400]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.400]                         fi[["size"]], fi[["mtime"]])
[17:03:40.400]                       stop(msg)
[17:03:40.400]                     }
[17:03:40.400]                     invisible(pathname)
[17:03:40.400]                   }
[17:03:40.400]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.400]                     rootPath = tempdir()) 
[17:03:40.400]                   {
[17:03:40.400]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.400]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.400]                       tmpdir = path, fileext = ".rds")
[17:03:40.400]                     save_rds(obj, file)
[17:03:40.400]                   }
[17:03:40.400]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.400]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.400]                   {
[17:03:40.400]                     inherits <- base::inherits
[17:03:40.400]                     invokeRestart <- base::invokeRestart
[17:03:40.400]                     is.null <- base::is.null
[17:03:40.400]                     muffled <- FALSE
[17:03:40.400]                     if (inherits(cond, "message")) {
[17:03:40.400]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.400]                       if (muffled) 
[17:03:40.400]                         invokeRestart("muffleMessage")
[17:03:40.400]                     }
[17:03:40.400]                     else if (inherits(cond, "warning")) {
[17:03:40.400]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.400]                       if (muffled) 
[17:03:40.400]                         invokeRestart("muffleWarning")
[17:03:40.400]                     }
[17:03:40.400]                     else if (inherits(cond, "condition")) {
[17:03:40.400]                       if (!is.null(pattern)) {
[17:03:40.400]                         computeRestarts <- base::computeRestarts
[17:03:40.400]                         grepl <- base::grepl
[17:03:40.400]                         restarts <- computeRestarts(cond)
[17:03:40.400]                         for (restart in restarts) {
[17:03:40.400]                           name <- restart$name
[17:03:40.400]                           if (is.null(name)) 
[17:03:40.400]                             next
[17:03:40.400]                           if (!grepl(pattern, name)) 
[17:03:40.400]                             next
[17:03:40.400]                           invokeRestart(restart)
[17:03:40.400]                           muffled <- TRUE
[17:03:40.400]                           break
[17:03:40.400]                         }
[17:03:40.400]                       }
[17:03:40.400]                     }
[17:03:40.400]                     invisible(muffled)
[17:03:40.400]                   }
[17:03:40.400]                   muffleCondition(cond)
[17:03:40.400]                 })
[17:03:40.400]             }))
[17:03:40.400]             future::FutureResult(value = ...future.value$value, 
[17:03:40.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.400]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.400]                     ...future.globalenv.names))
[17:03:40.400]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.400]         }, condition = base::local({
[17:03:40.400]             c <- base::c
[17:03:40.400]             inherits <- base::inherits
[17:03:40.400]             invokeRestart <- base::invokeRestart
[17:03:40.400]             length <- base::length
[17:03:40.400]             list <- base::list
[17:03:40.400]             seq.int <- base::seq.int
[17:03:40.400]             signalCondition <- base::signalCondition
[17:03:40.400]             sys.calls <- base::sys.calls
[17:03:40.400]             `[[` <- base::`[[`
[17:03:40.400]             `+` <- base::`+`
[17:03:40.400]             `<<-` <- base::`<<-`
[17:03:40.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.400]                   3L)]
[17:03:40.400]             }
[17:03:40.400]             function(cond) {
[17:03:40.400]                 is_error <- inherits(cond, "error")
[17:03:40.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.400]                   NULL)
[17:03:40.400]                 if (is_error) {
[17:03:40.400]                   sessionInformation <- function() {
[17:03:40.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.400]                       search = base::search(), system = base::Sys.info())
[17:03:40.400]                   }
[17:03:40.400]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.400]                     cond$call), session = sessionInformation(), 
[17:03:40.400]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.400]                   signalCondition(cond)
[17:03:40.400]                 }
[17:03:40.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.400]                 "immediateCondition"))) {
[17:03:40.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.400]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.400]                   if (TRUE && !signal) {
[17:03:40.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.400]                     {
[17:03:40.400]                       inherits <- base::inherits
[17:03:40.400]                       invokeRestart <- base::invokeRestart
[17:03:40.400]                       is.null <- base::is.null
[17:03:40.400]                       muffled <- FALSE
[17:03:40.400]                       if (inherits(cond, "message")) {
[17:03:40.400]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.400]                         if (muffled) 
[17:03:40.400]                           invokeRestart("muffleMessage")
[17:03:40.400]                       }
[17:03:40.400]                       else if (inherits(cond, "warning")) {
[17:03:40.400]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.400]                         if (muffled) 
[17:03:40.400]                           invokeRestart("muffleWarning")
[17:03:40.400]                       }
[17:03:40.400]                       else if (inherits(cond, "condition")) {
[17:03:40.400]                         if (!is.null(pattern)) {
[17:03:40.400]                           computeRestarts <- base::computeRestarts
[17:03:40.400]                           grepl <- base::grepl
[17:03:40.400]                           restarts <- computeRestarts(cond)
[17:03:40.400]                           for (restart in restarts) {
[17:03:40.400]                             name <- restart$name
[17:03:40.400]                             if (is.null(name)) 
[17:03:40.400]                               next
[17:03:40.400]                             if (!grepl(pattern, name)) 
[17:03:40.400]                               next
[17:03:40.400]                             invokeRestart(restart)
[17:03:40.400]                             muffled <- TRUE
[17:03:40.400]                             break
[17:03:40.400]                           }
[17:03:40.400]                         }
[17:03:40.400]                       }
[17:03:40.400]                       invisible(muffled)
[17:03:40.400]                     }
[17:03:40.400]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.400]                   }
[17:03:40.400]                 }
[17:03:40.400]                 else {
[17:03:40.400]                   if (TRUE) {
[17:03:40.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.400]                     {
[17:03:40.400]                       inherits <- base::inherits
[17:03:40.400]                       invokeRestart <- base::invokeRestart
[17:03:40.400]                       is.null <- base::is.null
[17:03:40.400]                       muffled <- FALSE
[17:03:40.400]                       if (inherits(cond, "message")) {
[17:03:40.400]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.400]                         if (muffled) 
[17:03:40.400]                           invokeRestart("muffleMessage")
[17:03:40.400]                       }
[17:03:40.400]                       else if (inherits(cond, "warning")) {
[17:03:40.400]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.400]                         if (muffled) 
[17:03:40.400]                           invokeRestart("muffleWarning")
[17:03:40.400]                       }
[17:03:40.400]                       else if (inherits(cond, "condition")) {
[17:03:40.400]                         if (!is.null(pattern)) {
[17:03:40.400]                           computeRestarts <- base::computeRestarts
[17:03:40.400]                           grepl <- base::grepl
[17:03:40.400]                           restarts <- computeRestarts(cond)
[17:03:40.400]                           for (restart in restarts) {
[17:03:40.400]                             name <- restart$name
[17:03:40.400]                             if (is.null(name)) 
[17:03:40.400]                               next
[17:03:40.400]                             if (!grepl(pattern, name)) 
[17:03:40.400]                               next
[17:03:40.400]                             invokeRestart(restart)
[17:03:40.400]                             muffled <- TRUE
[17:03:40.400]                             break
[17:03:40.400]                           }
[17:03:40.400]                         }
[17:03:40.400]                       }
[17:03:40.400]                       invisible(muffled)
[17:03:40.400]                     }
[17:03:40.400]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.400]                   }
[17:03:40.400]                 }
[17:03:40.400]             }
[17:03:40.400]         }))
[17:03:40.400]     }, error = function(ex) {
[17:03:40.400]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.400]                 ...future.rng), started = ...future.startTime, 
[17:03:40.400]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.400]             version = "1.8"), class = "FutureResult")
[17:03:40.400]     }, finally = {
[17:03:40.400]         if (!identical(...future.workdir, getwd())) 
[17:03:40.400]             setwd(...future.workdir)
[17:03:40.400]         {
[17:03:40.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.400]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.400]             }
[17:03:40.400]             base::options(...future.oldOptions)
[17:03:40.400]             if (.Platform$OS.type == "windows") {
[17:03:40.400]                 old_names <- names(...future.oldEnvVars)
[17:03:40.400]                 envs <- base::Sys.getenv()
[17:03:40.400]                 names <- names(envs)
[17:03:40.400]                 common <- intersect(names, old_names)
[17:03:40.400]                 added <- setdiff(names, old_names)
[17:03:40.400]                 removed <- setdiff(old_names, names)
[17:03:40.400]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.400]                   envs[common]]
[17:03:40.400]                 NAMES <- toupper(changed)
[17:03:40.400]                 args <- list()
[17:03:40.400]                 for (kk in seq_along(NAMES)) {
[17:03:40.400]                   name <- changed[[kk]]
[17:03:40.400]                   NAME <- NAMES[[kk]]
[17:03:40.400]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.400]                     next
[17:03:40.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.400]                 }
[17:03:40.400]                 NAMES <- toupper(added)
[17:03:40.400]                 for (kk in seq_along(NAMES)) {
[17:03:40.400]                   name <- added[[kk]]
[17:03:40.400]                   NAME <- NAMES[[kk]]
[17:03:40.400]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.400]                     next
[17:03:40.400]                   args[[name]] <- ""
[17:03:40.400]                 }
[17:03:40.400]                 NAMES <- toupper(removed)
[17:03:40.400]                 for (kk in seq_along(NAMES)) {
[17:03:40.400]                   name <- removed[[kk]]
[17:03:40.400]                   NAME <- NAMES[[kk]]
[17:03:40.400]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.400]                     next
[17:03:40.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.400]                 }
[17:03:40.400]                 if (length(args) > 0) 
[17:03:40.400]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.400]             }
[17:03:40.400]             else {
[17:03:40.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.400]             }
[17:03:40.400]             {
[17:03:40.400]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.400]                   0L) {
[17:03:40.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.400]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.400]                   base::options(opts)
[17:03:40.400]                 }
[17:03:40.400]                 {
[17:03:40.400]                   {
[17:03:40.400]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.400]                     NULL
[17:03:40.400]                   }
[17:03:40.400]                   options(future.plan = NULL)
[17:03:40.400]                   if (is.na(NA_character_)) 
[17:03:40.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.400]                     .init = FALSE)
[17:03:40.400]                 }
[17:03:40.400]             }
[17:03:40.400]         }
[17:03:40.400]     })
[17:03:40.400]     if (TRUE) {
[17:03:40.400]         base::sink(type = "output", split = FALSE)
[17:03:40.400]         if (TRUE) {
[17:03:40.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.400]         }
[17:03:40.400]         else {
[17:03:40.400]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.400]         }
[17:03:40.400]         base::close(...future.stdout)
[17:03:40.400]         ...future.stdout <- NULL
[17:03:40.400]     }
[17:03:40.400]     ...future.result$conditions <- ...future.conditions
[17:03:40.400]     ...future.result$finished <- base::Sys.time()
[17:03:40.400]     ...future.result
[17:03:40.400] }
[17:03:40.404] requestCore(): workers = 2
[17:03:40.404] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.415] result() for MulticoreFuture ...
[17:03:40.416] result() for MulticoreFuture ...
[17:03:40.416] result() for MulticoreFuture ... done
[17:03:40.416] result() for MulticoreFuture ... done
[17:03:40.416] result() for MulticoreFuture ...
[17:03:40.416] result() for MulticoreFuture ... done
[17:03:40.419] MulticoreFuture started
[17:03:40.419] - Launch lazy future ... done
[17:03:40.420] run() for ‘MulticoreFuture’ ... done
[17:03:40.420] plan(): Setting new future strategy stack:
[17:03:40.421] getGlobalsAndPackages() ...
[17:03:40.421] Searching for globals...
[17:03:40.420] List of future strategies:
[17:03:40.420] 1. sequential:
[17:03:40.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.420]    - tweaked: FALSE
[17:03:40.420]    - call: NULL
[17:03:40.422] plan(): nbrOfWorkers() = 1
[17:03:40.424] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:03:40.424] Searching for globals ... DONE
[17:03:40.425] Resolving globals: FALSE
[17:03:40.425] plan(): Setting new future strategy stack:
[17:03:40.425] List of future strategies:
[17:03:40.425] 1. multicore:
[17:03:40.425]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.425]    - tweaked: FALSE
[17:03:40.425]    - call: plan(strategy)
[17:03:40.426] 
[17:03:40.426] 
[17:03:40.426] getGlobalsAndPackages() ... DONE
[17:03:40.427] run() for ‘Future’ ...
[17:03:40.427] - state: ‘created’
[17:03:40.427] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.431] plan(): nbrOfWorkers() = 2
[17:03:40.432] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.432]   - Field: ‘label’
[17:03:40.433]   - Field: ‘local’
[17:03:40.433]   - Field: ‘owner’
[17:03:40.433]   - Field: ‘envir’
[17:03:40.433]   - Field: ‘workers’
[17:03:40.433]   - Field: ‘packages’
[17:03:40.433]   - Field: ‘gc’
[17:03:40.433]   - Field: ‘job’
[17:03:40.434]   - Field: ‘conditions’
[17:03:40.434]   - Field: ‘expr’
[17:03:40.434]   - Field: ‘uuid’
[17:03:40.434]   - Field: ‘seed’
[17:03:40.434]   - Field: ‘version’
[17:03:40.434]   - Field: ‘result’
[17:03:40.434]   - Field: ‘asynchronous’
[17:03:40.435]   - Field: ‘calls’
[17:03:40.435]   - Field: ‘globals’
[17:03:40.435]   - Field: ‘stdout’
[17:03:40.439]   - Field: ‘earlySignal’
[17:03:40.439]   - Field: ‘lazy’
[17:03:40.440]   - Field: ‘state’
[17:03:40.440] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.441] - Launch lazy future ...
[17:03:40.442] Packages needed by the future expression (n = 0): <none>
[17:03:40.442] Packages needed by future strategies (n = 0): <none>
[17:03:40.443] {
[17:03:40.443]     {
[17:03:40.443]         {
[17:03:40.443]             ...future.startTime <- base::Sys.time()
[17:03:40.443]             {
[17:03:40.443]                 {
[17:03:40.443]                   {
[17:03:40.443]                     {
[17:03:40.443]                       base::local({
[17:03:40.443]                         has_future <- base::requireNamespace("future", 
[17:03:40.443]                           quietly = TRUE)
[17:03:40.443]                         if (has_future) {
[17:03:40.443]                           ns <- base::getNamespace("future")
[17:03:40.443]                           version <- ns[[".package"]][["version"]]
[17:03:40.443]                           if (is.null(version)) 
[17:03:40.443]                             version <- utils::packageVersion("future")
[17:03:40.443]                         }
[17:03:40.443]                         else {
[17:03:40.443]                           version <- NULL
[17:03:40.443]                         }
[17:03:40.443]                         if (!has_future || version < "1.8.0") {
[17:03:40.443]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.443]                             "", base::R.version$version.string), 
[17:03:40.443]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.443]                               "release", "version")], collapse = " "), 
[17:03:40.443]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.443]                             info)
[17:03:40.443]                           info <- base::paste(info, collapse = "; ")
[17:03:40.443]                           if (!has_future) {
[17:03:40.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.443]                               info)
[17:03:40.443]                           }
[17:03:40.443]                           else {
[17:03:40.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.443]                               info, version)
[17:03:40.443]                           }
[17:03:40.443]                           base::stop(msg)
[17:03:40.443]                         }
[17:03:40.443]                       })
[17:03:40.443]                     }
[17:03:40.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.443]                     base::options(mc.cores = 1L)
[17:03:40.443]                   }
[17:03:40.443]                   ...future.strategy.old <- future::plan("list")
[17:03:40.443]                   options(future.plan = NULL)
[17:03:40.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.443]                 }
[17:03:40.443]                 ...future.workdir <- getwd()
[17:03:40.443]             }
[17:03:40.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.443]         }
[17:03:40.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.443]             base::names(...future.oldOptions))
[17:03:40.443]     }
[17:03:40.443]     if (FALSE) {
[17:03:40.443]     }
[17:03:40.443]     else {
[17:03:40.443]         if (TRUE) {
[17:03:40.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.443]                 open = "w")
[17:03:40.443]         }
[17:03:40.443]         else {
[17:03:40.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.443]         }
[17:03:40.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.443]             base::sink(type = "output", split = FALSE)
[17:03:40.443]             base::close(...future.stdout)
[17:03:40.443]         }, add = TRUE)
[17:03:40.443]     }
[17:03:40.443]     ...future.frame <- base::sys.nframe()
[17:03:40.443]     ...future.conditions <- base::list()
[17:03:40.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.443]     if (FALSE) {
[17:03:40.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.443]     }
[17:03:40.443]     ...future.result <- base::tryCatch({
[17:03:40.443]         base::withCallingHandlers({
[17:03:40.443]             ...future.value <- base::withVisible(base::local({
[17:03:40.443]                 withCallingHandlers({
[17:03:40.443]                   {
[17:03:40.443]                     Sys.sleep(0.5)
[17:03:40.443]                     2
[17:03:40.443]                   }
[17:03:40.443]                 }, immediateCondition = function(cond) {
[17:03:40.443]                   save_rds <- function (object, pathname, ...) 
[17:03:40.443]                   {
[17:03:40.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.443]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.443]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.443]                         fi_tmp[["mtime"]])
[17:03:40.443]                     }
[17:03:40.443]                     tryCatch({
[17:03:40.443]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.443]                     }, error = function(ex) {
[17:03:40.443]                       msg <- conditionMessage(ex)
[17:03:40.443]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.443]                         fi_tmp[["mtime"]], msg)
[17:03:40.443]                       ex$message <- msg
[17:03:40.443]                       stop(ex)
[17:03:40.443]                     })
[17:03:40.443]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.443]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.443]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.443]                       fi <- file.info(pathname)
[17:03:40.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.443]                         fi[["size"]], fi[["mtime"]])
[17:03:40.443]                       stop(msg)
[17:03:40.443]                     }
[17:03:40.443]                     invisible(pathname)
[17:03:40.443]                   }
[17:03:40.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.443]                     rootPath = tempdir()) 
[17:03:40.443]                   {
[17:03:40.443]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.443]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.443]                       tmpdir = path, fileext = ".rds")
[17:03:40.443]                     save_rds(obj, file)
[17:03:40.443]                   }
[17:03:40.443]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.443]                   {
[17:03:40.443]                     inherits <- base::inherits
[17:03:40.443]                     invokeRestart <- base::invokeRestart
[17:03:40.443]                     is.null <- base::is.null
[17:03:40.443]                     muffled <- FALSE
[17:03:40.443]                     if (inherits(cond, "message")) {
[17:03:40.443]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.443]                       if (muffled) 
[17:03:40.443]                         invokeRestart("muffleMessage")
[17:03:40.443]                     }
[17:03:40.443]                     else if (inherits(cond, "warning")) {
[17:03:40.443]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.443]                       if (muffled) 
[17:03:40.443]                         invokeRestart("muffleWarning")
[17:03:40.443]                     }
[17:03:40.443]                     else if (inherits(cond, "condition")) {
[17:03:40.443]                       if (!is.null(pattern)) {
[17:03:40.443]                         computeRestarts <- base::computeRestarts
[17:03:40.443]                         grepl <- base::grepl
[17:03:40.443]                         restarts <- computeRestarts(cond)
[17:03:40.443]                         for (restart in restarts) {
[17:03:40.443]                           name <- restart$name
[17:03:40.443]                           if (is.null(name)) 
[17:03:40.443]                             next
[17:03:40.443]                           if (!grepl(pattern, name)) 
[17:03:40.443]                             next
[17:03:40.443]                           invokeRestart(restart)
[17:03:40.443]                           muffled <- TRUE
[17:03:40.443]                           break
[17:03:40.443]                         }
[17:03:40.443]                       }
[17:03:40.443]                     }
[17:03:40.443]                     invisible(muffled)
[17:03:40.443]                   }
[17:03:40.443]                   muffleCondition(cond)
[17:03:40.443]                 })
[17:03:40.443]             }))
[17:03:40.443]             future::FutureResult(value = ...future.value$value, 
[17:03:40.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.443]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.443]                     ...future.globalenv.names))
[17:03:40.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.443]         }, condition = base::local({
[17:03:40.443]             c <- base::c
[17:03:40.443]             inherits <- base::inherits
[17:03:40.443]             invokeRestart <- base::invokeRestart
[17:03:40.443]             length <- base::length
[17:03:40.443]             list <- base::list
[17:03:40.443]             seq.int <- base::seq.int
[17:03:40.443]             signalCondition <- base::signalCondition
[17:03:40.443]             sys.calls <- base::sys.calls
[17:03:40.443]             `[[` <- base::`[[`
[17:03:40.443]             `+` <- base::`+`
[17:03:40.443]             `<<-` <- base::`<<-`
[17:03:40.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.443]                   3L)]
[17:03:40.443]             }
[17:03:40.443]             function(cond) {
[17:03:40.443]                 is_error <- inherits(cond, "error")
[17:03:40.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.443]                   NULL)
[17:03:40.443]                 if (is_error) {
[17:03:40.443]                   sessionInformation <- function() {
[17:03:40.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.443]                       search = base::search(), system = base::Sys.info())
[17:03:40.443]                   }
[17:03:40.443]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.443]                     cond$call), session = sessionInformation(), 
[17:03:40.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.443]                   signalCondition(cond)
[17:03:40.443]                 }
[17:03:40.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.443]                 "immediateCondition"))) {
[17:03:40.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.443]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.443]                   if (TRUE && !signal) {
[17:03:40.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.443]                     {
[17:03:40.443]                       inherits <- base::inherits
[17:03:40.443]                       invokeRestart <- base::invokeRestart
[17:03:40.443]                       is.null <- base::is.null
[17:03:40.443]                       muffled <- FALSE
[17:03:40.443]                       if (inherits(cond, "message")) {
[17:03:40.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.443]                         if (muffled) 
[17:03:40.443]                           invokeRestart("muffleMessage")
[17:03:40.443]                       }
[17:03:40.443]                       else if (inherits(cond, "warning")) {
[17:03:40.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.443]                         if (muffled) 
[17:03:40.443]                           invokeRestart("muffleWarning")
[17:03:40.443]                       }
[17:03:40.443]                       else if (inherits(cond, "condition")) {
[17:03:40.443]                         if (!is.null(pattern)) {
[17:03:40.443]                           computeRestarts <- base::computeRestarts
[17:03:40.443]                           grepl <- base::grepl
[17:03:40.443]                           restarts <- computeRestarts(cond)
[17:03:40.443]                           for (restart in restarts) {
[17:03:40.443]                             name <- restart$name
[17:03:40.443]                             if (is.null(name)) 
[17:03:40.443]                               next
[17:03:40.443]                             if (!grepl(pattern, name)) 
[17:03:40.443]                               next
[17:03:40.443]                             invokeRestart(restart)
[17:03:40.443]                             muffled <- TRUE
[17:03:40.443]                             break
[17:03:40.443]                           }
[17:03:40.443]                         }
[17:03:40.443]                       }
[17:03:40.443]                       invisible(muffled)
[17:03:40.443]                     }
[17:03:40.443]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.443]                   }
[17:03:40.443]                 }
[17:03:40.443]                 else {
[17:03:40.443]                   if (TRUE) {
[17:03:40.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.443]                     {
[17:03:40.443]                       inherits <- base::inherits
[17:03:40.443]                       invokeRestart <- base::invokeRestart
[17:03:40.443]                       is.null <- base::is.null
[17:03:40.443]                       muffled <- FALSE
[17:03:40.443]                       if (inherits(cond, "message")) {
[17:03:40.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.443]                         if (muffled) 
[17:03:40.443]                           invokeRestart("muffleMessage")
[17:03:40.443]                       }
[17:03:40.443]                       else if (inherits(cond, "warning")) {
[17:03:40.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.443]                         if (muffled) 
[17:03:40.443]                           invokeRestart("muffleWarning")
[17:03:40.443]                       }
[17:03:40.443]                       else if (inherits(cond, "condition")) {
[17:03:40.443]                         if (!is.null(pattern)) {
[17:03:40.443]                           computeRestarts <- base::computeRestarts
[17:03:40.443]                           grepl <- base::grepl
[17:03:40.443]                           restarts <- computeRestarts(cond)
[17:03:40.443]                           for (restart in restarts) {
[17:03:40.443]                             name <- restart$name
[17:03:40.443]                             if (is.null(name)) 
[17:03:40.443]                               next
[17:03:40.443]                             if (!grepl(pattern, name)) 
[17:03:40.443]                               next
[17:03:40.443]                             invokeRestart(restart)
[17:03:40.443]                             muffled <- TRUE
[17:03:40.443]                             break
[17:03:40.443]                           }
[17:03:40.443]                         }
[17:03:40.443]                       }
[17:03:40.443]                       invisible(muffled)
[17:03:40.443]                     }
[17:03:40.443]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.443]                   }
[17:03:40.443]                 }
[17:03:40.443]             }
[17:03:40.443]         }))
[17:03:40.443]     }, error = function(ex) {
[17:03:40.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.443]                 ...future.rng), started = ...future.startTime, 
[17:03:40.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.443]             version = "1.8"), class = "FutureResult")
[17:03:40.443]     }, finally = {
[17:03:40.443]         if (!identical(...future.workdir, getwd())) 
[17:03:40.443]             setwd(...future.workdir)
[17:03:40.443]         {
[17:03:40.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.443]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.443]             }
[17:03:40.443]             base::options(...future.oldOptions)
[17:03:40.443]             if (.Platform$OS.type == "windows") {
[17:03:40.443]                 old_names <- names(...future.oldEnvVars)
[17:03:40.443]                 envs <- base::Sys.getenv()
[17:03:40.443]                 names <- names(envs)
[17:03:40.443]                 common <- intersect(names, old_names)
[17:03:40.443]                 added <- setdiff(names, old_names)
[17:03:40.443]                 removed <- setdiff(old_names, names)
[17:03:40.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.443]                   envs[common]]
[17:03:40.443]                 NAMES <- toupper(changed)
[17:03:40.443]                 args <- list()
[17:03:40.443]                 for (kk in seq_along(NAMES)) {
[17:03:40.443]                   name <- changed[[kk]]
[17:03:40.443]                   NAME <- NAMES[[kk]]
[17:03:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.443]                     next
[17:03:40.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.443]                 }
[17:03:40.443]                 NAMES <- toupper(added)
[17:03:40.443]                 for (kk in seq_along(NAMES)) {
[17:03:40.443]                   name <- added[[kk]]
[17:03:40.443]                   NAME <- NAMES[[kk]]
[17:03:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.443]                     next
[17:03:40.443]                   args[[name]] <- ""
[17:03:40.443]                 }
[17:03:40.443]                 NAMES <- toupper(removed)
[17:03:40.443]                 for (kk in seq_along(NAMES)) {
[17:03:40.443]                   name <- removed[[kk]]
[17:03:40.443]                   NAME <- NAMES[[kk]]
[17:03:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.443]                     next
[17:03:40.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.443]                 }
[17:03:40.443]                 if (length(args) > 0) 
[17:03:40.443]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.443]             }
[17:03:40.443]             else {
[17:03:40.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.443]             }
[17:03:40.443]             {
[17:03:40.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.443]                   0L) {
[17:03:40.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.443]                   base::options(opts)
[17:03:40.443]                 }
[17:03:40.443]                 {
[17:03:40.443]                   {
[17:03:40.443]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.443]                     NULL
[17:03:40.443]                   }
[17:03:40.443]                   options(future.plan = NULL)
[17:03:40.443]                   if (is.na(NA_character_)) 
[17:03:40.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.443]                     .init = FALSE)
[17:03:40.443]                 }
[17:03:40.443]             }
[17:03:40.443]         }
[17:03:40.443]     })
[17:03:40.443]     if (TRUE) {
[17:03:40.443]         base::sink(type = "output", split = FALSE)
[17:03:40.443]         if (TRUE) {
[17:03:40.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.443]         }
[17:03:40.443]         else {
[17:03:40.443]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.443]         }
[17:03:40.443]         base::close(...future.stdout)
[17:03:40.443]         ...future.stdout <- NULL
[17:03:40.443]     }
[17:03:40.443]     ...future.result$conditions <- ...future.conditions
[17:03:40.443]     ...future.result$finished <- base::Sys.time()
[17:03:40.443]     ...future.result
[17:03:40.443] }
[17:03:40.446] requestCore(): workers = 2
[17:03:40.447] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.457] result() for MulticoreFuture ...
[17:03:40.458] result() for MulticoreFuture ...
[17:03:40.459] result() for MulticoreFuture ... done
[17:03:40.459] result() for MulticoreFuture ... done
[17:03:40.459] result() for MulticoreFuture ...
[17:03:40.459] result() for MulticoreFuture ... done
[17:03:40.462] MulticoreFuture started
[17:03:40.463] - Launch lazy future ... done
[17:03:40.463] run() for ‘MulticoreFuture’ ... done
[17:03:40.463] plan(): Setting new future strategy stack:
[17:03:40.465] getGlobalsAndPackages() ...
[17:03:40.464] List of future strategies:
[17:03:40.464] 1. sequential:
[17:03:40.464]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.464]    - tweaked: FALSE
[17:03:40.464]    - call: NULL
[17:03:40.465] Searching for globals...
[17:03:40.465] plan(): nbrOfWorkers() = 1
[17:03:40.466] - globals found: [1] ‘{’
[17:03:40.467] Searching for globals ... DONE
[17:03:40.467] Resolving globals: FALSE
[17:03:40.467] 
[17:03:40.468] 
[17:03:40.468] getGlobalsAndPackages() ... DONE
[17:03:40.468] run() for ‘Future’ ...
[17:03:40.468] - state: ‘created’
[17:03:40.469] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:03:40.474] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:40.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:03:40.474]   - Field: ‘label’
[17:03:40.474]   - Field: ‘local’
[17:03:40.475]   - Field: ‘owner’
[17:03:40.475]   - Field: ‘envir’
[17:03:40.475]   - Field: ‘workers’
[17:03:40.475]   - Field: ‘packages’
[17:03:40.475]   - Field: ‘gc’
[17:03:40.475]   - Field: ‘job’
[17:03:40.475]   - Field: ‘conditions’
[17:03:40.476]   - Field: ‘expr’
[17:03:40.476]   - Field: ‘uuid’
[17:03:40.476]   - Field: ‘seed’
[17:03:40.476]   - Field: ‘version’
[17:03:40.476]   - Field: ‘result’
[17:03:40.476]   - Field: ‘asynchronous’
[17:03:40.476]   - Field: ‘calls’
[17:03:40.477]   - Field: ‘globals’
[17:03:40.477]   - Field: ‘stdout’
[17:03:40.477]   - Field: ‘earlySignal’
[17:03:40.477]   - Field: ‘lazy’
[17:03:40.477]   - Field: ‘state’
[17:03:40.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:03:40.478] - Launch lazy future ...
[17:03:40.478] Packages needed by the future expression (n = 0): <none>
[17:03:40.478] Packages needed by future strategies (n = 0): <none>
[17:03:40.479] {
[17:03:40.479]     {
[17:03:40.479]         {
[17:03:40.479]             ...future.startTime <- base::Sys.time()
[17:03:40.479]             {
[17:03:40.479]                 {
[17:03:40.479]                   {
[17:03:40.479]                     {
[17:03:40.479]                       base::local({
[17:03:40.479]                         has_future <- base::requireNamespace("future", 
[17:03:40.479]                           quietly = TRUE)
[17:03:40.479]                         if (has_future) {
[17:03:40.479]                           ns <- base::getNamespace("future")
[17:03:40.479]                           version <- ns[[".package"]][["version"]]
[17:03:40.479]                           if (is.null(version)) 
[17:03:40.479]                             version <- utils::packageVersion("future")
[17:03:40.479]                         }
[17:03:40.479]                         else {
[17:03:40.479]                           version <- NULL
[17:03:40.479]                         }
[17:03:40.479]                         if (!has_future || version < "1.8.0") {
[17:03:40.479]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:40.479]                             "", base::R.version$version.string), 
[17:03:40.479]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:40.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:40.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:40.479]                               "release", "version")], collapse = " "), 
[17:03:40.479]                             hostname = base::Sys.info()[["nodename"]])
[17:03:40.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:40.479]                             info)
[17:03:40.479]                           info <- base::paste(info, collapse = "; ")
[17:03:40.479]                           if (!has_future) {
[17:03:40.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:40.479]                               info)
[17:03:40.479]                           }
[17:03:40.479]                           else {
[17:03:40.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:40.479]                               info, version)
[17:03:40.479]                           }
[17:03:40.479]                           base::stop(msg)
[17:03:40.479]                         }
[17:03:40.479]                       })
[17:03:40.479]                     }
[17:03:40.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:40.479]                     base::options(mc.cores = 1L)
[17:03:40.479]                   }
[17:03:40.479]                   ...future.strategy.old <- future::plan("list")
[17:03:40.479]                   options(future.plan = NULL)
[17:03:40.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:40.479]                 }
[17:03:40.479]                 ...future.workdir <- getwd()
[17:03:40.479]             }
[17:03:40.479]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:40.479]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:40.479]         }
[17:03:40.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:40.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:40.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:40.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:40.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:40.479]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:40.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:40.479]             base::names(...future.oldOptions))
[17:03:40.479]     }
[17:03:40.479]     if (FALSE) {
[17:03:40.479]     }
[17:03:40.479]     else {
[17:03:40.479]         if (TRUE) {
[17:03:40.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:40.479]                 open = "w")
[17:03:40.479]         }
[17:03:40.479]         else {
[17:03:40.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:40.479]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:40.479]         }
[17:03:40.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:40.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:40.479]             base::sink(type = "output", split = FALSE)
[17:03:40.479]             base::close(...future.stdout)
[17:03:40.479]         }, add = TRUE)
[17:03:40.479]     }
[17:03:40.479]     ...future.frame <- base::sys.nframe()
[17:03:40.479]     ...future.conditions <- base::list()
[17:03:40.479]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:40.479]     if (FALSE) {
[17:03:40.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:40.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:40.479]     }
[17:03:40.479]     ...future.result <- base::tryCatch({
[17:03:40.479]         base::withCallingHandlers({
[17:03:40.479]             ...future.value <- base::withVisible(base::local({
[17:03:40.479]                 withCallingHandlers({
[17:03:40.479]                   {
[17:03:40.479]                     3
[17:03:40.479]                   }
[17:03:40.479]                 }, immediateCondition = function(cond) {
[17:03:40.479]                   save_rds <- function (object, pathname, ...) 
[17:03:40.479]                   {
[17:03:40.479]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:03:40.479]                     if (file_test("-f", pathname_tmp)) {
[17:03:40.479]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.479]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:03:40.479]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.479]                         fi_tmp[["mtime"]])
[17:03:40.479]                     }
[17:03:40.479]                     tryCatch({
[17:03:40.479]                       saveRDS(object, file = pathname_tmp, ...)
[17:03:40.479]                     }, error = function(ex) {
[17:03:40.479]                       msg <- conditionMessage(ex)
[17:03:40.479]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.479]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:03:40.479]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.479]                         fi_tmp[["mtime"]], msg)
[17:03:40.479]                       ex$message <- msg
[17:03:40.479]                       stop(ex)
[17:03:40.479]                     })
[17:03:40.479]                     stopifnot(file_test("-f", pathname_tmp))
[17:03:40.479]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:03:40.479]                     if (!res || file_test("-f", pathname_tmp)) {
[17:03:40.479]                       fi_tmp <- file.info(pathname_tmp)
[17:03:40.479]                       fi <- file.info(pathname)
[17:03:40.479]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:03:40.479]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:03:40.479]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:03:40.479]                         fi[["size"]], fi[["mtime"]])
[17:03:40.479]                       stop(msg)
[17:03:40.479]                     }
[17:03:40.479]                     invisible(pathname)
[17:03:40.479]                   }
[17:03:40.479]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:03:40.479]                     rootPath = tempdir()) 
[17:03:40.479]                   {
[17:03:40.479]                     obj <- list(time = Sys.time(), condition = cond)
[17:03:40.479]                     file <- tempfile(pattern = class(cond)[1], 
[17:03:40.479]                       tmpdir = path, fileext = ".rds")
[17:03:40.479]                     save_rds(obj, file)
[17:03:40.479]                   }
[17:03:40.479]                   saveImmediateCondition(cond, path = "/tmp/RtmpHiJQUw/.future/immediateConditions")
[17:03:40.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.479]                   {
[17:03:40.479]                     inherits <- base::inherits
[17:03:40.479]                     invokeRestart <- base::invokeRestart
[17:03:40.479]                     is.null <- base::is.null
[17:03:40.479]                     muffled <- FALSE
[17:03:40.479]                     if (inherits(cond, "message")) {
[17:03:40.479]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:40.479]                       if (muffled) 
[17:03:40.479]                         invokeRestart("muffleMessage")
[17:03:40.479]                     }
[17:03:40.479]                     else if (inherits(cond, "warning")) {
[17:03:40.479]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:40.479]                       if (muffled) 
[17:03:40.479]                         invokeRestart("muffleWarning")
[17:03:40.479]                     }
[17:03:40.479]                     else if (inherits(cond, "condition")) {
[17:03:40.479]                       if (!is.null(pattern)) {
[17:03:40.479]                         computeRestarts <- base::computeRestarts
[17:03:40.479]                         grepl <- base::grepl
[17:03:40.479]                         restarts <- computeRestarts(cond)
[17:03:40.479]                         for (restart in restarts) {
[17:03:40.479]                           name <- restart$name
[17:03:40.479]                           if (is.null(name)) 
[17:03:40.479]                             next
[17:03:40.479]                           if (!grepl(pattern, name)) 
[17:03:40.479]                             next
[17:03:40.479]                           invokeRestart(restart)
[17:03:40.479]                           muffled <- TRUE
[17:03:40.479]                           break
[17:03:40.479]                         }
[17:03:40.479]                       }
[17:03:40.479]                     }
[17:03:40.479]                     invisible(muffled)
[17:03:40.479]                   }
[17:03:40.479]                   muffleCondition(cond)
[17:03:40.479]                 })
[17:03:40.479]             }))
[17:03:40.479]             future::FutureResult(value = ...future.value$value, 
[17:03:40.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.479]                   ...future.rng), globalenv = if (FALSE) 
[17:03:40.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:40.479]                     ...future.globalenv.names))
[17:03:40.479]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:40.479]         }, condition = base::local({
[17:03:40.479]             c <- base::c
[17:03:40.479]             inherits <- base::inherits
[17:03:40.479]             invokeRestart <- base::invokeRestart
[17:03:40.479]             length <- base::length
[17:03:40.479]             list <- base::list
[17:03:40.479]             seq.int <- base::seq.int
[17:03:40.479]             signalCondition <- base::signalCondition
[17:03:40.479]             sys.calls <- base::sys.calls
[17:03:40.479]             `[[` <- base::`[[`
[17:03:40.479]             `+` <- base::`+`
[17:03:40.479]             `<<-` <- base::`<<-`
[17:03:40.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:40.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:40.479]                   3L)]
[17:03:40.479]             }
[17:03:40.479]             function(cond) {
[17:03:40.479]                 is_error <- inherits(cond, "error")
[17:03:40.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:40.479]                   NULL)
[17:03:40.479]                 if (is_error) {
[17:03:40.479]                   sessionInformation <- function() {
[17:03:40.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:40.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:40.479]                       search = base::search(), system = base::Sys.info())
[17:03:40.479]                   }
[17:03:40.479]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:40.479]                     cond$call), session = sessionInformation(), 
[17:03:40.479]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:40.479]                   signalCondition(cond)
[17:03:40.479]                 }
[17:03:40.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:40.479]                 "immediateCondition"))) {
[17:03:40.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:40.479]                   ...future.conditions[[length(...future.conditions) + 
[17:03:40.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:40.479]                   if (TRUE && !signal) {
[17:03:40.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.479]                     {
[17:03:40.479]                       inherits <- base::inherits
[17:03:40.479]                       invokeRestart <- base::invokeRestart
[17:03:40.479]                       is.null <- base::is.null
[17:03:40.479]                       muffled <- FALSE
[17:03:40.479]                       if (inherits(cond, "message")) {
[17:03:40.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.479]                         if (muffled) 
[17:03:40.479]                           invokeRestart("muffleMessage")
[17:03:40.479]                       }
[17:03:40.479]                       else if (inherits(cond, "warning")) {
[17:03:40.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.479]                         if (muffled) 
[17:03:40.479]                           invokeRestart("muffleWarning")
[17:03:40.479]                       }
[17:03:40.479]                       else if (inherits(cond, "condition")) {
[17:03:40.479]                         if (!is.null(pattern)) {
[17:03:40.479]                           computeRestarts <- base::computeRestarts
[17:03:40.479]                           grepl <- base::grepl
[17:03:40.479]                           restarts <- computeRestarts(cond)
[17:03:40.479]                           for (restart in restarts) {
[17:03:40.479]                             name <- restart$name
[17:03:40.479]                             if (is.null(name)) 
[17:03:40.479]                               next
[17:03:40.479]                             if (!grepl(pattern, name)) 
[17:03:40.479]                               next
[17:03:40.479]                             invokeRestart(restart)
[17:03:40.479]                             muffled <- TRUE
[17:03:40.479]                             break
[17:03:40.479]                           }
[17:03:40.479]                         }
[17:03:40.479]                       }
[17:03:40.479]                       invisible(muffled)
[17:03:40.479]                     }
[17:03:40.479]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.479]                   }
[17:03:40.479]                 }
[17:03:40.479]                 else {
[17:03:40.479]                   if (TRUE) {
[17:03:40.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:40.479]                     {
[17:03:40.479]                       inherits <- base::inherits
[17:03:40.479]                       invokeRestart <- base::invokeRestart
[17:03:40.479]                       is.null <- base::is.null
[17:03:40.479]                       muffled <- FALSE
[17:03:40.479]                       if (inherits(cond, "message")) {
[17:03:40.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:40.479]                         if (muffled) 
[17:03:40.479]                           invokeRestart("muffleMessage")
[17:03:40.479]                       }
[17:03:40.479]                       else if (inherits(cond, "warning")) {
[17:03:40.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:40.479]                         if (muffled) 
[17:03:40.479]                           invokeRestart("muffleWarning")
[17:03:40.479]                       }
[17:03:40.479]                       else if (inherits(cond, "condition")) {
[17:03:40.479]                         if (!is.null(pattern)) {
[17:03:40.479]                           computeRestarts <- base::computeRestarts
[17:03:40.479]                           grepl <- base::grepl
[17:03:40.479]                           restarts <- computeRestarts(cond)
[17:03:40.479]                           for (restart in restarts) {
[17:03:40.479]                             name <- restart$name
[17:03:40.479]                             if (is.null(name)) 
[17:03:40.479]                               next
[17:03:40.479]                             if (!grepl(pattern, name)) 
[17:03:40.479]                               next
[17:03:40.479]                             invokeRestart(restart)
[17:03:40.479]                             muffled <- TRUE
[17:03:40.479]                             break
[17:03:40.479]                           }
[17:03:40.479]                         }
[17:03:40.479]                       }
[17:03:40.479]                       invisible(muffled)
[17:03:40.479]                     }
[17:03:40.479]                     muffleCondition(cond, pattern = "^muffle")
[17:03:40.479]                   }
[17:03:40.479]                 }
[17:03:40.479]             }
[17:03:40.479]         }))
[17:03:40.479]     }, error = function(ex) {
[17:03:40.479]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:40.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:40.479]                 ...future.rng), started = ...future.startTime, 
[17:03:40.479]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:40.479]             version = "1.8"), class = "FutureResult")
[17:03:40.479]     }, finally = {
[17:03:40.479]         if (!identical(...future.workdir, getwd())) 
[17:03:40.479]             setwd(...future.workdir)
[17:03:40.479]         {
[17:03:40.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:40.479]                 ...future.oldOptions$nwarnings <- NULL
[17:03:40.479]             }
[17:03:40.479]             base::options(...future.oldOptions)
[17:03:40.479]             if (.Platform$OS.type == "windows") {
[17:03:40.479]                 old_names <- names(...future.oldEnvVars)
[17:03:40.479]                 envs <- base::Sys.getenv()
[17:03:40.479]                 names <- names(envs)
[17:03:40.479]                 common <- intersect(names, old_names)
[17:03:40.479]                 added <- setdiff(names, old_names)
[17:03:40.479]                 removed <- setdiff(old_names, names)
[17:03:40.479]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:40.479]                   envs[common]]
[17:03:40.479]                 NAMES <- toupper(changed)
[17:03:40.479]                 args <- list()
[17:03:40.479]                 for (kk in seq_along(NAMES)) {
[17:03:40.479]                   name <- changed[[kk]]
[17:03:40.479]                   NAME <- NAMES[[kk]]
[17:03:40.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.479]                     next
[17:03:40.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.479]                 }
[17:03:40.479]                 NAMES <- toupper(added)
[17:03:40.479]                 for (kk in seq_along(NAMES)) {
[17:03:40.479]                   name <- added[[kk]]
[17:03:40.479]                   NAME <- NAMES[[kk]]
[17:03:40.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.479]                     next
[17:03:40.479]                   args[[name]] <- ""
[17:03:40.479]                 }
[17:03:40.479]                 NAMES <- toupper(removed)
[17:03:40.479]                 for (kk in seq_along(NAMES)) {
[17:03:40.479]                   name <- removed[[kk]]
[17:03:40.479]                   NAME <- NAMES[[kk]]
[17:03:40.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:40.479]                     next
[17:03:40.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:40.479]                 }
[17:03:40.479]                 if (length(args) > 0) 
[17:03:40.479]                   base::do.call(base::Sys.setenv, args = args)
[17:03:40.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:40.479]             }
[17:03:40.479]             else {
[17:03:40.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:40.479]             }
[17:03:40.479]             {
[17:03:40.479]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:40.479]                   0L) {
[17:03:40.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:40.479]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:40.479]                   base::options(opts)
[17:03:40.479]                 }
[17:03:40.479]                 {
[17:03:40.479]                   {
[17:03:40.479]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:40.479]                     NULL
[17:03:40.479]                   }
[17:03:40.479]                   options(future.plan = NULL)
[17:03:40.479]                   if (is.na(NA_character_)) 
[17:03:40.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:40.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:40.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:40.479]                     .init = FALSE)
[17:03:40.479]                 }
[17:03:40.479]             }
[17:03:40.479]         }
[17:03:40.479]     })
[17:03:40.479]     if (TRUE) {
[17:03:40.479]         base::sink(type = "output", split = FALSE)
[17:03:40.479]         if (TRUE) {
[17:03:40.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:40.479]         }
[17:03:40.479]         else {
[17:03:40.479]             ...future.result["stdout"] <- base::list(NULL)
[17:03:40.479]         }
[17:03:40.479]         base::close(...future.stdout)
[17:03:40.479]         ...future.stdout <- NULL
[17:03:40.479]     }
[17:03:40.479]     ...future.result$conditions <- ...future.conditions
[17:03:40.479]     ...future.result$finished <- base::Sys.time()
[17:03:40.479]     ...future.result
[17:03:40.479] }
[17:03:40.482] requestCore(): workers = 2
[17:03:40.483] Poll #1 (0): usedCores() = 2, workers = 2
[17:03:40.494] result() for MulticoreFuture ...
[17:03:40.494] result() for MulticoreFuture ...
[17:03:40.495] result() for MulticoreFuture ... done
[17:03:40.495] result() for MulticoreFuture ... done
[17:03:40.495] result() for MulticoreFuture ...
[17:03:40.495] result() for MulticoreFuture ... done
[17:03:40.498] MulticoreFuture started
[17:03:40.498] - Launch lazy future ... done
[17:03:40.498] run() for ‘MulticoreFuture’ ... done
[17:03:40.499] plan(): Setting new future strategy stack:
[17:03:40.499] List of future strategies:
[17:03:40.499] 1. sequential:
[17:03:40.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:40.499]    - tweaked: FALSE
[17:03:40.499]    - call: NULL
[17:03:40.500] resolve() on list environment ...
[17:03:40.501] plan(): nbrOfWorkers() = 1
[17:03:40.501]  recursive: 0
[17:03:40.502]  length: 4
[17:03:40.502]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:40.503] Future #1
[17:03:40.503]  length: 3 (resolved future 1)
[17:03:40.504] plan(): Setting new future strategy stack:
[17:03:40.504] List of future strategies:
[17:03:40.504] 1. multicore:
[17:03:40.504]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.504]    - tweaked: FALSE
[17:03:40.504]    - call: plan(strategy)
[17:03:40.509] plan(): nbrOfWorkers() = 2
[17:03:40.514] Future #3
[17:03:40.514]  length: 2 (resolved future 3)
[17:03:40.515]  length: 1 (resolved future 4)
[17:03:40.968] plan(): Setting new future strategy stack:
[17:03:40.968] List of future strategies:
[17:03:40.968] 1. multicore:
[17:03:40.968]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:03:40.968]    - tweaked: FALSE
[17:03:40.968]    - call: plan(strategy)
[17:03:40.973] plan(): nbrOfWorkers() = 2
[17:03:40.975] Future #2
[17:03:40.976]  length: 0 (resolved future 2)
[17:03:40.976] resolve() on list environment ... DONE
[17:03:40.976] resolve() on list environment ...
[17:03:40.977]  recursive: 0
[17:03:40.978]  length: 4
[17:03:40.978]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:40.978] Future #1
[17:03:40.978]  length: 3 (resolved future 1)
[17:03:40.979] Future #2
[17:03:40.979]  length: 2 (resolved future 2)
[17:03:40.979] Future #3
[17:03:40.979]  length: 1 (resolved future 3)
[17:03:40.979]  length: 0 (resolved future 4)
[17:03:40.980] resolve() on list environment ... DONE
[17:03:40.980] resolve() on list environment ...
[17:03:40.981]  recursive: 0
[17:03:40.982]  length: 4
[17:03:40.982]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:40.982] Future #1
[17:03:40.982]  length: 3 (resolved future 1)
[17:03:40.982] Future #2
[17:03:40.983]  length: 2 (resolved future 2)
[17:03:40.983] Future #3
[17:03:40.983]  length: 1 (resolved future 3)
[17:03:40.983]  length: 0 (resolved future 4)
[17:03:40.983] resolve() on list environment ... DONE
[17:03:40.984] resolve() on list environment ...
[17:03:40.984]  recursive: 0
[17:03:40.985]  length: 4
[17:03:40.985]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:40.986] Future #1
[17:03:40.990]  length: 3 (resolved future 1)
[17:03:40.990] Future #2
[17:03:40.991]  length: 2 (resolved future 2)
[17:03:40.991] Future #3
[17:03:40.992]  length: 1 (resolved future 3)
[17:03:40.992]  length: 0 (resolved future 4)
[17:03:40.992] resolve() on list environment ... DONE
[17:03:40.994] resolve() on list environment ...
[17:03:40.994]  recursive: 0
[17:03:40.995]  length: 4
[17:03:40.995]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:40.995] Future #1
[17:03:40.996] result() for MulticoreFuture ...
[17:03:40.996] result() for MulticoreFuture ... done
[17:03:40.996] result() for MulticoreFuture ...
[17:03:40.996] result() for MulticoreFuture ... done
[17:03:40.996]  length: 3 (resolved future 1)
[17:03:40.997] Future #2
[17:03:40.997] result() for MulticoreFuture ...
[17:03:40.998] result() for MulticoreFuture ...
[17:03:40.998] result() for MulticoreFuture ... done
[17:03:40.998] result() for MulticoreFuture ... done
[17:03:40.998] result() for MulticoreFuture ...
[17:03:40.999] result() for MulticoreFuture ... done
[17:03:40.999]  length: 2 (resolved future 2)
[17:03:40.999] Future #3
[17:03:40.999] result() for MulticoreFuture ...
[17:03:41.000] result() for MulticoreFuture ...
[17:03:41.000] result() for MulticoreFuture ... done
[17:03:41.001] result() for MulticoreFuture ... done
[17:03:41.001] result() for MulticoreFuture ...
[17:03:41.001] result() for MulticoreFuture ... done
[17:03:41.001]  length: 1 (resolved future 3)
[17:03:41.001]  length: 0 (resolved future 4)
[17:03:41.002] resolve() on list environment ... DONE
[17:03:41.002] resolve() on list environment ...
[17:03:41.002]  recursive: 99
[17:03:41.003]  length: 4
[17:03:41.003]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:41.003] Future #1
[17:03:41.003] result() for MulticoreFuture ...
[17:03:41.004] result() for MulticoreFuture ... done
[17:03:41.004] result() for MulticoreFuture ...
[17:03:41.004] result() for MulticoreFuture ... done
[17:03:41.004] A MulticoreFuture was resolved
[17:03:41.004]  length: 3 (resolved future 1)
[17:03:41.004] Future #2
[17:03:41.004] result() for MulticoreFuture ...
[17:03:41.004] result() for MulticoreFuture ... done
[17:03:41.004] result() for MulticoreFuture ...
[17:03:41.005] result() for MulticoreFuture ... done
[17:03:41.005] A MulticoreFuture was resolved
[17:03:41.005]  length: 2 (resolved future 2)
[17:03:41.005] Future #3
[17:03:41.005] result() for MulticoreFuture ...
[17:03:41.005] result() for MulticoreFuture ... done
[17:03:41.005] result() for MulticoreFuture ...
[17:03:41.006] result() for MulticoreFuture ... done
[17:03:41.006] A MulticoreFuture was resolved
[17:03:41.006]  length: 1 (resolved future 3)
[17:03:41.006]  length: 0 (resolved future 4)
[17:03:41.006] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[17:03:41.007] plan(): Setting new future strategy stack:
[17:03:41.007] List of future strategies:
[17:03:41.007] 1. multisession:
[17:03:41.007]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:03:41.007]    - tweaked: FALSE
[17:03:41.007]    - call: plan(strategy)
[17:03:41.007] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:03:41.007] multisession:
[17:03:41.007] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:03:41.007] - tweaked: FALSE
[17:03:41.007] - call: plan(strategy)
[17:03:41.013] getGlobalsAndPackages() ...
[17:03:41.014] Not searching for globals
[17:03:41.014] - globals: [0] <none>
[17:03:41.014] getGlobalsAndPackages() ... DONE
[17:03:41.014] [local output] makeClusterPSOCK() ...
[17:03:41.060] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:03:41.061] [local output] Base port: 11254
[17:03:41.062] [local output] Getting setup options for 2 cluster nodes ...
[17:03:41.062] [local output]  - Node 1 of 2 ...
[17:03:41.062] [local output] localMachine=TRUE => revtunnel=FALSE

[17:03:41.063] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpHiJQUw/worker.rank=1.parallelly.parent=48729.be59506b3df3.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpHiJQUw/worker.rank=1.parallelly.parent=48729.be59506b3df3.pid")'’
[17:03:41.254] - Possible to infer worker's PID: TRUE
[17:03:41.254] [local output] Rscript port: 11254

[17:03:41.255] [local output]  - Node 2 of 2 ...
[17:03:41.255] [local output] localMachine=TRUE => revtunnel=FALSE

[17:03:41.256] [local output] Rscript port: 11254

[17:03:41.256] [local output] Getting setup options for 2 cluster nodes ... done
[17:03:41.256] [local output]  - Parallel setup requested for some PSOCK nodes
[17:03:41.257] [local output] Setting up PSOCK nodes in parallel
[17:03:41.257] List of 36
[17:03:41.257]  $ worker          : chr "localhost"
[17:03:41.257]   ..- attr(*, "localhost")= logi TRUE
[17:03:41.257]  $ master          : chr "localhost"
[17:03:41.257]  $ port            : int 11254
[17:03:41.257]  $ connectTimeout  : num 120
[17:03:41.257]  $ timeout         : num 2592000
[17:03:41.257]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:03:41.257]  $ homogeneous     : logi TRUE
[17:03:41.257]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:03:41.257]  $ rscript_envs    : NULL
[17:03:41.257]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:03:41.257]  $ rscript_startup : NULL
[17:03:41.257]  $ rscript_sh      : chr "sh"
[17:03:41.257]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:03:41.257]  $ methods         : logi TRUE
[17:03:41.257]  $ socketOptions   : chr "no-delay"
[17:03:41.257]  $ useXDR          : logi FALSE
[17:03:41.257]  $ outfile         : chr "/dev/null"
[17:03:41.257]  $ renice          : int NA
[17:03:41.257]  $ rshcmd          : NULL
[17:03:41.257]  $ user            : chr(0) 
[17:03:41.257]  $ revtunnel       : logi FALSE
[17:03:41.257]  $ rshlogfile      : NULL
[17:03:41.257]  $ rshopts         : chr(0) 
[17:03:41.257]  $ rank            : int 1
[17:03:41.257]  $ manual          : logi FALSE
[17:03:41.257]  $ dryrun          : logi FALSE
[17:03:41.257]  $ quiet           : logi FALSE
[17:03:41.257]  $ setup_strategy  : chr "parallel"
[17:03:41.257]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:03:41.257]  $ pidfile         : chr "/tmp/RtmpHiJQUw/worker.rank=1.parallelly.parent=48729.be59506b3df3.pid"
[17:03:41.257]  $ rshcmd_label    : NULL
[17:03:41.257]  $ rsh_call        : NULL
[17:03:41.257]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:03:41.257]  $ localMachine    : logi TRUE
[17:03:41.257]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:03:41.257]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:03:41.257]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:03:41.257]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:03:41.257]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:03:41.257]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:03:41.257]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:03:41.257]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:03:41.257]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:03:41.257]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:03:41.257]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:03:41.257]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:03:41.257]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:03:41.257]  $ arguments       :List of 28
[17:03:41.257]   ..$ worker          : chr "localhost"
[17:03:41.257]   ..$ master          : NULL
[17:03:41.257]   ..$ port            : int 11254
[17:03:41.257]   ..$ connectTimeout  : num 120
[17:03:41.257]   ..$ timeout         : num 2592000
[17:03:41.257]   ..$ rscript         : NULL
[17:03:41.257]   ..$ homogeneous     : NULL
[17:03:41.257]   ..$ rscript_args    : NULL
[17:03:41.257]   ..$ rscript_envs    : NULL
[17:03:41.257]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:03:41.257]   ..$ rscript_startup : NULL
[17:03:41.257]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:03:41.257]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:03:41.257]   ..$ methods         : logi TRUE
[17:03:41.257]   ..$ socketOptions   : chr "no-delay"
[17:03:41.257]   ..$ useXDR          : logi FALSE
[17:03:41.257]   ..$ outfile         : chr "/dev/null"
[17:03:41.257]   ..$ renice          : int NA
[17:03:41.257]   ..$ rshcmd          : NULL
[17:03:41.257]   ..$ user            : NULL
[17:03:41.257]   ..$ revtunnel       : logi NA
[17:03:41.257]   ..$ rshlogfile      : NULL
[17:03:41.257]   ..$ rshopts         : NULL
[17:03:41.257]   ..$ rank            : int 1
[17:03:41.257]   ..$ manual          : logi FALSE
[17:03:41.257]   ..$ dryrun          : logi FALSE
[17:03:41.257]   ..$ quiet           : logi FALSE
[17:03:41.257]   ..$ setup_strategy  : chr "parallel"
[17:03:41.257]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:03:41.273] [local output] System call to launch all workers:
[17:03:41.273] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpHiJQUw/worker.rank=1.parallelly.parent=48729.be59506b3df3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11254 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:03:41.273] [local output] Starting PSOCK main server
[17:03:41.279] [local output] Workers launched
[17:03:41.279] [local output] Waiting for workers to connect back
[17:03:41.279]  - [local output] 0 workers out of 2 ready
[17:03:41.517]  - [local output] 0 workers out of 2 ready
[17:03:41.518]  - [local output] 1 workers out of 2 ready
[17:03:41.534]  - [local output] 1 workers out of 2 ready
[17:03:41.534]  - [local output] 2 workers out of 2 ready
[17:03:41.534] [local output] Launching of workers completed
[17:03:41.534] [local output] Collecting session information from workers
[17:03:41.535] [local output]  - Worker #1 of 2
[17:03:41.536] [local output]  - Worker #2 of 2
[17:03:41.536] [local output] makeClusterPSOCK() ... done
[17:03:41.547] Packages needed by the future expression (n = 0): <none>
[17:03:41.547] Packages needed by future strategies (n = 0): <none>
[17:03:41.548] {
[17:03:41.548]     {
[17:03:41.548]         {
[17:03:41.548]             ...future.startTime <- base::Sys.time()
[17:03:41.548]             {
[17:03:41.548]                 {
[17:03:41.548]                   {
[17:03:41.548]                     {
[17:03:41.548]                       base::local({
[17:03:41.548]                         has_future <- base::requireNamespace("future", 
[17:03:41.548]                           quietly = TRUE)
[17:03:41.548]                         if (has_future) {
[17:03:41.548]                           ns <- base::getNamespace("future")
[17:03:41.548]                           version <- ns[[".package"]][["version"]]
[17:03:41.548]                           if (is.null(version)) 
[17:03:41.548]                             version <- utils::packageVersion("future")
[17:03:41.548]                         }
[17:03:41.548]                         else {
[17:03:41.548]                           version <- NULL
[17:03:41.548]                         }
[17:03:41.548]                         if (!has_future || version < "1.8.0") {
[17:03:41.548]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:41.548]                             "", base::R.version$version.string), 
[17:03:41.548]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:41.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:41.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:41.548]                               "release", "version")], collapse = " "), 
[17:03:41.548]                             hostname = base::Sys.info()[["nodename"]])
[17:03:41.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:41.548]                             info)
[17:03:41.548]                           info <- base::paste(info, collapse = "; ")
[17:03:41.548]                           if (!has_future) {
[17:03:41.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:41.548]                               info)
[17:03:41.548]                           }
[17:03:41.548]                           else {
[17:03:41.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:41.548]                               info, version)
[17:03:41.548]                           }
[17:03:41.548]                           base::stop(msg)
[17:03:41.548]                         }
[17:03:41.548]                       })
[17:03:41.548]                     }
[17:03:41.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:41.548]                     base::options(mc.cores = 1L)
[17:03:41.548]                   }
[17:03:41.548]                   ...future.strategy.old <- future::plan("list")
[17:03:41.548]                   options(future.plan = NULL)
[17:03:41.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:41.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:41.548]                 }
[17:03:41.548]                 ...future.workdir <- getwd()
[17:03:41.548]             }
[17:03:41.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:41.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:41.548]         }
[17:03:41.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:41.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:41.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:41.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:41.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:41.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:41.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:41.548]             base::names(...future.oldOptions))
[17:03:41.548]     }
[17:03:41.548]     if (FALSE) {
[17:03:41.548]     }
[17:03:41.548]     else {
[17:03:41.548]         if (TRUE) {
[17:03:41.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:41.548]                 open = "w")
[17:03:41.548]         }
[17:03:41.548]         else {
[17:03:41.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:41.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:41.548]         }
[17:03:41.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:41.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:41.548]             base::sink(type = "output", split = FALSE)
[17:03:41.548]             base::close(...future.stdout)
[17:03:41.548]         }, add = TRUE)
[17:03:41.548]     }
[17:03:41.548]     ...future.frame <- base::sys.nframe()
[17:03:41.548]     ...future.conditions <- base::list()
[17:03:41.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:41.548]     if (FALSE) {
[17:03:41.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:41.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:41.548]     }
[17:03:41.548]     ...future.result <- base::tryCatch({
[17:03:41.548]         base::withCallingHandlers({
[17:03:41.548]             ...future.value <- base::withVisible(base::local({
[17:03:41.548]                 ...future.makeSendCondition <- base::local({
[17:03:41.548]                   sendCondition <- NULL
[17:03:41.548]                   function(frame = 1L) {
[17:03:41.548]                     if (is.function(sendCondition)) 
[17:03:41.548]                       return(sendCondition)
[17:03:41.548]                     ns <- getNamespace("parallel")
[17:03:41.548]                     if (exists("sendData", mode = "function", 
[17:03:41.548]                       envir = ns)) {
[17:03:41.548]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:41.548]                         envir = ns)
[17:03:41.548]                       envir <- sys.frame(frame)
[17:03:41.548]                       master <- NULL
[17:03:41.548]                       while (!identical(envir, .GlobalEnv) && 
[17:03:41.548]                         !identical(envir, emptyenv())) {
[17:03:41.548]                         if (exists("master", mode = "list", envir = envir, 
[17:03:41.548]                           inherits = FALSE)) {
[17:03:41.548]                           master <- get("master", mode = "list", 
[17:03:41.548]                             envir = envir, inherits = FALSE)
[17:03:41.548]                           if (inherits(master, c("SOCKnode", 
[17:03:41.548]                             "SOCK0node"))) {
[17:03:41.548]                             sendCondition <<- function(cond) {
[17:03:41.548]                               data <- list(type = "VALUE", value = cond, 
[17:03:41.548]                                 success = TRUE)
[17:03:41.548]                               parallel_sendData(master, data)
[17:03:41.548]                             }
[17:03:41.548]                             return(sendCondition)
[17:03:41.548]                           }
[17:03:41.548]                         }
[17:03:41.548]                         frame <- frame + 1L
[17:03:41.548]                         envir <- sys.frame(frame)
[17:03:41.548]                       }
[17:03:41.548]                     }
[17:03:41.548]                     sendCondition <<- function(cond) NULL
[17:03:41.548]                   }
[17:03:41.548]                 })
[17:03:41.548]                 withCallingHandlers({
[17:03:41.548]                   NA
[17:03:41.548]                 }, immediateCondition = function(cond) {
[17:03:41.548]                   sendCondition <- ...future.makeSendCondition()
[17:03:41.548]                   sendCondition(cond)
[17:03:41.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:41.548]                   {
[17:03:41.548]                     inherits <- base::inherits
[17:03:41.548]                     invokeRestart <- base::invokeRestart
[17:03:41.548]                     is.null <- base::is.null
[17:03:41.548]                     muffled <- FALSE
[17:03:41.548]                     if (inherits(cond, "message")) {
[17:03:41.548]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:41.548]                       if (muffled) 
[17:03:41.548]                         invokeRestart("muffleMessage")
[17:03:41.548]                     }
[17:03:41.548]                     else if (inherits(cond, "warning")) {
[17:03:41.548]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:41.548]                       if (muffled) 
[17:03:41.548]                         invokeRestart("muffleWarning")
[17:03:41.548]                     }
[17:03:41.548]                     else if (inherits(cond, "condition")) {
[17:03:41.548]                       if (!is.null(pattern)) {
[17:03:41.548]                         computeRestarts <- base::computeRestarts
[17:03:41.548]                         grepl <- base::grepl
[17:03:41.548]                         restarts <- computeRestarts(cond)
[17:03:41.548]                         for (restart in restarts) {
[17:03:41.548]                           name <- restart$name
[17:03:41.548]                           if (is.null(name)) 
[17:03:41.548]                             next
[17:03:41.548]                           if (!grepl(pattern, name)) 
[17:03:41.548]                             next
[17:03:41.548]                           invokeRestart(restart)
[17:03:41.548]                           muffled <- TRUE
[17:03:41.548]                           break
[17:03:41.548]                         }
[17:03:41.548]                       }
[17:03:41.548]                     }
[17:03:41.548]                     invisible(muffled)
[17:03:41.548]                   }
[17:03:41.548]                   muffleCondition(cond)
[17:03:41.548]                 })
[17:03:41.548]             }))
[17:03:41.548]             future::FutureResult(value = ...future.value$value, 
[17:03:41.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:41.548]                   ...future.rng), globalenv = if (FALSE) 
[17:03:41.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:41.548]                     ...future.globalenv.names))
[17:03:41.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:41.548]         }, condition = base::local({
[17:03:41.548]             c <- base::c
[17:03:41.548]             inherits <- base::inherits
[17:03:41.548]             invokeRestart <- base::invokeRestart
[17:03:41.548]             length <- base::length
[17:03:41.548]             list <- base::list
[17:03:41.548]             seq.int <- base::seq.int
[17:03:41.548]             signalCondition <- base::signalCondition
[17:03:41.548]             sys.calls <- base::sys.calls
[17:03:41.548]             `[[` <- base::`[[`
[17:03:41.548]             `+` <- base::`+`
[17:03:41.548]             `<<-` <- base::`<<-`
[17:03:41.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:41.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:41.548]                   3L)]
[17:03:41.548]             }
[17:03:41.548]             function(cond) {
[17:03:41.548]                 is_error <- inherits(cond, "error")
[17:03:41.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:41.548]                   NULL)
[17:03:41.548]                 if (is_error) {
[17:03:41.548]                   sessionInformation <- function() {
[17:03:41.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:41.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:41.548]                       search = base::search(), system = base::Sys.info())
[17:03:41.548]                   }
[17:03:41.548]                   ...future.conditions[[length(...future.conditions) + 
[17:03:41.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:41.548]                     cond$call), session = sessionInformation(), 
[17:03:41.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:41.548]                   signalCondition(cond)
[17:03:41.548]                 }
[17:03:41.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:41.548]                 "immediateCondition"))) {
[17:03:41.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:41.548]                   ...future.conditions[[length(...future.conditions) + 
[17:03:41.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:41.548]                   if (TRUE && !signal) {
[17:03:41.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:41.548]                     {
[17:03:41.548]                       inherits <- base::inherits
[17:03:41.548]                       invokeRestart <- base::invokeRestart
[17:03:41.548]                       is.null <- base::is.null
[17:03:41.548]                       muffled <- FALSE
[17:03:41.548]                       if (inherits(cond, "message")) {
[17:03:41.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:41.548]                         if (muffled) 
[17:03:41.548]                           invokeRestart("muffleMessage")
[17:03:41.548]                       }
[17:03:41.548]                       else if (inherits(cond, "warning")) {
[17:03:41.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:41.548]                         if (muffled) 
[17:03:41.548]                           invokeRestart("muffleWarning")
[17:03:41.548]                       }
[17:03:41.548]                       else if (inherits(cond, "condition")) {
[17:03:41.548]                         if (!is.null(pattern)) {
[17:03:41.548]                           computeRestarts <- base::computeRestarts
[17:03:41.548]                           grepl <- base::grepl
[17:03:41.548]                           restarts <- computeRestarts(cond)
[17:03:41.548]                           for (restart in restarts) {
[17:03:41.548]                             name <- restart$name
[17:03:41.548]                             if (is.null(name)) 
[17:03:41.548]                               next
[17:03:41.548]                             if (!grepl(pattern, name)) 
[17:03:41.548]                               next
[17:03:41.548]                             invokeRestart(restart)
[17:03:41.548]                             muffled <- TRUE
[17:03:41.548]                             break
[17:03:41.548]                           }
[17:03:41.548]                         }
[17:03:41.548]                       }
[17:03:41.548]                       invisible(muffled)
[17:03:41.548]                     }
[17:03:41.548]                     muffleCondition(cond, pattern = "^muffle")
[17:03:41.548]                   }
[17:03:41.548]                 }
[17:03:41.548]                 else {
[17:03:41.548]                   if (TRUE) {
[17:03:41.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:41.548]                     {
[17:03:41.548]                       inherits <- base::inherits
[17:03:41.548]                       invokeRestart <- base::invokeRestart
[17:03:41.548]                       is.null <- base::is.null
[17:03:41.548]                       muffled <- FALSE
[17:03:41.548]                       if (inherits(cond, "message")) {
[17:03:41.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:41.548]                         if (muffled) 
[17:03:41.548]                           invokeRestart("muffleMessage")
[17:03:41.548]                       }
[17:03:41.548]                       else if (inherits(cond, "warning")) {
[17:03:41.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:41.548]                         if (muffled) 
[17:03:41.548]                           invokeRestart("muffleWarning")
[17:03:41.548]                       }
[17:03:41.548]                       else if (inherits(cond, "condition")) {
[17:03:41.548]                         if (!is.null(pattern)) {
[17:03:41.548]                           computeRestarts <- base::computeRestarts
[17:03:41.548]                           grepl <- base::grepl
[17:03:41.548]                           restarts <- computeRestarts(cond)
[17:03:41.548]                           for (restart in restarts) {
[17:03:41.548]                             name <- restart$name
[17:03:41.548]                             if (is.null(name)) 
[17:03:41.548]                               next
[17:03:41.548]                             if (!grepl(pattern, name)) 
[17:03:41.548]                               next
[17:03:41.548]                             invokeRestart(restart)
[17:03:41.548]                             muffled <- TRUE
[17:03:41.548]                             break
[17:03:41.548]                           }
[17:03:41.548]                         }
[17:03:41.548]                       }
[17:03:41.548]                       invisible(muffled)
[17:03:41.548]                     }
[17:03:41.548]                     muffleCondition(cond, pattern = "^muffle")
[17:03:41.548]                   }
[17:03:41.548]                 }
[17:03:41.548]             }
[17:03:41.548]         }))
[17:03:41.548]     }, error = function(ex) {
[17:03:41.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:41.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:41.548]                 ...future.rng), started = ...future.startTime, 
[17:03:41.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:41.548]             version = "1.8"), class = "FutureResult")
[17:03:41.548]     }, finally = {
[17:03:41.548]         if (!identical(...future.workdir, getwd())) 
[17:03:41.548]             setwd(...future.workdir)
[17:03:41.548]         {
[17:03:41.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:41.548]                 ...future.oldOptions$nwarnings <- NULL
[17:03:41.548]             }
[17:03:41.548]             base::options(...future.oldOptions)
[17:03:41.548]             if (.Platform$OS.type == "windows") {
[17:03:41.548]                 old_names <- names(...future.oldEnvVars)
[17:03:41.548]                 envs <- base::Sys.getenv()
[17:03:41.548]                 names <- names(envs)
[17:03:41.548]                 common <- intersect(names, old_names)
[17:03:41.548]                 added <- setdiff(names, old_names)
[17:03:41.548]                 removed <- setdiff(old_names, names)
[17:03:41.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:41.548]                   envs[common]]
[17:03:41.548]                 NAMES <- toupper(changed)
[17:03:41.548]                 args <- list()
[17:03:41.548]                 for (kk in seq_along(NAMES)) {
[17:03:41.548]                   name <- changed[[kk]]
[17:03:41.548]                   NAME <- NAMES[[kk]]
[17:03:41.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:41.548]                     next
[17:03:41.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:41.548]                 }
[17:03:41.548]                 NAMES <- toupper(added)
[17:03:41.548]                 for (kk in seq_along(NAMES)) {
[17:03:41.548]                   name <- added[[kk]]
[17:03:41.548]                   NAME <- NAMES[[kk]]
[17:03:41.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:41.548]                     next
[17:03:41.548]                   args[[name]] <- ""
[17:03:41.548]                 }
[17:03:41.548]                 NAMES <- toupper(removed)
[17:03:41.548]                 for (kk in seq_along(NAMES)) {
[17:03:41.548]                   name <- removed[[kk]]
[17:03:41.548]                   NAME <- NAMES[[kk]]
[17:03:41.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:41.548]                     next
[17:03:41.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:41.548]                 }
[17:03:41.548]                 if (length(args) > 0) 
[17:03:41.548]                   base::do.call(base::Sys.setenv, args = args)
[17:03:41.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:41.548]             }
[17:03:41.548]             else {
[17:03:41.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:41.548]             }
[17:03:41.548]             {
[17:03:41.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:41.548]                   0L) {
[17:03:41.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:41.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:41.548]                   base::options(opts)
[17:03:41.548]                 }
[17:03:41.548]                 {
[17:03:41.548]                   {
[17:03:41.548]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:41.548]                     NULL
[17:03:41.548]                   }
[17:03:41.548]                   options(future.plan = NULL)
[17:03:41.548]                   if (is.na(NA_character_)) 
[17:03:41.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:41.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:41.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:41.548]                     .init = FALSE)
[17:03:41.548]                 }
[17:03:41.548]             }
[17:03:41.548]         }
[17:03:41.548]     })
[17:03:41.548]     if (TRUE) {
[17:03:41.548]         base::sink(type = "output", split = FALSE)
[17:03:41.548]         if (TRUE) {
[17:03:41.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:41.548]         }
[17:03:41.548]         else {
[17:03:41.548]             ...future.result["stdout"] <- base::list(NULL)
[17:03:41.548]         }
[17:03:41.548]         base::close(...future.stdout)
[17:03:41.548]         ...future.stdout <- NULL
[17:03:41.548]     }
[17:03:41.548]     ...future.result$conditions <- ...future.conditions
[17:03:41.548]     ...future.result$finished <- base::Sys.time()
[17:03:41.548]     ...future.result
[17:03:41.548] }
[17:03:41.601] MultisessionFuture started
[17:03:41.601] result() for ClusterFuture ...
[17:03:41.602] receiveMessageFromWorker() for ClusterFuture ...
[17:03:41.602] - Validating connection of MultisessionFuture
[17:03:41.634] - received message: FutureResult
[17:03:41.634] - Received FutureResult
[17:03:41.634] - Erased future from FutureRegistry
[17:03:41.634] result() for ClusterFuture ...
[17:03:41.634] - result already collected: FutureResult
[17:03:41.634] result() for ClusterFuture ... done
[17:03:41.634] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:41.635] result() for ClusterFuture ... done
[17:03:41.635] result() for ClusterFuture ...
[17:03:41.635] - result already collected: FutureResult
[17:03:41.635] result() for ClusterFuture ... done
[17:03:41.635] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:03:41.639] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[17:03:41.642] getGlobalsAndPackages() ...
[17:03:41.642] Searching for globals...
[17:03:41.644] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:41.644] Searching for globals ... DONE
[17:03:41.644] Resolving globals: FALSE
[17:03:41.644] 
[17:03:41.645] 
[17:03:41.645] getGlobalsAndPackages() ... DONE
[17:03:41.645] run() for ‘Future’ ...
[17:03:41.645] - state: ‘created’
[17:03:41.645] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:41.659] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:41.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:41.660]   - Field: ‘node’
[17:03:41.660]   - Field: ‘label’
[17:03:41.660]   - Field: ‘local’
[17:03:41.660]   - Field: ‘owner’
[17:03:41.660]   - Field: ‘envir’
[17:03:41.660]   - Field: ‘workers’
[17:03:41.660]   - Field: ‘packages’
[17:03:41.660]   - Field: ‘gc’
[17:03:41.661]   - Field: ‘conditions’
[17:03:41.661]   - Field: ‘persistent’
[17:03:41.661]   - Field: ‘expr’
[17:03:41.661]   - Field: ‘uuid’
[17:03:41.661]   - Field: ‘seed’
[17:03:41.661]   - Field: ‘version’
[17:03:41.661]   - Field: ‘result’
[17:03:41.661]   - Field: ‘asynchronous’
[17:03:41.661]   - Field: ‘calls’
[17:03:41.662]   - Field: ‘globals’
[17:03:41.662]   - Field: ‘stdout’
[17:03:41.662]   - Field: ‘earlySignal’
[17:03:41.662]   - Field: ‘lazy’
[17:03:41.662]   - Field: ‘state’
[17:03:41.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:41.662] - Launch lazy future ...
[17:03:41.663] Packages needed by the future expression (n = 0): <none>
[17:03:41.663] Packages needed by future strategies (n = 0): <none>
[17:03:41.663] {
[17:03:41.663]     {
[17:03:41.663]         {
[17:03:41.663]             ...future.startTime <- base::Sys.time()
[17:03:41.663]             {
[17:03:41.663]                 {
[17:03:41.663]                   {
[17:03:41.663]                     {
[17:03:41.663]                       base::local({
[17:03:41.663]                         has_future <- base::requireNamespace("future", 
[17:03:41.663]                           quietly = TRUE)
[17:03:41.663]                         if (has_future) {
[17:03:41.663]                           ns <- base::getNamespace("future")
[17:03:41.663]                           version <- ns[[".package"]][["version"]]
[17:03:41.663]                           if (is.null(version)) 
[17:03:41.663]                             version <- utils::packageVersion("future")
[17:03:41.663]                         }
[17:03:41.663]                         else {
[17:03:41.663]                           version <- NULL
[17:03:41.663]                         }
[17:03:41.663]                         if (!has_future || version < "1.8.0") {
[17:03:41.663]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:41.663]                             "", base::R.version$version.string), 
[17:03:41.663]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:41.663]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:41.663]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:41.663]                               "release", "version")], collapse = " "), 
[17:03:41.663]                             hostname = base::Sys.info()[["nodename"]])
[17:03:41.663]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:41.663]                             info)
[17:03:41.663]                           info <- base::paste(info, collapse = "; ")
[17:03:41.663]                           if (!has_future) {
[17:03:41.663]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:41.663]                               info)
[17:03:41.663]                           }
[17:03:41.663]                           else {
[17:03:41.663]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:41.663]                               info, version)
[17:03:41.663]                           }
[17:03:41.663]                           base::stop(msg)
[17:03:41.663]                         }
[17:03:41.663]                       })
[17:03:41.663]                     }
[17:03:41.663]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:41.663]                     base::options(mc.cores = 1L)
[17:03:41.663]                   }
[17:03:41.663]                   ...future.strategy.old <- future::plan("list")
[17:03:41.663]                   options(future.plan = NULL)
[17:03:41.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:41.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:41.663]                 }
[17:03:41.663]                 ...future.workdir <- getwd()
[17:03:41.663]             }
[17:03:41.663]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:41.663]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:41.663]         }
[17:03:41.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:41.663]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:41.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:41.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:41.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:41.663]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:41.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:41.663]             base::names(...future.oldOptions))
[17:03:41.663]     }
[17:03:41.663]     if (FALSE) {
[17:03:41.663]     }
[17:03:41.663]     else {
[17:03:41.663]         if (TRUE) {
[17:03:41.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:41.663]                 open = "w")
[17:03:41.663]         }
[17:03:41.663]         else {
[17:03:41.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:41.663]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:41.663]         }
[17:03:41.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:41.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:41.663]             base::sink(type = "output", split = FALSE)
[17:03:41.663]             base::close(...future.stdout)
[17:03:41.663]         }, add = TRUE)
[17:03:41.663]     }
[17:03:41.663]     ...future.frame <- base::sys.nframe()
[17:03:41.663]     ...future.conditions <- base::list()
[17:03:41.663]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:41.663]     if (FALSE) {
[17:03:41.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:41.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:41.663]     }
[17:03:41.663]     ...future.result <- base::tryCatch({
[17:03:41.663]         base::withCallingHandlers({
[17:03:41.663]             ...future.value <- base::withVisible(base::local({
[17:03:41.663]                 ...future.makeSendCondition <- base::local({
[17:03:41.663]                   sendCondition <- NULL
[17:03:41.663]                   function(frame = 1L) {
[17:03:41.663]                     if (is.function(sendCondition)) 
[17:03:41.663]                       return(sendCondition)
[17:03:41.663]                     ns <- getNamespace("parallel")
[17:03:41.663]                     if (exists("sendData", mode = "function", 
[17:03:41.663]                       envir = ns)) {
[17:03:41.663]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:41.663]                         envir = ns)
[17:03:41.663]                       envir <- sys.frame(frame)
[17:03:41.663]                       master <- NULL
[17:03:41.663]                       while (!identical(envir, .GlobalEnv) && 
[17:03:41.663]                         !identical(envir, emptyenv())) {
[17:03:41.663]                         if (exists("master", mode = "list", envir = envir, 
[17:03:41.663]                           inherits = FALSE)) {
[17:03:41.663]                           master <- get("master", mode = "list", 
[17:03:41.663]                             envir = envir, inherits = FALSE)
[17:03:41.663]                           if (inherits(master, c("SOCKnode", 
[17:03:41.663]                             "SOCK0node"))) {
[17:03:41.663]                             sendCondition <<- function(cond) {
[17:03:41.663]                               data <- list(type = "VALUE", value = cond, 
[17:03:41.663]                                 success = TRUE)
[17:03:41.663]                               parallel_sendData(master, data)
[17:03:41.663]                             }
[17:03:41.663]                             return(sendCondition)
[17:03:41.663]                           }
[17:03:41.663]                         }
[17:03:41.663]                         frame <- frame + 1L
[17:03:41.663]                         envir <- sys.frame(frame)
[17:03:41.663]                       }
[17:03:41.663]                     }
[17:03:41.663]                     sendCondition <<- function(cond) NULL
[17:03:41.663]                   }
[17:03:41.663]                 })
[17:03:41.663]                 withCallingHandlers({
[17:03:41.663]                   {
[17:03:41.663]                     Sys.sleep(0.5)
[17:03:41.663]                     list(a = 1, b = 42L)
[17:03:41.663]                   }
[17:03:41.663]                 }, immediateCondition = function(cond) {
[17:03:41.663]                   sendCondition <- ...future.makeSendCondition()
[17:03:41.663]                   sendCondition(cond)
[17:03:41.663]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:41.663]                   {
[17:03:41.663]                     inherits <- base::inherits
[17:03:41.663]                     invokeRestart <- base::invokeRestart
[17:03:41.663]                     is.null <- base::is.null
[17:03:41.663]                     muffled <- FALSE
[17:03:41.663]                     if (inherits(cond, "message")) {
[17:03:41.663]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:41.663]                       if (muffled) 
[17:03:41.663]                         invokeRestart("muffleMessage")
[17:03:41.663]                     }
[17:03:41.663]                     else if (inherits(cond, "warning")) {
[17:03:41.663]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:41.663]                       if (muffled) 
[17:03:41.663]                         invokeRestart("muffleWarning")
[17:03:41.663]                     }
[17:03:41.663]                     else if (inherits(cond, "condition")) {
[17:03:41.663]                       if (!is.null(pattern)) {
[17:03:41.663]                         computeRestarts <- base::computeRestarts
[17:03:41.663]                         grepl <- base::grepl
[17:03:41.663]                         restarts <- computeRestarts(cond)
[17:03:41.663]                         for (restart in restarts) {
[17:03:41.663]                           name <- restart$name
[17:03:41.663]                           if (is.null(name)) 
[17:03:41.663]                             next
[17:03:41.663]                           if (!grepl(pattern, name)) 
[17:03:41.663]                             next
[17:03:41.663]                           invokeRestart(restart)
[17:03:41.663]                           muffled <- TRUE
[17:03:41.663]                           break
[17:03:41.663]                         }
[17:03:41.663]                       }
[17:03:41.663]                     }
[17:03:41.663]                     invisible(muffled)
[17:03:41.663]                   }
[17:03:41.663]                   muffleCondition(cond)
[17:03:41.663]                 })
[17:03:41.663]             }))
[17:03:41.663]             future::FutureResult(value = ...future.value$value, 
[17:03:41.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:41.663]                   ...future.rng), globalenv = if (FALSE) 
[17:03:41.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:41.663]                     ...future.globalenv.names))
[17:03:41.663]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:41.663]         }, condition = base::local({
[17:03:41.663]             c <- base::c
[17:03:41.663]             inherits <- base::inherits
[17:03:41.663]             invokeRestart <- base::invokeRestart
[17:03:41.663]             length <- base::length
[17:03:41.663]             list <- base::list
[17:03:41.663]             seq.int <- base::seq.int
[17:03:41.663]             signalCondition <- base::signalCondition
[17:03:41.663]             sys.calls <- base::sys.calls
[17:03:41.663]             `[[` <- base::`[[`
[17:03:41.663]             `+` <- base::`+`
[17:03:41.663]             `<<-` <- base::`<<-`
[17:03:41.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:41.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:41.663]                   3L)]
[17:03:41.663]             }
[17:03:41.663]             function(cond) {
[17:03:41.663]                 is_error <- inherits(cond, "error")
[17:03:41.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:41.663]                   NULL)
[17:03:41.663]                 if (is_error) {
[17:03:41.663]                   sessionInformation <- function() {
[17:03:41.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:41.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:41.663]                       search = base::search(), system = base::Sys.info())
[17:03:41.663]                   }
[17:03:41.663]                   ...future.conditions[[length(...future.conditions) + 
[17:03:41.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:41.663]                     cond$call), session = sessionInformation(), 
[17:03:41.663]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:41.663]                   signalCondition(cond)
[17:03:41.663]                 }
[17:03:41.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:41.663]                 "immediateCondition"))) {
[17:03:41.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:41.663]                   ...future.conditions[[length(...future.conditions) + 
[17:03:41.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:41.663]                   if (TRUE && !signal) {
[17:03:41.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:41.663]                     {
[17:03:41.663]                       inherits <- base::inherits
[17:03:41.663]                       invokeRestart <- base::invokeRestart
[17:03:41.663]                       is.null <- base::is.null
[17:03:41.663]                       muffled <- FALSE
[17:03:41.663]                       if (inherits(cond, "message")) {
[17:03:41.663]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:41.663]                         if (muffled) 
[17:03:41.663]                           invokeRestart("muffleMessage")
[17:03:41.663]                       }
[17:03:41.663]                       else if (inherits(cond, "warning")) {
[17:03:41.663]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:41.663]                         if (muffled) 
[17:03:41.663]                           invokeRestart("muffleWarning")
[17:03:41.663]                       }
[17:03:41.663]                       else if (inherits(cond, "condition")) {
[17:03:41.663]                         if (!is.null(pattern)) {
[17:03:41.663]                           computeRestarts <- base::computeRestarts
[17:03:41.663]                           grepl <- base::grepl
[17:03:41.663]                           restarts <- computeRestarts(cond)
[17:03:41.663]                           for (restart in restarts) {
[17:03:41.663]                             name <- restart$name
[17:03:41.663]                             if (is.null(name)) 
[17:03:41.663]                               next
[17:03:41.663]                             if (!grepl(pattern, name)) 
[17:03:41.663]                               next
[17:03:41.663]                             invokeRestart(restart)
[17:03:41.663]                             muffled <- TRUE
[17:03:41.663]                             break
[17:03:41.663]                           }
[17:03:41.663]                         }
[17:03:41.663]                       }
[17:03:41.663]                       invisible(muffled)
[17:03:41.663]                     }
[17:03:41.663]                     muffleCondition(cond, pattern = "^muffle")
[17:03:41.663]                   }
[17:03:41.663]                 }
[17:03:41.663]                 else {
[17:03:41.663]                   if (TRUE) {
[17:03:41.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:41.663]                     {
[17:03:41.663]                       inherits <- base::inherits
[17:03:41.663]                       invokeRestart <- base::invokeRestart
[17:03:41.663]                       is.null <- base::is.null
[17:03:41.663]                       muffled <- FALSE
[17:03:41.663]                       if (inherits(cond, "message")) {
[17:03:41.663]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:41.663]                         if (muffled) 
[17:03:41.663]                           invokeRestart("muffleMessage")
[17:03:41.663]                       }
[17:03:41.663]                       else if (inherits(cond, "warning")) {
[17:03:41.663]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:41.663]                         if (muffled) 
[17:03:41.663]                           invokeRestart("muffleWarning")
[17:03:41.663]                       }
[17:03:41.663]                       else if (inherits(cond, "condition")) {
[17:03:41.663]                         if (!is.null(pattern)) {
[17:03:41.663]                           computeRestarts <- base::computeRestarts
[17:03:41.663]                           grepl <- base::grepl
[17:03:41.663]                           restarts <- computeRestarts(cond)
[17:03:41.663]                           for (restart in restarts) {
[17:03:41.663]                             name <- restart$name
[17:03:41.663]                             if (is.null(name)) 
[17:03:41.663]                               next
[17:03:41.663]                             if (!grepl(pattern, name)) 
[17:03:41.663]                               next
[17:03:41.663]                             invokeRestart(restart)
[17:03:41.663]                             muffled <- TRUE
[17:03:41.663]                             break
[17:03:41.663]                           }
[17:03:41.663]                         }
[17:03:41.663]                       }
[17:03:41.663]                       invisible(muffled)
[17:03:41.663]                     }
[17:03:41.663]                     muffleCondition(cond, pattern = "^muffle")
[17:03:41.663]                   }
[17:03:41.663]                 }
[17:03:41.663]             }
[17:03:41.663]         }))
[17:03:41.663]     }, error = function(ex) {
[17:03:41.663]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:41.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:41.663]                 ...future.rng), started = ...future.startTime, 
[17:03:41.663]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:41.663]             version = "1.8"), class = "FutureResult")
[17:03:41.663]     }, finally = {
[17:03:41.663]         if (!identical(...future.workdir, getwd())) 
[17:03:41.663]             setwd(...future.workdir)
[17:03:41.663]         {
[17:03:41.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:41.663]                 ...future.oldOptions$nwarnings <- NULL
[17:03:41.663]             }
[17:03:41.663]             base::options(...future.oldOptions)
[17:03:41.663]             if (.Platform$OS.type == "windows") {
[17:03:41.663]                 old_names <- names(...future.oldEnvVars)
[17:03:41.663]                 envs <- base::Sys.getenv()
[17:03:41.663]                 names <- names(envs)
[17:03:41.663]                 common <- intersect(names, old_names)
[17:03:41.663]                 added <- setdiff(names, old_names)
[17:03:41.663]                 removed <- setdiff(old_names, names)
[17:03:41.663]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:41.663]                   envs[common]]
[17:03:41.663]                 NAMES <- toupper(changed)
[17:03:41.663]                 args <- list()
[17:03:41.663]                 for (kk in seq_along(NAMES)) {
[17:03:41.663]                   name <- changed[[kk]]
[17:03:41.663]                   NAME <- NAMES[[kk]]
[17:03:41.663]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:41.663]                     next
[17:03:41.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:41.663]                 }
[17:03:41.663]                 NAMES <- toupper(added)
[17:03:41.663]                 for (kk in seq_along(NAMES)) {
[17:03:41.663]                   name <- added[[kk]]
[17:03:41.663]                   NAME <- NAMES[[kk]]
[17:03:41.663]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:41.663]                     next
[17:03:41.663]                   args[[name]] <- ""
[17:03:41.663]                 }
[17:03:41.663]                 NAMES <- toupper(removed)
[17:03:41.663]                 for (kk in seq_along(NAMES)) {
[17:03:41.663]                   name <- removed[[kk]]
[17:03:41.663]                   NAME <- NAMES[[kk]]
[17:03:41.663]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:41.663]                     next
[17:03:41.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:41.663]                 }
[17:03:41.663]                 if (length(args) > 0) 
[17:03:41.663]                   base::do.call(base::Sys.setenv, args = args)
[17:03:41.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:41.663]             }
[17:03:41.663]             else {
[17:03:41.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:41.663]             }
[17:03:41.663]             {
[17:03:41.663]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:41.663]                   0L) {
[17:03:41.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:41.663]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:41.663]                   base::options(opts)
[17:03:41.663]                 }
[17:03:41.663]                 {
[17:03:41.663]                   {
[17:03:41.663]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:41.663]                     NULL
[17:03:41.663]                   }
[17:03:41.663]                   options(future.plan = NULL)
[17:03:41.663]                   if (is.na(NA_character_)) 
[17:03:41.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:41.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:41.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:41.663]                     .init = FALSE)
[17:03:41.663]                 }
[17:03:41.663]             }
[17:03:41.663]         }
[17:03:41.663]     })
[17:03:41.663]     if (TRUE) {
[17:03:41.663]         base::sink(type = "output", split = FALSE)
[17:03:41.663]         if (TRUE) {
[17:03:41.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:41.663]         }
[17:03:41.663]         else {
[17:03:41.663]             ...future.result["stdout"] <- base::list(NULL)
[17:03:41.663]         }
[17:03:41.663]         base::close(...future.stdout)
[17:03:41.663]         ...future.stdout <- NULL
[17:03:41.663]     }
[17:03:41.663]     ...future.result$conditions <- ...future.conditions
[17:03:41.663]     ...future.result$finished <- base::Sys.time()
[17:03:41.663]     ...future.result
[17:03:41.663] }
[17:03:41.667] MultisessionFuture started
[17:03:41.667] - Launch lazy future ... done
[17:03:41.667] run() for ‘MultisessionFuture’ ... done
[17:03:42.170] receiveMessageFromWorker() for ClusterFuture ...
[17:03:42.170] - Validating connection of MultisessionFuture
[17:03:42.170] - received message: FutureResult
[17:03:42.170] - Received FutureResult
[17:03:42.171] - Erased future from FutureRegistry
[17:03:42.171] result() for ClusterFuture ...
[17:03:42.171] - result already collected: FutureResult
[17:03:42.171] result() for ClusterFuture ... done
[17:03:42.171] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:42.171] A MultisessionFuture was resolved (result was not collected)
[17:03:42.171] getGlobalsAndPackages() ...
[17:03:42.171] Searching for globals...
[17:03:42.173] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:42.173] Searching for globals ... DONE
[17:03:42.173] Resolving globals: FALSE
[17:03:42.174] 
[17:03:42.174] 
[17:03:42.174] getGlobalsAndPackages() ... DONE
[17:03:42.174] run() for ‘Future’ ...
[17:03:42.174] - state: ‘created’
[17:03:42.174] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:42.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:42.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:42.190]   - Field: ‘node’
[17:03:42.190]   - Field: ‘label’
[17:03:42.190]   - Field: ‘local’
[17:03:42.190]   - Field: ‘owner’
[17:03:42.190]   - Field: ‘envir’
[17:03:42.190]   - Field: ‘workers’
[17:03:42.190]   - Field: ‘packages’
[17:03:42.190]   - Field: ‘gc’
[17:03:42.191]   - Field: ‘conditions’
[17:03:42.191]   - Field: ‘persistent’
[17:03:42.191]   - Field: ‘expr’
[17:03:42.191]   - Field: ‘uuid’
[17:03:42.191]   - Field: ‘seed’
[17:03:42.191]   - Field: ‘version’
[17:03:42.191]   - Field: ‘result’
[17:03:42.191]   - Field: ‘asynchronous’
[17:03:42.191]   - Field: ‘calls’
[17:03:42.192]   - Field: ‘globals’
[17:03:42.192]   - Field: ‘stdout’
[17:03:42.192]   - Field: ‘earlySignal’
[17:03:42.192]   - Field: ‘lazy’
[17:03:42.192]   - Field: ‘state’
[17:03:42.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:42.192] - Launch lazy future ...
[17:03:42.193] Packages needed by the future expression (n = 0): <none>
[17:03:42.193] Packages needed by future strategies (n = 0): <none>
[17:03:42.193] {
[17:03:42.193]     {
[17:03:42.193]         {
[17:03:42.193]             ...future.startTime <- base::Sys.time()
[17:03:42.193]             {
[17:03:42.193]                 {
[17:03:42.193]                   {
[17:03:42.193]                     {
[17:03:42.193]                       base::local({
[17:03:42.193]                         has_future <- base::requireNamespace("future", 
[17:03:42.193]                           quietly = TRUE)
[17:03:42.193]                         if (has_future) {
[17:03:42.193]                           ns <- base::getNamespace("future")
[17:03:42.193]                           version <- ns[[".package"]][["version"]]
[17:03:42.193]                           if (is.null(version)) 
[17:03:42.193]                             version <- utils::packageVersion("future")
[17:03:42.193]                         }
[17:03:42.193]                         else {
[17:03:42.193]                           version <- NULL
[17:03:42.193]                         }
[17:03:42.193]                         if (!has_future || version < "1.8.0") {
[17:03:42.193]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:42.193]                             "", base::R.version$version.string), 
[17:03:42.193]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:42.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:42.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:42.193]                               "release", "version")], collapse = " "), 
[17:03:42.193]                             hostname = base::Sys.info()[["nodename"]])
[17:03:42.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:42.193]                             info)
[17:03:42.193]                           info <- base::paste(info, collapse = "; ")
[17:03:42.193]                           if (!has_future) {
[17:03:42.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:42.193]                               info)
[17:03:42.193]                           }
[17:03:42.193]                           else {
[17:03:42.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:42.193]                               info, version)
[17:03:42.193]                           }
[17:03:42.193]                           base::stop(msg)
[17:03:42.193]                         }
[17:03:42.193]                       })
[17:03:42.193]                     }
[17:03:42.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:42.193]                     base::options(mc.cores = 1L)
[17:03:42.193]                   }
[17:03:42.193]                   ...future.strategy.old <- future::plan("list")
[17:03:42.193]                   options(future.plan = NULL)
[17:03:42.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:42.193]                 }
[17:03:42.193]                 ...future.workdir <- getwd()
[17:03:42.193]             }
[17:03:42.193]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:42.193]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:42.193]         }
[17:03:42.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:42.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:42.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:42.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:42.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:42.193]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:42.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:42.193]             base::names(...future.oldOptions))
[17:03:42.193]     }
[17:03:42.193]     if (FALSE) {
[17:03:42.193]     }
[17:03:42.193]     else {
[17:03:42.193]         if (TRUE) {
[17:03:42.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:42.193]                 open = "w")
[17:03:42.193]         }
[17:03:42.193]         else {
[17:03:42.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:42.193]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:42.193]         }
[17:03:42.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:42.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:42.193]             base::sink(type = "output", split = FALSE)
[17:03:42.193]             base::close(...future.stdout)
[17:03:42.193]         }, add = TRUE)
[17:03:42.193]     }
[17:03:42.193]     ...future.frame <- base::sys.nframe()
[17:03:42.193]     ...future.conditions <- base::list()
[17:03:42.193]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:42.193]     if (FALSE) {
[17:03:42.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:42.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:42.193]     }
[17:03:42.193]     ...future.result <- base::tryCatch({
[17:03:42.193]         base::withCallingHandlers({
[17:03:42.193]             ...future.value <- base::withVisible(base::local({
[17:03:42.193]                 ...future.makeSendCondition <- base::local({
[17:03:42.193]                   sendCondition <- NULL
[17:03:42.193]                   function(frame = 1L) {
[17:03:42.193]                     if (is.function(sendCondition)) 
[17:03:42.193]                       return(sendCondition)
[17:03:42.193]                     ns <- getNamespace("parallel")
[17:03:42.193]                     if (exists("sendData", mode = "function", 
[17:03:42.193]                       envir = ns)) {
[17:03:42.193]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:42.193]                         envir = ns)
[17:03:42.193]                       envir <- sys.frame(frame)
[17:03:42.193]                       master <- NULL
[17:03:42.193]                       while (!identical(envir, .GlobalEnv) && 
[17:03:42.193]                         !identical(envir, emptyenv())) {
[17:03:42.193]                         if (exists("master", mode = "list", envir = envir, 
[17:03:42.193]                           inherits = FALSE)) {
[17:03:42.193]                           master <- get("master", mode = "list", 
[17:03:42.193]                             envir = envir, inherits = FALSE)
[17:03:42.193]                           if (inherits(master, c("SOCKnode", 
[17:03:42.193]                             "SOCK0node"))) {
[17:03:42.193]                             sendCondition <<- function(cond) {
[17:03:42.193]                               data <- list(type = "VALUE", value = cond, 
[17:03:42.193]                                 success = TRUE)
[17:03:42.193]                               parallel_sendData(master, data)
[17:03:42.193]                             }
[17:03:42.193]                             return(sendCondition)
[17:03:42.193]                           }
[17:03:42.193]                         }
[17:03:42.193]                         frame <- frame + 1L
[17:03:42.193]                         envir <- sys.frame(frame)
[17:03:42.193]                       }
[17:03:42.193]                     }
[17:03:42.193]                     sendCondition <<- function(cond) NULL
[17:03:42.193]                   }
[17:03:42.193]                 })
[17:03:42.193]                 withCallingHandlers({
[17:03:42.193]                   {
[17:03:42.193]                     Sys.sleep(0.5)
[17:03:42.193]                     list(a = 1, b = 42L)
[17:03:42.193]                   }
[17:03:42.193]                 }, immediateCondition = function(cond) {
[17:03:42.193]                   sendCondition <- ...future.makeSendCondition()
[17:03:42.193]                   sendCondition(cond)
[17:03:42.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.193]                   {
[17:03:42.193]                     inherits <- base::inherits
[17:03:42.193]                     invokeRestart <- base::invokeRestart
[17:03:42.193]                     is.null <- base::is.null
[17:03:42.193]                     muffled <- FALSE
[17:03:42.193]                     if (inherits(cond, "message")) {
[17:03:42.193]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:42.193]                       if (muffled) 
[17:03:42.193]                         invokeRestart("muffleMessage")
[17:03:42.193]                     }
[17:03:42.193]                     else if (inherits(cond, "warning")) {
[17:03:42.193]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:42.193]                       if (muffled) 
[17:03:42.193]                         invokeRestart("muffleWarning")
[17:03:42.193]                     }
[17:03:42.193]                     else if (inherits(cond, "condition")) {
[17:03:42.193]                       if (!is.null(pattern)) {
[17:03:42.193]                         computeRestarts <- base::computeRestarts
[17:03:42.193]                         grepl <- base::grepl
[17:03:42.193]                         restarts <- computeRestarts(cond)
[17:03:42.193]                         for (restart in restarts) {
[17:03:42.193]                           name <- restart$name
[17:03:42.193]                           if (is.null(name)) 
[17:03:42.193]                             next
[17:03:42.193]                           if (!grepl(pattern, name)) 
[17:03:42.193]                             next
[17:03:42.193]                           invokeRestart(restart)
[17:03:42.193]                           muffled <- TRUE
[17:03:42.193]                           break
[17:03:42.193]                         }
[17:03:42.193]                       }
[17:03:42.193]                     }
[17:03:42.193]                     invisible(muffled)
[17:03:42.193]                   }
[17:03:42.193]                   muffleCondition(cond)
[17:03:42.193]                 })
[17:03:42.193]             }))
[17:03:42.193]             future::FutureResult(value = ...future.value$value, 
[17:03:42.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.193]                   ...future.rng), globalenv = if (FALSE) 
[17:03:42.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:42.193]                     ...future.globalenv.names))
[17:03:42.193]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:42.193]         }, condition = base::local({
[17:03:42.193]             c <- base::c
[17:03:42.193]             inherits <- base::inherits
[17:03:42.193]             invokeRestart <- base::invokeRestart
[17:03:42.193]             length <- base::length
[17:03:42.193]             list <- base::list
[17:03:42.193]             seq.int <- base::seq.int
[17:03:42.193]             signalCondition <- base::signalCondition
[17:03:42.193]             sys.calls <- base::sys.calls
[17:03:42.193]             `[[` <- base::`[[`
[17:03:42.193]             `+` <- base::`+`
[17:03:42.193]             `<<-` <- base::`<<-`
[17:03:42.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:42.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:42.193]                   3L)]
[17:03:42.193]             }
[17:03:42.193]             function(cond) {
[17:03:42.193]                 is_error <- inherits(cond, "error")
[17:03:42.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:42.193]                   NULL)
[17:03:42.193]                 if (is_error) {
[17:03:42.193]                   sessionInformation <- function() {
[17:03:42.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:42.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:42.193]                       search = base::search(), system = base::Sys.info())
[17:03:42.193]                   }
[17:03:42.193]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:42.193]                     cond$call), session = sessionInformation(), 
[17:03:42.193]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:42.193]                   signalCondition(cond)
[17:03:42.193]                 }
[17:03:42.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:42.193]                 "immediateCondition"))) {
[17:03:42.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:42.193]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:42.193]                   if (TRUE && !signal) {
[17:03:42.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.193]                     {
[17:03:42.193]                       inherits <- base::inherits
[17:03:42.193]                       invokeRestart <- base::invokeRestart
[17:03:42.193]                       is.null <- base::is.null
[17:03:42.193]                       muffled <- FALSE
[17:03:42.193]                       if (inherits(cond, "message")) {
[17:03:42.193]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.193]                         if (muffled) 
[17:03:42.193]                           invokeRestart("muffleMessage")
[17:03:42.193]                       }
[17:03:42.193]                       else if (inherits(cond, "warning")) {
[17:03:42.193]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.193]                         if (muffled) 
[17:03:42.193]                           invokeRestart("muffleWarning")
[17:03:42.193]                       }
[17:03:42.193]                       else if (inherits(cond, "condition")) {
[17:03:42.193]                         if (!is.null(pattern)) {
[17:03:42.193]                           computeRestarts <- base::computeRestarts
[17:03:42.193]                           grepl <- base::grepl
[17:03:42.193]                           restarts <- computeRestarts(cond)
[17:03:42.193]                           for (restart in restarts) {
[17:03:42.193]                             name <- restart$name
[17:03:42.193]                             if (is.null(name)) 
[17:03:42.193]                               next
[17:03:42.193]                             if (!grepl(pattern, name)) 
[17:03:42.193]                               next
[17:03:42.193]                             invokeRestart(restart)
[17:03:42.193]                             muffled <- TRUE
[17:03:42.193]                             break
[17:03:42.193]                           }
[17:03:42.193]                         }
[17:03:42.193]                       }
[17:03:42.193]                       invisible(muffled)
[17:03:42.193]                     }
[17:03:42.193]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.193]                   }
[17:03:42.193]                 }
[17:03:42.193]                 else {
[17:03:42.193]                   if (TRUE) {
[17:03:42.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.193]                     {
[17:03:42.193]                       inherits <- base::inherits
[17:03:42.193]                       invokeRestart <- base::invokeRestart
[17:03:42.193]                       is.null <- base::is.null
[17:03:42.193]                       muffled <- FALSE
[17:03:42.193]                       if (inherits(cond, "message")) {
[17:03:42.193]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.193]                         if (muffled) 
[17:03:42.193]                           invokeRestart("muffleMessage")
[17:03:42.193]                       }
[17:03:42.193]                       else if (inherits(cond, "warning")) {
[17:03:42.193]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.193]                         if (muffled) 
[17:03:42.193]                           invokeRestart("muffleWarning")
[17:03:42.193]                       }
[17:03:42.193]                       else if (inherits(cond, "condition")) {
[17:03:42.193]                         if (!is.null(pattern)) {
[17:03:42.193]                           computeRestarts <- base::computeRestarts
[17:03:42.193]                           grepl <- base::grepl
[17:03:42.193]                           restarts <- computeRestarts(cond)
[17:03:42.193]                           for (restart in restarts) {
[17:03:42.193]                             name <- restart$name
[17:03:42.193]                             if (is.null(name)) 
[17:03:42.193]                               next
[17:03:42.193]                             if (!grepl(pattern, name)) 
[17:03:42.193]                               next
[17:03:42.193]                             invokeRestart(restart)
[17:03:42.193]                             muffled <- TRUE
[17:03:42.193]                             break
[17:03:42.193]                           }
[17:03:42.193]                         }
[17:03:42.193]                       }
[17:03:42.193]                       invisible(muffled)
[17:03:42.193]                     }
[17:03:42.193]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.193]                   }
[17:03:42.193]                 }
[17:03:42.193]             }
[17:03:42.193]         }))
[17:03:42.193]     }, error = function(ex) {
[17:03:42.193]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:42.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.193]                 ...future.rng), started = ...future.startTime, 
[17:03:42.193]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:42.193]             version = "1.8"), class = "FutureResult")
[17:03:42.193]     }, finally = {
[17:03:42.193]         if (!identical(...future.workdir, getwd())) 
[17:03:42.193]             setwd(...future.workdir)
[17:03:42.193]         {
[17:03:42.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:42.193]                 ...future.oldOptions$nwarnings <- NULL
[17:03:42.193]             }
[17:03:42.193]             base::options(...future.oldOptions)
[17:03:42.193]             if (.Platform$OS.type == "windows") {
[17:03:42.193]                 old_names <- names(...future.oldEnvVars)
[17:03:42.193]                 envs <- base::Sys.getenv()
[17:03:42.193]                 names <- names(envs)
[17:03:42.193]                 common <- intersect(names, old_names)
[17:03:42.193]                 added <- setdiff(names, old_names)
[17:03:42.193]                 removed <- setdiff(old_names, names)
[17:03:42.193]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:42.193]                   envs[common]]
[17:03:42.193]                 NAMES <- toupper(changed)
[17:03:42.193]                 args <- list()
[17:03:42.193]                 for (kk in seq_along(NAMES)) {
[17:03:42.193]                   name <- changed[[kk]]
[17:03:42.193]                   NAME <- NAMES[[kk]]
[17:03:42.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.193]                     next
[17:03:42.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.193]                 }
[17:03:42.193]                 NAMES <- toupper(added)
[17:03:42.193]                 for (kk in seq_along(NAMES)) {
[17:03:42.193]                   name <- added[[kk]]
[17:03:42.193]                   NAME <- NAMES[[kk]]
[17:03:42.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.193]                     next
[17:03:42.193]                   args[[name]] <- ""
[17:03:42.193]                 }
[17:03:42.193]                 NAMES <- toupper(removed)
[17:03:42.193]                 for (kk in seq_along(NAMES)) {
[17:03:42.193]                   name <- removed[[kk]]
[17:03:42.193]                   NAME <- NAMES[[kk]]
[17:03:42.193]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.193]                     next
[17:03:42.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.193]                 }
[17:03:42.193]                 if (length(args) > 0) 
[17:03:42.193]                   base::do.call(base::Sys.setenv, args = args)
[17:03:42.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:42.193]             }
[17:03:42.193]             else {
[17:03:42.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:42.193]             }
[17:03:42.193]             {
[17:03:42.193]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:42.193]                   0L) {
[17:03:42.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:42.193]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:42.193]                   base::options(opts)
[17:03:42.193]                 }
[17:03:42.193]                 {
[17:03:42.193]                   {
[17:03:42.193]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:42.193]                     NULL
[17:03:42.193]                   }
[17:03:42.193]                   options(future.plan = NULL)
[17:03:42.193]                   if (is.na(NA_character_)) 
[17:03:42.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:42.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:42.193]                     .init = FALSE)
[17:03:42.193]                 }
[17:03:42.193]             }
[17:03:42.193]         }
[17:03:42.193]     })
[17:03:42.193]     if (TRUE) {
[17:03:42.193]         base::sink(type = "output", split = FALSE)
[17:03:42.193]         if (TRUE) {
[17:03:42.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:42.193]         }
[17:03:42.193]         else {
[17:03:42.193]             ...future.result["stdout"] <- base::list(NULL)
[17:03:42.193]         }
[17:03:42.193]         base::close(...future.stdout)
[17:03:42.193]         ...future.stdout <- NULL
[17:03:42.193]     }
[17:03:42.193]     ...future.result$conditions <- ...future.conditions
[17:03:42.193]     ...future.result$finished <- base::Sys.time()
[17:03:42.193]     ...future.result
[17:03:42.193] }
[17:03:42.197] MultisessionFuture started
[17:03:42.197] - Launch lazy future ... done
[17:03:42.197] run() for ‘MultisessionFuture’ ... done
[17:03:42.703] receiveMessageFromWorker() for ClusterFuture ...
[17:03:42.703] - Validating connection of MultisessionFuture
[17:03:42.703] - received message: FutureResult
[17:03:42.703] - Received FutureResult
[17:03:42.704] - Erased future from FutureRegistry
[17:03:42.704] result() for ClusterFuture ...
[17:03:42.704] - result already collected: FutureResult
[17:03:42.704] result() for ClusterFuture ... done
[17:03:42.704] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:42.704] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:03:42.704] getGlobalsAndPackages() ...
[17:03:42.705] Searching for globals...
[17:03:42.705] - globals found: [2] ‘list’, ‘stop’
[17:03:42.706] Searching for globals ... DONE
[17:03:42.706] Resolving globals: FALSE
[17:03:42.706] 
[17:03:42.706] 
[17:03:42.706] getGlobalsAndPackages() ... DONE
[17:03:42.707] run() for ‘Future’ ...
[17:03:42.707] - state: ‘created’
[17:03:42.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:42.724] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:42.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:42.724]   - Field: ‘node’
[17:03:42.724]   - Field: ‘label’
[17:03:42.725]   - Field: ‘local’
[17:03:42.725]   - Field: ‘owner’
[17:03:42.725]   - Field: ‘envir’
[17:03:42.725]   - Field: ‘workers’
[17:03:42.725]   - Field: ‘packages’
[17:03:42.725]   - Field: ‘gc’
[17:03:42.725]   - Field: ‘conditions’
[17:03:42.725]   - Field: ‘persistent’
[17:03:42.725]   - Field: ‘expr’
[17:03:42.725]   - Field: ‘uuid’
[17:03:42.725]   - Field: ‘seed’
[17:03:42.725]   - Field: ‘version’
[17:03:42.726]   - Field: ‘result’
[17:03:42.726]   - Field: ‘asynchronous’
[17:03:42.726]   - Field: ‘calls’
[17:03:42.726]   - Field: ‘globals’
[17:03:42.726]   - Field: ‘stdout’
[17:03:42.726]   - Field: ‘earlySignal’
[17:03:42.726]   - Field: ‘lazy’
[17:03:42.726]   - Field: ‘state’
[17:03:42.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:42.726] - Launch lazy future ...
[17:03:42.727] Packages needed by the future expression (n = 0): <none>
[17:03:42.727] Packages needed by future strategies (n = 0): <none>
[17:03:42.727] {
[17:03:42.727]     {
[17:03:42.727]         {
[17:03:42.727]             ...future.startTime <- base::Sys.time()
[17:03:42.727]             {
[17:03:42.727]                 {
[17:03:42.727]                   {
[17:03:42.727]                     {
[17:03:42.727]                       base::local({
[17:03:42.727]                         has_future <- base::requireNamespace("future", 
[17:03:42.727]                           quietly = TRUE)
[17:03:42.727]                         if (has_future) {
[17:03:42.727]                           ns <- base::getNamespace("future")
[17:03:42.727]                           version <- ns[[".package"]][["version"]]
[17:03:42.727]                           if (is.null(version)) 
[17:03:42.727]                             version <- utils::packageVersion("future")
[17:03:42.727]                         }
[17:03:42.727]                         else {
[17:03:42.727]                           version <- NULL
[17:03:42.727]                         }
[17:03:42.727]                         if (!has_future || version < "1.8.0") {
[17:03:42.727]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:42.727]                             "", base::R.version$version.string), 
[17:03:42.727]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:42.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:42.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:42.727]                               "release", "version")], collapse = " "), 
[17:03:42.727]                             hostname = base::Sys.info()[["nodename"]])
[17:03:42.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:42.727]                             info)
[17:03:42.727]                           info <- base::paste(info, collapse = "; ")
[17:03:42.727]                           if (!has_future) {
[17:03:42.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:42.727]                               info)
[17:03:42.727]                           }
[17:03:42.727]                           else {
[17:03:42.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:42.727]                               info, version)
[17:03:42.727]                           }
[17:03:42.727]                           base::stop(msg)
[17:03:42.727]                         }
[17:03:42.727]                       })
[17:03:42.727]                     }
[17:03:42.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:42.727]                     base::options(mc.cores = 1L)
[17:03:42.727]                   }
[17:03:42.727]                   ...future.strategy.old <- future::plan("list")
[17:03:42.727]                   options(future.plan = NULL)
[17:03:42.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:42.727]                 }
[17:03:42.727]                 ...future.workdir <- getwd()
[17:03:42.727]             }
[17:03:42.727]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:42.727]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:42.727]         }
[17:03:42.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:42.727]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:42.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:42.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:42.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:42.727]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:42.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:42.727]             base::names(...future.oldOptions))
[17:03:42.727]     }
[17:03:42.727]     if (FALSE) {
[17:03:42.727]     }
[17:03:42.727]     else {
[17:03:42.727]         if (TRUE) {
[17:03:42.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:42.727]                 open = "w")
[17:03:42.727]         }
[17:03:42.727]         else {
[17:03:42.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:42.727]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:42.727]         }
[17:03:42.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:42.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:42.727]             base::sink(type = "output", split = FALSE)
[17:03:42.727]             base::close(...future.stdout)
[17:03:42.727]         }, add = TRUE)
[17:03:42.727]     }
[17:03:42.727]     ...future.frame <- base::sys.nframe()
[17:03:42.727]     ...future.conditions <- base::list()
[17:03:42.727]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:42.727]     if (FALSE) {
[17:03:42.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:42.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:42.727]     }
[17:03:42.727]     ...future.result <- base::tryCatch({
[17:03:42.727]         base::withCallingHandlers({
[17:03:42.727]             ...future.value <- base::withVisible(base::local({
[17:03:42.727]                 ...future.makeSendCondition <- base::local({
[17:03:42.727]                   sendCondition <- NULL
[17:03:42.727]                   function(frame = 1L) {
[17:03:42.727]                     if (is.function(sendCondition)) 
[17:03:42.727]                       return(sendCondition)
[17:03:42.727]                     ns <- getNamespace("parallel")
[17:03:42.727]                     if (exists("sendData", mode = "function", 
[17:03:42.727]                       envir = ns)) {
[17:03:42.727]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:42.727]                         envir = ns)
[17:03:42.727]                       envir <- sys.frame(frame)
[17:03:42.727]                       master <- NULL
[17:03:42.727]                       while (!identical(envir, .GlobalEnv) && 
[17:03:42.727]                         !identical(envir, emptyenv())) {
[17:03:42.727]                         if (exists("master", mode = "list", envir = envir, 
[17:03:42.727]                           inherits = FALSE)) {
[17:03:42.727]                           master <- get("master", mode = "list", 
[17:03:42.727]                             envir = envir, inherits = FALSE)
[17:03:42.727]                           if (inherits(master, c("SOCKnode", 
[17:03:42.727]                             "SOCK0node"))) {
[17:03:42.727]                             sendCondition <<- function(cond) {
[17:03:42.727]                               data <- list(type = "VALUE", value = cond, 
[17:03:42.727]                                 success = TRUE)
[17:03:42.727]                               parallel_sendData(master, data)
[17:03:42.727]                             }
[17:03:42.727]                             return(sendCondition)
[17:03:42.727]                           }
[17:03:42.727]                         }
[17:03:42.727]                         frame <- frame + 1L
[17:03:42.727]                         envir <- sys.frame(frame)
[17:03:42.727]                       }
[17:03:42.727]                     }
[17:03:42.727]                     sendCondition <<- function(cond) NULL
[17:03:42.727]                   }
[17:03:42.727]                 })
[17:03:42.727]                 withCallingHandlers({
[17:03:42.727]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:42.727]                 }, immediateCondition = function(cond) {
[17:03:42.727]                   sendCondition <- ...future.makeSendCondition()
[17:03:42.727]                   sendCondition(cond)
[17:03:42.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.727]                   {
[17:03:42.727]                     inherits <- base::inherits
[17:03:42.727]                     invokeRestart <- base::invokeRestart
[17:03:42.727]                     is.null <- base::is.null
[17:03:42.727]                     muffled <- FALSE
[17:03:42.727]                     if (inherits(cond, "message")) {
[17:03:42.727]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:42.727]                       if (muffled) 
[17:03:42.727]                         invokeRestart("muffleMessage")
[17:03:42.727]                     }
[17:03:42.727]                     else if (inherits(cond, "warning")) {
[17:03:42.727]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:42.727]                       if (muffled) 
[17:03:42.727]                         invokeRestart("muffleWarning")
[17:03:42.727]                     }
[17:03:42.727]                     else if (inherits(cond, "condition")) {
[17:03:42.727]                       if (!is.null(pattern)) {
[17:03:42.727]                         computeRestarts <- base::computeRestarts
[17:03:42.727]                         grepl <- base::grepl
[17:03:42.727]                         restarts <- computeRestarts(cond)
[17:03:42.727]                         for (restart in restarts) {
[17:03:42.727]                           name <- restart$name
[17:03:42.727]                           if (is.null(name)) 
[17:03:42.727]                             next
[17:03:42.727]                           if (!grepl(pattern, name)) 
[17:03:42.727]                             next
[17:03:42.727]                           invokeRestart(restart)
[17:03:42.727]                           muffled <- TRUE
[17:03:42.727]                           break
[17:03:42.727]                         }
[17:03:42.727]                       }
[17:03:42.727]                     }
[17:03:42.727]                     invisible(muffled)
[17:03:42.727]                   }
[17:03:42.727]                   muffleCondition(cond)
[17:03:42.727]                 })
[17:03:42.727]             }))
[17:03:42.727]             future::FutureResult(value = ...future.value$value, 
[17:03:42.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.727]                   ...future.rng), globalenv = if (FALSE) 
[17:03:42.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:42.727]                     ...future.globalenv.names))
[17:03:42.727]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:42.727]         }, condition = base::local({
[17:03:42.727]             c <- base::c
[17:03:42.727]             inherits <- base::inherits
[17:03:42.727]             invokeRestart <- base::invokeRestart
[17:03:42.727]             length <- base::length
[17:03:42.727]             list <- base::list
[17:03:42.727]             seq.int <- base::seq.int
[17:03:42.727]             signalCondition <- base::signalCondition
[17:03:42.727]             sys.calls <- base::sys.calls
[17:03:42.727]             `[[` <- base::`[[`
[17:03:42.727]             `+` <- base::`+`
[17:03:42.727]             `<<-` <- base::`<<-`
[17:03:42.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:42.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:42.727]                   3L)]
[17:03:42.727]             }
[17:03:42.727]             function(cond) {
[17:03:42.727]                 is_error <- inherits(cond, "error")
[17:03:42.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:42.727]                   NULL)
[17:03:42.727]                 if (is_error) {
[17:03:42.727]                   sessionInformation <- function() {
[17:03:42.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:42.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:42.727]                       search = base::search(), system = base::Sys.info())
[17:03:42.727]                   }
[17:03:42.727]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:42.727]                     cond$call), session = sessionInformation(), 
[17:03:42.727]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:42.727]                   signalCondition(cond)
[17:03:42.727]                 }
[17:03:42.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:42.727]                 "immediateCondition"))) {
[17:03:42.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:42.727]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:42.727]                   if (TRUE && !signal) {
[17:03:42.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.727]                     {
[17:03:42.727]                       inherits <- base::inherits
[17:03:42.727]                       invokeRestart <- base::invokeRestart
[17:03:42.727]                       is.null <- base::is.null
[17:03:42.727]                       muffled <- FALSE
[17:03:42.727]                       if (inherits(cond, "message")) {
[17:03:42.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.727]                         if (muffled) 
[17:03:42.727]                           invokeRestart("muffleMessage")
[17:03:42.727]                       }
[17:03:42.727]                       else if (inherits(cond, "warning")) {
[17:03:42.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.727]                         if (muffled) 
[17:03:42.727]                           invokeRestart("muffleWarning")
[17:03:42.727]                       }
[17:03:42.727]                       else if (inherits(cond, "condition")) {
[17:03:42.727]                         if (!is.null(pattern)) {
[17:03:42.727]                           computeRestarts <- base::computeRestarts
[17:03:42.727]                           grepl <- base::grepl
[17:03:42.727]                           restarts <- computeRestarts(cond)
[17:03:42.727]                           for (restart in restarts) {
[17:03:42.727]                             name <- restart$name
[17:03:42.727]                             if (is.null(name)) 
[17:03:42.727]                               next
[17:03:42.727]                             if (!grepl(pattern, name)) 
[17:03:42.727]                               next
[17:03:42.727]                             invokeRestart(restart)
[17:03:42.727]                             muffled <- TRUE
[17:03:42.727]                             break
[17:03:42.727]                           }
[17:03:42.727]                         }
[17:03:42.727]                       }
[17:03:42.727]                       invisible(muffled)
[17:03:42.727]                     }
[17:03:42.727]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.727]                   }
[17:03:42.727]                 }
[17:03:42.727]                 else {
[17:03:42.727]                   if (TRUE) {
[17:03:42.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.727]                     {
[17:03:42.727]                       inherits <- base::inherits
[17:03:42.727]                       invokeRestart <- base::invokeRestart
[17:03:42.727]                       is.null <- base::is.null
[17:03:42.727]                       muffled <- FALSE
[17:03:42.727]                       if (inherits(cond, "message")) {
[17:03:42.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.727]                         if (muffled) 
[17:03:42.727]                           invokeRestart("muffleMessage")
[17:03:42.727]                       }
[17:03:42.727]                       else if (inherits(cond, "warning")) {
[17:03:42.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.727]                         if (muffled) 
[17:03:42.727]                           invokeRestart("muffleWarning")
[17:03:42.727]                       }
[17:03:42.727]                       else if (inherits(cond, "condition")) {
[17:03:42.727]                         if (!is.null(pattern)) {
[17:03:42.727]                           computeRestarts <- base::computeRestarts
[17:03:42.727]                           grepl <- base::grepl
[17:03:42.727]                           restarts <- computeRestarts(cond)
[17:03:42.727]                           for (restart in restarts) {
[17:03:42.727]                             name <- restart$name
[17:03:42.727]                             if (is.null(name)) 
[17:03:42.727]                               next
[17:03:42.727]                             if (!grepl(pattern, name)) 
[17:03:42.727]                               next
[17:03:42.727]                             invokeRestart(restart)
[17:03:42.727]                             muffled <- TRUE
[17:03:42.727]                             break
[17:03:42.727]                           }
[17:03:42.727]                         }
[17:03:42.727]                       }
[17:03:42.727]                       invisible(muffled)
[17:03:42.727]                     }
[17:03:42.727]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.727]                   }
[17:03:42.727]                 }
[17:03:42.727]             }
[17:03:42.727]         }))
[17:03:42.727]     }, error = function(ex) {
[17:03:42.727]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:42.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.727]                 ...future.rng), started = ...future.startTime, 
[17:03:42.727]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:42.727]             version = "1.8"), class = "FutureResult")
[17:03:42.727]     }, finally = {
[17:03:42.727]         if (!identical(...future.workdir, getwd())) 
[17:03:42.727]             setwd(...future.workdir)
[17:03:42.727]         {
[17:03:42.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:42.727]                 ...future.oldOptions$nwarnings <- NULL
[17:03:42.727]             }
[17:03:42.727]             base::options(...future.oldOptions)
[17:03:42.727]             if (.Platform$OS.type == "windows") {
[17:03:42.727]                 old_names <- names(...future.oldEnvVars)
[17:03:42.727]                 envs <- base::Sys.getenv()
[17:03:42.727]                 names <- names(envs)
[17:03:42.727]                 common <- intersect(names, old_names)
[17:03:42.727]                 added <- setdiff(names, old_names)
[17:03:42.727]                 removed <- setdiff(old_names, names)
[17:03:42.727]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:42.727]                   envs[common]]
[17:03:42.727]                 NAMES <- toupper(changed)
[17:03:42.727]                 args <- list()
[17:03:42.727]                 for (kk in seq_along(NAMES)) {
[17:03:42.727]                   name <- changed[[kk]]
[17:03:42.727]                   NAME <- NAMES[[kk]]
[17:03:42.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.727]                     next
[17:03:42.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.727]                 }
[17:03:42.727]                 NAMES <- toupper(added)
[17:03:42.727]                 for (kk in seq_along(NAMES)) {
[17:03:42.727]                   name <- added[[kk]]
[17:03:42.727]                   NAME <- NAMES[[kk]]
[17:03:42.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.727]                     next
[17:03:42.727]                   args[[name]] <- ""
[17:03:42.727]                 }
[17:03:42.727]                 NAMES <- toupper(removed)
[17:03:42.727]                 for (kk in seq_along(NAMES)) {
[17:03:42.727]                   name <- removed[[kk]]
[17:03:42.727]                   NAME <- NAMES[[kk]]
[17:03:42.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.727]                     next
[17:03:42.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.727]                 }
[17:03:42.727]                 if (length(args) > 0) 
[17:03:42.727]                   base::do.call(base::Sys.setenv, args = args)
[17:03:42.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:42.727]             }
[17:03:42.727]             else {
[17:03:42.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:42.727]             }
[17:03:42.727]             {
[17:03:42.727]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:42.727]                   0L) {
[17:03:42.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:42.727]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:42.727]                   base::options(opts)
[17:03:42.727]                 }
[17:03:42.727]                 {
[17:03:42.727]                   {
[17:03:42.727]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:42.727]                     NULL
[17:03:42.727]                   }
[17:03:42.727]                   options(future.plan = NULL)
[17:03:42.727]                   if (is.na(NA_character_)) 
[17:03:42.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:42.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:42.727]                     .init = FALSE)
[17:03:42.727]                 }
[17:03:42.727]             }
[17:03:42.727]         }
[17:03:42.727]     })
[17:03:42.727]     if (TRUE) {
[17:03:42.727]         base::sink(type = "output", split = FALSE)
[17:03:42.727]         if (TRUE) {
[17:03:42.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:42.727]         }
[17:03:42.727]         else {
[17:03:42.727]             ...future.result["stdout"] <- base::list(NULL)
[17:03:42.727]         }
[17:03:42.727]         base::close(...future.stdout)
[17:03:42.727]         ...future.stdout <- NULL
[17:03:42.727]     }
[17:03:42.727]     ...future.result$conditions <- ...future.conditions
[17:03:42.727]     ...future.result$finished <- base::Sys.time()
[17:03:42.727]     ...future.result
[17:03:42.727] }
[17:03:42.730] MultisessionFuture started
[17:03:42.730] - Launch lazy future ... done
[17:03:42.730] run() for ‘MultisessionFuture’ ... done
[17:03:42.732] receiveMessageFromWorker() for ClusterFuture ...
[17:03:42.733] - Validating connection of MultisessionFuture
[17:03:42.733] - received message: FutureResult
[17:03:42.733] - Received FutureResult
[17:03:42.733] - Erased future from FutureRegistry
[17:03:42.733] result() for ClusterFuture ...
[17:03:42.734] - result already collected: FutureResult
[17:03:42.734] result() for ClusterFuture ... done
[17:03:42.734] signalConditions() ...
[17:03:42.734]  - include = ‘immediateCondition’
[17:03:42.734]  - exclude = 
[17:03:42.734]  - resignal = FALSE
[17:03:42.734]  - Number of conditions: 1
[17:03:42.734] signalConditions() ... done
[17:03:42.734] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:42.734] A MultisessionFuture was resolved (result was not collected)
[17:03:42.734] getGlobalsAndPackages() ...
[17:03:42.734] Searching for globals...
[17:03:42.735] - globals found: [2] ‘list’, ‘stop’
[17:03:42.735] Searching for globals ... DONE
[17:03:42.735] Resolving globals: FALSE
[17:03:42.736] 
[17:03:42.736] 
[17:03:42.736] getGlobalsAndPackages() ... DONE
[17:03:42.736] run() for ‘Future’ ...
[17:03:42.736] - state: ‘created’
[17:03:42.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:42.750] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:42.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:42.750]   - Field: ‘node’
[17:03:42.750]   - Field: ‘label’
[17:03:42.750]   - Field: ‘local’
[17:03:42.750]   - Field: ‘owner’
[17:03:42.750]   - Field: ‘envir’
[17:03:42.750]   - Field: ‘workers’
[17:03:42.751]   - Field: ‘packages’
[17:03:42.751]   - Field: ‘gc’
[17:03:42.751]   - Field: ‘conditions’
[17:03:42.751]   - Field: ‘persistent’
[17:03:42.751]   - Field: ‘expr’
[17:03:42.751]   - Field: ‘uuid’
[17:03:42.751]   - Field: ‘seed’
[17:03:42.751]   - Field: ‘version’
[17:03:42.751]   - Field: ‘result’
[17:03:42.751]   - Field: ‘asynchronous’
[17:03:42.751]   - Field: ‘calls’
[17:03:42.752]   - Field: ‘globals’
[17:03:42.752]   - Field: ‘stdout’
[17:03:42.752]   - Field: ‘earlySignal’
[17:03:42.752]   - Field: ‘lazy’
[17:03:42.752]   - Field: ‘state’
[17:03:42.752] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:42.752] - Launch lazy future ...
[17:03:42.752] Packages needed by the future expression (n = 0): <none>
[17:03:42.752] Packages needed by future strategies (n = 0): <none>
[17:03:42.753] {
[17:03:42.753]     {
[17:03:42.753]         {
[17:03:42.753]             ...future.startTime <- base::Sys.time()
[17:03:42.753]             {
[17:03:42.753]                 {
[17:03:42.753]                   {
[17:03:42.753]                     {
[17:03:42.753]                       base::local({
[17:03:42.753]                         has_future <- base::requireNamespace("future", 
[17:03:42.753]                           quietly = TRUE)
[17:03:42.753]                         if (has_future) {
[17:03:42.753]                           ns <- base::getNamespace("future")
[17:03:42.753]                           version <- ns[[".package"]][["version"]]
[17:03:42.753]                           if (is.null(version)) 
[17:03:42.753]                             version <- utils::packageVersion("future")
[17:03:42.753]                         }
[17:03:42.753]                         else {
[17:03:42.753]                           version <- NULL
[17:03:42.753]                         }
[17:03:42.753]                         if (!has_future || version < "1.8.0") {
[17:03:42.753]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:42.753]                             "", base::R.version$version.string), 
[17:03:42.753]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:42.753]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:42.753]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:42.753]                               "release", "version")], collapse = " "), 
[17:03:42.753]                             hostname = base::Sys.info()[["nodename"]])
[17:03:42.753]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:42.753]                             info)
[17:03:42.753]                           info <- base::paste(info, collapse = "; ")
[17:03:42.753]                           if (!has_future) {
[17:03:42.753]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:42.753]                               info)
[17:03:42.753]                           }
[17:03:42.753]                           else {
[17:03:42.753]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:42.753]                               info, version)
[17:03:42.753]                           }
[17:03:42.753]                           base::stop(msg)
[17:03:42.753]                         }
[17:03:42.753]                       })
[17:03:42.753]                     }
[17:03:42.753]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:42.753]                     base::options(mc.cores = 1L)
[17:03:42.753]                   }
[17:03:42.753]                   ...future.strategy.old <- future::plan("list")
[17:03:42.753]                   options(future.plan = NULL)
[17:03:42.753]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.753]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:42.753]                 }
[17:03:42.753]                 ...future.workdir <- getwd()
[17:03:42.753]             }
[17:03:42.753]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:42.753]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:42.753]         }
[17:03:42.753]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:42.753]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:42.753]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:42.753]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:42.753]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:42.753]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:42.753]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:42.753]             base::names(...future.oldOptions))
[17:03:42.753]     }
[17:03:42.753]     if (FALSE) {
[17:03:42.753]     }
[17:03:42.753]     else {
[17:03:42.753]         if (TRUE) {
[17:03:42.753]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:42.753]                 open = "w")
[17:03:42.753]         }
[17:03:42.753]         else {
[17:03:42.753]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:42.753]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:42.753]         }
[17:03:42.753]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:42.753]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:42.753]             base::sink(type = "output", split = FALSE)
[17:03:42.753]             base::close(...future.stdout)
[17:03:42.753]         }, add = TRUE)
[17:03:42.753]     }
[17:03:42.753]     ...future.frame <- base::sys.nframe()
[17:03:42.753]     ...future.conditions <- base::list()
[17:03:42.753]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:42.753]     if (FALSE) {
[17:03:42.753]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:42.753]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:42.753]     }
[17:03:42.753]     ...future.result <- base::tryCatch({
[17:03:42.753]         base::withCallingHandlers({
[17:03:42.753]             ...future.value <- base::withVisible(base::local({
[17:03:42.753]                 ...future.makeSendCondition <- base::local({
[17:03:42.753]                   sendCondition <- NULL
[17:03:42.753]                   function(frame = 1L) {
[17:03:42.753]                     if (is.function(sendCondition)) 
[17:03:42.753]                       return(sendCondition)
[17:03:42.753]                     ns <- getNamespace("parallel")
[17:03:42.753]                     if (exists("sendData", mode = "function", 
[17:03:42.753]                       envir = ns)) {
[17:03:42.753]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:42.753]                         envir = ns)
[17:03:42.753]                       envir <- sys.frame(frame)
[17:03:42.753]                       master <- NULL
[17:03:42.753]                       while (!identical(envir, .GlobalEnv) && 
[17:03:42.753]                         !identical(envir, emptyenv())) {
[17:03:42.753]                         if (exists("master", mode = "list", envir = envir, 
[17:03:42.753]                           inherits = FALSE)) {
[17:03:42.753]                           master <- get("master", mode = "list", 
[17:03:42.753]                             envir = envir, inherits = FALSE)
[17:03:42.753]                           if (inherits(master, c("SOCKnode", 
[17:03:42.753]                             "SOCK0node"))) {
[17:03:42.753]                             sendCondition <<- function(cond) {
[17:03:42.753]                               data <- list(type = "VALUE", value = cond, 
[17:03:42.753]                                 success = TRUE)
[17:03:42.753]                               parallel_sendData(master, data)
[17:03:42.753]                             }
[17:03:42.753]                             return(sendCondition)
[17:03:42.753]                           }
[17:03:42.753]                         }
[17:03:42.753]                         frame <- frame + 1L
[17:03:42.753]                         envir <- sys.frame(frame)
[17:03:42.753]                       }
[17:03:42.753]                     }
[17:03:42.753]                     sendCondition <<- function(cond) NULL
[17:03:42.753]                   }
[17:03:42.753]                 })
[17:03:42.753]                 withCallingHandlers({
[17:03:42.753]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:42.753]                 }, immediateCondition = function(cond) {
[17:03:42.753]                   sendCondition <- ...future.makeSendCondition()
[17:03:42.753]                   sendCondition(cond)
[17:03:42.753]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.753]                   {
[17:03:42.753]                     inherits <- base::inherits
[17:03:42.753]                     invokeRestart <- base::invokeRestart
[17:03:42.753]                     is.null <- base::is.null
[17:03:42.753]                     muffled <- FALSE
[17:03:42.753]                     if (inherits(cond, "message")) {
[17:03:42.753]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:42.753]                       if (muffled) 
[17:03:42.753]                         invokeRestart("muffleMessage")
[17:03:42.753]                     }
[17:03:42.753]                     else if (inherits(cond, "warning")) {
[17:03:42.753]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:42.753]                       if (muffled) 
[17:03:42.753]                         invokeRestart("muffleWarning")
[17:03:42.753]                     }
[17:03:42.753]                     else if (inherits(cond, "condition")) {
[17:03:42.753]                       if (!is.null(pattern)) {
[17:03:42.753]                         computeRestarts <- base::computeRestarts
[17:03:42.753]                         grepl <- base::grepl
[17:03:42.753]                         restarts <- computeRestarts(cond)
[17:03:42.753]                         for (restart in restarts) {
[17:03:42.753]                           name <- restart$name
[17:03:42.753]                           if (is.null(name)) 
[17:03:42.753]                             next
[17:03:42.753]                           if (!grepl(pattern, name)) 
[17:03:42.753]                             next
[17:03:42.753]                           invokeRestart(restart)
[17:03:42.753]                           muffled <- TRUE
[17:03:42.753]                           break
[17:03:42.753]                         }
[17:03:42.753]                       }
[17:03:42.753]                     }
[17:03:42.753]                     invisible(muffled)
[17:03:42.753]                   }
[17:03:42.753]                   muffleCondition(cond)
[17:03:42.753]                 })
[17:03:42.753]             }))
[17:03:42.753]             future::FutureResult(value = ...future.value$value, 
[17:03:42.753]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.753]                   ...future.rng), globalenv = if (FALSE) 
[17:03:42.753]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:42.753]                     ...future.globalenv.names))
[17:03:42.753]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:42.753]         }, condition = base::local({
[17:03:42.753]             c <- base::c
[17:03:42.753]             inherits <- base::inherits
[17:03:42.753]             invokeRestart <- base::invokeRestart
[17:03:42.753]             length <- base::length
[17:03:42.753]             list <- base::list
[17:03:42.753]             seq.int <- base::seq.int
[17:03:42.753]             signalCondition <- base::signalCondition
[17:03:42.753]             sys.calls <- base::sys.calls
[17:03:42.753]             `[[` <- base::`[[`
[17:03:42.753]             `+` <- base::`+`
[17:03:42.753]             `<<-` <- base::`<<-`
[17:03:42.753]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:42.753]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:42.753]                   3L)]
[17:03:42.753]             }
[17:03:42.753]             function(cond) {
[17:03:42.753]                 is_error <- inherits(cond, "error")
[17:03:42.753]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:42.753]                   NULL)
[17:03:42.753]                 if (is_error) {
[17:03:42.753]                   sessionInformation <- function() {
[17:03:42.753]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:42.753]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:42.753]                       search = base::search(), system = base::Sys.info())
[17:03:42.753]                   }
[17:03:42.753]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.753]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:42.753]                     cond$call), session = sessionInformation(), 
[17:03:42.753]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:42.753]                   signalCondition(cond)
[17:03:42.753]                 }
[17:03:42.753]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:42.753]                 "immediateCondition"))) {
[17:03:42.753]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:42.753]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.753]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:42.753]                   if (TRUE && !signal) {
[17:03:42.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.753]                     {
[17:03:42.753]                       inherits <- base::inherits
[17:03:42.753]                       invokeRestart <- base::invokeRestart
[17:03:42.753]                       is.null <- base::is.null
[17:03:42.753]                       muffled <- FALSE
[17:03:42.753]                       if (inherits(cond, "message")) {
[17:03:42.753]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.753]                         if (muffled) 
[17:03:42.753]                           invokeRestart("muffleMessage")
[17:03:42.753]                       }
[17:03:42.753]                       else if (inherits(cond, "warning")) {
[17:03:42.753]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.753]                         if (muffled) 
[17:03:42.753]                           invokeRestart("muffleWarning")
[17:03:42.753]                       }
[17:03:42.753]                       else if (inherits(cond, "condition")) {
[17:03:42.753]                         if (!is.null(pattern)) {
[17:03:42.753]                           computeRestarts <- base::computeRestarts
[17:03:42.753]                           grepl <- base::grepl
[17:03:42.753]                           restarts <- computeRestarts(cond)
[17:03:42.753]                           for (restart in restarts) {
[17:03:42.753]                             name <- restart$name
[17:03:42.753]                             if (is.null(name)) 
[17:03:42.753]                               next
[17:03:42.753]                             if (!grepl(pattern, name)) 
[17:03:42.753]                               next
[17:03:42.753]                             invokeRestart(restart)
[17:03:42.753]                             muffled <- TRUE
[17:03:42.753]                             break
[17:03:42.753]                           }
[17:03:42.753]                         }
[17:03:42.753]                       }
[17:03:42.753]                       invisible(muffled)
[17:03:42.753]                     }
[17:03:42.753]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.753]                   }
[17:03:42.753]                 }
[17:03:42.753]                 else {
[17:03:42.753]                   if (TRUE) {
[17:03:42.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.753]                     {
[17:03:42.753]                       inherits <- base::inherits
[17:03:42.753]                       invokeRestart <- base::invokeRestart
[17:03:42.753]                       is.null <- base::is.null
[17:03:42.753]                       muffled <- FALSE
[17:03:42.753]                       if (inherits(cond, "message")) {
[17:03:42.753]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.753]                         if (muffled) 
[17:03:42.753]                           invokeRestart("muffleMessage")
[17:03:42.753]                       }
[17:03:42.753]                       else if (inherits(cond, "warning")) {
[17:03:42.753]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.753]                         if (muffled) 
[17:03:42.753]                           invokeRestart("muffleWarning")
[17:03:42.753]                       }
[17:03:42.753]                       else if (inherits(cond, "condition")) {
[17:03:42.753]                         if (!is.null(pattern)) {
[17:03:42.753]                           computeRestarts <- base::computeRestarts
[17:03:42.753]                           grepl <- base::grepl
[17:03:42.753]                           restarts <- computeRestarts(cond)
[17:03:42.753]                           for (restart in restarts) {
[17:03:42.753]                             name <- restart$name
[17:03:42.753]                             if (is.null(name)) 
[17:03:42.753]                               next
[17:03:42.753]                             if (!grepl(pattern, name)) 
[17:03:42.753]                               next
[17:03:42.753]                             invokeRestart(restart)
[17:03:42.753]                             muffled <- TRUE
[17:03:42.753]                             break
[17:03:42.753]                           }
[17:03:42.753]                         }
[17:03:42.753]                       }
[17:03:42.753]                       invisible(muffled)
[17:03:42.753]                     }
[17:03:42.753]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.753]                   }
[17:03:42.753]                 }
[17:03:42.753]             }
[17:03:42.753]         }))
[17:03:42.753]     }, error = function(ex) {
[17:03:42.753]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:42.753]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.753]                 ...future.rng), started = ...future.startTime, 
[17:03:42.753]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:42.753]             version = "1.8"), class = "FutureResult")
[17:03:42.753]     }, finally = {
[17:03:42.753]         if (!identical(...future.workdir, getwd())) 
[17:03:42.753]             setwd(...future.workdir)
[17:03:42.753]         {
[17:03:42.753]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:42.753]                 ...future.oldOptions$nwarnings <- NULL
[17:03:42.753]             }
[17:03:42.753]             base::options(...future.oldOptions)
[17:03:42.753]             if (.Platform$OS.type == "windows") {
[17:03:42.753]                 old_names <- names(...future.oldEnvVars)
[17:03:42.753]                 envs <- base::Sys.getenv()
[17:03:42.753]                 names <- names(envs)
[17:03:42.753]                 common <- intersect(names, old_names)
[17:03:42.753]                 added <- setdiff(names, old_names)
[17:03:42.753]                 removed <- setdiff(old_names, names)
[17:03:42.753]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:42.753]                   envs[common]]
[17:03:42.753]                 NAMES <- toupper(changed)
[17:03:42.753]                 args <- list()
[17:03:42.753]                 for (kk in seq_along(NAMES)) {
[17:03:42.753]                   name <- changed[[kk]]
[17:03:42.753]                   NAME <- NAMES[[kk]]
[17:03:42.753]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.753]                     next
[17:03:42.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.753]                 }
[17:03:42.753]                 NAMES <- toupper(added)
[17:03:42.753]                 for (kk in seq_along(NAMES)) {
[17:03:42.753]                   name <- added[[kk]]
[17:03:42.753]                   NAME <- NAMES[[kk]]
[17:03:42.753]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.753]                     next
[17:03:42.753]                   args[[name]] <- ""
[17:03:42.753]                 }
[17:03:42.753]                 NAMES <- toupper(removed)
[17:03:42.753]                 for (kk in seq_along(NAMES)) {
[17:03:42.753]                   name <- removed[[kk]]
[17:03:42.753]                   NAME <- NAMES[[kk]]
[17:03:42.753]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.753]                     next
[17:03:42.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.753]                 }
[17:03:42.753]                 if (length(args) > 0) 
[17:03:42.753]                   base::do.call(base::Sys.setenv, args = args)
[17:03:42.753]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:42.753]             }
[17:03:42.753]             else {
[17:03:42.753]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:42.753]             }
[17:03:42.753]             {
[17:03:42.753]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:42.753]                   0L) {
[17:03:42.753]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:42.753]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:42.753]                   base::options(opts)
[17:03:42.753]                 }
[17:03:42.753]                 {
[17:03:42.753]                   {
[17:03:42.753]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:42.753]                     NULL
[17:03:42.753]                   }
[17:03:42.753]                   options(future.plan = NULL)
[17:03:42.753]                   if (is.na(NA_character_)) 
[17:03:42.753]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.753]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:42.753]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:42.753]                     .init = FALSE)
[17:03:42.753]                 }
[17:03:42.753]             }
[17:03:42.753]         }
[17:03:42.753]     })
[17:03:42.753]     if (TRUE) {
[17:03:42.753]         base::sink(type = "output", split = FALSE)
[17:03:42.753]         if (TRUE) {
[17:03:42.753]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:42.753]         }
[17:03:42.753]         else {
[17:03:42.753]             ...future.result["stdout"] <- base::list(NULL)
[17:03:42.753]         }
[17:03:42.753]         base::close(...future.stdout)
[17:03:42.753]         ...future.stdout <- NULL
[17:03:42.753]     }
[17:03:42.753]     ...future.result$conditions <- ...future.conditions
[17:03:42.753]     ...future.result$finished <- base::Sys.time()
[17:03:42.753]     ...future.result
[17:03:42.753] }
[17:03:42.756] MultisessionFuture started
[17:03:42.756] - Launch lazy future ... done
[17:03:42.756] run() for ‘MultisessionFuture’ ... done
[17:03:42.758] receiveMessageFromWorker() for ClusterFuture ...
[17:03:42.758] - Validating connection of MultisessionFuture
[17:03:42.758] - received message: FutureResult
[17:03:42.759] - Received FutureResult
[17:03:42.759] - Erased future from FutureRegistry
[17:03:42.759] result() for ClusterFuture ...
[17:03:42.759] - result already collected: FutureResult
[17:03:42.759] result() for ClusterFuture ... done
[17:03:42.759] signalConditions() ...
[17:03:42.759]  - include = ‘immediateCondition’
[17:03:42.759]  - exclude = 
[17:03:42.759]  - resignal = FALSE
[17:03:42.759]  - Number of conditions: 1
[17:03:42.760] signalConditions() ... done
[17:03:42.760] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:42.760] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[17:03:42.760] getGlobalsAndPackages() ...
[17:03:42.760] Searching for globals...
[17:03:42.761] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:42.761] Searching for globals ... DONE
[17:03:42.761] Resolving globals: FALSE
[17:03:42.762] 
[17:03:42.762] 
[17:03:42.762] getGlobalsAndPackages() ... DONE
[17:03:42.762] run() for ‘Future’ ...
[17:03:42.762] - state: ‘created’
[17:03:42.762] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:42.777] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:42.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:42.777]   - Field: ‘node’
[17:03:42.778]   - Field: ‘label’
[17:03:42.778]   - Field: ‘local’
[17:03:42.778]   - Field: ‘owner’
[17:03:42.778]   - Field: ‘envir’
[17:03:42.778]   - Field: ‘workers’
[17:03:42.778]   - Field: ‘packages’
[17:03:42.778]   - Field: ‘gc’
[17:03:42.778]   - Field: ‘conditions’
[17:03:42.778]   - Field: ‘persistent’
[17:03:42.778]   - Field: ‘expr’
[17:03:42.778]   - Field: ‘uuid’
[17:03:42.779]   - Field: ‘seed’
[17:03:42.779]   - Field: ‘version’
[17:03:42.779]   - Field: ‘result’
[17:03:42.779]   - Field: ‘asynchronous’
[17:03:42.779]   - Field: ‘calls’
[17:03:42.779]   - Field: ‘globals’
[17:03:42.779]   - Field: ‘stdout’
[17:03:42.779]   - Field: ‘earlySignal’
[17:03:42.779]   - Field: ‘lazy’
[17:03:42.779]   - Field: ‘state’
[17:03:42.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:42.780] - Launch lazy future ...
[17:03:42.780] Packages needed by the future expression (n = 0): <none>
[17:03:42.780] Packages needed by future strategies (n = 0): <none>
[17:03:42.780] {
[17:03:42.780]     {
[17:03:42.780]         {
[17:03:42.780]             ...future.startTime <- base::Sys.time()
[17:03:42.780]             {
[17:03:42.780]                 {
[17:03:42.780]                   {
[17:03:42.780]                     {
[17:03:42.780]                       base::local({
[17:03:42.780]                         has_future <- base::requireNamespace("future", 
[17:03:42.780]                           quietly = TRUE)
[17:03:42.780]                         if (has_future) {
[17:03:42.780]                           ns <- base::getNamespace("future")
[17:03:42.780]                           version <- ns[[".package"]][["version"]]
[17:03:42.780]                           if (is.null(version)) 
[17:03:42.780]                             version <- utils::packageVersion("future")
[17:03:42.780]                         }
[17:03:42.780]                         else {
[17:03:42.780]                           version <- NULL
[17:03:42.780]                         }
[17:03:42.780]                         if (!has_future || version < "1.8.0") {
[17:03:42.780]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:42.780]                             "", base::R.version$version.string), 
[17:03:42.780]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:42.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:42.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:42.780]                               "release", "version")], collapse = " "), 
[17:03:42.780]                             hostname = base::Sys.info()[["nodename"]])
[17:03:42.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:42.780]                             info)
[17:03:42.780]                           info <- base::paste(info, collapse = "; ")
[17:03:42.780]                           if (!has_future) {
[17:03:42.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:42.780]                               info)
[17:03:42.780]                           }
[17:03:42.780]                           else {
[17:03:42.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:42.780]                               info, version)
[17:03:42.780]                           }
[17:03:42.780]                           base::stop(msg)
[17:03:42.780]                         }
[17:03:42.780]                       })
[17:03:42.780]                     }
[17:03:42.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:42.780]                     base::options(mc.cores = 1L)
[17:03:42.780]                   }
[17:03:42.780]                   ...future.strategy.old <- future::plan("list")
[17:03:42.780]                   options(future.plan = NULL)
[17:03:42.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:42.780]                 }
[17:03:42.780]                 ...future.workdir <- getwd()
[17:03:42.780]             }
[17:03:42.780]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:42.780]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:42.780]         }
[17:03:42.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:42.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:42.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:42.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:42.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:42.780]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:42.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:42.780]             base::names(...future.oldOptions))
[17:03:42.780]     }
[17:03:42.780]     if (FALSE) {
[17:03:42.780]     }
[17:03:42.780]     else {
[17:03:42.780]         if (TRUE) {
[17:03:42.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:42.780]                 open = "w")
[17:03:42.780]         }
[17:03:42.780]         else {
[17:03:42.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:42.780]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:42.780]         }
[17:03:42.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:42.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:42.780]             base::sink(type = "output", split = FALSE)
[17:03:42.780]             base::close(...future.stdout)
[17:03:42.780]         }, add = TRUE)
[17:03:42.780]     }
[17:03:42.780]     ...future.frame <- base::sys.nframe()
[17:03:42.780]     ...future.conditions <- base::list()
[17:03:42.780]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:42.780]     if (FALSE) {
[17:03:42.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:42.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:42.780]     }
[17:03:42.780]     ...future.result <- base::tryCatch({
[17:03:42.780]         base::withCallingHandlers({
[17:03:42.780]             ...future.value <- base::withVisible(base::local({
[17:03:42.780]                 ...future.makeSendCondition <- base::local({
[17:03:42.780]                   sendCondition <- NULL
[17:03:42.780]                   function(frame = 1L) {
[17:03:42.780]                     if (is.function(sendCondition)) 
[17:03:42.780]                       return(sendCondition)
[17:03:42.780]                     ns <- getNamespace("parallel")
[17:03:42.780]                     if (exists("sendData", mode = "function", 
[17:03:42.780]                       envir = ns)) {
[17:03:42.780]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:42.780]                         envir = ns)
[17:03:42.780]                       envir <- sys.frame(frame)
[17:03:42.780]                       master <- NULL
[17:03:42.780]                       while (!identical(envir, .GlobalEnv) && 
[17:03:42.780]                         !identical(envir, emptyenv())) {
[17:03:42.780]                         if (exists("master", mode = "list", envir = envir, 
[17:03:42.780]                           inherits = FALSE)) {
[17:03:42.780]                           master <- get("master", mode = "list", 
[17:03:42.780]                             envir = envir, inherits = FALSE)
[17:03:42.780]                           if (inherits(master, c("SOCKnode", 
[17:03:42.780]                             "SOCK0node"))) {
[17:03:42.780]                             sendCondition <<- function(cond) {
[17:03:42.780]                               data <- list(type = "VALUE", value = cond, 
[17:03:42.780]                                 success = TRUE)
[17:03:42.780]                               parallel_sendData(master, data)
[17:03:42.780]                             }
[17:03:42.780]                             return(sendCondition)
[17:03:42.780]                           }
[17:03:42.780]                         }
[17:03:42.780]                         frame <- frame + 1L
[17:03:42.780]                         envir <- sys.frame(frame)
[17:03:42.780]                       }
[17:03:42.780]                     }
[17:03:42.780]                     sendCondition <<- function(cond) NULL
[17:03:42.780]                   }
[17:03:42.780]                 })
[17:03:42.780]                 withCallingHandlers({
[17:03:42.780]                   {
[17:03:42.780]                     Sys.sleep(0.5)
[17:03:42.780]                     list(a = 1, b = 42L)
[17:03:42.780]                   }
[17:03:42.780]                 }, immediateCondition = function(cond) {
[17:03:42.780]                   sendCondition <- ...future.makeSendCondition()
[17:03:42.780]                   sendCondition(cond)
[17:03:42.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.780]                   {
[17:03:42.780]                     inherits <- base::inherits
[17:03:42.780]                     invokeRestart <- base::invokeRestart
[17:03:42.780]                     is.null <- base::is.null
[17:03:42.780]                     muffled <- FALSE
[17:03:42.780]                     if (inherits(cond, "message")) {
[17:03:42.780]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:42.780]                       if (muffled) 
[17:03:42.780]                         invokeRestart("muffleMessage")
[17:03:42.780]                     }
[17:03:42.780]                     else if (inherits(cond, "warning")) {
[17:03:42.780]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:42.780]                       if (muffled) 
[17:03:42.780]                         invokeRestart("muffleWarning")
[17:03:42.780]                     }
[17:03:42.780]                     else if (inherits(cond, "condition")) {
[17:03:42.780]                       if (!is.null(pattern)) {
[17:03:42.780]                         computeRestarts <- base::computeRestarts
[17:03:42.780]                         grepl <- base::grepl
[17:03:42.780]                         restarts <- computeRestarts(cond)
[17:03:42.780]                         for (restart in restarts) {
[17:03:42.780]                           name <- restart$name
[17:03:42.780]                           if (is.null(name)) 
[17:03:42.780]                             next
[17:03:42.780]                           if (!grepl(pattern, name)) 
[17:03:42.780]                             next
[17:03:42.780]                           invokeRestart(restart)
[17:03:42.780]                           muffled <- TRUE
[17:03:42.780]                           break
[17:03:42.780]                         }
[17:03:42.780]                       }
[17:03:42.780]                     }
[17:03:42.780]                     invisible(muffled)
[17:03:42.780]                   }
[17:03:42.780]                   muffleCondition(cond)
[17:03:42.780]                 })
[17:03:42.780]             }))
[17:03:42.780]             future::FutureResult(value = ...future.value$value, 
[17:03:42.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.780]                   ...future.rng), globalenv = if (FALSE) 
[17:03:42.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:42.780]                     ...future.globalenv.names))
[17:03:42.780]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:42.780]         }, condition = base::local({
[17:03:42.780]             c <- base::c
[17:03:42.780]             inherits <- base::inherits
[17:03:42.780]             invokeRestart <- base::invokeRestart
[17:03:42.780]             length <- base::length
[17:03:42.780]             list <- base::list
[17:03:42.780]             seq.int <- base::seq.int
[17:03:42.780]             signalCondition <- base::signalCondition
[17:03:42.780]             sys.calls <- base::sys.calls
[17:03:42.780]             `[[` <- base::`[[`
[17:03:42.780]             `+` <- base::`+`
[17:03:42.780]             `<<-` <- base::`<<-`
[17:03:42.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:42.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:42.780]                   3L)]
[17:03:42.780]             }
[17:03:42.780]             function(cond) {
[17:03:42.780]                 is_error <- inherits(cond, "error")
[17:03:42.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:42.780]                   NULL)
[17:03:42.780]                 if (is_error) {
[17:03:42.780]                   sessionInformation <- function() {
[17:03:42.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:42.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:42.780]                       search = base::search(), system = base::Sys.info())
[17:03:42.780]                   }
[17:03:42.780]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:42.780]                     cond$call), session = sessionInformation(), 
[17:03:42.780]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:42.780]                   signalCondition(cond)
[17:03:42.780]                 }
[17:03:42.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:42.780]                 "immediateCondition"))) {
[17:03:42.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:42.780]                   ...future.conditions[[length(...future.conditions) + 
[17:03:42.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:42.780]                   if (TRUE && !signal) {
[17:03:42.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.780]                     {
[17:03:42.780]                       inherits <- base::inherits
[17:03:42.780]                       invokeRestart <- base::invokeRestart
[17:03:42.780]                       is.null <- base::is.null
[17:03:42.780]                       muffled <- FALSE
[17:03:42.780]                       if (inherits(cond, "message")) {
[17:03:42.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.780]                         if (muffled) 
[17:03:42.780]                           invokeRestart("muffleMessage")
[17:03:42.780]                       }
[17:03:42.780]                       else if (inherits(cond, "warning")) {
[17:03:42.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.780]                         if (muffled) 
[17:03:42.780]                           invokeRestart("muffleWarning")
[17:03:42.780]                       }
[17:03:42.780]                       else if (inherits(cond, "condition")) {
[17:03:42.780]                         if (!is.null(pattern)) {
[17:03:42.780]                           computeRestarts <- base::computeRestarts
[17:03:42.780]                           grepl <- base::grepl
[17:03:42.780]                           restarts <- computeRestarts(cond)
[17:03:42.780]                           for (restart in restarts) {
[17:03:42.780]                             name <- restart$name
[17:03:42.780]                             if (is.null(name)) 
[17:03:42.780]                               next
[17:03:42.780]                             if (!grepl(pattern, name)) 
[17:03:42.780]                               next
[17:03:42.780]                             invokeRestart(restart)
[17:03:42.780]                             muffled <- TRUE
[17:03:42.780]                             break
[17:03:42.780]                           }
[17:03:42.780]                         }
[17:03:42.780]                       }
[17:03:42.780]                       invisible(muffled)
[17:03:42.780]                     }
[17:03:42.780]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.780]                   }
[17:03:42.780]                 }
[17:03:42.780]                 else {
[17:03:42.780]                   if (TRUE) {
[17:03:42.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:42.780]                     {
[17:03:42.780]                       inherits <- base::inherits
[17:03:42.780]                       invokeRestart <- base::invokeRestart
[17:03:42.780]                       is.null <- base::is.null
[17:03:42.780]                       muffled <- FALSE
[17:03:42.780]                       if (inherits(cond, "message")) {
[17:03:42.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:42.780]                         if (muffled) 
[17:03:42.780]                           invokeRestart("muffleMessage")
[17:03:42.780]                       }
[17:03:42.780]                       else if (inherits(cond, "warning")) {
[17:03:42.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:42.780]                         if (muffled) 
[17:03:42.780]                           invokeRestart("muffleWarning")
[17:03:42.780]                       }
[17:03:42.780]                       else if (inherits(cond, "condition")) {
[17:03:42.780]                         if (!is.null(pattern)) {
[17:03:42.780]                           computeRestarts <- base::computeRestarts
[17:03:42.780]                           grepl <- base::grepl
[17:03:42.780]                           restarts <- computeRestarts(cond)
[17:03:42.780]                           for (restart in restarts) {
[17:03:42.780]                             name <- restart$name
[17:03:42.780]                             if (is.null(name)) 
[17:03:42.780]                               next
[17:03:42.780]                             if (!grepl(pattern, name)) 
[17:03:42.780]                               next
[17:03:42.780]                             invokeRestart(restart)
[17:03:42.780]                             muffled <- TRUE
[17:03:42.780]                             break
[17:03:42.780]                           }
[17:03:42.780]                         }
[17:03:42.780]                       }
[17:03:42.780]                       invisible(muffled)
[17:03:42.780]                     }
[17:03:42.780]                     muffleCondition(cond, pattern = "^muffle")
[17:03:42.780]                   }
[17:03:42.780]                 }
[17:03:42.780]             }
[17:03:42.780]         }))
[17:03:42.780]     }, error = function(ex) {
[17:03:42.780]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:42.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:42.780]                 ...future.rng), started = ...future.startTime, 
[17:03:42.780]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:42.780]             version = "1.8"), class = "FutureResult")
[17:03:42.780]     }, finally = {
[17:03:42.780]         if (!identical(...future.workdir, getwd())) 
[17:03:42.780]             setwd(...future.workdir)
[17:03:42.780]         {
[17:03:42.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:42.780]                 ...future.oldOptions$nwarnings <- NULL
[17:03:42.780]             }
[17:03:42.780]             base::options(...future.oldOptions)
[17:03:42.780]             if (.Platform$OS.type == "windows") {
[17:03:42.780]                 old_names <- names(...future.oldEnvVars)
[17:03:42.780]                 envs <- base::Sys.getenv()
[17:03:42.780]                 names <- names(envs)
[17:03:42.780]                 common <- intersect(names, old_names)
[17:03:42.780]                 added <- setdiff(names, old_names)
[17:03:42.780]                 removed <- setdiff(old_names, names)
[17:03:42.780]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:42.780]                   envs[common]]
[17:03:42.780]                 NAMES <- toupper(changed)
[17:03:42.780]                 args <- list()
[17:03:42.780]                 for (kk in seq_along(NAMES)) {
[17:03:42.780]                   name <- changed[[kk]]
[17:03:42.780]                   NAME <- NAMES[[kk]]
[17:03:42.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.780]                     next
[17:03:42.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.780]                 }
[17:03:42.780]                 NAMES <- toupper(added)
[17:03:42.780]                 for (kk in seq_along(NAMES)) {
[17:03:42.780]                   name <- added[[kk]]
[17:03:42.780]                   NAME <- NAMES[[kk]]
[17:03:42.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.780]                     next
[17:03:42.780]                   args[[name]] <- ""
[17:03:42.780]                 }
[17:03:42.780]                 NAMES <- toupper(removed)
[17:03:42.780]                 for (kk in seq_along(NAMES)) {
[17:03:42.780]                   name <- removed[[kk]]
[17:03:42.780]                   NAME <- NAMES[[kk]]
[17:03:42.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:42.780]                     next
[17:03:42.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:42.780]                 }
[17:03:42.780]                 if (length(args) > 0) 
[17:03:42.780]                   base::do.call(base::Sys.setenv, args = args)
[17:03:42.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:42.780]             }
[17:03:42.780]             else {
[17:03:42.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:42.780]             }
[17:03:42.780]             {
[17:03:42.780]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:42.780]                   0L) {
[17:03:42.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:42.780]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:42.780]                   base::options(opts)
[17:03:42.780]                 }
[17:03:42.780]                 {
[17:03:42.780]                   {
[17:03:42.780]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:42.780]                     NULL
[17:03:42.780]                   }
[17:03:42.780]                   options(future.plan = NULL)
[17:03:42.780]                   if (is.na(NA_character_)) 
[17:03:42.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:42.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:42.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:42.780]                     .init = FALSE)
[17:03:42.780]                 }
[17:03:42.780]             }
[17:03:42.780]         }
[17:03:42.780]     })
[17:03:42.780]     if (TRUE) {
[17:03:42.780]         base::sink(type = "output", split = FALSE)
[17:03:42.780]         if (TRUE) {
[17:03:42.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:42.780]         }
[17:03:42.780]         else {
[17:03:42.780]             ...future.result["stdout"] <- base::list(NULL)
[17:03:42.780]         }
[17:03:42.780]         base::close(...future.stdout)
[17:03:42.780]         ...future.stdout <- NULL
[17:03:42.780]     }
[17:03:42.780]     ...future.result$conditions <- ...future.conditions
[17:03:42.780]     ...future.result$finished <- base::Sys.time()
[17:03:42.780]     ...future.result
[17:03:42.780] }
[17:03:42.783] MultisessionFuture started
[17:03:42.783] - Launch lazy future ... done
[17:03:42.784] run() for ‘MultisessionFuture’ ... done
[17:03:43.286] receiveMessageFromWorker() for ClusterFuture ...
[17:03:43.286] - Validating connection of MultisessionFuture
[17:03:43.287] - received message: FutureResult
[17:03:43.287] - Received FutureResult
[17:03:43.287] - Erased future from FutureRegistry
[17:03:43.287] result() for ClusterFuture ...
[17:03:43.287] - result already collected: FutureResult
[17:03:43.287] result() for ClusterFuture ... done
[17:03:43.287] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:43.287] A MultisessionFuture was resolved (result was not collected)
[17:03:43.287] getGlobalsAndPackages() ...
[17:03:43.287] Searching for globals...
[17:03:43.289] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:43.289] Searching for globals ... DONE
[17:03:43.289] Resolving globals: FALSE
[17:03:43.289] 
[17:03:43.289] 
[17:03:43.289] getGlobalsAndPackages() ... DONE
[17:03:43.290] run() for ‘Future’ ...
[17:03:43.290] - state: ‘created’
[17:03:43.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:43.304] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:43.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:43.304]   - Field: ‘node’
[17:03:43.304]   - Field: ‘label’
[17:03:43.304]   - Field: ‘local’
[17:03:43.304]   - Field: ‘owner’
[17:03:43.304]   - Field: ‘envir’
[17:03:43.304]   - Field: ‘workers’
[17:03:43.304]   - Field: ‘packages’
[17:03:43.305]   - Field: ‘gc’
[17:03:43.305]   - Field: ‘conditions’
[17:03:43.305]   - Field: ‘persistent’
[17:03:43.305]   - Field: ‘expr’
[17:03:43.305]   - Field: ‘uuid’
[17:03:43.305]   - Field: ‘seed’
[17:03:43.305]   - Field: ‘version’
[17:03:43.305]   - Field: ‘result’
[17:03:43.305]   - Field: ‘asynchronous’
[17:03:43.305]   - Field: ‘calls’
[17:03:43.305]   - Field: ‘globals’
[17:03:43.306]   - Field: ‘stdout’
[17:03:43.306]   - Field: ‘earlySignal’
[17:03:43.306]   - Field: ‘lazy’
[17:03:43.306]   - Field: ‘state’
[17:03:43.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:43.306] - Launch lazy future ...
[17:03:43.306] Packages needed by the future expression (n = 0): <none>
[17:03:43.306] Packages needed by future strategies (n = 0): <none>
[17:03:43.307] {
[17:03:43.307]     {
[17:03:43.307]         {
[17:03:43.307]             ...future.startTime <- base::Sys.time()
[17:03:43.307]             {
[17:03:43.307]                 {
[17:03:43.307]                   {
[17:03:43.307]                     {
[17:03:43.307]                       base::local({
[17:03:43.307]                         has_future <- base::requireNamespace("future", 
[17:03:43.307]                           quietly = TRUE)
[17:03:43.307]                         if (has_future) {
[17:03:43.307]                           ns <- base::getNamespace("future")
[17:03:43.307]                           version <- ns[[".package"]][["version"]]
[17:03:43.307]                           if (is.null(version)) 
[17:03:43.307]                             version <- utils::packageVersion("future")
[17:03:43.307]                         }
[17:03:43.307]                         else {
[17:03:43.307]                           version <- NULL
[17:03:43.307]                         }
[17:03:43.307]                         if (!has_future || version < "1.8.0") {
[17:03:43.307]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:43.307]                             "", base::R.version$version.string), 
[17:03:43.307]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:43.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:43.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:43.307]                               "release", "version")], collapse = " "), 
[17:03:43.307]                             hostname = base::Sys.info()[["nodename"]])
[17:03:43.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:43.307]                             info)
[17:03:43.307]                           info <- base::paste(info, collapse = "; ")
[17:03:43.307]                           if (!has_future) {
[17:03:43.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:43.307]                               info)
[17:03:43.307]                           }
[17:03:43.307]                           else {
[17:03:43.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:43.307]                               info, version)
[17:03:43.307]                           }
[17:03:43.307]                           base::stop(msg)
[17:03:43.307]                         }
[17:03:43.307]                       })
[17:03:43.307]                     }
[17:03:43.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:43.307]                     base::options(mc.cores = 1L)
[17:03:43.307]                   }
[17:03:43.307]                   ...future.strategy.old <- future::plan("list")
[17:03:43.307]                   options(future.plan = NULL)
[17:03:43.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:43.307]                 }
[17:03:43.307]                 ...future.workdir <- getwd()
[17:03:43.307]             }
[17:03:43.307]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:43.307]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:43.307]         }
[17:03:43.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:43.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:43.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:43.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:43.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:43.307]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:43.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:43.307]             base::names(...future.oldOptions))
[17:03:43.307]     }
[17:03:43.307]     if (FALSE) {
[17:03:43.307]     }
[17:03:43.307]     else {
[17:03:43.307]         if (TRUE) {
[17:03:43.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:43.307]                 open = "w")
[17:03:43.307]         }
[17:03:43.307]         else {
[17:03:43.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:43.307]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:43.307]         }
[17:03:43.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:43.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:43.307]             base::sink(type = "output", split = FALSE)
[17:03:43.307]             base::close(...future.stdout)
[17:03:43.307]         }, add = TRUE)
[17:03:43.307]     }
[17:03:43.307]     ...future.frame <- base::sys.nframe()
[17:03:43.307]     ...future.conditions <- base::list()
[17:03:43.307]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:43.307]     if (FALSE) {
[17:03:43.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:43.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:43.307]     }
[17:03:43.307]     ...future.result <- base::tryCatch({
[17:03:43.307]         base::withCallingHandlers({
[17:03:43.307]             ...future.value <- base::withVisible(base::local({
[17:03:43.307]                 ...future.makeSendCondition <- base::local({
[17:03:43.307]                   sendCondition <- NULL
[17:03:43.307]                   function(frame = 1L) {
[17:03:43.307]                     if (is.function(sendCondition)) 
[17:03:43.307]                       return(sendCondition)
[17:03:43.307]                     ns <- getNamespace("parallel")
[17:03:43.307]                     if (exists("sendData", mode = "function", 
[17:03:43.307]                       envir = ns)) {
[17:03:43.307]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:43.307]                         envir = ns)
[17:03:43.307]                       envir <- sys.frame(frame)
[17:03:43.307]                       master <- NULL
[17:03:43.307]                       while (!identical(envir, .GlobalEnv) && 
[17:03:43.307]                         !identical(envir, emptyenv())) {
[17:03:43.307]                         if (exists("master", mode = "list", envir = envir, 
[17:03:43.307]                           inherits = FALSE)) {
[17:03:43.307]                           master <- get("master", mode = "list", 
[17:03:43.307]                             envir = envir, inherits = FALSE)
[17:03:43.307]                           if (inherits(master, c("SOCKnode", 
[17:03:43.307]                             "SOCK0node"))) {
[17:03:43.307]                             sendCondition <<- function(cond) {
[17:03:43.307]                               data <- list(type = "VALUE", value = cond, 
[17:03:43.307]                                 success = TRUE)
[17:03:43.307]                               parallel_sendData(master, data)
[17:03:43.307]                             }
[17:03:43.307]                             return(sendCondition)
[17:03:43.307]                           }
[17:03:43.307]                         }
[17:03:43.307]                         frame <- frame + 1L
[17:03:43.307]                         envir <- sys.frame(frame)
[17:03:43.307]                       }
[17:03:43.307]                     }
[17:03:43.307]                     sendCondition <<- function(cond) NULL
[17:03:43.307]                   }
[17:03:43.307]                 })
[17:03:43.307]                 withCallingHandlers({
[17:03:43.307]                   {
[17:03:43.307]                     Sys.sleep(0.5)
[17:03:43.307]                     list(a = 1, b = 42L)
[17:03:43.307]                   }
[17:03:43.307]                 }, immediateCondition = function(cond) {
[17:03:43.307]                   sendCondition <- ...future.makeSendCondition()
[17:03:43.307]                   sendCondition(cond)
[17:03:43.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.307]                   {
[17:03:43.307]                     inherits <- base::inherits
[17:03:43.307]                     invokeRestart <- base::invokeRestart
[17:03:43.307]                     is.null <- base::is.null
[17:03:43.307]                     muffled <- FALSE
[17:03:43.307]                     if (inherits(cond, "message")) {
[17:03:43.307]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:43.307]                       if (muffled) 
[17:03:43.307]                         invokeRestart("muffleMessage")
[17:03:43.307]                     }
[17:03:43.307]                     else if (inherits(cond, "warning")) {
[17:03:43.307]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:43.307]                       if (muffled) 
[17:03:43.307]                         invokeRestart("muffleWarning")
[17:03:43.307]                     }
[17:03:43.307]                     else if (inherits(cond, "condition")) {
[17:03:43.307]                       if (!is.null(pattern)) {
[17:03:43.307]                         computeRestarts <- base::computeRestarts
[17:03:43.307]                         grepl <- base::grepl
[17:03:43.307]                         restarts <- computeRestarts(cond)
[17:03:43.307]                         for (restart in restarts) {
[17:03:43.307]                           name <- restart$name
[17:03:43.307]                           if (is.null(name)) 
[17:03:43.307]                             next
[17:03:43.307]                           if (!grepl(pattern, name)) 
[17:03:43.307]                             next
[17:03:43.307]                           invokeRestart(restart)
[17:03:43.307]                           muffled <- TRUE
[17:03:43.307]                           break
[17:03:43.307]                         }
[17:03:43.307]                       }
[17:03:43.307]                     }
[17:03:43.307]                     invisible(muffled)
[17:03:43.307]                   }
[17:03:43.307]                   muffleCondition(cond)
[17:03:43.307]                 })
[17:03:43.307]             }))
[17:03:43.307]             future::FutureResult(value = ...future.value$value, 
[17:03:43.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.307]                   ...future.rng), globalenv = if (FALSE) 
[17:03:43.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:43.307]                     ...future.globalenv.names))
[17:03:43.307]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:43.307]         }, condition = base::local({
[17:03:43.307]             c <- base::c
[17:03:43.307]             inherits <- base::inherits
[17:03:43.307]             invokeRestart <- base::invokeRestart
[17:03:43.307]             length <- base::length
[17:03:43.307]             list <- base::list
[17:03:43.307]             seq.int <- base::seq.int
[17:03:43.307]             signalCondition <- base::signalCondition
[17:03:43.307]             sys.calls <- base::sys.calls
[17:03:43.307]             `[[` <- base::`[[`
[17:03:43.307]             `+` <- base::`+`
[17:03:43.307]             `<<-` <- base::`<<-`
[17:03:43.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:43.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:43.307]                   3L)]
[17:03:43.307]             }
[17:03:43.307]             function(cond) {
[17:03:43.307]                 is_error <- inherits(cond, "error")
[17:03:43.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:43.307]                   NULL)
[17:03:43.307]                 if (is_error) {
[17:03:43.307]                   sessionInformation <- function() {
[17:03:43.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:43.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:43.307]                       search = base::search(), system = base::Sys.info())
[17:03:43.307]                   }
[17:03:43.307]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:43.307]                     cond$call), session = sessionInformation(), 
[17:03:43.307]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:43.307]                   signalCondition(cond)
[17:03:43.307]                 }
[17:03:43.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:43.307]                 "immediateCondition"))) {
[17:03:43.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:43.307]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:43.307]                   if (TRUE && !signal) {
[17:03:43.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.307]                     {
[17:03:43.307]                       inherits <- base::inherits
[17:03:43.307]                       invokeRestart <- base::invokeRestart
[17:03:43.307]                       is.null <- base::is.null
[17:03:43.307]                       muffled <- FALSE
[17:03:43.307]                       if (inherits(cond, "message")) {
[17:03:43.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.307]                         if (muffled) 
[17:03:43.307]                           invokeRestart("muffleMessage")
[17:03:43.307]                       }
[17:03:43.307]                       else if (inherits(cond, "warning")) {
[17:03:43.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.307]                         if (muffled) 
[17:03:43.307]                           invokeRestart("muffleWarning")
[17:03:43.307]                       }
[17:03:43.307]                       else if (inherits(cond, "condition")) {
[17:03:43.307]                         if (!is.null(pattern)) {
[17:03:43.307]                           computeRestarts <- base::computeRestarts
[17:03:43.307]                           grepl <- base::grepl
[17:03:43.307]                           restarts <- computeRestarts(cond)
[17:03:43.307]                           for (restart in restarts) {
[17:03:43.307]                             name <- restart$name
[17:03:43.307]                             if (is.null(name)) 
[17:03:43.307]                               next
[17:03:43.307]                             if (!grepl(pattern, name)) 
[17:03:43.307]                               next
[17:03:43.307]                             invokeRestart(restart)
[17:03:43.307]                             muffled <- TRUE
[17:03:43.307]                             break
[17:03:43.307]                           }
[17:03:43.307]                         }
[17:03:43.307]                       }
[17:03:43.307]                       invisible(muffled)
[17:03:43.307]                     }
[17:03:43.307]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.307]                   }
[17:03:43.307]                 }
[17:03:43.307]                 else {
[17:03:43.307]                   if (TRUE) {
[17:03:43.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.307]                     {
[17:03:43.307]                       inherits <- base::inherits
[17:03:43.307]                       invokeRestart <- base::invokeRestart
[17:03:43.307]                       is.null <- base::is.null
[17:03:43.307]                       muffled <- FALSE
[17:03:43.307]                       if (inherits(cond, "message")) {
[17:03:43.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.307]                         if (muffled) 
[17:03:43.307]                           invokeRestart("muffleMessage")
[17:03:43.307]                       }
[17:03:43.307]                       else if (inherits(cond, "warning")) {
[17:03:43.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.307]                         if (muffled) 
[17:03:43.307]                           invokeRestart("muffleWarning")
[17:03:43.307]                       }
[17:03:43.307]                       else if (inherits(cond, "condition")) {
[17:03:43.307]                         if (!is.null(pattern)) {
[17:03:43.307]                           computeRestarts <- base::computeRestarts
[17:03:43.307]                           grepl <- base::grepl
[17:03:43.307]                           restarts <- computeRestarts(cond)
[17:03:43.307]                           for (restart in restarts) {
[17:03:43.307]                             name <- restart$name
[17:03:43.307]                             if (is.null(name)) 
[17:03:43.307]                               next
[17:03:43.307]                             if (!grepl(pattern, name)) 
[17:03:43.307]                               next
[17:03:43.307]                             invokeRestart(restart)
[17:03:43.307]                             muffled <- TRUE
[17:03:43.307]                             break
[17:03:43.307]                           }
[17:03:43.307]                         }
[17:03:43.307]                       }
[17:03:43.307]                       invisible(muffled)
[17:03:43.307]                     }
[17:03:43.307]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.307]                   }
[17:03:43.307]                 }
[17:03:43.307]             }
[17:03:43.307]         }))
[17:03:43.307]     }, error = function(ex) {
[17:03:43.307]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:43.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.307]                 ...future.rng), started = ...future.startTime, 
[17:03:43.307]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:43.307]             version = "1.8"), class = "FutureResult")
[17:03:43.307]     }, finally = {
[17:03:43.307]         if (!identical(...future.workdir, getwd())) 
[17:03:43.307]             setwd(...future.workdir)
[17:03:43.307]         {
[17:03:43.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:43.307]                 ...future.oldOptions$nwarnings <- NULL
[17:03:43.307]             }
[17:03:43.307]             base::options(...future.oldOptions)
[17:03:43.307]             if (.Platform$OS.type == "windows") {
[17:03:43.307]                 old_names <- names(...future.oldEnvVars)
[17:03:43.307]                 envs <- base::Sys.getenv()
[17:03:43.307]                 names <- names(envs)
[17:03:43.307]                 common <- intersect(names, old_names)
[17:03:43.307]                 added <- setdiff(names, old_names)
[17:03:43.307]                 removed <- setdiff(old_names, names)
[17:03:43.307]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:43.307]                   envs[common]]
[17:03:43.307]                 NAMES <- toupper(changed)
[17:03:43.307]                 args <- list()
[17:03:43.307]                 for (kk in seq_along(NAMES)) {
[17:03:43.307]                   name <- changed[[kk]]
[17:03:43.307]                   NAME <- NAMES[[kk]]
[17:03:43.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.307]                     next
[17:03:43.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.307]                 }
[17:03:43.307]                 NAMES <- toupper(added)
[17:03:43.307]                 for (kk in seq_along(NAMES)) {
[17:03:43.307]                   name <- added[[kk]]
[17:03:43.307]                   NAME <- NAMES[[kk]]
[17:03:43.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.307]                     next
[17:03:43.307]                   args[[name]] <- ""
[17:03:43.307]                 }
[17:03:43.307]                 NAMES <- toupper(removed)
[17:03:43.307]                 for (kk in seq_along(NAMES)) {
[17:03:43.307]                   name <- removed[[kk]]
[17:03:43.307]                   NAME <- NAMES[[kk]]
[17:03:43.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.307]                     next
[17:03:43.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.307]                 }
[17:03:43.307]                 if (length(args) > 0) 
[17:03:43.307]                   base::do.call(base::Sys.setenv, args = args)
[17:03:43.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:43.307]             }
[17:03:43.307]             else {
[17:03:43.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:43.307]             }
[17:03:43.307]             {
[17:03:43.307]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:43.307]                   0L) {
[17:03:43.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:43.307]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:43.307]                   base::options(opts)
[17:03:43.307]                 }
[17:03:43.307]                 {
[17:03:43.307]                   {
[17:03:43.307]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:43.307]                     NULL
[17:03:43.307]                   }
[17:03:43.307]                   options(future.plan = NULL)
[17:03:43.307]                   if (is.na(NA_character_)) 
[17:03:43.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:43.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:43.307]                     .init = FALSE)
[17:03:43.307]                 }
[17:03:43.307]             }
[17:03:43.307]         }
[17:03:43.307]     })
[17:03:43.307]     if (TRUE) {
[17:03:43.307]         base::sink(type = "output", split = FALSE)
[17:03:43.307]         if (TRUE) {
[17:03:43.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:43.307]         }
[17:03:43.307]         else {
[17:03:43.307]             ...future.result["stdout"] <- base::list(NULL)
[17:03:43.307]         }
[17:03:43.307]         base::close(...future.stdout)
[17:03:43.307]         ...future.stdout <- NULL
[17:03:43.307]     }
[17:03:43.307]     ...future.result$conditions <- ...future.conditions
[17:03:43.307]     ...future.result$finished <- base::Sys.time()
[17:03:43.307]     ...future.result
[17:03:43.307] }
[17:03:43.310] MultisessionFuture started
[17:03:43.310] - Launch lazy future ... done
[17:03:43.310] run() for ‘MultisessionFuture’ ... done
[17:03:43.813] receiveMessageFromWorker() for ClusterFuture ...
[17:03:43.813] - Validating connection of MultisessionFuture
[17:03:43.813] - received message: FutureResult
[17:03:43.813] - Received FutureResult
[17:03:43.813] - Erased future from FutureRegistry
[17:03:43.813] result() for ClusterFuture ...
[17:03:43.813] - result already collected: FutureResult
[17:03:43.814] result() for ClusterFuture ... done
[17:03:43.814] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:43.814] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:03:43.814] getGlobalsAndPackages() ...
[17:03:43.814] Searching for globals...
[17:03:43.815] - globals found: [2] ‘list’, ‘stop’
[17:03:43.815] Searching for globals ... DONE
[17:03:43.815] Resolving globals: FALSE
[17:03:43.815] 
[17:03:43.815] 
[17:03:43.815] getGlobalsAndPackages() ... DONE
[17:03:43.816] run() for ‘Future’ ...
[17:03:43.816] - state: ‘created’
[17:03:43.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:43.830] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:43.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:43.830]   - Field: ‘node’
[17:03:43.830]   - Field: ‘label’
[17:03:43.830]   - Field: ‘local’
[17:03:43.830]   - Field: ‘owner’
[17:03:43.830]   - Field: ‘envir’
[17:03:43.830]   - Field: ‘workers’
[17:03:43.831]   - Field: ‘packages’
[17:03:43.831]   - Field: ‘gc’
[17:03:43.831]   - Field: ‘conditions’
[17:03:43.831]   - Field: ‘persistent’
[17:03:43.831]   - Field: ‘expr’
[17:03:43.831]   - Field: ‘uuid’
[17:03:43.831]   - Field: ‘seed’
[17:03:43.831]   - Field: ‘version’
[17:03:43.831]   - Field: ‘result’
[17:03:43.831]   - Field: ‘asynchronous’
[17:03:43.832]   - Field: ‘calls’
[17:03:43.832]   - Field: ‘globals’
[17:03:43.832]   - Field: ‘stdout’
[17:03:43.832]   - Field: ‘earlySignal’
[17:03:43.832]   - Field: ‘lazy’
[17:03:43.832]   - Field: ‘state’
[17:03:43.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:43.832] - Launch lazy future ...
[17:03:43.832] Packages needed by the future expression (n = 0): <none>
[17:03:43.833] Packages needed by future strategies (n = 0): <none>
[17:03:43.833] {
[17:03:43.833]     {
[17:03:43.833]         {
[17:03:43.833]             ...future.startTime <- base::Sys.time()
[17:03:43.833]             {
[17:03:43.833]                 {
[17:03:43.833]                   {
[17:03:43.833]                     {
[17:03:43.833]                       base::local({
[17:03:43.833]                         has_future <- base::requireNamespace("future", 
[17:03:43.833]                           quietly = TRUE)
[17:03:43.833]                         if (has_future) {
[17:03:43.833]                           ns <- base::getNamespace("future")
[17:03:43.833]                           version <- ns[[".package"]][["version"]]
[17:03:43.833]                           if (is.null(version)) 
[17:03:43.833]                             version <- utils::packageVersion("future")
[17:03:43.833]                         }
[17:03:43.833]                         else {
[17:03:43.833]                           version <- NULL
[17:03:43.833]                         }
[17:03:43.833]                         if (!has_future || version < "1.8.0") {
[17:03:43.833]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:43.833]                             "", base::R.version$version.string), 
[17:03:43.833]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:43.833]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:43.833]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:43.833]                               "release", "version")], collapse = " "), 
[17:03:43.833]                             hostname = base::Sys.info()[["nodename"]])
[17:03:43.833]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:43.833]                             info)
[17:03:43.833]                           info <- base::paste(info, collapse = "; ")
[17:03:43.833]                           if (!has_future) {
[17:03:43.833]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:43.833]                               info)
[17:03:43.833]                           }
[17:03:43.833]                           else {
[17:03:43.833]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:43.833]                               info, version)
[17:03:43.833]                           }
[17:03:43.833]                           base::stop(msg)
[17:03:43.833]                         }
[17:03:43.833]                       })
[17:03:43.833]                     }
[17:03:43.833]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:43.833]                     base::options(mc.cores = 1L)
[17:03:43.833]                   }
[17:03:43.833]                   ...future.strategy.old <- future::plan("list")
[17:03:43.833]                   options(future.plan = NULL)
[17:03:43.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:43.833]                 }
[17:03:43.833]                 ...future.workdir <- getwd()
[17:03:43.833]             }
[17:03:43.833]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:43.833]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:43.833]         }
[17:03:43.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:43.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:43.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:43.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:43.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:43.833]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:43.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:43.833]             base::names(...future.oldOptions))
[17:03:43.833]     }
[17:03:43.833]     if (FALSE) {
[17:03:43.833]     }
[17:03:43.833]     else {
[17:03:43.833]         if (TRUE) {
[17:03:43.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:43.833]                 open = "w")
[17:03:43.833]         }
[17:03:43.833]         else {
[17:03:43.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:43.833]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:43.833]         }
[17:03:43.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:43.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:43.833]             base::sink(type = "output", split = FALSE)
[17:03:43.833]             base::close(...future.stdout)
[17:03:43.833]         }, add = TRUE)
[17:03:43.833]     }
[17:03:43.833]     ...future.frame <- base::sys.nframe()
[17:03:43.833]     ...future.conditions <- base::list()
[17:03:43.833]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:43.833]     if (FALSE) {
[17:03:43.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:43.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:43.833]     }
[17:03:43.833]     ...future.result <- base::tryCatch({
[17:03:43.833]         base::withCallingHandlers({
[17:03:43.833]             ...future.value <- base::withVisible(base::local({
[17:03:43.833]                 ...future.makeSendCondition <- base::local({
[17:03:43.833]                   sendCondition <- NULL
[17:03:43.833]                   function(frame = 1L) {
[17:03:43.833]                     if (is.function(sendCondition)) 
[17:03:43.833]                       return(sendCondition)
[17:03:43.833]                     ns <- getNamespace("parallel")
[17:03:43.833]                     if (exists("sendData", mode = "function", 
[17:03:43.833]                       envir = ns)) {
[17:03:43.833]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:43.833]                         envir = ns)
[17:03:43.833]                       envir <- sys.frame(frame)
[17:03:43.833]                       master <- NULL
[17:03:43.833]                       while (!identical(envir, .GlobalEnv) && 
[17:03:43.833]                         !identical(envir, emptyenv())) {
[17:03:43.833]                         if (exists("master", mode = "list", envir = envir, 
[17:03:43.833]                           inherits = FALSE)) {
[17:03:43.833]                           master <- get("master", mode = "list", 
[17:03:43.833]                             envir = envir, inherits = FALSE)
[17:03:43.833]                           if (inherits(master, c("SOCKnode", 
[17:03:43.833]                             "SOCK0node"))) {
[17:03:43.833]                             sendCondition <<- function(cond) {
[17:03:43.833]                               data <- list(type = "VALUE", value = cond, 
[17:03:43.833]                                 success = TRUE)
[17:03:43.833]                               parallel_sendData(master, data)
[17:03:43.833]                             }
[17:03:43.833]                             return(sendCondition)
[17:03:43.833]                           }
[17:03:43.833]                         }
[17:03:43.833]                         frame <- frame + 1L
[17:03:43.833]                         envir <- sys.frame(frame)
[17:03:43.833]                       }
[17:03:43.833]                     }
[17:03:43.833]                     sendCondition <<- function(cond) NULL
[17:03:43.833]                   }
[17:03:43.833]                 })
[17:03:43.833]                 withCallingHandlers({
[17:03:43.833]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:43.833]                 }, immediateCondition = function(cond) {
[17:03:43.833]                   sendCondition <- ...future.makeSendCondition()
[17:03:43.833]                   sendCondition(cond)
[17:03:43.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.833]                   {
[17:03:43.833]                     inherits <- base::inherits
[17:03:43.833]                     invokeRestart <- base::invokeRestart
[17:03:43.833]                     is.null <- base::is.null
[17:03:43.833]                     muffled <- FALSE
[17:03:43.833]                     if (inherits(cond, "message")) {
[17:03:43.833]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:43.833]                       if (muffled) 
[17:03:43.833]                         invokeRestart("muffleMessage")
[17:03:43.833]                     }
[17:03:43.833]                     else if (inherits(cond, "warning")) {
[17:03:43.833]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:43.833]                       if (muffled) 
[17:03:43.833]                         invokeRestart("muffleWarning")
[17:03:43.833]                     }
[17:03:43.833]                     else if (inherits(cond, "condition")) {
[17:03:43.833]                       if (!is.null(pattern)) {
[17:03:43.833]                         computeRestarts <- base::computeRestarts
[17:03:43.833]                         grepl <- base::grepl
[17:03:43.833]                         restarts <- computeRestarts(cond)
[17:03:43.833]                         for (restart in restarts) {
[17:03:43.833]                           name <- restart$name
[17:03:43.833]                           if (is.null(name)) 
[17:03:43.833]                             next
[17:03:43.833]                           if (!grepl(pattern, name)) 
[17:03:43.833]                             next
[17:03:43.833]                           invokeRestart(restart)
[17:03:43.833]                           muffled <- TRUE
[17:03:43.833]                           break
[17:03:43.833]                         }
[17:03:43.833]                       }
[17:03:43.833]                     }
[17:03:43.833]                     invisible(muffled)
[17:03:43.833]                   }
[17:03:43.833]                   muffleCondition(cond)
[17:03:43.833]                 })
[17:03:43.833]             }))
[17:03:43.833]             future::FutureResult(value = ...future.value$value, 
[17:03:43.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.833]                   ...future.rng), globalenv = if (FALSE) 
[17:03:43.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:43.833]                     ...future.globalenv.names))
[17:03:43.833]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:43.833]         }, condition = base::local({
[17:03:43.833]             c <- base::c
[17:03:43.833]             inherits <- base::inherits
[17:03:43.833]             invokeRestart <- base::invokeRestart
[17:03:43.833]             length <- base::length
[17:03:43.833]             list <- base::list
[17:03:43.833]             seq.int <- base::seq.int
[17:03:43.833]             signalCondition <- base::signalCondition
[17:03:43.833]             sys.calls <- base::sys.calls
[17:03:43.833]             `[[` <- base::`[[`
[17:03:43.833]             `+` <- base::`+`
[17:03:43.833]             `<<-` <- base::`<<-`
[17:03:43.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:43.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:43.833]                   3L)]
[17:03:43.833]             }
[17:03:43.833]             function(cond) {
[17:03:43.833]                 is_error <- inherits(cond, "error")
[17:03:43.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:43.833]                   NULL)
[17:03:43.833]                 if (is_error) {
[17:03:43.833]                   sessionInformation <- function() {
[17:03:43.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:43.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:43.833]                       search = base::search(), system = base::Sys.info())
[17:03:43.833]                   }
[17:03:43.833]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:43.833]                     cond$call), session = sessionInformation(), 
[17:03:43.833]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:43.833]                   signalCondition(cond)
[17:03:43.833]                 }
[17:03:43.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:43.833]                 "immediateCondition"))) {
[17:03:43.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:43.833]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:43.833]                   if (TRUE && !signal) {
[17:03:43.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.833]                     {
[17:03:43.833]                       inherits <- base::inherits
[17:03:43.833]                       invokeRestart <- base::invokeRestart
[17:03:43.833]                       is.null <- base::is.null
[17:03:43.833]                       muffled <- FALSE
[17:03:43.833]                       if (inherits(cond, "message")) {
[17:03:43.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.833]                         if (muffled) 
[17:03:43.833]                           invokeRestart("muffleMessage")
[17:03:43.833]                       }
[17:03:43.833]                       else if (inherits(cond, "warning")) {
[17:03:43.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.833]                         if (muffled) 
[17:03:43.833]                           invokeRestart("muffleWarning")
[17:03:43.833]                       }
[17:03:43.833]                       else if (inherits(cond, "condition")) {
[17:03:43.833]                         if (!is.null(pattern)) {
[17:03:43.833]                           computeRestarts <- base::computeRestarts
[17:03:43.833]                           grepl <- base::grepl
[17:03:43.833]                           restarts <- computeRestarts(cond)
[17:03:43.833]                           for (restart in restarts) {
[17:03:43.833]                             name <- restart$name
[17:03:43.833]                             if (is.null(name)) 
[17:03:43.833]                               next
[17:03:43.833]                             if (!grepl(pattern, name)) 
[17:03:43.833]                               next
[17:03:43.833]                             invokeRestart(restart)
[17:03:43.833]                             muffled <- TRUE
[17:03:43.833]                             break
[17:03:43.833]                           }
[17:03:43.833]                         }
[17:03:43.833]                       }
[17:03:43.833]                       invisible(muffled)
[17:03:43.833]                     }
[17:03:43.833]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.833]                   }
[17:03:43.833]                 }
[17:03:43.833]                 else {
[17:03:43.833]                   if (TRUE) {
[17:03:43.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.833]                     {
[17:03:43.833]                       inherits <- base::inherits
[17:03:43.833]                       invokeRestart <- base::invokeRestart
[17:03:43.833]                       is.null <- base::is.null
[17:03:43.833]                       muffled <- FALSE
[17:03:43.833]                       if (inherits(cond, "message")) {
[17:03:43.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.833]                         if (muffled) 
[17:03:43.833]                           invokeRestart("muffleMessage")
[17:03:43.833]                       }
[17:03:43.833]                       else if (inherits(cond, "warning")) {
[17:03:43.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.833]                         if (muffled) 
[17:03:43.833]                           invokeRestart("muffleWarning")
[17:03:43.833]                       }
[17:03:43.833]                       else if (inherits(cond, "condition")) {
[17:03:43.833]                         if (!is.null(pattern)) {
[17:03:43.833]                           computeRestarts <- base::computeRestarts
[17:03:43.833]                           grepl <- base::grepl
[17:03:43.833]                           restarts <- computeRestarts(cond)
[17:03:43.833]                           for (restart in restarts) {
[17:03:43.833]                             name <- restart$name
[17:03:43.833]                             if (is.null(name)) 
[17:03:43.833]                               next
[17:03:43.833]                             if (!grepl(pattern, name)) 
[17:03:43.833]                               next
[17:03:43.833]                             invokeRestart(restart)
[17:03:43.833]                             muffled <- TRUE
[17:03:43.833]                             break
[17:03:43.833]                           }
[17:03:43.833]                         }
[17:03:43.833]                       }
[17:03:43.833]                       invisible(muffled)
[17:03:43.833]                     }
[17:03:43.833]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.833]                   }
[17:03:43.833]                 }
[17:03:43.833]             }
[17:03:43.833]         }))
[17:03:43.833]     }, error = function(ex) {
[17:03:43.833]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:43.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.833]                 ...future.rng), started = ...future.startTime, 
[17:03:43.833]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:43.833]             version = "1.8"), class = "FutureResult")
[17:03:43.833]     }, finally = {
[17:03:43.833]         if (!identical(...future.workdir, getwd())) 
[17:03:43.833]             setwd(...future.workdir)
[17:03:43.833]         {
[17:03:43.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:43.833]                 ...future.oldOptions$nwarnings <- NULL
[17:03:43.833]             }
[17:03:43.833]             base::options(...future.oldOptions)
[17:03:43.833]             if (.Platform$OS.type == "windows") {
[17:03:43.833]                 old_names <- names(...future.oldEnvVars)
[17:03:43.833]                 envs <- base::Sys.getenv()
[17:03:43.833]                 names <- names(envs)
[17:03:43.833]                 common <- intersect(names, old_names)
[17:03:43.833]                 added <- setdiff(names, old_names)
[17:03:43.833]                 removed <- setdiff(old_names, names)
[17:03:43.833]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:43.833]                   envs[common]]
[17:03:43.833]                 NAMES <- toupper(changed)
[17:03:43.833]                 args <- list()
[17:03:43.833]                 for (kk in seq_along(NAMES)) {
[17:03:43.833]                   name <- changed[[kk]]
[17:03:43.833]                   NAME <- NAMES[[kk]]
[17:03:43.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.833]                     next
[17:03:43.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.833]                 }
[17:03:43.833]                 NAMES <- toupper(added)
[17:03:43.833]                 for (kk in seq_along(NAMES)) {
[17:03:43.833]                   name <- added[[kk]]
[17:03:43.833]                   NAME <- NAMES[[kk]]
[17:03:43.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.833]                     next
[17:03:43.833]                   args[[name]] <- ""
[17:03:43.833]                 }
[17:03:43.833]                 NAMES <- toupper(removed)
[17:03:43.833]                 for (kk in seq_along(NAMES)) {
[17:03:43.833]                   name <- removed[[kk]]
[17:03:43.833]                   NAME <- NAMES[[kk]]
[17:03:43.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.833]                     next
[17:03:43.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.833]                 }
[17:03:43.833]                 if (length(args) > 0) 
[17:03:43.833]                   base::do.call(base::Sys.setenv, args = args)
[17:03:43.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:43.833]             }
[17:03:43.833]             else {
[17:03:43.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:43.833]             }
[17:03:43.833]             {
[17:03:43.833]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:43.833]                   0L) {
[17:03:43.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:43.833]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:43.833]                   base::options(opts)
[17:03:43.833]                 }
[17:03:43.833]                 {
[17:03:43.833]                   {
[17:03:43.833]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:43.833]                     NULL
[17:03:43.833]                   }
[17:03:43.833]                   options(future.plan = NULL)
[17:03:43.833]                   if (is.na(NA_character_)) 
[17:03:43.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:43.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:43.833]                     .init = FALSE)
[17:03:43.833]                 }
[17:03:43.833]             }
[17:03:43.833]         }
[17:03:43.833]     })
[17:03:43.833]     if (TRUE) {
[17:03:43.833]         base::sink(type = "output", split = FALSE)
[17:03:43.833]         if (TRUE) {
[17:03:43.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:43.833]         }
[17:03:43.833]         else {
[17:03:43.833]             ...future.result["stdout"] <- base::list(NULL)
[17:03:43.833]         }
[17:03:43.833]         base::close(...future.stdout)
[17:03:43.833]         ...future.stdout <- NULL
[17:03:43.833]     }
[17:03:43.833]     ...future.result$conditions <- ...future.conditions
[17:03:43.833]     ...future.result$finished <- base::Sys.time()
[17:03:43.833]     ...future.result
[17:03:43.833] }
[17:03:43.836] MultisessionFuture started
[17:03:43.836] - Launch lazy future ... done
[17:03:43.836] run() for ‘MultisessionFuture’ ... done
[17:03:43.838] receiveMessageFromWorker() for ClusterFuture ...
[17:03:43.838] - Validating connection of MultisessionFuture
[17:03:43.839] - received message: FutureResult
[17:03:43.839] - Received FutureResult
[17:03:43.839] - Erased future from FutureRegistry
[17:03:43.839] result() for ClusterFuture ...
[17:03:43.839] - result already collected: FutureResult
[17:03:43.839] result() for ClusterFuture ... done
[17:03:43.839] signalConditions() ...
[17:03:43.840]  - include = ‘immediateCondition’
[17:03:43.840]  - exclude = 
[17:03:43.840]  - resignal = FALSE
[17:03:43.840]  - Number of conditions: 1
[17:03:43.840] signalConditions() ... done
[17:03:43.840] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:43.840] A MultisessionFuture was resolved (result was not collected)
[17:03:43.840] getGlobalsAndPackages() ...
[17:03:43.840] Searching for globals...
[17:03:43.841] - globals found: [2] ‘list’, ‘stop’
[17:03:43.841] Searching for globals ... DONE
[17:03:43.841] Resolving globals: FALSE
[17:03:43.841] 
[17:03:43.842] 
[17:03:43.842] getGlobalsAndPackages() ... DONE
[17:03:43.842] run() for ‘Future’ ...
[17:03:43.842] - state: ‘created’
[17:03:43.842] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:43.856] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:43.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:43.856]   - Field: ‘node’
[17:03:43.856]   - Field: ‘label’
[17:03:43.856]   - Field: ‘local’
[17:03:43.857]   - Field: ‘owner’
[17:03:43.857]   - Field: ‘envir’
[17:03:43.857]   - Field: ‘workers’
[17:03:43.857]   - Field: ‘packages’
[17:03:43.857]   - Field: ‘gc’
[17:03:43.857]   - Field: ‘conditions’
[17:03:43.857]   - Field: ‘persistent’
[17:03:43.857]   - Field: ‘expr’
[17:03:43.857]   - Field: ‘uuid’
[17:03:43.857]   - Field: ‘seed’
[17:03:43.857]   - Field: ‘version’
[17:03:43.858]   - Field: ‘result’
[17:03:43.858]   - Field: ‘asynchronous’
[17:03:43.858]   - Field: ‘calls’
[17:03:43.858]   - Field: ‘globals’
[17:03:43.858]   - Field: ‘stdout’
[17:03:43.858]   - Field: ‘earlySignal’
[17:03:43.858]   - Field: ‘lazy’
[17:03:43.858]   - Field: ‘state’
[17:03:43.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:43.858] - Launch lazy future ...
[17:03:43.859] Packages needed by the future expression (n = 0): <none>
[17:03:43.859] Packages needed by future strategies (n = 0): <none>
[17:03:43.859] {
[17:03:43.859]     {
[17:03:43.859]         {
[17:03:43.859]             ...future.startTime <- base::Sys.time()
[17:03:43.859]             {
[17:03:43.859]                 {
[17:03:43.859]                   {
[17:03:43.859]                     {
[17:03:43.859]                       base::local({
[17:03:43.859]                         has_future <- base::requireNamespace("future", 
[17:03:43.859]                           quietly = TRUE)
[17:03:43.859]                         if (has_future) {
[17:03:43.859]                           ns <- base::getNamespace("future")
[17:03:43.859]                           version <- ns[[".package"]][["version"]]
[17:03:43.859]                           if (is.null(version)) 
[17:03:43.859]                             version <- utils::packageVersion("future")
[17:03:43.859]                         }
[17:03:43.859]                         else {
[17:03:43.859]                           version <- NULL
[17:03:43.859]                         }
[17:03:43.859]                         if (!has_future || version < "1.8.0") {
[17:03:43.859]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:43.859]                             "", base::R.version$version.string), 
[17:03:43.859]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:43.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:43.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:43.859]                               "release", "version")], collapse = " "), 
[17:03:43.859]                             hostname = base::Sys.info()[["nodename"]])
[17:03:43.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:43.859]                             info)
[17:03:43.859]                           info <- base::paste(info, collapse = "; ")
[17:03:43.859]                           if (!has_future) {
[17:03:43.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:43.859]                               info)
[17:03:43.859]                           }
[17:03:43.859]                           else {
[17:03:43.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:43.859]                               info, version)
[17:03:43.859]                           }
[17:03:43.859]                           base::stop(msg)
[17:03:43.859]                         }
[17:03:43.859]                       })
[17:03:43.859]                     }
[17:03:43.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:43.859]                     base::options(mc.cores = 1L)
[17:03:43.859]                   }
[17:03:43.859]                   ...future.strategy.old <- future::plan("list")
[17:03:43.859]                   options(future.plan = NULL)
[17:03:43.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:43.859]                 }
[17:03:43.859]                 ...future.workdir <- getwd()
[17:03:43.859]             }
[17:03:43.859]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:43.859]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:43.859]         }
[17:03:43.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:43.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:43.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:43.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:43.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:43.859]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:43.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:43.859]             base::names(...future.oldOptions))
[17:03:43.859]     }
[17:03:43.859]     if (FALSE) {
[17:03:43.859]     }
[17:03:43.859]     else {
[17:03:43.859]         if (TRUE) {
[17:03:43.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:43.859]                 open = "w")
[17:03:43.859]         }
[17:03:43.859]         else {
[17:03:43.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:43.859]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:43.859]         }
[17:03:43.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:43.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:43.859]             base::sink(type = "output", split = FALSE)
[17:03:43.859]             base::close(...future.stdout)
[17:03:43.859]         }, add = TRUE)
[17:03:43.859]     }
[17:03:43.859]     ...future.frame <- base::sys.nframe()
[17:03:43.859]     ...future.conditions <- base::list()
[17:03:43.859]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:43.859]     if (FALSE) {
[17:03:43.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:43.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:43.859]     }
[17:03:43.859]     ...future.result <- base::tryCatch({
[17:03:43.859]         base::withCallingHandlers({
[17:03:43.859]             ...future.value <- base::withVisible(base::local({
[17:03:43.859]                 ...future.makeSendCondition <- base::local({
[17:03:43.859]                   sendCondition <- NULL
[17:03:43.859]                   function(frame = 1L) {
[17:03:43.859]                     if (is.function(sendCondition)) 
[17:03:43.859]                       return(sendCondition)
[17:03:43.859]                     ns <- getNamespace("parallel")
[17:03:43.859]                     if (exists("sendData", mode = "function", 
[17:03:43.859]                       envir = ns)) {
[17:03:43.859]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:43.859]                         envir = ns)
[17:03:43.859]                       envir <- sys.frame(frame)
[17:03:43.859]                       master <- NULL
[17:03:43.859]                       while (!identical(envir, .GlobalEnv) && 
[17:03:43.859]                         !identical(envir, emptyenv())) {
[17:03:43.859]                         if (exists("master", mode = "list", envir = envir, 
[17:03:43.859]                           inherits = FALSE)) {
[17:03:43.859]                           master <- get("master", mode = "list", 
[17:03:43.859]                             envir = envir, inherits = FALSE)
[17:03:43.859]                           if (inherits(master, c("SOCKnode", 
[17:03:43.859]                             "SOCK0node"))) {
[17:03:43.859]                             sendCondition <<- function(cond) {
[17:03:43.859]                               data <- list(type = "VALUE", value = cond, 
[17:03:43.859]                                 success = TRUE)
[17:03:43.859]                               parallel_sendData(master, data)
[17:03:43.859]                             }
[17:03:43.859]                             return(sendCondition)
[17:03:43.859]                           }
[17:03:43.859]                         }
[17:03:43.859]                         frame <- frame + 1L
[17:03:43.859]                         envir <- sys.frame(frame)
[17:03:43.859]                       }
[17:03:43.859]                     }
[17:03:43.859]                     sendCondition <<- function(cond) NULL
[17:03:43.859]                   }
[17:03:43.859]                 })
[17:03:43.859]                 withCallingHandlers({
[17:03:43.859]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:43.859]                 }, immediateCondition = function(cond) {
[17:03:43.859]                   sendCondition <- ...future.makeSendCondition()
[17:03:43.859]                   sendCondition(cond)
[17:03:43.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.859]                   {
[17:03:43.859]                     inherits <- base::inherits
[17:03:43.859]                     invokeRestart <- base::invokeRestart
[17:03:43.859]                     is.null <- base::is.null
[17:03:43.859]                     muffled <- FALSE
[17:03:43.859]                     if (inherits(cond, "message")) {
[17:03:43.859]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:43.859]                       if (muffled) 
[17:03:43.859]                         invokeRestart("muffleMessage")
[17:03:43.859]                     }
[17:03:43.859]                     else if (inherits(cond, "warning")) {
[17:03:43.859]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:43.859]                       if (muffled) 
[17:03:43.859]                         invokeRestart("muffleWarning")
[17:03:43.859]                     }
[17:03:43.859]                     else if (inherits(cond, "condition")) {
[17:03:43.859]                       if (!is.null(pattern)) {
[17:03:43.859]                         computeRestarts <- base::computeRestarts
[17:03:43.859]                         grepl <- base::grepl
[17:03:43.859]                         restarts <- computeRestarts(cond)
[17:03:43.859]                         for (restart in restarts) {
[17:03:43.859]                           name <- restart$name
[17:03:43.859]                           if (is.null(name)) 
[17:03:43.859]                             next
[17:03:43.859]                           if (!grepl(pattern, name)) 
[17:03:43.859]                             next
[17:03:43.859]                           invokeRestart(restart)
[17:03:43.859]                           muffled <- TRUE
[17:03:43.859]                           break
[17:03:43.859]                         }
[17:03:43.859]                       }
[17:03:43.859]                     }
[17:03:43.859]                     invisible(muffled)
[17:03:43.859]                   }
[17:03:43.859]                   muffleCondition(cond)
[17:03:43.859]                 })
[17:03:43.859]             }))
[17:03:43.859]             future::FutureResult(value = ...future.value$value, 
[17:03:43.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.859]                   ...future.rng), globalenv = if (FALSE) 
[17:03:43.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:43.859]                     ...future.globalenv.names))
[17:03:43.859]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:43.859]         }, condition = base::local({
[17:03:43.859]             c <- base::c
[17:03:43.859]             inherits <- base::inherits
[17:03:43.859]             invokeRestart <- base::invokeRestart
[17:03:43.859]             length <- base::length
[17:03:43.859]             list <- base::list
[17:03:43.859]             seq.int <- base::seq.int
[17:03:43.859]             signalCondition <- base::signalCondition
[17:03:43.859]             sys.calls <- base::sys.calls
[17:03:43.859]             `[[` <- base::`[[`
[17:03:43.859]             `+` <- base::`+`
[17:03:43.859]             `<<-` <- base::`<<-`
[17:03:43.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:43.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:43.859]                   3L)]
[17:03:43.859]             }
[17:03:43.859]             function(cond) {
[17:03:43.859]                 is_error <- inherits(cond, "error")
[17:03:43.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:43.859]                   NULL)
[17:03:43.859]                 if (is_error) {
[17:03:43.859]                   sessionInformation <- function() {
[17:03:43.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:43.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:43.859]                       search = base::search(), system = base::Sys.info())
[17:03:43.859]                   }
[17:03:43.859]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:43.859]                     cond$call), session = sessionInformation(), 
[17:03:43.859]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:43.859]                   signalCondition(cond)
[17:03:43.859]                 }
[17:03:43.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:43.859]                 "immediateCondition"))) {
[17:03:43.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:43.859]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:43.859]                   if (TRUE && !signal) {
[17:03:43.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.859]                     {
[17:03:43.859]                       inherits <- base::inherits
[17:03:43.859]                       invokeRestart <- base::invokeRestart
[17:03:43.859]                       is.null <- base::is.null
[17:03:43.859]                       muffled <- FALSE
[17:03:43.859]                       if (inherits(cond, "message")) {
[17:03:43.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.859]                         if (muffled) 
[17:03:43.859]                           invokeRestart("muffleMessage")
[17:03:43.859]                       }
[17:03:43.859]                       else if (inherits(cond, "warning")) {
[17:03:43.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.859]                         if (muffled) 
[17:03:43.859]                           invokeRestart("muffleWarning")
[17:03:43.859]                       }
[17:03:43.859]                       else if (inherits(cond, "condition")) {
[17:03:43.859]                         if (!is.null(pattern)) {
[17:03:43.859]                           computeRestarts <- base::computeRestarts
[17:03:43.859]                           grepl <- base::grepl
[17:03:43.859]                           restarts <- computeRestarts(cond)
[17:03:43.859]                           for (restart in restarts) {
[17:03:43.859]                             name <- restart$name
[17:03:43.859]                             if (is.null(name)) 
[17:03:43.859]                               next
[17:03:43.859]                             if (!grepl(pattern, name)) 
[17:03:43.859]                               next
[17:03:43.859]                             invokeRestart(restart)
[17:03:43.859]                             muffled <- TRUE
[17:03:43.859]                             break
[17:03:43.859]                           }
[17:03:43.859]                         }
[17:03:43.859]                       }
[17:03:43.859]                       invisible(muffled)
[17:03:43.859]                     }
[17:03:43.859]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.859]                   }
[17:03:43.859]                 }
[17:03:43.859]                 else {
[17:03:43.859]                   if (TRUE) {
[17:03:43.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.859]                     {
[17:03:43.859]                       inherits <- base::inherits
[17:03:43.859]                       invokeRestart <- base::invokeRestart
[17:03:43.859]                       is.null <- base::is.null
[17:03:43.859]                       muffled <- FALSE
[17:03:43.859]                       if (inherits(cond, "message")) {
[17:03:43.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.859]                         if (muffled) 
[17:03:43.859]                           invokeRestart("muffleMessage")
[17:03:43.859]                       }
[17:03:43.859]                       else if (inherits(cond, "warning")) {
[17:03:43.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.859]                         if (muffled) 
[17:03:43.859]                           invokeRestart("muffleWarning")
[17:03:43.859]                       }
[17:03:43.859]                       else if (inherits(cond, "condition")) {
[17:03:43.859]                         if (!is.null(pattern)) {
[17:03:43.859]                           computeRestarts <- base::computeRestarts
[17:03:43.859]                           grepl <- base::grepl
[17:03:43.859]                           restarts <- computeRestarts(cond)
[17:03:43.859]                           for (restart in restarts) {
[17:03:43.859]                             name <- restart$name
[17:03:43.859]                             if (is.null(name)) 
[17:03:43.859]                               next
[17:03:43.859]                             if (!grepl(pattern, name)) 
[17:03:43.859]                               next
[17:03:43.859]                             invokeRestart(restart)
[17:03:43.859]                             muffled <- TRUE
[17:03:43.859]                             break
[17:03:43.859]                           }
[17:03:43.859]                         }
[17:03:43.859]                       }
[17:03:43.859]                       invisible(muffled)
[17:03:43.859]                     }
[17:03:43.859]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.859]                   }
[17:03:43.859]                 }
[17:03:43.859]             }
[17:03:43.859]         }))
[17:03:43.859]     }, error = function(ex) {
[17:03:43.859]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:43.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.859]                 ...future.rng), started = ...future.startTime, 
[17:03:43.859]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:43.859]             version = "1.8"), class = "FutureResult")
[17:03:43.859]     }, finally = {
[17:03:43.859]         if (!identical(...future.workdir, getwd())) 
[17:03:43.859]             setwd(...future.workdir)
[17:03:43.859]         {
[17:03:43.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:43.859]                 ...future.oldOptions$nwarnings <- NULL
[17:03:43.859]             }
[17:03:43.859]             base::options(...future.oldOptions)
[17:03:43.859]             if (.Platform$OS.type == "windows") {
[17:03:43.859]                 old_names <- names(...future.oldEnvVars)
[17:03:43.859]                 envs <- base::Sys.getenv()
[17:03:43.859]                 names <- names(envs)
[17:03:43.859]                 common <- intersect(names, old_names)
[17:03:43.859]                 added <- setdiff(names, old_names)
[17:03:43.859]                 removed <- setdiff(old_names, names)
[17:03:43.859]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:43.859]                   envs[common]]
[17:03:43.859]                 NAMES <- toupper(changed)
[17:03:43.859]                 args <- list()
[17:03:43.859]                 for (kk in seq_along(NAMES)) {
[17:03:43.859]                   name <- changed[[kk]]
[17:03:43.859]                   NAME <- NAMES[[kk]]
[17:03:43.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.859]                     next
[17:03:43.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.859]                 }
[17:03:43.859]                 NAMES <- toupper(added)
[17:03:43.859]                 for (kk in seq_along(NAMES)) {
[17:03:43.859]                   name <- added[[kk]]
[17:03:43.859]                   NAME <- NAMES[[kk]]
[17:03:43.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.859]                     next
[17:03:43.859]                   args[[name]] <- ""
[17:03:43.859]                 }
[17:03:43.859]                 NAMES <- toupper(removed)
[17:03:43.859]                 for (kk in seq_along(NAMES)) {
[17:03:43.859]                   name <- removed[[kk]]
[17:03:43.859]                   NAME <- NAMES[[kk]]
[17:03:43.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.859]                     next
[17:03:43.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.859]                 }
[17:03:43.859]                 if (length(args) > 0) 
[17:03:43.859]                   base::do.call(base::Sys.setenv, args = args)
[17:03:43.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:43.859]             }
[17:03:43.859]             else {
[17:03:43.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:43.859]             }
[17:03:43.859]             {
[17:03:43.859]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:43.859]                   0L) {
[17:03:43.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:43.859]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:43.859]                   base::options(opts)
[17:03:43.859]                 }
[17:03:43.859]                 {
[17:03:43.859]                   {
[17:03:43.859]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:43.859]                     NULL
[17:03:43.859]                   }
[17:03:43.859]                   options(future.plan = NULL)
[17:03:43.859]                   if (is.na(NA_character_)) 
[17:03:43.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:43.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:43.859]                     .init = FALSE)
[17:03:43.859]                 }
[17:03:43.859]             }
[17:03:43.859]         }
[17:03:43.859]     })
[17:03:43.859]     if (TRUE) {
[17:03:43.859]         base::sink(type = "output", split = FALSE)
[17:03:43.859]         if (TRUE) {
[17:03:43.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:43.859]         }
[17:03:43.859]         else {
[17:03:43.859]             ...future.result["stdout"] <- base::list(NULL)
[17:03:43.859]         }
[17:03:43.859]         base::close(...future.stdout)
[17:03:43.859]         ...future.stdout <- NULL
[17:03:43.859]     }
[17:03:43.859]     ...future.result$conditions <- ...future.conditions
[17:03:43.859]     ...future.result$finished <- base::Sys.time()
[17:03:43.859]     ...future.result
[17:03:43.859] }
[17:03:43.862] MultisessionFuture started
[17:03:43.862] - Launch lazy future ... done
[17:03:43.863] run() for ‘MultisessionFuture’ ... done
[17:03:43.864] receiveMessageFromWorker() for ClusterFuture ...
[17:03:43.864] - Validating connection of MultisessionFuture
[17:03:43.865] - received message: FutureResult
[17:03:43.865] - Received FutureResult
[17:03:43.867] - Erased future from FutureRegistry
[17:03:43.867] result() for ClusterFuture ...
[17:03:43.867] - result already collected: FutureResult
[17:03:43.867] result() for ClusterFuture ... done
[17:03:43.868] signalConditions() ...
[17:03:43.868]  - include = ‘immediateCondition’
[17:03:43.868]  - exclude = 
[17:03:43.868]  - resignal = FALSE
[17:03:43.868]  - Number of conditions: 1
[17:03:43.868] signalConditions() ... done
[17:03:43.868] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:43.868] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[17:03:43.868] getGlobalsAndPackages() ...
[17:03:43.868] Searching for globals...
[17:03:43.869] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:43.870] Searching for globals ... DONE
[17:03:43.870] Resolving globals: FALSE
[17:03:43.870] 
[17:03:43.870] 
[17:03:43.870] getGlobalsAndPackages() ... DONE
[17:03:43.870] run() for ‘Future’ ...
[17:03:43.871] - state: ‘created’
[17:03:43.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:43.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:43.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:43.884]   - Field: ‘node’
[17:03:43.884]   - Field: ‘label’
[17:03:43.885]   - Field: ‘local’
[17:03:43.885]   - Field: ‘owner’
[17:03:43.885]   - Field: ‘envir’
[17:03:43.885]   - Field: ‘workers’
[17:03:43.885]   - Field: ‘packages’
[17:03:43.885]   - Field: ‘gc’
[17:03:43.885]   - Field: ‘conditions’
[17:03:43.885]   - Field: ‘persistent’
[17:03:43.885]   - Field: ‘expr’
[17:03:43.885]   - Field: ‘uuid’
[17:03:43.885]   - Field: ‘seed’
[17:03:43.886]   - Field: ‘version’
[17:03:43.886]   - Field: ‘result’
[17:03:43.886]   - Field: ‘asynchronous’
[17:03:43.886]   - Field: ‘calls’
[17:03:43.886]   - Field: ‘globals’
[17:03:43.886]   - Field: ‘stdout’
[17:03:43.886]   - Field: ‘earlySignal’
[17:03:43.886]   - Field: ‘lazy’
[17:03:43.886]   - Field: ‘state’
[17:03:43.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:43.886] - Launch lazy future ...
[17:03:43.887] Packages needed by the future expression (n = 0): <none>
[17:03:43.887] Packages needed by future strategies (n = 0): <none>
[17:03:43.887] {
[17:03:43.887]     {
[17:03:43.887]         {
[17:03:43.887]             ...future.startTime <- base::Sys.time()
[17:03:43.887]             {
[17:03:43.887]                 {
[17:03:43.887]                   {
[17:03:43.887]                     {
[17:03:43.887]                       base::local({
[17:03:43.887]                         has_future <- base::requireNamespace("future", 
[17:03:43.887]                           quietly = TRUE)
[17:03:43.887]                         if (has_future) {
[17:03:43.887]                           ns <- base::getNamespace("future")
[17:03:43.887]                           version <- ns[[".package"]][["version"]]
[17:03:43.887]                           if (is.null(version)) 
[17:03:43.887]                             version <- utils::packageVersion("future")
[17:03:43.887]                         }
[17:03:43.887]                         else {
[17:03:43.887]                           version <- NULL
[17:03:43.887]                         }
[17:03:43.887]                         if (!has_future || version < "1.8.0") {
[17:03:43.887]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:43.887]                             "", base::R.version$version.string), 
[17:03:43.887]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:43.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:43.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:43.887]                               "release", "version")], collapse = " "), 
[17:03:43.887]                             hostname = base::Sys.info()[["nodename"]])
[17:03:43.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:43.887]                             info)
[17:03:43.887]                           info <- base::paste(info, collapse = "; ")
[17:03:43.887]                           if (!has_future) {
[17:03:43.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:43.887]                               info)
[17:03:43.887]                           }
[17:03:43.887]                           else {
[17:03:43.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:43.887]                               info, version)
[17:03:43.887]                           }
[17:03:43.887]                           base::stop(msg)
[17:03:43.887]                         }
[17:03:43.887]                       })
[17:03:43.887]                     }
[17:03:43.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:43.887]                     base::options(mc.cores = 1L)
[17:03:43.887]                   }
[17:03:43.887]                   ...future.strategy.old <- future::plan("list")
[17:03:43.887]                   options(future.plan = NULL)
[17:03:43.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:43.887]                 }
[17:03:43.887]                 ...future.workdir <- getwd()
[17:03:43.887]             }
[17:03:43.887]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:43.887]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:43.887]         }
[17:03:43.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:43.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:43.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:43.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:43.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:43.887]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:43.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:43.887]             base::names(...future.oldOptions))
[17:03:43.887]     }
[17:03:43.887]     if (FALSE) {
[17:03:43.887]     }
[17:03:43.887]     else {
[17:03:43.887]         if (TRUE) {
[17:03:43.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:43.887]                 open = "w")
[17:03:43.887]         }
[17:03:43.887]         else {
[17:03:43.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:43.887]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:43.887]         }
[17:03:43.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:43.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:43.887]             base::sink(type = "output", split = FALSE)
[17:03:43.887]             base::close(...future.stdout)
[17:03:43.887]         }, add = TRUE)
[17:03:43.887]     }
[17:03:43.887]     ...future.frame <- base::sys.nframe()
[17:03:43.887]     ...future.conditions <- base::list()
[17:03:43.887]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:43.887]     if (FALSE) {
[17:03:43.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:43.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:43.887]     }
[17:03:43.887]     ...future.result <- base::tryCatch({
[17:03:43.887]         base::withCallingHandlers({
[17:03:43.887]             ...future.value <- base::withVisible(base::local({
[17:03:43.887]                 ...future.makeSendCondition <- base::local({
[17:03:43.887]                   sendCondition <- NULL
[17:03:43.887]                   function(frame = 1L) {
[17:03:43.887]                     if (is.function(sendCondition)) 
[17:03:43.887]                       return(sendCondition)
[17:03:43.887]                     ns <- getNamespace("parallel")
[17:03:43.887]                     if (exists("sendData", mode = "function", 
[17:03:43.887]                       envir = ns)) {
[17:03:43.887]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:43.887]                         envir = ns)
[17:03:43.887]                       envir <- sys.frame(frame)
[17:03:43.887]                       master <- NULL
[17:03:43.887]                       while (!identical(envir, .GlobalEnv) && 
[17:03:43.887]                         !identical(envir, emptyenv())) {
[17:03:43.887]                         if (exists("master", mode = "list", envir = envir, 
[17:03:43.887]                           inherits = FALSE)) {
[17:03:43.887]                           master <- get("master", mode = "list", 
[17:03:43.887]                             envir = envir, inherits = FALSE)
[17:03:43.887]                           if (inherits(master, c("SOCKnode", 
[17:03:43.887]                             "SOCK0node"))) {
[17:03:43.887]                             sendCondition <<- function(cond) {
[17:03:43.887]                               data <- list(type = "VALUE", value = cond, 
[17:03:43.887]                                 success = TRUE)
[17:03:43.887]                               parallel_sendData(master, data)
[17:03:43.887]                             }
[17:03:43.887]                             return(sendCondition)
[17:03:43.887]                           }
[17:03:43.887]                         }
[17:03:43.887]                         frame <- frame + 1L
[17:03:43.887]                         envir <- sys.frame(frame)
[17:03:43.887]                       }
[17:03:43.887]                     }
[17:03:43.887]                     sendCondition <<- function(cond) NULL
[17:03:43.887]                   }
[17:03:43.887]                 })
[17:03:43.887]                 withCallingHandlers({
[17:03:43.887]                   {
[17:03:43.887]                     Sys.sleep(0.5)
[17:03:43.887]                     list(a = 1, b = 42L)
[17:03:43.887]                   }
[17:03:43.887]                 }, immediateCondition = function(cond) {
[17:03:43.887]                   sendCondition <- ...future.makeSendCondition()
[17:03:43.887]                   sendCondition(cond)
[17:03:43.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.887]                   {
[17:03:43.887]                     inherits <- base::inherits
[17:03:43.887]                     invokeRestart <- base::invokeRestart
[17:03:43.887]                     is.null <- base::is.null
[17:03:43.887]                     muffled <- FALSE
[17:03:43.887]                     if (inherits(cond, "message")) {
[17:03:43.887]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:43.887]                       if (muffled) 
[17:03:43.887]                         invokeRestart("muffleMessage")
[17:03:43.887]                     }
[17:03:43.887]                     else if (inherits(cond, "warning")) {
[17:03:43.887]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:43.887]                       if (muffled) 
[17:03:43.887]                         invokeRestart("muffleWarning")
[17:03:43.887]                     }
[17:03:43.887]                     else if (inherits(cond, "condition")) {
[17:03:43.887]                       if (!is.null(pattern)) {
[17:03:43.887]                         computeRestarts <- base::computeRestarts
[17:03:43.887]                         grepl <- base::grepl
[17:03:43.887]                         restarts <- computeRestarts(cond)
[17:03:43.887]                         for (restart in restarts) {
[17:03:43.887]                           name <- restart$name
[17:03:43.887]                           if (is.null(name)) 
[17:03:43.887]                             next
[17:03:43.887]                           if (!grepl(pattern, name)) 
[17:03:43.887]                             next
[17:03:43.887]                           invokeRestart(restart)
[17:03:43.887]                           muffled <- TRUE
[17:03:43.887]                           break
[17:03:43.887]                         }
[17:03:43.887]                       }
[17:03:43.887]                     }
[17:03:43.887]                     invisible(muffled)
[17:03:43.887]                   }
[17:03:43.887]                   muffleCondition(cond)
[17:03:43.887]                 })
[17:03:43.887]             }))
[17:03:43.887]             future::FutureResult(value = ...future.value$value, 
[17:03:43.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.887]                   ...future.rng), globalenv = if (FALSE) 
[17:03:43.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:43.887]                     ...future.globalenv.names))
[17:03:43.887]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:43.887]         }, condition = base::local({
[17:03:43.887]             c <- base::c
[17:03:43.887]             inherits <- base::inherits
[17:03:43.887]             invokeRestart <- base::invokeRestart
[17:03:43.887]             length <- base::length
[17:03:43.887]             list <- base::list
[17:03:43.887]             seq.int <- base::seq.int
[17:03:43.887]             signalCondition <- base::signalCondition
[17:03:43.887]             sys.calls <- base::sys.calls
[17:03:43.887]             `[[` <- base::`[[`
[17:03:43.887]             `+` <- base::`+`
[17:03:43.887]             `<<-` <- base::`<<-`
[17:03:43.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:43.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:43.887]                   3L)]
[17:03:43.887]             }
[17:03:43.887]             function(cond) {
[17:03:43.887]                 is_error <- inherits(cond, "error")
[17:03:43.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:43.887]                   NULL)
[17:03:43.887]                 if (is_error) {
[17:03:43.887]                   sessionInformation <- function() {
[17:03:43.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:43.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:43.887]                       search = base::search(), system = base::Sys.info())
[17:03:43.887]                   }
[17:03:43.887]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:43.887]                     cond$call), session = sessionInformation(), 
[17:03:43.887]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:43.887]                   signalCondition(cond)
[17:03:43.887]                 }
[17:03:43.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:43.887]                 "immediateCondition"))) {
[17:03:43.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:43.887]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:43.887]                   if (TRUE && !signal) {
[17:03:43.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.887]                     {
[17:03:43.887]                       inherits <- base::inherits
[17:03:43.887]                       invokeRestart <- base::invokeRestart
[17:03:43.887]                       is.null <- base::is.null
[17:03:43.887]                       muffled <- FALSE
[17:03:43.887]                       if (inherits(cond, "message")) {
[17:03:43.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.887]                         if (muffled) 
[17:03:43.887]                           invokeRestart("muffleMessage")
[17:03:43.887]                       }
[17:03:43.887]                       else if (inherits(cond, "warning")) {
[17:03:43.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.887]                         if (muffled) 
[17:03:43.887]                           invokeRestart("muffleWarning")
[17:03:43.887]                       }
[17:03:43.887]                       else if (inherits(cond, "condition")) {
[17:03:43.887]                         if (!is.null(pattern)) {
[17:03:43.887]                           computeRestarts <- base::computeRestarts
[17:03:43.887]                           grepl <- base::grepl
[17:03:43.887]                           restarts <- computeRestarts(cond)
[17:03:43.887]                           for (restart in restarts) {
[17:03:43.887]                             name <- restart$name
[17:03:43.887]                             if (is.null(name)) 
[17:03:43.887]                               next
[17:03:43.887]                             if (!grepl(pattern, name)) 
[17:03:43.887]                               next
[17:03:43.887]                             invokeRestart(restart)
[17:03:43.887]                             muffled <- TRUE
[17:03:43.887]                             break
[17:03:43.887]                           }
[17:03:43.887]                         }
[17:03:43.887]                       }
[17:03:43.887]                       invisible(muffled)
[17:03:43.887]                     }
[17:03:43.887]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.887]                   }
[17:03:43.887]                 }
[17:03:43.887]                 else {
[17:03:43.887]                   if (TRUE) {
[17:03:43.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.887]                     {
[17:03:43.887]                       inherits <- base::inherits
[17:03:43.887]                       invokeRestart <- base::invokeRestart
[17:03:43.887]                       is.null <- base::is.null
[17:03:43.887]                       muffled <- FALSE
[17:03:43.887]                       if (inherits(cond, "message")) {
[17:03:43.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.887]                         if (muffled) 
[17:03:43.887]                           invokeRestart("muffleMessage")
[17:03:43.887]                       }
[17:03:43.887]                       else if (inherits(cond, "warning")) {
[17:03:43.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.887]                         if (muffled) 
[17:03:43.887]                           invokeRestart("muffleWarning")
[17:03:43.887]                       }
[17:03:43.887]                       else if (inherits(cond, "condition")) {
[17:03:43.887]                         if (!is.null(pattern)) {
[17:03:43.887]                           computeRestarts <- base::computeRestarts
[17:03:43.887]                           grepl <- base::grepl
[17:03:43.887]                           restarts <- computeRestarts(cond)
[17:03:43.887]                           for (restart in restarts) {
[17:03:43.887]                             name <- restart$name
[17:03:43.887]                             if (is.null(name)) 
[17:03:43.887]                               next
[17:03:43.887]                             if (!grepl(pattern, name)) 
[17:03:43.887]                               next
[17:03:43.887]                             invokeRestart(restart)
[17:03:43.887]                             muffled <- TRUE
[17:03:43.887]                             break
[17:03:43.887]                           }
[17:03:43.887]                         }
[17:03:43.887]                       }
[17:03:43.887]                       invisible(muffled)
[17:03:43.887]                     }
[17:03:43.887]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.887]                   }
[17:03:43.887]                 }
[17:03:43.887]             }
[17:03:43.887]         }))
[17:03:43.887]     }, error = function(ex) {
[17:03:43.887]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:43.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.887]                 ...future.rng), started = ...future.startTime, 
[17:03:43.887]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:43.887]             version = "1.8"), class = "FutureResult")
[17:03:43.887]     }, finally = {
[17:03:43.887]         if (!identical(...future.workdir, getwd())) 
[17:03:43.887]             setwd(...future.workdir)
[17:03:43.887]         {
[17:03:43.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:43.887]                 ...future.oldOptions$nwarnings <- NULL
[17:03:43.887]             }
[17:03:43.887]             base::options(...future.oldOptions)
[17:03:43.887]             if (.Platform$OS.type == "windows") {
[17:03:43.887]                 old_names <- names(...future.oldEnvVars)
[17:03:43.887]                 envs <- base::Sys.getenv()
[17:03:43.887]                 names <- names(envs)
[17:03:43.887]                 common <- intersect(names, old_names)
[17:03:43.887]                 added <- setdiff(names, old_names)
[17:03:43.887]                 removed <- setdiff(old_names, names)
[17:03:43.887]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:43.887]                   envs[common]]
[17:03:43.887]                 NAMES <- toupper(changed)
[17:03:43.887]                 args <- list()
[17:03:43.887]                 for (kk in seq_along(NAMES)) {
[17:03:43.887]                   name <- changed[[kk]]
[17:03:43.887]                   NAME <- NAMES[[kk]]
[17:03:43.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.887]                     next
[17:03:43.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.887]                 }
[17:03:43.887]                 NAMES <- toupper(added)
[17:03:43.887]                 for (kk in seq_along(NAMES)) {
[17:03:43.887]                   name <- added[[kk]]
[17:03:43.887]                   NAME <- NAMES[[kk]]
[17:03:43.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.887]                     next
[17:03:43.887]                   args[[name]] <- ""
[17:03:43.887]                 }
[17:03:43.887]                 NAMES <- toupper(removed)
[17:03:43.887]                 for (kk in seq_along(NAMES)) {
[17:03:43.887]                   name <- removed[[kk]]
[17:03:43.887]                   NAME <- NAMES[[kk]]
[17:03:43.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.887]                     next
[17:03:43.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.887]                 }
[17:03:43.887]                 if (length(args) > 0) 
[17:03:43.887]                   base::do.call(base::Sys.setenv, args = args)
[17:03:43.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:43.887]             }
[17:03:43.887]             else {
[17:03:43.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:43.887]             }
[17:03:43.887]             {
[17:03:43.887]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:43.887]                   0L) {
[17:03:43.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:43.887]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:43.887]                   base::options(opts)
[17:03:43.887]                 }
[17:03:43.887]                 {
[17:03:43.887]                   {
[17:03:43.887]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:43.887]                     NULL
[17:03:43.887]                   }
[17:03:43.887]                   options(future.plan = NULL)
[17:03:43.887]                   if (is.na(NA_character_)) 
[17:03:43.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:43.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:43.887]                     .init = FALSE)
[17:03:43.887]                 }
[17:03:43.887]             }
[17:03:43.887]         }
[17:03:43.887]     })
[17:03:43.887]     if (TRUE) {
[17:03:43.887]         base::sink(type = "output", split = FALSE)
[17:03:43.887]         if (TRUE) {
[17:03:43.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:43.887]         }
[17:03:43.887]         else {
[17:03:43.887]             ...future.result["stdout"] <- base::list(NULL)
[17:03:43.887]         }
[17:03:43.887]         base::close(...future.stdout)
[17:03:43.887]         ...future.stdout <- NULL
[17:03:43.887]     }
[17:03:43.887]     ...future.result$conditions <- ...future.conditions
[17:03:43.887]     ...future.result$finished <- base::Sys.time()
[17:03:43.887]     ...future.result
[17:03:43.887] }
[17:03:43.890] MultisessionFuture started
[17:03:43.890] - Launch lazy future ... done
[17:03:43.891] run() for ‘MultisessionFuture’ ... done
[17:03:43.891] getGlobalsAndPackages() ...
[17:03:43.891] Searching for globals...
[17:03:43.892] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:43.893] Searching for globals ... DONE
[17:03:43.893] Resolving globals: FALSE
[17:03:43.893] 
[17:03:43.893] 
[17:03:43.893] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:03:43.893] getGlobalsAndPackages() ...
[17:03:43.894] Searching for globals...
[17:03:43.894] - globals found: [2] ‘list’, ‘stop’
[17:03:43.894] Searching for globals ... DONE
[17:03:43.894] Resolving globals: FALSE
[17:03:43.895] 
[17:03:43.895] 
[17:03:43.895] getGlobalsAndPackages() ... DONE
[17:03:43.895] run() for ‘Future’ ...
[17:03:43.895] - state: ‘created’
[17:03:43.895] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:43.909] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:43.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:43.909]   - Field: ‘node’
[17:03:43.909]   - Field: ‘label’
[17:03:43.909]   - Field: ‘local’
[17:03:43.909]   - Field: ‘owner’
[17:03:43.909]   - Field: ‘envir’
[17:03:43.910]   - Field: ‘workers’
[17:03:43.910]   - Field: ‘packages’
[17:03:43.910]   - Field: ‘gc’
[17:03:43.910]   - Field: ‘conditions’
[17:03:43.910]   - Field: ‘persistent’
[17:03:43.910]   - Field: ‘expr’
[17:03:43.910]   - Field: ‘uuid’
[17:03:43.910]   - Field: ‘seed’
[17:03:43.910]   - Field: ‘version’
[17:03:43.910]   - Field: ‘result’
[17:03:43.910]   - Field: ‘asynchronous’
[17:03:43.910]   - Field: ‘calls’
[17:03:43.911]   - Field: ‘globals’
[17:03:43.911]   - Field: ‘stdout’
[17:03:43.911]   - Field: ‘earlySignal’
[17:03:43.911]   - Field: ‘lazy’
[17:03:43.911]   - Field: ‘state’
[17:03:43.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:43.911] - Launch lazy future ...
[17:03:43.911] Packages needed by the future expression (n = 0): <none>
[17:03:43.911] Packages needed by future strategies (n = 0): <none>
[17:03:43.912] {
[17:03:43.912]     {
[17:03:43.912]         {
[17:03:43.912]             ...future.startTime <- base::Sys.time()
[17:03:43.912]             {
[17:03:43.912]                 {
[17:03:43.912]                   {
[17:03:43.912]                     {
[17:03:43.912]                       base::local({
[17:03:43.912]                         has_future <- base::requireNamespace("future", 
[17:03:43.912]                           quietly = TRUE)
[17:03:43.912]                         if (has_future) {
[17:03:43.912]                           ns <- base::getNamespace("future")
[17:03:43.912]                           version <- ns[[".package"]][["version"]]
[17:03:43.912]                           if (is.null(version)) 
[17:03:43.912]                             version <- utils::packageVersion("future")
[17:03:43.912]                         }
[17:03:43.912]                         else {
[17:03:43.912]                           version <- NULL
[17:03:43.912]                         }
[17:03:43.912]                         if (!has_future || version < "1.8.0") {
[17:03:43.912]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:43.912]                             "", base::R.version$version.string), 
[17:03:43.912]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:43.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:43.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:43.912]                               "release", "version")], collapse = " "), 
[17:03:43.912]                             hostname = base::Sys.info()[["nodename"]])
[17:03:43.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:43.912]                             info)
[17:03:43.912]                           info <- base::paste(info, collapse = "; ")
[17:03:43.912]                           if (!has_future) {
[17:03:43.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:43.912]                               info)
[17:03:43.912]                           }
[17:03:43.912]                           else {
[17:03:43.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:43.912]                               info, version)
[17:03:43.912]                           }
[17:03:43.912]                           base::stop(msg)
[17:03:43.912]                         }
[17:03:43.912]                       })
[17:03:43.912]                     }
[17:03:43.912]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:43.912]                     base::options(mc.cores = 1L)
[17:03:43.912]                   }
[17:03:43.912]                   ...future.strategy.old <- future::plan("list")
[17:03:43.912]                   options(future.plan = NULL)
[17:03:43.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:43.912]                 }
[17:03:43.912]                 ...future.workdir <- getwd()
[17:03:43.912]             }
[17:03:43.912]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:43.912]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:43.912]         }
[17:03:43.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:43.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:43.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:43.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:43.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:43.912]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:43.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:43.912]             base::names(...future.oldOptions))
[17:03:43.912]     }
[17:03:43.912]     if (FALSE) {
[17:03:43.912]     }
[17:03:43.912]     else {
[17:03:43.912]         if (TRUE) {
[17:03:43.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:43.912]                 open = "w")
[17:03:43.912]         }
[17:03:43.912]         else {
[17:03:43.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:43.912]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:43.912]         }
[17:03:43.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:43.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:43.912]             base::sink(type = "output", split = FALSE)
[17:03:43.912]             base::close(...future.stdout)
[17:03:43.912]         }, add = TRUE)
[17:03:43.912]     }
[17:03:43.912]     ...future.frame <- base::sys.nframe()
[17:03:43.912]     ...future.conditions <- base::list()
[17:03:43.912]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:43.912]     if (FALSE) {
[17:03:43.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:43.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:43.912]     }
[17:03:43.912]     ...future.result <- base::tryCatch({
[17:03:43.912]         base::withCallingHandlers({
[17:03:43.912]             ...future.value <- base::withVisible(base::local({
[17:03:43.912]                 ...future.makeSendCondition <- base::local({
[17:03:43.912]                   sendCondition <- NULL
[17:03:43.912]                   function(frame = 1L) {
[17:03:43.912]                     if (is.function(sendCondition)) 
[17:03:43.912]                       return(sendCondition)
[17:03:43.912]                     ns <- getNamespace("parallel")
[17:03:43.912]                     if (exists("sendData", mode = "function", 
[17:03:43.912]                       envir = ns)) {
[17:03:43.912]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:43.912]                         envir = ns)
[17:03:43.912]                       envir <- sys.frame(frame)
[17:03:43.912]                       master <- NULL
[17:03:43.912]                       while (!identical(envir, .GlobalEnv) && 
[17:03:43.912]                         !identical(envir, emptyenv())) {
[17:03:43.912]                         if (exists("master", mode = "list", envir = envir, 
[17:03:43.912]                           inherits = FALSE)) {
[17:03:43.912]                           master <- get("master", mode = "list", 
[17:03:43.912]                             envir = envir, inherits = FALSE)
[17:03:43.912]                           if (inherits(master, c("SOCKnode", 
[17:03:43.912]                             "SOCK0node"))) {
[17:03:43.912]                             sendCondition <<- function(cond) {
[17:03:43.912]                               data <- list(type = "VALUE", value = cond, 
[17:03:43.912]                                 success = TRUE)
[17:03:43.912]                               parallel_sendData(master, data)
[17:03:43.912]                             }
[17:03:43.912]                             return(sendCondition)
[17:03:43.912]                           }
[17:03:43.912]                         }
[17:03:43.912]                         frame <- frame + 1L
[17:03:43.912]                         envir <- sys.frame(frame)
[17:03:43.912]                       }
[17:03:43.912]                     }
[17:03:43.912]                     sendCondition <<- function(cond) NULL
[17:03:43.912]                   }
[17:03:43.912]                 })
[17:03:43.912]                 withCallingHandlers({
[17:03:43.912]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:43.912]                 }, immediateCondition = function(cond) {
[17:03:43.912]                   sendCondition <- ...future.makeSendCondition()
[17:03:43.912]                   sendCondition(cond)
[17:03:43.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.912]                   {
[17:03:43.912]                     inherits <- base::inherits
[17:03:43.912]                     invokeRestart <- base::invokeRestart
[17:03:43.912]                     is.null <- base::is.null
[17:03:43.912]                     muffled <- FALSE
[17:03:43.912]                     if (inherits(cond, "message")) {
[17:03:43.912]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:43.912]                       if (muffled) 
[17:03:43.912]                         invokeRestart("muffleMessage")
[17:03:43.912]                     }
[17:03:43.912]                     else if (inherits(cond, "warning")) {
[17:03:43.912]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:43.912]                       if (muffled) 
[17:03:43.912]                         invokeRestart("muffleWarning")
[17:03:43.912]                     }
[17:03:43.912]                     else if (inherits(cond, "condition")) {
[17:03:43.912]                       if (!is.null(pattern)) {
[17:03:43.912]                         computeRestarts <- base::computeRestarts
[17:03:43.912]                         grepl <- base::grepl
[17:03:43.912]                         restarts <- computeRestarts(cond)
[17:03:43.912]                         for (restart in restarts) {
[17:03:43.912]                           name <- restart$name
[17:03:43.912]                           if (is.null(name)) 
[17:03:43.912]                             next
[17:03:43.912]                           if (!grepl(pattern, name)) 
[17:03:43.912]                             next
[17:03:43.912]                           invokeRestart(restart)
[17:03:43.912]                           muffled <- TRUE
[17:03:43.912]                           break
[17:03:43.912]                         }
[17:03:43.912]                       }
[17:03:43.912]                     }
[17:03:43.912]                     invisible(muffled)
[17:03:43.912]                   }
[17:03:43.912]                   muffleCondition(cond)
[17:03:43.912]                 })
[17:03:43.912]             }))
[17:03:43.912]             future::FutureResult(value = ...future.value$value, 
[17:03:43.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.912]                   ...future.rng), globalenv = if (FALSE) 
[17:03:43.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:43.912]                     ...future.globalenv.names))
[17:03:43.912]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:43.912]         }, condition = base::local({
[17:03:43.912]             c <- base::c
[17:03:43.912]             inherits <- base::inherits
[17:03:43.912]             invokeRestart <- base::invokeRestart
[17:03:43.912]             length <- base::length
[17:03:43.912]             list <- base::list
[17:03:43.912]             seq.int <- base::seq.int
[17:03:43.912]             signalCondition <- base::signalCondition
[17:03:43.912]             sys.calls <- base::sys.calls
[17:03:43.912]             `[[` <- base::`[[`
[17:03:43.912]             `+` <- base::`+`
[17:03:43.912]             `<<-` <- base::`<<-`
[17:03:43.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:43.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:43.912]                   3L)]
[17:03:43.912]             }
[17:03:43.912]             function(cond) {
[17:03:43.912]                 is_error <- inherits(cond, "error")
[17:03:43.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:43.912]                   NULL)
[17:03:43.912]                 if (is_error) {
[17:03:43.912]                   sessionInformation <- function() {
[17:03:43.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:43.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:43.912]                       search = base::search(), system = base::Sys.info())
[17:03:43.912]                   }
[17:03:43.912]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:43.912]                     cond$call), session = sessionInformation(), 
[17:03:43.912]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:43.912]                   signalCondition(cond)
[17:03:43.912]                 }
[17:03:43.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:43.912]                 "immediateCondition"))) {
[17:03:43.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:43.912]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:43.912]                   if (TRUE && !signal) {
[17:03:43.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.912]                     {
[17:03:43.912]                       inherits <- base::inherits
[17:03:43.912]                       invokeRestart <- base::invokeRestart
[17:03:43.912]                       is.null <- base::is.null
[17:03:43.912]                       muffled <- FALSE
[17:03:43.912]                       if (inherits(cond, "message")) {
[17:03:43.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.912]                         if (muffled) 
[17:03:43.912]                           invokeRestart("muffleMessage")
[17:03:43.912]                       }
[17:03:43.912]                       else if (inherits(cond, "warning")) {
[17:03:43.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.912]                         if (muffled) 
[17:03:43.912]                           invokeRestart("muffleWarning")
[17:03:43.912]                       }
[17:03:43.912]                       else if (inherits(cond, "condition")) {
[17:03:43.912]                         if (!is.null(pattern)) {
[17:03:43.912]                           computeRestarts <- base::computeRestarts
[17:03:43.912]                           grepl <- base::grepl
[17:03:43.912]                           restarts <- computeRestarts(cond)
[17:03:43.912]                           for (restart in restarts) {
[17:03:43.912]                             name <- restart$name
[17:03:43.912]                             if (is.null(name)) 
[17:03:43.912]                               next
[17:03:43.912]                             if (!grepl(pattern, name)) 
[17:03:43.912]                               next
[17:03:43.912]                             invokeRestart(restart)
[17:03:43.912]                             muffled <- TRUE
[17:03:43.912]                             break
[17:03:43.912]                           }
[17:03:43.912]                         }
[17:03:43.912]                       }
[17:03:43.912]                       invisible(muffled)
[17:03:43.912]                     }
[17:03:43.912]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.912]                   }
[17:03:43.912]                 }
[17:03:43.912]                 else {
[17:03:43.912]                   if (TRUE) {
[17:03:43.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.912]                     {
[17:03:43.912]                       inherits <- base::inherits
[17:03:43.912]                       invokeRestart <- base::invokeRestart
[17:03:43.912]                       is.null <- base::is.null
[17:03:43.912]                       muffled <- FALSE
[17:03:43.912]                       if (inherits(cond, "message")) {
[17:03:43.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.912]                         if (muffled) 
[17:03:43.912]                           invokeRestart("muffleMessage")
[17:03:43.912]                       }
[17:03:43.912]                       else if (inherits(cond, "warning")) {
[17:03:43.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.912]                         if (muffled) 
[17:03:43.912]                           invokeRestart("muffleWarning")
[17:03:43.912]                       }
[17:03:43.912]                       else if (inherits(cond, "condition")) {
[17:03:43.912]                         if (!is.null(pattern)) {
[17:03:43.912]                           computeRestarts <- base::computeRestarts
[17:03:43.912]                           grepl <- base::grepl
[17:03:43.912]                           restarts <- computeRestarts(cond)
[17:03:43.912]                           for (restart in restarts) {
[17:03:43.912]                             name <- restart$name
[17:03:43.912]                             if (is.null(name)) 
[17:03:43.912]                               next
[17:03:43.912]                             if (!grepl(pattern, name)) 
[17:03:43.912]                               next
[17:03:43.912]                             invokeRestart(restart)
[17:03:43.912]                             muffled <- TRUE
[17:03:43.912]                             break
[17:03:43.912]                           }
[17:03:43.912]                         }
[17:03:43.912]                       }
[17:03:43.912]                       invisible(muffled)
[17:03:43.912]                     }
[17:03:43.912]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.912]                   }
[17:03:43.912]                 }
[17:03:43.912]             }
[17:03:43.912]         }))
[17:03:43.912]     }, error = function(ex) {
[17:03:43.912]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:43.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.912]                 ...future.rng), started = ...future.startTime, 
[17:03:43.912]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:43.912]             version = "1.8"), class = "FutureResult")
[17:03:43.912]     }, finally = {
[17:03:43.912]         if (!identical(...future.workdir, getwd())) 
[17:03:43.912]             setwd(...future.workdir)
[17:03:43.912]         {
[17:03:43.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:43.912]                 ...future.oldOptions$nwarnings <- NULL
[17:03:43.912]             }
[17:03:43.912]             base::options(...future.oldOptions)
[17:03:43.912]             if (.Platform$OS.type == "windows") {
[17:03:43.912]                 old_names <- names(...future.oldEnvVars)
[17:03:43.912]                 envs <- base::Sys.getenv()
[17:03:43.912]                 names <- names(envs)
[17:03:43.912]                 common <- intersect(names, old_names)
[17:03:43.912]                 added <- setdiff(names, old_names)
[17:03:43.912]                 removed <- setdiff(old_names, names)
[17:03:43.912]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:43.912]                   envs[common]]
[17:03:43.912]                 NAMES <- toupper(changed)
[17:03:43.912]                 args <- list()
[17:03:43.912]                 for (kk in seq_along(NAMES)) {
[17:03:43.912]                   name <- changed[[kk]]
[17:03:43.912]                   NAME <- NAMES[[kk]]
[17:03:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.912]                     next
[17:03:43.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.912]                 }
[17:03:43.912]                 NAMES <- toupper(added)
[17:03:43.912]                 for (kk in seq_along(NAMES)) {
[17:03:43.912]                   name <- added[[kk]]
[17:03:43.912]                   NAME <- NAMES[[kk]]
[17:03:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.912]                     next
[17:03:43.912]                   args[[name]] <- ""
[17:03:43.912]                 }
[17:03:43.912]                 NAMES <- toupper(removed)
[17:03:43.912]                 for (kk in seq_along(NAMES)) {
[17:03:43.912]                   name <- removed[[kk]]
[17:03:43.912]                   NAME <- NAMES[[kk]]
[17:03:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.912]                     next
[17:03:43.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.912]                 }
[17:03:43.912]                 if (length(args) > 0) 
[17:03:43.912]                   base::do.call(base::Sys.setenv, args = args)
[17:03:43.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:43.912]             }
[17:03:43.912]             else {
[17:03:43.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:43.912]             }
[17:03:43.912]             {
[17:03:43.912]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:43.912]                   0L) {
[17:03:43.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:43.912]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:43.912]                   base::options(opts)
[17:03:43.912]                 }
[17:03:43.912]                 {
[17:03:43.912]                   {
[17:03:43.912]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:43.912]                     NULL
[17:03:43.912]                   }
[17:03:43.912]                   options(future.plan = NULL)
[17:03:43.912]                   if (is.na(NA_character_)) 
[17:03:43.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:43.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:43.912]                     .init = FALSE)
[17:03:43.912]                 }
[17:03:43.912]             }
[17:03:43.912]         }
[17:03:43.912]     })
[17:03:43.912]     if (TRUE) {
[17:03:43.912]         base::sink(type = "output", split = FALSE)
[17:03:43.912]         if (TRUE) {
[17:03:43.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:43.912]         }
[17:03:43.912]         else {
[17:03:43.912]             ...future.result["stdout"] <- base::list(NULL)
[17:03:43.912]         }
[17:03:43.912]         base::close(...future.stdout)
[17:03:43.912]         ...future.stdout <- NULL
[17:03:43.912]     }
[17:03:43.912]     ...future.result$conditions <- ...future.conditions
[17:03:43.912]     ...future.result$finished <- base::Sys.time()
[17:03:43.912]     ...future.result
[17:03:43.912] }
[17:03:43.964] MultisessionFuture started
[17:03:43.965] - Launch lazy future ... done
[17:03:43.965] run() for ‘MultisessionFuture’ ... done
[17:03:43.965] getGlobalsAndPackages() ...
[17:03:43.965] Searching for globals...
[17:03:43.966] - globals found: [2] ‘list’, ‘stop’
[17:03:43.966] Searching for globals ... DONE
[17:03:43.966] Resolving globals: FALSE
[17:03:43.966] 
[17:03:43.966] 
[17:03:43.966] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[17:03:43.967] getGlobalsAndPackages() ...
[17:03:43.967] Searching for globals...
[17:03:43.968] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:43.968] Searching for globals ... DONE
[17:03:43.968] Resolving globals: FALSE
[17:03:43.968] 
[17:03:43.969] 
[17:03:43.969] getGlobalsAndPackages() ... DONE
[17:03:43.969] run() for ‘Future’ ...
[17:03:43.969] - state: ‘created’
[17:03:43.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:43.983] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:43.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:43.983]   - Field: ‘node’
[17:03:43.983]   - Field: ‘label’
[17:03:43.983]   - Field: ‘local’
[17:03:43.983]   - Field: ‘owner’
[17:03:43.983]   - Field: ‘envir’
[17:03:43.984]   - Field: ‘workers’
[17:03:43.984]   - Field: ‘packages’
[17:03:43.984]   - Field: ‘gc’
[17:03:43.984]   - Field: ‘conditions’
[17:03:43.984]   - Field: ‘persistent’
[17:03:43.984]   - Field: ‘expr’
[17:03:43.984]   - Field: ‘uuid’
[17:03:43.984]   - Field: ‘seed’
[17:03:43.984]   - Field: ‘version’
[17:03:43.984]   - Field: ‘result’
[17:03:43.984]   - Field: ‘asynchronous’
[17:03:43.985]   - Field: ‘calls’
[17:03:43.985]   - Field: ‘globals’
[17:03:43.985]   - Field: ‘stdout’
[17:03:43.985]   - Field: ‘earlySignal’
[17:03:43.985]   - Field: ‘lazy’
[17:03:43.985]   - Field: ‘state’
[17:03:43.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:43.985] - Launch lazy future ...
[17:03:43.985] Packages needed by the future expression (n = 0): <none>
[17:03:43.986] Packages needed by future strategies (n = 0): <none>
[17:03:43.986] {
[17:03:43.986]     {
[17:03:43.986]         {
[17:03:43.986]             ...future.startTime <- base::Sys.time()
[17:03:43.986]             {
[17:03:43.986]                 {
[17:03:43.986]                   {
[17:03:43.986]                     {
[17:03:43.986]                       base::local({
[17:03:43.986]                         has_future <- base::requireNamespace("future", 
[17:03:43.986]                           quietly = TRUE)
[17:03:43.986]                         if (has_future) {
[17:03:43.986]                           ns <- base::getNamespace("future")
[17:03:43.986]                           version <- ns[[".package"]][["version"]]
[17:03:43.986]                           if (is.null(version)) 
[17:03:43.986]                             version <- utils::packageVersion("future")
[17:03:43.986]                         }
[17:03:43.986]                         else {
[17:03:43.986]                           version <- NULL
[17:03:43.986]                         }
[17:03:43.986]                         if (!has_future || version < "1.8.0") {
[17:03:43.986]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:43.986]                             "", base::R.version$version.string), 
[17:03:43.986]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:43.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:43.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:43.986]                               "release", "version")], collapse = " "), 
[17:03:43.986]                             hostname = base::Sys.info()[["nodename"]])
[17:03:43.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:43.986]                             info)
[17:03:43.986]                           info <- base::paste(info, collapse = "; ")
[17:03:43.986]                           if (!has_future) {
[17:03:43.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:43.986]                               info)
[17:03:43.986]                           }
[17:03:43.986]                           else {
[17:03:43.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:43.986]                               info, version)
[17:03:43.986]                           }
[17:03:43.986]                           base::stop(msg)
[17:03:43.986]                         }
[17:03:43.986]                       })
[17:03:43.986]                     }
[17:03:43.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:43.986]                     base::options(mc.cores = 1L)
[17:03:43.986]                   }
[17:03:43.986]                   ...future.strategy.old <- future::plan("list")
[17:03:43.986]                   options(future.plan = NULL)
[17:03:43.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:43.986]                 }
[17:03:43.986]                 ...future.workdir <- getwd()
[17:03:43.986]             }
[17:03:43.986]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:43.986]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:43.986]         }
[17:03:43.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:43.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:43.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:43.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:43.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:43.986]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:43.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:43.986]             base::names(...future.oldOptions))
[17:03:43.986]     }
[17:03:43.986]     if (FALSE) {
[17:03:43.986]     }
[17:03:43.986]     else {
[17:03:43.986]         if (TRUE) {
[17:03:43.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:43.986]                 open = "w")
[17:03:43.986]         }
[17:03:43.986]         else {
[17:03:43.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:43.986]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:43.986]         }
[17:03:43.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:43.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:43.986]             base::sink(type = "output", split = FALSE)
[17:03:43.986]             base::close(...future.stdout)
[17:03:43.986]         }, add = TRUE)
[17:03:43.986]     }
[17:03:43.986]     ...future.frame <- base::sys.nframe()
[17:03:43.986]     ...future.conditions <- base::list()
[17:03:43.986]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:43.986]     if (FALSE) {
[17:03:43.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:43.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:43.986]     }
[17:03:43.986]     ...future.result <- base::tryCatch({
[17:03:43.986]         base::withCallingHandlers({
[17:03:43.986]             ...future.value <- base::withVisible(base::local({
[17:03:43.986]                 ...future.makeSendCondition <- base::local({
[17:03:43.986]                   sendCondition <- NULL
[17:03:43.986]                   function(frame = 1L) {
[17:03:43.986]                     if (is.function(sendCondition)) 
[17:03:43.986]                       return(sendCondition)
[17:03:43.986]                     ns <- getNamespace("parallel")
[17:03:43.986]                     if (exists("sendData", mode = "function", 
[17:03:43.986]                       envir = ns)) {
[17:03:43.986]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:43.986]                         envir = ns)
[17:03:43.986]                       envir <- sys.frame(frame)
[17:03:43.986]                       master <- NULL
[17:03:43.986]                       while (!identical(envir, .GlobalEnv) && 
[17:03:43.986]                         !identical(envir, emptyenv())) {
[17:03:43.986]                         if (exists("master", mode = "list", envir = envir, 
[17:03:43.986]                           inherits = FALSE)) {
[17:03:43.986]                           master <- get("master", mode = "list", 
[17:03:43.986]                             envir = envir, inherits = FALSE)
[17:03:43.986]                           if (inherits(master, c("SOCKnode", 
[17:03:43.986]                             "SOCK0node"))) {
[17:03:43.986]                             sendCondition <<- function(cond) {
[17:03:43.986]                               data <- list(type = "VALUE", value = cond, 
[17:03:43.986]                                 success = TRUE)
[17:03:43.986]                               parallel_sendData(master, data)
[17:03:43.986]                             }
[17:03:43.986]                             return(sendCondition)
[17:03:43.986]                           }
[17:03:43.986]                         }
[17:03:43.986]                         frame <- frame + 1L
[17:03:43.986]                         envir <- sys.frame(frame)
[17:03:43.986]                       }
[17:03:43.986]                     }
[17:03:43.986]                     sendCondition <<- function(cond) NULL
[17:03:43.986]                   }
[17:03:43.986]                 })
[17:03:43.986]                 withCallingHandlers({
[17:03:43.986]                   {
[17:03:43.986]                     Sys.sleep(0.5)
[17:03:43.986]                     list(a = 1, b = 42L)
[17:03:43.986]                   }
[17:03:43.986]                 }, immediateCondition = function(cond) {
[17:03:43.986]                   sendCondition <- ...future.makeSendCondition()
[17:03:43.986]                   sendCondition(cond)
[17:03:43.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.986]                   {
[17:03:43.986]                     inherits <- base::inherits
[17:03:43.986]                     invokeRestart <- base::invokeRestart
[17:03:43.986]                     is.null <- base::is.null
[17:03:43.986]                     muffled <- FALSE
[17:03:43.986]                     if (inherits(cond, "message")) {
[17:03:43.986]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:43.986]                       if (muffled) 
[17:03:43.986]                         invokeRestart("muffleMessage")
[17:03:43.986]                     }
[17:03:43.986]                     else if (inherits(cond, "warning")) {
[17:03:43.986]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:43.986]                       if (muffled) 
[17:03:43.986]                         invokeRestart("muffleWarning")
[17:03:43.986]                     }
[17:03:43.986]                     else if (inherits(cond, "condition")) {
[17:03:43.986]                       if (!is.null(pattern)) {
[17:03:43.986]                         computeRestarts <- base::computeRestarts
[17:03:43.986]                         grepl <- base::grepl
[17:03:43.986]                         restarts <- computeRestarts(cond)
[17:03:43.986]                         for (restart in restarts) {
[17:03:43.986]                           name <- restart$name
[17:03:43.986]                           if (is.null(name)) 
[17:03:43.986]                             next
[17:03:43.986]                           if (!grepl(pattern, name)) 
[17:03:43.986]                             next
[17:03:43.986]                           invokeRestart(restart)
[17:03:43.986]                           muffled <- TRUE
[17:03:43.986]                           break
[17:03:43.986]                         }
[17:03:43.986]                       }
[17:03:43.986]                     }
[17:03:43.986]                     invisible(muffled)
[17:03:43.986]                   }
[17:03:43.986]                   muffleCondition(cond)
[17:03:43.986]                 })
[17:03:43.986]             }))
[17:03:43.986]             future::FutureResult(value = ...future.value$value, 
[17:03:43.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.986]                   ...future.rng), globalenv = if (FALSE) 
[17:03:43.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:43.986]                     ...future.globalenv.names))
[17:03:43.986]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:43.986]         }, condition = base::local({
[17:03:43.986]             c <- base::c
[17:03:43.986]             inherits <- base::inherits
[17:03:43.986]             invokeRestart <- base::invokeRestart
[17:03:43.986]             length <- base::length
[17:03:43.986]             list <- base::list
[17:03:43.986]             seq.int <- base::seq.int
[17:03:43.986]             signalCondition <- base::signalCondition
[17:03:43.986]             sys.calls <- base::sys.calls
[17:03:43.986]             `[[` <- base::`[[`
[17:03:43.986]             `+` <- base::`+`
[17:03:43.986]             `<<-` <- base::`<<-`
[17:03:43.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:43.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:43.986]                   3L)]
[17:03:43.986]             }
[17:03:43.986]             function(cond) {
[17:03:43.986]                 is_error <- inherits(cond, "error")
[17:03:43.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:43.986]                   NULL)
[17:03:43.986]                 if (is_error) {
[17:03:43.986]                   sessionInformation <- function() {
[17:03:43.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:43.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:43.986]                       search = base::search(), system = base::Sys.info())
[17:03:43.986]                   }
[17:03:43.986]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:43.986]                     cond$call), session = sessionInformation(), 
[17:03:43.986]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:43.986]                   signalCondition(cond)
[17:03:43.986]                 }
[17:03:43.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:43.986]                 "immediateCondition"))) {
[17:03:43.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:43.986]                   ...future.conditions[[length(...future.conditions) + 
[17:03:43.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:43.986]                   if (TRUE && !signal) {
[17:03:43.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.986]                     {
[17:03:43.986]                       inherits <- base::inherits
[17:03:43.986]                       invokeRestart <- base::invokeRestart
[17:03:43.986]                       is.null <- base::is.null
[17:03:43.986]                       muffled <- FALSE
[17:03:43.986]                       if (inherits(cond, "message")) {
[17:03:43.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.986]                         if (muffled) 
[17:03:43.986]                           invokeRestart("muffleMessage")
[17:03:43.986]                       }
[17:03:43.986]                       else if (inherits(cond, "warning")) {
[17:03:43.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.986]                         if (muffled) 
[17:03:43.986]                           invokeRestart("muffleWarning")
[17:03:43.986]                       }
[17:03:43.986]                       else if (inherits(cond, "condition")) {
[17:03:43.986]                         if (!is.null(pattern)) {
[17:03:43.986]                           computeRestarts <- base::computeRestarts
[17:03:43.986]                           grepl <- base::grepl
[17:03:43.986]                           restarts <- computeRestarts(cond)
[17:03:43.986]                           for (restart in restarts) {
[17:03:43.986]                             name <- restart$name
[17:03:43.986]                             if (is.null(name)) 
[17:03:43.986]                               next
[17:03:43.986]                             if (!grepl(pattern, name)) 
[17:03:43.986]                               next
[17:03:43.986]                             invokeRestart(restart)
[17:03:43.986]                             muffled <- TRUE
[17:03:43.986]                             break
[17:03:43.986]                           }
[17:03:43.986]                         }
[17:03:43.986]                       }
[17:03:43.986]                       invisible(muffled)
[17:03:43.986]                     }
[17:03:43.986]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.986]                   }
[17:03:43.986]                 }
[17:03:43.986]                 else {
[17:03:43.986]                   if (TRUE) {
[17:03:43.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:43.986]                     {
[17:03:43.986]                       inherits <- base::inherits
[17:03:43.986]                       invokeRestart <- base::invokeRestart
[17:03:43.986]                       is.null <- base::is.null
[17:03:43.986]                       muffled <- FALSE
[17:03:43.986]                       if (inherits(cond, "message")) {
[17:03:43.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:43.986]                         if (muffled) 
[17:03:43.986]                           invokeRestart("muffleMessage")
[17:03:43.986]                       }
[17:03:43.986]                       else if (inherits(cond, "warning")) {
[17:03:43.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:43.986]                         if (muffled) 
[17:03:43.986]                           invokeRestart("muffleWarning")
[17:03:43.986]                       }
[17:03:43.986]                       else if (inherits(cond, "condition")) {
[17:03:43.986]                         if (!is.null(pattern)) {
[17:03:43.986]                           computeRestarts <- base::computeRestarts
[17:03:43.986]                           grepl <- base::grepl
[17:03:43.986]                           restarts <- computeRestarts(cond)
[17:03:43.986]                           for (restart in restarts) {
[17:03:43.986]                             name <- restart$name
[17:03:43.986]                             if (is.null(name)) 
[17:03:43.986]                               next
[17:03:43.986]                             if (!grepl(pattern, name)) 
[17:03:43.986]                               next
[17:03:43.986]                             invokeRestart(restart)
[17:03:43.986]                             muffled <- TRUE
[17:03:43.986]                             break
[17:03:43.986]                           }
[17:03:43.986]                         }
[17:03:43.986]                       }
[17:03:43.986]                       invisible(muffled)
[17:03:43.986]                     }
[17:03:43.986]                     muffleCondition(cond, pattern = "^muffle")
[17:03:43.986]                   }
[17:03:43.986]                 }
[17:03:43.986]             }
[17:03:43.986]         }))
[17:03:43.986]     }, error = function(ex) {
[17:03:43.986]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:43.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:43.986]                 ...future.rng), started = ...future.startTime, 
[17:03:43.986]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:43.986]             version = "1.8"), class = "FutureResult")
[17:03:43.986]     }, finally = {
[17:03:43.986]         if (!identical(...future.workdir, getwd())) 
[17:03:43.986]             setwd(...future.workdir)
[17:03:43.986]         {
[17:03:43.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:43.986]                 ...future.oldOptions$nwarnings <- NULL
[17:03:43.986]             }
[17:03:43.986]             base::options(...future.oldOptions)
[17:03:43.986]             if (.Platform$OS.type == "windows") {
[17:03:43.986]                 old_names <- names(...future.oldEnvVars)
[17:03:43.986]                 envs <- base::Sys.getenv()
[17:03:43.986]                 names <- names(envs)
[17:03:43.986]                 common <- intersect(names, old_names)
[17:03:43.986]                 added <- setdiff(names, old_names)
[17:03:43.986]                 removed <- setdiff(old_names, names)
[17:03:43.986]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:43.986]                   envs[common]]
[17:03:43.986]                 NAMES <- toupper(changed)
[17:03:43.986]                 args <- list()
[17:03:43.986]                 for (kk in seq_along(NAMES)) {
[17:03:43.986]                   name <- changed[[kk]]
[17:03:43.986]                   NAME <- NAMES[[kk]]
[17:03:43.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.986]                     next
[17:03:43.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.986]                 }
[17:03:43.986]                 NAMES <- toupper(added)
[17:03:43.986]                 for (kk in seq_along(NAMES)) {
[17:03:43.986]                   name <- added[[kk]]
[17:03:43.986]                   NAME <- NAMES[[kk]]
[17:03:43.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.986]                     next
[17:03:43.986]                   args[[name]] <- ""
[17:03:43.986]                 }
[17:03:43.986]                 NAMES <- toupper(removed)
[17:03:43.986]                 for (kk in seq_along(NAMES)) {
[17:03:43.986]                   name <- removed[[kk]]
[17:03:43.986]                   NAME <- NAMES[[kk]]
[17:03:43.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:43.986]                     next
[17:03:43.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:43.986]                 }
[17:03:43.986]                 if (length(args) > 0) 
[17:03:43.986]                   base::do.call(base::Sys.setenv, args = args)
[17:03:43.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:43.986]             }
[17:03:43.986]             else {
[17:03:43.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:43.986]             }
[17:03:43.986]             {
[17:03:43.986]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:43.986]                   0L) {
[17:03:43.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:43.986]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:43.986]                   base::options(opts)
[17:03:43.986]                 }
[17:03:43.986]                 {
[17:03:43.986]                   {
[17:03:43.986]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:43.986]                     NULL
[17:03:43.986]                   }
[17:03:43.986]                   options(future.plan = NULL)
[17:03:43.986]                   if (is.na(NA_character_)) 
[17:03:43.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:43.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:43.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:43.986]                     .init = FALSE)
[17:03:43.986]                 }
[17:03:43.986]             }
[17:03:43.986]         }
[17:03:43.986]     })
[17:03:43.986]     if (TRUE) {
[17:03:43.986]         base::sink(type = "output", split = FALSE)
[17:03:43.986]         if (TRUE) {
[17:03:43.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:43.986]         }
[17:03:43.986]         else {
[17:03:43.986]             ...future.result["stdout"] <- base::list(NULL)
[17:03:43.986]         }
[17:03:43.986]         base::close(...future.stdout)
[17:03:43.986]         ...future.stdout <- NULL
[17:03:43.986]     }
[17:03:43.986]     ...future.result$conditions <- ...future.conditions
[17:03:43.986]     ...future.result$finished <- base::Sys.time()
[17:03:43.986]     ...future.result
[17:03:43.986] }
[17:03:43.988] Poll #1 (0): usedNodes() = 2, workers = 2
[17:03:44.009] receiveMessageFromWorker() for ClusterFuture ...
[17:03:44.009] - Validating connection of MultisessionFuture
[17:03:44.010] - received message: FutureResult
[17:03:44.010] - Received FutureResult
[17:03:44.010] - Erased future from FutureRegistry
[17:03:44.010] result() for ClusterFuture ...
[17:03:44.010] - result already collected: FutureResult
[17:03:44.010] result() for ClusterFuture ... done
[17:03:44.011] signalConditions() ...
[17:03:44.011]  - include = ‘immediateCondition’
[17:03:44.011]  - exclude = 
[17:03:44.011]  - resignal = FALSE
[17:03:44.011]  - Number of conditions: 1
[17:03:44.011] signalConditions() ... done
[17:03:44.011] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:44.011] result() for ClusterFuture ...
[17:03:44.011] - result already collected: FutureResult
[17:03:44.011] result() for ClusterFuture ... done
[17:03:44.011] result() for ClusterFuture ...
[17:03:44.012] - result already collected: FutureResult
[17:03:44.012] result() for ClusterFuture ... done
[17:03:44.012] signalConditions() ...
[17:03:44.012]  - include = ‘immediateCondition’
[17:03:44.012]  - exclude = 
[17:03:44.012]  - resignal = FALSE
[17:03:44.012]  - Number of conditions: 1
[17:03:44.012] signalConditions() ... done
[17:03:44.013] MultisessionFuture started
[17:03:44.013] - Launch lazy future ... done
[17:03:44.013] run() for ‘MultisessionFuture’ ... done
[17:03:44.516] receiveMessageFromWorker() for ClusterFuture ...
[17:03:44.516] - Validating connection of MultisessionFuture
[17:03:44.517] - received message: FutureResult
[17:03:44.517] - Received FutureResult
[17:03:44.517] - Erased future from FutureRegistry
[17:03:44.517] result() for ClusterFuture ...
[17:03:44.517] - result already collected: FutureResult
[17:03:44.517] result() for ClusterFuture ... done
[17:03:44.517] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:44.517] A MultisessionFuture was resolved (result was not collected)
[17:03:44.517] getGlobalsAndPackages() ...
[17:03:44.518] Searching for globals...
[17:03:44.519] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:44.519] Searching for globals ... DONE
[17:03:44.519] Resolving globals: FALSE
[17:03:44.519] 
[17:03:44.519] 
[17:03:44.519] getGlobalsAndPackages() ... DONE
[17:03:44.520] run() for ‘Future’ ...
[17:03:44.520] - state: ‘created’
[17:03:44.520] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:44.534] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:44.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:44.534]   - Field: ‘node’
[17:03:44.534]   - Field: ‘label’
[17:03:44.534]   - Field: ‘local’
[17:03:44.534]   - Field: ‘owner’
[17:03:44.534]   - Field: ‘envir’
[17:03:44.534]   - Field: ‘workers’
[17:03:44.534]   - Field: ‘packages’
[17:03:44.535]   - Field: ‘gc’
[17:03:44.535]   - Field: ‘conditions’
[17:03:44.535]   - Field: ‘persistent’
[17:03:44.535]   - Field: ‘expr’
[17:03:44.535]   - Field: ‘uuid’
[17:03:44.535]   - Field: ‘seed’
[17:03:44.535]   - Field: ‘version’
[17:03:44.535]   - Field: ‘result’
[17:03:44.535]   - Field: ‘asynchronous’
[17:03:44.535]   - Field: ‘calls’
[17:03:44.535]   - Field: ‘globals’
[17:03:44.536]   - Field: ‘stdout’
[17:03:44.536]   - Field: ‘earlySignal’
[17:03:44.536]   - Field: ‘lazy’
[17:03:44.536]   - Field: ‘state’
[17:03:44.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:44.536] - Launch lazy future ...
[17:03:44.536] Packages needed by the future expression (n = 0): <none>
[17:03:44.536] Packages needed by future strategies (n = 0): <none>
[17:03:44.537] {
[17:03:44.537]     {
[17:03:44.537]         {
[17:03:44.537]             ...future.startTime <- base::Sys.time()
[17:03:44.537]             {
[17:03:44.537]                 {
[17:03:44.537]                   {
[17:03:44.537]                     {
[17:03:44.537]                       base::local({
[17:03:44.537]                         has_future <- base::requireNamespace("future", 
[17:03:44.537]                           quietly = TRUE)
[17:03:44.537]                         if (has_future) {
[17:03:44.537]                           ns <- base::getNamespace("future")
[17:03:44.537]                           version <- ns[[".package"]][["version"]]
[17:03:44.537]                           if (is.null(version)) 
[17:03:44.537]                             version <- utils::packageVersion("future")
[17:03:44.537]                         }
[17:03:44.537]                         else {
[17:03:44.537]                           version <- NULL
[17:03:44.537]                         }
[17:03:44.537]                         if (!has_future || version < "1.8.0") {
[17:03:44.537]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:44.537]                             "", base::R.version$version.string), 
[17:03:44.537]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:44.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:44.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:44.537]                               "release", "version")], collapse = " "), 
[17:03:44.537]                             hostname = base::Sys.info()[["nodename"]])
[17:03:44.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:44.537]                             info)
[17:03:44.537]                           info <- base::paste(info, collapse = "; ")
[17:03:44.537]                           if (!has_future) {
[17:03:44.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:44.537]                               info)
[17:03:44.537]                           }
[17:03:44.537]                           else {
[17:03:44.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:44.537]                               info, version)
[17:03:44.537]                           }
[17:03:44.537]                           base::stop(msg)
[17:03:44.537]                         }
[17:03:44.537]                       })
[17:03:44.537]                     }
[17:03:44.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:44.537]                     base::options(mc.cores = 1L)
[17:03:44.537]                   }
[17:03:44.537]                   ...future.strategy.old <- future::plan("list")
[17:03:44.537]                   options(future.plan = NULL)
[17:03:44.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:44.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:44.537]                 }
[17:03:44.537]                 ...future.workdir <- getwd()
[17:03:44.537]             }
[17:03:44.537]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:44.537]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:44.537]         }
[17:03:44.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:44.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:44.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:44.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:44.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:44.537]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:44.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:44.537]             base::names(...future.oldOptions))
[17:03:44.537]     }
[17:03:44.537]     if (FALSE) {
[17:03:44.537]     }
[17:03:44.537]     else {
[17:03:44.537]         if (TRUE) {
[17:03:44.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:44.537]                 open = "w")
[17:03:44.537]         }
[17:03:44.537]         else {
[17:03:44.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:44.537]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:44.537]         }
[17:03:44.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:44.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:44.537]             base::sink(type = "output", split = FALSE)
[17:03:44.537]             base::close(...future.stdout)
[17:03:44.537]         }, add = TRUE)
[17:03:44.537]     }
[17:03:44.537]     ...future.frame <- base::sys.nframe()
[17:03:44.537]     ...future.conditions <- base::list()
[17:03:44.537]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:44.537]     if (FALSE) {
[17:03:44.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:44.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:44.537]     }
[17:03:44.537]     ...future.result <- base::tryCatch({
[17:03:44.537]         base::withCallingHandlers({
[17:03:44.537]             ...future.value <- base::withVisible(base::local({
[17:03:44.537]                 ...future.makeSendCondition <- base::local({
[17:03:44.537]                   sendCondition <- NULL
[17:03:44.537]                   function(frame = 1L) {
[17:03:44.537]                     if (is.function(sendCondition)) 
[17:03:44.537]                       return(sendCondition)
[17:03:44.537]                     ns <- getNamespace("parallel")
[17:03:44.537]                     if (exists("sendData", mode = "function", 
[17:03:44.537]                       envir = ns)) {
[17:03:44.537]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:44.537]                         envir = ns)
[17:03:44.537]                       envir <- sys.frame(frame)
[17:03:44.537]                       master <- NULL
[17:03:44.537]                       while (!identical(envir, .GlobalEnv) && 
[17:03:44.537]                         !identical(envir, emptyenv())) {
[17:03:44.537]                         if (exists("master", mode = "list", envir = envir, 
[17:03:44.537]                           inherits = FALSE)) {
[17:03:44.537]                           master <- get("master", mode = "list", 
[17:03:44.537]                             envir = envir, inherits = FALSE)
[17:03:44.537]                           if (inherits(master, c("SOCKnode", 
[17:03:44.537]                             "SOCK0node"))) {
[17:03:44.537]                             sendCondition <<- function(cond) {
[17:03:44.537]                               data <- list(type = "VALUE", value = cond, 
[17:03:44.537]                                 success = TRUE)
[17:03:44.537]                               parallel_sendData(master, data)
[17:03:44.537]                             }
[17:03:44.537]                             return(sendCondition)
[17:03:44.537]                           }
[17:03:44.537]                         }
[17:03:44.537]                         frame <- frame + 1L
[17:03:44.537]                         envir <- sys.frame(frame)
[17:03:44.537]                       }
[17:03:44.537]                     }
[17:03:44.537]                     sendCondition <<- function(cond) NULL
[17:03:44.537]                   }
[17:03:44.537]                 })
[17:03:44.537]                 withCallingHandlers({
[17:03:44.537]                   {
[17:03:44.537]                     Sys.sleep(0.5)
[17:03:44.537]                     list(a = 1, b = 42L)
[17:03:44.537]                   }
[17:03:44.537]                 }, immediateCondition = function(cond) {
[17:03:44.537]                   sendCondition <- ...future.makeSendCondition()
[17:03:44.537]                   sendCondition(cond)
[17:03:44.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:44.537]                   {
[17:03:44.537]                     inherits <- base::inherits
[17:03:44.537]                     invokeRestart <- base::invokeRestart
[17:03:44.537]                     is.null <- base::is.null
[17:03:44.537]                     muffled <- FALSE
[17:03:44.537]                     if (inherits(cond, "message")) {
[17:03:44.537]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:44.537]                       if (muffled) 
[17:03:44.537]                         invokeRestart("muffleMessage")
[17:03:44.537]                     }
[17:03:44.537]                     else if (inherits(cond, "warning")) {
[17:03:44.537]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:44.537]                       if (muffled) 
[17:03:44.537]                         invokeRestart("muffleWarning")
[17:03:44.537]                     }
[17:03:44.537]                     else if (inherits(cond, "condition")) {
[17:03:44.537]                       if (!is.null(pattern)) {
[17:03:44.537]                         computeRestarts <- base::computeRestarts
[17:03:44.537]                         grepl <- base::grepl
[17:03:44.537]                         restarts <- computeRestarts(cond)
[17:03:44.537]                         for (restart in restarts) {
[17:03:44.537]                           name <- restart$name
[17:03:44.537]                           if (is.null(name)) 
[17:03:44.537]                             next
[17:03:44.537]                           if (!grepl(pattern, name)) 
[17:03:44.537]                             next
[17:03:44.537]                           invokeRestart(restart)
[17:03:44.537]                           muffled <- TRUE
[17:03:44.537]                           break
[17:03:44.537]                         }
[17:03:44.537]                       }
[17:03:44.537]                     }
[17:03:44.537]                     invisible(muffled)
[17:03:44.537]                   }
[17:03:44.537]                   muffleCondition(cond)
[17:03:44.537]                 })
[17:03:44.537]             }))
[17:03:44.537]             future::FutureResult(value = ...future.value$value, 
[17:03:44.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:44.537]                   ...future.rng), globalenv = if (FALSE) 
[17:03:44.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:44.537]                     ...future.globalenv.names))
[17:03:44.537]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:44.537]         }, condition = base::local({
[17:03:44.537]             c <- base::c
[17:03:44.537]             inherits <- base::inherits
[17:03:44.537]             invokeRestart <- base::invokeRestart
[17:03:44.537]             length <- base::length
[17:03:44.537]             list <- base::list
[17:03:44.537]             seq.int <- base::seq.int
[17:03:44.537]             signalCondition <- base::signalCondition
[17:03:44.537]             sys.calls <- base::sys.calls
[17:03:44.537]             `[[` <- base::`[[`
[17:03:44.537]             `+` <- base::`+`
[17:03:44.537]             `<<-` <- base::`<<-`
[17:03:44.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:44.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:44.537]                   3L)]
[17:03:44.537]             }
[17:03:44.537]             function(cond) {
[17:03:44.537]                 is_error <- inherits(cond, "error")
[17:03:44.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:44.537]                   NULL)
[17:03:44.537]                 if (is_error) {
[17:03:44.537]                   sessionInformation <- function() {
[17:03:44.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:44.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:44.537]                       search = base::search(), system = base::Sys.info())
[17:03:44.537]                   }
[17:03:44.537]                   ...future.conditions[[length(...future.conditions) + 
[17:03:44.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:44.537]                     cond$call), session = sessionInformation(), 
[17:03:44.537]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:44.537]                   signalCondition(cond)
[17:03:44.537]                 }
[17:03:44.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:44.537]                 "immediateCondition"))) {
[17:03:44.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:44.537]                   ...future.conditions[[length(...future.conditions) + 
[17:03:44.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:44.537]                   if (TRUE && !signal) {
[17:03:44.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:44.537]                     {
[17:03:44.537]                       inherits <- base::inherits
[17:03:44.537]                       invokeRestart <- base::invokeRestart
[17:03:44.537]                       is.null <- base::is.null
[17:03:44.537]                       muffled <- FALSE
[17:03:44.537]                       if (inherits(cond, "message")) {
[17:03:44.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:44.537]                         if (muffled) 
[17:03:44.537]                           invokeRestart("muffleMessage")
[17:03:44.537]                       }
[17:03:44.537]                       else if (inherits(cond, "warning")) {
[17:03:44.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:44.537]                         if (muffled) 
[17:03:44.537]                           invokeRestart("muffleWarning")
[17:03:44.537]                       }
[17:03:44.537]                       else if (inherits(cond, "condition")) {
[17:03:44.537]                         if (!is.null(pattern)) {
[17:03:44.537]                           computeRestarts <- base::computeRestarts
[17:03:44.537]                           grepl <- base::grepl
[17:03:44.537]                           restarts <- computeRestarts(cond)
[17:03:44.537]                           for (restart in restarts) {
[17:03:44.537]                             name <- restart$name
[17:03:44.537]                             if (is.null(name)) 
[17:03:44.537]                               next
[17:03:44.537]                             if (!grepl(pattern, name)) 
[17:03:44.537]                               next
[17:03:44.537]                             invokeRestart(restart)
[17:03:44.537]                             muffled <- TRUE
[17:03:44.537]                             break
[17:03:44.537]                           }
[17:03:44.537]                         }
[17:03:44.537]                       }
[17:03:44.537]                       invisible(muffled)
[17:03:44.537]                     }
[17:03:44.537]                     muffleCondition(cond, pattern = "^muffle")
[17:03:44.537]                   }
[17:03:44.537]                 }
[17:03:44.537]                 else {
[17:03:44.537]                   if (TRUE) {
[17:03:44.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:44.537]                     {
[17:03:44.537]                       inherits <- base::inherits
[17:03:44.537]                       invokeRestart <- base::invokeRestart
[17:03:44.537]                       is.null <- base::is.null
[17:03:44.537]                       muffled <- FALSE
[17:03:44.537]                       if (inherits(cond, "message")) {
[17:03:44.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:44.537]                         if (muffled) 
[17:03:44.537]                           invokeRestart("muffleMessage")
[17:03:44.537]                       }
[17:03:44.537]                       else if (inherits(cond, "warning")) {
[17:03:44.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:44.537]                         if (muffled) 
[17:03:44.537]                           invokeRestart("muffleWarning")
[17:03:44.537]                       }
[17:03:44.537]                       else if (inherits(cond, "condition")) {
[17:03:44.537]                         if (!is.null(pattern)) {
[17:03:44.537]                           computeRestarts <- base::computeRestarts
[17:03:44.537]                           grepl <- base::grepl
[17:03:44.537]                           restarts <- computeRestarts(cond)
[17:03:44.537]                           for (restart in restarts) {
[17:03:44.537]                             name <- restart$name
[17:03:44.537]                             if (is.null(name)) 
[17:03:44.537]                               next
[17:03:44.537]                             if (!grepl(pattern, name)) 
[17:03:44.537]                               next
[17:03:44.537]                             invokeRestart(restart)
[17:03:44.537]                             muffled <- TRUE
[17:03:44.537]                             break
[17:03:44.537]                           }
[17:03:44.537]                         }
[17:03:44.537]                       }
[17:03:44.537]                       invisible(muffled)
[17:03:44.537]                     }
[17:03:44.537]                     muffleCondition(cond, pattern = "^muffle")
[17:03:44.537]                   }
[17:03:44.537]                 }
[17:03:44.537]             }
[17:03:44.537]         }))
[17:03:44.537]     }, error = function(ex) {
[17:03:44.537]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:44.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:44.537]                 ...future.rng), started = ...future.startTime, 
[17:03:44.537]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:44.537]             version = "1.8"), class = "FutureResult")
[17:03:44.537]     }, finally = {
[17:03:44.537]         if (!identical(...future.workdir, getwd())) 
[17:03:44.537]             setwd(...future.workdir)
[17:03:44.537]         {
[17:03:44.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:44.537]                 ...future.oldOptions$nwarnings <- NULL
[17:03:44.537]             }
[17:03:44.537]             base::options(...future.oldOptions)
[17:03:44.537]             if (.Platform$OS.type == "windows") {
[17:03:44.537]                 old_names <- names(...future.oldEnvVars)
[17:03:44.537]                 envs <- base::Sys.getenv()
[17:03:44.537]                 names <- names(envs)
[17:03:44.537]                 common <- intersect(names, old_names)
[17:03:44.537]                 added <- setdiff(names, old_names)
[17:03:44.537]                 removed <- setdiff(old_names, names)
[17:03:44.537]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:44.537]                   envs[common]]
[17:03:44.537]                 NAMES <- toupper(changed)
[17:03:44.537]                 args <- list()
[17:03:44.537]                 for (kk in seq_along(NAMES)) {
[17:03:44.537]                   name <- changed[[kk]]
[17:03:44.537]                   NAME <- NAMES[[kk]]
[17:03:44.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:44.537]                     next
[17:03:44.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:44.537]                 }
[17:03:44.537]                 NAMES <- toupper(added)
[17:03:44.537]                 for (kk in seq_along(NAMES)) {
[17:03:44.537]                   name <- added[[kk]]
[17:03:44.537]                   NAME <- NAMES[[kk]]
[17:03:44.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:44.537]                     next
[17:03:44.537]                   args[[name]] <- ""
[17:03:44.537]                 }
[17:03:44.537]                 NAMES <- toupper(removed)
[17:03:44.537]                 for (kk in seq_along(NAMES)) {
[17:03:44.537]                   name <- removed[[kk]]
[17:03:44.537]                   NAME <- NAMES[[kk]]
[17:03:44.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:44.537]                     next
[17:03:44.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:44.537]                 }
[17:03:44.537]                 if (length(args) > 0) 
[17:03:44.537]                   base::do.call(base::Sys.setenv, args = args)
[17:03:44.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:44.537]             }
[17:03:44.537]             else {
[17:03:44.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:44.537]             }
[17:03:44.537]             {
[17:03:44.537]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:44.537]                   0L) {
[17:03:44.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:44.537]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:44.537]                   base::options(opts)
[17:03:44.537]                 }
[17:03:44.537]                 {
[17:03:44.537]                   {
[17:03:44.537]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:44.537]                     NULL
[17:03:44.537]                   }
[17:03:44.537]                   options(future.plan = NULL)
[17:03:44.537]                   if (is.na(NA_character_)) 
[17:03:44.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:44.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:44.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:44.537]                     .init = FALSE)
[17:03:44.537]                 }
[17:03:44.537]             }
[17:03:44.537]         }
[17:03:44.537]     })
[17:03:44.537]     if (TRUE) {
[17:03:44.537]         base::sink(type = "output", split = FALSE)
[17:03:44.537]         if (TRUE) {
[17:03:44.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:44.537]         }
[17:03:44.537]         else {
[17:03:44.537]             ...future.result["stdout"] <- base::list(NULL)
[17:03:44.537]         }
[17:03:44.537]         base::close(...future.stdout)
[17:03:44.537]         ...future.stdout <- NULL
[17:03:44.537]     }
[17:03:44.537]     ...future.result$conditions <- ...future.conditions
[17:03:44.537]     ...future.result$finished <- base::Sys.time()
[17:03:44.537]     ...future.result
[17:03:44.537] }
[17:03:44.540] MultisessionFuture started
[17:03:44.540] - Launch lazy future ... done
[17:03:44.540] run() for ‘MultisessionFuture’ ... done
[17:03:45.046] receiveMessageFromWorker() for ClusterFuture ...
[17:03:45.046] - Validating connection of MultisessionFuture
[17:03:45.046] - received message: FutureResult
[17:03:45.046] - Received FutureResult
[17:03:45.046] - Erased future from FutureRegistry
[17:03:45.046] result() for ClusterFuture ...
[17:03:45.047] - result already collected: FutureResult
[17:03:45.047] result() for ClusterFuture ... done
[17:03:45.047] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:45.047] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:03:45.047] getGlobalsAndPackages() ...
[17:03:45.047] Searching for globals...
[17:03:45.048] - globals found: [2] ‘list’, ‘stop’
[17:03:45.048] Searching for globals ... DONE
[17:03:45.048] Resolving globals: FALSE
[17:03:45.048] 
[17:03:45.048] 
[17:03:45.049] getGlobalsAndPackages() ... DONE
[17:03:45.049] run() for ‘Future’ ...
[17:03:45.049] - state: ‘created’
[17:03:45.049] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:45.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:45.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:45.063]   - Field: ‘node’
[17:03:45.063]   - Field: ‘label’
[17:03:45.063]   - Field: ‘local’
[17:03:45.063]   - Field: ‘owner’
[17:03:45.064]   - Field: ‘envir’
[17:03:45.064]   - Field: ‘workers’
[17:03:45.064]   - Field: ‘packages’
[17:03:45.064]   - Field: ‘gc’
[17:03:45.064]   - Field: ‘conditions’
[17:03:45.064]   - Field: ‘persistent’
[17:03:45.064]   - Field: ‘expr’
[17:03:45.064]   - Field: ‘uuid’
[17:03:45.064]   - Field: ‘seed’
[17:03:45.064]   - Field: ‘version’
[17:03:45.064]   - Field: ‘result’
[17:03:45.064]   - Field: ‘asynchronous’
[17:03:45.065]   - Field: ‘calls’
[17:03:45.065]   - Field: ‘globals’
[17:03:45.065]   - Field: ‘stdout’
[17:03:45.065]   - Field: ‘earlySignal’
[17:03:45.065]   - Field: ‘lazy’
[17:03:45.065]   - Field: ‘state’
[17:03:45.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:45.065] - Launch lazy future ...
[17:03:45.065] Packages needed by the future expression (n = 0): <none>
[17:03:45.066] Packages needed by future strategies (n = 0): <none>
[17:03:45.066] {
[17:03:45.066]     {
[17:03:45.066]         {
[17:03:45.066]             ...future.startTime <- base::Sys.time()
[17:03:45.066]             {
[17:03:45.066]                 {
[17:03:45.066]                   {
[17:03:45.066]                     {
[17:03:45.066]                       base::local({
[17:03:45.066]                         has_future <- base::requireNamespace("future", 
[17:03:45.066]                           quietly = TRUE)
[17:03:45.066]                         if (has_future) {
[17:03:45.066]                           ns <- base::getNamespace("future")
[17:03:45.066]                           version <- ns[[".package"]][["version"]]
[17:03:45.066]                           if (is.null(version)) 
[17:03:45.066]                             version <- utils::packageVersion("future")
[17:03:45.066]                         }
[17:03:45.066]                         else {
[17:03:45.066]                           version <- NULL
[17:03:45.066]                         }
[17:03:45.066]                         if (!has_future || version < "1.8.0") {
[17:03:45.066]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:45.066]                             "", base::R.version$version.string), 
[17:03:45.066]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:45.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:45.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:45.066]                               "release", "version")], collapse = " "), 
[17:03:45.066]                             hostname = base::Sys.info()[["nodename"]])
[17:03:45.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:45.066]                             info)
[17:03:45.066]                           info <- base::paste(info, collapse = "; ")
[17:03:45.066]                           if (!has_future) {
[17:03:45.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:45.066]                               info)
[17:03:45.066]                           }
[17:03:45.066]                           else {
[17:03:45.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:45.066]                               info, version)
[17:03:45.066]                           }
[17:03:45.066]                           base::stop(msg)
[17:03:45.066]                         }
[17:03:45.066]                       })
[17:03:45.066]                     }
[17:03:45.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:45.066]                     base::options(mc.cores = 1L)
[17:03:45.066]                   }
[17:03:45.066]                   ...future.strategy.old <- future::plan("list")
[17:03:45.066]                   options(future.plan = NULL)
[17:03:45.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:45.066]                 }
[17:03:45.066]                 ...future.workdir <- getwd()
[17:03:45.066]             }
[17:03:45.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:45.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:45.066]         }
[17:03:45.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:45.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:45.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:45.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:45.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:45.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:45.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:45.066]             base::names(...future.oldOptions))
[17:03:45.066]     }
[17:03:45.066]     if (FALSE) {
[17:03:45.066]     }
[17:03:45.066]     else {
[17:03:45.066]         if (TRUE) {
[17:03:45.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:45.066]                 open = "w")
[17:03:45.066]         }
[17:03:45.066]         else {
[17:03:45.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:45.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:45.066]         }
[17:03:45.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:45.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:45.066]             base::sink(type = "output", split = FALSE)
[17:03:45.066]             base::close(...future.stdout)
[17:03:45.066]         }, add = TRUE)
[17:03:45.066]     }
[17:03:45.066]     ...future.frame <- base::sys.nframe()
[17:03:45.066]     ...future.conditions <- base::list()
[17:03:45.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:45.066]     if (FALSE) {
[17:03:45.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:45.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:45.066]     }
[17:03:45.066]     ...future.result <- base::tryCatch({
[17:03:45.066]         base::withCallingHandlers({
[17:03:45.066]             ...future.value <- base::withVisible(base::local({
[17:03:45.066]                 ...future.makeSendCondition <- base::local({
[17:03:45.066]                   sendCondition <- NULL
[17:03:45.066]                   function(frame = 1L) {
[17:03:45.066]                     if (is.function(sendCondition)) 
[17:03:45.066]                       return(sendCondition)
[17:03:45.066]                     ns <- getNamespace("parallel")
[17:03:45.066]                     if (exists("sendData", mode = "function", 
[17:03:45.066]                       envir = ns)) {
[17:03:45.066]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:45.066]                         envir = ns)
[17:03:45.066]                       envir <- sys.frame(frame)
[17:03:45.066]                       master <- NULL
[17:03:45.066]                       while (!identical(envir, .GlobalEnv) && 
[17:03:45.066]                         !identical(envir, emptyenv())) {
[17:03:45.066]                         if (exists("master", mode = "list", envir = envir, 
[17:03:45.066]                           inherits = FALSE)) {
[17:03:45.066]                           master <- get("master", mode = "list", 
[17:03:45.066]                             envir = envir, inherits = FALSE)
[17:03:45.066]                           if (inherits(master, c("SOCKnode", 
[17:03:45.066]                             "SOCK0node"))) {
[17:03:45.066]                             sendCondition <<- function(cond) {
[17:03:45.066]                               data <- list(type = "VALUE", value = cond, 
[17:03:45.066]                                 success = TRUE)
[17:03:45.066]                               parallel_sendData(master, data)
[17:03:45.066]                             }
[17:03:45.066]                             return(sendCondition)
[17:03:45.066]                           }
[17:03:45.066]                         }
[17:03:45.066]                         frame <- frame + 1L
[17:03:45.066]                         envir <- sys.frame(frame)
[17:03:45.066]                       }
[17:03:45.066]                     }
[17:03:45.066]                     sendCondition <<- function(cond) NULL
[17:03:45.066]                   }
[17:03:45.066]                 })
[17:03:45.066]                 withCallingHandlers({
[17:03:45.066]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:45.066]                 }, immediateCondition = function(cond) {
[17:03:45.066]                   sendCondition <- ...future.makeSendCondition()
[17:03:45.066]                   sendCondition(cond)
[17:03:45.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.066]                   {
[17:03:45.066]                     inherits <- base::inherits
[17:03:45.066]                     invokeRestart <- base::invokeRestart
[17:03:45.066]                     is.null <- base::is.null
[17:03:45.066]                     muffled <- FALSE
[17:03:45.066]                     if (inherits(cond, "message")) {
[17:03:45.066]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:45.066]                       if (muffled) 
[17:03:45.066]                         invokeRestart("muffleMessage")
[17:03:45.066]                     }
[17:03:45.066]                     else if (inherits(cond, "warning")) {
[17:03:45.066]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:45.066]                       if (muffled) 
[17:03:45.066]                         invokeRestart("muffleWarning")
[17:03:45.066]                     }
[17:03:45.066]                     else if (inherits(cond, "condition")) {
[17:03:45.066]                       if (!is.null(pattern)) {
[17:03:45.066]                         computeRestarts <- base::computeRestarts
[17:03:45.066]                         grepl <- base::grepl
[17:03:45.066]                         restarts <- computeRestarts(cond)
[17:03:45.066]                         for (restart in restarts) {
[17:03:45.066]                           name <- restart$name
[17:03:45.066]                           if (is.null(name)) 
[17:03:45.066]                             next
[17:03:45.066]                           if (!grepl(pattern, name)) 
[17:03:45.066]                             next
[17:03:45.066]                           invokeRestart(restart)
[17:03:45.066]                           muffled <- TRUE
[17:03:45.066]                           break
[17:03:45.066]                         }
[17:03:45.066]                       }
[17:03:45.066]                     }
[17:03:45.066]                     invisible(muffled)
[17:03:45.066]                   }
[17:03:45.066]                   muffleCondition(cond)
[17:03:45.066]                 })
[17:03:45.066]             }))
[17:03:45.066]             future::FutureResult(value = ...future.value$value, 
[17:03:45.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.066]                   ...future.rng), globalenv = if (FALSE) 
[17:03:45.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:45.066]                     ...future.globalenv.names))
[17:03:45.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:45.066]         }, condition = base::local({
[17:03:45.066]             c <- base::c
[17:03:45.066]             inherits <- base::inherits
[17:03:45.066]             invokeRestart <- base::invokeRestart
[17:03:45.066]             length <- base::length
[17:03:45.066]             list <- base::list
[17:03:45.066]             seq.int <- base::seq.int
[17:03:45.066]             signalCondition <- base::signalCondition
[17:03:45.066]             sys.calls <- base::sys.calls
[17:03:45.066]             `[[` <- base::`[[`
[17:03:45.066]             `+` <- base::`+`
[17:03:45.066]             `<<-` <- base::`<<-`
[17:03:45.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:45.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:45.066]                   3L)]
[17:03:45.066]             }
[17:03:45.066]             function(cond) {
[17:03:45.066]                 is_error <- inherits(cond, "error")
[17:03:45.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:45.066]                   NULL)
[17:03:45.066]                 if (is_error) {
[17:03:45.066]                   sessionInformation <- function() {
[17:03:45.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:45.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:45.066]                       search = base::search(), system = base::Sys.info())
[17:03:45.066]                   }
[17:03:45.066]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:45.066]                     cond$call), session = sessionInformation(), 
[17:03:45.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:45.066]                   signalCondition(cond)
[17:03:45.066]                 }
[17:03:45.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:45.066]                 "immediateCondition"))) {
[17:03:45.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:45.066]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:45.066]                   if (TRUE && !signal) {
[17:03:45.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.066]                     {
[17:03:45.066]                       inherits <- base::inherits
[17:03:45.066]                       invokeRestart <- base::invokeRestart
[17:03:45.066]                       is.null <- base::is.null
[17:03:45.066]                       muffled <- FALSE
[17:03:45.066]                       if (inherits(cond, "message")) {
[17:03:45.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.066]                         if (muffled) 
[17:03:45.066]                           invokeRestart("muffleMessage")
[17:03:45.066]                       }
[17:03:45.066]                       else if (inherits(cond, "warning")) {
[17:03:45.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.066]                         if (muffled) 
[17:03:45.066]                           invokeRestart("muffleWarning")
[17:03:45.066]                       }
[17:03:45.066]                       else if (inherits(cond, "condition")) {
[17:03:45.066]                         if (!is.null(pattern)) {
[17:03:45.066]                           computeRestarts <- base::computeRestarts
[17:03:45.066]                           grepl <- base::grepl
[17:03:45.066]                           restarts <- computeRestarts(cond)
[17:03:45.066]                           for (restart in restarts) {
[17:03:45.066]                             name <- restart$name
[17:03:45.066]                             if (is.null(name)) 
[17:03:45.066]                               next
[17:03:45.066]                             if (!grepl(pattern, name)) 
[17:03:45.066]                               next
[17:03:45.066]                             invokeRestart(restart)
[17:03:45.066]                             muffled <- TRUE
[17:03:45.066]                             break
[17:03:45.066]                           }
[17:03:45.066]                         }
[17:03:45.066]                       }
[17:03:45.066]                       invisible(muffled)
[17:03:45.066]                     }
[17:03:45.066]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.066]                   }
[17:03:45.066]                 }
[17:03:45.066]                 else {
[17:03:45.066]                   if (TRUE) {
[17:03:45.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.066]                     {
[17:03:45.066]                       inherits <- base::inherits
[17:03:45.066]                       invokeRestart <- base::invokeRestart
[17:03:45.066]                       is.null <- base::is.null
[17:03:45.066]                       muffled <- FALSE
[17:03:45.066]                       if (inherits(cond, "message")) {
[17:03:45.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.066]                         if (muffled) 
[17:03:45.066]                           invokeRestart("muffleMessage")
[17:03:45.066]                       }
[17:03:45.066]                       else if (inherits(cond, "warning")) {
[17:03:45.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.066]                         if (muffled) 
[17:03:45.066]                           invokeRestart("muffleWarning")
[17:03:45.066]                       }
[17:03:45.066]                       else if (inherits(cond, "condition")) {
[17:03:45.066]                         if (!is.null(pattern)) {
[17:03:45.066]                           computeRestarts <- base::computeRestarts
[17:03:45.066]                           grepl <- base::grepl
[17:03:45.066]                           restarts <- computeRestarts(cond)
[17:03:45.066]                           for (restart in restarts) {
[17:03:45.066]                             name <- restart$name
[17:03:45.066]                             if (is.null(name)) 
[17:03:45.066]                               next
[17:03:45.066]                             if (!grepl(pattern, name)) 
[17:03:45.066]                               next
[17:03:45.066]                             invokeRestart(restart)
[17:03:45.066]                             muffled <- TRUE
[17:03:45.066]                             break
[17:03:45.066]                           }
[17:03:45.066]                         }
[17:03:45.066]                       }
[17:03:45.066]                       invisible(muffled)
[17:03:45.066]                     }
[17:03:45.066]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.066]                   }
[17:03:45.066]                 }
[17:03:45.066]             }
[17:03:45.066]         }))
[17:03:45.066]     }, error = function(ex) {
[17:03:45.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:45.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.066]                 ...future.rng), started = ...future.startTime, 
[17:03:45.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:45.066]             version = "1.8"), class = "FutureResult")
[17:03:45.066]     }, finally = {
[17:03:45.066]         if (!identical(...future.workdir, getwd())) 
[17:03:45.066]             setwd(...future.workdir)
[17:03:45.066]         {
[17:03:45.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:45.066]                 ...future.oldOptions$nwarnings <- NULL
[17:03:45.066]             }
[17:03:45.066]             base::options(...future.oldOptions)
[17:03:45.066]             if (.Platform$OS.type == "windows") {
[17:03:45.066]                 old_names <- names(...future.oldEnvVars)
[17:03:45.066]                 envs <- base::Sys.getenv()
[17:03:45.066]                 names <- names(envs)
[17:03:45.066]                 common <- intersect(names, old_names)
[17:03:45.066]                 added <- setdiff(names, old_names)
[17:03:45.066]                 removed <- setdiff(old_names, names)
[17:03:45.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:45.066]                   envs[common]]
[17:03:45.066]                 NAMES <- toupper(changed)
[17:03:45.066]                 args <- list()
[17:03:45.066]                 for (kk in seq_along(NAMES)) {
[17:03:45.066]                   name <- changed[[kk]]
[17:03:45.066]                   NAME <- NAMES[[kk]]
[17:03:45.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.066]                     next
[17:03:45.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.066]                 }
[17:03:45.066]                 NAMES <- toupper(added)
[17:03:45.066]                 for (kk in seq_along(NAMES)) {
[17:03:45.066]                   name <- added[[kk]]
[17:03:45.066]                   NAME <- NAMES[[kk]]
[17:03:45.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.066]                     next
[17:03:45.066]                   args[[name]] <- ""
[17:03:45.066]                 }
[17:03:45.066]                 NAMES <- toupper(removed)
[17:03:45.066]                 for (kk in seq_along(NAMES)) {
[17:03:45.066]                   name <- removed[[kk]]
[17:03:45.066]                   NAME <- NAMES[[kk]]
[17:03:45.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.066]                     next
[17:03:45.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.066]                 }
[17:03:45.066]                 if (length(args) > 0) 
[17:03:45.066]                   base::do.call(base::Sys.setenv, args = args)
[17:03:45.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:45.066]             }
[17:03:45.066]             else {
[17:03:45.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:45.066]             }
[17:03:45.066]             {
[17:03:45.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:45.066]                   0L) {
[17:03:45.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:45.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:45.066]                   base::options(opts)
[17:03:45.066]                 }
[17:03:45.066]                 {
[17:03:45.066]                   {
[17:03:45.066]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:45.066]                     NULL
[17:03:45.066]                   }
[17:03:45.066]                   options(future.plan = NULL)
[17:03:45.066]                   if (is.na(NA_character_)) 
[17:03:45.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:45.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:45.066]                     .init = FALSE)
[17:03:45.066]                 }
[17:03:45.066]             }
[17:03:45.066]         }
[17:03:45.066]     })
[17:03:45.066]     if (TRUE) {
[17:03:45.066]         base::sink(type = "output", split = FALSE)
[17:03:45.066]         if (TRUE) {
[17:03:45.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:45.066]         }
[17:03:45.066]         else {
[17:03:45.066]             ...future.result["stdout"] <- base::list(NULL)
[17:03:45.066]         }
[17:03:45.066]         base::close(...future.stdout)
[17:03:45.066]         ...future.stdout <- NULL
[17:03:45.066]     }
[17:03:45.066]     ...future.result$conditions <- ...future.conditions
[17:03:45.066]     ...future.result$finished <- base::Sys.time()
[17:03:45.066]     ...future.result
[17:03:45.066] }
[17:03:45.069] MultisessionFuture started
[17:03:45.069] - Launch lazy future ... done
[17:03:45.069] run() for ‘MultisessionFuture’ ... done
[17:03:45.071] receiveMessageFromWorker() for ClusterFuture ...
[17:03:45.071] - Validating connection of MultisessionFuture
[17:03:45.071] - received message: FutureResult
[17:03:45.073] - Received FutureResult
[17:03:45.073] - Erased future from FutureRegistry
[17:03:45.073] result() for ClusterFuture ...
[17:03:45.074] - result already collected: FutureResult
[17:03:45.074] result() for ClusterFuture ... done
[17:03:45.074] signalConditions() ...
[17:03:45.074]  - include = ‘immediateCondition’
[17:03:45.074]  - exclude = 
[17:03:45.074]  - resignal = FALSE
[17:03:45.074]  - Number of conditions: 1
[17:03:45.074] signalConditions() ... done
[17:03:45.074] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:45.074] A MultisessionFuture was resolved (result was not collected)
[17:03:45.074] getGlobalsAndPackages() ...
[17:03:45.074] Searching for globals...
[17:03:45.075] - globals found: [2] ‘list’, ‘stop’
[17:03:45.075] Searching for globals ... DONE
[17:03:45.075] Resolving globals: FALSE
[17:03:45.076] 
[17:03:45.076] 
[17:03:45.076] getGlobalsAndPackages() ... DONE
[17:03:45.076] run() for ‘Future’ ...
[17:03:45.076] - state: ‘created’
[17:03:45.076] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:45.090] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:45.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:45.090]   - Field: ‘node’
[17:03:45.091]   - Field: ‘label’
[17:03:45.091]   - Field: ‘local’
[17:03:45.091]   - Field: ‘owner’
[17:03:45.091]   - Field: ‘envir’
[17:03:45.091]   - Field: ‘workers’
[17:03:45.091]   - Field: ‘packages’
[17:03:45.091]   - Field: ‘gc’
[17:03:45.091]   - Field: ‘conditions’
[17:03:45.091]   - Field: ‘persistent’
[17:03:45.091]   - Field: ‘expr’
[17:03:45.091]   - Field: ‘uuid’
[17:03:45.092]   - Field: ‘seed’
[17:03:45.092]   - Field: ‘version’
[17:03:45.092]   - Field: ‘result’
[17:03:45.092]   - Field: ‘asynchronous’
[17:03:45.092]   - Field: ‘calls’
[17:03:45.092]   - Field: ‘globals’
[17:03:45.092]   - Field: ‘stdout’
[17:03:45.092]   - Field: ‘earlySignal’
[17:03:45.092]   - Field: ‘lazy’
[17:03:45.092]   - Field: ‘state’
[17:03:45.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:45.092] - Launch lazy future ...
[17:03:45.093] Packages needed by the future expression (n = 0): <none>
[17:03:45.093] Packages needed by future strategies (n = 0): <none>
[17:03:45.093] {
[17:03:45.093]     {
[17:03:45.093]         {
[17:03:45.093]             ...future.startTime <- base::Sys.time()
[17:03:45.093]             {
[17:03:45.093]                 {
[17:03:45.093]                   {
[17:03:45.093]                     {
[17:03:45.093]                       base::local({
[17:03:45.093]                         has_future <- base::requireNamespace("future", 
[17:03:45.093]                           quietly = TRUE)
[17:03:45.093]                         if (has_future) {
[17:03:45.093]                           ns <- base::getNamespace("future")
[17:03:45.093]                           version <- ns[[".package"]][["version"]]
[17:03:45.093]                           if (is.null(version)) 
[17:03:45.093]                             version <- utils::packageVersion("future")
[17:03:45.093]                         }
[17:03:45.093]                         else {
[17:03:45.093]                           version <- NULL
[17:03:45.093]                         }
[17:03:45.093]                         if (!has_future || version < "1.8.0") {
[17:03:45.093]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:45.093]                             "", base::R.version$version.string), 
[17:03:45.093]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:45.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:45.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:45.093]                               "release", "version")], collapse = " "), 
[17:03:45.093]                             hostname = base::Sys.info()[["nodename"]])
[17:03:45.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:45.093]                             info)
[17:03:45.093]                           info <- base::paste(info, collapse = "; ")
[17:03:45.093]                           if (!has_future) {
[17:03:45.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:45.093]                               info)
[17:03:45.093]                           }
[17:03:45.093]                           else {
[17:03:45.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:45.093]                               info, version)
[17:03:45.093]                           }
[17:03:45.093]                           base::stop(msg)
[17:03:45.093]                         }
[17:03:45.093]                       })
[17:03:45.093]                     }
[17:03:45.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:45.093]                     base::options(mc.cores = 1L)
[17:03:45.093]                   }
[17:03:45.093]                   ...future.strategy.old <- future::plan("list")
[17:03:45.093]                   options(future.plan = NULL)
[17:03:45.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:45.093]                 }
[17:03:45.093]                 ...future.workdir <- getwd()
[17:03:45.093]             }
[17:03:45.093]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:45.093]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:45.093]         }
[17:03:45.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:45.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:45.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:45.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:45.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:45.093]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:45.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:45.093]             base::names(...future.oldOptions))
[17:03:45.093]     }
[17:03:45.093]     if (FALSE) {
[17:03:45.093]     }
[17:03:45.093]     else {
[17:03:45.093]         if (TRUE) {
[17:03:45.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:45.093]                 open = "w")
[17:03:45.093]         }
[17:03:45.093]         else {
[17:03:45.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:45.093]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:45.093]         }
[17:03:45.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:45.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:45.093]             base::sink(type = "output", split = FALSE)
[17:03:45.093]             base::close(...future.stdout)
[17:03:45.093]         }, add = TRUE)
[17:03:45.093]     }
[17:03:45.093]     ...future.frame <- base::sys.nframe()
[17:03:45.093]     ...future.conditions <- base::list()
[17:03:45.093]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:45.093]     if (FALSE) {
[17:03:45.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:45.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:45.093]     }
[17:03:45.093]     ...future.result <- base::tryCatch({
[17:03:45.093]         base::withCallingHandlers({
[17:03:45.093]             ...future.value <- base::withVisible(base::local({
[17:03:45.093]                 ...future.makeSendCondition <- base::local({
[17:03:45.093]                   sendCondition <- NULL
[17:03:45.093]                   function(frame = 1L) {
[17:03:45.093]                     if (is.function(sendCondition)) 
[17:03:45.093]                       return(sendCondition)
[17:03:45.093]                     ns <- getNamespace("parallel")
[17:03:45.093]                     if (exists("sendData", mode = "function", 
[17:03:45.093]                       envir = ns)) {
[17:03:45.093]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:45.093]                         envir = ns)
[17:03:45.093]                       envir <- sys.frame(frame)
[17:03:45.093]                       master <- NULL
[17:03:45.093]                       while (!identical(envir, .GlobalEnv) && 
[17:03:45.093]                         !identical(envir, emptyenv())) {
[17:03:45.093]                         if (exists("master", mode = "list", envir = envir, 
[17:03:45.093]                           inherits = FALSE)) {
[17:03:45.093]                           master <- get("master", mode = "list", 
[17:03:45.093]                             envir = envir, inherits = FALSE)
[17:03:45.093]                           if (inherits(master, c("SOCKnode", 
[17:03:45.093]                             "SOCK0node"))) {
[17:03:45.093]                             sendCondition <<- function(cond) {
[17:03:45.093]                               data <- list(type = "VALUE", value = cond, 
[17:03:45.093]                                 success = TRUE)
[17:03:45.093]                               parallel_sendData(master, data)
[17:03:45.093]                             }
[17:03:45.093]                             return(sendCondition)
[17:03:45.093]                           }
[17:03:45.093]                         }
[17:03:45.093]                         frame <- frame + 1L
[17:03:45.093]                         envir <- sys.frame(frame)
[17:03:45.093]                       }
[17:03:45.093]                     }
[17:03:45.093]                     sendCondition <<- function(cond) NULL
[17:03:45.093]                   }
[17:03:45.093]                 })
[17:03:45.093]                 withCallingHandlers({
[17:03:45.093]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:45.093]                 }, immediateCondition = function(cond) {
[17:03:45.093]                   sendCondition <- ...future.makeSendCondition()
[17:03:45.093]                   sendCondition(cond)
[17:03:45.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.093]                   {
[17:03:45.093]                     inherits <- base::inherits
[17:03:45.093]                     invokeRestart <- base::invokeRestart
[17:03:45.093]                     is.null <- base::is.null
[17:03:45.093]                     muffled <- FALSE
[17:03:45.093]                     if (inherits(cond, "message")) {
[17:03:45.093]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:45.093]                       if (muffled) 
[17:03:45.093]                         invokeRestart("muffleMessage")
[17:03:45.093]                     }
[17:03:45.093]                     else if (inherits(cond, "warning")) {
[17:03:45.093]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:45.093]                       if (muffled) 
[17:03:45.093]                         invokeRestart("muffleWarning")
[17:03:45.093]                     }
[17:03:45.093]                     else if (inherits(cond, "condition")) {
[17:03:45.093]                       if (!is.null(pattern)) {
[17:03:45.093]                         computeRestarts <- base::computeRestarts
[17:03:45.093]                         grepl <- base::grepl
[17:03:45.093]                         restarts <- computeRestarts(cond)
[17:03:45.093]                         for (restart in restarts) {
[17:03:45.093]                           name <- restart$name
[17:03:45.093]                           if (is.null(name)) 
[17:03:45.093]                             next
[17:03:45.093]                           if (!grepl(pattern, name)) 
[17:03:45.093]                             next
[17:03:45.093]                           invokeRestart(restart)
[17:03:45.093]                           muffled <- TRUE
[17:03:45.093]                           break
[17:03:45.093]                         }
[17:03:45.093]                       }
[17:03:45.093]                     }
[17:03:45.093]                     invisible(muffled)
[17:03:45.093]                   }
[17:03:45.093]                   muffleCondition(cond)
[17:03:45.093]                 })
[17:03:45.093]             }))
[17:03:45.093]             future::FutureResult(value = ...future.value$value, 
[17:03:45.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.093]                   ...future.rng), globalenv = if (FALSE) 
[17:03:45.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:45.093]                     ...future.globalenv.names))
[17:03:45.093]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:45.093]         }, condition = base::local({
[17:03:45.093]             c <- base::c
[17:03:45.093]             inherits <- base::inherits
[17:03:45.093]             invokeRestart <- base::invokeRestart
[17:03:45.093]             length <- base::length
[17:03:45.093]             list <- base::list
[17:03:45.093]             seq.int <- base::seq.int
[17:03:45.093]             signalCondition <- base::signalCondition
[17:03:45.093]             sys.calls <- base::sys.calls
[17:03:45.093]             `[[` <- base::`[[`
[17:03:45.093]             `+` <- base::`+`
[17:03:45.093]             `<<-` <- base::`<<-`
[17:03:45.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:45.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:45.093]                   3L)]
[17:03:45.093]             }
[17:03:45.093]             function(cond) {
[17:03:45.093]                 is_error <- inherits(cond, "error")
[17:03:45.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:45.093]                   NULL)
[17:03:45.093]                 if (is_error) {
[17:03:45.093]                   sessionInformation <- function() {
[17:03:45.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:45.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:45.093]                       search = base::search(), system = base::Sys.info())
[17:03:45.093]                   }
[17:03:45.093]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:45.093]                     cond$call), session = sessionInformation(), 
[17:03:45.093]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:45.093]                   signalCondition(cond)
[17:03:45.093]                 }
[17:03:45.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:45.093]                 "immediateCondition"))) {
[17:03:45.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:45.093]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:45.093]                   if (TRUE && !signal) {
[17:03:45.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.093]                     {
[17:03:45.093]                       inherits <- base::inherits
[17:03:45.093]                       invokeRestart <- base::invokeRestart
[17:03:45.093]                       is.null <- base::is.null
[17:03:45.093]                       muffled <- FALSE
[17:03:45.093]                       if (inherits(cond, "message")) {
[17:03:45.093]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.093]                         if (muffled) 
[17:03:45.093]                           invokeRestart("muffleMessage")
[17:03:45.093]                       }
[17:03:45.093]                       else if (inherits(cond, "warning")) {
[17:03:45.093]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.093]                         if (muffled) 
[17:03:45.093]                           invokeRestart("muffleWarning")
[17:03:45.093]                       }
[17:03:45.093]                       else if (inherits(cond, "condition")) {
[17:03:45.093]                         if (!is.null(pattern)) {
[17:03:45.093]                           computeRestarts <- base::computeRestarts
[17:03:45.093]                           grepl <- base::grepl
[17:03:45.093]                           restarts <- computeRestarts(cond)
[17:03:45.093]                           for (restart in restarts) {
[17:03:45.093]                             name <- restart$name
[17:03:45.093]                             if (is.null(name)) 
[17:03:45.093]                               next
[17:03:45.093]                             if (!grepl(pattern, name)) 
[17:03:45.093]                               next
[17:03:45.093]                             invokeRestart(restart)
[17:03:45.093]                             muffled <- TRUE
[17:03:45.093]                             break
[17:03:45.093]                           }
[17:03:45.093]                         }
[17:03:45.093]                       }
[17:03:45.093]                       invisible(muffled)
[17:03:45.093]                     }
[17:03:45.093]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.093]                   }
[17:03:45.093]                 }
[17:03:45.093]                 else {
[17:03:45.093]                   if (TRUE) {
[17:03:45.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.093]                     {
[17:03:45.093]                       inherits <- base::inherits
[17:03:45.093]                       invokeRestart <- base::invokeRestart
[17:03:45.093]                       is.null <- base::is.null
[17:03:45.093]                       muffled <- FALSE
[17:03:45.093]                       if (inherits(cond, "message")) {
[17:03:45.093]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.093]                         if (muffled) 
[17:03:45.093]                           invokeRestart("muffleMessage")
[17:03:45.093]                       }
[17:03:45.093]                       else if (inherits(cond, "warning")) {
[17:03:45.093]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.093]                         if (muffled) 
[17:03:45.093]                           invokeRestart("muffleWarning")
[17:03:45.093]                       }
[17:03:45.093]                       else if (inherits(cond, "condition")) {
[17:03:45.093]                         if (!is.null(pattern)) {
[17:03:45.093]                           computeRestarts <- base::computeRestarts
[17:03:45.093]                           grepl <- base::grepl
[17:03:45.093]                           restarts <- computeRestarts(cond)
[17:03:45.093]                           for (restart in restarts) {
[17:03:45.093]                             name <- restart$name
[17:03:45.093]                             if (is.null(name)) 
[17:03:45.093]                               next
[17:03:45.093]                             if (!grepl(pattern, name)) 
[17:03:45.093]                               next
[17:03:45.093]                             invokeRestart(restart)
[17:03:45.093]                             muffled <- TRUE
[17:03:45.093]                             break
[17:03:45.093]                           }
[17:03:45.093]                         }
[17:03:45.093]                       }
[17:03:45.093]                       invisible(muffled)
[17:03:45.093]                     }
[17:03:45.093]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.093]                   }
[17:03:45.093]                 }
[17:03:45.093]             }
[17:03:45.093]         }))
[17:03:45.093]     }, error = function(ex) {
[17:03:45.093]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:45.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.093]                 ...future.rng), started = ...future.startTime, 
[17:03:45.093]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:45.093]             version = "1.8"), class = "FutureResult")
[17:03:45.093]     }, finally = {
[17:03:45.093]         if (!identical(...future.workdir, getwd())) 
[17:03:45.093]             setwd(...future.workdir)
[17:03:45.093]         {
[17:03:45.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:45.093]                 ...future.oldOptions$nwarnings <- NULL
[17:03:45.093]             }
[17:03:45.093]             base::options(...future.oldOptions)
[17:03:45.093]             if (.Platform$OS.type == "windows") {
[17:03:45.093]                 old_names <- names(...future.oldEnvVars)
[17:03:45.093]                 envs <- base::Sys.getenv()
[17:03:45.093]                 names <- names(envs)
[17:03:45.093]                 common <- intersect(names, old_names)
[17:03:45.093]                 added <- setdiff(names, old_names)
[17:03:45.093]                 removed <- setdiff(old_names, names)
[17:03:45.093]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:45.093]                   envs[common]]
[17:03:45.093]                 NAMES <- toupper(changed)
[17:03:45.093]                 args <- list()
[17:03:45.093]                 for (kk in seq_along(NAMES)) {
[17:03:45.093]                   name <- changed[[kk]]
[17:03:45.093]                   NAME <- NAMES[[kk]]
[17:03:45.093]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.093]                     next
[17:03:45.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.093]                 }
[17:03:45.093]                 NAMES <- toupper(added)
[17:03:45.093]                 for (kk in seq_along(NAMES)) {
[17:03:45.093]                   name <- added[[kk]]
[17:03:45.093]                   NAME <- NAMES[[kk]]
[17:03:45.093]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.093]                     next
[17:03:45.093]                   args[[name]] <- ""
[17:03:45.093]                 }
[17:03:45.093]                 NAMES <- toupper(removed)
[17:03:45.093]                 for (kk in seq_along(NAMES)) {
[17:03:45.093]                   name <- removed[[kk]]
[17:03:45.093]                   NAME <- NAMES[[kk]]
[17:03:45.093]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.093]                     next
[17:03:45.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.093]                 }
[17:03:45.093]                 if (length(args) > 0) 
[17:03:45.093]                   base::do.call(base::Sys.setenv, args = args)
[17:03:45.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:45.093]             }
[17:03:45.093]             else {
[17:03:45.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:45.093]             }
[17:03:45.093]             {
[17:03:45.093]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:45.093]                   0L) {
[17:03:45.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:45.093]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:45.093]                   base::options(opts)
[17:03:45.093]                 }
[17:03:45.093]                 {
[17:03:45.093]                   {
[17:03:45.093]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:45.093]                     NULL
[17:03:45.093]                   }
[17:03:45.093]                   options(future.plan = NULL)
[17:03:45.093]                   if (is.na(NA_character_)) 
[17:03:45.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:45.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:45.093]                     .init = FALSE)
[17:03:45.093]                 }
[17:03:45.093]             }
[17:03:45.093]         }
[17:03:45.093]     })
[17:03:45.093]     if (TRUE) {
[17:03:45.093]         base::sink(type = "output", split = FALSE)
[17:03:45.093]         if (TRUE) {
[17:03:45.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:45.093]         }
[17:03:45.093]         else {
[17:03:45.093]             ...future.result["stdout"] <- base::list(NULL)
[17:03:45.093]         }
[17:03:45.093]         base::close(...future.stdout)
[17:03:45.093]         ...future.stdout <- NULL
[17:03:45.093]     }
[17:03:45.093]     ...future.result$conditions <- ...future.conditions
[17:03:45.093]     ...future.result$finished <- base::Sys.time()
[17:03:45.093]     ...future.result
[17:03:45.093] }
[17:03:45.096] MultisessionFuture started
[17:03:45.096] - Launch lazy future ... done
[17:03:45.096] run() for ‘MultisessionFuture’ ... done
[17:03:45.098] receiveMessageFromWorker() for ClusterFuture ...
[17:03:45.098] - Validating connection of MultisessionFuture
[17:03:45.099] - received message: FutureResult
[17:03:45.099] - Received FutureResult
[17:03:45.099] - Erased future from FutureRegistry
[17:03:45.099] result() for ClusterFuture ...
[17:03:45.099] - result already collected: FutureResult
[17:03:45.099] result() for ClusterFuture ... done
[17:03:45.099] signalConditions() ...
[17:03:45.100]  - include = ‘immediateCondition’
[17:03:45.100]  - exclude = 
[17:03:45.100]  - resignal = FALSE
[17:03:45.100]  - Number of conditions: 1
[17:03:45.100] signalConditions() ... done
[17:03:45.100] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:45.100] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[17:03:45.100] getGlobalsAndPackages() ...
[17:03:45.100] Searching for globals...
[17:03:45.101] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:45.102] Searching for globals ... DONE
[17:03:45.102] Resolving globals: FALSE
[17:03:45.102] 
[17:03:45.102] 
[17:03:45.102] getGlobalsAndPackages() ... DONE
[17:03:45.102] run() for ‘Future’ ...
[17:03:45.102] - state: ‘created’
[17:03:45.103] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:45.117] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:45.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:45.117]   - Field: ‘node’
[17:03:45.117]   - Field: ‘label’
[17:03:45.117]   - Field: ‘local’
[17:03:45.117]   - Field: ‘owner’
[17:03:45.118]   - Field: ‘envir’
[17:03:45.118]   - Field: ‘workers’
[17:03:45.118]   - Field: ‘packages’
[17:03:45.118]   - Field: ‘gc’
[17:03:45.118]   - Field: ‘conditions’
[17:03:45.118]   - Field: ‘persistent’
[17:03:45.118]   - Field: ‘expr’
[17:03:45.118]   - Field: ‘uuid’
[17:03:45.118]   - Field: ‘seed’
[17:03:45.118]   - Field: ‘version’
[17:03:45.118]   - Field: ‘result’
[17:03:45.118]   - Field: ‘asynchronous’
[17:03:45.119]   - Field: ‘calls’
[17:03:45.119]   - Field: ‘globals’
[17:03:45.119]   - Field: ‘stdout’
[17:03:45.119]   - Field: ‘earlySignal’
[17:03:45.119]   - Field: ‘lazy’
[17:03:45.119]   - Field: ‘state’
[17:03:45.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:45.119] - Launch lazy future ...
[17:03:45.119] Packages needed by the future expression (n = 0): <none>
[17:03:45.120] Packages needed by future strategies (n = 0): <none>
[17:03:45.120] {
[17:03:45.120]     {
[17:03:45.120]         {
[17:03:45.120]             ...future.startTime <- base::Sys.time()
[17:03:45.120]             {
[17:03:45.120]                 {
[17:03:45.120]                   {
[17:03:45.120]                     {
[17:03:45.120]                       base::local({
[17:03:45.120]                         has_future <- base::requireNamespace("future", 
[17:03:45.120]                           quietly = TRUE)
[17:03:45.120]                         if (has_future) {
[17:03:45.120]                           ns <- base::getNamespace("future")
[17:03:45.120]                           version <- ns[[".package"]][["version"]]
[17:03:45.120]                           if (is.null(version)) 
[17:03:45.120]                             version <- utils::packageVersion("future")
[17:03:45.120]                         }
[17:03:45.120]                         else {
[17:03:45.120]                           version <- NULL
[17:03:45.120]                         }
[17:03:45.120]                         if (!has_future || version < "1.8.0") {
[17:03:45.120]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:45.120]                             "", base::R.version$version.string), 
[17:03:45.120]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:45.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:45.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:45.120]                               "release", "version")], collapse = " "), 
[17:03:45.120]                             hostname = base::Sys.info()[["nodename"]])
[17:03:45.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:45.120]                             info)
[17:03:45.120]                           info <- base::paste(info, collapse = "; ")
[17:03:45.120]                           if (!has_future) {
[17:03:45.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:45.120]                               info)
[17:03:45.120]                           }
[17:03:45.120]                           else {
[17:03:45.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:45.120]                               info, version)
[17:03:45.120]                           }
[17:03:45.120]                           base::stop(msg)
[17:03:45.120]                         }
[17:03:45.120]                       })
[17:03:45.120]                     }
[17:03:45.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:45.120]                     base::options(mc.cores = 1L)
[17:03:45.120]                   }
[17:03:45.120]                   ...future.strategy.old <- future::plan("list")
[17:03:45.120]                   options(future.plan = NULL)
[17:03:45.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:45.120]                 }
[17:03:45.120]                 ...future.workdir <- getwd()
[17:03:45.120]             }
[17:03:45.120]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:45.120]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:45.120]         }
[17:03:45.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:45.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:45.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:45.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:45.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:45.120]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:45.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:45.120]             base::names(...future.oldOptions))
[17:03:45.120]     }
[17:03:45.120]     if (FALSE) {
[17:03:45.120]     }
[17:03:45.120]     else {
[17:03:45.120]         if (TRUE) {
[17:03:45.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:45.120]                 open = "w")
[17:03:45.120]         }
[17:03:45.120]         else {
[17:03:45.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:45.120]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:45.120]         }
[17:03:45.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:45.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:45.120]             base::sink(type = "output", split = FALSE)
[17:03:45.120]             base::close(...future.stdout)
[17:03:45.120]         }, add = TRUE)
[17:03:45.120]     }
[17:03:45.120]     ...future.frame <- base::sys.nframe()
[17:03:45.120]     ...future.conditions <- base::list()
[17:03:45.120]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:45.120]     if (FALSE) {
[17:03:45.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:45.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:45.120]     }
[17:03:45.120]     ...future.result <- base::tryCatch({
[17:03:45.120]         base::withCallingHandlers({
[17:03:45.120]             ...future.value <- base::withVisible(base::local({
[17:03:45.120]                 ...future.makeSendCondition <- base::local({
[17:03:45.120]                   sendCondition <- NULL
[17:03:45.120]                   function(frame = 1L) {
[17:03:45.120]                     if (is.function(sendCondition)) 
[17:03:45.120]                       return(sendCondition)
[17:03:45.120]                     ns <- getNamespace("parallel")
[17:03:45.120]                     if (exists("sendData", mode = "function", 
[17:03:45.120]                       envir = ns)) {
[17:03:45.120]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:45.120]                         envir = ns)
[17:03:45.120]                       envir <- sys.frame(frame)
[17:03:45.120]                       master <- NULL
[17:03:45.120]                       while (!identical(envir, .GlobalEnv) && 
[17:03:45.120]                         !identical(envir, emptyenv())) {
[17:03:45.120]                         if (exists("master", mode = "list", envir = envir, 
[17:03:45.120]                           inherits = FALSE)) {
[17:03:45.120]                           master <- get("master", mode = "list", 
[17:03:45.120]                             envir = envir, inherits = FALSE)
[17:03:45.120]                           if (inherits(master, c("SOCKnode", 
[17:03:45.120]                             "SOCK0node"))) {
[17:03:45.120]                             sendCondition <<- function(cond) {
[17:03:45.120]                               data <- list(type = "VALUE", value = cond, 
[17:03:45.120]                                 success = TRUE)
[17:03:45.120]                               parallel_sendData(master, data)
[17:03:45.120]                             }
[17:03:45.120]                             return(sendCondition)
[17:03:45.120]                           }
[17:03:45.120]                         }
[17:03:45.120]                         frame <- frame + 1L
[17:03:45.120]                         envir <- sys.frame(frame)
[17:03:45.120]                       }
[17:03:45.120]                     }
[17:03:45.120]                     sendCondition <<- function(cond) NULL
[17:03:45.120]                   }
[17:03:45.120]                 })
[17:03:45.120]                 withCallingHandlers({
[17:03:45.120]                   {
[17:03:45.120]                     Sys.sleep(0.5)
[17:03:45.120]                     list(a = 1, b = 42L)
[17:03:45.120]                   }
[17:03:45.120]                 }, immediateCondition = function(cond) {
[17:03:45.120]                   sendCondition <- ...future.makeSendCondition()
[17:03:45.120]                   sendCondition(cond)
[17:03:45.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.120]                   {
[17:03:45.120]                     inherits <- base::inherits
[17:03:45.120]                     invokeRestart <- base::invokeRestart
[17:03:45.120]                     is.null <- base::is.null
[17:03:45.120]                     muffled <- FALSE
[17:03:45.120]                     if (inherits(cond, "message")) {
[17:03:45.120]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:45.120]                       if (muffled) 
[17:03:45.120]                         invokeRestart("muffleMessage")
[17:03:45.120]                     }
[17:03:45.120]                     else if (inherits(cond, "warning")) {
[17:03:45.120]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:45.120]                       if (muffled) 
[17:03:45.120]                         invokeRestart("muffleWarning")
[17:03:45.120]                     }
[17:03:45.120]                     else if (inherits(cond, "condition")) {
[17:03:45.120]                       if (!is.null(pattern)) {
[17:03:45.120]                         computeRestarts <- base::computeRestarts
[17:03:45.120]                         grepl <- base::grepl
[17:03:45.120]                         restarts <- computeRestarts(cond)
[17:03:45.120]                         for (restart in restarts) {
[17:03:45.120]                           name <- restart$name
[17:03:45.120]                           if (is.null(name)) 
[17:03:45.120]                             next
[17:03:45.120]                           if (!grepl(pattern, name)) 
[17:03:45.120]                             next
[17:03:45.120]                           invokeRestart(restart)
[17:03:45.120]                           muffled <- TRUE
[17:03:45.120]                           break
[17:03:45.120]                         }
[17:03:45.120]                       }
[17:03:45.120]                     }
[17:03:45.120]                     invisible(muffled)
[17:03:45.120]                   }
[17:03:45.120]                   muffleCondition(cond)
[17:03:45.120]                 })
[17:03:45.120]             }))
[17:03:45.120]             future::FutureResult(value = ...future.value$value, 
[17:03:45.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.120]                   ...future.rng), globalenv = if (FALSE) 
[17:03:45.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:45.120]                     ...future.globalenv.names))
[17:03:45.120]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:45.120]         }, condition = base::local({
[17:03:45.120]             c <- base::c
[17:03:45.120]             inherits <- base::inherits
[17:03:45.120]             invokeRestart <- base::invokeRestart
[17:03:45.120]             length <- base::length
[17:03:45.120]             list <- base::list
[17:03:45.120]             seq.int <- base::seq.int
[17:03:45.120]             signalCondition <- base::signalCondition
[17:03:45.120]             sys.calls <- base::sys.calls
[17:03:45.120]             `[[` <- base::`[[`
[17:03:45.120]             `+` <- base::`+`
[17:03:45.120]             `<<-` <- base::`<<-`
[17:03:45.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:45.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:45.120]                   3L)]
[17:03:45.120]             }
[17:03:45.120]             function(cond) {
[17:03:45.120]                 is_error <- inherits(cond, "error")
[17:03:45.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:45.120]                   NULL)
[17:03:45.120]                 if (is_error) {
[17:03:45.120]                   sessionInformation <- function() {
[17:03:45.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:45.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:45.120]                       search = base::search(), system = base::Sys.info())
[17:03:45.120]                   }
[17:03:45.120]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:45.120]                     cond$call), session = sessionInformation(), 
[17:03:45.120]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:45.120]                   signalCondition(cond)
[17:03:45.120]                 }
[17:03:45.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:45.120]                 "immediateCondition"))) {
[17:03:45.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:45.120]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:45.120]                   if (TRUE && !signal) {
[17:03:45.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.120]                     {
[17:03:45.120]                       inherits <- base::inherits
[17:03:45.120]                       invokeRestart <- base::invokeRestart
[17:03:45.120]                       is.null <- base::is.null
[17:03:45.120]                       muffled <- FALSE
[17:03:45.120]                       if (inherits(cond, "message")) {
[17:03:45.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.120]                         if (muffled) 
[17:03:45.120]                           invokeRestart("muffleMessage")
[17:03:45.120]                       }
[17:03:45.120]                       else if (inherits(cond, "warning")) {
[17:03:45.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.120]                         if (muffled) 
[17:03:45.120]                           invokeRestart("muffleWarning")
[17:03:45.120]                       }
[17:03:45.120]                       else if (inherits(cond, "condition")) {
[17:03:45.120]                         if (!is.null(pattern)) {
[17:03:45.120]                           computeRestarts <- base::computeRestarts
[17:03:45.120]                           grepl <- base::grepl
[17:03:45.120]                           restarts <- computeRestarts(cond)
[17:03:45.120]                           for (restart in restarts) {
[17:03:45.120]                             name <- restart$name
[17:03:45.120]                             if (is.null(name)) 
[17:03:45.120]                               next
[17:03:45.120]                             if (!grepl(pattern, name)) 
[17:03:45.120]                               next
[17:03:45.120]                             invokeRestart(restart)
[17:03:45.120]                             muffled <- TRUE
[17:03:45.120]                             break
[17:03:45.120]                           }
[17:03:45.120]                         }
[17:03:45.120]                       }
[17:03:45.120]                       invisible(muffled)
[17:03:45.120]                     }
[17:03:45.120]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.120]                   }
[17:03:45.120]                 }
[17:03:45.120]                 else {
[17:03:45.120]                   if (TRUE) {
[17:03:45.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.120]                     {
[17:03:45.120]                       inherits <- base::inherits
[17:03:45.120]                       invokeRestart <- base::invokeRestart
[17:03:45.120]                       is.null <- base::is.null
[17:03:45.120]                       muffled <- FALSE
[17:03:45.120]                       if (inherits(cond, "message")) {
[17:03:45.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.120]                         if (muffled) 
[17:03:45.120]                           invokeRestart("muffleMessage")
[17:03:45.120]                       }
[17:03:45.120]                       else if (inherits(cond, "warning")) {
[17:03:45.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.120]                         if (muffled) 
[17:03:45.120]                           invokeRestart("muffleWarning")
[17:03:45.120]                       }
[17:03:45.120]                       else if (inherits(cond, "condition")) {
[17:03:45.120]                         if (!is.null(pattern)) {
[17:03:45.120]                           computeRestarts <- base::computeRestarts
[17:03:45.120]                           grepl <- base::grepl
[17:03:45.120]                           restarts <- computeRestarts(cond)
[17:03:45.120]                           for (restart in restarts) {
[17:03:45.120]                             name <- restart$name
[17:03:45.120]                             if (is.null(name)) 
[17:03:45.120]                               next
[17:03:45.120]                             if (!grepl(pattern, name)) 
[17:03:45.120]                               next
[17:03:45.120]                             invokeRestart(restart)
[17:03:45.120]                             muffled <- TRUE
[17:03:45.120]                             break
[17:03:45.120]                           }
[17:03:45.120]                         }
[17:03:45.120]                       }
[17:03:45.120]                       invisible(muffled)
[17:03:45.120]                     }
[17:03:45.120]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.120]                   }
[17:03:45.120]                 }
[17:03:45.120]             }
[17:03:45.120]         }))
[17:03:45.120]     }, error = function(ex) {
[17:03:45.120]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:45.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.120]                 ...future.rng), started = ...future.startTime, 
[17:03:45.120]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:45.120]             version = "1.8"), class = "FutureResult")
[17:03:45.120]     }, finally = {
[17:03:45.120]         if (!identical(...future.workdir, getwd())) 
[17:03:45.120]             setwd(...future.workdir)
[17:03:45.120]         {
[17:03:45.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:45.120]                 ...future.oldOptions$nwarnings <- NULL
[17:03:45.120]             }
[17:03:45.120]             base::options(...future.oldOptions)
[17:03:45.120]             if (.Platform$OS.type == "windows") {
[17:03:45.120]                 old_names <- names(...future.oldEnvVars)
[17:03:45.120]                 envs <- base::Sys.getenv()
[17:03:45.120]                 names <- names(envs)
[17:03:45.120]                 common <- intersect(names, old_names)
[17:03:45.120]                 added <- setdiff(names, old_names)
[17:03:45.120]                 removed <- setdiff(old_names, names)
[17:03:45.120]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:45.120]                   envs[common]]
[17:03:45.120]                 NAMES <- toupper(changed)
[17:03:45.120]                 args <- list()
[17:03:45.120]                 for (kk in seq_along(NAMES)) {
[17:03:45.120]                   name <- changed[[kk]]
[17:03:45.120]                   NAME <- NAMES[[kk]]
[17:03:45.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.120]                     next
[17:03:45.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.120]                 }
[17:03:45.120]                 NAMES <- toupper(added)
[17:03:45.120]                 for (kk in seq_along(NAMES)) {
[17:03:45.120]                   name <- added[[kk]]
[17:03:45.120]                   NAME <- NAMES[[kk]]
[17:03:45.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.120]                     next
[17:03:45.120]                   args[[name]] <- ""
[17:03:45.120]                 }
[17:03:45.120]                 NAMES <- toupper(removed)
[17:03:45.120]                 for (kk in seq_along(NAMES)) {
[17:03:45.120]                   name <- removed[[kk]]
[17:03:45.120]                   NAME <- NAMES[[kk]]
[17:03:45.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.120]                     next
[17:03:45.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.120]                 }
[17:03:45.120]                 if (length(args) > 0) 
[17:03:45.120]                   base::do.call(base::Sys.setenv, args = args)
[17:03:45.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:45.120]             }
[17:03:45.120]             else {
[17:03:45.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:45.120]             }
[17:03:45.120]             {
[17:03:45.120]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:45.120]                   0L) {
[17:03:45.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:45.120]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:45.120]                   base::options(opts)
[17:03:45.120]                 }
[17:03:45.120]                 {
[17:03:45.120]                   {
[17:03:45.120]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:45.120]                     NULL
[17:03:45.120]                   }
[17:03:45.120]                   options(future.plan = NULL)
[17:03:45.120]                   if (is.na(NA_character_)) 
[17:03:45.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:45.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:45.120]                     .init = FALSE)
[17:03:45.120]                 }
[17:03:45.120]             }
[17:03:45.120]         }
[17:03:45.120]     })
[17:03:45.120]     if (TRUE) {
[17:03:45.120]         base::sink(type = "output", split = FALSE)
[17:03:45.120]         if (TRUE) {
[17:03:45.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:45.120]         }
[17:03:45.120]         else {
[17:03:45.120]             ...future.result["stdout"] <- base::list(NULL)
[17:03:45.120]         }
[17:03:45.120]         base::close(...future.stdout)
[17:03:45.120]         ...future.stdout <- NULL
[17:03:45.120]     }
[17:03:45.120]     ...future.result$conditions <- ...future.conditions
[17:03:45.120]     ...future.result$finished <- base::Sys.time()
[17:03:45.120]     ...future.result
[17:03:45.120] }
[17:03:45.123] MultisessionFuture started
[17:03:45.123] - Launch lazy future ... done
[17:03:45.123] run() for ‘MultisessionFuture’ ... done
[17:03:45.625] receiveMessageFromWorker() for ClusterFuture ...
[17:03:45.626] - Validating connection of MultisessionFuture
[17:03:45.626] - received message: FutureResult
[17:03:45.626] - Received FutureResult
[17:03:45.626] - Erased future from FutureRegistry
[17:03:45.626] result() for ClusterFuture ...
[17:03:45.626] - result already collected: FutureResult
[17:03:45.627] result() for ClusterFuture ... done
[17:03:45.627] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:45.627] A MultisessionFuture was resolved (result was not collected)
[17:03:45.627] getGlobalsAndPackages() ...
[17:03:45.627] Searching for globals...
[17:03:45.628] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:45.628] Searching for globals ... DONE
[17:03:45.628] Resolving globals: FALSE
[17:03:45.629] 
[17:03:45.629] 
[17:03:45.629] getGlobalsAndPackages() ... DONE
[17:03:45.629] run() for ‘Future’ ...
[17:03:45.629] - state: ‘created’
[17:03:45.629] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:45.643] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:45.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:45.644]   - Field: ‘node’
[17:03:45.644]   - Field: ‘label’
[17:03:45.644]   - Field: ‘local’
[17:03:45.644]   - Field: ‘owner’
[17:03:45.644]   - Field: ‘envir’
[17:03:45.644]   - Field: ‘workers’
[17:03:45.644]   - Field: ‘packages’
[17:03:45.644]   - Field: ‘gc’
[17:03:45.644]   - Field: ‘conditions’
[17:03:45.644]   - Field: ‘persistent’
[17:03:45.644]   - Field: ‘expr’
[17:03:45.645]   - Field: ‘uuid’
[17:03:45.645]   - Field: ‘seed’
[17:03:45.645]   - Field: ‘version’
[17:03:45.645]   - Field: ‘result’
[17:03:45.645]   - Field: ‘asynchronous’
[17:03:45.645]   - Field: ‘calls’
[17:03:45.645]   - Field: ‘globals’
[17:03:45.645]   - Field: ‘stdout’
[17:03:45.645]   - Field: ‘earlySignal’
[17:03:45.645]   - Field: ‘lazy’
[17:03:45.645]   - Field: ‘state’
[17:03:45.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:45.646] - Launch lazy future ...
[17:03:45.646] Packages needed by the future expression (n = 0): <none>
[17:03:45.646] Packages needed by future strategies (n = 0): <none>
[17:03:45.646] {
[17:03:45.646]     {
[17:03:45.646]         {
[17:03:45.646]             ...future.startTime <- base::Sys.time()
[17:03:45.646]             {
[17:03:45.646]                 {
[17:03:45.646]                   {
[17:03:45.646]                     {
[17:03:45.646]                       base::local({
[17:03:45.646]                         has_future <- base::requireNamespace("future", 
[17:03:45.646]                           quietly = TRUE)
[17:03:45.646]                         if (has_future) {
[17:03:45.646]                           ns <- base::getNamespace("future")
[17:03:45.646]                           version <- ns[[".package"]][["version"]]
[17:03:45.646]                           if (is.null(version)) 
[17:03:45.646]                             version <- utils::packageVersion("future")
[17:03:45.646]                         }
[17:03:45.646]                         else {
[17:03:45.646]                           version <- NULL
[17:03:45.646]                         }
[17:03:45.646]                         if (!has_future || version < "1.8.0") {
[17:03:45.646]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:45.646]                             "", base::R.version$version.string), 
[17:03:45.646]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:45.646]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:45.646]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:45.646]                               "release", "version")], collapse = " "), 
[17:03:45.646]                             hostname = base::Sys.info()[["nodename"]])
[17:03:45.646]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:45.646]                             info)
[17:03:45.646]                           info <- base::paste(info, collapse = "; ")
[17:03:45.646]                           if (!has_future) {
[17:03:45.646]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:45.646]                               info)
[17:03:45.646]                           }
[17:03:45.646]                           else {
[17:03:45.646]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:45.646]                               info, version)
[17:03:45.646]                           }
[17:03:45.646]                           base::stop(msg)
[17:03:45.646]                         }
[17:03:45.646]                       })
[17:03:45.646]                     }
[17:03:45.646]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:45.646]                     base::options(mc.cores = 1L)
[17:03:45.646]                   }
[17:03:45.646]                   ...future.strategy.old <- future::plan("list")
[17:03:45.646]                   options(future.plan = NULL)
[17:03:45.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:45.646]                 }
[17:03:45.646]                 ...future.workdir <- getwd()
[17:03:45.646]             }
[17:03:45.646]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:45.646]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:45.646]         }
[17:03:45.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:45.646]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:45.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:45.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:45.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:45.646]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:45.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:45.646]             base::names(...future.oldOptions))
[17:03:45.646]     }
[17:03:45.646]     if (FALSE) {
[17:03:45.646]     }
[17:03:45.646]     else {
[17:03:45.646]         if (TRUE) {
[17:03:45.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:45.646]                 open = "w")
[17:03:45.646]         }
[17:03:45.646]         else {
[17:03:45.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:45.646]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:45.646]         }
[17:03:45.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:45.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:45.646]             base::sink(type = "output", split = FALSE)
[17:03:45.646]             base::close(...future.stdout)
[17:03:45.646]         }, add = TRUE)
[17:03:45.646]     }
[17:03:45.646]     ...future.frame <- base::sys.nframe()
[17:03:45.646]     ...future.conditions <- base::list()
[17:03:45.646]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:45.646]     if (FALSE) {
[17:03:45.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:45.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:45.646]     }
[17:03:45.646]     ...future.result <- base::tryCatch({
[17:03:45.646]         base::withCallingHandlers({
[17:03:45.646]             ...future.value <- base::withVisible(base::local({
[17:03:45.646]                 ...future.makeSendCondition <- base::local({
[17:03:45.646]                   sendCondition <- NULL
[17:03:45.646]                   function(frame = 1L) {
[17:03:45.646]                     if (is.function(sendCondition)) 
[17:03:45.646]                       return(sendCondition)
[17:03:45.646]                     ns <- getNamespace("parallel")
[17:03:45.646]                     if (exists("sendData", mode = "function", 
[17:03:45.646]                       envir = ns)) {
[17:03:45.646]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:45.646]                         envir = ns)
[17:03:45.646]                       envir <- sys.frame(frame)
[17:03:45.646]                       master <- NULL
[17:03:45.646]                       while (!identical(envir, .GlobalEnv) && 
[17:03:45.646]                         !identical(envir, emptyenv())) {
[17:03:45.646]                         if (exists("master", mode = "list", envir = envir, 
[17:03:45.646]                           inherits = FALSE)) {
[17:03:45.646]                           master <- get("master", mode = "list", 
[17:03:45.646]                             envir = envir, inherits = FALSE)
[17:03:45.646]                           if (inherits(master, c("SOCKnode", 
[17:03:45.646]                             "SOCK0node"))) {
[17:03:45.646]                             sendCondition <<- function(cond) {
[17:03:45.646]                               data <- list(type = "VALUE", value = cond, 
[17:03:45.646]                                 success = TRUE)
[17:03:45.646]                               parallel_sendData(master, data)
[17:03:45.646]                             }
[17:03:45.646]                             return(sendCondition)
[17:03:45.646]                           }
[17:03:45.646]                         }
[17:03:45.646]                         frame <- frame + 1L
[17:03:45.646]                         envir <- sys.frame(frame)
[17:03:45.646]                       }
[17:03:45.646]                     }
[17:03:45.646]                     sendCondition <<- function(cond) NULL
[17:03:45.646]                   }
[17:03:45.646]                 })
[17:03:45.646]                 withCallingHandlers({
[17:03:45.646]                   {
[17:03:45.646]                     Sys.sleep(0.5)
[17:03:45.646]                     list(a = 1, b = 42L)
[17:03:45.646]                   }
[17:03:45.646]                 }, immediateCondition = function(cond) {
[17:03:45.646]                   sendCondition <- ...future.makeSendCondition()
[17:03:45.646]                   sendCondition(cond)
[17:03:45.646]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.646]                   {
[17:03:45.646]                     inherits <- base::inherits
[17:03:45.646]                     invokeRestart <- base::invokeRestart
[17:03:45.646]                     is.null <- base::is.null
[17:03:45.646]                     muffled <- FALSE
[17:03:45.646]                     if (inherits(cond, "message")) {
[17:03:45.646]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:45.646]                       if (muffled) 
[17:03:45.646]                         invokeRestart("muffleMessage")
[17:03:45.646]                     }
[17:03:45.646]                     else if (inherits(cond, "warning")) {
[17:03:45.646]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:45.646]                       if (muffled) 
[17:03:45.646]                         invokeRestart("muffleWarning")
[17:03:45.646]                     }
[17:03:45.646]                     else if (inherits(cond, "condition")) {
[17:03:45.646]                       if (!is.null(pattern)) {
[17:03:45.646]                         computeRestarts <- base::computeRestarts
[17:03:45.646]                         grepl <- base::grepl
[17:03:45.646]                         restarts <- computeRestarts(cond)
[17:03:45.646]                         for (restart in restarts) {
[17:03:45.646]                           name <- restart$name
[17:03:45.646]                           if (is.null(name)) 
[17:03:45.646]                             next
[17:03:45.646]                           if (!grepl(pattern, name)) 
[17:03:45.646]                             next
[17:03:45.646]                           invokeRestart(restart)
[17:03:45.646]                           muffled <- TRUE
[17:03:45.646]                           break
[17:03:45.646]                         }
[17:03:45.646]                       }
[17:03:45.646]                     }
[17:03:45.646]                     invisible(muffled)
[17:03:45.646]                   }
[17:03:45.646]                   muffleCondition(cond)
[17:03:45.646]                 })
[17:03:45.646]             }))
[17:03:45.646]             future::FutureResult(value = ...future.value$value, 
[17:03:45.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.646]                   ...future.rng), globalenv = if (FALSE) 
[17:03:45.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:45.646]                     ...future.globalenv.names))
[17:03:45.646]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:45.646]         }, condition = base::local({
[17:03:45.646]             c <- base::c
[17:03:45.646]             inherits <- base::inherits
[17:03:45.646]             invokeRestart <- base::invokeRestart
[17:03:45.646]             length <- base::length
[17:03:45.646]             list <- base::list
[17:03:45.646]             seq.int <- base::seq.int
[17:03:45.646]             signalCondition <- base::signalCondition
[17:03:45.646]             sys.calls <- base::sys.calls
[17:03:45.646]             `[[` <- base::`[[`
[17:03:45.646]             `+` <- base::`+`
[17:03:45.646]             `<<-` <- base::`<<-`
[17:03:45.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:45.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:45.646]                   3L)]
[17:03:45.646]             }
[17:03:45.646]             function(cond) {
[17:03:45.646]                 is_error <- inherits(cond, "error")
[17:03:45.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:45.646]                   NULL)
[17:03:45.646]                 if (is_error) {
[17:03:45.646]                   sessionInformation <- function() {
[17:03:45.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:45.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:45.646]                       search = base::search(), system = base::Sys.info())
[17:03:45.646]                   }
[17:03:45.646]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:45.646]                     cond$call), session = sessionInformation(), 
[17:03:45.646]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:45.646]                   signalCondition(cond)
[17:03:45.646]                 }
[17:03:45.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:45.646]                 "immediateCondition"))) {
[17:03:45.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:45.646]                   ...future.conditions[[length(...future.conditions) + 
[17:03:45.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:45.646]                   if (TRUE && !signal) {
[17:03:45.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.646]                     {
[17:03:45.646]                       inherits <- base::inherits
[17:03:45.646]                       invokeRestart <- base::invokeRestart
[17:03:45.646]                       is.null <- base::is.null
[17:03:45.646]                       muffled <- FALSE
[17:03:45.646]                       if (inherits(cond, "message")) {
[17:03:45.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.646]                         if (muffled) 
[17:03:45.646]                           invokeRestart("muffleMessage")
[17:03:45.646]                       }
[17:03:45.646]                       else if (inherits(cond, "warning")) {
[17:03:45.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.646]                         if (muffled) 
[17:03:45.646]                           invokeRestart("muffleWarning")
[17:03:45.646]                       }
[17:03:45.646]                       else if (inherits(cond, "condition")) {
[17:03:45.646]                         if (!is.null(pattern)) {
[17:03:45.646]                           computeRestarts <- base::computeRestarts
[17:03:45.646]                           grepl <- base::grepl
[17:03:45.646]                           restarts <- computeRestarts(cond)
[17:03:45.646]                           for (restart in restarts) {
[17:03:45.646]                             name <- restart$name
[17:03:45.646]                             if (is.null(name)) 
[17:03:45.646]                               next
[17:03:45.646]                             if (!grepl(pattern, name)) 
[17:03:45.646]                               next
[17:03:45.646]                             invokeRestart(restart)
[17:03:45.646]                             muffled <- TRUE
[17:03:45.646]                             break
[17:03:45.646]                           }
[17:03:45.646]                         }
[17:03:45.646]                       }
[17:03:45.646]                       invisible(muffled)
[17:03:45.646]                     }
[17:03:45.646]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.646]                   }
[17:03:45.646]                 }
[17:03:45.646]                 else {
[17:03:45.646]                   if (TRUE) {
[17:03:45.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:45.646]                     {
[17:03:45.646]                       inherits <- base::inherits
[17:03:45.646]                       invokeRestart <- base::invokeRestart
[17:03:45.646]                       is.null <- base::is.null
[17:03:45.646]                       muffled <- FALSE
[17:03:45.646]                       if (inherits(cond, "message")) {
[17:03:45.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:45.646]                         if (muffled) 
[17:03:45.646]                           invokeRestart("muffleMessage")
[17:03:45.646]                       }
[17:03:45.646]                       else if (inherits(cond, "warning")) {
[17:03:45.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:45.646]                         if (muffled) 
[17:03:45.646]                           invokeRestart("muffleWarning")
[17:03:45.646]                       }
[17:03:45.646]                       else if (inherits(cond, "condition")) {
[17:03:45.646]                         if (!is.null(pattern)) {
[17:03:45.646]                           computeRestarts <- base::computeRestarts
[17:03:45.646]                           grepl <- base::grepl
[17:03:45.646]                           restarts <- computeRestarts(cond)
[17:03:45.646]                           for (restart in restarts) {
[17:03:45.646]                             name <- restart$name
[17:03:45.646]                             if (is.null(name)) 
[17:03:45.646]                               next
[17:03:45.646]                             if (!grepl(pattern, name)) 
[17:03:45.646]                               next
[17:03:45.646]                             invokeRestart(restart)
[17:03:45.646]                             muffled <- TRUE
[17:03:45.646]                             break
[17:03:45.646]                           }
[17:03:45.646]                         }
[17:03:45.646]                       }
[17:03:45.646]                       invisible(muffled)
[17:03:45.646]                     }
[17:03:45.646]                     muffleCondition(cond, pattern = "^muffle")
[17:03:45.646]                   }
[17:03:45.646]                 }
[17:03:45.646]             }
[17:03:45.646]         }))
[17:03:45.646]     }, error = function(ex) {
[17:03:45.646]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:45.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:45.646]                 ...future.rng), started = ...future.startTime, 
[17:03:45.646]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:45.646]             version = "1.8"), class = "FutureResult")
[17:03:45.646]     }, finally = {
[17:03:45.646]         if (!identical(...future.workdir, getwd())) 
[17:03:45.646]             setwd(...future.workdir)
[17:03:45.646]         {
[17:03:45.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:45.646]                 ...future.oldOptions$nwarnings <- NULL
[17:03:45.646]             }
[17:03:45.646]             base::options(...future.oldOptions)
[17:03:45.646]             if (.Platform$OS.type == "windows") {
[17:03:45.646]                 old_names <- names(...future.oldEnvVars)
[17:03:45.646]                 envs <- base::Sys.getenv()
[17:03:45.646]                 names <- names(envs)
[17:03:45.646]                 common <- intersect(names, old_names)
[17:03:45.646]                 added <- setdiff(names, old_names)
[17:03:45.646]                 removed <- setdiff(old_names, names)
[17:03:45.646]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:45.646]                   envs[common]]
[17:03:45.646]                 NAMES <- toupper(changed)
[17:03:45.646]                 args <- list()
[17:03:45.646]                 for (kk in seq_along(NAMES)) {
[17:03:45.646]                   name <- changed[[kk]]
[17:03:45.646]                   NAME <- NAMES[[kk]]
[17:03:45.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.646]                     next
[17:03:45.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.646]                 }
[17:03:45.646]                 NAMES <- toupper(added)
[17:03:45.646]                 for (kk in seq_along(NAMES)) {
[17:03:45.646]                   name <- added[[kk]]
[17:03:45.646]                   NAME <- NAMES[[kk]]
[17:03:45.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.646]                     next
[17:03:45.646]                   args[[name]] <- ""
[17:03:45.646]                 }
[17:03:45.646]                 NAMES <- toupper(removed)
[17:03:45.646]                 for (kk in seq_along(NAMES)) {
[17:03:45.646]                   name <- removed[[kk]]
[17:03:45.646]                   NAME <- NAMES[[kk]]
[17:03:45.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:45.646]                     next
[17:03:45.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:45.646]                 }
[17:03:45.646]                 if (length(args) > 0) 
[17:03:45.646]                   base::do.call(base::Sys.setenv, args = args)
[17:03:45.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:45.646]             }
[17:03:45.646]             else {
[17:03:45.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:45.646]             }
[17:03:45.646]             {
[17:03:45.646]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:45.646]                   0L) {
[17:03:45.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:45.646]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:45.646]                   base::options(opts)
[17:03:45.646]                 }
[17:03:45.646]                 {
[17:03:45.646]                   {
[17:03:45.646]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:45.646]                     NULL
[17:03:45.646]                   }
[17:03:45.646]                   options(future.plan = NULL)
[17:03:45.646]                   if (is.na(NA_character_)) 
[17:03:45.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:45.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:45.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:45.646]                     .init = FALSE)
[17:03:45.646]                 }
[17:03:45.646]             }
[17:03:45.646]         }
[17:03:45.646]     })
[17:03:45.646]     if (TRUE) {
[17:03:45.646]         base::sink(type = "output", split = FALSE)
[17:03:45.646]         if (TRUE) {
[17:03:45.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:45.646]         }
[17:03:45.646]         else {
[17:03:45.646]             ...future.result["stdout"] <- base::list(NULL)
[17:03:45.646]         }
[17:03:45.646]         base::close(...future.stdout)
[17:03:45.646]         ...future.stdout <- NULL
[17:03:45.646]     }
[17:03:45.646]     ...future.result$conditions <- ...future.conditions
[17:03:45.646]     ...future.result$finished <- base::Sys.time()
[17:03:45.646]     ...future.result
[17:03:45.646] }
[17:03:45.649] MultisessionFuture started
[17:03:45.649] - Launch lazy future ... done
[17:03:45.650] run() for ‘MultisessionFuture’ ... done
[17:03:46.152] receiveMessageFromWorker() for ClusterFuture ...
[17:03:46.152] - Validating connection of MultisessionFuture
[17:03:46.152] - received message: FutureResult
[17:03:46.152] - Received FutureResult
[17:03:46.153] - Erased future from FutureRegistry
[17:03:46.153] result() for ClusterFuture ...
[17:03:46.153] - result already collected: FutureResult
[17:03:46.153] result() for ClusterFuture ... done
[17:03:46.153] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:46.153] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:03:46.153] getGlobalsAndPackages() ...
[17:03:46.153] Searching for globals...
[17:03:46.154] - globals found: [2] ‘list’, ‘stop’
[17:03:46.154] Searching for globals ... DONE
[17:03:46.154] Resolving globals: FALSE
[17:03:46.155] 
[17:03:46.155] 
[17:03:46.155] getGlobalsAndPackages() ... DONE
[17:03:46.155] run() for ‘Future’ ...
[17:03:46.155] - state: ‘created’
[17:03:46.155] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:46.169] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:46.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:46.169]   - Field: ‘node’
[17:03:46.169]   - Field: ‘label’
[17:03:46.169]   - Field: ‘local’
[17:03:46.169]   - Field: ‘owner’
[17:03:46.170]   - Field: ‘envir’
[17:03:46.170]   - Field: ‘workers’
[17:03:46.170]   - Field: ‘packages’
[17:03:46.170]   - Field: ‘gc’
[17:03:46.170]   - Field: ‘conditions’
[17:03:46.170]   - Field: ‘persistent’
[17:03:46.170]   - Field: ‘expr’
[17:03:46.170]   - Field: ‘uuid’
[17:03:46.170]   - Field: ‘seed’
[17:03:46.170]   - Field: ‘version’
[17:03:46.170]   - Field: ‘result’
[17:03:46.171]   - Field: ‘asynchronous’
[17:03:46.171]   - Field: ‘calls’
[17:03:46.171]   - Field: ‘globals’
[17:03:46.171]   - Field: ‘stdout’
[17:03:46.171]   - Field: ‘earlySignal’
[17:03:46.171]   - Field: ‘lazy’
[17:03:46.171]   - Field: ‘state’
[17:03:46.171] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:46.171] - Launch lazy future ...
[17:03:46.172] Packages needed by the future expression (n = 0): <none>
[17:03:46.172] Packages needed by future strategies (n = 0): <none>
[17:03:46.172] {
[17:03:46.172]     {
[17:03:46.172]         {
[17:03:46.172]             ...future.startTime <- base::Sys.time()
[17:03:46.172]             {
[17:03:46.172]                 {
[17:03:46.172]                   {
[17:03:46.172]                     {
[17:03:46.172]                       base::local({
[17:03:46.172]                         has_future <- base::requireNamespace("future", 
[17:03:46.172]                           quietly = TRUE)
[17:03:46.172]                         if (has_future) {
[17:03:46.172]                           ns <- base::getNamespace("future")
[17:03:46.172]                           version <- ns[[".package"]][["version"]]
[17:03:46.172]                           if (is.null(version)) 
[17:03:46.172]                             version <- utils::packageVersion("future")
[17:03:46.172]                         }
[17:03:46.172]                         else {
[17:03:46.172]                           version <- NULL
[17:03:46.172]                         }
[17:03:46.172]                         if (!has_future || version < "1.8.0") {
[17:03:46.172]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:46.172]                             "", base::R.version$version.string), 
[17:03:46.172]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:46.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:46.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:46.172]                               "release", "version")], collapse = " "), 
[17:03:46.172]                             hostname = base::Sys.info()[["nodename"]])
[17:03:46.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:46.172]                             info)
[17:03:46.172]                           info <- base::paste(info, collapse = "; ")
[17:03:46.172]                           if (!has_future) {
[17:03:46.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:46.172]                               info)
[17:03:46.172]                           }
[17:03:46.172]                           else {
[17:03:46.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:46.172]                               info, version)
[17:03:46.172]                           }
[17:03:46.172]                           base::stop(msg)
[17:03:46.172]                         }
[17:03:46.172]                       })
[17:03:46.172]                     }
[17:03:46.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:46.172]                     base::options(mc.cores = 1L)
[17:03:46.172]                   }
[17:03:46.172]                   ...future.strategy.old <- future::plan("list")
[17:03:46.172]                   options(future.plan = NULL)
[17:03:46.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:46.172]                 }
[17:03:46.172]                 ...future.workdir <- getwd()
[17:03:46.172]             }
[17:03:46.172]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:46.172]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:46.172]         }
[17:03:46.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:46.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:46.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:46.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:46.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:46.172]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:46.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:46.172]             base::names(...future.oldOptions))
[17:03:46.172]     }
[17:03:46.172]     if (FALSE) {
[17:03:46.172]     }
[17:03:46.172]     else {
[17:03:46.172]         if (TRUE) {
[17:03:46.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:46.172]                 open = "w")
[17:03:46.172]         }
[17:03:46.172]         else {
[17:03:46.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:46.172]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:46.172]         }
[17:03:46.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:46.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:46.172]             base::sink(type = "output", split = FALSE)
[17:03:46.172]             base::close(...future.stdout)
[17:03:46.172]         }, add = TRUE)
[17:03:46.172]     }
[17:03:46.172]     ...future.frame <- base::sys.nframe()
[17:03:46.172]     ...future.conditions <- base::list()
[17:03:46.172]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:46.172]     if (FALSE) {
[17:03:46.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:46.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:46.172]     }
[17:03:46.172]     ...future.result <- base::tryCatch({
[17:03:46.172]         base::withCallingHandlers({
[17:03:46.172]             ...future.value <- base::withVisible(base::local({
[17:03:46.172]                 ...future.makeSendCondition <- base::local({
[17:03:46.172]                   sendCondition <- NULL
[17:03:46.172]                   function(frame = 1L) {
[17:03:46.172]                     if (is.function(sendCondition)) 
[17:03:46.172]                       return(sendCondition)
[17:03:46.172]                     ns <- getNamespace("parallel")
[17:03:46.172]                     if (exists("sendData", mode = "function", 
[17:03:46.172]                       envir = ns)) {
[17:03:46.172]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:46.172]                         envir = ns)
[17:03:46.172]                       envir <- sys.frame(frame)
[17:03:46.172]                       master <- NULL
[17:03:46.172]                       while (!identical(envir, .GlobalEnv) && 
[17:03:46.172]                         !identical(envir, emptyenv())) {
[17:03:46.172]                         if (exists("master", mode = "list", envir = envir, 
[17:03:46.172]                           inherits = FALSE)) {
[17:03:46.172]                           master <- get("master", mode = "list", 
[17:03:46.172]                             envir = envir, inherits = FALSE)
[17:03:46.172]                           if (inherits(master, c("SOCKnode", 
[17:03:46.172]                             "SOCK0node"))) {
[17:03:46.172]                             sendCondition <<- function(cond) {
[17:03:46.172]                               data <- list(type = "VALUE", value = cond, 
[17:03:46.172]                                 success = TRUE)
[17:03:46.172]                               parallel_sendData(master, data)
[17:03:46.172]                             }
[17:03:46.172]                             return(sendCondition)
[17:03:46.172]                           }
[17:03:46.172]                         }
[17:03:46.172]                         frame <- frame + 1L
[17:03:46.172]                         envir <- sys.frame(frame)
[17:03:46.172]                       }
[17:03:46.172]                     }
[17:03:46.172]                     sendCondition <<- function(cond) NULL
[17:03:46.172]                   }
[17:03:46.172]                 })
[17:03:46.172]                 withCallingHandlers({
[17:03:46.172]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:46.172]                 }, immediateCondition = function(cond) {
[17:03:46.172]                   sendCondition <- ...future.makeSendCondition()
[17:03:46.172]                   sendCondition(cond)
[17:03:46.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.172]                   {
[17:03:46.172]                     inherits <- base::inherits
[17:03:46.172]                     invokeRestart <- base::invokeRestart
[17:03:46.172]                     is.null <- base::is.null
[17:03:46.172]                     muffled <- FALSE
[17:03:46.172]                     if (inherits(cond, "message")) {
[17:03:46.172]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:46.172]                       if (muffled) 
[17:03:46.172]                         invokeRestart("muffleMessage")
[17:03:46.172]                     }
[17:03:46.172]                     else if (inherits(cond, "warning")) {
[17:03:46.172]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:46.172]                       if (muffled) 
[17:03:46.172]                         invokeRestart("muffleWarning")
[17:03:46.172]                     }
[17:03:46.172]                     else if (inherits(cond, "condition")) {
[17:03:46.172]                       if (!is.null(pattern)) {
[17:03:46.172]                         computeRestarts <- base::computeRestarts
[17:03:46.172]                         grepl <- base::grepl
[17:03:46.172]                         restarts <- computeRestarts(cond)
[17:03:46.172]                         for (restart in restarts) {
[17:03:46.172]                           name <- restart$name
[17:03:46.172]                           if (is.null(name)) 
[17:03:46.172]                             next
[17:03:46.172]                           if (!grepl(pattern, name)) 
[17:03:46.172]                             next
[17:03:46.172]                           invokeRestart(restart)
[17:03:46.172]                           muffled <- TRUE
[17:03:46.172]                           break
[17:03:46.172]                         }
[17:03:46.172]                       }
[17:03:46.172]                     }
[17:03:46.172]                     invisible(muffled)
[17:03:46.172]                   }
[17:03:46.172]                   muffleCondition(cond)
[17:03:46.172]                 })
[17:03:46.172]             }))
[17:03:46.172]             future::FutureResult(value = ...future.value$value, 
[17:03:46.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.172]                   ...future.rng), globalenv = if (FALSE) 
[17:03:46.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:46.172]                     ...future.globalenv.names))
[17:03:46.172]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:46.172]         }, condition = base::local({
[17:03:46.172]             c <- base::c
[17:03:46.172]             inherits <- base::inherits
[17:03:46.172]             invokeRestart <- base::invokeRestart
[17:03:46.172]             length <- base::length
[17:03:46.172]             list <- base::list
[17:03:46.172]             seq.int <- base::seq.int
[17:03:46.172]             signalCondition <- base::signalCondition
[17:03:46.172]             sys.calls <- base::sys.calls
[17:03:46.172]             `[[` <- base::`[[`
[17:03:46.172]             `+` <- base::`+`
[17:03:46.172]             `<<-` <- base::`<<-`
[17:03:46.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:46.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:46.172]                   3L)]
[17:03:46.172]             }
[17:03:46.172]             function(cond) {
[17:03:46.172]                 is_error <- inherits(cond, "error")
[17:03:46.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:46.172]                   NULL)
[17:03:46.172]                 if (is_error) {
[17:03:46.172]                   sessionInformation <- function() {
[17:03:46.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:46.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:46.172]                       search = base::search(), system = base::Sys.info())
[17:03:46.172]                   }
[17:03:46.172]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:46.172]                     cond$call), session = sessionInformation(), 
[17:03:46.172]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:46.172]                   signalCondition(cond)
[17:03:46.172]                 }
[17:03:46.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:46.172]                 "immediateCondition"))) {
[17:03:46.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:46.172]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:46.172]                   if (TRUE && !signal) {
[17:03:46.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.172]                     {
[17:03:46.172]                       inherits <- base::inherits
[17:03:46.172]                       invokeRestart <- base::invokeRestart
[17:03:46.172]                       is.null <- base::is.null
[17:03:46.172]                       muffled <- FALSE
[17:03:46.172]                       if (inherits(cond, "message")) {
[17:03:46.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.172]                         if (muffled) 
[17:03:46.172]                           invokeRestart("muffleMessage")
[17:03:46.172]                       }
[17:03:46.172]                       else if (inherits(cond, "warning")) {
[17:03:46.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.172]                         if (muffled) 
[17:03:46.172]                           invokeRestart("muffleWarning")
[17:03:46.172]                       }
[17:03:46.172]                       else if (inherits(cond, "condition")) {
[17:03:46.172]                         if (!is.null(pattern)) {
[17:03:46.172]                           computeRestarts <- base::computeRestarts
[17:03:46.172]                           grepl <- base::grepl
[17:03:46.172]                           restarts <- computeRestarts(cond)
[17:03:46.172]                           for (restart in restarts) {
[17:03:46.172]                             name <- restart$name
[17:03:46.172]                             if (is.null(name)) 
[17:03:46.172]                               next
[17:03:46.172]                             if (!grepl(pattern, name)) 
[17:03:46.172]                               next
[17:03:46.172]                             invokeRestart(restart)
[17:03:46.172]                             muffled <- TRUE
[17:03:46.172]                             break
[17:03:46.172]                           }
[17:03:46.172]                         }
[17:03:46.172]                       }
[17:03:46.172]                       invisible(muffled)
[17:03:46.172]                     }
[17:03:46.172]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.172]                   }
[17:03:46.172]                 }
[17:03:46.172]                 else {
[17:03:46.172]                   if (TRUE) {
[17:03:46.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.172]                     {
[17:03:46.172]                       inherits <- base::inherits
[17:03:46.172]                       invokeRestart <- base::invokeRestart
[17:03:46.172]                       is.null <- base::is.null
[17:03:46.172]                       muffled <- FALSE
[17:03:46.172]                       if (inherits(cond, "message")) {
[17:03:46.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.172]                         if (muffled) 
[17:03:46.172]                           invokeRestart("muffleMessage")
[17:03:46.172]                       }
[17:03:46.172]                       else if (inherits(cond, "warning")) {
[17:03:46.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.172]                         if (muffled) 
[17:03:46.172]                           invokeRestart("muffleWarning")
[17:03:46.172]                       }
[17:03:46.172]                       else if (inherits(cond, "condition")) {
[17:03:46.172]                         if (!is.null(pattern)) {
[17:03:46.172]                           computeRestarts <- base::computeRestarts
[17:03:46.172]                           grepl <- base::grepl
[17:03:46.172]                           restarts <- computeRestarts(cond)
[17:03:46.172]                           for (restart in restarts) {
[17:03:46.172]                             name <- restart$name
[17:03:46.172]                             if (is.null(name)) 
[17:03:46.172]                               next
[17:03:46.172]                             if (!grepl(pattern, name)) 
[17:03:46.172]                               next
[17:03:46.172]                             invokeRestart(restart)
[17:03:46.172]                             muffled <- TRUE
[17:03:46.172]                             break
[17:03:46.172]                           }
[17:03:46.172]                         }
[17:03:46.172]                       }
[17:03:46.172]                       invisible(muffled)
[17:03:46.172]                     }
[17:03:46.172]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.172]                   }
[17:03:46.172]                 }
[17:03:46.172]             }
[17:03:46.172]         }))
[17:03:46.172]     }, error = function(ex) {
[17:03:46.172]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:46.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.172]                 ...future.rng), started = ...future.startTime, 
[17:03:46.172]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:46.172]             version = "1.8"), class = "FutureResult")
[17:03:46.172]     }, finally = {
[17:03:46.172]         if (!identical(...future.workdir, getwd())) 
[17:03:46.172]             setwd(...future.workdir)
[17:03:46.172]         {
[17:03:46.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:46.172]                 ...future.oldOptions$nwarnings <- NULL
[17:03:46.172]             }
[17:03:46.172]             base::options(...future.oldOptions)
[17:03:46.172]             if (.Platform$OS.type == "windows") {
[17:03:46.172]                 old_names <- names(...future.oldEnvVars)
[17:03:46.172]                 envs <- base::Sys.getenv()
[17:03:46.172]                 names <- names(envs)
[17:03:46.172]                 common <- intersect(names, old_names)
[17:03:46.172]                 added <- setdiff(names, old_names)
[17:03:46.172]                 removed <- setdiff(old_names, names)
[17:03:46.172]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:46.172]                   envs[common]]
[17:03:46.172]                 NAMES <- toupper(changed)
[17:03:46.172]                 args <- list()
[17:03:46.172]                 for (kk in seq_along(NAMES)) {
[17:03:46.172]                   name <- changed[[kk]]
[17:03:46.172]                   NAME <- NAMES[[kk]]
[17:03:46.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.172]                     next
[17:03:46.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.172]                 }
[17:03:46.172]                 NAMES <- toupper(added)
[17:03:46.172]                 for (kk in seq_along(NAMES)) {
[17:03:46.172]                   name <- added[[kk]]
[17:03:46.172]                   NAME <- NAMES[[kk]]
[17:03:46.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.172]                     next
[17:03:46.172]                   args[[name]] <- ""
[17:03:46.172]                 }
[17:03:46.172]                 NAMES <- toupper(removed)
[17:03:46.172]                 for (kk in seq_along(NAMES)) {
[17:03:46.172]                   name <- removed[[kk]]
[17:03:46.172]                   NAME <- NAMES[[kk]]
[17:03:46.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.172]                     next
[17:03:46.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.172]                 }
[17:03:46.172]                 if (length(args) > 0) 
[17:03:46.172]                   base::do.call(base::Sys.setenv, args = args)
[17:03:46.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:46.172]             }
[17:03:46.172]             else {
[17:03:46.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:46.172]             }
[17:03:46.172]             {
[17:03:46.172]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:46.172]                   0L) {
[17:03:46.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:46.172]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:46.172]                   base::options(opts)
[17:03:46.172]                 }
[17:03:46.172]                 {
[17:03:46.172]                   {
[17:03:46.172]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:46.172]                     NULL
[17:03:46.172]                   }
[17:03:46.172]                   options(future.plan = NULL)
[17:03:46.172]                   if (is.na(NA_character_)) 
[17:03:46.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:46.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:46.172]                     .init = FALSE)
[17:03:46.172]                 }
[17:03:46.172]             }
[17:03:46.172]         }
[17:03:46.172]     })
[17:03:46.172]     if (TRUE) {
[17:03:46.172]         base::sink(type = "output", split = FALSE)
[17:03:46.172]         if (TRUE) {
[17:03:46.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:46.172]         }
[17:03:46.172]         else {
[17:03:46.172]             ...future.result["stdout"] <- base::list(NULL)
[17:03:46.172]         }
[17:03:46.172]         base::close(...future.stdout)
[17:03:46.172]         ...future.stdout <- NULL
[17:03:46.172]     }
[17:03:46.172]     ...future.result$conditions <- ...future.conditions
[17:03:46.172]     ...future.result$finished <- base::Sys.time()
[17:03:46.172]     ...future.result
[17:03:46.172] }
[17:03:46.175] MultisessionFuture started
[17:03:46.175] - Launch lazy future ... done
[17:03:46.175] run() for ‘MultisessionFuture’ ... done
[17:03:46.177] receiveMessageFromWorker() for ClusterFuture ...
[17:03:46.177] - Validating connection of MultisessionFuture
[17:03:46.177] - received message: FutureResult
[17:03:46.178] - Received FutureResult
[17:03:46.178] - Erased future from FutureRegistry
[17:03:46.178] result() for ClusterFuture ...
[17:03:46.178] - result already collected: FutureResult
[17:03:46.178] result() for ClusterFuture ... done
[17:03:46.178] signalConditions() ...
[17:03:46.178]  - include = ‘immediateCondition’
[17:03:46.178]  - exclude = 
[17:03:46.178]  - resignal = FALSE
[17:03:46.178]  - Number of conditions: 1
[17:03:46.178] signalConditions() ... done
[17:03:46.179] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:46.179] A MultisessionFuture was resolved (result was not collected)
[17:03:46.179] getGlobalsAndPackages() ...
[17:03:46.179] Searching for globals...
[17:03:46.180] - globals found: [2] ‘list’, ‘stop’
[17:03:46.180] Searching for globals ... DONE
[17:03:46.180] Resolving globals: FALSE
[17:03:46.180] 
[17:03:46.180] 
[17:03:46.180] getGlobalsAndPackages() ... DONE
[17:03:46.180] run() for ‘Future’ ...
[17:03:46.181] - state: ‘created’
[17:03:46.181] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:46.194] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:46.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:46.194]   - Field: ‘node’
[17:03:46.195]   - Field: ‘label’
[17:03:46.195]   - Field: ‘local’
[17:03:46.195]   - Field: ‘owner’
[17:03:46.195]   - Field: ‘envir’
[17:03:46.195]   - Field: ‘workers’
[17:03:46.195]   - Field: ‘packages’
[17:03:46.195]   - Field: ‘gc’
[17:03:46.195]   - Field: ‘conditions’
[17:03:46.195]   - Field: ‘persistent’
[17:03:46.195]   - Field: ‘expr’
[17:03:46.195]   - Field: ‘uuid’
[17:03:46.196]   - Field: ‘seed’
[17:03:46.196]   - Field: ‘version’
[17:03:46.196]   - Field: ‘result’
[17:03:46.196]   - Field: ‘asynchronous’
[17:03:46.196]   - Field: ‘calls’
[17:03:46.196]   - Field: ‘globals’
[17:03:46.196]   - Field: ‘stdout’
[17:03:46.196]   - Field: ‘earlySignal’
[17:03:46.196]   - Field: ‘lazy’
[17:03:46.196]   - Field: ‘state’
[17:03:46.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:46.197] - Launch lazy future ...
[17:03:46.197] Packages needed by the future expression (n = 0): <none>
[17:03:46.197] Packages needed by future strategies (n = 0): <none>
[17:03:46.197] {
[17:03:46.197]     {
[17:03:46.197]         {
[17:03:46.197]             ...future.startTime <- base::Sys.time()
[17:03:46.197]             {
[17:03:46.197]                 {
[17:03:46.197]                   {
[17:03:46.197]                     {
[17:03:46.197]                       base::local({
[17:03:46.197]                         has_future <- base::requireNamespace("future", 
[17:03:46.197]                           quietly = TRUE)
[17:03:46.197]                         if (has_future) {
[17:03:46.197]                           ns <- base::getNamespace("future")
[17:03:46.197]                           version <- ns[[".package"]][["version"]]
[17:03:46.197]                           if (is.null(version)) 
[17:03:46.197]                             version <- utils::packageVersion("future")
[17:03:46.197]                         }
[17:03:46.197]                         else {
[17:03:46.197]                           version <- NULL
[17:03:46.197]                         }
[17:03:46.197]                         if (!has_future || version < "1.8.0") {
[17:03:46.197]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:46.197]                             "", base::R.version$version.string), 
[17:03:46.197]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:46.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:46.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:46.197]                               "release", "version")], collapse = " "), 
[17:03:46.197]                             hostname = base::Sys.info()[["nodename"]])
[17:03:46.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:46.197]                             info)
[17:03:46.197]                           info <- base::paste(info, collapse = "; ")
[17:03:46.197]                           if (!has_future) {
[17:03:46.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:46.197]                               info)
[17:03:46.197]                           }
[17:03:46.197]                           else {
[17:03:46.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:46.197]                               info, version)
[17:03:46.197]                           }
[17:03:46.197]                           base::stop(msg)
[17:03:46.197]                         }
[17:03:46.197]                       })
[17:03:46.197]                     }
[17:03:46.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:46.197]                     base::options(mc.cores = 1L)
[17:03:46.197]                   }
[17:03:46.197]                   ...future.strategy.old <- future::plan("list")
[17:03:46.197]                   options(future.plan = NULL)
[17:03:46.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:46.197]                 }
[17:03:46.197]                 ...future.workdir <- getwd()
[17:03:46.197]             }
[17:03:46.197]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:46.197]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:46.197]         }
[17:03:46.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:46.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:46.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:46.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:46.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:46.197]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:46.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:46.197]             base::names(...future.oldOptions))
[17:03:46.197]     }
[17:03:46.197]     if (FALSE) {
[17:03:46.197]     }
[17:03:46.197]     else {
[17:03:46.197]         if (TRUE) {
[17:03:46.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:46.197]                 open = "w")
[17:03:46.197]         }
[17:03:46.197]         else {
[17:03:46.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:46.197]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:46.197]         }
[17:03:46.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:46.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:46.197]             base::sink(type = "output", split = FALSE)
[17:03:46.197]             base::close(...future.stdout)
[17:03:46.197]         }, add = TRUE)
[17:03:46.197]     }
[17:03:46.197]     ...future.frame <- base::sys.nframe()
[17:03:46.197]     ...future.conditions <- base::list()
[17:03:46.197]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:46.197]     if (FALSE) {
[17:03:46.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:46.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:46.197]     }
[17:03:46.197]     ...future.result <- base::tryCatch({
[17:03:46.197]         base::withCallingHandlers({
[17:03:46.197]             ...future.value <- base::withVisible(base::local({
[17:03:46.197]                 ...future.makeSendCondition <- base::local({
[17:03:46.197]                   sendCondition <- NULL
[17:03:46.197]                   function(frame = 1L) {
[17:03:46.197]                     if (is.function(sendCondition)) 
[17:03:46.197]                       return(sendCondition)
[17:03:46.197]                     ns <- getNamespace("parallel")
[17:03:46.197]                     if (exists("sendData", mode = "function", 
[17:03:46.197]                       envir = ns)) {
[17:03:46.197]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:46.197]                         envir = ns)
[17:03:46.197]                       envir <- sys.frame(frame)
[17:03:46.197]                       master <- NULL
[17:03:46.197]                       while (!identical(envir, .GlobalEnv) && 
[17:03:46.197]                         !identical(envir, emptyenv())) {
[17:03:46.197]                         if (exists("master", mode = "list", envir = envir, 
[17:03:46.197]                           inherits = FALSE)) {
[17:03:46.197]                           master <- get("master", mode = "list", 
[17:03:46.197]                             envir = envir, inherits = FALSE)
[17:03:46.197]                           if (inherits(master, c("SOCKnode", 
[17:03:46.197]                             "SOCK0node"))) {
[17:03:46.197]                             sendCondition <<- function(cond) {
[17:03:46.197]                               data <- list(type = "VALUE", value = cond, 
[17:03:46.197]                                 success = TRUE)
[17:03:46.197]                               parallel_sendData(master, data)
[17:03:46.197]                             }
[17:03:46.197]                             return(sendCondition)
[17:03:46.197]                           }
[17:03:46.197]                         }
[17:03:46.197]                         frame <- frame + 1L
[17:03:46.197]                         envir <- sys.frame(frame)
[17:03:46.197]                       }
[17:03:46.197]                     }
[17:03:46.197]                     sendCondition <<- function(cond) NULL
[17:03:46.197]                   }
[17:03:46.197]                 })
[17:03:46.197]                 withCallingHandlers({
[17:03:46.197]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:46.197]                 }, immediateCondition = function(cond) {
[17:03:46.197]                   sendCondition <- ...future.makeSendCondition()
[17:03:46.197]                   sendCondition(cond)
[17:03:46.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.197]                   {
[17:03:46.197]                     inherits <- base::inherits
[17:03:46.197]                     invokeRestart <- base::invokeRestart
[17:03:46.197]                     is.null <- base::is.null
[17:03:46.197]                     muffled <- FALSE
[17:03:46.197]                     if (inherits(cond, "message")) {
[17:03:46.197]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:46.197]                       if (muffled) 
[17:03:46.197]                         invokeRestart("muffleMessage")
[17:03:46.197]                     }
[17:03:46.197]                     else if (inherits(cond, "warning")) {
[17:03:46.197]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:46.197]                       if (muffled) 
[17:03:46.197]                         invokeRestart("muffleWarning")
[17:03:46.197]                     }
[17:03:46.197]                     else if (inherits(cond, "condition")) {
[17:03:46.197]                       if (!is.null(pattern)) {
[17:03:46.197]                         computeRestarts <- base::computeRestarts
[17:03:46.197]                         grepl <- base::grepl
[17:03:46.197]                         restarts <- computeRestarts(cond)
[17:03:46.197]                         for (restart in restarts) {
[17:03:46.197]                           name <- restart$name
[17:03:46.197]                           if (is.null(name)) 
[17:03:46.197]                             next
[17:03:46.197]                           if (!grepl(pattern, name)) 
[17:03:46.197]                             next
[17:03:46.197]                           invokeRestart(restart)
[17:03:46.197]                           muffled <- TRUE
[17:03:46.197]                           break
[17:03:46.197]                         }
[17:03:46.197]                       }
[17:03:46.197]                     }
[17:03:46.197]                     invisible(muffled)
[17:03:46.197]                   }
[17:03:46.197]                   muffleCondition(cond)
[17:03:46.197]                 })
[17:03:46.197]             }))
[17:03:46.197]             future::FutureResult(value = ...future.value$value, 
[17:03:46.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.197]                   ...future.rng), globalenv = if (FALSE) 
[17:03:46.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:46.197]                     ...future.globalenv.names))
[17:03:46.197]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:46.197]         }, condition = base::local({
[17:03:46.197]             c <- base::c
[17:03:46.197]             inherits <- base::inherits
[17:03:46.197]             invokeRestart <- base::invokeRestart
[17:03:46.197]             length <- base::length
[17:03:46.197]             list <- base::list
[17:03:46.197]             seq.int <- base::seq.int
[17:03:46.197]             signalCondition <- base::signalCondition
[17:03:46.197]             sys.calls <- base::sys.calls
[17:03:46.197]             `[[` <- base::`[[`
[17:03:46.197]             `+` <- base::`+`
[17:03:46.197]             `<<-` <- base::`<<-`
[17:03:46.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:46.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:46.197]                   3L)]
[17:03:46.197]             }
[17:03:46.197]             function(cond) {
[17:03:46.197]                 is_error <- inherits(cond, "error")
[17:03:46.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:46.197]                   NULL)
[17:03:46.197]                 if (is_error) {
[17:03:46.197]                   sessionInformation <- function() {
[17:03:46.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:46.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:46.197]                       search = base::search(), system = base::Sys.info())
[17:03:46.197]                   }
[17:03:46.197]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:46.197]                     cond$call), session = sessionInformation(), 
[17:03:46.197]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:46.197]                   signalCondition(cond)
[17:03:46.197]                 }
[17:03:46.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:46.197]                 "immediateCondition"))) {
[17:03:46.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:46.197]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:46.197]                   if (TRUE && !signal) {
[17:03:46.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.197]                     {
[17:03:46.197]                       inherits <- base::inherits
[17:03:46.197]                       invokeRestart <- base::invokeRestart
[17:03:46.197]                       is.null <- base::is.null
[17:03:46.197]                       muffled <- FALSE
[17:03:46.197]                       if (inherits(cond, "message")) {
[17:03:46.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.197]                         if (muffled) 
[17:03:46.197]                           invokeRestart("muffleMessage")
[17:03:46.197]                       }
[17:03:46.197]                       else if (inherits(cond, "warning")) {
[17:03:46.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.197]                         if (muffled) 
[17:03:46.197]                           invokeRestart("muffleWarning")
[17:03:46.197]                       }
[17:03:46.197]                       else if (inherits(cond, "condition")) {
[17:03:46.197]                         if (!is.null(pattern)) {
[17:03:46.197]                           computeRestarts <- base::computeRestarts
[17:03:46.197]                           grepl <- base::grepl
[17:03:46.197]                           restarts <- computeRestarts(cond)
[17:03:46.197]                           for (restart in restarts) {
[17:03:46.197]                             name <- restart$name
[17:03:46.197]                             if (is.null(name)) 
[17:03:46.197]                               next
[17:03:46.197]                             if (!grepl(pattern, name)) 
[17:03:46.197]                               next
[17:03:46.197]                             invokeRestart(restart)
[17:03:46.197]                             muffled <- TRUE
[17:03:46.197]                             break
[17:03:46.197]                           }
[17:03:46.197]                         }
[17:03:46.197]                       }
[17:03:46.197]                       invisible(muffled)
[17:03:46.197]                     }
[17:03:46.197]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.197]                   }
[17:03:46.197]                 }
[17:03:46.197]                 else {
[17:03:46.197]                   if (TRUE) {
[17:03:46.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.197]                     {
[17:03:46.197]                       inherits <- base::inherits
[17:03:46.197]                       invokeRestart <- base::invokeRestart
[17:03:46.197]                       is.null <- base::is.null
[17:03:46.197]                       muffled <- FALSE
[17:03:46.197]                       if (inherits(cond, "message")) {
[17:03:46.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.197]                         if (muffled) 
[17:03:46.197]                           invokeRestart("muffleMessage")
[17:03:46.197]                       }
[17:03:46.197]                       else if (inherits(cond, "warning")) {
[17:03:46.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.197]                         if (muffled) 
[17:03:46.197]                           invokeRestart("muffleWarning")
[17:03:46.197]                       }
[17:03:46.197]                       else if (inherits(cond, "condition")) {
[17:03:46.197]                         if (!is.null(pattern)) {
[17:03:46.197]                           computeRestarts <- base::computeRestarts
[17:03:46.197]                           grepl <- base::grepl
[17:03:46.197]                           restarts <- computeRestarts(cond)
[17:03:46.197]                           for (restart in restarts) {
[17:03:46.197]                             name <- restart$name
[17:03:46.197]                             if (is.null(name)) 
[17:03:46.197]                               next
[17:03:46.197]                             if (!grepl(pattern, name)) 
[17:03:46.197]                               next
[17:03:46.197]                             invokeRestart(restart)
[17:03:46.197]                             muffled <- TRUE
[17:03:46.197]                             break
[17:03:46.197]                           }
[17:03:46.197]                         }
[17:03:46.197]                       }
[17:03:46.197]                       invisible(muffled)
[17:03:46.197]                     }
[17:03:46.197]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.197]                   }
[17:03:46.197]                 }
[17:03:46.197]             }
[17:03:46.197]         }))
[17:03:46.197]     }, error = function(ex) {
[17:03:46.197]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:46.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.197]                 ...future.rng), started = ...future.startTime, 
[17:03:46.197]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:46.197]             version = "1.8"), class = "FutureResult")
[17:03:46.197]     }, finally = {
[17:03:46.197]         if (!identical(...future.workdir, getwd())) 
[17:03:46.197]             setwd(...future.workdir)
[17:03:46.197]         {
[17:03:46.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:46.197]                 ...future.oldOptions$nwarnings <- NULL
[17:03:46.197]             }
[17:03:46.197]             base::options(...future.oldOptions)
[17:03:46.197]             if (.Platform$OS.type == "windows") {
[17:03:46.197]                 old_names <- names(...future.oldEnvVars)
[17:03:46.197]                 envs <- base::Sys.getenv()
[17:03:46.197]                 names <- names(envs)
[17:03:46.197]                 common <- intersect(names, old_names)
[17:03:46.197]                 added <- setdiff(names, old_names)
[17:03:46.197]                 removed <- setdiff(old_names, names)
[17:03:46.197]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:46.197]                   envs[common]]
[17:03:46.197]                 NAMES <- toupper(changed)
[17:03:46.197]                 args <- list()
[17:03:46.197]                 for (kk in seq_along(NAMES)) {
[17:03:46.197]                   name <- changed[[kk]]
[17:03:46.197]                   NAME <- NAMES[[kk]]
[17:03:46.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.197]                     next
[17:03:46.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.197]                 }
[17:03:46.197]                 NAMES <- toupper(added)
[17:03:46.197]                 for (kk in seq_along(NAMES)) {
[17:03:46.197]                   name <- added[[kk]]
[17:03:46.197]                   NAME <- NAMES[[kk]]
[17:03:46.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.197]                     next
[17:03:46.197]                   args[[name]] <- ""
[17:03:46.197]                 }
[17:03:46.197]                 NAMES <- toupper(removed)
[17:03:46.197]                 for (kk in seq_along(NAMES)) {
[17:03:46.197]                   name <- removed[[kk]]
[17:03:46.197]                   NAME <- NAMES[[kk]]
[17:03:46.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.197]                     next
[17:03:46.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.197]                 }
[17:03:46.197]                 if (length(args) > 0) 
[17:03:46.197]                   base::do.call(base::Sys.setenv, args = args)
[17:03:46.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:46.197]             }
[17:03:46.197]             else {
[17:03:46.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:46.197]             }
[17:03:46.197]             {
[17:03:46.197]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:46.197]                   0L) {
[17:03:46.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:46.197]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:46.197]                   base::options(opts)
[17:03:46.197]                 }
[17:03:46.197]                 {
[17:03:46.197]                   {
[17:03:46.197]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:46.197]                     NULL
[17:03:46.197]                   }
[17:03:46.197]                   options(future.plan = NULL)
[17:03:46.197]                   if (is.na(NA_character_)) 
[17:03:46.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:46.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:46.197]                     .init = FALSE)
[17:03:46.197]                 }
[17:03:46.197]             }
[17:03:46.197]         }
[17:03:46.197]     })
[17:03:46.197]     if (TRUE) {
[17:03:46.197]         base::sink(type = "output", split = FALSE)
[17:03:46.197]         if (TRUE) {
[17:03:46.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:46.197]         }
[17:03:46.197]         else {
[17:03:46.197]             ...future.result["stdout"] <- base::list(NULL)
[17:03:46.197]         }
[17:03:46.197]         base::close(...future.stdout)
[17:03:46.197]         ...future.stdout <- NULL
[17:03:46.197]     }
[17:03:46.197]     ...future.result$conditions <- ...future.conditions
[17:03:46.197]     ...future.result$finished <- base::Sys.time()
[17:03:46.197]     ...future.result
[17:03:46.197] }
[17:03:46.200] MultisessionFuture started
[17:03:46.200] - Launch lazy future ... done
[17:03:46.200] run() for ‘MultisessionFuture’ ... done
[17:03:46.202] receiveMessageFromWorker() for ClusterFuture ...
[17:03:46.202] - Validating connection of MultisessionFuture
[17:03:46.202] - received message: FutureResult
[17:03:46.203] - Received FutureResult
[17:03:46.203] - Erased future from FutureRegistry
[17:03:46.203] result() for ClusterFuture ...
[17:03:46.203] - result already collected: FutureResult
[17:03:46.203] result() for ClusterFuture ... done
[17:03:46.203] signalConditions() ...
[17:03:46.203]  - include = ‘immediateCondition’
[17:03:46.203]  - exclude = 
[17:03:46.203]  - resignal = FALSE
[17:03:46.203]  - Number of conditions: 1
[17:03:46.203] signalConditions() ... done
[17:03:46.204] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:46.204] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[17:03:46.204] getGlobalsAndPackages() ...
[17:03:46.204] Searching for globals...
[17:03:46.205] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:46.205] Searching for globals ... DONE
[17:03:46.205] Resolving globals: FALSE
[17:03:46.206] 
[17:03:46.206] 
[17:03:46.206] getGlobalsAndPackages() ... DONE
[17:03:46.208] run() for ‘Future’ ...
[17:03:46.208] - state: ‘created’
[17:03:46.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:46.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:46.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:46.222]   - Field: ‘node’
[17:03:46.222]   - Field: ‘label’
[17:03:46.223]   - Field: ‘local’
[17:03:46.223]   - Field: ‘owner’
[17:03:46.223]   - Field: ‘envir’
[17:03:46.223]   - Field: ‘workers’
[17:03:46.223]   - Field: ‘packages’
[17:03:46.223]   - Field: ‘gc’
[17:03:46.223]   - Field: ‘conditions’
[17:03:46.223]   - Field: ‘persistent’
[17:03:46.223]   - Field: ‘expr’
[17:03:46.223]   - Field: ‘uuid’
[17:03:46.223]   - Field: ‘seed’
[17:03:46.224]   - Field: ‘version’
[17:03:46.224]   - Field: ‘result’
[17:03:46.224]   - Field: ‘asynchronous’
[17:03:46.224]   - Field: ‘calls’
[17:03:46.224]   - Field: ‘globals’
[17:03:46.224]   - Field: ‘stdout’
[17:03:46.224]   - Field: ‘earlySignal’
[17:03:46.224]   - Field: ‘lazy’
[17:03:46.224]   - Field: ‘state’
[17:03:46.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:46.224] - Launch lazy future ...
[17:03:46.225] Packages needed by the future expression (n = 0): <none>
[17:03:46.225] Packages needed by future strategies (n = 0): <none>
[17:03:46.225] {
[17:03:46.225]     {
[17:03:46.225]         {
[17:03:46.225]             ...future.startTime <- base::Sys.time()
[17:03:46.225]             {
[17:03:46.225]                 {
[17:03:46.225]                   {
[17:03:46.225]                     {
[17:03:46.225]                       base::local({
[17:03:46.225]                         has_future <- base::requireNamespace("future", 
[17:03:46.225]                           quietly = TRUE)
[17:03:46.225]                         if (has_future) {
[17:03:46.225]                           ns <- base::getNamespace("future")
[17:03:46.225]                           version <- ns[[".package"]][["version"]]
[17:03:46.225]                           if (is.null(version)) 
[17:03:46.225]                             version <- utils::packageVersion("future")
[17:03:46.225]                         }
[17:03:46.225]                         else {
[17:03:46.225]                           version <- NULL
[17:03:46.225]                         }
[17:03:46.225]                         if (!has_future || version < "1.8.0") {
[17:03:46.225]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:46.225]                             "", base::R.version$version.string), 
[17:03:46.225]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:46.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:46.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:46.225]                               "release", "version")], collapse = " "), 
[17:03:46.225]                             hostname = base::Sys.info()[["nodename"]])
[17:03:46.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:46.225]                             info)
[17:03:46.225]                           info <- base::paste(info, collapse = "; ")
[17:03:46.225]                           if (!has_future) {
[17:03:46.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:46.225]                               info)
[17:03:46.225]                           }
[17:03:46.225]                           else {
[17:03:46.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:46.225]                               info, version)
[17:03:46.225]                           }
[17:03:46.225]                           base::stop(msg)
[17:03:46.225]                         }
[17:03:46.225]                       })
[17:03:46.225]                     }
[17:03:46.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:46.225]                     base::options(mc.cores = 1L)
[17:03:46.225]                   }
[17:03:46.225]                   ...future.strategy.old <- future::plan("list")
[17:03:46.225]                   options(future.plan = NULL)
[17:03:46.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:46.225]                 }
[17:03:46.225]                 ...future.workdir <- getwd()
[17:03:46.225]             }
[17:03:46.225]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:46.225]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:46.225]         }
[17:03:46.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:46.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:46.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:46.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:46.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:46.225]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:46.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:46.225]             base::names(...future.oldOptions))
[17:03:46.225]     }
[17:03:46.225]     if (FALSE) {
[17:03:46.225]     }
[17:03:46.225]     else {
[17:03:46.225]         if (TRUE) {
[17:03:46.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:46.225]                 open = "w")
[17:03:46.225]         }
[17:03:46.225]         else {
[17:03:46.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:46.225]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:46.225]         }
[17:03:46.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:46.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:46.225]             base::sink(type = "output", split = FALSE)
[17:03:46.225]             base::close(...future.stdout)
[17:03:46.225]         }, add = TRUE)
[17:03:46.225]     }
[17:03:46.225]     ...future.frame <- base::sys.nframe()
[17:03:46.225]     ...future.conditions <- base::list()
[17:03:46.225]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:46.225]     if (FALSE) {
[17:03:46.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:46.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:46.225]     }
[17:03:46.225]     ...future.result <- base::tryCatch({
[17:03:46.225]         base::withCallingHandlers({
[17:03:46.225]             ...future.value <- base::withVisible(base::local({
[17:03:46.225]                 ...future.makeSendCondition <- base::local({
[17:03:46.225]                   sendCondition <- NULL
[17:03:46.225]                   function(frame = 1L) {
[17:03:46.225]                     if (is.function(sendCondition)) 
[17:03:46.225]                       return(sendCondition)
[17:03:46.225]                     ns <- getNamespace("parallel")
[17:03:46.225]                     if (exists("sendData", mode = "function", 
[17:03:46.225]                       envir = ns)) {
[17:03:46.225]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:46.225]                         envir = ns)
[17:03:46.225]                       envir <- sys.frame(frame)
[17:03:46.225]                       master <- NULL
[17:03:46.225]                       while (!identical(envir, .GlobalEnv) && 
[17:03:46.225]                         !identical(envir, emptyenv())) {
[17:03:46.225]                         if (exists("master", mode = "list", envir = envir, 
[17:03:46.225]                           inherits = FALSE)) {
[17:03:46.225]                           master <- get("master", mode = "list", 
[17:03:46.225]                             envir = envir, inherits = FALSE)
[17:03:46.225]                           if (inherits(master, c("SOCKnode", 
[17:03:46.225]                             "SOCK0node"))) {
[17:03:46.225]                             sendCondition <<- function(cond) {
[17:03:46.225]                               data <- list(type = "VALUE", value = cond, 
[17:03:46.225]                                 success = TRUE)
[17:03:46.225]                               parallel_sendData(master, data)
[17:03:46.225]                             }
[17:03:46.225]                             return(sendCondition)
[17:03:46.225]                           }
[17:03:46.225]                         }
[17:03:46.225]                         frame <- frame + 1L
[17:03:46.225]                         envir <- sys.frame(frame)
[17:03:46.225]                       }
[17:03:46.225]                     }
[17:03:46.225]                     sendCondition <<- function(cond) NULL
[17:03:46.225]                   }
[17:03:46.225]                 })
[17:03:46.225]                 withCallingHandlers({
[17:03:46.225]                   {
[17:03:46.225]                     Sys.sleep(0.5)
[17:03:46.225]                     list(a = 1, b = 42L)
[17:03:46.225]                   }
[17:03:46.225]                 }, immediateCondition = function(cond) {
[17:03:46.225]                   sendCondition <- ...future.makeSendCondition()
[17:03:46.225]                   sendCondition(cond)
[17:03:46.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.225]                   {
[17:03:46.225]                     inherits <- base::inherits
[17:03:46.225]                     invokeRestart <- base::invokeRestart
[17:03:46.225]                     is.null <- base::is.null
[17:03:46.225]                     muffled <- FALSE
[17:03:46.225]                     if (inherits(cond, "message")) {
[17:03:46.225]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:46.225]                       if (muffled) 
[17:03:46.225]                         invokeRestart("muffleMessage")
[17:03:46.225]                     }
[17:03:46.225]                     else if (inherits(cond, "warning")) {
[17:03:46.225]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:46.225]                       if (muffled) 
[17:03:46.225]                         invokeRestart("muffleWarning")
[17:03:46.225]                     }
[17:03:46.225]                     else if (inherits(cond, "condition")) {
[17:03:46.225]                       if (!is.null(pattern)) {
[17:03:46.225]                         computeRestarts <- base::computeRestarts
[17:03:46.225]                         grepl <- base::grepl
[17:03:46.225]                         restarts <- computeRestarts(cond)
[17:03:46.225]                         for (restart in restarts) {
[17:03:46.225]                           name <- restart$name
[17:03:46.225]                           if (is.null(name)) 
[17:03:46.225]                             next
[17:03:46.225]                           if (!grepl(pattern, name)) 
[17:03:46.225]                             next
[17:03:46.225]                           invokeRestart(restart)
[17:03:46.225]                           muffled <- TRUE
[17:03:46.225]                           break
[17:03:46.225]                         }
[17:03:46.225]                       }
[17:03:46.225]                     }
[17:03:46.225]                     invisible(muffled)
[17:03:46.225]                   }
[17:03:46.225]                   muffleCondition(cond)
[17:03:46.225]                 })
[17:03:46.225]             }))
[17:03:46.225]             future::FutureResult(value = ...future.value$value, 
[17:03:46.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.225]                   ...future.rng), globalenv = if (FALSE) 
[17:03:46.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:46.225]                     ...future.globalenv.names))
[17:03:46.225]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:46.225]         }, condition = base::local({
[17:03:46.225]             c <- base::c
[17:03:46.225]             inherits <- base::inherits
[17:03:46.225]             invokeRestart <- base::invokeRestart
[17:03:46.225]             length <- base::length
[17:03:46.225]             list <- base::list
[17:03:46.225]             seq.int <- base::seq.int
[17:03:46.225]             signalCondition <- base::signalCondition
[17:03:46.225]             sys.calls <- base::sys.calls
[17:03:46.225]             `[[` <- base::`[[`
[17:03:46.225]             `+` <- base::`+`
[17:03:46.225]             `<<-` <- base::`<<-`
[17:03:46.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:46.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:46.225]                   3L)]
[17:03:46.225]             }
[17:03:46.225]             function(cond) {
[17:03:46.225]                 is_error <- inherits(cond, "error")
[17:03:46.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:46.225]                   NULL)
[17:03:46.225]                 if (is_error) {
[17:03:46.225]                   sessionInformation <- function() {
[17:03:46.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:46.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:46.225]                       search = base::search(), system = base::Sys.info())
[17:03:46.225]                   }
[17:03:46.225]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:46.225]                     cond$call), session = sessionInformation(), 
[17:03:46.225]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:46.225]                   signalCondition(cond)
[17:03:46.225]                 }
[17:03:46.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:46.225]                 "immediateCondition"))) {
[17:03:46.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:46.225]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:46.225]                   if (TRUE && !signal) {
[17:03:46.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.225]                     {
[17:03:46.225]                       inherits <- base::inherits
[17:03:46.225]                       invokeRestart <- base::invokeRestart
[17:03:46.225]                       is.null <- base::is.null
[17:03:46.225]                       muffled <- FALSE
[17:03:46.225]                       if (inherits(cond, "message")) {
[17:03:46.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.225]                         if (muffled) 
[17:03:46.225]                           invokeRestart("muffleMessage")
[17:03:46.225]                       }
[17:03:46.225]                       else if (inherits(cond, "warning")) {
[17:03:46.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.225]                         if (muffled) 
[17:03:46.225]                           invokeRestart("muffleWarning")
[17:03:46.225]                       }
[17:03:46.225]                       else if (inherits(cond, "condition")) {
[17:03:46.225]                         if (!is.null(pattern)) {
[17:03:46.225]                           computeRestarts <- base::computeRestarts
[17:03:46.225]                           grepl <- base::grepl
[17:03:46.225]                           restarts <- computeRestarts(cond)
[17:03:46.225]                           for (restart in restarts) {
[17:03:46.225]                             name <- restart$name
[17:03:46.225]                             if (is.null(name)) 
[17:03:46.225]                               next
[17:03:46.225]                             if (!grepl(pattern, name)) 
[17:03:46.225]                               next
[17:03:46.225]                             invokeRestart(restart)
[17:03:46.225]                             muffled <- TRUE
[17:03:46.225]                             break
[17:03:46.225]                           }
[17:03:46.225]                         }
[17:03:46.225]                       }
[17:03:46.225]                       invisible(muffled)
[17:03:46.225]                     }
[17:03:46.225]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.225]                   }
[17:03:46.225]                 }
[17:03:46.225]                 else {
[17:03:46.225]                   if (TRUE) {
[17:03:46.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.225]                     {
[17:03:46.225]                       inherits <- base::inherits
[17:03:46.225]                       invokeRestart <- base::invokeRestart
[17:03:46.225]                       is.null <- base::is.null
[17:03:46.225]                       muffled <- FALSE
[17:03:46.225]                       if (inherits(cond, "message")) {
[17:03:46.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.225]                         if (muffled) 
[17:03:46.225]                           invokeRestart("muffleMessage")
[17:03:46.225]                       }
[17:03:46.225]                       else if (inherits(cond, "warning")) {
[17:03:46.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.225]                         if (muffled) 
[17:03:46.225]                           invokeRestart("muffleWarning")
[17:03:46.225]                       }
[17:03:46.225]                       else if (inherits(cond, "condition")) {
[17:03:46.225]                         if (!is.null(pattern)) {
[17:03:46.225]                           computeRestarts <- base::computeRestarts
[17:03:46.225]                           grepl <- base::grepl
[17:03:46.225]                           restarts <- computeRestarts(cond)
[17:03:46.225]                           for (restart in restarts) {
[17:03:46.225]                             name <- restart$name
[17:03:46.225]                             if (is.null(name)) 
[17:03:46.225]                               next
[17:03:46.225]                             if (!grepl(pattern, name)) 
[17:03:46.225]                               next
[17:03:46.225]                             invokeRestart(restart)
[17:03:46.225]                             muffled <- TRUE
[17:03:46.225]                             break
[17:03:46.225]                           }
[17:03:46.225]                         }
[17:03:46.225]                       }
[17:03:46.225]                       invisible(muffled)
[17:03:46.225]                     }
[17:03:46.225]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.225]                   }
[17:03:46.225]                 }
[17:03:46.225]             }
[17:03:46.225]         }))
[17:03:46.225]     }, error = function(ex) {
[17:03:46.225]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:46.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.225]                 ...future.rng), started = ...future.startTime, 
[17:03:46.225]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:46.225]             version = "1.8"), class = "FutureResult")
[17:03:46.225]     }, finally = {
[17:03:46.225]         if (!identical(...future.workdir, getwd())) 
[17:03:46.225]             setwd(...future.workdir)
[17:03:46.225]         {
[17:03:46.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:46.225]                 ...future.oldOptions$nwarnings <- NULL
[17:03:46.225]             }
[17:03:46.225]             base::options(...future.oldOptions)
[17:03:46.225]             if (.Platform$OS.type == "windows") {
[17:03:46.225]                 old_names <- names(...future.oldEnvVars)
[17:03:46.225]                 envs <- base::Sys.getenv()
[17:03:46.225]                 names <- names(envs)
[17:03:46.225]                 common <- intersect(names, old_names)
[17:03:46.225]                 added <- setdiff(names, old_names)
[17:03:46.225]                 removed <- setdiff(old_names, names)
[17:03:46.225]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:46.225]                   envs[common]]
[17:03:46.225]                 NAMES <- toupper(changed)
[17:03:46.225]                 args <- list()
[17:03:46.225]                 for (kk in seq_along(NAMES)) {
[17:03:46.225]                   name <- changed[[kk]]
[17:03:46.225]                   NAME <- NAMES[[kk]]
[17:03:46.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.225]                     next
[17:03:46.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.225]                 }
[17:03:46.225]                 NAMES <- toupper(added)
[17:03:46.225]                 for (kk in seq_along(NAMES)) {
[17:03:46.225]                   name <- added[[kk]]
[17:03:46.225]                   NAME <- NAMES[[kk]]
[17:03:46.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.225]                     next
[17:03:46.225]                   args[[name]] <- ""
[17:03:46.225]                 }
[17:03:46.225]                 NAMES <- toupper(removed)
[17:03:46.225]                 for (kk in seq_along(NAMES)) {
[17:03:46.225]                   name <- removed[[kk]]
[17:03:46.225]                   NAME <- NAMES[[kk]]
[17:03:46.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.225]                     next
[17:03:46.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.225]                 }
[17:03:46.225]                 if (length(args) > 0) 
[17:03:46.225]                   base::do.call(base::Sys.setenv, args = args)
[17:03:46.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:46.225]             }
[17:03:46.225]             else {
[17:03:46.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:46.225]             }
[17:03:46.225]             {
[17:03:46.225]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:46.225]                   0L) {
[17:03:46.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:46.225]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:46.225]                   base::options(opts)
[17:03:46.225]                 }
[17:03:46.225]                 {
[17:03:46.225]                   {
[17:03:46.225]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:46.225]                     NULL
[17:03:46.225]                   }
[17:03:46.225]                   options(future.plan = NULL)
[17:03:46.225]                   if (is.na(NA_character_)) 
[17:03:46.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:46.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:46.225]                     .init = FALSE)
[17:03:46.225]                 }
[17:03:46.225]             }
[17:03:46.225]         }
[17:03:46.225]     })
[17:03:46.225]     if (TRUE) {
[17:03:46.225]         base::sink(type = "output", split = FALSE)
[17:03:46.225]         if (TRUE) {
[17:03:46.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:46.225]         }
[17:03:46.225]         else {
[17:03:46.225]             ...future.result["stdout"] <- base::list(NULL)
[17:03:46.225]         }
[17:03:46.225]         base::close(...future.stdout)
[17:03:46.225]         ...future.stdout <- NULL
[17:03:46.225]     }
[17:03:46.225]     ...future.result$conditions <- ...future.conditions
[17:03:46.225]     ...future.result$finished <- base::Sys.time()
[17:03:46.225]     ...future.result
[17:03:46.225] }
[17:03:46.228] MultisessionFuture started
[17:03:46.228] - Launch lazy future ... done
[17:03:46.228] run() for ‘MultisessionFuture’ ... done
[17:03:46.731] receiveMessageFromWorker() for ClusterFuture ...
[17:03:46.731] - Validating connection of MultisessionFuture
[17:03:46.731] - received message: FutureResult
[17:03:46.731] - Received FutureResult
[17:03:46.732] - Erased future from FutureRegistry
[17:03:46.732] result() for ClusterFuture ...
[17:03:46.732] - result already collected: FutureResult
[17:03:46.732] result() for ClusterFuture ... done
[17:03:46.732] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:46.732] A MultisessionFuture was resolved (result was not collected)
[17:03:46.732] getGlobalsAndPackages() ...
[17:03:46.732] Searching for globals...
[17:03:46.733] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:46.733] Searching for globals ... DONE
[17:03:46.734] Resolving globals: FALSE
[17:03:46.734] 
[17:03:46.734] 
[17:03:46.734] getGlobalsAndPackages() ... DONE
[17:03:46.734] run() for ‘Future’ ...
[17:03:46.734] - state: ‘created’
[17:03:46.735] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:46.748] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:46.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:46.749]   - Field: ‘node’
[17:03:46.749]   - Field: ‘label’
[17:03:46.749]   - Field: ‘local’
[17:03:46.749]   - Field: ‘owner’
[17:03:46.749]   - Field: ‘envir’
[17:03:46.749]   - Field: ‘workers’
[17:03:46.749]   - Field: ‘packages’
[17:03:46.749]   - Field: ‘gc’
[17:03:46.749]   - Field: ‘conditions’
[17:03:46.749]   - Field: ‘persistent’
[17:03:46.750]   - Field: ‘expr’
[17:03:46.750]   - Field: ‘uuid’
[17:03:46.750]   - Field: ‘seed’
[17:03:46.750]   - Field: ‘version’
[17:03:46.750]   - Field: ‘result’
[17:03:46.750]   - Field: ‘asynchronous’
[17:03:46.750]   - Field: ‘calls’
[17:03:46.750]   - Field: ‘globals’
[17:03:46.750]   - Field: ‘stdout’
[17:03:46.750]   - Field: ‘earlySignal’
[17:03:46.750]   - Field: ‘lazy’
[17:03:46.751]   - Field: ‘state’
[17:03:46.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:46.751] - Launch lazy future ...
[17:03:46.751] Packages needed by the future expression (n = 0): <none>
[17:03:46.751] Packages needed by future strategies (n = 0): <none>
[17:03:46.752] {
[17:03:46.752]     {
[17:03:46.752]         {
[17:03:46.752]             ...future.startTime <- base::Sys.time()
[17:03:46.752]             {
[17:03:46.752]                 {
[17:03:46.752]                   {
[17:03:46.752]                     {
[17:03:46.752]                       base::local({
[17:03:46.752]                         has_future <- base::requireNamespace("future", 
[17:03:46.752]                           quietly = TRUE)
[17:03:46.752]                         if (has_future) {
[17:03:46.752]                           ns <- base::getNamespace("future")
[17:03:46.752]                           version <- ns[[".package"]][["version"]]
[17:03:46.752]                           if (is.null(version)) 
[17:03:46.752]                             version <- utils::packageVersion("future")
[17:03:46.752]                         }
[17:03:46.752]                         else {
[17:03:46.752]                           version <- NULL
[17:03:46.752]                         }
[17:03:46.752]                         if (!has_future || version < "1.8.0") {
[17:03:46.752]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:46.752]                             "", base::R.version$version.string), 
[17:03:46.752]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:46.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:46.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:46.752]                               "release", "version")], collapse = " "), 
[17:03:46.752]                             hostname = base::Sys.info()[["nodename"]])
[17:03:46.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:46.752]                             info)
[17:03:46.752]                           info <- base::paste(info, collapse = "; ")
[17:03:46.752]                           if (!has_future) {
[17:03:46.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:46.752]                               info)
[17:03:46.752]                           }
[17:03:46.752]                           else {
[17:03:46.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:46.752]                               info, version)
[17:03:46.752]                           }
[17:03:46.752]                           base::stop(msg)
[17:03:46.752]                         }
[17:03:46.752]                       })
[17:03:46.752]                     }
[17:03:46.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:46.752]                     base::options(mc.cores = 1L)
[17:03:46.752]                   }
[17:03:46.752]                   ...future.strategy.old <- future::plan("list")
[17:03:46.752]                   options(future.plan = NULL)
[17:03:46.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:46.752]                 }
[17:03:46.752]                 ...future.workdir <- getwd()
[17:03:46.752]             }
[17:03:46.752]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:46.752]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:46.752]         }
[17:03:46.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:46.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:46.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:46.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:46.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:46.752]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:46.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:46.752]             base::names(...future.oldOptions))
[17:03:46.752]     }
[17:03:46.752]     if (FALSE) {
[17:03:46.752]     }
[17:03:46.752]     else {
[17:03:46.752]         if (TRUE) {
[17:03:46.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:46.752]                 open = "w")
[17:03:46.752]         }
[17:03:46.752]         else {
[17:03:46.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:46.752]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:46.752]         }
[17:03:46.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:46.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:46.752]             base::sink(type = "output", split = FALSE)
[17:03:46.752]             base::close(...future.stdout)
[17:03:46.752]         }, add = TRUE)
[17:03:46.752]     }
[17:03:46.752]     ...future.frame <- base::sys.nframe()
[17:03:46.752]     ...future.conditions <- base::list()
[17:03:46.752]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:46.752]     if (FALSE) {
[17:03:46.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:46.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:46.752]     }
[17:03:46.752]     ...future.result <- base::tryCatch({
[17:03:46.752]         base::withCallingHandlers({
[17:03:46.752]             ...future.value <- base::withVisible(base::local({
[17:03:46.752]                 ...future.makeSendCondition <- base::local({
[17:03:46.752]                   sendCondition <- NULL
[17:03:46.752]                   function(frame = 1L) {
[17:03:46.752]                     if (is.function(sendCondition)) 
[17:03:46.752]                       return(sendCondition)
[17:03:46.752]                     ns <- getNamespace("parallel")
[17:03:46.752]                     if (exists("sendData", mode = "function", 
[17:03:46.752]                       envir = ns)) {
[17:03:46.752]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:46.752]                         envir = ns)
[17:03:46.752]                       envir <- sys.frame(frame)
[17:03:46.752]                       master <- NULL
[17:03:46.752]                       while (!identical(envir, .GlobalEnv) && 
[17:03:46.752]                         !identical(envir, emptyenv())) {
[17:03:46.752]                         if (exists("master", mode = "list", envir = envir, 
[17:03:46.752]                           inherits = FALSE)) {
[17:03:46.752]                           master <- get("master", mode = "list", 
[17:03:46.752]                             envir = envir, inherits = FALSE)
[17:03:46.752]                           if (inherits(master, c("SOCKnode", 
[17:03:46.752]                             "SOCK0node"))) {
[17:03:46.752]                             sendCondition <<- function(cond) {
[17:03:46.752]                               data <- list(type = "VALUE", value = cond, 
[17:03:46.752]                                 success = TRUE)
[17:03:46.752]                               parallel_sendData(master, data)
[17:03:46.752]                             }
[17:03:46.752]                             return(sendCondition)
[17:03:46.752]                           }
[17:03:46.752]                         }
[17:03:46.752]                         frame <- frame + 1L
[17:03:46.752]                         envir <- sys.frame(frame)
[17:03:46.752]                       }
[17:03:46.752]                     }
[17:03:46.752]                     sendCondition <<- function(cond) NULL
[17:03:46.752]                   }
[17:03:46.752]                 })
[17:03:46.752]                 withCallingHandlers({
[17:03:46.752]                   {
[17:03:46.752]                     Sys.sleep(0.5)
[17:03:46.752]                     list(a = 1, b = 42L)
[17:03:46.752]                   }
[17:03:46.752]                 }, immediateCondition = function(cond) {
[17:03:46.752]                   sendCondition <- ...future.makeSendCondition()
[17:03:46.752]                   sendCondition(cond)
[17:03:46.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.752]                   {
[17:03:46.752]                     inherits <- base::inherits
[17:03:46.752]                     invokeRestart <- base::invokeRestart
[17:03:46.752]                     is.null <- base::is.null
[17:03:46.752]                     muffled <- FALSE
[17:03:46.752]                     if (inherits(cond, "message")) {
[17:03:46.752]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:46.752]                       if (muffled) 
[17:03:46.752]                         invokeRestart("muffleMessage")
[17:03:46.752]                     }
[17:03:46.752]                     else if (inherits(cond, "warning")) {
[17:03:46.752]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:46.752]                       if (muffled) 
[17:03:46.752]                         invokeRestart("muffleWarning")
[17:03:46.752]                     }
[17:03:46.752]                     else if (inherits(cond, "condition")) {
[17:03:46.752]                       if (!is.null(pattern)) {
[17:03:46.752]                         computeRestarts <- base::computeRestarts
[17:03:46.752]                         grepl <- base::grepl
[17:03:46.752]                         restarts <- computeRestarts(cond)
[17:03:46.752]                         for (restart in restarts) {
[17:03:46.752]                           name <- restart$name
[17:03:46.752]                           if (is.null(name)) 
[17:03:46.752]                             next
[17:03:46.752]                           if (!grepl(pattern, name)) 
[17:03:46.752]                             next
[17:03:46.752]                           invokeRestart(restart)
[17:03:46.752]                           muffled <- TRUE
[17:03:46.752]                           break
[17:03:46.752]                         }
[17:03:46.752]                       }
[17:03:46.752]                     }
[17:03:46.752]                     invisible(muffled)
[17:03:46.752]                   }
[17:03:46.752]                   muffleCondition(cond)
[17:03:46.752]                 })
[17:03:46.752]             }))
[17:03:46.752]             future::FutureResult(value = ...future.value$value, 
[17:03:46.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.752]                   ...future.rng), globalenv = if (FALSE) 
[17:03:46.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:46.752]                     ...future.globalenv.names))
[17:03:46.752]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:46.752]         }, condition = base::local({
[17:03:46.752]             c <- base::c
[17:03:46.752]             inherits <- base::inherits
[17:03:46.752]             invokeRestart <- base::invokeRestart
[17:03:46.752]             length <- base::length
[17:03:46.752]             list <- base::list
[17:03:46.752]             seq.int <- base::seq.int
[17:03:46.752]             signalCondition <- base::signalCondition
[17:03:46.752]             sys.calls <- base::sys.calls
[17:03:46.752]             `[[` <- base::`[[`
[17:03:46.752]             `+` <- base::`+`
[17:03:46.752]             `<<-` <- base::`<<-`
[17:03:46.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:46.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:46.752]                   3L)]
[17:03:46.752]             }
[17:03:46.752]             function(cond) {
[17:03:46.752]                 is_error <- inherits(cond, "error")
[17:03:46.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:46.752]                   NULL)
[17:03:46.752]                 if (is_error) {
[17:03:46.752]                   sessionInformation <- function() {
[17:03:46.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:46.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:46.752]                       search = base::search(), system = base::Sys.info())
[17:03:46.752]                   }
[17:03:46.752]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:46.752]                     cond$call), session = sessionInformation(), 
[17:03:46.752]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:46.752]                   signalCondition(cond)
[17:03:46.752]                 }
[17:03:46.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:46.752]                 "immediateCondition"))) {
[17:03:46.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:46.752]                   ...future.conditions[[length(...future.conditions) + 
[17:03:46.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:46.752]                   if (TRUE && !signal) {
[17:03:46.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.752]                     {
[17:03:46.752]                       inherits <- base::inherits
[17:03:46.752]                       invokeRestart <- base::invokeRestart
[17:03:46.752]                       is.null <- base::is.null
[17:03:46.752]                       muffled <- FALSE
[17:03:46.752]                       if (inherits(cond, "message")) {
[17:03:46.752]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.752]                         if (muffled) 
[17:03:46.752]                           invokeRestart("muffleMessage")
[17:03:46.752]                       }
[17:03:46.752]                       else if (inherits(cond, "warning")) {
[17:03:46.752]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.752]                         if (muffled) 
[17:03:46.752]                           invokeRestart("muffleWarning")
[17:03:46.752]                       }
[17:03:46.752]                       else if (inherits(cond, "condition")) {
[17:03:46.752]                         if (!is.null(pattern)) {
[17:03:46.752]                           computeRestarts <- base::computeRestarts
[17:03:46.752]                           grepl <- base::grepl
[17:03:46.752]                           restarts <- computeRestarts(cond)
[17:03:46.752]                           for (restart in restarts) {
[17:03:46.752]                             name <- restart$name
[17:03:46.752]                             if (is.null(name)) 
[17:03:46.752]                               next
[17:03:46.752]                             if (!grepl(pattern, name)) 
[17:03:46.752]                               next
[17:03:46.752]                             invokeRestart(restart)
[17:03:46.752]                             muffled <- TRUE
[17:03:46.752]                             break
[17:03:46.752]                           }
[17:03:46.752]                         }
[17:03:46.752]                       }
[17:03:46.752]                       invisible(muffled)
[17:03:46.752]                     }
[17:03:46.752]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.752]                   }
[17:03:46.752]                 }
[17:03:46.752]                 else {
[17:03:46.752]                   if (TRUE) {
[17:03:46.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:46.752]                     {
[17:03:46.752]                       inherits <- base::inherits
[17:03:46.752]                       invokeRestart <- base::invokeRestart
[17:03:46.752]                       is.null <- base::is.null
[17:03:46.752]                       muffled <- FALSE
[17:03:46.752]                       if (inherits(cond, "message")) {
[17:03:46.752]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:46.752]                         if (muffled) 
[17:03:46.752]                           invokeRestart("muffleMessage")
[17:03:46.752]                       }
[17:03:46.752]                       else if (inherits(cond, "warning")) {
[17:03:46.752]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:46.752]                         if (muffled) 
[17:03:46.752]                           invokeRestart("muffleWarning")
[17:03:46.752]                       }
[17:03:46.752]                       else if (inherits(cond, "condition")) {
[17:03:46.752]                         if (!is.null(pattern)) {
[17:03:46.752]                           computeRestarts <- base::computeRestarts
[17:03:46.752]                           grepl <- base::grepl
[17:03:46.752]                           restarts <- computeRestarts(cond)
[17:03:46.752]                           for (restart in restarts) {
[17:03:46.752]                             name <- restart$name
[17:03:46.752]                             if (is.null(name)) 
[17:03:46.752]                               next
[17:03:46.752]                             if (!grepl(pattern, name)) 
[17:03:46.752]                               next
[17:03:46.752]                             invokeRestart(restart)
[17:03:46.752]                             muffled <- TRUE
[17:03:46.752]                             break
[17:03:46.752]                           }
[17:03:46.752]                         }
[17:03:46.752]                       }
[17:03:46.752]                       invisible(muffled)
[17:03:46.752]                     }
[17:03:46.752]                     muffleCondition(cond, pattern = "^muffle")
[17:03:46.752]                   }
[17:03:46.752]                 }
[17:03:46.752]             }
[17:03:46.752]         }))
[17:03:46.752]     }, error = function(ex) {
[17:03:46.752]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:46.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:46.752]                 ...future.rng), started = ...future.startTime, 
[17:03:46.752]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:46.752]             version = "1.8"), class = "FutureResult")
[17:03:46.752]     }, finally = {
[17:03:46.752]         if (!identical(...future.workdir, getwd())) 
[17:03:46.752]             setwd(...future.workdir)
[17:03:46.752]         {
[17:03:46.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:46.752]                 ...future.oldOptions$nwarnings <- NULL
[17:03:46.752]             }
[17:03:46.752]             base::options(...future.oldOptions)
[17:03:46.752]             if (.Platform$OS.type == "windows") {
[17:03:46.752]                 old_names <- names(...future.oldEnvVars)
[17:03:46.752]                 envs <- base::Sys.getenv()
[17:03:46.752]                 names <- names(envs)
[17:03:46.752]                 common <- intersect(names, old_names)
[17:03:46.752]                 added <- setdiff(names, old_names)
[17:03:46.752]                 removed <- setdiff(old_names, names)
[17:03:46.752]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:46.752]                   envs[common]]
[17:03:46.752]                 NAMES <- toupper(changed)
[17:03:46.752]                 args <- list()
[17:03:46.752]                 for (kk in seq_along(NAMES)) {
[17:03:46.752]                   name <- changed[[kk]]
[17:03:46.752]                   NAME <- NAMES[[kk]]
[17:03:46.752]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.752]                     next
[17:03:46.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.752]                 }
[17:03:46.752]                 NAMES <- toupper(added)
[17:03:46.752]                 for (kk in seq_along(NAMES)) {
[17:03:46.752]                   name <- added[[kk]]
[17:03:46.752]                   NAME <- NAMES[[kk]]
[17:03:46.752]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.752]                     next
[17:03:46.752]                   args[[name]] <- ""
[17:03:46.752]                 }
[17:03:46.752]                 NAMES <- toupper(removed)
[17:03:46.752]                 for (kk in seq_along(NAMES)) {
[17:03:46.752]                   name <- removed[[kk]]
[17:03:46.752]                   NAME <- NAMES[[kk]]
[17:03:46.752]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:46.752]                     next
[17:03:46.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:46.752]                 }
[17:03:46.752]                 if (length(args) > 0) 
[17:03:46.752]                   base::do.call(base::Sys.setenv, args = args)
[17:03:46.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:46.752]             }
[17:03:46.752]             else {
[17:03:46.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:46.752]             }
[17:03:46.752]             {
[17:03:46.752]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:46.752]                   0L) {
[17:03:46.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:46.752]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:46.752]                   base::options(opts)
[17:03:46.752]                 }
[17:03:46.752]                 {
[17:03:46.752]                   {
[17:03:46.752]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:46.752]                     NULL
[17:03:46.752]                   }
[17:03:46.752]                   options(future.plan = NULL)
[17:03:46.752]                   if (is.na(NA_character_)) 
[17:03:46.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:46.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:46.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:46.752]                     .init = FALSE)
[17:03:46.752]                 }
[17:03:46.752]             }
[17:03:46.752]         }
[17:03:46.752]     })
[17:03:46.752]     if (TRUE) {
[17:03:46.752]         base::sink(type = "output", split = FALSE)
[17:03:46.752]         if (TRUE) {
[17:03:46.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:46.752]         }
[17:03:46.752]         else {
[17:03:46.752]             ...future.result["stdout"] <- base::list(NULL)
[17:03:46.752]         }
[17:03:46.752]         base::close(...future.stdout)
[17:03:46.752]         ...future.stdout <- NULL
[17:03:46.752]     }
[17:03:46.752]     ...future.result$conditions <- ...future.conditions
[17:03:46.752]     ...future.result$finished <- base::Sys.time()
[17:03:46.752]     ...future.result
[17:03:46.752] }
[17:03:46.754] MultisessionFuture started
[17:03:46.755] - Launch lazy future ... done
[17:03:46.755] run() for ‘MultisessionFuture’ ... done
[17:03:47.257] receiveMessageFromWorker() for ClusterFuture ...
[17:03:47.257] - Validating connection of MultisessionFuture
[17:03:47.258] - received message: FutureResult
[17:03:47.258] - Received FutureResult
[17:03:47.258] - Erased future from FutureRegistry
[17:03:47.258] result() for ClusterFuture ...
[17:03:47.258] - result already collected: FutureResult
[17:03:47.258] result() for ClusterFuture ... done
[17:03:47.258] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:47.258] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:03:47.259] getGlobalsAndPackages() ...
[17:03:47.259] Searching for globals...
[17:03:47.259] - globals found: [2] ‘list’, ‘stop’
[17:03:47.260] Searching for globals ... DONE
[17:03:47.260] Resolving globals: FALSE
[17:03:47.260] 
[17:03:47.260] 
[17:03:47.260] getGlobalsAndPackages() ... DONE
[17:03:47.260] run() for ‘Future’ ...
[17:03:47.261] - state: ‘created’
[17:03:47.261] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:47.274] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:47.275] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:47.275]   - Field: ‘node’
[17:03:47.275]   - Field: ‘label’
[17:03:47.275]   - Field: ‘local’
[17:03:47.275]   - Field: ‘owner’
[17:03:47.275]   - Field: ‘envir’
[17:03:47.275]   - Field: ‘workers’
[17:03:47.275]   - Field: ‘packages’
[17:03:47.275]   - Field: ‘gc’
[17:03:47.275]   - Field: ‘conditions’
[17:03:47.276]   - Field: ‘persistent’
[17:03:47.276]   - Field: ‘expr’
[17:03:47.276]   - Field: ‘uuid’
[17:03:47.276]   - Field: ‘seed’
[17:03:47.276]   - Field: ‘version’
[17:03:47.276]   - Field: ‘result’
[17:03:47.276]   - Field: ‘asynchronous’
[17:03:47.276]   - Field: ‘calls’
[17:03:47.276]   - Field: ‘globals’
[17:03:47.276]   - Field: ‘stdout’
[17:03:47.276]   - Field: ‘earlySignal’
[17:03:47.276]   - Field: ‘lazy’
[17:03:47.277]   - Field: ‘state’
[17:03:47.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:47.277] - Launch lazy future ...
[17:03:47.277] Packages needed by the future expression (n = 0): <none>
[17:03:47.277] Packages needed by future strategies (n = 0): <none>
[17:03:47.278] {
[17:03:47.278]     {
[17:03:47.278]         {
[17:03:47.278]             ...future.startTime <- base::Sys.time()
[17:03:47.278]             {
[17:03:47.278]                 {
[17:03:47.278]                   {
[17:03:47.278]                     {
[17:03:47.278]                       base::local({
[17:03:47.278]                         has_future <- base::requireNamespace("future", 
[17:03:47.278]                           quietly = TRUE)
[17:03:47.278]                         if (has_future) {
[17:03:47.278]                           ns <- base::getNamespace("future")
[17:03:47.278]                           version <- ns[[".package"]][["version"]]
[17:03:47.278]                           if (is.null(version)) 
[17:03:47.278]                             version <- utils::packageVersion("future")
[17:03:47.278]                         }
[17:03:47.278]                         else {
[17:03:47.278]                           version <- NULL
[17:03:47.278]                         }
[17:03:47.278]                         if (!has_future || version < "1.8.0") {
[17:03:47.278]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:47.278]                             "", base::R.version$version.string), 
[17:03:47.278]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:47.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:47.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:47.278]                               "release", "version")], collapse = " "), 
[17:03:47.278]                             hostname = base::Sys.info()[["nodename"]])
[17:03:47.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:47.278]                             info)
[17:03:47.278]                           info <- base::paste(info, collapse = "; ")
[17:03:47.278]                           if (!has_future) {
[17:03:47.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:47.278]                               info)
[17:03:47.278]                           }
[17:03:47.278]                           else {
[17:03:47.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:47.278]                               info, version)
[17:03:47.278]                           }
[17:03:47.278]                           base::stop(msg)
[17:03:47.278]                         }
[17:03:47.278]                       })
[17:03:47.278]                     }
[17:03:47.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:47.278]                     base::options(mc.cores = 1L)
[17:03:47.278]                   }
[17:03:47.278]                   ...future.strategy.old <- future::plan("list")
[17:03:47.278]                   options(future.plan = NULL)
[17:03:47.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:47.278]                 }
[17:03:47.278]                 ...future.workdir <- getwd()
[17:03:47.278]             }
[17:03:47.278]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:47.278]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:47.278]         }
[17:03:47.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:47.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:47.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:47.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:47.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:47.278]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:47.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:47.278]             base::names(...future.oldOptions))
[17:03:47.278]     }
[17:03:47.278]     if (FALSE) {
[17:03:47.278]     }
[17:03:47.278]     else {
[17:03:47.278]         if (TRUE) {
[17:03:47.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:47.278]                 open = "w")
[17:03:47.278]         }
[17:03:47.278]         else {
[17:03:47.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:47.278]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:47.278]         }
[17:03:47.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:47.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:47.278]             base::sink(type = "output", split = FALSE)
[17:03:47.278]             base::close(...future.stdout)
[17:03:47.278]         }, add = TRUE)
[17:03:47.278]     }
[17:03:47.278]     ...future.frame <- base::sys.nframe()
[17:03:47.278]     ...future.conditions <- base::list()
[17:03:47.278]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:47.278]     if (FALSE) {
[17:03:47.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:47.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:47.278]     }
[17:03:47.278]     ...future.result <- base::tryCatch({
[17:03:47.278]         base::withCallingHandlers({
[17:03:47.278]             ...future.value <- base::withVisible(base::local({
[17:03:47.278]                 ...future.makeSendCondition <- base::local({
[17:03:47.278]                   sendCondition <- NULL
[17:03:47.278]                   function(frame = 1L) {
[17:03:47.278]                     if (is.function(sendCondition)) 
[17:03:47.278]                       return(sendCondition)
[17:03:47.278]                     ns <- getNamespace("parallel")
[17:03:47.278]                     if (exists("sendData", mode = "function", 
[17:03:47.278]                       envir = ns)) {
[17:03:47.278]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:47.278]                         envir = ns)
[17:03:47.278]                       envir <- sys.frame(frame)
[17:03:47.278]                       master <- NULL
[17:03:47.278]                       while (!identical(envir, .GlobalEnv) && 
[17:03:47.278]                         !identical(envir, emptyenv())) {
[17:03:47.278]                         if (exists("master", mode = "list", envir = envir, 
[17:03:47.278]                           inherits = FALSE)) {
[17:03:47.278]                           master <- get("master", mode = "list", 
[17:03:47.278]                             envir = envir, inherits = FALSE)
[17:03:47.278]                           if (inherits(master, c("SOCKnode", 
[17:03:47.278]                             "SOCK0node"))) {
[17:03:47.278]                             sendCondition <<- function(cond) {
[17:03:47.278]                               data <- list(type = "VALUE", value = cond, 
[17:03:47.278]                                 success = TRUE)
[17:03:47.278]                               parallel_sendData(master, data)
[17:03:47.278]                             }
[17:03:47.278]                             return(sendCondition)
[17:03:47.278]                           }
[17:03:47.278]                         }
[17:03:47.278]                         frame <- frame + 1L
[17:03:47.278]                         envir <- sys.frame(frame)
[17:03:47.278]                       }
[17:03:47.278]                     }
[17:03:47.278]                     sendCondition <<- function(cond) NULL
[17:03:47.278]                   }
[17:03:47.278]                 })
[17:03:47.278]                 withCallingHandlers({
[17:03:47.278]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:47.278]                 }, immediateCondition = function(cond) {
[17:03:47.278]                   sendCondition <- ...future.makeSendCondition()
[17:03:47.278]                   sendCondition(cond)
[17:03:47.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.278]                   {
[17:03:47.278]                     inherits <- base::inherits
[17:03:47.278]                     invokeRestart <- base::invokeRestart
[17:03:47.278]                     is.null <- base::is.null
[17:03:47.278]                     muffled <- FALSE
[17:03:47.278]                     if (inherits(cond, "message")) {
[17:03:47.278]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:47.278]                       if (muffled) 
[17:03:47.278]                         invokeRestart("muffleMessage")
[17:03:47.278]                     }
[17:03:47.278]                     else if (inherits(cond, "warning")) {
[17:03:47.278]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:47.278]                       if (muffled) 
[17:03:47.278]                         invokeRestart("muffleWarning")
[17:03:47.278]                     }
[17:03:47.278]                     else if (inherits(cond, "condition")) {
[17:03:47.278]                       if (!is.null(pattern)) {
[17:03:47.278]                         computeRestarts <- base::computeRestarts
[17:03:47.278]                         grepl <- base::grepl
[17:03:47.278]                         restarts <- computeRestarts(cond)
[17:03:47.278]                         for (restart in restarts) {
[17:03:47.278]                           name <- restart$name
[17:03:47.278]                           if (is.null(name)) 
[17:03:47.278]                             next
[17:03:47.278]                           if (!grepl(pattern, name)) 
[17:03:47.278]                             next
[17:03:47.278]                           invokeRestart(restart)
[17:03:47.278]                           muffled <- TRUE
[17:03:47.278]                           break
[17:03:47.278]                         }
[17:03:47.278]                       }
[17:03:47.278]                     }
[17:03:47.278]                     invisible(muffled)
[17:03:47.278]                   }
[17:03:47.278]                   muffleCondition(cond)
[17:03:47.278]                 })
[17:03:47.278]             }))
[17:03:47.278]             future::FutureResult(value = ...future.value$value, 
[17:03:47.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.278]                   ...future.rng), globalenv = if (FALSE) 
[17:03:47.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:47.278]                     ...future.globalenv.names))
[17:03:47.278]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:47.278]         }, condition = base::local({
[17:03:47.278]             c <- base::c
[17:03:47.278]             inherits <- base::inherits
[17:03:47.278]             invokeRestart <- base::invokeRestart
[17:03:47.278]             length <- base::length
[17:03:47.278]             list <- base::list
[17:03:47.278]             seq.int <- base::seq.int
[17:03:47.278]             signalCondition <- base::signalCondition
[17:03:47.278]             sys.calls <- base::sys.calls
[17:03:47.278]             `[[` <- base::`[[`
[17:03:47.278]             `+` <- base::`+`
[17:03:47.278]             `<<-` <- base::`<<-`
[17:03:47.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:47.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:47.278]                   3L)]
[17:03:47.278]             }
[17:03:47.278]             function(cond) {
[17:03:47.278]                 is_error <- inherits(cond, "error")
[17:03:47.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:47.278]                   NULL)
[17:03:47.278]                 if (is_error) {
[17:03:47.278]                   sessionInformation <- function() {
[17:03:47.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:47.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:47.278]                       search = base::search(), system = base::Sys.info())
[17:03:47.278]                   }
[17:03:47.278]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:47.278]                     cond$call), session = sessionInformation(), 
[17:03:47.278]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:47.278]                   signalCondition(cond)
[17:03:47.278]                 }
[17:03:47.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:47.278]                 "immediateCondition"))) {
[17:03:47.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:47.278]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:47.278]                   if (TRUE && !signal) {
[17:03:47.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.278]                     {
[17:03:47.278]                       inherits <- base::inherits
[17:03:47.278]                       invokeRestart <- base::invokeRestart
[17:03:47.278]                       is.null <- base::is.null
[17:03:47.278]                       muffled <- FALSE
[17:03:47.278]                       if (inherits(cond, "message")) {
[17:03:47.278]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.278]                         if (muffled) 
[17:03:47.278]                           invokeRestart("muffleMessage")
[17:03:47.278]                       }
[17:03:47.278]                       else if (inherits(cond, "warning")) {
[17:03:47.278]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.278]                         if (muffled) 
[17:03:47.278]                           invokeRestart("muffleWarning")
[17:03:47.278]                       }
[17:03:47.278]                       else if (inherits(cond, "condition")) {
[17:03:47.278]                         if (!is.null(pattern)) {
[17:03:47.278]                           computeRestarts <- base::computeRestarts
[17:03:47.278]                           grepl <- base::grepl
[17:03:47.278]                           restarts <- computeRestarts(cond)
[17:03:47.278]                           for (restart in restarts) {
[17:03:47.278]                             name <- restart$name
[17:03:47.278]                             if (is.null(name)) 
[17:03:47.278]                               next
[17:03:47.278]                             if (!grepl(pattern, name)) 
[17:03:47.278]                               next
[17:03:47.278]                             invokeRestart(restart)
[17:03:47.278]                             muffled <- TRUE
[17:03:47.278]                             break
[17:03:47.278]                           }
[17:03:47.278]                         }
[17:03:47.278]                       }
[17:03:47.278]                       invisible(muffled)
[17:03:47.278]                     }
[17:03:47.278]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.278]                   }
[17:03:47.278]                 }
[17:03:47.278]                 else {
[17:03:47.278]                   if (TRUE) {
[17:03:47.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.278]                     {
[17:03:47.278]                       inherits <- base::inherits
[17:03:47.278]                       invokeRestart <- base::invokeRestart
[17:03:47.278]                       is.null <- base::is.null
[17:03:47.278]                       muffled <- FALSE
[17:03:47.278]                       if (inherits(cond, "message")) {
[17:03:47.278]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.278]                         if (muffled) 
[17:03:47.278]                           invokeRestart("muffleMessage")
[17:03:47.278]                       }
[17:03:47.278]                       else if (inherits(cond, "warning")) {
[17:03:47.278]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.278]                         if (muffled) 
[17:03:47.278]                           invokeRestart("muffleWarning")
[17:03:47.278]                       }
[17:03:47.278]                       else if (inherits(cond, "condition")) {
[17:03:47.278]                         if (!is.null(pattern)) {
[17:03:47.278]                           computeRestarts <- base::computeRestarts
[17:03:47.278]                           grepl <- base::grepl
[17:03:47.278]                           restarts <- computeRestarts(cond)
[17:03:47.278]                           for (restart in restarts) {
[17:03:47.278]                             name <- restart$name
[17:03:47.278]                             if (is.null(name)) 
[17:03:47.278]                               next
[17:03:47.278]                             if (!grepl(pattern, name)) 
[17:03:47.278]                               next
[17:03:47.278]                             invokeRestart(restart)
[17:03:47.278]                             muffled <- TRUE
[17:03:47.278]                             break
[17:03:47.278]                           }
[17:03:47.278]                         }
[17:03:47.278]                       }
[17:03:47.278]                       invisible(muffled)
[17:03:47.278]                     }
[17:03:47.278]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.278]                   }
[17:03:47.278]                 }
[17:03:47.278]             }
[17:03:47.278]         }))
[17:03:47.278]     }, error = function(ex) {
[17:03:47.278]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:47.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.278]                 ...future.rng), started = ...future.startTime, 
[17:03:47.278]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:47.278]             version = "1.8"), class = "FutureResult")
[17:03:47.278]     }, finally = {
[17:03:47.278]         if (!identical(...future.workdir, getwd())) 
[17:03:47.278]             setwd(...future.workdir)
[17:03:47.278]         {
[17:03:47.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:47.278]                 ...future.oldOptions$nwarnings <- NULL
[17:03:47.278]             }
[17:03:47.278]             base::options(...future.oldOptions)
[17:03:47.278]             if (.Platform$OS.type == "windows") {
[17:03:47.278]                 old_names <- names(...future.oldEnvVars)
[17:03:47.278]                 envs <- base::Sys.getenv()
[17:03:47.278]                 names <- names(envs)
[17:03:47.278]                 common <- intersect(names, old_names)
[17:03:47.278]                 added <- setdiff(names, old_names)
[17:03:47.278]                 removed <- setdiff(old_names, names)
[17:03:47.278]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:47.278]                   envs[common]]
[17:03:47.278]                 NAMES <- toupper(changed)
[17:03:47.278]                 args <- list()
[17:03:47.278]                 for (kk in seq_along(NAMES)) {
[17:03:47.278]                   name <- changed[[kk]]
[17:03:47.278]                   NAME <- NAMES[[kk]]
[17:03:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.278]                     next
[17:03:47.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.278]                 }
[17:03:47.278]                 NAMES <- toupper(added)
[17:03:47.278]                 for (kk in seq_along(NAMES)) {
[17:03:47.278]                   name <- added[[kk]]
[17:03:47.278]                   NAME <- NAMES[[kk]]
[17:03:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.278]                     next
[17:03:47.278]                   args[[name]] <- ""
[17:03:47.278]                 }
[17:03:47.278]                 NAMES <- toupper(removed)
[17:03:47.278]                 for (kk in seq_along(NAMES)) {
[17:03:47.278]                   name <- removed[[kk]]
[17:03:47.278]                   NAME <- NAMES[[kk]]
[17:03:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.278]                     next
[17:03:47.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.278]                 }
[17:03:47.278]                 if (length(args) > 0) 
[17:03:47.278]                   base::do.call(base::Sys.setenv, args = args)
[17:03:47.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:47.278]             }
[17:03:47.278]             else {
[17:03:47.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:47.278]             }
[17:03:47.278]             {
[17:03:47.278]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:47.278]                   0L) {
[17:03:47.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:47.278]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:47.278]                   base::options(opts)
[17:03:47.278]                 }
[17:03:47.278]                 {
[17:03:47.278]                   {
[17:03:47.278]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:47.278]                     NULL
[17:03:47.278]                   }
[17:03:47.278]                   options(future.plan = NULL)
[17:03:47.278]                   if (is.na(NA_character_)) 
[17:03:47.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:47.278]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:47.278]                     .init = FALSE)
[17:03:47.278]                 }
[17:03:47.278]             }
[17:03:47.278]         }
[17:03:47.278]     })
[17:03:47.278]     if (TRUE) {
[17:03:47.278]         base::sink(type = "output", split = FALSE)
[17:03:47.278]         if (TRUE) {
[17:03:47.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:47.278]         }
[17:03:47.278]         else {
[17:03:47.278]             ...future.result["stdout"] <- base::list(NULL)
[17:03:47.278]         }
[17:03:47.278]         base::close(...future.stdout)
[17:03:47.278]         ...future.stdout <- NULL
[17:03:47.278]     }
[17:03:47.278]     ...future.result$conditions <- ...future.conditions
[17:03:47.278]     ...future.result$finished <- base::Sys.time()
[17:03:47.278]     ...future.result
[17:03:47.278] }
[17:03:47.280] MultisessionFuture started
[17:03:47.281] - Launch lazy future ... done
[17:03:47.281] run() for ‘MultisessionFuture’ ... done
[17:03:47.282] receiveMessageFromWorker() for ClusterFuture ...
[17:03:47.282] - Validating connection of MultisessionFuture
[17:03:47.283] - received message: FutureResult
[17:03:47.283] - Received FutureResult
[17:03:47.283] - Erased future from FutureRegistry
[17:03:47.283] result() for ClusterFuture ...
[17:03:47.283] - result already collected: FutureResult
[17:03:47.283] result() for ClusterFuture ... done
[17:03:47.283] signalConditions() ...
[17:03:47.283]  - include = ‘immediateCondition’
[17:03:47.284]  - exclude = 
[17:03:47.284]  - resignal = FALSE
[17:03:47.284]  - Number of conditions: 1
[17:03:47.284] signalConditions() ... done
[17:03:47.284] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:47.284] A MultisessionFuture was resolved (result was not collected)
[17:03:47.284] getGlobalsAndPackages() ...
[17:03:47.284] Searching for globals...
[17:03:47.285] - globals found: [2] ‘list’, ‘stop’
[17:03:47.285] Searching for globals ... DONE
[17:03:47.285] Resolving globals: FALSE
[17:03:47.285] 
[17:03:47.285] 
[17:03:47.285] getGlobalsAndPackages() ... DONE
[17:03:47.286] run() for ‘Future’ ...
[17:03:47.286] - state: ‘created’
[17:03:47.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:47.299] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:47.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:47.300]   - Field: ‘node’
[17:03:47.300]   - Field: ‘label’
[17:03:47.300]   - Field: ‘local’
[17:03:47.300]   - Field: ‘owner’
[17:03:47.300]   - Field: ‘envir’
[17:03:47.300]   - Field: ‘workers’
[17:03:47.300]   - Field: ‘packages’
[17:03:47.300]   - Field: ‘gc’
[17:03:47.300]   - Field: ‘conditions’
[17:03:47.301]   - Field: ‘persistent’
[17:03:47.301]   - Field: ‘expr’
[17:03:47.301]   - Field: ‘uuid’
[17:03:47.301]   - Field: ‘seed’
[17:03:47.301]   - Field: ‘version’
[17:03:47.301]   - Field: ‘result’
[17:03:47.301]   - Field: ‘asynchronous’
[17:03:47.301]   - Field: ‘calls’
[17:03:47.301]   - Field: ‘globals’
[17:03:47.301]   - Field: ‘stdout’
[17:03:47.301]   - Field: ‘earlySignal’
[17:03:47.302]   - Field: ‘lazy’
[17:03:47.302]   - Field: ‘state’
[17:03:47.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:47.302] - Launch lazy future ...
[17:03:47.302] Packages needed by the future expression (n = 0): <none>
[17:03:47.302] Packages needed by future strategies (n = 0): <none>
[17:03:47.303] {
[17:03:47.303]     {
[17:03:47.303]         {
[17:03:47.303]             ...future.startTime <- base::Sys.time()
[17:03:47.303]             {
[17:03:47.303]                 {
[17:03:47.303]                   {
[17:03:47.303]                     {
[17:03:47.303]                       base::local({
[17:03:47.303]                         has_future <- base::requireNamespace("future", 
[17:03:47.303]                           quietly = TRUE)
[17:03:47.303]                         if (has_future) {
[17:03:47.303]                           ns <- base::getNamespace("future")
[17:03:47.303]                           version <- ns[[".package"]][["version"]]
[17:03:47.303]                           if (is.null(version)) 
[17:03:47.303]                             version <- utils::packageVersion("future")
[17:03:47.303]                         }
[17:03:47.303]                         else {
[17:03:47.303]                           version <- NULL
[17:03:47.303]                         }
[17:03:47.303]                         if (!has_future || version < "1.8.0") {
[17:03:47.303]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:47.303]                             "", base::R.version$version.string), 
[17:03:47.303]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:47.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:47.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:47.303]                               "release", "version")], collapse = " "), 
[17:03:47.303]                             hostname = base::Sys.info()[["nodename"]])
[17:03:47.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:47.303]                             info)
[17:03:47.303]                           info <- base::paste(info, collapse = "; ")
[17:03:47.303]                           if (!has_future) {
[17:03:47.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:47.303]                               info)
[17:03:47.303]                           }
[17:03:47.303]                           else {
[17:03:47.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:47.303]                               info, version)
[17:03:47.303]                           }
[17:03:47.303]                           base::stop(msg)
[17:03:47.303]                         }
[17:03:47.303]                       })
[17:03:47.303]                     }
[17:03:47.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:47.303]                     base::options(mc.cores = 1L)
[17:03:47.303]                   }
[17:03:47.303]                   ...future.strategy.old <- future::plan("list")
[17:03:47.303]                   options(future.plan = NULL)
[17:03:47.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:47.303]                 }
[17:03:47.303]                 ...future.workdir <- getwd()
[17:03:47.303]             }
[17:03:47.303]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:47.303]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:47.303]         }
[17:03:47.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:47.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:47.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:47.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:47.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:47.303]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:47.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:47.303]             base::names(...future.oldOptions))
[17:03:47.303]     }
[17:03:47.303]     if (FALSE) {
[17:03:47.303]     }
[17:03:47.303]     else {
[17:03:47.303]         if (TRUE) {
[17:03:47.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:47.303]                 open = "w")
[17:03:47.303]         }
[17:03:47.303]         else {
[17:03:47.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:47.303]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:47.303]         }
[17:03:47.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:47.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:47.303]             base::sink(type = "output", split = FALSE)
[17:03:47.303]             base::close(...future.stdout)
[17:03:47.303]         }, add = TRUE)
[17:03:47.303]     }
[17:03:47.303]     ...future.frame <- base::sys.nframe()
[17:03:47.303]     ...future.conditions <- base::list()
[17:03:47.303]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:47.303]     if (FALSE) {
[17:03:47.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:47.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:47.303]     }
[17:03:47.303]     ...future.result <- base::tryCatch({
[17:03:47.303]         base::withCallingHandlers({
[17:03:47.303]             ...future.value <- base::withVisible(base::local({
[17:03:47.303]                 ...future.makeSendCondition <- base::local({
[17:03:47.303]                   sendCondition <- NULL
[17:03:47.303]                   function(frame = 1L) {
[17:03:47.303]                     if (is.function(sendCondition)) 
[17:03:47.303]                       return(sendCondition)
[17:03:47.303]                     ns <- getNamespace("parallel")
[17:03:47.303]                     if (exists("sendData", mode = "function", 
[17:03:47.303]                       envir = ns)) {
[17:03:47.303]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:47.303]                         envir = ns)
[17:03:47.303]                       envir <- sys.frame(frame)
[17:03:47.303]                       master <- NULL
[17:03:47.303]                       while (!identical(envir, .GlobalEnv) && 
[17:03:47.303]                         !identical(envir, emptyenv())) {
[17:03:47.303]                         if (exists("master", mode = "list", envir = envir, 
[17:03:47.303]                           inherits = FALSE)) {
[17:03:47.303]                           master <- get("master", mode = "list", 
[17:03:47.303]                             envir = envir, inherits = FALSE)
[17:03:47.303]                           if (inherits(master, c("SOCKnode", 
[17:03:47.303]                             "SOCK0node"))) {
[17:03:47.303]                             sendCondition <<- function(cond) {
[17:03:47.303]                               data <- list(type = "VALUE", value = cond, 
[17:03:47.303]                                 success = TRUE)
[17:03:47.303]                               parallel_sendData(master, data)
[17:03:47.303]                             }
[17:03:47.303]                             return(sendCondition)
[17:03:47.303]                           }
[17:03:47.303]                         }
[17:03:47.303]                         frame <- frame + 1L
[17:03:47.303]                         envir <- sys.frame(frame)
[17:03:47.303]                       }
[17:03:47.303]                     }
[17:03:47.303]                     sendCondition <<- function(cond) NULL
[17:03:47.303]                   }
[17:03:47.303]                 })
[17:03:47.303]                 withCallingHandlers({
[17:03:47.303]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:47.303]                 }, immediateCondition = function(cond) {
[17:03:47.303]                   sendCondition <- ...future.makeSendCondition()
[17:03:47.303]                   sendCondition(cond)
[17:03:47.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.303]                   {
[17:03:47.303]                     inherits <- base::inherits
[17:03:47.303]                     invokeRestart <- base::invokeRestart
[17:03:47.303]                     is.null <- base::is.null
[17:03:47.303]                     muffled <- FALSE
[17:03:47.303]                     if (inherits(cond, "message")) {
[17:03:47.303]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:47.303]                       if (muffled) 
[17:03:47.303]                         invokeRestart("muffleMessage")
[17:03:47.303]                     }
[17:03:47.303]                     else if (inherits(cond, "warning")) {
[17:03:47.303]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:47.303]                       if (muffled) 
[17:03:47.303]                         invokeRestart("muffleWarning")
[17:03:47.303]                     }
[17:03:47.303]                     else if (inherits(cond, "condition")) {
[17:03:47.303]                       if (!is.null(pattern)) {
[17:03:47.303]                         computeRestarts <- base::computeRestarts
[17:03:47.303]                         grepl <- base::grepl
[17:03:47.303]                         restarts <- computeRestarts(cond)
[17:03:47.303]                         for (restart in restarts) {
[17:03:47.303]                           name <- restart$name
[17:03:47.303]                           if (is.null(name)) 
[17:03:47.303]                             next
[17:03:47.303]                           if (!grepl(pattern, name)) 
[17:03:47.303]                             next
[17:03:47.303]                           invokeRestart(restart)
[17:03:47.303]                           muffled <- TRUE
[17:03:47.303]                           break
[17:03:47.303]                         }
[17:03:47.303]                       }
[17:03:47.303]                     }
[17:03:47.303]                     invisible(muffled)
[17:03:47.303]                   }
[17:03:47.303]                   muffleCondition(cond)
[17:03:47.303]                 })
[17:03:47.303]             }))
[17:03:47.303]             future::FutureResult(value = ...future.value$value, 
[17:03:47.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.303]                   ...future.rng), globalenv = if (FALSE) 
[17:03:47.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:47.303]                     ...future.globalenv.names))
[17:03:47.303]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:47.303]         }, condition = base::local({
[17:03:47.303]             c <- base::c
[17:03:47.303]             inherits <- base::inherits
[17:03:47.303]             invokeRestart <- base::invokeRestart
[17:03:47.303]             length <- base::length
[17:03:47.303]             list <- base::list
[17:03:47.303]             seq.int <- base::seq.int
[17:03:47.303]             signalCondition <- base::signalCondition
[17:03:47.303]             sys.calls <- base::sys.calls
[17:03:47.303]             `[[` <- base::`[[`
[17:03:47.303]             `+` <- base::`+`
[17:03:47.303]             `<<-` <- base::`<<-`
[17:03:47.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:47.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:47.303]                   3L)]
[17:03:47.303]             }
[17:03:47.303]             function(cond) {
[17:03:47.303]                 is_error <- inherits(cond, "error")
[17:03:47.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:47.303]                   NULL)
[17:03:47.303]                 if (is_error) {
[17:03:47.303]                   sessionInformation <- function() {
[17:03:47.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:47.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:47.303]                       search = base::search(), system = base::Sys.info())
[17:03:47.303]                   }
[17:03:47.303]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:47.303]                     cond$call), session = sessionInformation(), 
[17:03:47.303]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:47.303]                   signalCondition(cond)
[17:03:47.303]                 }
[17:03:47.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:47.303]                 "immediateCondition"))) {
[17:03:47.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:47.303]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:47.303]                   if (TRUE && !signal) {
[17:03:47.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.303]                     {
[17:03:47.303]                       inherits <- base::inherits
[17:03:47.303]                       invokeRestart <- base::invokeRestart
[17:03:47.303]                       is.null <- base::is.null
[17:03:47.303]                       muffled <- FALSE
[17:03:47.303]                       if (inherits(cond, "message")) {
[17:03:47.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.303]                         if (muffled) 
[17:03:47.303]                           invokeRestart("muffleMessage")
[17:03:47.303]                       }
[17:03:47.303]                       else if (inherits(cond, "warning")) {
[17:03:47.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.303]                         if (muffled) 
[17:03:47.303]                           invokeRestart("muffleWarning")
[17:03:47.303]                       }
[17:03:47.303]                       else if (inherits(cond, "condition")) {
[17:03:47.303]                         if (!is.null(pattern)) {
[17:03:47.303]                           computeRestarts <- base::computeRestarts
[17:03:47.303]                           grepl <- base::grepl
[17:03:47.303]                           restarts <- computeRestarts(cond)
[17:03:47.303]                           for (restart in restarts) {
[17:03:47.303]                             name <- restart$name
[17:03:47.303]                             if (is.null(name)) 
[17:03:47.303]                               next
[17:03:47.303]                             if (!grepl(pattern, name)) 
[17:03:47.303]                               next
[17:03:47.303]                             invokeRestart(restart)
[17:03:47.303]                             muffled <- TRUE
[17:03:47.303]                             break
[17:03:47.303]                           }
[17:03:47.303]                         }
[17:03:47.303]                       }
[17:03:47.303]                       invisible(muffled)
[17:03:47.303]                     }
[17:03:47.303]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.303]                   }
[17:03:47.303]                 }
[17:03:47.303]                 else {
[17:03:47.303]                   if (TRUE) {
[17:03:47.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.303]                     {
[17:03:47.303]                       inherits <- base::inherits
[17:03:47.303]                       invokeRestart <- base::invokeRestart
[17:03:47.303]                       is.null <- base::is.null
[17:03:47.303]                       muffled <- FALSE
[17:03:47.303]                       if (inherits(cond, "message")) {
[17:03:47.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.303]                         if (muffled) 
[17:03:47.303]                           invokeRestart("muffleMessage")
[17:03:47.303]                       }
[17:03:47.303]                       else if (inherits(cond, "warning")) {
[17:03:47.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.303]                         if (muffled) 
[17:03:47.303]                           invokeRestart("muffleWarning")
[17:03:47.303]                       }
[17:03:47.303]                       else if (inherits(cond, "condition")) {
[17:03:47.303]                         if (!is.null(pattern)) {
[17:03:47.303]                           computeRestarts <- base::computeRestarts
[17:03:47.303]                           grepl <- base::grepl
[17:03:47.303]                           restarts <- computeRestarts(cond)
[17:03:47.303]                           for (restart in restarts) {
[17:03:47.303]                             name <- restart$name
[17:03:47.303]                             if (is.null(name)) 
[17:03:47.303]                               next
[17:03:47.303]                             if (!grepl(pattern, name)) 
[17:03:47.303]                               next
[17:03:47.303]                             invokeRestart(restart)
[17:03:47.303]                             muffled <- TRUE
[17:03:47.303]                             break
[17:03:47.303]                           }
[17:03:47.303]                         }
[17:03:47.303]                       }
[17:03:47.303]                       invisible(muffled)
[17:03:47.303]                     }
[17:03:47.303]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.303]                   }
[17:03:47.303]                 }
[17:03:47.303]             }
[17:03:47.303]         }))
[17:03:47.303]     }, error = function(ex) {
[17:03:47.303]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:47.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.303]                 ...future.rng), started = ...future.startTime, 
[17:03:47.303]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:47.303]             version = "1.8"), class = "FutureResult")
[17:03:47.303]     }, finally = {
[17:03:47.303]         if (!identical(...future.workdir, getwd())) 
[17:03:47.303]             setwd(...future.workdir)
[17:03:47.303]         {
[17:03:47.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:47.303]                 ...future.oldOptions$nwarnings <- NULL
[17:03:47.303]             }
[17:03:47.303]             base::options(...future.oldOptions)
[17:03:47.303]             if (.Platform$OS.type == "windows") {
[17:03:47.303]                 old_names <- names(...future.oldEnvVars)
[17:03:47.303]                 envs <- base::Sys.getenv()
[17:03:47.303]                 names <- names(envs)
[17:03:47.303]                 common <- intersect(names, old_names)
[17:03:47.303]                 added <- setdiff(names, old_names)
[17:03:47.303]                 removed <- setdiff(old_names, names)
[17:03:47.303]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:47.303]                   envs[common]]
[17:03:47.303]                 NAMES <- toupper(changed)
[17:03:47.303]                 args <- list()
[17:03:47.303]                 for (kk in seq_along(NAMES)) {
[17:03:47.303]                   name <- changed[[kk]]
[17:03:47.303]                   NAME <- NAMES[[kk]]
[17:03:47.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.303]                     next
[17:03:47.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.303]                 }
[17:03:47.303]                 NAMES <- toupper(added)
[17:03:47.303]                 for (kk in seq_along(NAMES)) {
[17:03:47.303]                   name <- added[[kk]]
[17:03:47.303]                   NAME <- NAMES[[kk]]
[17:03:47.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.303]                     next
[17:03:47.303]                   args[[name]] <- ""
[17:03:47.303]                 }
[17:03:47.303]                 NAMES <- toupper(removed)
[17:03:47.303]                 for (kk in seq_along(NAMES)) {
[17:03:47.303]                   name <- removed[[kk]]
[17:03:47.303]                   NAME <- NAMES[[kk]]
[17:03:47.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.303]                     next
[17:03:47.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.303]                 }
[17:03:47.303]                 if (length(args) > 0) 
[17:03:47.303]                   base::do.call(base::Sys.setenv, args = args)
[17:03:47.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:47.303]             }
[17:03:47.303]             else {
[17:03:47.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:47.303]             }
[17:03:47.303]             {
[17:03:47.303]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:47.303]                   0L) {
[17:03:47.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:47.303]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:47.303]                   base::options(opts)
[17:03:47.303]                 }
[17:03:47.303]                 {
[17:03:47.303]                   {
[17:03:47.303]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:47.303]                     NULL
[17:03:47.303]                   }
[17:03:47.303]                   options(future.plan = NULL)
[17:03:47.303]                   if (is.na(NA_character_)) 
[17:03:47.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:47.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:47.303]                     .init = FALSE)
[17:03:47.303]                 }
[17:03:47.303]             }
[17:03:47.303]         }
[17:03:47.303]     })
[17:03:47.303]     if (TRUE) {
[17:03:47.303]         base::sink(type = "output", split = FALSE)
[17:03:47.303]         if (TRUE) {
[17:03:47.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:47.303]         }
[17:03:47.303]         else {
[17:03:47.303]             ...future.result["stdout"] <- base::list(NULL)
[17:03:47.303]         }
[17:03:47.303]         base::close(...future.stdout)
[17:03:47.303]         ...future.stdout <- NULL
[17:03:47.303]     }
[17:03:47.303]     ...future.result$conditions <- ...future.conditions
[17:03:47.303]     ...future.result$finished <- base::Sys.time()
[17:03:47.303]     ...future.result
[17:03:47.303] }
[17:03:47.305] MultisessionFuture started
[17:03:47.306] - Launch lazy future ... done
[17:03:47.306] run() for ‘MultisessionFuture’ ... done
[17:03:47.307] receiveMessageFromWorker() for ClusterFuture ...
[17:03:47.307] - Validating connection of MultisessionFuture
[17:03:47.308] - received message: FutureResult
[17:03:47.308] - Received FutureResult
[17:03:47.308] - Erased future from FutureRegistry
[17:03:47.308] result() for ClusterFuture ...
[17:03:47.308] - result already collected: FutureResult
[17:03:47.308] result() for ClusterFuture ... done
[17:03:47.308] signalConditions() ...
[17:03:47.308]  - include = ‘immediateCondition’
[17:03:47.308]  - exclude = 
[17:03:47.308]  - resignal = FALSE
[17:03:47.309]  - Number of conditions: 1
[17:03:47.309] signalConditions() ... done
[17:03:47.309] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:47.309] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[17:03:47.309] getGlobalsAndPackages() ...
[17:03:47.309] Searching for globals...
[17:03:47.310] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:47.310] Searching for globals ... DONE
[17:03:47.310] Resolving globals: FALSE
[17:03:47.311] 
[17:03:47.311] 
[17:03:47.311] getGlobalsAndPackages() ... DONE
[17:03:47.311] run() for ‘Future’ ...
[17:03:47.311] - state: ‘created’
[17:03:47.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:47.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:47.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:47.325]   - Field: ‘node’
[17:03:47.325]   - Field: ‘label’
[17:03:47.325]   - Field: ‘local’
[17:03:47.325]   - Field: ‘owner’
[17:03:47.325]   - Field: ‘envir’
[17:03:47.326]   - Field: ‘workers’
[17:03:47.326]   - Field: ‘packages’
[17:03:47.326]   - Field: ‘gc’
[17:03:47.326]   - Field: ‘conditions’
[17:03:47.326]   - Field: ‘persistent’
[17:03:47.326]   - Field: ‘expr’
[17:03:47.326]   - Field: ‘uuid’
[17:03:47.326]   - Field: ‘seed’
[17:03:47.326]   - Field: ‘version’
[17:03:47.326]   - Field: ‘result’
[17:03:47.326]   - Field: ‘asynchronous’
[17:03:47.327]   - Field: ‘calls’
[17:03:47.327]   - Field: ‘globals’
[17:03:47.327]   - Field: ‘stdout’
[17:03:47.327]   - Field: ‘earlySignal’
[17:03:47.327]   - Field: ‘lazy’
[17:03:47.327]   - Field: ‘state’
[17:03:47.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:47.327] - Launch lazy future ...
[17:03:47.327] Packages needed by the future expression (n = 0): <none>
[17:03:47.328] Packages needed by future strategies (n = 0): <none>
[17:03:47.328] {
[17:03:47.328]     {
[17:03:47.328]         {
[17:03:47.328]             ...future.startTime <- base::Sys.time()
[17:03:47.328]             {
[17:03:47.328]                 {
[17:03:47.328]                   {
[17:03:47.328]                     {
[17:03:47.328]                       base::local({
[17:03:47.328]                         has_future <- base::requireNamespace("future", 
[17:03:47.328]                           quietly = TRUE)
[17:03:47.328]                         if (has_future) {
[17:03:47.328]                           ns <- base::getNamespace("future")
[17:03:47.328]                           version <- ns[[".package"]][["version"]]
[17:03:47.328]                           if (is.null(version)) 
[17:03:47.328]                             version <- utils::packageVersion("future")
[17:03:47.328]                         }
[17:03:47.328]                         else {
[17:03:47.328]                           version <- NULL
[17:03:47.328]                         }
[17:03:47.328]                         if (!has_future || version < "1.8.0") {
[17:03:47.328]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:47.328]                             "", base::R.version$version.string), 
[17:03:47.328]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:47.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:47.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:47.328]                               "release", "version")], collapse = " "), 
[17:03:47.328]                             hostname = base::Sys.info()[["nodename"]])
[17:03:47.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:47.328]                             info)
[17:03:47.328]                           info <- base::paste(info, collapse = "; ")
[17:03:47.328]                           if (!has_future) {
[17:03:47.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:47.328]                               info)
[17:03:47.328]                           }
[17:03:47.328]                           else {
[17:03:47.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:47.328]                               info, version)
[17:03:47.328]                           }
[17:03:47.328]                           base::stop(msg)
[17:03:47.328]                         }
[17:03:47.328]                       })
[17:03:47.328]                     }
[17:03:47.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:47.328]                     base::options(mc.cores = 1L)
[17:03:47.328]                   }
[17:03:47.328]                   ...future.strategy.old <- future::plan("list")
[17:03:47.328]                   options(future.plan = NULL)
[17:03:47.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:47.328]                 }
[17:03:47.328]                 ...future.workdir <- getwd()
[17:03:47.328]             }
[17:03:47.328]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:47.328]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:47.328]         }
[17:03:47.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:47.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:47.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:47.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:47.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:47.328]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:47.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:47.328]             base::names(...future.oldOptions))
[17:03:47.328]     }
[17:03:47.328]     if (FALSE) {
[17:03:47.328]     }
[17:03:47.328]     else {
[17:03:47.328]         if (TRUE) {
[17:03:47.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:47.328]                 open = "w")
[17:03:47.328]         }
[17:03:47.328]         else {
[17:03:47.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:47.328]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:47.328]         }
[17:03:47.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:47.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:47.328]             base::sink(type = "output", split = FALSE)
[17:03:47.328]             base::close(...future.stdout)
[17:03:47.328]         }, add = TRUE)
[17:03:47.328]     }
[17:03:47.328]     ...future.frame <- base::sys.nframe()
[17:03:47.328]     ...future.conditions <- base::list()
[17:03:47.328]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:47.328]     if (FALSE) {
[17:03:47.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:47.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:47.328]     }
[17:03:47.328]     ...future.result <- base::tryCatch({
[17:03:47.328]         base::withCallingHandlers({
[17:03:47.328]             ...future.value <- base::withVisible(base::local({
[17:03:47.328]                 ...future.makeSendCondition <- base::local({
[17:03:47.328]                   sendCondition <- NULL
[17:03:47.328]                   function(frame = 1L) {
[17:03:47.328]                     if (is.function(sendCondition)) 
[17:03:47.328]                       return(sendCondition)
[17:03:47.328]                     ns <- getNamespace("parallel")
[17:03:47.328]                     if (exists("sendData", mode = "function", 
[17:03:47.328]                       envir = ns)) {
[17:03:47.328]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:47.328]                         envir = ns)
[17:03:47.328]                       envir <- sys.frame(frame)
[17:03:47.328]                       master <- NULL
[17:03:47.328]                       while (!identical(envir, .GlobalEnv) && 
[17:03:47.328]                         !identical(envir, emptyenv())) {
[17:03:47.328]                         if (exists("master", mode = "list", envir = envir, 
[17:03:47.328]                           inherits = FALSE)) {
[17:03:47.328]                           master <- get("master", mode = "list", 
[17:03:47.328]                             envir = envir, inherits = FALSE)
[17:03:47.328]                           if (inherits(master, c("SOCKnode", 
[17:03:47.328]                             "SOCK0node"))) {
[17:03:47.328]                             sendCondition <<- function(cond) {
[17:03:47.328]                               data <- list(type = "VALUE", value = cond, 
[17:03:47.328]                                 success = TRUE)
[17:03:47.328]                               parallel_sendData(master, data)
[17:03:47.328]                             }
[17:03:47.328]                             return(sendCondition)
[17:03:47.328]                           }
[17:03:47.328]                         }
[17:03:47.328]                         frame <- frame + 1L
[17:03:47.328]                         envir <- sys.frame(frame)
[17:03:47.328]                       }
[17:03:47.328]                     }
[17:03:47.328]                     sendCondition <<- function(cond) NULL
[17:03:47.328]                   }
[17:03:47.328]                 })
[17:03:47.328]                 withCallingHandlers({
[17:03:47.328]                   {
[17:03:47.328]                     Sys.sleep(0.5)
[17:03:47.328]                     list(a = 1, b = 42L)
[17:03:47.328]                   }
[17:03:47.328]                 }, immediateCondition = function(cond) {
[17:03:47.328]                   sendCondition <- ...future.makeSendCondition()
[17:03:47.328]                   sendCondition(cond)
[17:03:47.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.328]                   {
[17:03:47.328]                     inherits <- base::inherits
[17:03:47.328]                     invokeRestart <- base::invokeRestart
[17:03:47.328]                     is.null <- base::is.null
[17:03:47.328]                     muffled <- FALSE
[17:03:47.328]                     if (inherits(cond, "message")) {
[17:03:47.328]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:47.328]                       if (muffled) 
[17:03:47.328]                         invokeRestart("muffleMessage")
[17:03:47.328]                     }
[17:03:47.328]                     else if (inherits(cond, "warning")) {
[17:03:47.328]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:47.328]                       if (muffled) 
[17:03:47.328]                         invokeRestart("muffleWarning")
[17:03:47.328]                     }
[17:03:47.328]                     else if (inherits(cond, "condition")) {
[17:03:47.328]                       if (!is.null(pattern)) {
[17:03:47.328]                         computeRestarts <- base::computeRestarts
[17:03:47.328]                         grepl <- base::grepl
[17:03:47.328]                         restarts <- computeRestarts(cond)
[17:03:47.328]                         for (restart in restarts) {
[17:03:47.328]                           name <- restart$name
[17:03:47.328]                           if (is.null(name)) 
[17:03:47.328]                             next
[17:03:47.328]                           if (!grepl(pattern, name)) 
[17:03:47.328]                             next
[17:03:47.328]                           invokeRestart(restart)
[17:03:47.328]                           muffled <- TRUE
[17:03:47.328]                           break
[17:03:47.328]                         }
[17:03:47.328]                       }
[17:03:47.328]                     }
[17:03:47.328]                     invisible(muffled)
[17:03:47.328]                   }
[17:03:47.328]                   muffleCondition(cond)
[17:03:47.328]                 })
[17:03:47.328]             }))
[17:03:47.328]             future::FutureResult(value = ...future.value$value, 
[17:03:47.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.328]                   ...future.rng), globalenv = if (FALSE) 
[17:03:47.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:47.328]                     ...future.globalenv.names))
[17:03:47.328]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:47.328]         }, condition = base::local({
[17:03:47.328]             c <- base::c
[17:03:47.328]             inherits <- base::inherits
[17:03:47.328]             invokeRestart <- base::invokeRestart
[17:03:47.328]             length <- base::length
[17:03:47.328]             list <- base::list
[17:03:47.328]             seq.int <- base::seq.int
[17:03:47.328]             signalCondition <- base::signalCondition
[17:03:47.328]             sys.calls <- base::sys.calls
[17:03:47.328]             `[[` <- base::`[[`
[17:03:47.328]             `+` <- base::`+`
[17:03:47.328]             `<<-` <- base::`<<-`
[17:03:47.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:47.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:47.328]                   3L)]
[17:03:47.328]             }
[17:03:47.328]             function(cond) {
[17:03:47.328]                 is_error <- inherits(cond, "error")
[17:03:47.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:47.328]                   NULL)
[17:03:47.328]                 if (is_error) {
[17:03:47.328]                   sessionInformation <- function() {
[17:03:47.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:47.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:47.328]                       search = base::search(), system = base::Sys.info())
[17:03:47.328]                   }
[17:03:47.328]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:47.328]                     cond$call), session = sessionInformation(), 
[17:03:47.328]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:47.328]                   signalCondition(cond)
[17:03:47.328]                 }
[17:03:47.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:47.328]                 "immediateCondition"))) {
[17:03:47.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:47.328]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:47.328]                   if (TRUE && !signal) {
[17:03:47.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.328]                     {
[17:03:47.328]                       inherits <- base::inherits
[17:03:47.328]                       invokeRestart <- base::invokeRestart
[17:03:47.328]                       is.null <- base::is.null
[17:03:47.328]                       muffled <- FALSE
[17:03:47.328]                       if (inherits(cond, "message")) {
[17:03:47.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.328]                         if (muffled) 
[17:03:47.328]                           invokeRestart("muffleMessage")
[17:03:47.328]                       }
[17:03:47.328]                       else if (inherits(cond, "warning")) {
[17:03:47.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.328]                         if (muffled) 
[17:03:47.328]                           invokeRestart("muffleWarning")
[17:03:47.328]                       }
[17:03:47.328]                       else if (inherits(cond, "condition")) {
[17:03:47.328]                         if (!is.null(pattern)) {
[17:03:47.328]                           computeRestarts <- base::computeRestarts
[17:03:47.328]                           grepl <- base::grepl
[17:03:47.328]                           restarts <- computeRestarts(cond)
[17:03:47.328]                           for (restart in restarts) {
[17:03:47.328]                             name <- restart$name
[17:03:47.328]                             if (is.null(name)) 
[17:03:47.328]                               next
[17:03:47.328]                             if (!grepl(pattern, name)) 
[17:03:47.328]                               next
[17:03:47.328]                             invokeRestart(restart)
[17:03:47.328]                             muffled <- TRUE
[17:03:47.328]                             break
[17:03:47.328]                           }
[17:03:47.328]                         }
[17:03:47.328]                       }
[17:03:47.328]                       invisible(muffled)
[17:03:47.328]                     }
[17:03:47.328]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.328]                   }
[17:03:47.328]                 }
[17:03:47.328]                 else {
[17:03:47.328]                   if (TRUE) {
[17:03:47.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.328]                     {
[17:03:47.328]                       inherits <- base::inherits
[17:03:47.328]                       invokeRestart <- base::invokeRestart
[17:03:47.328]                       is.null <- base::is.null
[17:03:47.328]                       muffled <- FALSE
[17:03:47.328]                       if (inherits(cond, "message")) {
[17:03:47.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.328]                         if (muffled) 
[17:03:47.328]                           invokeRestart("muffleMessage")
[17:03:47.328]                       }
[17:03:47.328]                       else if (inherits(cond, "warning")) {
[17:03:47.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.328]                         if (muffled) 
[17:03:47.328]                           invokeRestart("muffleWarning")
[17:03:47.328]                       }
[17:03:47.328]                       else if (inherits(cond, "condition")) {
[17:03:47.328]                         if (!is.null(pattern)) {
[17:03:47.328]                           computeRestarts <- base::computeRestarts
[17:03:47.328]                           grepl <- base::grepl
[17:03:47.328]                           restarts <- computeRestarts(cond)
[17:03:47.328]                           for (restart in restarts) {
[17:03:47.328]                             name <- restart$name
[17:03:47.328]                             if (is.null(name)) 
[17:03:47.328]                               next
[17:03:47.328]                             if (!grepl(pattern, name)) 
[17:03:47.328]                               next
[17:03:47.328]                             invokeRestart(restart)
[17:03:47.328]                             muffled <- TRUE
[17:03:47.328]                             break
[17:03:47.328]                           }
[17:03:47.328]                         }
[17:03:47.328]                       }
[17:03:47.328]                       invisible(muffled)
[17:03:47.328]                     }
[17:03:47.328]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.328]                   }
[17:03:47.328]                 }
[17:03:47.328]             }
[17:03:47.328]         }))
[17:03:47.328]     }, error = function(ex) {
[17:03:47.328]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:47.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.328]                 ...future.rng), started = ...future.startTime, 
[17:03:47.328]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:47.328]             version = "1.8"), class = "FutureResult")
[17:03:47.328]     }, finally = {
[17:03:47.328]         if (!identical(...future.workdir, getwd())) 
[17:03:47.328]             setwd(...future.workdir)
[17:03:47.328]         {
[17:03:47.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:47.328]                 ...future.oldOptions$nwarnings <- NULL
[17:03:47.328]             }
[17:03:47.328]             base::options(...future.oldOptions)
[17:03:47.328]             if (.Platform$OS.type == "windows") {
[17:03:47.328]                 old_names <- names(...future.oldEnvVars)
[17:03:47.328]                 envs <- base::Sys.getenv()
[17:03:47.328]                 names <- names(envs)
[17:03:47.328]                 common <- intersect(names, old_names)
[17:03:47.328]                 added <- setdiff(names, old_names)
[17:03:47.328]                 removed <- setdiff(old_names, names)
[17:03:47.328]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:47.328]                   envs[common]]
[17:03:47.328]                 NAMES <- toupper(changed)
[17:03:47.328]                 args <- list()
[17:03:47.328]                 for (kk in seq_along(NAMES)) {
[17:03:47.328]                   name <- changed[[kk]]
[17:03:47.328]                   NAME <- NAMES[[kk]]
[17:03:47.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.328]                     next
[17:03:47.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.328]                 }
[17:03:47.328]                 NAMES <- toupper(added)
[17:03:47.328]                 for (kk in seq_along(NAMES)) {
[17:03:47.328]                   name <- added[[kk]]
[17:03:47.328]                   NAME <- NAMES[[kk]]
[17:03:47.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.328]                     next
[17:03:47.328]                   args[[name]] <- ""
[17:03:47.328]                 }
[17:03:47.328]                 NAMES <- toupper(removed)
[17:03:47.328]                 for (kk in seq_along(NAMES)) {
[17:03:47.328]                   name <- removed[[kk]]
[17:03:47.328]                   NAME <- NAMES[[kk]]
[17:03:47.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.328]                     next
[17:03:47.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.328]                 }
[17:03:47.328]                 if (length(args) > 0) 
[17:03:47.328]                   base::do.call(base::Sys.setenv, args = args)
[17:03:47.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:47.328]             }
[17:03:47.328]             else {
[17:03:47.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:47.328]             }
[17:03:47.328]             {
[17:03:47.328]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:47.328]                   0L) {
[17:03:47.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:47.328]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:47.328]                   base::options(opts)
[17:03:47.328]                 }
[17:03:47.328]                 {
[17:03:47.328]                   {
[17:03:47.328]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:47.328]                     NULL
[17:03:47.328]                   }
[17:03:47.328]                   options(future.plan = NULL)
[17:03:47.328]                   if (is.na(NA_character_)) 
[17:03:47.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:47.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:47.328]                     .init = FALSE)
[17:03:47.328]                 }
[17:03:47.328]             }
[17:03:47.328]         }
[17:03:47.328]     })
[17:03:47.328]     if (TRUE) {
[17:03:47.328]         base::sink(type = "output", split = FALSE)
[17:03:47.328]         if (TRUE) {
[17:03:47.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:47.328]         }
[17:03:47.328]         else {
[17:03:47.328]             ...future.result["stdout"] <- base::list(NULL)
[17:03:47.328]         }
[17:03:47.328]         base::close(...future.stdout)
[17:03:47.328]         ...future.stdout <- NULL
[17:03:47.328]     }
[17:03:47.328]     ...future.result$conditions <- ...future.conditions
[17:03:47.328]     ...future.result$finished <- base::Sys.time()
[17:03:47.328]     ...future.result
[17:03:47.328] }
[17:03:47.331] MultisessionFuture started
[17:03:47.331] - Launch lazy future ... done
[17:03:47.331] run() for ‘MultisessionFuture’ ... done
[17:03:47.833] receiveMessageFromWorker() for ClusterFuture ...
[17:03:47.834] - Validating connection of MultisessionFuture
[17:03:47.834] - received message: FutureResult
[17:03:47.834] - Received FutureResult
[17:03:47.834] - Erased future from FutureRegistry
[17:03:47.834] result() for ClusterFuture ...
[17:03:47.834] - result already collected: FutureResult
[17:03:47.837] result() for ClusterFuture ... done
[17:03:47.837] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:47.837] A MultisessionFuture was resolved (result was not collected)
[17:03:47.837] getGlobalsAndPackages() ...
[17:03:47.837] Searching for globals...
[17:03:47.838] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:47.838] Searching for globals ... DONE
[17:03:47.838] Resolving globals: FALSE
[17:03:47.839] 
[17:03:47.839] 
[17:03:47.839] getGlobalsAndPackages() ... DONE
[17:03:47.839] run() for ‘Future’ ...
[17:03:47.839] - state: ‘created’
[17:03:47.839] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:47.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:47.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:47.853]   - Field: ‘node’
[17:03:47.853]   - Field: ‘label’
[17:03:47.854]   - Field: ‘local’
[17:03:47.854]   - Field: ‘owner’
[17:03:47.854]   - Field: ‘envir’
[17:03:47.854]   - Field: ‘workers’
[17:03:47.854]   - Field: ‘packages’
[17:03:47.854]   - Field: ‘gc’
[17:03:47.854]   - Field: ‘conditions’
[17:03:47.854]   - Field: ‘persistent’
[17:03:47.854]   - Field: ‘expr’
[17:03:47.854]   - Field: ‘uuid’
[17:03:47.854]   - Field: ‘seed’
[17:03:47.855]   - Field: ‘version’
[17:03:47.855]   - Field: ‘result’
[17:03:47.855]   - Field: ‘asynchronous’
[17:03:47.855]   - Field: ‘calls’
[17:03:47.855]   - Field: ‘globals’
[17:03:47.855]   - Field: ‘stdout’
[17:03:47.855]   - Field: ‘earlySignal’
[17:03:47.855]   - Field: ‘lazy’
[17:03:47.855]   - Field: ‘state’
[17:03:47.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:47.855] - Launch lazy future ...
[17:03:47.856] Packages needed by the future expression (n = 0): <none>
[17:03:47.856] Packages needed by future strategies (n = 0): <none>
[17:03:47.856] {
[17:03:47.856]     {
[17:03:47.856]         {
[17:03:47.856]             ...future.startTime <- base::Sys.time()
[17:03:47.856]             {
[17:03:47.856]                 {
[17:03:47.856]                   {
[17:03:47.856]                     {
[17:03:47.856]                       base::local({
[17:03:47.856]                         has_future <- base::requireNamespace("future", 
[17:03:47.856]                           quietly = TRUE)
[17:03:47.856]                         if (has_future) {
[17:03:47.856]                           ns <- base::getNamespace("future")
[17:03:47.856]                           version <- ns[[".package"]][["version"]]
[17:03:47.856]                           if (is.null(version)) 
[17:03:47.856]                             version <- utils::packageVersion("future")
[17:03:47.856]                         }
[17:03:47.856]                         else {
[17:03:47.856]                           version <- NULL
[17:03:47.856]                         }
[17:03:47.856]                         if (!has_future || version < "1.8.0") {
[17:03:47.856]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:47.856]                             "", base::R.version$version.string), 
[17:03:47.856]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:47.856]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:47.856]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:47.856]                               "release", "version")], collapse = " "), 
[17:03:47.856]                             hostname = base::Sys.info()[["nodename"]])
[17:03:47.856]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:47.856]                             info)
[17:03:47.856]                           info <- base::paste(info, collapse = "; ")
[17:03:47.856]                           if (!has_future) {
[17:03:47.856]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:47.856]                               info)
[17:03:47.856]                           }
[17:03:47.856]                           else {
[17:03:47.856]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:47.856]                               info, version)
[17:03:47.856]                           }
[17:03:47.856]                           base::stop(msg)
[17:03:47.856]                         }
[17:03:47.856]                       })
[17:03:47.856]                     }
[17:03:47.856]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:47.856]                     base::options(mc.cores = 1L)
[17:03:47.856]                   }
[17:03:47.856]                   ...future.strategy.old <- future::plan("list")
[17:03:47.856]                   options(future.plan = NULL)
[17:03:47.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:47.856]                 }
[17:03:47.856]                 ...future.workdir <- getwd()
[17:03:47.856]             }
[17:03:47.856]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:47.856]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:47.856]         }
[17:03:47.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:47.856]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:47.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:47.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:47.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:47.856]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:47.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:47.856]             base::names(...future.oldOptions))
[17:03:47.856]     }
[17:03:47.856]     if (FALSE) {
[17:03:47.856]     }
[17:03:47.856]     else {
[17:03:47.856]         if (TRUE) {
[17:03:47.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:47.856]                 open = "w")
[17:03:47.856]         }
[17:03:47.856]         else {
[17:03:47.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:47.856]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:47.856]         }
[17:03:47.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:47.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:47.856]             base::sink(type = "output", split = FALSE)
[17:03:47.856]             base::close(...future.stdout)
[17:03:47.856]         }, add = TRUE)
[17:03:47.856]     }
[17:03:47.856]     ...future.frame <- base::sys.nframe()
[17:03:47.856]     ...future.conditions <- base::list()
[17:03:47.856]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:47.856]     if (FALSE) {
[17:03:47.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:47.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:47.856]     }
[17:03:47.856]     ...future.result <- base::tryCatch({
[17:03:47.856]         base::withCallingHandlers({
[17:03:47.856]             ...future.value <- base::withVisible(base::local({
[17:03:47.856]                 ...future.makeSendCondition <- base::local({
[17:03:47.856]                   sendCondition <- NULL
[17:03:47.856]                   function(frame = 1L) {
[17:03:47.856]                     if (is.function(sendCondition)) 
[17:03:47.856]                       return(sendCondition)
[17:03:47.856]                     ns <- getNamespace("parallel")
[17:03:47.856]                     if (exists("sendData", mode = "function", 
[17:03:47.856]                       envir = ns)) {
[17:03:47.856]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:47.856]                         envir = ns)
[17:03:47.856]                       envir <- sys.frame(frame)
[17:03:47.856]                       master <- NULL
[17:03:47.856]                       while (!identical(envir, .GlobalEnv) && 
[17:03:47.856]                         !identical(envir, emptyenv())) {
[17:03:47.856]                         if (exists("master", mode = "list", envir = envir, 
[17:03:47.856]                           inherits = FALSE)) {
[17:03:47.856]                           master <- get("master", mode = "list", 
[17:03:47.856]                             envir = envir, inherits = FALSE)
[17:03:47.856]                           if (inherits(master, c("SOCKnode", 
[17:03:47.856]                             "SOCK0node"))) {
[17:03:47.856]                             sendCondition <<- function(cond) {
[17:03:47.856]                               data <- list(type = "VALUE", value = cond, 
[17:03:47.856]                                 success = TRUE)
[17:03:47.856]                               parallel_sendData(master, data)
[17:03:47.856]                             }
[17:03:47.856]                             return(sendCondition)
[17:03:47.856]                           }
[17:03:47.856]                         }
[17:03:47.856]                         frame <- frame + 1L
[17:03:47.856]                         envir <- sys.frame(frame)
[17:03:47.856]                       }
[17:03:47.856]                     }
[17:03:47.856]                     sendCondition <<- function(cond) NULL
[17:03:47.856]                   }
[17:03:47.856]                 })
[17:03:47.856]                 withCallingHandlers({
[17:03:47.856]                   {
[17:03:47.856]                     Sys.sleep(0.5)
[17:03:47.856]                     list(a = 1, b = 42L)
[17:03:47.856]                   }
[17:03:47.856]                 }, immediateCondition = function(cond) {
[17:03:47.856]                   sendCondition <- ...future.makeSendCondition()
[17:03:47.856]                   sendCondition(cond)
[17:03:47.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.856]                   {
[17:03:47.856]                     inherits <- base::inherits
[17:03:47.856]                     invokeRestart <- base::invokeRestart
[17:03:47.856]                     is.null <- base::is.null
[17:03:47.856]                     muffled <- FALSE
[17:03:47.856]                     if (inherits(cond, "message")) {
[17:03:47.856]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:47.856]                       if (muffled) 
[17:03:47.856]                         invokeRestart("muffleMessage")
[17:03:47.856]                     }
[17:03:47.856]                     else if (inherits(cond, "warning")) {
[17:03:47.856]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:47.856]                       if (muffled) 
[17:03:47.856]                         invokeRestart("muffleWarning")
[17:03:47.856]                     }
[17:03:47.856]                     else if (inherits(cond, "condition")) {
[17:03:47.856]                       if (!is.null(pattern)) {
[17:03:47.856]                         computeRestarts <- base::computeRestarts
[17:03:47.856]                         grepl <- base::grepl
[17:03:47.856]                         restarts <- computeRestarts(cond)
[17:03:47.856]                         for (restart in restarts) {
[17:03:47.856]                           name <- restart$name
[17:03:47.856]                           if (is.null(name)) 
[17:03:47.856]                             next
[17:03:47.856]                           if (!grepl(pattern, name)) 
[17:03:47.856]                             next
[17:03:47.856]                           invokeRestart(restart)
[17:03:47.856]                           muffled <- TRUE
[17:03:47.856]                           break
[17:03:47.856]                         }
[17:03:47.856]                       }
[17:03:47.856]                     }
[17:03:47.856]                     invisible(muffled)
[17:03:47.856]                   }
[17:03:47.856]                   muffleCondition(cond)
[17:03:47.856]                 })
[17:03:47.856]             }))
[17:03:47.856]             future::FutureResult(value = ...future.value$value, 
[17:03:47.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.856]                   ...future.rng), globalenv = if (FALSE) 
[17:03:47.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:47.856]                     ...future.globalenv.names))
[17:03:47.856]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:47.856]         }, condition = base::local({
[17:03:47.856]             c <- base::c
[17:03:47.856]             inherits <- base::inherits
[17:03:47.856]             invokeRestart <- base::invokeRestart
[17:03:47.856]             length <- base::length
[17:03:47.856]             list <- base::list
[17:03:47.856]             seq.int <- base::seq.int
[17:03:47.856]             signalCondition <- base::signalCondition
[17:03:47.856]             sys.calls <- base::sys.calls
[17:03:47.856]             `[[` <- base::`[[`
[17:03:47.856]             `+` <- base::`+`
[17:03:47.856]             `<<-` <- base::`<<-`
[17:03:47.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:47.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:47.856]                   3L)]
[17:03:47.856]             }
[17:03:47.856]             function(cond) {
[17:03:47.856]                 is_error <- inherits(cond, "error")
[17:03:47.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:47.856]                   NULL)
[17:03:47.856]                 if (is_error) {
[17:03:47.856]                   sessionInformation <- function() {
[17:03:47.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:47.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:47.856]                       search = base::search(), system = base::Sys.info())
[17:03:47.856]                   }
[17:03:47.856]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:47.856]                     cond$call), session = sessionInformation(), 
[17:03:47.856]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:47.856]                   signalCondition(cond)
[17:03:47.856]                 }
[17:03:47.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:47.856]                 "immediateCondition"))) {
[17:03:47.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:47.856]                   ...future.conditions[[length(...future.conditions) + 
[17:03:47.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:47.856]                   if (TRUE && !signal) {
[17:03:47.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.856]                     {
[17:03:47.856]                       inherits <- base::inherits
[17:03:47.856]                       invokeRestart <- base::invokeRestart
[17:03:47.856]                       is.null <- base::is.null
[17:03:47.856]                       muffled <- FALSE
[17:03:47.856]                       if (inherits(cond, "message")) {
[17:03:47.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.856]                         if (muffled) 
[17:03:47.856]                           invokeRestart("muffleMessage")
[17:03:47.856]                       }
[17:03:47.856]                       else if (inherits(cond, "warning")) {
[17:03:47.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.856]                         if (muffled) 
[17:03:47.856]                           invokeRestart("muffleWarning")
[17:03:47.856]                       }
[17:03:47.856]                       else if (inherits(cond, "condition")) {
[17:03:47.856]                         if (!is.null(pattern)) {
[17:03:47.856]                           computeRestarts <- base::computeRestarts
[17:03:47.856]                           grepl <- base::grepl
[17:03:47.856]                           restarts <- computeRestarts(cond)
[17:03:47.856]                           for (restart in restarts) {
[17:03:47.856]                             name <- restart$name
[17:03:47.856]                             if (is.null(name)) 
[17:03:47.856]                               next
[17:03:47.856]                             if (!grepl(pattern, name)) 
[17:03:47.856]                               next
[17:03:47.856]                             invokeRestart(restart)
[17:03:47.856]                             muffled <- TRUE
[17:03:47.856]                             break
[17:03:47.856]                           }
[17:03:47.856]                         }
[17:03:47.856]                       }
[17:03:47.856]                       invisible(muffled)
[17:03:47.856]                     }
[17:03:47.856]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.856]                   }
[17:03:47.856]                 }
[17:03:47.856]                 else {
[17:03:47.856]                   if (TRUE) {
[17:03:47.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:47.856]                     {
[17:03:47.856]                       inherits <- base::inherits
[17:03:47.856]                       invokeRestart <- base::invokeRestart
[17:03:47.856]                       is.null <- base::is.null
[17:03:47.856]                       muffled <- FALSE
[17:03:47.856]                       if (inherits(cond, "message")) {
[17:03:47.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:47.856]                         if (muffled) 
[17:03:47.856]                           invokeRestart("muffleMessage")
[17:03:47.856]                       }
[17:03:47.856]                       else if (inherits(cond, "warning")) {
[17:03:47.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:47.856]                         if (muffled) 
[17:03:47.856]                           invokeRestart("muffleWarning")
[17:03:47.856]                       }
[17:03:47.856]                       else if (inherits(cond, "condition")) {
[17:03:47.856]                         if (!is.null(pattern)) {
[17:03:47.856]                           computeRestarts <- base::computeRestarts
[17:03:47.856]                           grepl <- base::grepl
[17:03:47.856]                           restarts <- computeRestarts(cond)
[17:03:47.856]                           for (restart in restarts) {
[17:03:47.856]                             name <- restart$name
[17:03:47.856]                             if (is.null(name)) 
[17:03:47.856]                               next
[17:03:47.856]                             if (!grepl(pattern, name)) 
[17:03:47.856]                               next
[17:03:47.856]                             invokeRestart(restart)
[17:03:47.856]                             muffled <- TRUE
[17:03:47.856]                             break
[17:03:47.856]                           }
[17:03:47.856]                         }
[17:03:47.856]                       }
[17:03:47.856]                       invisible(muffled)
[17:03:47.856]                     }
[17:03:47.856]                     muffleCondition(cond, pattern = "^muffle")
[17:03:47.856]                   }
[17:03:47.856]                 }
[17:03:47.856]             }
[17:03:47.856]         }))
[17:03:47.856]     }, error = function(ex) {
[17:03:47.856]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:47.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:47.856]                 ...future.rng), started = ...future.startTime, 
[17:03:47.856]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:47.856]             version = "1.8"), class = "FutureResult")
[17:03:47.856]     }, finally = {
[17:03:47.856]         if (!identical(...future.workdir, getwd())) 
[17:03:47.856]             setwd(...future.workdir)
[17:03:47.856]         {
[17:03:47.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:47.856]                 ...future.oldOptions$nwarnings <- NULL
[17:03:47.856]             }
[17:03:47.856]             base::options(...future.oldOptions)
[17:03:47.856]             if (.Platform$OS.type == "windows") {
[17:03:47.856]                 old_names <- names(...future.oldEnvVars)
[17:03:47.856]                 envs <- base::Sys.getenv()
[17:03:47.856]                 names <- names(envs)
[17:03:47.856]                 common <- intersect(names, old_names)
[17:03:47.856]                 added <- setdiff(names, old_names)
[17:03:47.856]                 removed <- setdiff(old_names, names)
[17:03:47.856]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:47.856]                   envs[common]]
[17:03:47.856]                 NAMES <- toupper(changed)
[17:03:47.856]                 args <- list()
[17:03:47.856]                 for (kk in seq_along(NAMES)) {
[17:03:47.856]                   name <- changed[[kk]]
[17:03:47.856]                   NAME <- NAMES[[kk]]
[17:03:47.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.856]                     next
[17:03:47.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.856]                 }
[17:03:47.856]                 NAMES <- toupper(added)
[17:03:47.856]                 for (kk in seq_along(NAMES)) {
[17:03:47.856]                   name <- added[[kk]]
[17:03:47.856]                   NAME <- NAMES[[kk]]
[17:03:47.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.856]                     next
[17:03:47.856]                   args[[name]] <- ""
[17:03:47.856]                 }
[17:03:47.856]                 NAMES <- toupper(removed)
[17:03:47.856]                 for (kk in seq_along(NAMES)) {
[17:03:47.856]                   name <- removed[[kk]]
[17:03:47.856]                   NAME <- NAMES[[kk]]
[17:03:47.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:47.856]                     next
[17:03:47.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:47.856]                 }
[17:03:47.856]                 if (length(args) > 0) 
[17:03:47.856]                   base::do.call(base::Sys.setenv, args = args)
[17:03:47.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:47.856]             }
[17:03:47.856]             else {
[17:03:47.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:47.856]             }
[17:03:47.856]             {
[17:03:47.856]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:47.856]                   0L) {
[17:03:47.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:47.856]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:47.856]                   base::options(opts)
[17:03:47.856]                 }
[17:03:47.856]                 {
[17:03:47.856]                   {
[17:03:47.856]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:47.856]                     NULL
[17:03:47.856]                   }
[17:03:47.856]                   options(future.plan = NULL)
[17:03:47.856]                   if (is.na(NA_character_)) 
[17:03:47.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:47.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:47.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:47.856]                     .init = FALSE)
[17:03:47.856]                 }
[17:03:47.856]             }
[17:03:47.856]         }
[17:03:47.856]     })
[17:03:47.856]     if (TRUE) {
[17:03:47.856]         base::sink(type = "output", split = FALSE)
[17:03:47.856]         if (TRUE) {
[17:03:47.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:47.856]         }
[17:03:47.856]         else {
[17:03:47.856]             ...future.result["stdout"] <- base::list(NULL)
[17:03:47.856]         }
[17:03:47.856]         base::close(...future.stdout)
[17:03:47.856]         ...future.stdout <- NULL
[17:03:47.856]     }
[17:03:47.856]     ...future.result$conditions <- ...future.conditions
[17:03:47.856]     ...future.result$finished <- base::Sys.time()
[17:03:47.856]     ...future.result
[17:03:47.856] }
[17:03:47.859] MultisessionFuture started
[17:03:47.859] - Launch lazy future ... done
[17:03:47.859] run() for ‘MultisessionFuture’ ... done
[17:03:48.362] receiveMessageFromWorker() for ClusterFuture ...
[17:03:48.362] - Validating connection of MultisessionFuture
[17:03:48.362] - received message: FutureResult
[17:03:48.362] - Received FutureResult
[17:03:48.362] - Erased future from FutureRegistry
[17:03:48.363] result() for ClusterFuture ...
[17:03:48.363] - result already collected: FutureResult
[17:03:48.363] result() for ClusterFuture ... done
[17:03:48.363] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:48.363] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:03:48.363] getGlobalsAndPackages() ...
[17:03:48.363] Searching for globals...
[17:03:48.364] - globals found: [2] ‘list’, ‘stop’
[17:03:48.364] Searching for globals ... DONE
[17:03:48.364] Resolving globals: FALSE
[17:03:48.364] 
[17:03:48.365] 
[17:03:48.365] getGlobalsAndPackages() ... DONE
[17:03:48.365] run() for ‘Future’ ...
[17:03:48.365] - state: ‘created’
[17:03:48.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:48.381] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:48.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:48.381]   - Field: ‘node’
[17:03:48.381]   - Field: ‘label’
[17:03:48.381]   - Field: ‘local’
[17:03:48.381]   - Field: ‘owner’
[17:03:48.381]   - Field: ‘envir’
[17:03:48.381]   - Field: ‘workers’
[17:03:48.381]   - Field: ‘packages’
[17:03:48.382]   - Field: ‘gc’
[17:03:48.382]   - Field: ‘conditions’
[17:03:48.382]   - Field: ‘persistent’
[17:03:48.382]   - Field: ‘expr’
[17:03:48.382]   - Field: ‘uuid’
[17:03:48.382]   - Field: ‘seed’
[17:03:48.382]   - Field: ‘version’
[17:03:48.382]   - Field: ‘result’
[17:03:48.382]   - Field: ‘asynchronous’
[17:03:48.382]   - Field: ‘calls’
[17:03:48.382]   - Field: ‘globals’
[17:03:48.383]   - Field: ‘stdout’
[17:03:48.383]   - Field: ‘earlySignal’
[17:03:48.383]   - Field: ‘lazy’
[17:03:48.383]   - Field: ‘state’
[17:03:48.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:48.383] - Launch lazy future ...
[17:03:48.383] Packages needed by the future expression (n = 0): <none>
[17:03:48.383] Packages needed by future strategies (n = 0): <none>
[17:03:48.384] {
[17:03:48.384]     {
[17:03:48.384]         {
[17:03:48.384]             ...future.startTime <- base::Sys.time()
[17:03:48.384]             {
[17:03:48.384]                 {
[17:03:48.384]                   {
[17:03:48.384]                     {
[17:03:48.384]                       base::local({
[17:03:48.384]                         has_future <- base::requireNamespace("future", 
[17:03:48.384]                           quietly = TRUE)
[17:03:48.384]                         if (has_future) {
[17:03:48.384]                           ns <- base::getNamespace("future")
[17:03:48.384]                           version <- ns[[".package"]][["version"]]
[17:03:48.384]                           if (is.null(version)) 
[17:03:48.384]                             version <- utils::packageVersion("future")
[17:03:48.384]                         }
[17:03:48.384]                         else {
[17:03:48.384]                           version <- NULL
[17:03:48.384]                         }
[17:03:48.384]                         if (!has_future || version < "1.8.0") {
[17:03:48.384]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:48.384]                             "", base::R.version$version.string), 
[17:03:48.384]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:48.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:48.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:48.384]                               "release", "version")], collapse = " "), 
[17:03:48.384]                             hostname = base::Sys.info()[["nodename"]])
[17:03:48.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:48.384]                             info)
[17:03:48.384]                           info <- base::paste(info, collapse = "; ")
[17:03:48.384]                           if (!has_future) {
[17:03:48.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:48.384]                               info)
[17:03:48.384]                           }
[17:03:48.384]                           else {
[17:03:48.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:48.384]                               info, version)
[17:03:48.384]                           }
[17:03:48.384]                           base::stop(msg)
[17:03:48.384]                         }
[17:03:48.384]                       })
[17:03:48.384]                     }
[17:03:48.384]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:48.384]                     base::options(mc.cores = 1L)
[17:03:48.384]                   }
[17:03:48.384]                   ...future.strategy.old <- future::plan("list")
[17:03:48.384]                   options(future.plan = NULL)
[17:03:48.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:48.384]                 }
[17:03:48.384]                 ...future.workdir <- getwd()
[17:03:48.384]             }
[17:03:48.384]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:48.384]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:48.384]         }
[17:03:48.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:48.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:48.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:48.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:48.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:48.384]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:48.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:48.384]             base::names(...future.oldOptions))
[17:03:48.384]     }
[17:03:48.384]     if (FALSE) {
[17:03:48.384]     }
[17:03:48.384]     else {
[17:03:48.384]         if (TRUE) {
[17:03:48.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:48.384]                 open = "w")
[17:03:48.384]         }
[17:03:48.384]         else {
[17:03:48.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:48.384]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:48.384]         }
[17:03:48.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:48.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:48.384]             base::sink(type = "output", split = FALSE)
[17:03:48.384]             base::close(...future.stdout)
[17:03:48.384]         }, add = TRUE)
[17:03:48.384]     }
[17:03:48.384]     ...future.frame <- base::sys.nframe()
[17:03:48.384]     ...future.conditions <- base::list()
[17:03:48.384]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:48.384]     if (FALSE) {
[17:03:48.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:48.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:48.384]     }
[17:03:48.384]     ...future.result <- base::tryCatch({
[17:03:48.384]         base::withCallingHandlers({
[17:03:48.384]             ...future.value <- base::withVisible(base::local({
[17:03:48.384]                 ...future.makeSendCondition <- base::local({
[17:03:48.384]                   sendCondition <- NULL
[17:03:48.384]                   function(frame = 1L) {
[17:03:48.384]                     if (is.function(sendCondition)) 
[17:03:48.384]                       return(sendCondition)
[17:03:48.384]                     ns <- getNamespace("parallel")
[17:03:48.384]                     if (exists("sendData", mode = "function", 
[17:03:48.384]                       envir = ns)) {
[17:03:48.384]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:48.384]                         envir = ns)
[17:03:48.384]                       envir <- sys.frame(frame)
[17:03:48.384]                       master <- NULL
[17:03:48.384]                       while (!identical(envir, .GlobalEnv) && 
[17:03:48.384]                         !identical(envir, emptyenv())) {
[17:03:48.384]                         if (exists("master", mode = "list", envir = envir, 
[17:03:48.384]                           inherits = FALSE)) {
[17:03:48.384]                           master <- get("master", mode = "list", 
[17:03:48.384]                             envir = envir, inherits = FALSE)
[17:03:48.384]                           if (inherits(master, c("SOCKnode", 
[17:03:48.384]                             "SOCK0node"))) {
[17:03:48.384]                             sendCondition <<- function(cond) {
[17:03:48.384]                               data <- list(type = "VALUE", value = cond, 
[17:03:48.384]                                 success = TRUE)
[17:03:48.384]                               parallel_sendData(master, data)
[17:03:48.384]                             }
[17:03:48.384]                             return(sendCondition)
[17:03:48.384]                           }
[17:03:48.384]                         }
[17:03:48.384]                         frame <- frame + 1L
[17:03:48.384]                         envir <- sys.frame(frame)
[17:03:48.384]                       }
[17:03:48.384]                     }
[17:03:48.384]                     sendCondition <<- function(cond) NULL
[17:03:48.384]                   }
[17:03:48.384]                 })
[17:03:48.384]                 withCallingHandlers({
[17:03:48.384]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:48.384]                 }, immediateCondition = function(cond) {
[17:03:48.384]                   sendCondition <- ...future.makeSendCondition()
[17:03:48.384]                   sendCondition(cond)
[17:03:48.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.384]                   {
[17:03:48.384]                     inherits <- base::inherits
[17:03:48.384]                     invokeRestart <- base::invokeRestart
[17:03:48.384]                     is.null <- base::is.null
[17:03:48.384]                     muffled <- FALSE
[17:03:48.384]                     if (inherits(cond, "message")) {
[17:03:48.384]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:48.384]                       if (muffled) 
[17:03:48.384]                         invokeRestart("muffleMessage")
[17:03:48.384]                     }
[17:03:48.384]                     else if (inherits(cond, "warning")) {
[17:03:48.384]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:48.384]                       if (muffled) 
[17:03:48.384]                         invokeRestart("muffleWarning")
[17:03:48.384]                     }
[17:03:48.384]                     else if (inherits(cond, "condition")) {
[17:03:48.384]                       if (!is.null(pattern)) {
[17:03:48.384]                         computeRestarts <- base::computeRestarts
[17:03:48.384]                         grepl <- base::grepl
[17:03:48.384]                         restarts <- computeRestarts(cond)
[17:03:48.384]                         for (restart in restarts) {
[17:03:48.384]                           name <- restart$name
[17:03:48.384]                           if (is.null(name)) 
[17:03:48.384]                             next
[17:03:48.384]                           if (!grepl(pattern, name)) 
[17:03:48.384]                             next
[17:03:48.384]                           invokeRestart(restart)
[17:03:48.384]                           muffled <- TRUE
[17:03:48.384]                           break
[17:03:48.384]                         }
[17:03:48.384]                       }
[17:03:48.384]                     }
[17:03:48.384]                     invisible(muffled)
[17:03:48.384]                   }
[17:03:48.384]                   muffleCondition(cond)
[17:03:48.384]                 })
[17:03:48.384]             }))
[17:03:48.384]             future::FutureResult(value = ...future.value$value, 
[17:03:48.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.384]                   ...future.rng), globalenv = if (FALSE) 
[17:03:48.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:48.384]                     ...future.globalenv.names))
[17:03:48.384]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:48.384]         }, condition = base::local({
[17:03:48.384]             c <- base::c
[17:03:48.384]             inherits <- base::inherits
[17:03:48.384]             invokeRestart <- base::invokeRestart
[17:03:48.384]             length <- base::length
[17:03:48.384]             list <- base::list
[17:03:48.384]             seq.int <- base::seq.int
[17:03:48.384]             signalCondition <- base::signalCondition
[17:03:48.384]             sys.calls <- base::sys.calls
[17:03:48.384]             `[[` <- base::`[[`
[17:03:48.384]             `+` <- base::`+`
[17:03:48.384]             `<<-` <- base::`<<-`
[17:03:48.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:48.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:48.384]                   3L)]
[17:03:48.384]             }
[17:03:48.384]             function(cond) {
[17:03:48.384]                 is_error <- inherits(cond, "error")
[17:03:48.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:48.384]                   NULL)
[17:03:48.384]                 if (is_error) {
[17:03:48.384]                   sessionInformation <- function() {
[17:03:48.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:48.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:48.384]                       search = base::search(), system = base::Sys.info())
[17:03:48.384]                   }
[17:03:48.384]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:48.384]                     cond$call), session = sessionInformation(), 
[17:03:48.384]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:48.384]                   signalCondition(cond)
[17:03:48.384]                 }
[17:03:48.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:48.384]                 "immediateCondition"))) {
[17:03:48.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:48.384]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:48.384]                   if (TRUE && !signal) {
[17:03:48.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.384]                     {
[17:03:48.384]                       inherits <- base::inherits
[17:03:48.384]                       invokeRestart <- base::invokeRestart
[17:03:48.384]                       is.null <- base::is.null
[17:03:48.384]                       muffled <- FALSE
[17:03:48.384]                       if (inherits(cond, "message")) {
[17:03:48.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.384]                         if (muffled) 
[17:03:48.384]                           invokeRestart("muffleMessage")
[17:03:48.384]                       }
[17:03:48.384]                       else if (inherits(cond, "warning")) {
[17:03:48.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.384]                         if (muffled) 
[17:03:48.384]                           invokeRestart("muffleWarning")
[17:03:48.384]                       }
[17:03:48.384]                       else if (inherits(cond, "condition")) {
[17:03:48.384]                         if (!is.null(pattern)) {
[17:03:48.384]                           computeRestarts <- base::computeRestarts
[17:03:48.384]                           grepl <- base::grepl
[17:03:48.384]                           restarts <- computeRestarts(cond)
[17:03:48.384]                           for (restart in restarts) {
[17:03:48.384]                             name <- restart$name
[17:03:48.384]                             if (is.null(name)) 
[17:03:48.384]                               next
[17:03:48.384]                             if (!grepl(pattern, name)) 
[17:03:48.384]                               next
[17:03:48.384]                             invokeRestart(restart)
[17:03:48.384]                             muffled <- TRUE
[17:03:48.384]                             break
[17:03:48.384]                           }
[17:03:48.384]                         }
[17:03:48.384]                       }
[17:03:48.384]                       invisible(muffled)
[17:03:48.384]                     }
[17:03:48.384]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.384]                   }
[17:03:48.384]                 }
[17:03:48.384]                 else {
[17:03:48.384]                   if (TRUE) {
[17:03:48.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.384]                     {
[17:03:48.384]                       inherits <- base::inherits
[17:03:48.384]                       invokeRestart <- base::invokeRestart
[17:03:48.384]                       is.null <- base::is.null
[17:03:48.384]                       muffled <- FALSE
[17:03:48.384]                       if (inherits(cond, "message")) {
[17:03:48.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.384]                         if (muffled) 
[17:03:48.384]                           invokeRestart("muffleMessage")
[17:03:48.384]                       }
[17:03:48.384]                       else if (inherits(cond, "warning")) {
[17:03:48.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.384]                         if (muffled) 
[17:03:48.384]                           invokeRestart("muffleWarning")
[17:03:48.384]                       }
[17:03:48.384]                       else if (inherits(cond, "condition")) {
[17:03:48.384]                         if (!is.null(pattern)) {
[17:03:48.384]                           computeRestarts <- base::computeRestarts
[17:03:48.384]                           grepl <- base::grepl
[17:03:48.384]                           restarts <- computeRestarts(cond)
[17:03:48.384]                           for (restart in restarts) {
[17:03:48.384]                             name <- restart$name
[17:03:48.384]                             if (is.null(name)) 
[17:03:48.384]                               next
[17:03:48.384]                             if (!grepl(pattern, name)) 
[17:03:48.384]                               next
[17:03:48.384]                             invokeRestart(restart)
[17:03:48.384]                             muffled <- TRUE
[17:03:48.384]                             break
[17:03:48.384]                           }
[17:03:48.384]                         }
[17:03:48.384]                       }
[17:03:48.384]                       invisible(muffled)
[17:03:48.384]                     }
[17:03:48.384]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.384]                   }
[17:03:48.384]                 }
[17:03:48.384]             }
[17:03:48.384]         }))
[17:03:48.384]     }, error = function(ex) {
[17:03:48.384]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:48.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.384]                 ...future.rng), started = ...future.startTime, 
[17:03:48.384]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:48.384]             version = "1.8"), class = "FutureResult")
[17:03:48.384]     }, finally = {
[17:03:48.384]         if (!identical(...future.workdir, getwd())) 
[17:03:48.384]             setwd(...future.workdir)
[17:03:48.384]         {
[17:03:48.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:48.384]                 ...future.oldOptions$nwarnings <- NULL
[17:03:48.384]             }
[17:03:48.384]             base::options(...future.oldOptions)
[17:03:48.384]             if (.Platform$OS.type == "windows") {
[17:03:48.384]                 old_names <- names(...future.oldEnvVars)
[17:03:48.384]                 envs <- base::Sys.getenv()
[17:03:48.384]                 names <- names(envs)
[17:03:48.384]                 common <- intersect(names, old_names)
[17:03:48.384]                 added <- setdiff(names, old_names)
[17:03:48.384]                 removed <- setdiff(old_names, names)
[17:03:48.384]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:48.384]                   envs[common]]
[17:03:48.384]                 NAMES <- toupper(changed)
[17:03:48.384]                 args <- list()
[17:03:48.384]                 for (kk in seq_along(NAMES)) {
[17:03:48.384]                   name <- changed[[kk]]
[17:03:48.384]                   NAME <- NAMES[[kk]]
[17:03:48.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.384]                     next
[17:03:48.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.384]                 }
[17:03:48.384]                 NAMES <- toupper(added)
[17:03:48.384]                 for (kk in seq_along(NAMES)) {
[17:03:48.384]                   name <- added[[kk]]
[17:03:48.384]                   NAME <- NAMES[[kk]]
[17:03:48.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.384]                     next
[17:03:48.384]                   args[[name]] <- ""
[17:03:48.384]                 }
[17:03:48.384]                 NAMES <- toupper(removed)
[17:03:48.384]                 for (kk in seq_along(NAMES)) {
[17:03:48.384]                   name <- removed[[kk]]
[17:03:48.384]                   NAME <- NAMES[[kk]]
[17:03:48.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.384]                     next
[17:03:48.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.384]                 }
[17:03:48.384]                 if (length(args) > 0) 
[17:03:48.384]                   base::do.call(base::Sys.setenv, args = args)
[17:03:48.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:48.384]             }
[17:03:48.384]             else {
[17:03:48.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:48.384]             }
[17:03:48.384]             {
[17:03:48.384]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:48.384]                   0L) {
[17:03:48.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:48.384]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:48.384]                   base::options(opts)
[17:03:48.384]                 }
[17:03:48.384]                 {
[17:03:48.384]                   {
[17:03:48.384]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:48.384]                     NULL
[17:03:48.384]                   }
[17:03:48.384]                   options(future.plan = NULL)
[17:03:48.384]                   if (is.na(NA_character_)) 
[17:03:48.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:48.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:48.384]                     .init = FALSE)
[17:03:48.384]                 }
[17:03:48.384]             }
[17:03:48.384]         }
[17:03:48.384]     })
[17:03:48.384]     if (TRUE) {
[17:03:48.384]         base::sink(type = "output", split = FALSE)
[17:03:48.384]         if (TRUE) {
[17:03:48.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:48.384]         }
[17:03:48.384]         else {
[17:03:48.384]             ...future.result["stdout"] <- base::list(NULL)
[17:03:48.384]         }
[17:03:48.384]         base::close(...future.stdout)
[17:03:48.384]         ...future.stdout <- NULL
[17:03:48.384]     }
[17:03:48.384]     ...future.result$conditions <- ...future.conditions
[17:03:48.384]     ...future.result$finished <- base::Sys.time()
[17:03:48.384]     ...future.result
[17:03:48.384] }
[17:03:48.387] MultisessionFuture started
[17:03:48.387] - Launch lazy future ... done
[17:03:48.387] run() for ‘MultisessionFuture’ ... done
[17:03:48.389] receiveMessageFromWorker() for ClusterFuture ...
[17:03:48.389] - Validating connection of MultisessionFuture
[17:03:48.390] - received message: FutureResult
[17:03:48.390] - Received FutureResult
[17:03:48.390] - Erased future from FutureRegistry
[17:03:48.390] result() for ClusterFuture ...
[17:03:48.391] - result already collected: FutureResult
[17:03:48.391] result() for ClusterFuture ... done
[17:03:48.391] signalConditions() ...
[17:03:48.391]  - include = ‘immediateCondition’
[17:03:48.391]  - exclude = 
[17:03:48.391]  - resignal = FALSE
[17:03:48.391]  - Number of conditions: 1
[17:03:48.391] signalConditions() ... done
[17:03:48.392] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:48.392] A MultisessionFuture was resolved (result was not collected)
[17:03:48.392] getGlobalsAndPackages() ...
[17:03:48.392] Searching for globals...
[17:03:48.393] - globals found: [2] ‘list’, ‘stop’
[17:03:48.393] Searching for globals ... DONE
[17:03:48.393] Resolving globals: FALSE
[17:03:48.394] 
[17:03:48.394] 
[17:03:48.394] getGlobalsAndPackages() ... DONE
[17:03:48.394] run() for ‘Future’ ...
[17:03:48.394] - state: ‘created’
[17:03:48.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:48.408] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:48.409] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:48.409]   - Field: ‘node’
[17:03:48.409]   - Field: ‘label’
[17:03:48.409]   - Field: ‘local’
[17:03:48.409]   - Field: ‘owner’
[17:03:48.409]   - Field: ‘envir’
[17:03:48.409]   - Field: ‘workers’
[17:03:48.409]   - Field: ‘packages’
[17:03:48.409]   - Field: ‘gc’
[17:03:48.409]   - Field: ‘conditions’
[17:03:48.410]   - Field: ‘persistent’
[17:03:48.410]   - Field: ‘expr’
[17:03:48.410]   - Field: ‘uuid’
[17:03:48.410]   - Field: ‘seed’
[17:03:48.410]   - Field: ‘version’
[17:03:48.410]   - Field: ‘result’
[17:03:48.410]   - Field: ‘asynchronous’
[17:03:48.410]   - Field: ‘calls’
[17:03:48.410]   - Field: ‘globals’
[17:03:48.410]   - Field: ‘stdout’
[17:03:48.410]   - Field: ‘earlySignal’
[17:03:48.411]   - Field: ‘lazy’
[17:03:48.411]   - Field: ‘state’
[17:03:48.411] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:48.411] - Launch lazy future ...
[17:03:48.411] Packages needed by the future expression (n = 0): <none>
[17:03:48.411] Packages needed by future strategies (n = 0): <none>
[17:03:48.412] {
[17:03:48.412]     {
[17:03:48.412]         {
[17:03:48.412]             ...future.startTime <- base::Sys.time()
[17:03:48.412]             {
[17:03:48.412]                 {
[17:03:48.412]                   {
[17:03:48.412]                     {
[17:03:48.412]                       base::local({
[17:03:48.412]                         has_future <- base::requireNamespace("future", 
[17:03:48.412]                           quietly = TRUE)
[17:03:48.412]                         if (has_future) {
[17:03:48.412]                           ns <- base::getNamespace("future")
[17:03:48.412]                           version <- ns[[".package"]][["version"]]
[17:03:48.412]                           if (is.null(version)) 
[17:03:48.412]                             version <- utils::packageVersion("future")
[17:03:48.412]                         }
[17:03:48.412]                         else {
[17:03:48.412]                           version <- NULL
[17:03:48.412]                         }
[17:03:48.412]                         if (!has_future || version < "1.8.0") {
[17:03:48.412]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:48.412]                             "", base::R.version$version.string), 
[17:03:48.412]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:48.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:48.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:48.412]                               "release", "version")], collapse = " "), 
[17:03:48.412]                             hostname = base::Sys.info()[["nodename"]])
[17:03:48.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:48.412]                             info)
[17:03:48.412]                           info <- base::paste(info, collapse = "; ")
[17:03:48.412]                           if (!has_future) {
[17:03:48.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:48.412]                               info)
[17:03:48.412]                           }
[17:03:48.412]                           else {
[17:03:48.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:48.412]                               info, version)
[17:03:48.412]                           }
[17:03:48.412]                           base::stop(msg)
[17:03:48.412]                         }
[17:03:48.412]                       })
[17:03:48.412]                     }
[17:03:48.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:48.412]                     base::options(mc.cores = 1L)
[17:03:48.412]                   }
[17:03:48.412]                   ...future.strategy.old <- future::plan("list")
[17:03:48.412]                   options(future.plan = NULL)
[17:03:48.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:48.412]                 }
[17:03:48.412]                 ...future.workdir <- getwd()
[17:03:48.412]             }
[17:03:48.412]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:48.412]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:48.412]         }
[17:03:48.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:48.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:48.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:48.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:48.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:48.412]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:48.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:48.412]             base::names(...future.oldOptions))
[17:03:48.412]     }
[17:03:48.412]     if (FALSE) {
[17:03:48.412]     }
[17:03:48.412]     else {
[17:03:48.412]         if (TRUE) {
[17:03:48.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:48.412]                 open = "w")
[17:03:48.412]         }
[17:03:48.412]         else {
[17:03:48.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:48.412]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:48.412]         }
[17:03:48.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:48.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:48.412]             base::sink(type = "output", split = FALSE)
[17:03:48.412]             base::close(...future.stdout)
[17:03:48.412]         }, add = TRUE)
[17:03:48.412]     }
[17:03:48.412]     ...future.frame <- base::sys.nframe()
[17:03:48.412]     ...future.conditions <- base::list()
[17:03:48.412]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:48.412]     if (FALSE) {
[17:03:48.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:48.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:48.412]     }
[17:03:48.412]     ...future.result <- base::tryCatch({
[17:03:48.412]         base::withCallingHandlers({
[17:03:48.412]             ...future.value <- base::withVisible(base::local({
[17:03:48.412]                 ...future.makeSendCondition <- base::local({
[17:03:48.412]                   sendCondition <- NULL
[17:03:48.412]                   function(frame = 1L) {
[17:03:48.412]                     if (is.function(sendCondition)) 
[17:03:48.412]                       return(sendCondition)
[17:03:48.412]                     ns <- getNamespace("parallel")
[17:03:48.412]                     if (exists("sendData", mode = "function", 
[17:03:48.412]                       envir = ns)) {
[17:03:48.412]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:48.412]                         envir = ns)
[17:03:48.412]                       envir <- sys.frame(frame)
[17:03:48.412]                       master <- NULL
[17:03:48.412]                       while (!identical(envir, .GlobalEnv) && 
[17:03:48.412]                         !identical(envir, emptyenv())) {
[17:03:48.412]                         if (exists("master", mode = "list", envir = envir, 
[17:03:48.412]                           inherits = FALSE)) {
[17:03:48.412]                           master <- get("master", mode = "list", 
[17:03:48.412]                             envir = envir, inherits = FALSE)
[17:03:48.412]                           if (inherits(master, c("SOCKnode", 
[17:03:48.412]                             "SOCK0node"))) {
[17:03:48.412]                             sendCondition <<- function(cond) {
[17:03:48.412]                               data <- list(type = "VALUE", value = cond, 
[17:03:48.412]                                 success = TRUE)
[17:03:48.412]                               parallel_sendData(master, data)
[17:03:48.412]                             }
[17:03:48.412]                             return(sendCondition)
[17:03:48.412]                           }
[17:03:48.412]                         }
[17:03:48.412]                         frame <- frame + 1L
[17:03:48.412]                         envir <- sys.frame(frame)
[17:03:48.412]                       }
[17:03:48.412]                     }
[17:03:48.412]                     sendCondition <<- function(cond) NULL
[17:03:48.412]                   }
[17:03:48.412]                 })
[17:03:48.412]                 withCallingHandlers({
[17:03:48.412]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:48.412]                 }, immediateCondition = function(cond) {
[17:03:48.412]                   sendCondition <- ...future.makeSendCondition()
[17:03:48.412]                   sendCondition(cond)
[17:03:48.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.412]                   {
[17:03:48.412]                     inherits <- base::inherits
[17:03:48.412]                     invokeRestart <- base::invokeRestart
[17:03:48.412]                     is.null <- base::is.null
[17:03:48.412]                     muffled <- FALSE
[17:03:48.412]                     if (inherits(cond, "message")) {
[17:03:48.412]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:48.412]                       if (muffled) 
[17:03:48.412]                         invokeRestart("muffleMessage")
[17:03:48.412]                     }
[17:03:48.412]                     else if (inherits(cond, "warning")) {
[17:03:48.412]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:48.412]                       if (muffled) 
[17:03:48.412]                         invokeRestart("muffleWarning")
[17:03:48.412]                     }
[17:03:48.412]                     else if (inherits(cond, "condition")) {
[17:03:48.412]                       if (!is.null(pattern)) {
[17:03:48.412]                         computeRestarts <- base::computeRestarts
[17:03:48.412]                         grepl <- base::grepl
[17:03:48.412]                         restarts <- computeRestarts(cond)
[17:03:48.412]                         for (restart in restarts) {
[17:03:48.412]                           name <- restart$name
[17:03:48.412]                           if (is.null(name)) 
[17:03:48.412]                             next
[17:03:48.412]                           if (!grepl(pattern, name)) 
[17:03:48.412]                             next
[17:03:48.412]                           invokeRestart(restart)
[17:03:48.412]                           muffled <- TRUE
[17:03:48.412]                           break
[17:03:48.412]                         }
[17:03:48.412]                       }
[17:03:48.412]                     }
[17:03:48.412]                     invisible(muffled)
[17:03:48.412]                   }
[17:03:48.412]                   muffleCondition(cond)
[17:03:48.412]                 })
[17:03:48.412]             }))
[17:03:48.412]             future::FutureResult(value = ...future.value$value, 
[17:03:48.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.412]                   ...future.rng), globalenv = if (FALSE) 
[17:03:48.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:48.412]                     ...future.globalenv.names))
[17:03:48.412]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:48.412]         }, condition = base::local({
[17:03:48.412]             c <- base::c
[17:03:48.412]             inherits <- base::inherits
[17:03:48.412]             invokeRestart <- base::invokeRestart
[17:03:48.412]             length <- base::length
[17:03:48.412]             list <- base::list
[17:03:48.412]             seq.int <- base::seq.int
[17:03:48.412]             signalCondition <- base::signalCondition
[17:03:48.412]             sys.calls <- base::sys.calls
[17:03:48.412]             `[[` <- base::`[[`
[17:03:48.412]             `+` <- base::`+`
[17:03:48.412]             `<<-` <- base::`<<-`
[17:03:48.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:48.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:48.412]                   3L)]
[17:03:48.412]             }
[17:03:48.412]             function(cond) {
[17:03:48.412]                 is_error <- inherits(cond, "error")
[17:03:48.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:48.412]                   NULL)
[17:03:48.412]                 if (is_error) {
[17:03:48.412]                   sessionInformation <- function() {
[17:03:48.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:48.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:48.412]                       search = base::search(), system = base::Sys.info())
[17:03:48.412]                   }
[17:03:48.412]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:48.412]                     cond$call), session = sessionInformation(), 
[17:03:48.412]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:48.412]                   signalCondition(cond)
[17:03:48.412]                 }
[17:03:48.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:48.412]                 "immediateCondition"))) {
[17:03:48.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:48.412]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:48.412]                   if (TRUE && !signal) {
[17:03:48.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.412]                     {
[17:03:48.412]                       inherits <- base::inherits
[17:03:48.412]                       invokeRestart <- base::invokeRestart
[17:03:48.412]                       is.null <- base::is.null
[17:03:48.412]                       muffled <- FALSE
[17:03:48.412]                       if (inherits(cond, "message")) {
[17:03:48.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.412]                         if (muffled) 
[17:03:48.412]                           invokeRestart("muffleMessage")
[17:03:48.412]                       }
[17:03:48.412]                       else if (inherits(cond, "warning")) {
[17:03:48.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.412]                         if (muffled) 
[17:03:48.412]                           invokeRestart("muffleWarning")
[17:03:48.412]                       }
[17:03:48.412]                       else if (inherits(cond, "condition")) {
[17:03:48.412]                         if (!is.null(pattern)) {
[17:03:48.412]                           computeRestarts <- base::computeRestarts
[17:03:48.412]                           grepl <- base::grepl
[17:03:48.412]                           restarts <- computeRestarts(cond)
[17:03:48.412]                           for (restart in restarts) {
[17:03:48.412]                             name <- restart$name
[17:03:48.412]                             if (is.null(name)) 
[17:03:48.412]                               next
[17:03:48.412]                             if (!grepl(pattern, name)) 
[17:03:48.412]                               next
[17:03:48.412]                             invokeRestart(restart)
[17:03:48.412]                             muffled <- TRUE
[17:03:48.412]                             break
[17:03:48.412]                           }
[17:03:48.412]                         }
[17:03:48.412]                       }
[17:03:48.412]                       invisible(muffled)
[17:03:48.412]                     }
[17:03:48.412]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.412]                   }
[17:03:48.412]                 }
[17:03:48.412]                 else {
[17:03:48.412]                   if (TRUE) {
[17:03:48.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.412]                     {
[17:03:48.412]                       inherits <- base::inherits
[17:03:48.412]                       invokeRestart <- base::invokeRestart
[17:03:48.412]                       is.null <- base::is.null
[17:03:48.412]                       muffled <- FALSE
[17:03:48.412]                       if (inherits(cond, "message")) {
[17:03:48.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.412]                         if (muffled) 
[17:03:48.412]                           invokeRestart("muffleMessage")
[17:03:48.412]                       }
[17:03:48.412]                       else if (inherits(cond, "warning")) {
[17:03:48.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.412]                         if (muffled) 
[17:03:48.412]                           invokeRestart("muffleWarning")
[17:03:48.412]                       }
[17:03:48.412]                       else if (inherits(cond, "condition")) {
[17:03:48.412]                         if (!is.null(pattern)) {
[17:03:48.412]                           computeRestarts <- base::computeRestarts
[17:03:48.412]                           grepl <- base::grepl
[17:03:48.412]                           restarts <- computeRestarts(cond)
[17:03:48.412]                           for (restart in restarts) {
[17:03:48.412]                             name <- restart$name
[17:03:48.412]                             if (is.null(name)) 
[17:03:48.412]                               next
[17:03:48.412]                             if (!grepl(pattern, name)) 
[17:03:48.412]                               next
[17:03:48.412]                             invokeRestart(restart)
[17:03:48.412]                             muffled <- TRUE
[17:03:48.412]                             break
[17:03:48.412]                           }
[17:03:48.412]                         }
[17:03:48.412]                       }
[17:03:48.412]                       invisible(muffled)
[17:03:48.412]                     }
[17:03:48.412]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.412]                   }
[17:03:48.412]                 }
[17:03:48.412]             }
[17:03:48.412]         }))
[17:03:48.412]     }, error = function(ex) {
[17:03:48.412]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:48.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.412]                 ...future.rng), started = ...future.startTime, 
[17:03:48.412]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:48.412]             version = "1.8"), class = "FutureResult")
[17:03:48.412]     }, finally = {
[17:03:48.412]         if (!identical(...future.workdir, getwd())) 
[17:03:48.412]             setwd(...future.workdir)
[17:03:48.412]         {
[17:03:48.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:48.412]                 ...future.oldOptions$nwarnings <- NULL
[17:03:48.412]             }
[17:03:48.412]             base::options(...future.oldOptions)
[17:03:48.412]             if (.Platform$OS.type == "windows") {
[17:03:48.412]                 old_names <- names(...future.oldEnvVars)
[17:03:48.412]                 envs <- base::Sys.getenv()
[17:03:48.412]                 names <- names(envs)
[17:03:48.412]                 common <- intersect(names, old_names)
[17:03:48.412]                 added <- setdiff(names, old_names)
[17:03:48.412]                 removed <- setdiff(old_names, names)
[17:03:48.412]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:48.412]                   envs[common]]
[17:03:48.412]                 NAMES <- toupper(changed)
[17:03:48.412]                 args <- list()
[17:03:48.412]                 for (kk in seq_along(NAMES)) {
[17:03:48.412]                   name <- changed[[kk]]
[17:03:48.412]                   NAME <- NAMES[[kk]]
[17:03:48.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.412]                     next
[17:03:48.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.412]                 }
[17:03:48.412]                 NAMES <- toupper(added)
[17:03:48.412]                 for (kk in seq_along(NAMES)) {
[17:03:48.412]                   name <- added[[kk]]
[17:03:48.412]                   NAME <- NAMES[[kk]]
[17:03:48.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.412]                     next
[17:03:48.412]                   args[[name]] <- ""
[17:03:48.412]                 }
[17:03:48.412]                 NAMES <- toupper(removed)
[17:03:48.412]                 for (kk in seq_along(NAMES)) {
[17:03:48.412]                   name <- removed[[kk]]
[17:03:48.412]                   NAME <- NAMES[[kk]]
[17:03:48.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.412]                     next
[17:03:48.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.412]                 }
[17:03:48.412]                 if (length(args) > 0) 
[17:03:48.412]                   base::do.call(base::Sys.setenv, args = args)
[17:03:48.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:48.412]             }
[17:03:48.412]             else {
[17:03:48.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:48.412]             }
[17:03:48.412]             {
[17:03:48.412]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:48.412]                   0L) {
[17:03:48.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:48.412]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:48.412]                   base::options(opts)
[17:03:48.412]                 }
[17:03:48.412]                 {
[17:03:48.412]                   {
[17:03:48.412]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:48.412]                     NULL
[17:03:48.412]                   }
[17:03:48.412]                   options(future.plan = NULL)
[17:03:48.412]                   if (is.na(NA_character_)) 
[17:03:48.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:48.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:48.412]                     .init = FALSE)
[17:03:48.412]                 }
[17:03:48.412]             }
[17:03:48.412]         }
[17:03:48.412]     })
[17:03:48.412]     if (TRUE) {
[17:03:48.412]         base::sink(type = "output", split = FALSE)
[17:03:48.412]         if (TRUE) {
[17:03:48.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:48.412]         }
[17:03:48.412]         else {
[17:03:48.412]             ...future.result["stdout"] <- base::list(NULL)
[17:03:48.412]         }
[17:03:48.412]         base::close(...future.stdout)
[17:03:48.412]         ...future.stdout <- NULL
[17:03:48.412]     }
[17:03:48.412]     ...future.result$conditions <- ...future.conditions
[17:03:48.412]     ...future.result$finished <- base::Sys.time()
[17:03:48.412]     ...future.result
[17:03:48.412] }
[17:03:48.415] MultisessionFuture started
[17:03:48.415] - Launch lazy future ... done
[17:03:48.415] run() for ‘MultisessionFuture’ ... done
[17:03:48.416] receiveMessageFromWorker() for ClusterFuture ...
[17:03:48.417] - Validating connection of MultisessionFuture
[17:03:48.417] - received message: FutureResult
[17:03:48.417] - Received FutureResult
[17:03:48.417] - Erased future from FutureRegistry
[17:03:48.417] result() for ClusterFuture ...
[17:03:48.417] - result already collected: FutureResult
[17:03:48.417] result() for ClusterFuture ... done
[17:03:48.418] signalConditions() ...
[17:03:48.418]  - include = ‘immediateCondition’
[17:03:48.418]  - exclude = 
[17:03:48.418]  - resignal = FALSE
[17:03:48.418]  - Number of conditions: 1
[17:03:48.418] signalConditions() ... done
[17:03:48.418] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:48.418] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[17:03:48.418] getGlobalsAndPackages() ...
[17:03:48.418] Searching for globals...
[17:03:48.420] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:48.420] Searching for globals ... DONE
[17:03:48.420] Resolving globals: FALSE
[17:03:48.420] 
[17:03:48.420] 
[17:03:48.420] getGlobalsAndPackages() ... DONE
[17:03:48.421] run() for ‘Future’ ...
[17:03:48.421] - state: ‘created’
[17:03:48.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:48.434] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:48.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:48.435]   - Field: ‘node’
[17:03:48.435]   - Field: ‘label’
[17:03:48.435]   - Field: ‘local’
[17:03:48.435]   - Field: ‘owner’
[17:03:48.435]   - Field: ‘envir’
[17:03:48.435]   - Field: ‘workers’
[17:03:48.435]   - Field: ‘packages’
[17:03:48.435]   - Field: ‘gc’
[17:03:48.436]   - Field: ‘conditions’
[17:03:48.436]   - Field: ‘persistent’
[17:03:48.436]   - Field: ‘expr’
[17:03:48.436]   - Field: ‘uuid’
[17:03:48.436]   - Field: ‘seed’
[17:03:48.436]   - Field: ‘version’
[17:03:48.436]   - Field: ‘result’
[17:03:48.436]   - Field: ‘asynchronous’
[17:03:48.436]   - Field: ‘calls’
[17:03:48.436]   - Field: ‘globals’
[17:03:48.436]   - Field: ‘stdout’
[17:03:48.437]   - Field: ‘earlySignal’
[17:03:48.437]   - Field: ‘lazy’
[17:03:48.437]   - Field: ‘state’
[17:03:48.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:48.437] - Launch lazy future ...
[17:03:48.437] Packages needed by the future expression (n = 0): <none>
[17:03:48.437] Packages needed by future strategies (n = 0): <none>
[17:03:48.438] {
[17:03:48.438]     {
[17:03:48.438]         {
[17:03:48.438]             ...future.startTime <- base::Sys.time()
[17:03:48.438]             {
[17:03:48.438]                 {
[17:03:48.438]                   {
[17:03:48.438]                     {
[17:03:48.438]                       base::local({
[17:03:48.438]                         has_future <- base::requireNamespace("future", 
[17:03:48.438]                           quietly = TRUE)
[17:03:48.438]                         if (has_future) {
[17:03:48.438]                           ns <- base::getNamespace("future")
[17:03:48.438]                           version <- ns[[".package"]][["version"]]
[17:03:48.438]                           if (is.null(version)) 
[17:03:48.438]                             version <- utils::packageVersion("future")
[17:03:48.438]                         }
[17:03:48.438]                         else {
[17:03:48.438]                           version <- NULL
[17:03:48.438]                         }
[17:03:48.438]                         if (!has_future || version < "1.8.0") {
[17:03:48.438]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:48.438]                             "", base::R.version$version.string), 
[17:03:48.438]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:48.438]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:48.438]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:48.438]                               "release", "version")], collapse = " "), 
[17:03:48.438]                             hostname = base::Sys.info()[["nodename"]])
[17:03:48.438]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:48.438]                             info)
[17:03:48.438]                           info <- base::paste(info, collapse = "; ")
[17:03:48.438]                           if (!has_future) {
[17:03:48.438]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:48.438]                               info)
[17:03:48.438]                           }
[17:03:48.438]                           else {
[17:03:48.438]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:48.438]                               info, version)
[17:03:48.438]                           }
[17:03:48.438]                           base::stop(msg)
[17:03:48.438]                         }
[17:03:48.438]                       })
[17:03:48.438]                     }
[17:03:48.438]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:48.438]                     base::options(mc.cores = 1L)
[17:03:48.438]                   }
[17:03:48.438]                   ...future.strategy.old <- future::plan("list")
[17:03:48.438]                   options(future.plan = NULL)
[17:03:48.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:48.438]                 }
[17:03:48.438]                 ...future.workdir <- getwd()
[17:03:48.438]             }
[17:03:48.438]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:48.438]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:48.438]         }
[17:03:48.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:48.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:48.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:48.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:48.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:48.438]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:48.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:48.438]             base::names(...future.oldOptions))
[17:03:48.438]     }
[17:03:48.438]     if (FALSE) {
[17:03:48.438]     }
[17:03:48.438]     else {
[17:03:48.438]         if (TRUE) {
[17:03:48.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:48.438]                 open = "w")
[17:03:48.438]         }
[17:03:48.438]         else {
[17:03:48.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:48.438]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:48.438]         }
[17:03:48.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:48.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:48.438]             base::sink(type = "output", split = FALSE)
[17:03:48.438]             base::close(...future.stdout)
[17:03:48.438]         }, add = TRUE)
[17:03:48.438]     }
[17:03:48.438]     ...future.frame <- base::sys.nframe()
[17:03:48.438]     ...future.conditions <- base::list()
[17:03:48.438]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:48.438]     if (FALSE) {
[17:03:48.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:48.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:48.438]     }
[17:03:48.438]     ...future.result <- base::tryCatch({
[17:03:48.438]         base::withCallingHandlers({
[17:03:48.438]             ...future.value <- base::withVisible(base::local({
[17:03:48.438]                 ...future.makeSendCondition <- base::local({
[17:03:48.438]                   sendCondition <- NULL
[17:03:48.438]                   function(frame = 1L) {
[17:03:48.438]                     if (is.function(sendCondition)) 
[17:03:48.438]                       return(sendCondition)
[17:03:48.438]                     ns <- getNamespace("parallel")
[17:03:48.438]                     if (exists("sendData", mode = "function", 
[17:03:48.438]                       envir = ns)) {
[17:03:48.438]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:48.438]                         envir = ns)
[17:03:48.438]                       envir <- sys.frame(frame)
[17:03:48.438]                       master <- NULL
[17:03:48.438]                       while (!identical(envir, .GlobalEnv) && 
[17:03:48.438]                         !identical(envir, emptyenv())) {
[17:03:48.438]                         if (exists("master", mode = "list", envir = envir, 
[17:03:48.438]                           inherits = FALSE)) {
[17:03:48.438]                           master <- get("master", mode = "list", 
[17:03:48.438]                             envir = envir, inherits = FALSE)
[17:03:48.438]                           if (inherits(master, c("SOCKnode", 
[17:03:48.438]                             "SOCK0node"))) {
[17:03:48.438]                             sendCondition <<- function(cond) {
[17:03:48.438]                               data <- list(type = "VALUE", value = cond, 
[17:03:48.438]                                 success = TRUE)
[17:03:48.438]                               parallel_sendData(master, data)
[17:03:48.438]                             }
[17:03:48.438]                             return(sendCondition)
[17:03:48.438]                           }
[17:03:48.438]                         }
[17:03:48.438]                         frame <- frame + 1L
[17:03:48.438]                         envir <- sys.frame(frame)
[17:03:48.438]                       }
[17:03:48.438]                     }
[17:03:48.438]                     sendCondition <<- function(cond) NULL
[17:03:48.438]                   }
[17:03:48.438]                 })
[17:03:48.438]                 withCallingHandlers({
[17:03:48.438]                   {
[17:03:48.438]                     Sys.sleep(0.5)
[17:03:48.438]                     list(a = 1, b = 42L)
[17:03:48.438]                   }
[17:03:48.438]                 }, immediateCondition = function(cond) {
[17:03:48.438]                   sendCondition <- ...future.makeSendCondition()
[17:03:48.438]                   sendCondition(cond)
[17:03:48.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.438]                   {
[17:03:48.438]                     inherits <- base::inherits
[17:03:48.438]                     invokeRestart <- base::invokeRestart
[17:03:48.438]                     is.null <- base::is.null
[17:03:48.438]                     muffled <- FALSE
[17:03:48.438]                     if (inherits(cond, "message")) {
[17:03:48.438]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:48.438]                       if (muffled) 
[17:03:48.438]                         invokeRestart("muffleMessage")
[17:03:48.438]                     }
[17:03:48.438]                     else if (inherits(cond, "warning")) {
[17:03:48.438]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:48.438]                       if (muffled) 
[17:03:48.438]                         invokeRestart("muffleWarning")
[17:03:48.438]                     }
[17:03:48.438]                     else if (inherits(cond, "condition")) {
[17:03:48.438]                       if (!is.null(pattern)) {
[17:03:48.438]                         computeRestarts <- base::computeRestarts
[17:03:48.438]                         grepl <- base::grepl
[17:03:48.438]                         restarts <- computeRestarts(cond)
[17:03:48.438]                         for (restart in restarts) {
[17:03:48.438]                           name <- restart$name
[17:03:48.438]                           if (is.null(name)) 
[17:03:48.438]                             next
[17:03:48.438]                           if (!grepl(pattern, name)) 
[17:03:48.438]                             next
[17:03:48.438]                           invokeRestart(restart)
[17:03:48.438]                           muffled <- TRUE
[17:03:48.438]                           break
[17:03:48.438]                         }
[17:03:48.438]                       }
[17:03:48.438]                     }
[17:03:48.438]                     invisible(muffled)
[17:03:48.438]                   }
[17:03:48.438]                   muffleCondition(cond)
[17:03:48.438]                 })
[17:03:48.438]             }))
[17:03:48.438]             future::FutureResult(value = ...future.value$value, 
[17:03:48.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.438]                   ...future.rng), globalenv = if (FALSE) 
[17:03:48.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:48.438]                     ...future.globalenv.names))
[17:03:48.438]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:48.438]         }, condition = base::local({
[17:03:48.438]             c <- base::c
[17:03:48.438]             inherits <- base::inherits
[17:03:48.438]             invokeRestart <- base::invokeRestart
[17:03:48.438]             length <- base::length
[17:03:48.438]             list <- base::list
[17:03:48.438]             seq.int <- base::seq.int
[17:03:48.438]             signalCondition <- base::signalCondition
[17:03:48.438]             sys.calls <- base::sys.calls
[17:03:48.438]             `[[` <- base::`[[`
[17:03:48.438]             `+` <- base::`+`
[17:03:48.438]             `<<-` <- base::`<<-`
[17:03:48.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:48.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:48.438]                   3L)]
[17:03:48.438]             }
[17:03:48.438]             function(cond) {
[17:03:48.438]                 is_error <- inherits(cond, "error")
[17:03:48.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:48.438]                   NULL)
[17:03:48.438]                 if (is_error) {
[17:03:48.438]                   sessionInformation <- function() {
[17:03:48.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:48.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:48.438]                       search = base::search(), system = base::Sys.info())
[17:03:48.438]                   }
[17:03:48.438]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:48.438]                     cond$call), session = sessionInformation(), 
[17:03:48.438]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:48.438]                   signalCondition(cond)
[17:03:48.438]                 }
[17:03:48.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:48.438]                 "immediateCondition"))) {
[17:03:48.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:48.438]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:48.438]                   if (TRUE && !signal) {
[17:03:48.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.438]                     {
[17:03:48.438]                       inherits <- base::inherits
[17:03:48.438]                       invokeRestart <- base::invokeRestart
[17:03:48.438]                       is.null <- base::is.null
[17:03:48.438]                       muffled <- FALSE
[17:03:48.438]                       if (inherits(cond, "message")) {
[17:03:48.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.438]                         if (muffled) 
[17:03:48.438]                           invokeRestart("muffleMessage")
[17:03:48.438]                       }
[17:03:48.438]                       else if (inherits(cond, "warning")) {
[17:03:48.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.438]                         if (muffled) 
[17:03:48.438]                           invokeRestart("muffleWarning")
[17:03:48.438]                       }
[17:03:48.438]                       else if (inherits(cond, "condition")) {
[17:03:48.438]                         if (!is.null(pattern)) {
[17:03:48.438]                           computeRestarts <- base::computeRestarts
[17:03:48.438]                           grepl <- base::grepl
[17:03:48.438]                           restarts <- computeRestarts(cond)
[17:03:48.438]                           for (restart in restarts) {
[17:03:48.438]                             name <- restart$name
[17:03:48.438]                             if (is.null(name)) 
[17:03:48.438]                               next
[17:03:48.438]                             if (!grepl(pattern, name)) 
[17:03:48.438]                               next
[17:03:48.438]                             invokeRestart(restart)
[17:03:48.438]                             muffled <- TRUE
[17:03:48.438]                             break
[17:03:48.438]                           }
[17:03:48.438]                         }
[17:03:48.438]                       }
[17:03:48.438]                       invisible(muffled)
[17:03:48.438]                     }
[17:03:48.438]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.438]                   }
[17:03:48.438]                 }
[17:03:48.438]                 else {
[17:03:48.438]                   if (TRUE) {
[17:03:48.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.438]                     {
[17:03:48.438]                       inherits <- base::inherits
[17:03:48.438]                       invokeRestart <- base::invokeRestart
[17:03:48.438]                       is.null <- base::is.null
[17:03:48.438]                       muffled <- FALSE
[17:03:48.438]                       if (inherits(cond, "message")) {
[17:03:48.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.438]                         if (muffled) 
[17:03:48.438]                           invokeRestart("muffleMessage")
[17:03:48.438]                       }
[17:03:48.438]                       else if (inherits(cond, "warning")) {
[17:03:48.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.438]                         if (muffled) 
[17:03:48.438]                           invokeRestart("muffleWarning")
[17:03:48.438]                       }
[17:03:48.438]                       else if (inherits(cond, "condition")) {
[17:03:48.438]                         if (!is.null(pattern)) {
[17:03:48.438]                           computeRestarts <- base::computeRestarts
[17:03:48.438]                           grepl <- base::grepl
[17:03:48.438]                           restarts <- computeRestarts(cond)
[17:03:48.438]                           for (restart in restarts) {
[17:03:48.438]                             name <- restart$name
[17:03:48.438]                             if (is.null(name)) 
[17:03:48.438]                               next
[17:03:48.438]                             if (!grepl(pattern, name)) 
[17:03:48.438]                               next
[17:03:48.438]                             invokeRestart(restart)
[17:03:48.438]                             muffled <- TRUE
[17:03:48.438]                             break
[17:03:48.438]                           }
[17:03:48.438]                         }
[17:03:48.438]                       }
[17:03:48.438]                       invisible(muffled)
[17:03:48.438]                     }
[17:03:48.438]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.438]                   }
[17:03:48.438]                 }
[17:03:48.438]             }
[17:03:48.438]         }))
[17:03:48.438]     }, error = function(ex) {
[17:03:48.438]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:48.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.438]                 ...future.rng), started = ...future.startTime, 
[17:03:48.438]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:48.438]             version = "1.8"), class = "FutureResult")
[17:03:48.438]     }, finally = {
[17:03:48.438]         if (!identical(...future.workdir, getwd())) 
[17:03:48.438]             setwd(...future.workdir)
[17:03:48.438]         {
[17:03:48.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:48.438]                 ...future.oldOptions$nwarnings <- NULL
[17:03:48.438]             }
[17:03:48.438]             base::options(...future.oldOptions)
[17:03:48.438]             if (.Platform$OS.type == "windows") {
[17:03:48.438]                 old_names <- names(...future.oldEnvVars)
[17:03:48.438]                 envs <- base::Sys.getenv()
[17:03:48.438]                 names <- names(envs)
[17:03:48.438]                 common <- intersect(names, old_names)
[17:03:48.438]                 added <- setdiff(names, old_names)
[17:03:48.438]                 removed <- setdiff(old_names, names)
[17:03:48.438]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:48.438]                   envs[common]]
[17:03:48.438]                 NAMES <- toupper(changed)
[17:03:48.438]                 args <- list()
[17:03:48.438]                 for (kk in seq_along(NAMES)) {
[17:03:48.438]                   name <- changed[[kk]]
[17:03:48.438]                   NAME <- NAMES[[kk]]
[17:03:48.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.438]                     next
[17:03:48.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.438]                 }
[17:03:48.438]                 NAMES <- toupper(added)
[17:03:48.438]                 for (kk in seq_along(NAMES)) {
[17:03:48.438]                   name <- added[[kk]]
[17:03:48.438]                   NAME <- NAMES[[kk]]
[17:03:48.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.438]                     next
[17:03:48.438]                   args[[name]] <- ""
[17:03:48.438]                 }
[17:03:48.438]                 NAMES <- toupper(removed)
[17:03:48.438]                 for (kk in seq_along(NAMES)) {
[17:03:48.438]                   name <- removed[[kk]]
[17:03:48.438]                   NAME <- NAMES[[kk]]
[17:03:48.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.438]                     next
[17:03:48.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.438]                 }
[17:03:48.438]                 if (length(args) > 0) 
[17:03:48.438]                   base::do.call(base::Sys.setenv, args = args)
[17:03:48.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:48.438]             }
[17:03:48.438]             else {
[17:03:48.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:48.438]             }
[17:03:48.438]             {
[17:03:48.438]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:48.438]                   0L) {
[17:03:48.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:48.438]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:48.438]                   base::options(opts)
[17:03:48.438]                 }
[17:03:48.438]                 {
[17:03:48.438]                   {
[17:03:48.438]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:48.438]                     NULL
[17:03:48.438]                   }
[17:03:48.438]                   options(future.plan = NULL)
[17:03:48.438]                   if (is.na(NA_character_)) 
[17:03:48.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:48.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:48.438]                     .init = FALSE)
[17:03:48.438]                 }
[17:03:48.438]             }
[17:03:48.438]         }
[17:03:48.438]     })
[17:03:48.438]     if (TRUE) {
[17:03:48.438]         base::sink(type = "output", split = FALSE)
[17:03:48.438]         if (TRUE) {
[17:03:48.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:48.438]         }
[17:03:48.438]         else {
[17:03:48.438]             ...future.result["stdout"] <- base::list(NULL)
[17:03:48.438]         }
[17:03:48.438]         base::close(...future.stdout)
[17:03:48.438]         ...future.stdout <- NULL
[17:03:48.438]     }
[17:03:48.438]     ...future.result$conditions <- ...future.conditions
[17:03:48.438]     ...future.result$finished <- base::Sys.time()
[17:03:48.438]     ...future.result
[17:03:48.438] }
[17:03:48.441] MultisessionFuture started
[17:03:48.441] - Launch lazy future ... done
[17:03:48.441] run() for ‘MultisessionFuture’ ... done
[17:03:48.943] receiveMessageFromWorker() for ClusterFuture ...
[17:03:48.944] - Validating connection of MultisessionFuture
[17:03:48.944] - received message: FutureResult
[17:03:48.944] - Received FutureResult
[17:03:48.944] - Erased future from FutureRegistry
[17:03:48.944] result() for ClusterFuture ...
[17:03:48.944] - result already collected: FutureResult
[17:03:48.944] result() for ClusterFuture ... done
[17:03:48.944] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:48.944] A MultisessionFuture was resolved
[17:03:48.945] getGlobalsAndPackages() ...
[17:03:48.945] Searching for globals...
[17:03:48.946] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:48.946] Searching for globals ... DONE
[17:03:48.946] Resolving globals: FALSE
[17:03:48.946] 
[17:03:48.946] 
[17:03:48.946] getGlobalsAndPackages() ... DONE
[17:03:48.947] run() for ‘Future’ ...
[17:03:48.947] - state: ‘created’
[17:03:48.947] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:48.961] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:48.961] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:48.961]   - Field: ‘node’
[17:03:48.961]   - Field: ‘label’
[17:03:48.961]   - Field: ‘local’
[17:03:48.961]   - Field: ‘owner’
[17:03:48.961]   - Field: ‘envir’
[17:03:48.962]   - Field: ‘workers’
[17:03:48.962]   - Field: ‘packages’
[17:03:48.962]   - Field: ‘gc’
[17:03:48.962]   - Field: ‘conditions’
[17:03:48.962]   - Field: ‘persistent’
[17:03:48.962]   - Field: ‘expr’
[17:03:48.962]   - Field: ‘uuid’
[17:03:48.962]   - Field: ‘seed’
[17:03:48.962]   - Field: ‘version’
[17:03:48.962]   - Field: ‘result’
[17:03:48.962]   - Field: ‘asynchronous’
[17:03:48.963]   - Field: ‘calls’
[17:03:48.963]   - Field: ‘globals’
[17:03:48.963]   - Field: ‘stdout’
[17:03:48.963]   - Field: ‘earlySignal’
[17:03:48.963]   - Field: ‘lazy’
[17:03:48.963]   - Field: ‘state’
[17:03:48.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:48.963] - Launch lazy future ...
[17:03:48.964] Packages needed by the future expression (n = 0): <none>
[17:03:48.964] Packages needed by future strategies (n = 0): <none>
[17:03:48.964] {
[17:03:48.964]     {
[17:03:48.964]         {
[17:03:48.964]             ...future.startTime <- base::Sys.time()
[17:03:48.964]             {
[17:03:48.964]                 {
[17:03:48.964]                   {
[17:03:48.964]                     {
[17:03:48.964]                       base::local({
[17:03:48.964]                         has_future <- base::requireNamespace("future", 
[17:03:48.964]                           quietly = TRUE)
[17:03:48.964]                         if (has_future) {
[17:03:48.964]                           ns <- base::getNamespace("future")
[17:03:48.964]                           version <- ns[[".package"]][["version"]]
[17:03:48.964]                           if (is.null(version)) 
[17:03:48.964]                             version <- utils::packageVersion("future")
[17:03:48.964]                         }
[17:03:48.964]                         else {
[17:03:48.964]                           version <- NULL
[17:03:48.964]                         }
[17:03:48.964]                         if (!has_future || version < "1.8.0") {
[17:03:48.964]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:48.964]                             "", base::R.version$version.string), 
[17:03:48.964]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:48.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:48.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:48.964]                               "release", "version")], collapse = " "), 
[17:03:48.964]                             hostname = base::Sys.info()[["nodename"]])
[17:03:48.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:48.964]                             info)
[17:03:48.964]                           info <- base::paste(info, collapse = "; ")
[17:03:48.964]                           if (!has_future) {
[17:03:48.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:48.964]                               info)
[17:03:48.964]                           }
[17:03:48.964]                           else {
[17:03:48.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:48.964]                               info, version)
[17:03:48.964]                           }
[17:03:48.964]                           base::stop(msg)
[17:03:48.964]                         }
[17:03:48.964]                       })
[17:03:48.964]                     }
[17:03:48.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:48.964]                     base::options(mc.cores = 1L)
[17:03:48.964]                   }
[17:03:48.964]                   ...future.strategy.old <- future::plan("list")
[17:03:48.964]                   options(future.plan = NULL)
[17:03:48.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:48.964]                 }
[17:03:48.964]                 ...future.workdir <- getwd()
[17:03:48.964]             }
[17:03:48.964]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:48.964]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:48.964]         }
[17:03:48.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:48.964]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:48.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:48.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:48.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:48.964]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:48.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:48.964]             base::names(...future.oldOptions))
[17:03:48.964]     }
[17:03:48.964]     if (FALSE) {
[17:03:48.964]     }
[17:03:48.964]     else {
[17:03:48.964]         if (TRUE) {
[17:03:48.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:48.964]                 open = "w")
[17:03:48.964]         }
[17:03:48.964]         else {
[17:03:48.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:48.964]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:48.964]         }
[17:03:48.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:48.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:48.964]             base::sink(type = "output", split = FALSE)
[17:03:48.964]             base::close(...future.stdout)
[17:03:48.964]         }, add = TRUE)
[17:03:48.964]     }
[17:03:48.964]     ...future.frame <- base::sys.nframe()
[17:03:48.964]     ...future.conditions <- base::list()
[17:03:48.964]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:48.964]     if (FALSE) {
[17:03:48.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:48.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:48.964]     }
[17:03:48.964]     ...future.result <- base::tryCatch({
[17:03:48.964]         base::withCallingHandlers({
[17:03:48.964]             ...future.value <- base::withVisible(base::local({
[17:03:48.964]                 ...future.makeSendCondition <- base::local({
[17:03:48.964]                   sendCondition <- NULL
[17:03:48.964]                   function(frame = 1L) {
[17:03:48.964]                     if (is.function(sendCondition)) 
[17:03:48.964]                       return(sendCondition)
[17:03:48.964]                     ns <- getNamespace("parallel")
[17:03:48.964]                     if (exists("sendData", mode = "function", 
[17:03:48.964]                       envir = ns)) {
[17:03:48.964]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:48.964]                         envir = ns)
[17:03:48.964]                       envir <- sys.frame(frame)
[17:03:48.964]                       master <- NULL
[17:03:48.964]                       while (!identical(envir, .GlobalEnv) && 
[17:03:48.964]                         !identical(envir, emptyenv())) {
[17:03:48.964]                         if (exists("master", mode = "list", envir = envir, 
[17:03:48.964]                           inherits = FALSE)) {
[17:03:48.964]                           master <- get("master", mode = "list", 
[17:03:48.964]                             envir = envir, inherits = FALSE)
[17:03:48.964]                           if (inherits(master, c("SOCKnode", 
[17:03:48.964]                             "SOCK0node"))) {
[17:03:48.964]                             sendCondition <<- function(cond) {
[17:03:48.964]                               data <- list(type = "VALUE", value = cond, 
[17:03:48.964]                                 success = TRUE)
[17:03:48.964]                               parallel_sendData(master, data)
[17:03:48.964]                             }
[17:03:48.964]                             return(sendCondition)
[17:03:48.964]                           }
[17:03:48.964]                         }
[17:03:48.964]                         frame <- frame + 1L
[17:03:48.964]                         envir <- sys.frame(frame)
[17:03:48.964]                       }
[17:03:48.964]                     }
[17:03:48.964]                     sendCondition <<- function(cond) NULL
[17:03:48.964]                   }
[17:03:48.964]                 })
[17:03:48.964]                 withCallingHandlers({
[17:03:48.964]                   {
[17:03:48.964]                     Sys.sleep(0.5)
[17:03:48.964]                     list(a = 1, b = 42L)
[17:03:48.964]                   }
[17:03:48.964]                 }, immediateCondition = function(cond) {
[17:03:48.964]                   sendCondition <- ...future.makeSendCondition()
[17:03:48.964]                   sendCondition(cond)
[17:03:48.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.964]                   {
[17:03:48.964]                     inherits <- base::inherits
[17:03:48.964]                     invokeRestart <- base::invokeRestart
[17:03:48.964]                     is.null <- base::is.null
[17:03:48.964]                     muffled <- FALSE
[17:03:48.964]                     if (inherits(cond, "message")) {
[17:03:48.964]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:48.964]                       if (muffled) 
[17:03:48.964]                         invokeRestart("muffleMessage")
[17:03:48.964]                     }
[17:03:48.964]                     else if (inherits(cond, "warning")) {
[17:03:48.964]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:48.964]                       if (muffled) 
[17:03:48.964]                         invokeRestart("muffleWarning")
[17:03:48.964]                     }
[17:03:48.964]                     else if (inherits(cond, "condition")) {
[17:03:48.964]                       if (!is.null(pattern)) {
[17:03:48.964]                         computeRestarts <- base::computeRestarts
[17:03:48.964]                         grepl <- base::grepl
[17:03:48.964]                         restarts <- computeRestarts(cond)
[17:03:48.964]                         for (restart in restarts) {
[17:03:48.964]                           name <- restart$name
[17:03:48.964]                           if (is.null(name)) 
[17:03:48.964]                             next
[17:03:48.964]                           if (!grepl(pattern, name)) 
[17:03:48.964]                             next
[17:03:48.964]                           invokeRestart(restart)
[17:03:48.964]                           muffled <- TRUE
[17:03:48.964]                           break
[17:03:48.964]                         }
[17:03:48.964]                       }
[17:03:48.964]                     }
[17:03:48.964]                     invisible(muffled)
[17:03:48.964]                   }
[17:03:48.964]                   muffleCondition(cond)
[17:03:48.964]                 })
[17:03:48.964]             }))
[17:03:48.964]             future::FutureResult(value = ...future.value$value, 
[17:03:48.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.964]                   ...future.rng), globalenv = if (FALSE) 
[17:03:48.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:48.964]                     ...future.globalenv.names))
[17:03:48.964]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:48.964]         }, condition = base::local({
[17:03:48.964]             c <- base::c
[17:03:48.964]             inherits <- base::inherits
[17:03:48.964]             invokeRestart <- base::invokeRestart
[17:03:48.964]             length <- base::length
[17:03:48.964]             list <- base::list
[17:03:48.964]             seq.int <- base::seq.int
[17:03:48.964]             signalCondition <- base::signalCondition
[17:03:48.964]             sys.calls <- base::sys.calls
[17:03:48.964]             `[[` <- base::`[[`
[17:03:48.964]             `+` <- base::`+`
[17:03:48.964]             `<<-` <- base::`<<-`
[17:03:48.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:48.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:48.964]                   3L)]
[17:03:48.964]             }
[17:03:48.964]             function(cond) {
[17:03:48.964]                 is_error <- inherits(cond, "error")
[17:03:48.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:48.964]                   NULL)
[17:03:48.964]                 if (is_error) {
[17:03:48.964]                   sessionInformation <- function() {
[17:03:48.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:48.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:48.964]                       search = base::search(), system = base::Sys.info())
[17:03:48.964]                   }
[17:03:48.964]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:48.964]                     cond$call), session = sessionInformation(), 
[17:03:48.964]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:48.964]                   signalCondition(cond)
[17:03:48.964]                 }
[17:03:48.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:48.964]                 "immediateCondition"))) {
[17:03:48.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:48.964]                   ...future.conditions[[length(...future.conditions) + 
[17:03:48.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:48.964]                   if (TRUE && !signal) {
[17:03:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.964]                     {
[17:03:48.964]                       inherits <- base::inherits
[17:03:48.964]                       invokeRestart <- base::invokeRestart
[17:03:48.964]                       is.null <- base::is.null
[17:03:48.964]                       muffled <- FALSE
[17:03:48.964]                       if (inherits(cond, "message")) {
[17:03:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.964]                         if (muffled) 
[17:03:48.964]                           invokeRestart("muffleMessage")
[17:03:48.964]                       }
[17:03:48.964]                       else if (inherits(cond, "warning")) {
[17:03:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.964]                         if (muffled) 
[17:03:48.964]                           invokeRestart("muffleWarning")
[17:03:48.964]                       }
[17:03:48.964]                       else if (inherits(cond, "condition")) {
[17:03:48.964]                         if (!is.null(pattern)) {
[17:03:48.964]                           computeRestarts <- base::computeRestarts
[17:03:48.964]                           grepl <- base::grepl
[17:03:48.964]                           restarts <- computeRestarts(cond)
[17:03:48.964]                           for (restart in restarts) {
[17:03:48.964]                             name <- restart$name
[17:03:48.964]                             if (is.null(name)) 
[17:03:48.964]                               next
[17:03:48.964]                             if (!grepl(pattern, name)) 
[17:03:48.964]                               next
[17:03:48.964]                             invokeRestart(restart)
[17:03:48.964]                             muffled <- TRUE
[17:03:48.964]                             break
[17:03:48.964]                           }
[17:03:48.964]                         }
[17:03:48.964]                       }
[17:03:48.964]                       invisible(muffled)
[17:03:48.964]                     }
[17:03:48.964]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.964]                   }
[17:03:48.964]                 }
[17:03:48.964]                 else {
[17:03:48.964]                   if (TRUE) {
[17:03:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:48.964]                     {
[17:03:48.964]                       inherits <- base::inherits
[17:03:48.964]                       invokeRestart <- base::invokeRestart
[17:03:48.964]                       is.null <- base::is.null
[17:03:48.964]                       muffled <- FALSE
[17:03:48.964]                       if (inherits(cond, "message")) {
[17:03:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:48.964]                         if (muffled) 
[17:03:48.964]                           invokeRestart("muffleMessage")
[17:03:48.964]                       }
[17:03:48.964]                       else if (inherits(cond, "warning")) {
[17:03:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:48.964]                         if (muffled) 
[17:03:48.964]                           invokeRestart("muffleWarning")
[17:03:48.964]                       }
[17:03:48.964]                       else if (inherits(cond, "condition")) {
[17:03:48.964]                         if (!is.null(pattern)) {
[17:03:48.964]                           computeRestarts <- base::computeRestarts
[17:03:48.964]                           grepl <- base::grepl
[17:03:48.964]                           restarts <- computeRestarts(cond)
[17:03:48.964]                           for (restart in restarts) {
[17:03:48.964]                             name <- restart$name
[17:03:48.964]                             if (is.null(name)) 
[17:03:48.964]                               next
[17:03:48.964]                             if (!grepl(pattern, name)) 
[17:03:48.964]                               next
[17:03:48.964]                             invokeRestart(restart)
[17:03:48.964]                             muffled <- TRUE
[17:03:48.964]                             break
[17:03:48.964]                           }
[17:03:48.964]                         }
[17:03:48.964]                       }
[17:03:48.964]                       invisible(muffled)
[17:03:48.964]                     }
[17:03:48.964]                     muffleCondition(cond, pattern = "^muffle")
[17:03:48.964]                   }
[17:03:48.964]                 }
[17:03:48.964]             }
[17:03:48.964]         }))
[17:03:48.964]     }, error = function(ex) {
[17:03:48.964]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:48.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:48.964]                 ...future.rng), started = ...future.startTime, 
[17:03:48.964]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:48.964]             version = "1.8"), class = "FutureResult")
[17:03:48.964]     }, finally = {
[17:03:48.964]         if (!identical(...future.workdir, getwd())) 
[17:03:48.964]             setwd(...future.workdir)
[17:03:48.964]         {
[17:03:48.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:48.964]                 ...future.oldOptions$nwarnings <- NULL
[17:03:48.964]             }
[17:03:48.964]             base::options(...future.oldOptions)
[17:03:48.964]             if (.Platform$OS.type == "windows") {
[17:03:48.964]                 old_names <- names(...future.oldEnvVars)
[17:03:48.964]                 envs <- base::Sys.getenv()
[17:03:48.964]                 names <- names(envs)
[17:03:48.964]                 common <- intersect(names, old_names)
[17:03:48.964]                 added <- setdiff(names, old_names)
[17:03:48.964]                 removed <- setdiff(old_names, names)
[17:03:48.964]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:48.964]                   envs[common]]
[17:03:48.964]                 NAMES <- toupper(changed)
[17:03:48.964]                 args <- list()
[17:03:48.964]                 for (kk in seq_along(NAMES)) {
[17:03:48.964]                   name <- changed[[kk]]
[17:03:48.964]                   NAME <- NAMES[[kk]]
[17:03:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.964]                     next
[17:03:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.964]                 }
[17:03:48.964]                 NAMES <- toupper(added)
[17:03:48.964]                 for (kk in seq_along(NAMES)) {
[17:03:48.964]                   name <- added[[kk]]
[17:03:48.964]                   NAME <- NAMES[[kk]]
[17:03:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.964]                     next
[17:03:48.964]                   args[[name]] <- ""
[17:03:48.964]                 }
[17:03:48.964]                 NAMES <- toupper(removed)
[17:03:48.964]                 for (kk in seq_along(NAMES)) {
[17:03:48.964]                   name <- removed[[kk]]
[17:03:48.964]                   NAME <- NAMES[[kk]]
[17:03:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:48.964]                     next
[17:03:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:48.964]                 }
[17:03:48.964]                 if (length(args) > 0) 
[17:03:48.964]                   base::do.call(base::Sys.setenv, args = args)
[17:03:48.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:48.964]             }
[17:03:48.964]             else {
[17:03:48.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:48.964]             }
[17:03:48.964]             {
[17:03:48.964]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:48.964]                   0L) {
[17:03:48.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:48.964]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:48.964]                   base::options(opts)
[17:03:48.964]                 }
[17:03:48.964]                 {
[17:03:48.964]                   {
[17:03:48.964]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:48.964]                     NULL
[17:03:48.964]                   }
[17:03:48.964]                   options(future.plan = NULL)
[17:03:48.964]                   if (is.na(NA_character_)) 
[17:03:48.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:48.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:48.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:48.964]                     .init = FALSE)
[17:03:48.964]                 }
[17:03:48.964]             }
[17:03:48.964]         }
[17:03:48.964]     })
[17:03:48.964]     if (TRUE) {
[17:03:48.964]         base::sink(type = "output", split = FALSE)
[17:03:48.964]         if (TRUE) {
[17:03:48.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:48.964]         }
[17:03:48.964]         else {
[17:03:48.964]             ...future.result["stdout"] <- base::list(NULL)
[17:03:48.964]         }
[17:03:48.964]         base::close(...future.stdout)
[17:03:48.964]         ...future.stdout <- NULL
[17:03:48.964]     }
[17:03:48.964]     ...future.result$conditions <- ...future.conditions
[17:03:48.964]     ...future.result$finished <- base::Sys.time()
[17:03:48.964]     ...future.result
[17:03:48.964] }
[17:03:48.967] MultisessionFuture started
[17:03:48.967] - Launch lazy future ... done
[17:03:48.967] run() for ‘MultisessionFuture’ ... done
[17:03:49.470] receiveMessageFromWorker() for ClusterFuture ...
[17:03:49.470] - Validating connection of MultisessionFuture
[17:03:49.470] - received message: FutureResult
[17:03:49.470] - Received FutureResult
[17:03:49.471] - Erased future from FutureRegistry
[17:03:49.471] result() for ClusterFuture ...
[17:03:49.471] - result already collected: FutureResult
[17:03:49.471] result() for ClusterFuture ... done
[17:03:49.471] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:49.471] A MultisessionFuture was resolved
- w/ exception ...
[17:03:49.471] getGlobalsAndPackages() ...
[17:03:49.471] Searching for globals...
[17:03:49.472] - globals found: [2] ‘list’, ‘stop’
[17:03:49.472] Searching for globals ... DONE
[17:03:49.472] Resolving globals: FALSE
[17:03:49.473] 
[17:03:49.473] 
[17:03:49.473] getGlobalsAndPackages() ... DONE
[17:03:49.473] run() for ‘Future’ ...
[17:03:49.473] - state: ‘created’
[17:03:49.473] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:49.488] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:49.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:49.488]   - Field: ‘node’
[17:03:49.488]   - Field: ‘label’
[17:03:49.488]   - Field: ‘local’
[17:03:49.488]   - Field: ‘owner’
[17:03:49.489]   - Field: ‘envir’
[17:03:49.489]   - Field: ‘workers’
[17:03:49.489]   - Field: ‘packages’
[17:03:49.489]   - Field: ‘gc’
[17:03:49.489]   - Field: ‘conditions’
[17:03:49.489]   - Field: ‘persistent’
[17:03:49.489]   - Field: ‘expr’
[17:03:49.489]   - Field: ‘uuid’
[17:03:49.489]   - Field: ‘seed’
[17:03:49.489]   - Field: ‘version’
[17:03:49.489]   - Field: ‘result’
[17:03:49.489]   - Field: ‘asynchronous’
[17:03:49.490]   - Field: ‘calls’
[17:03:49.490]   - Field: ‘globals’
[17:03:49.490]   - Field: ‘stdout’
[17:03:49.490]   - Field: ‘earlySignal’
[17:03:49.490]   - Field: ‘lazy’
[17:03:49.490]   - Field: ‘state’
[17:03:49.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:49.490] - Launch lazy future ...
[17:03:49.490] Packages needed by the future expression (n = 0): <none>
[17:03:49.491] Packages needed by future strategies (n = 0): <none>
[17:03:49.491] {
[17:03:49.491]     {
[17:03:49.491]         {
[17:03:49.491]             ...future.startTime <- base::Sys.time()
[17:03:49.491]             {
[17:03:49.491]                 {
[17:03:49.491]                   {
[17:03:49.491]                     {
[17:03:49.491]                       base::local({
[17:03:49.491]                         has_future <- base::requireNamespace("future", 
[17:03:49.491]                           quietly = TRUE)
[17:03:49.491]                         if (has_future) {
[17:03:49.491]                           ns <- base::getNamespace("future")
[17:03:49.491]                           version <- ns[[".package"]][["version"]]
[17:03:49.491]                           if (is.null(version)) 
[17:03:49.491]                             version <- utils::packageVersion("future")
[17:03:49.491]                         }
[17:03:49.491]                         else {
[17:03:49.491]                           version <- NULL
[17:03:49.491]                         }
[17:03:49.491]                         if (!has_future || version < "1.8.0") {
[17:03:49.491]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:49.491]                             "", base::R.version$version.string), 
[17:03:49.491]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:49.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:49.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:49.491]                               "release", "version")], collapse = " "), 
[17:03:49.491]                             hostname = base::Sys.info()[["nodename"]])
[17:03:49.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:49.491]                             info)
[17:03:49.491]                           info <- base::paste(info, collapse = "; ")
[17:03:49.491]                           if (!has_future) {
[17:03:49.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:49.491]                               info)
[17:03:49.491]                           }
[17:03:49.491]                           else {
[17:03:49.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:49.491]                               info, version)
[17:03:49.491]                           }
[17:03:49.491]                           base::stop(msg)
[17:03:49.491]                         }
[17:03:49.491]                       })
[17:03:49.491]                     }
[17:03:49.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:49.491]                     base::options(mc.cores = 1L)
[17:03:49.491]                   }
[17:03:49.491]                   ...future.strategy.old <- future::plan("list")
[17:03:49.491]                   options(future.plan = NULL)
[17:03:49.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:49.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:49.491]                 }
[17:03:49.491]                 ...future.workdir <- getwd()
[17:03:49.491]             }
[17:03:49.491]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:49.491]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:49.491]         }
[17:03:49.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:49.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:49.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:49.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:49.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:49.491]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:49.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:49.491]             base::names(...future.oldOptions))
[17:03:49.491]     }
[17:03:49.491]     if (FALSE) {
[17:03:49.491]     }
[17:03:49.491]     else {
[17:03:49.491]         if (TRUE) {
[17:03:49.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:49.491]                 open = "w")
[17:03:49.491]         }
[17:03:49.491]         else {
[17:03:49.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:49.491]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:49.491]         }
[17:03:49.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:49.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:49.491]             base::sink(type = "output", split = FALSE)
[17:03:49.491]             base::close(...future.stdout)
[17:03:49.491]         }, add = TRUE)
[17:03:49.491]     }
[17:03:49.491]     ...future.frame <- base::sys.nframe()
[17:03:49.491]     ...future.conditions <- base::list()
[17:03:49.491]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:49.491]     if (FALSE) {
[17:03:49.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:49.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:49.491]     }
[17:03:49.491]     ...future.result <- base::tryCatch({
[17:03:49.491]         base::withCallingHandlers({
[17:03:49.491]             ...future.value <- base::withVisible(base::local({
[17:03:49.491]                 ...future.makeSendCondition <- base::local({
[17:03:49.491]                   sendCondition <- NULL
[17:03:49.491]                   function(frame = 1L) {
[17:03:49.491]                     if (is.function(sendCondition)) 
[17:03:49.491]                       return(sendCondition)
[17:03:49.491]                     ns <- getNamespace("parallel")
[17:03:49.491]                     if (exists("sendData", mode = "function", 
[17:03:49.491]                       envir = ns)) {
[17:03:49.491]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:49.491]                         envir = ns)
[17:03:49.491]                       envir <- sys.frame(frame)
[17:03:49.491]                       master <- NULL
[17:03:49.491]                       while (!identical(envir, .GlobalEnv) && 
[17:03:49.491]                         !identical(envir, emptyenv())) {
[17:03:49.491]                         if (exists("master", mode = "list", envir = envir, 
[17:03:49.491]                           inherits = FALSE)) {
[17:03:49.491]                           master <- get("master", mode = "list", 
[17:03:49.491]                             envir = envir, inherits = FALSE)
[17:03:49.491]                           if (inherits(master, c("SOCKnode", 
[17:03:49.491]                             "SOCK0node"))) {
[17:03:49.491]                             sendCondition <<- function(cond) {
[17:03:49.491]                               data <- list(type = "VALUE", value = cond, 
[17:03:49.491]                                 success = TRUE)
[17:03:49.491]                               parallel_sendData(master, data)
[17:03:49.491]                             }
[17:03:49.491]                             return(sendCondition)
[17:03:49.491]                           }
[17:03:49.491]                         }
[17:03:49.491]                         frame <- frame + 1L
[17:03:49.491]                         envir <- sys.frame(frame)
[17:03:49.491]                       }
[17:03:49.491]                     }
[17:03:49.491]                     sendCondition <<- function(cond) NULL
[17:03:49.491]                   }
[17:03:49.491]                 })
[17:03:49.491]                 withCallingHandlers({
[17:03:49.491]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:49.491]                 }, immediateCondition = function(cond) {
[17:03:49.491]                   sendCondition <- ...future.makeSendCondition()
[17:03:49.491]                   sendCondition(cond)
[17:03:49.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.491]                   {
[17:03:49.491]                     inherits <- base::inherits
[17:03:49.491]                     invokeRestart <- base::invokeRestart
[17:03:49.491]                     is.null <- base::is.null
[17:03:49.491]                     muffled <- FALSE
[17:03:49.491]                     if (inherits(cond, "message")) {
[17:03:49.491]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:49.491]                       if (muffled) 
[17:03:49.491]                         invokeRestart("muffleMessage")
[17:03:49.491]                     }
[17:03:49.491]                     else if (inherits(cond, "warning")) {
[17:03:49.491]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:49.491]                       if (muffled) 
[17:03:49.491]                         invokeRestart("muffleWarning")
[17:03:49.491]                     }
[17:03:49.491]                     else if (inherits(cond, "condition")) {
[17:03:49.491]                       if (!is.null(pattern)) {
[17:03:49.491]                         computeRestarts <- base::computeRestarts
[17:03:49.491]                         grepl <- base::grepl
[17:03:49.491]                         restarts <- computeRestarts(cond)
[17:03:49.491]                         for (restart in restarts) {
[17:03:49.491]                           name <- restart$name
[17:03:49.491]                           if (is.null(name)) 
[17:03:49.491]                             next
[17:03:49.491]                           if (!grepl(pattern, name)) 
[17:03:49.491]                             next
[17:03:49.491]                           invokeRestart(restart)
[17:03:49.491]                           muffled <- TRUE
[17:03:49.491]                           break
[17:03:49.491]                         }
[17:03:49.491]                       }
[17:03:49.491]                     }
[17:03:49.491]                     invisible(muffled)
[17:03:49.491]                   }
[17:03:49.491]                   muffleCondition(cond)
[17:03:49.491]                 })
[17:03:49.491]             }))
[17:03:49.491]             future::FutureResult(value = ...future.value$value, 
[17:03:49.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:49.491]                   ...future.rng), globalenv = if (FALSE) 
[17:03:49.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:49.491]                     ...future.globalenv.names))
[17:03:49.491]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:49.491]         }, condition = base::local({
[17:03:49.491]             c <- base::c
[17:03:49.491]             inherits <- base::inherits
[17:03:49.491]             invokeRestart <- base::invokeRestart
[17:03:49.491]             length <- base::length
[17:03:49.491]             list <- base::list
[17:03:49.491]             seq.int <- base::seq.int
[17:03:49.491]             signalCondition <- base::signalCondition
[17:03:49.491]             sys.calls <- base::sys.calls
[17:03:49.491]             `[[` <- base::`[[`
[17:03:49.491]             `+` <- base::`+`
[17:03:49.491]             `<<-` <- base::`<<-`
[17:03:49.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:49.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:49.491]                   3L)]
[17:03:49.491]             }
[17:03:49.491]             function(cond) {
[17:03:49.491]                 is_error <- inherits(cond, "error")
[17:03:49.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:49.491]                   NULL)
[17:03:49.491]                 if (is_error) {
[17:03:49.491]                   sessionInformation <- function() {
[17:03:49.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:49.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:49.491]                       search = base::search(), system = base::Sys.info())
[17:03:49.491]                   }
[17:03:49.491]                   ...future.conditions[[length(...future.conditions) + 
[17:03:49.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:49.491]                     cond$call), session = sessionInformation(), 
[17:03:49.491]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:49.491]                   signalCondition(cond)
[17:03:49.491]                 }
[17:03:49.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:49.491]                 "immediateCondition"))) {
[17:03:49.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:49.491]                   ...future.conditions[[length(...future.conditions) + 
[17:03:49.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:49.491]                   if (TRUE && !signal) {
[17:03:49.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.491]                     {
[17:03:49.491]                       inherits <- base::inherits
[17:03:49.491]                       invokeRestart <- base::invokeRestart
[17:03:49.491]                       is.null <- base::is.null
[17:03:49.491]                       muffled <- FALSE
[17:03:49.491]                       if (inherits(cond, "message")) {
[17:03:49.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:49.491]                         if (muffled) 
[17:03:49.491]                           invokeRestart("muffleMessage")
[17:03:49.491]                       }
[17:03:49.491]                       else if (inherits(cond, "warning")) {
[17:03:49.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:49.491]                         if (muffled) 
[17:03:49.491]                           invokeRestart("muffleWarning")
[17:03:49.491]                       }
[17:03:49.491]                       else if (inherits(cond, "condition")) {
[17:03:49.491]                         if (!is.null(pattern)) {
[17:03:49.491]                           computeRestarts <- base::computeRestarts
[17:03:49.491]                           grepl <- base::grepl
[17:03:49.491]                           restarts <- computeRestarts(cond)
[17:03:49.491]                           for (restart in restarts) {
[17:03:49.491]                             name <- restart$name
[17:03:49.491]                             if (is.null(name)) 
[17:03:49.491]                               next
[17:03:49.491]                             if (!grepl(pattern, name)) 
[17:03:49.491]                               next
[17:03:49.491]                             invokeRestart(restart)
[17:03:49.491]                             muffled <- TRUE
[17:03:49.491]                             break
[17:03:49.491]                           }
[17:03:49.491]                         }
[17:03:49.491]                       }
[17:03:49.491]                       invisible(muffled)
[17:03:49.491]                     }
[17:03:49.491]                     muffleCondition(cond, pattern = "^muffle")
[17:03:49.491]                   }
[17:03:49.491]                 }
[17:03:49.491]                 else {
[17:03:49.491]                   if (TRUE) {
[17:03:49.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.491]                     {
[17:03:49.491]                       inherits <- base::inherits
[17:03:49.491]                       invokeRestart <- base::invokeRestart
[17:03:49.491]                       is.null <- base::is.null
[17:03:49.491]                       muffled <- FALSE
[17:03:49.491]                       if (inherits(cond, "message")) {
[17:03:49.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:49.491]                         if (muffled) 
[17:03:49.491]                           invokeRestart("muffleMessage")
[17:03:49.491]                       }
[17:03:49.491]                       else if (inherits(cond, "warning")) {
[17:03:49.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:49.491]                         if (muffled) 
[17:03:49.491]                           invokeRestart("muffleWarning")
[17:03:49.491]                       }
[17:03:49.491]                       else if (inherits(cond, "condition")) {
[17:03:49.491]                         if (!is.null(pattern)) {
[17:03:49.491]                           computeRestarts <- base::computeRestarts
[17:03:49.491]                           grepl <- base::grepl
[17:03:49.491]                           restarts <- computeRestarts(cond)
[17:03:49.491]                           for (restart in restarts) {
[17:03:49.491]                             name <- restart$name
[17:03:49.491]                             if (is.null(name)) 
[17:03:49.491]                               next
[17:03:49.491]                             if (!grepl(pattern, name)) 
[17:03:49.491]                               next
[17:03:49.491]                             invokeRestart(restart)
[17:03:49.491]                             muffled <- TRUE
[17:03:49.491]                             break
[17:03:49.491]                           }
[17:03:49.491]                         }
[17:03:49.491]                       }
[17:03:49.491]                       invisible(muffled)
[17:03:49.491]                     }
[17:03:49.491]                     muffleCondition(cond, pattern = "^muffle")
[17:03:49.491]                   }
[17:03:49.491]                 }
[17:03:49.491]             }
[17:03:49.491]         }))
[17:03:49.491]     }, error = function(ex) {
[17:03:49.491]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:49.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:49.491]                 ...future.rng), started = ...future.startTime, 
[17:03:49.491]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:49.491]             version = "1.8"), class = "FutureResult")
[17:03:49.491]     }, finally = {
[17:03:49.491]         if (!identical(...future.workdir, getwd())) 
[17:03:49.491]             setwd(...future.workdir)
[17:03:49.491]         {
[17:03:49.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:49.491]                 ...future.oldOptions$nwarnings <- NULL
[17:03:49.491]             }
[17:03:49.491]             base::options(...future.oldOptions)
[17:03:49.491]             if (.Platform$OS.type == "windows") {
[17:03:49.491]                 old_names <- names(...future.oldEnvVars)
[17:03:49.491]                 envs <- base::Sys.getenv()
[17:03:49.491]                 names <- names(envs)
[17:03:49.491]                 common <- intersect(names, old_names)
[17:03:49.491]                 added <- setdiff(names, old_names)
[17:03:49.491]                 removed <- setdiff(old_names, names)
[17:03:49.491]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:49.491]                   envs[common]]
[17:03:49.491]                 NAMES <- toupper(changed)
[17:03:49.491]                 args <- list()
[17:03:49.491]                 for (kk in seq_along(NAMES)) {
[17:03:49.491]                   name <- changed[[kk]]
[17:03:49.491]                   NAME <- NAMES[[kk]]
[17:03:49.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.491]                     next
[17:03:49.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:49.491]                 }
[17:03:49.491]                 NAMES <- toupper(added)
[17:03:49.491]                 for (kk in seq_along(NAMES)) {
[17:03:49.491]                   name <- added[[kk]]
[17:03:49.491]                   NAME <- NAMES[[kk]]
[17:03:49.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.491]                     next
[17:03:49.491]                   args[[name]] <- ""
[17:03:49.491]                 }
[17:03:49.491]                 NAMES <- toupper(removed)
[17:03:49.491]                 for (kk in seq_along(NAMES)) {
[17:03:49.491]                   name <- removed[[kk]]
[17:03:49.491]                   NAME <- NAMES[[kk]]
[17:03:49.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.491]                     next
[17:03:49.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:49.491]                 }
[17:03:49.491]                 if (length(args) > 0) 
[17:03:49.491]                   base::do.call(base::Sys.setenv, args = args)
[17:03:49.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:49.491]             }
[17:03:49.491]             else {
[17:03:49.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:49.491]             }
[17:03:49.491]             {
[17:03:49.491]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:49.491]                   0L) {
[17:03:49.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:49.491]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:49.491]                   base::options(opts)
[17:03:49.491]                 }
[17:03:49.491]                 {
[17:03:49.491]                   {
[17:03:49.491]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:49.491]                     NULL
[17:03:49.491]                   }
[17:03:49.491]                   options(future.plan = NULL)
[17:03:49.491]                   if (is.na(NA_character_)) 
[17:03:49.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:49.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:49.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:49.491]                     .init = FALSE)
[17:03:49.491]                 }
[17:03:49.491]             }
[17:03:49.491]         }
[17:03:49.491]     })
[17:03:49.491]     if (TRUE) {
[17:03:49.491]         base::sink(type = "output", split = FALSE)
[17:03:49.491]         if (TRUE) {
[17:03:49.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:49.491]         }
[17:03:49.491]         else {
[17:03:49.491]             ...future.result["stdout"] <- base::list(NULL)
[17:03:49.491]         }
[17:03:49.491]         base::close(...future.stdout)
[17:03:49.491]         ...future.stdout <- NULL
[17:03:49.491]     }
[17:03:49.491]     ...future.result$conditions <- ...future.conditions
[17:03:49.491]     ...future.result$finished <- base::Sys.time()
[17:03:49.491]     ...future.result
[17:03:49.491] }
[17:03:49.494] MultisessionFuture started
[17:03:49.494] - Launch lazy future ... done
[17:03:49.494] run() for ‘MultisessionFuture’ ... done
[17:03:49.496] receiveMessageFromWorker() for ClusterFuture ...
[17:03:49.496] - Validating connection of MultisessionFuture
[17:03:49.496] - received message: FutureResult
[17:03:49.496] - Received FutureResult
[17:03:49.497] - Erased future from FutureRegistry
[17:03:49.497] result() for ClusterFuture ...
[17:03:49.497] - result already collected: FutureResult
[17:03:49.497] result() for ClusterFuture ... done
[17:03:49.497] signalConditions() ...
[17:03:49.497]  - include = ‘immediateCondition’
[17:03:49.497]  - exclude = 
[17:03:49.497]  - resignal = FALSE
[17:03:49.497]  - Number of conditions: 1
[17:03:49.497] signalConditions() ... done
[17:03:49.497] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:49.497] A MultisessionFuture was resolved
[17:03:49.498] getGlobalsAndPackages() ...
[17:03:49.498] Searching for globals...
[17:03:49.498] - globals found: [2] ‘list’, ‘stop’
[17:03:49.498] Searching for globals ... DONE
[17:03:49.499] Resolving globals: FALSE
[17:03:49.499] 
[17:03:49.499] 
[17:03:49.499] getGlobalsAndPackages() ... DONE
[17:03:49.499] run() for ‘Future’ ...
[17:03:49.499] - state: ‘created’
[17:03:49.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:49.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:49.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:49.514]   - Field: ‘node’
[17:03:49.514]   - Field: ‘label’
[17:03:49.514]   - Field: ‘local’
[17:03:49.514]   - Field: ‘owner’
[17:03:49.514]   - Field: ‘envir’
[17:03:49.514]   - Field: ‘workers’
[17:03:49.514]   - Field: ‘packages’
[17:03:49.514]   - Field: ‘gc’
[17:03:49.515]   - Field: ‘conditions’
[17:03:49.515]   - Field: ‘persistent’
[17:03:49.515]   - Field: ‘expr’
[17:03:49.515]   - Field: ‘uuid’
[17:03:49.515]   - Field: ‘seed’
[17:03:49.515]   - Field: ‘version’
[17:03:49.515]   - Field: ‘result’
[17:03:49.515]   - Field: ‘asynchronous’
[17:03:49.515]   - Field: ‘calls’
[17:03:49.515]   - Field: ‘globals’
[17:03:49.515]   - Field: ‘stdout’
[17:03:49.516]   - Field: ‘earlySignal’
[17:03:49.516]   - Field: ‘lazy’
[17:03:49.516]   - Field: ‘state’
[17:03:49.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:49.516] - Launch lazy future ...
[17:03:49.516] Packages needed by the future expression (n = 0): <none>
[17:03:49.516] Packages needed by future strategies (n = 0): <none>
[17:03:49.517] {
[17:03:49.517]     {
[17:03:49.517]         {
[17:03:49.517]             ...future.startTime <- base::Sys.time()
[17:03:49.517]             {
[17:03:49.517]                 {
[17:03:49.517]                   {
[17:03:49.517]                     {
[17:03:49.517]                       base::local({
[17:03:49.517]                         has_future <- base::requireNamespace("future", 
[17:03:49.517]                           quietly = TRUE)
[17:03:49.517]                         if (has_future) {
[17:03:49.517]                           ns <- base::getNamespace("future")
[17:03:49.517]                           version <- ns[[".package"]][["version"]]
[17:03:49.517]                           if (is.null(version)) 
[17:03:49.517]                             version <- utils::packageVersion("future")
[17:03:49.517]                         }
[17:03:49.517]                         else {
[17:03:49.517]                           version <- NULL
[17:03:49.517]                         }
[17:03:49.517]                         if (!has_future || version < "1.8.0") {
[17:03:49.517]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:49.517]                             "", base::R.version$version.string), 
[17:03:49.517]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:49.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:49.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:49.517]                               "release", "version")], collapse = " "), 
[17:03:49.517]                             hostname = base::Sys.info()[["nodename"]])
[17:03:49.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:49.517]                             info)
[17:03:49.517]                           info <- base::paste(info, collapse = "; ")
[17:03:49.517]                           if (!has_future) {
[17:03:49.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:49.517]                               info)
[17:03:49.517]                           }
[17:03:49.517]                           else {
[17:03:49.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:49.517]                               info, version)
[17:03:49.517]                           }
[17:03:49.517]                           base::stop(msg)
[17:03:49.517]                         }
[17:03:49.517]                       })
[17:03:49.517]                     }
[17:03:49.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:49.517]                     base::options(mc.cores = 1L)
[17:03:49.517]                   }
[17:03:49.517]                   ...future.strategy.old <- future::plan("list")
[17:03:49.517]                   options(future.plan = NULL)
[17:03:49.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:49.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:49.517]                 }
[17:03:49.517]                 ...future.workdir <- getwd()
[17:03:49.517]             }
[17:03:49.517]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:49.517]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:49.517]         }
[17:03:49.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:49.517]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:49.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:49.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:49.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:49.517]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:49.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:49.517]             base::names(...future.oldOptions))
[17:03:49.517]     }
[17:03:49.517]     if (FALSE) {
[17:03:49.517]     }
[17:03:49.517]     else {
[17:03:49.517]         if (TRUE) {
[17:03:49.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:49.517]                 open = "w")
[17:03:49.517]         }
[17:03:49.517]         else {
[17:03:49.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:49.517]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:49.517]         }
[17:03:49.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:49.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:49.517]             base::sink(type = "output", split = FALSE)
[17:03:49.517]             base::close(...future.stdout)
[17:03:49.517]         }, add = TRUE)
[17:03:49.517]     }
[17:03:49.517]     ...future.frame <- base::sys.nframe()
[17:03:49.517]     ...future.conditions <- base::list()
[17:03:49.517]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:49.517]     if (FALSE) {
[17:03:49.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:49.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:49.517]     }
[17:03:49.517]     ...future.result <- base::tryCatch({
[17:03:49.517]         base::withCallingHandlers({
[17:03:49.517]             ...future.value <- base::withVisible(base::local({
[17:03:49.517]                 ...future.makeSendCondition <- base::local({
[17:03:49.517]                   sendCondition <- NULL
[17:03:49.517]                   function(frame = 1L) {
[17:03:49.517]                     if (is.function(sendCondition)) 
[17:03:49.517]                       return(sendCondition)
[17:03:49.517]                     ns <- getNamespace("parallel")
[17:03:49.517]                     if (exists("sendData", mode = "function", 
[17:03:49.517]                       envir = ns)) {
[17:03:49.517]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:49.517]                         envir = ns)
[17:03:49.517]                       envir <- sys.frame(frame)
[17:03:49.517]                       master <- NULL
[17:03:49.517]                       while (!identical(envir, .GlobalEnv) && 
[17:03:49.517]                         !identical(envir, emptyenv())) {
[17:03:49.517]                         if (exists("master", mode = "list", envir = envir, 
[17:03:49.517]                           inherits = FALSE)) {
[17:03:49.517]                           master <- get("master", mode = "list", 
[17:03:49.517]                             envir = envir, inherits = FALSE)
[17:03:49.517]                           if (inherits(master, c("SOCKnode", 
[17:03:49.517]                             "SOCK0node"))) {
[17:03:49.517]                             sendCondition <<- function(cond) {
[17:03:49.517]                               data <- list(type = "VALUE", value = cond, 
[17:03:49.517]                                 success = TRUE)
[17:03:49.517]                               parallel_sendData(master, data)
[17:03:49.517]                             }
[17:03:49.517]                             return(sendCondition)
[17:03:49.517]                           }
[17:03:49.517]                         }
[17:03:49.517]                         frame <- frame + 1L
[17:03:49.517]                         envir <- sys.frame(frame)
[17:03:49.517]                       }
[17:03:49.517]                     }
[17:03:49.517]                     sendCondition <<- function(cond) NULL
[17:03:49.517]                   }
[17:03:49.517]                 })
[17:03:49.517]                 withCallingHandlers({
[17:03:49.517]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:49.517]                 }, immediateCondition = function(cond) {
[17:03:49.517]                   sendCondition <- ...future.makeSendCondition()
[17:03:49.517]                   sendCondition(cond)
[17:03:49.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.517]                   {
[17:03:49.517]                     inherits <- base::inherits
[17:03:49.517]                     invokeRestart <- base::invokeRestart
[17:03:49.517]                     is.null <- base::is.null
[17:03:49.517]                     muffled <- FALSE
[17:03:49.517]                     if (inherits(cond, "message")) {
[17:03:49.517]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:49.517]                       if (muffled) 
[17:03:49.517]                         invokeRestart("muffleMessage")
[17:03:49.517]                     }
[17:03:49.517]                     else if (inherits(cond, "warning")) {
[17:03:49.517]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:49.517]                       if (muffled) 
[17:03:49.517]                         invokeRestart("muffleWarning")
[17:03:49.517]                     }
[17:03:49.517]                     else if (inherits(cond, "condition")) {
[17:03:49.517]                       if (!is.null(pattern)) {
[17:03:49.517]                         computeRestarts <- base::computeRestarts
[17:03:49.517]                         grepl <- base::grepl
[17:03:49.517]                         restarts <- computeRestarts(cond)
[17:03:49.517]                         for (restart in restarts) {
[17:03:49.517]                           name <- restart$name
[17:03:49.517]                           if (is.null(name)) 
[17:03:49.517]                             next
[17:03:49.517]                           if (!grepl(pattern, name)) 
[17:03:49.517]                             next
[17:03:49.517]                           invokeRestart(restart)
[17:03:49.517]                           muffled <- TRUE
[17:03:49.517]                           break
[17:03:49.517]                         }
[17:03:49.517]                       }
[17:03:49.517]                     }
[17:03:49.517]                     invisible(muffled)
[17:03:49.517]                   }
[17:03:49.517]                   muffleCondition(cond)
[17:03:49.517]                 })
[17:03:49.517]             }))
[17:03:49.517]             future::FutureResult(value = ...future.value$value, 
[17:03:49.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:49.517]                   ...future.rng), globalenv = if (FALSE) 
[17:03:49.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:49.517]                     ...future.globalenv.names))
[17:03:49.517]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:49.517]         }, condition = base::local({
[17:03:49.517]             c <- base::c
[17:03:49.517]             inherits <- base::inherits
[17:03:49.517]             invokeRestart <- base::invokeRestart
[17:03:49.517]             length <- base::length
[17:03:49.517]             list <- base::list
[17:03:49.517]             seq.int <- base::seq.int
[17:03:49.517]             signalCondition <- base::signalCondition
[17:03:49.517]             sys.calls <- base::sys.calls
[17:03:49.517]             `[[` <- base::`[[`
[17:03:49.517]             `+` <- base::`+`
[17:03:49.517]             `<<-` <- base::`<<-`
[17:03:49.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:49.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:49.517]                   3L)]
[17:03:49.517]             }
[17:03:49.517]             function(cond) {
[17:03:49.517]                 is_error <- inherits(cond, "error")
[17:03:49.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:49.517]                   NULL)
[17:03:49.517]                 if (is_error) {
[17:03:49.517]                   sessionInformation <- function() {
[17:03:49.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:49.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:49.517]                       search = base::search(), system = base::Sys.info())
[17:03:49.517]                   }
[17:03:49.517]                   ...future.conditions[[length(...future.conditions) + 
[17:03:49.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:49.517]                     cond$call), session = sessionInformation(), 
[17:03:49.517]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:49.517]                   signalCondition(cond)
[17:03:49.517]                 }
[17:03:49.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:49.517]                 "immediateCondition"))) {
[17:03:49.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:49.517]                   ...future.conditions[[length(...future.conditions) + 
[17:03:49.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:49.517]                   if (TRUE && !signal) {
[17:03:49.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.517]                     {
[17:03:49.517]                       inherits <- base::inherits
[17:03:49.517]                       invokeRestart <- base::invokeRestart
[17:03:49.517]                       is.null <- base::is.null
[17:03:49.517]                       muffled <- FALSE
[17:03:49.517]                       if (inherits(cond, "message")) {
[17:03:49.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:49.517]                         if (muffled) 
[17:03:49.517]                           invokeRestart("muffleMessage")
[17:03:49.517]                       }
[17:03:49.517]                       else if (inherits(cond, "warning")) {
[17:03:49.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:49.517]                         if (muffled) 
[17:03:49.517]                           invokeRestart("muffleWarning")
[17:03:49.517]                       }
[17:03:49.517]                       else if (inherits(cond, "condition")) {
[17:03:49.517]                         if (!is.null(pattern)) {
[17:03:49.517]                           computeRestarts <- base::computeRestarts
[17:03:49.517]                           grepl <- base::grepl
[17:03:49.517]                           restarts <- computeRestarts(cond)
[17:03:49.517]                           for (restart in restarts) {
[17:03:49.517]                             name <- restart$name
[17:03:49.517]                             if (is.null(name)) 
[17:03:49.517]                               next
[17:03:49.517]                             if (!grepl(pattern, name)) 
[17:03:49.517]                               next
[17:03:49.517]                             invokeRestart(restart)
[17:03:49.517]                             muffled <- TRUE
[17:03:49.517]                             break
[17:03:49.517]                           }
[17:03:49.517]                         }
[17:03:49.517]                       }
[17:03:49.517]                       invisible(muffled)
[17:03:49.517]                     }
[17:03:49.517]                     muffleCondition(cond, pattern = "^muffle")
[17:03:49.517]                   }
[17:03:49.517]                 }
[17:03:49.517]                 else {
[17:03:49.517]                   if (TRUE) {
[17:03:49.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.517]                     {
[17:03:49.517]                       inherits <- base::inherits
[17:03:49.517]                       invokeRestart <- base::invokeRestart
[17:03:49.517]                       is.null <- base::is.null
[17:03:49.517]                       muffled <- FALSE
[17:03:49.517]                       if (inherits(cond, "message")) {
[17:03:49.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:49.517]                         if (muffled) 
[17:03:49.517]                           invokeRestart("muffleMessage")
[17:03:49.517]                       }
[17:03:49.517]                       else if (inherits(cond, "warning")) {
[17:03:49.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:49.517]                         if (muffled) 
[17:03:49.517]                           invokeRestart("muffleWarning")
[17:03:49.517]                       }
[17:03:49.517]                       else if (inherits(cond, "condition")) {
[17:03:49.517]                         if (!is.null(pattern)) {
[17:03:49.517]                           computeRestarts <- base::computeRestarts
[17:03:49.517]                           grepl <- base::grepl
[17:03:49.517]                           restarts <- computeRestarts(cond)
[17:03:49.517]                           for (restart in restarts) {
[17:03:49.517]                             name <- restart$name
[17:03:49.517]                             if (is.null(name)) 
[17:03:49.517]                               next
[17:03:49.517]                             if (!grepl(pattern, name)) 
[17:03:49.517]                               next
[17:03:49.517]                             invokeRestart(restart)
[17:03:49.517]                             muffled <- TRUE
[17:03:49.517]                             break
[17:03:49.517]                           }
[17:03:49.517]                         }
[17:03:49.517]                       }
[17:03:49.517]                       invisible(muffled)
[17:03:49.517]                     }
[17:03:49.517]                     muffleCondition(cond, pattern = "^muffle")
[17:03:49.517]                   }
[17:03:49.517]                 }
[17:03:49.517]             }
[17:03:49.517]         }))
[17:03:49.517]     }, error = function(ex) {
[17:03:49.517]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:49.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:49.517]                 ...future.rng), started = ...future.startTime, 
[17:03:49.517]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:49.517]             version = "1.8"), class = "FutureResult")
[17:03:49.517]     }, finally = {
[17:03:49.517]         if (!identical(...future.workdir, getwd())) 
[17:03:49.517]             setwd(...future.workdir)
[17:03:49.517]         {
[17:03:49.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:49.517]                 ...future.oldOptions$nwarnings <- NULL
[17:03:49.517]             }
[17:03:49.517]             base::options(...future.oldOptions)
[17:03:49.517]             if (.Platform$OS.type == "windows") {
[17:03:49.517]                 old_names <- names(...future.oldEnvVars)
[17:03:49.517]                 envs <- base::Sys.getenv()
[17:03:49.517]                 names <- names(envs)
[17:03:49.517]                 common <- intersect(names, old_names)
[17:03:49.517]                 added <- setdiff(names, old_names)
[17:03:49.517]                 removed <- setdiff(old_names, names)
[17:03:49.517]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:49.517]                   envs[common]]
[17:03:49.517]                 NAMES <- toupper(changed)
[17:03:49.517]                 args <- list()
[17:03:49.517]                 for (kk in seq_along(NAMES)) {
[17:03:49.517]                   name <- changed[[kk]]
[17:03:49.517]                   NAME <- NAMES[[kk]]
[17:03:49.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.517]                     next
[17:03:49.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:49.517]                 }
[17:03:49.517]                 NAMES <- toupper(added)
[17:03:49.517]                 for (kk in seq_along(NAMES)) {
[17:03:49.517]                   name <- added[[kk]]
[17:03:49.517]                   NAME <- NAMES[[kk]]
[17:03:49.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.517]                     next
[17:03:49.517]                   args[[name]] <- ""
[17:03:49.517]                 }
[17:03:49.517]                 NAMES <- toupper(removed)
[17:03:49.517]                 for (kk in seq_along(NAMES)) {
[17:03:49.517]                   name <- removed[[kk]]
[17:03:49.517]                   NAME <- NAMES[[kk]]
[17:03:49.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.517]                     next
[17:03:49.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:49.517]                 }
[17:03:49.517]                 if (length(args) > 0) 
[17:03:49.517]                   base::do.call(base::Sys.setenv, args = args)
[17:03:49.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:49.517]             }
[17:03:49.517]             else {
[17:03:49.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:49.517]             }
[17:03:49.517]             {
[17:03:49.517]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:49.517]                   0L) {
[17:03:49.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:49.517]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:49.517]                   base::options(opts)
[17:03:49.517]                 }
[17:03:49.517]                 {
[17:03:49.517]                   {
[17:03:49.517]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:49.517]                     NULL
[17:03:49.517]                   }
[17:03:49.517]                   options(future.plan = NULL)
[17:03:49.517]                   if (is.na(NA_character_)) 
[17:03:49.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:49.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:49.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:49.517]                     .init = FALSE)
[17:03:49.517]                 }
[17:03:49.517]             }
[17:03:49.517]         }
[17:03:49.517]     })
[17:03:49.517]     if (TRUE) {
[17:03:49.517]         base::sink(type = "output", split = FALSE)
[17:03:49.517]         if (TRUE) {
[17:03:49.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:49.517]         }
[17:03:49.517]         else {
[17:03:49.517]             ...future.result["stdout"] <- base::list(NULL)
[17:03:49.517]         }
[17:03:49.517]         base::close(...future.stdout)
[17:03:49.517]         ...future.stdout <- NULL
[17:03:49.517]     }
[17:03:49.517]     ...future.result$conditions <- ...future.conditions
[17:03:49.517]     ...future.result$finished <- base::Sys.time()
[17:03:49.517]     ...future.result
[17:03:49.517] }
[17:03:49.520] MultisessionFuture started
[17:03:49.520] - Launch lazy future ... done
[17:03:49.520] run() for ‘MultisessionFuture’ ... done
[17:03:49.522] receiveMessageFromWorker() for ClusterFuture ...
[17:03:49.522] - Validating connection of MultisessionFuture
[17:03:49.522] - received message: FutureResult
[17:03:49.522] - Received FutureResult
[17:03:49.522] - Erased future from FutureRegistry
[17:03:49.522] result() for ClusterFuture ...
[17:03:49.522] - result already collected: FutureResult
[17:03:49.523] result() for ClusterFuture ... done
[17:03:49.523] signalConditions() ...
[17:03:49.523]  - include = ‘immediateCondition’
[17:03:49.523]  - exclude = 
[17:03:49.523]  - resignal = FALSE
[17:03:49.523]  - Number of conditions: 1
[17:03:49.523] signalConditions() ... done
[17:03:49.523] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:49.523] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[17:03:49.524] getGlobalsAndPackages() ...
[17:03:49.524] Searching for globals...
[17:03:49.525] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:49.525] Searching for globals ... DONE
[17:03:49.525] Resolving globals: FALSE
[17:03:49.525] 
[17:03:49.525] 
[17:03:49.525] getGlobalsAndPackages() ... DONE
[17:03:49.526] run() for ‘Future’ ...
[17:03:49.526] - state: ‘created’
[17:03:49.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:49.540] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:49.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:49.540]   - Field: ‘node’
[17:03:49.540]   - Field: ‘label’
[17:03:49.540]   - Field: ‘local’
[17:03:49.540]   - Field: ‘owner’
[17:03:49.540]   - Field: ‘envir’
[17:03:49.541]   - Field: ‘workers’
[17:03:49.541]   - Field: ‘packages’
[17:03:49.541]   - Field: ‘gc’
[17:03:49.541]   - Field: ‘conditions’
[17:03:49.541]   - Field: ‘persistent’
[17:03:49.541]   - Field: ‘expr’
[17:03:49.541]   - Field: ‘uuid’
[17:03:49.541]   - Field: ‘seed’
[17:03:49.541]   - Field: ‘version’
[17:03:49.541]   - Field: ‘result’
[17:03:49.541]   - Field: ‘asynchronous’
[17:03:49.541]   - Field: ‘calls’
[17:03:49.542]   - Field: ‘globals’
[17:03:49.542]   - Field: ‘stdout’
[17:03:49.542]   - Field: ‘earlySignal’
[17:03:49.542]   - Field: ‘lazy’
[17:03:49.542]   - Field: ‘state’
[17:03:49.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:49.542] - Launch lazy future ...
[17:03:49.542] Packages needed by the future expression (n = 0): <none>
[17:03:49.542] Packages needed by future strategies (n = 0): <none>
[17:03:49.543] {
[17:03:49.543]     {
[17:03:49.543]         {
[17:03:49.543]             ...future.startTime <- base::Sys.time()
[17:03:49.543]             {
[17:03:49.543]                 {
[17:03:49.543]                   {
[17:03:49.543]                     {
[17:03:49.543]                       base::local({
[17:03:49.543]                         has_future <- base::requireNamespace("future", 
[17:03:49.543]                           quietly = TRUE)
[17:03:49.543]                         if (has_future) {
[17:03:49.543]                           ns <- base::getNamespace("future")
[17:03:49.543]                           version <- ns[[".package"]][["version"]]
[17:03:49.543]                           if (is.null(version)) 
[17:03:49.543]                             version <- utils::packageVersion("future")
[17:03:49.543]                         }
[17:03:49.543]                         else {
[17:03:49.543]                           version <- NULL
[17:03:49.543]                         }
[17:03:49.543]                         if (!has_future || version < "1.8.0") {
[17:03:49.543]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:49.543]                             "", base::R.version$version.string), 
[17:03:49.543]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:49.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:49.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:49.543]                               "release", "version")], collapse = " "), 
[17:03:49.543]                             hostname = base::Sys.info()[["nodename"]])
[17:03:49.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:49.543]                             info)
[17:03:49.543]                           info <- base::paste(info, collapse = "; ")
[17:03:49.543]                           if (!has_future) {
[17:03:49.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:49.543]                               info)
[17:03:49.543]                           }
[17:03:49.543]                           else {
[17:03:49.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:49.543]                               info, version)
[17:03:49.543]                           }
[17:03:49.543]                           base::stop(msg)
[17:03:49.543]                         }
[17:03:49.543]                       })
[17:03:49.543]                     }
[17:03:49.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:49.543]                     base::options(mc.cores = 1L)
[17:03:49.543]                   }
[17:03:49.543]                   ...future.strategy.old <- future::plan("list")
[17:03:49.543]                   options(future.plan = NULL)
[17:03:49.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:49.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:49.543]                 }
[17:03:49.543]                 ...future.workdir <- getwd()
[17:03:49.543]             }
[17:03:49.543]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:49.543]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:49.543]         }
[17:03:49.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:49.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:49.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:49.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:49.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:49.543]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:49.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:49.543]             base::names(...future.oldOptions))
[17:03:49.543]     }
[17:03:49.543]     if (FALSE) {
[17:03:49.543]     }
[17:03:49.543]     else {
[17:03:49.543]         if (TRUE) {
[17:03:49.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:49.543]                 open = "w")
[17:03:49.543]         }
[17:03:49.543]         else {
[17:03:49.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:49.543]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:49.543]         }
[17:03:49.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:49.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:49.543]             base::sink(type = "output", split = FALSE)
[17:03:49.543]             base::close(...future.stdout)
[17:03:49.543]         }, add = TRUE)
[17:03:49.543]     }
[17:03:49.543]     ...future.frame <- base::sys.nframe()
[17:03:49.543]     ...future.conditions <- base::list()
[17:03:49.543]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:49.543]     if (FALSE) {
[17:03:49.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:49.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:49.543]     }
[17:03:49.543]     ...future.result <- base::tryCatch({
[17:03:49.543]         base::withCallingHandlers({
[17:03:49.543]             ...future.value <- base::withVisible(base::local({
[17:03:49.543]                 ...future.makeSendCondition <- base::local({
[17:03:49.543]                   sendCondition <- NULL
[17:03:49.543]                   function(frame = 1L) {
[17:03:49.543]                     if (is.function(sendCondition)) 
[17:03:49.543]                       return(sendCondition)
[17:03:49.543]                     ns <- getNamespace("parallel")
[17:03:49.543]                     if (exists("sendData", mode = "function", 
[17:03:49.543]                       envir = ns)) {
[17:03:49.543]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:49.543]                         envir = ns)
[17:03:49.543]                       envir <- sys.frame(frame)
[17:03:49.543]                       master <- NULL
[17:03:49.543]                       while (!identical(envir, .GlobalEnv) && 
[17:03:49.543]                         !identical(envir, emptyenv())) {
[17:03:49.543]                         if (exists("master", mode = "list", envir = envir, 
[17:03:49.543]                           inherits = FALSE)) {
[17:03:49.543]                           master <- get("master", mode = "list", 
[17:03:49.543]                             envir = envir, inherits = FALSE)
[17:03:49.543]                           if (inherits(master, c("SOCKnode", 
[17:03:49.543]                             "SOCK0node"))) {
[17:03:49.543]                             sendCondition <<- function(cond) {
[17:03:49.543]                               data <- list(type = "VALUE", value = cond, 
[17:03:49.543]                                 success = TRUE)
[17:03:49.543]                               parallel_sendData(master, data)
[17:03:49.543]                             }
[17:03:49.543]                             return(sendCondition)
[17:03:49.543]                           }
[17:03:49.543]                         }
[17:03:49.543]                         frame <- frame + 1L
[17:03:49.543]                         envir <- sys.frame(frame)
[17:03:49.543]                       }
[17:03:49.543]                     }
[17:03:49.543]                     sendCondition <<- function(cond) NULL
[17:03:49.543]                   }
[17:03:49.543]                 })
[17:03:49.543]                 withCallingHandlers({
[17:03:49.543]                   {
[17:03:49.543]                     Sys.sleep(0.5)
[17:03:49.543]                     list(a = 1, b = 42L)
[17:03:49.543]                   }
[17:03:49.543]                 }, immediateCondition = function(cond) {
[17:03:49.543]                   sendCondition <- ...future.makeSendCondition()
[17:03:49.543]                   sendCondition(cond)
[17:03:49.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.543]                   {
[17:03:49.543]                     inherits <- base::inherits
[17:03:49.543]                     invokeRestart <- base::invokeRestart
[17:03:49.543]                     is.null <- base::is.null
[17:03:49.543]                     muffled <- FALSE
[17:03:49.543]                     if (inherits(cond, "message")) {
[17:03:49.543]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:49.543]                       if (muffled) 
[17:03:49.543]                         invokeRestart("muffleMessage")
[17:03:49.543]                     }
[17:03:49.543]                     else if (inherits(cond, "warning")) {
[17:03:49.543]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:49.543]                       if (muffled) 
[17:03:49.543]                         invokeRestart("muffleWarning")
[17:03:49.543]                     }
[17:03:49.543]                     else if (inherits(cond, "condition")) {
[17:03:49.543]                       if (!is.null(pattern)) {
[17:03:49.543]                         computeRestarts <- base::computeRestarts
[17:03:49.543]                         grepl <- base::grepl
[17:03:49.543]                         restarts <- computeRestarts(cond)
[17:03:49.543]                         for (restart in restarts) {
[17:03:49.543]                           name <- restart$name
[17:03:49.543]                           if (is.null(name)) 
[17:03:49.543]                             next
[17:03:49.543]                           if (!grepl(pattern, name)) 
[17:03:49.543]                             next
[17:03:49.543]                           invokeRestart(restart)
[17:03:49.543]                           muffled <- TRUE
[17:03:49.543]                           break
[17:03:49.543]                         }
[17:03:49.543]                       }
[17:03:49.543]                     }
[17:03:49.543]                     invisible(muffled)
[17:03:49.543]                   }
[17:03:49.543]                   muffleCondition(cond)
[17:03:49.543]                 })
[17:03:49.543]             }))
[17:03:49.543]             future::FutureResult(value = ...future.value$value, 
[17:03:49.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:49.543]                   ...future.rng), globalenv = if (FALSE) 
[17:03:49.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:49.543]                     ...future.globalenv.names))
[17:03:49.543]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:49.543]         }, condition = base::local({
[17:03:49.543]             c <- base::c
[17:03:49.543]             inherits <- base::inherits
[17:03:49.543]             invokeRestart <- base::invokeRestart
[17:03:49.543]             length <- base::length
[17:03:49.543]             list <- base::list
[17:03:49.543]             seq.int <- base::seq.int
[17:03:49.543]             signalCondition <- base::signalCondition
[17:03:49.543]             sys.calls <- base::sys.calls
[17:03:49.543]             `[[` <- base::`[[`
[17:03:49.543]             `+` <- base::`+`
[17:03:49.543]             `<<-` <- base::`<<-`
[17:03:49.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:49.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:49.543]                   3L)]
[17:03:49.543]             }
[17:03:49.543]             function(cond) {
[17:03:49.543]                 is_error <- inherits(cond, "error")
[17:03:49.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:49.543]                   NULL)
[17:03:49.543]                 if (is_error) {
[17:03:49.543]                   sessionInformation <- function() {
[17:03:49.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:49.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:49.543]                       search = base::search(), system = base::Sys.info())
[17:03:49.543]                   }
[17:03:49.543]                   ...future.conditions[[length(...future.conditions) + 
[17:03:49.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:49.543]                     cond$call), session = sessionInformation(), 
[17:03:49.543]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:49.543]                   signalCondition(cond)
[17:03:49.543]                 }
[17:03:49.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:49.543]                 "immediateCondition"))) {
[17:03:49.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:49.543]                   ...future.conditions[[length(...future.conditions) + 
[17:03:49.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:49.543]                   if (TRUE && !signal) {
[17:03:49.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.543]                     {
[17:03:49.543]                       inherits <- base::inherits
[17:03:49.543]                       invokeRestart <- base::invokeRestart
[17:03:49.543]                       is.null <- base::is.null
[17:03:49.543]                       muffled <- FALSE
[17:03:49.543]                       if (inherits(cond, "message")) {
[17:03:49.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:49.543]                         if (muffled) 
[17:03:49.543]                           invokeRestart("muffleMessage")
[17:03:49.543]                       }
[17:03:49.543]                       else if (inherits(cond, "warning")) {
[17:03:49.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:49.543]                         if (muffled) 
[17:03:49.543]                           invokeRestart("muffleWarning")
[17:03:49.543]                       }
[17:03:49.543]                       else if (inherits(cond, "condition")) {
[17:03:49.543]                         if (!is.null(pattern)) {
[17:03:49.543]                           computeRestarts <- base::computeRestarts
[17:03:49.543]                           grepl <- base::grepl
[17:03:49.543]                           restarts <- computeRestarts(cond)
[17:03:49.543]                           for (restart in restarts) {
[17:03:49.543]                             name <- restart$name
[17:03:49.543]                             if (is.null(name)) 
[17:03:49.543]                               next
[17:03:49.543]                             if (!grepl(pattern, name)) 
[17:03:49.543]                               next
[17:03:49.543]                             invokeRestart(restart)
[17:03:49.543]                             muffled <- TRUE
[17:03:49.543]                             break
[17:03:49.543]                           }
[17:03:49.543]                         }
[17:03:49.543]                       }
[17:03:49.543]                       invisible(muffled)
[17:03:49.543]                     }
[17:03:49.543]                     muffleCondition(cond, pattern = "^muffle")
[17:03:49.543]                   }
[17:03:49.543]                 }
[17:03:49.543]                 else {
[17:03:49.543]                   if (TRUE) {
[17:03:49.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:49.543]                     {
[17:03:49.543]                       inherits <- base::inherits
[17:03:49.543]                       invokeRestart <- base::invokeRestart
[17:03:49.543]                       is.null <- base::is.null
[17:03:49.543]                       muffled <- FALSE
[17:03:49.543]                       if (inherits(cond, "message")) {
[17:03:49.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:49.543]                         if (muffled) 
[17:03:49.543]                           invokeRestart("muffleMessage")
[17:03:49.543]                       }
[17:03:49.543]                       else if (inherits(cond, "warning")) {
[17:03:49.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:49.543]                         if (muffled) 
[17:03:49.543]                           invokeRestart("muffleWarning")
[17:03:49.543]                       }
[17:03:49.543]                       else if (inherits(cond, "condition")) {
[17:03:49.543]                         if (!is.null(pattern)) {
[17:03:49.543]                           computeRestarts <- base::computeRestarts
[17:03:49.543]                           grepl <- base::grepl
[17:03:49.543]                           restarts <- computeRestarts(cond)
[17:03:49.543]                           for (restart in restarts) {
[17:03:49.543]                             name <- restart$name
[17:03:49.543]                             if (is.null(name)) 
[17:03:49.543]                               next
[17:03:49.543]                             if (!grepl(pattern, name)) 
[17:03:49.543]                               next
[17:03:49.543]                             invokeRestart(restart)
[17:03:49.543]                             muffled <- TRUE
[17:03:49.543]                             break
[17:03:49.543]                           }
[17:03:49.543]                         }
[17:03:49.543]                       }
[17:03:49.543]                       invisible(muffled)
[17:03:49.543]                     }
[17:03:49.543]                     muffleCondition(cond, pattern = "^muffle")
[17:03:49.543]                   }
[17:03:49.543]                 }
[17:03:49.543]             }
[17:03:49.543]         }))
[17:03:49.543]     }, error = function(ex) {
[17:03:49.543]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:49.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:49.543]                 ...future.rng), started = ...future.startTime, 
[17:03:49.543]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:49.543]             version = "1.8"), class = "FutureResult")
[17:03:49.543]     }, finally = {
[17:03:49.543]         if (!identical(...future.workdir, getwd())) 
[17:03:49.543]             setwd(...future.workdir)
[17:03:49.543]         {
[17:03:49.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:49.543]                 ...future.oldOptions$nwarnings <- NULL
[17:03:49.543]             }
[17:03:49.543]             base::options(...future.oldOptions)
[17:03:49.543]             if (.Platform$OS.type == "windows") {
[17:03:49.543]                 old_names <- names(...future.oldEnvVars)
[17:03:49.543]                 envs <- base::Sys.getenv()
[17:03:49.543]                 names <- names(envs)
[17:03:49.543]                 common <- intersect(names, old_names)
[17:03:49.543]                 added <- setdiff(names, old_names)
[17:03:49.543]                 removed <- setdiff(old_names, names)
[17:03:49.543]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:49.543]                   envs[common]]
[17:03:49.543]                 NAMES <- toupper(changed)
[17:03:49.543]                 args <- list()
[17:03:49.543]                 for (kk in seq_along(NAMES)) {
[17:03:49.543]                   name <- changed[[kk]]
[17:03:49.543]                   NAME <- NAMES[[kk]]
[17:03:49.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.543]                     next
[17:03:49.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:49.543]                 }
[17:03:49.543]                 NAMES <- toupper(added)
[17:03:49.543]                 for (kk in seq_along(NAMES)) {
[17:03:49.543]                   name <- added[[kk]]
[17:03:49.543]                   NAME <- NAMES[[kk]]
[17:03:49.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.543]                     next
[17:03:49.543]                   args[[name]] <- ""
[17:03:49.543]                 }
[17:03:49.543]                 NAMES <- toupper(removed)
[17:03:49.543]                 for (kk in seq_along(NAMES)) {
[17:03:49.543]                   name <- removed[[kk]]
[17:03:49.543]                   NAME <- NAMES[[kk]]
[17:03:49.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:49.543]                     next
[17:03:49.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:49.543]                 }
[17:03:49.543]                 if (length(args) > 0) 
[17:03:49.543]                   base::do.call(base::Sys.setenv, args = args)
[17:03:49.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:49.543]             }
[17:03:49.543]             else {
[17:03:49.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:49.543]             }
[17:03:49.543]             {
[17:03:49.543]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:49.543]                   0L) {
[17:03:49.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:49.543]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:49.543]                   base::options(opts)
[17:03:49.543]                 }
[17:03:49.543]                 {
[17:03:49.543]                   {
[17:03:49.543]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:49.543]                     NULL
[17:03:49.543]                   }
[17:03:49.543]                   options(future.plan = NULL)
[17:03:49.543]                   if (is.na(NA_character_)) 
[17:03:49.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:49.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:49.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:49.543]                     .init = FALSE)
[17:03:49.543]                 }
[17:03:49.543]             }
[17:03:49.543]         }
[17:03:49.543]     })
[17:03:49.543]     if (TRUE) {
[17:03:49.543]         base::sink(type = "output", split = FALSE)
[17:03:49.543]         if (TRUE) {
[17:03:49.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:49.543]         }
[17:03:49.543]         else {
[17:03:49.543]             ...future.result["stdout"] <- base::list(NULL)
[17:03:49.543]         }
[17:03:49.543]         base::close(...future.stdout)
[17:03:49.543]         ...future.stdout <- NULL
[17:03:49.543]     }
[17:03:49.543]     ...future.result$conditions <- ...future.conditions
[17:03:49.543]     ...future.result$finished <- base::Sys.time()
[17:03:49.543]     ...future.result
[17:03:49.543] }
[17:03:49.546] MultisessionFuture started
[17:03:49.546] - Launch lazy future ... done
[17:03:49.546] run() for ‘MultisessionFuture’ ... done
[17:03:50.048] receiveMessageFromWorker() for ClusterFuture ...
[17:03:50.048] - Validating connection of MultisessionFuture
[17:03:50.049] - received message: FutureResult
[17:03:50.049] - Received FutureResult
[17:03:50.049] - Erased future from FutureRegistry
[17:03:50.049] result() for ClusterFuture ...
[17:03:50.049] - result already collected: FutureResult
[17:03:50.049] result() for ClusterFuture ... done
[17:03:50.049] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:50.049] resolve() on list ...
[17:03:50.050]  recursive: 98
[17:03:50.050]  length: 2
[17:03:50.050]  elements: ‘a’, ‘b’
[17:03:50.050]  length: 1 (resolved future 1)
[17:03:50.050]  length: 0 (resolved future 2)
[17:03:50.050] resolve() on list ... DONE
[17:03:50.050] A MultisessionFuture was resolved (and resolved itself)
[17:03:50.050] getGlobalsAndPackages() ...
[17:03:50.050] Searching for globals...
[17:03:50.051] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:50.052] Searching for globals ... DONE
[17:03:50.052] Resolving globals: FALSE
[17:03:50.052] 
[17:03:50.052] 
[17:03:50.052] getGlobalsAndPackages() ... DONE
[17:03:50.052] run() for ‘Future’ ...
[17:03:50.053] - state: ‘created’
[17:03:50.053] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:50.066] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:50.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:50.067]   - Field: ‘node’
[17:03:50.067]   - Field: ‘label’
[17:03:50.067]   - Field: ‘local’
[17:03:50.067]   - Field: ‘owner’
[17:03:50.067]   - Field: ‘envir’
[17:03:50.067]   - Field: ‘workers’
[17:03:50.067]   - Field: ‘packages’
[17:03:50.067]   - Field: ‘gc’
[17:03:50.068]   - Field: ‘conditions’
[17:03:50.068]   - Field: ‘persistent’
[17:03:50.068]   - Field: ‘expr’
[17:03:50.068]   - Field: ‘uuid’
[17:03:50.068]   - Field: ‘seed’
[17:03:50.068]   - Field: ‘version’
[17:03:50.068]   - Field: ‘result’
[17:03:50.068]   - Field: ‘asynchronous’
[17:03:50.068]   - Field: ‘calls’
[17:03:50.068]   - Field: ‘globals’
[17:03:50.068]   - Field: ‘stdout’
[17:03:50.069]   - Field: ‘earlySignal’
[17:03:50.069]   - Field: ‘lazy’
[17:03:50.069]   - Field: ‘state’
[17:03:50.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:50.069] - Launch lazy future ...
[17:03:50.069] Packages needed by the future expression (n = 0): <none>
[17:03:50.069] Packages needed by future strategies (n = 0): <none>
[17:03:50.070] {
[17:03:50.070]     {
[17:03:50.070]         {
[17:03:50.070]             ...future.startTime <- base::Sys.time()
[17:03:50.070]             {
[17:03:50.070]                 {
[17:03:50.070]                   {
[17:03:50.070]                     {
[17:03:50.070]                       base::local({
[17:03:50.070]                         has_future <- base::requireNamespace("future", 
[17:03:50.070]                           quietly = TRUE)
[17:03:50.070]                         if (has_future) {
[17:03:50.070]                           ns <- base::getNamespace("future")
[17:03:50.070]                           version <- ns[[".package"]][["version"]]
[17:03:50.070]                           if (is.null(version)) 
[17:03:50.070]                             version <- utils::packageVersion("future")
[17:03:50.070]                         }
[17:03:50.070]                         else {
[17:03:50.070]                           version <- NULL
[17:03:50.070]                         }
[17:03:50.070]                         if (!has_future || version < "1.8.0") {
[17:03:50.070]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:50.070]                             "", base::R.version$version.string), 
[17:03:50.070]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:50.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:50.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:50.070]                               "release", "version")], collapse = " "), 
[17:03:50.070]                             hostname = base::Sys.info()[["nodename"]])
[17:03:50.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:50.070]                             info)
[17:03:50.070]                           info <- base::paste(info, collapse = "; ")
[17:03:50.070]                           if (!has_future) {
[17:03:50.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:50.070]                               info)
[17:03:50.070]                           }
[17:03:50.070]                           else {
[17:03:50.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:50.070]                               info, version)
[17:03:50.070]                           }
[17:03:50.070]                           base::stop(msg)
[17:03:50.070]                         }
[17:03:50.070]                       })
[17:03:50.070]                     }
[17:03:50.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:50.070]                     base::options(mc.cores = 1L)
[17:03:50.070]                   }
[17:03:50.070]                   ...future.strategy.old <- future::plan("list")
[17:03:50.070]                   options(future.plan = NULL)
[17:03:50.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:50.070]                 }
[17:03:50.070]                 ...future.workdir <- getwd()
[17:03:50.070]             }
[17:03:50.070]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:50.070]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:50.070]         }
[17:03:50.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:50.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:50.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:50.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:50.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:50.070]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:50.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:50.070]             base::names(...future.oldOptions))
[17:03:50.070]     }
[17:03:50.070]     if (FALSE) {
[17:03:50.070]     }
[17:03:50.070]     else {
[17:03:50.070]         if (TRUE) {
[17:03:50.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:50.070]                 open = "w")
[17:03:50.070]         }
[17:03:50.070]         else {
[17:03:50.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:50.070]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:50.070]         }
[17:03:50.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:50.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:50.070]             base::sink(type = "output", split = FALSE)
[17:03:50.070]             base::close(...future.stdout)
[17:03:50.070]         }, add = TRUE)
[17:03:50.070]     }
[17:03:50.070]     ...future.frame <- base::sys.nframe()
[17:03:50.070]     ...future.conditions <- base::list()
[17:03:50.070]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:50.070]     if (FALSE) {
[17:03:50.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:50.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:50.070]     }
[17:03:50.070]     ...future.result <- base::tryCatch({
[17:03:50.070]         base::withCallingHandlers({
[17:03:50.070]             ...future.value <- base::withVisible(base::local({
[17:03:50.070]                 ...future.makeSendCondition <- base::local({
[17:03:50.070]                   sendCondition <- NULL
[17:03:50.070]                   function(frame = 1L) {
[17:03:50.070]                     if (is.function(sendCondition)) 
[17:03:50.070]                       return(sendCondition)
[17:03:50.070]                     ns <- getNamespace("parallel")
[17:03:50.070]                     if (exists("sendData", mode = "function", 
[17:03:50.070]                       envir = ns)) {
[17:03:50.070]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:50.070]                         envir = ns)
[17:03:50.070]                       envir <- sys.frame(frame)
[17:03:50.070]                       master <- NULL
[17:03:50.070]                       while (!identical(envir, .GlobalEnv) && 
[17:03:50.070]                         !identical(envir, emptyenv())) {
[17:03:50.070]                         if (exists("master", mode = "list", envir = envir, 
[17:03:50.070]                           inherits = FALSE)) {
[17:03:50.070]                           master <- get("master", mode = "list", 
[17:03:50.070]                             envir = envir, inherits = FALSE)
[17:03:50.070]                           if (inherits(master, c("SOCKnode", 
[17:03:50.070]                             "SOCK0node"))) {
[17:03:50.070]                             sendCondition <<- function(cond) {
[17:03:50.070]                               data <- list(type = "VALUE", value = cond, 
[17:03:50.070]                                 success = TRUE)
[17:03:50.070]                               parallel_sendData(master, data)
[17:03:50.070]                             }
[17:03:50.070]                             return(sendCondition)
[17:03:50.070]                           }
[17:03:50.070]                         }
[17:03:50.070]                         frame <- frame + 1L
[17:03:50.070]                         envir <- sys.frame(frame)
[17:03:50.070]                       }
[17:03:50.070]                     }
[17:03:50.070]                     sendCondition <<- function(cond) NULL
[17:03:50.070]                   }
[17:03:50.070]                 })
[17:03:50.070]                 withCallingHandlers({
[17:03:50.070]                   {
[17:03:50.070]                     Sys.sleep(0.5)
[17:03:50.070]                     list(a = 1, b = 42L)
[17:03:50.070]                   }
[17:03:50.070]                 }, immediateCondition = function(cond) {
[17:03:50.070]                   sendCondition <- ...future.makeSendCondition()
[17:03:50.070]                   sendCondition(cond)
[17:03:50.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.070]                   {
[17:03:50.070]                     inherits <- base::inherits
[17:03:50.070]                     invokeRestart <- base::invokeRestart
[17:03:50.070]                     is.null <- base::is.null
[17:03:50.070]                     muffled <- FALSE
[17:03:50.070]                     if (inherits(cond, "message")) {
[17:03:50.070]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:50.070]                       if (muffled) 
[17:03:50.070]                         invokeRestart("muffleMessage")
[17:03:50.070]                     }
[17:03:50.070]                     else if (inherits(cond, "warning")) {
[17:03:50.070]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:50.070]                       if (muffled) 
[17:03:50.070]                         invokeRestart("muffleWarning")
[17:03:50.070]                     }
[17:03:50.070]                     else if (inherits(cond, "condition")) {
[17:03:50.070]                       if (!is.null(pattern)) {
[17:03:50.070]                         computeRestarts <- base::computeRestarts
[17:03:50.070]                         grepl <- base::grepl
[17:03:50.070]                         restarts <- computeRestarts(cond)
[17:03:50.070]                         for (restart in restarts) {
[17:03:50.070]                           name <- restart$name
[17:03:50.070]                           if (is.null(name)) 
[17:03:50.070]                             next
[17:03:50.070]                           if (!grepl(pattern, name)) 
[17:03:50.070]                             next
[17:03:50.070]                           invokeRestart(restart)
[17:03:50.070]                           muffled <- TRUE
[17:03:50.070]                           break
[17:03:50.070]                         }
[17:03:50.070]                       }
[17:03:50.070]                     }
[17:03:50.070]                     invisible(muffled)
[17:03:50.070]                   }
[17:03:50.070]                   muffleCondition(cond)
[17:03:50.070]                 })
[17:03:50.070]             }))
[17:03:50.070]             future::FutureResult(value = ...future.value$value, 
[17:03:50.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.070]                   ...future.rng), globalenv = if (FALSE) 
[17:03:50.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:50.070]                     ...future.globalenv.names))
[17:03:50.070]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:50.070]         }, condition = base::local({
[17:03:50.070]             c <- base::c
[17:03:50.070]             inherits <- base::inherits
[17:03:50.070]             invokeRestart <- base::invokeRestart
[17:03:50.070]             length <- base::length
[17:03:50.070]             list <- base::list
[17:03:50.070]             seq.int <- base::seq.int
[17:03:50.070]             signalCondition <- base::signalCondition
[17:03:50.070]             sys.calls <- base::sys.calls
[17:03:50.070]             `[[` <- base::`[[`
[17:03:50.070]             `+` <- base::`+`
[17:03:50.070]             `<<-` <- base::`<<-`
[17:03:50.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:50.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:50.070]                   3L)]
[17:03:50.070]             }
[17:03:50.070]             function(cond) {
[17:03:50.070]                 is_error <- inherits(cond, "error")
[17:03:50.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:50.070]                   NULL)
[17:03:50.070]                 if (is_error) {
[17:03:50.070]                   sessionInformation <- function() {
[17:03:50.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:50.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:50.070]                       search = base::search(), system = base::Sys.info())
[17:03:50.070]                   }
[17:03:50.070]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:50.070]                     cond$call), session = sessionInformation(), 
[17:03:50.070]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:50.070]                   signalCondition(cond)
[17:03:50.070]                 }
[17:03:50.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:50.070]                 "immediateCondition"))) {
[17:03:50.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:50.070]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:50.070]                   if (TRUE && !signal) {
[17:03:50.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.070]                     {
[17:03:50.070]                       inherits <- base::inherits
[17:03:50.070]                       invokeRestart <- base::invokeRestart
[17:03:50.070]                       is.null <- base::is.null
[17:03:50.070]                       muffled <- FALSE
[17:03:50.070]                       if (inherits(cond, "message")) {
[17:03:50.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.070]                         if (muffled) 
[17:03:50.070]                           invokeRestart("muffleMessage")
[17:03:50.070]                       }
[17:03:50.070]                       else if (inherits(cond, "warning")) {
[17:03:50.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.070]                         if (muffled) 
[17:03:50.070]                           invokeRestart("muffleWarning")
[17:03:50.070]                       }
[17:03:50.070]                       else if (inherits(cond, "condition")) {
[17:03:50.070]                         if (!is.null(pattern)) {
[17:03:50.070]                           computeRestarts <- base::computeRestarts
[17:03:50.070]                           grepl <- base::grepl
[17:03:50.070]                           restarts <- computeRestarts(cond)
[17:03:50.070]                           for (restart in restarts) {
[17:03:50.070]                             name <- restart$name
[17:03:50.070]                             if (is.null(name)) 
[17:03:50.070]                               next
[17:03:50.070]                             if (!grepl(pattern, name)) 
[17:03:50.070]                               next
[17:03:50.070]                             invokeRestart(restart)
[17:03:50.070]                             muffled <- TRUE
[17:03:50.070]                             break
[17:03:50.070]                           }
[17:03:50.070]                         }
[17:03:50.070]                       }
[17:03:50.070]                       invisible(muffled)
[17:03:50.070]                     }
[17:03:50.070]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.070]                   }
[17:03:50.070]                 }
[17:03:50.070]                 else {
[17:03:50.070]                   if (TRUE) {
[17:03:50.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.070]                     {
[17:03:50.070]                       inherits <- base::inherits
[17:03:50.070]                       invokeRestart <- base::invokeRestart
[17:03:50.070]                       is.null <- base::is.null
[17:03:50.070]                       muffled <- FALSE
[17:03:50.070]                       if (inherits(cond, "message")) {
[17:03:50.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.070]                         if (muffled) 
[17:03:50.070]                           invokeRestart("muffleMessage")
[17:03:50.070]                       }
[17:03:50.070]                       else if (inherits(cond, "warning")) {
[17:03:50.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.070]                         if (muffled) 
[17:03:50.070]                           invokeRestart("muffleWarning")
[17:03:50.070]                       }
[17:03:50.070]                       else if (inherits(cond, "condition")) {
[17:03:50.070]                         if (!is.null(pattern)) {
[17:03:50.070]                           computeRestarts <- base::computeRestarts
[17:03:50.070]                           grepl <- base::grepl
[17:03:50.070]                           restarts <- computeRestarts(cond)
[17:03:50.070]                           for (restart in restarts) {
[17:03:50.070]                             name <- restart$name
[17:03:50.070]                             if (is.null(name)) 
[17:03:50.070]                               next
[17:03:50.070]                             if (!grepl(pattern, name)) 
[17:03:50.070]                               next
[17:03:50.070]                             invokeRestart(restart)
[17:03:50.070]                             muffled <- TRUE
[17:03:50.070]                             break
[17:03:50.070]                           }
[17:03:50.070]                         }
[17:03:50.070]                       }
[17:03:50.070]                       invisible(muffled)
[17:03:50.070]                     }
[17:03:50.070]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.070]                   }
[17:03:50.070]                 }
[17:03:50.070]             }
[17:03:50.070]         }))
[17:03:50.070]     }, error = function(ex) {
[17:03:50.070]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:50.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.070]                 ...future.rng), started = ...future.startTime, 
[17:03:50.070]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:50.070]             version = "1.8"), class = "FutureResult")
[17:03:50.070]     }, finally = {
[17:03:50.070]         if (!identical(...future.workdir, getwd())) 
[17:03:50.070]             setwd(...future.workdir)
[17:03:50.070]         {
[17:03:50.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:50.070]                 ...future.oldOptions$nwarnings <- NULL
[17:03:50.070]             }
[17:03:50.070]             base::options(...future.oldOptions)
[17:03:50.070]             if (.Platform$OS.type == "windows") {
[17:03:50.070]                 old_names <- names(...future.oldEnvVars)
[17:03:50.070]                 envs <- base::Sys.getenv()
[17:03:50.070]                 names <- names(envs)
[17:03:50.070]                 common <- intersect(names, old_names)
[17:03:50.070]                 added <- setdiff(names, old_names)
[17:03:50.070]                 removed <- setdiff(old_names, names)
[17:03:50.070]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:50.070]                   envs[common]]
[17:03:50.070]                 NAMES <- toupper(changed)
[17:03:50.070]                 args <- list()
[17:03:50.070]                 for (kk in seq_along(NAMES)) {
[17:03:50.070]                   name <- changed[[kk]]
[17:03:50.070]                   NAME <- NAMES[[kk]]
[17:03:50.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.070]                     next
[17:03:50.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.070]                 }
[17:03:50.070]                 NAMES <- toupper(added)
[17:03:50.070]                 for (kk in seq_along(NAMES)) {
[17:03:50.070]                   name <- added[[kk]]
[17:03:50.070]                   NAME <- NAMES[[kk]]
[17:03:50.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.070]                     next
[17:03:50.070]                   args[[name]] <- ""
[17:03:50.070]                 }
[17:03:50.070]                 NAMES <- toupper(removed)
[17:03:50.070]                 for (kk in seq_along(NAMES)) {
[17:03:50.070]                   name <- removed[[kk]]
[17:03:50.070]                   NAME <- NAMES[[kk]]
[17:03:50.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.070]                     next
[17:03:50.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.070]                 }
[17:03:50.070]                 if (length(args) > 0) 
[17:03:50.070]                   base::do.call(base::Sys.setenv, args = args)
[17:03:50.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:50.070]             }
[17:03:50.070]             else {
[17:03:50.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:50.070]             }
[17:03:50.070]             {
[17:03:50.070]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:50.070]                   0L) {
[17:03:50.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:50.070]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:50.070]                   base::options(opts)
[17:03:50.070]                 }
[17:03:50.070]                 {
[17:03:50.070]                   {
[17:03:50.070]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:50.070]                     NULL
[17:03:50.070]                   }
[17:03:50.070]                   options(future.plan = NULL)
[17:03:50.070]                   if (is.na(NA_character_)) 
[17:03:50.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:50.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:50.070]                     .init = FALSE)
[17:03:50.070]                 }
[17:03:50.070]             }
[17:03:50.070]         }
[17:03:50.070]     })
[17:03:50.070]     if (TRUE) {
[17:03:50.070]         base::sink(type = "output", split = FALSE)
[17:03:50.070]         if (TRUE) {
[17:03:50.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:50.070]         }
[17:03:50.070]         else {
[17:03:50.070]             ...future.result["stdout"] <- base::list(NULL)
[17:03:50.070]         }
[17:03:50.070]         base::close(...future.stdout)
[17:03:50.070]         ...future.stdout <- NULL
[17:03:50.070]     }
[17:03:50.070]     ...future.result$conditions <- ...future.conditions
[17:03:50.070]     ...future.result$finished <- base::Sys.time()
[17:03:50.070]     ...future.result
[17:03:50.070] }
[17:03:50.073] MultisessionFuture started
[17:03:50.073] - Launch lazy future ... done
[17:03:50.073] run() for ‘MultisessionFuture’ ... done
[17:03:50.575] receiveMessageFromWorker() for ClusterFuture ...
[17:03:50.576] - Validating connection of MultisessionFuture
[17:03:50.576] - received message: FutureResult
[17:03:50.576] - Received FutureResult
[17:03:50.576] - Erased future from FutureRegistry
[17:03:50.576] result() for ClusterFuture ...
[17:03:50.576] - result already collected: FutureResult
[17:03:50.576] result() for ClusterFuture ... done
[17:03:50.576] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:50.577] resolve() on list ...
[17:03:50.577]  recursive: 98
[17:03:50.577]  length: 2
[17:03:50.577]  elements: ‘a’, ‘b’
[17:03:50.577]  length: 1 (resolved future 1)
[17:03:50.577]  length: 0 (resolved future 2)
[17:03:50.577] resolve() on list ... DONE
[17:03:50.577] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:03:50.577] getGlobalsAndPackages() ...
[17:03:50.577] Searching for globals...
[17:03:50.578] - globals found: [2] ‘list’, ‘stop’
[17:03:50.578] Searching for globals ... DONE
[17:03:50.578] Resolving globals: FALSE
[17:03:50.579] 
[17:03:50.579] 
[17:03:50.579] getGlobalsAndPackages() ... DONE
[17:03:50.579] run() for ‘Future’ ...
[17:03:50.579] - state: ‘created’
[17:03:50.579] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:50.593] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:50.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:50.593]   - Field: ‘node’
[17:03:50.593]   - Field: ‘label’
[17:03:50.593]   - Field: ‘local’
[17:03:50.594]   - Field: ‘owner’
[17:03:50.594]   - Field: ‘envir’
[17:03:50.594]   - Field: ‘workers’
[17:03:50.594]   - Field: ‘packages’
[17:03:50.594]   - Field: ‘gc’
[17:03:50.594]   - Field: ‘conditions’
[17:03:50.594]   - Field: ‘persistent’
[17:03:50.594]   - Field: ‘expr’
[17:03:50.594]   - Field: ‘uuid’
[17:03:50.594]   - Field: ‘seed’
[17:03:50.594]   - Field: ‘version’
[17:03:50.595]   - Field: ‘result’
[17:03:50.595]   - Field: ‘asynchronous’
[17:03:50.595]   - Field: ‘calls’
[17:03:50.595]   - Field: ‘globals’
[17:03:50.595]   - Field: ‘stdout’
[17:03:50.595]   - Field: ‘earlySignal’
[17:03:50.595]   - Field: ‘lazy’
[17:03:50.595]   - Field: ‘state’
[17:03:50.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:50.595] - Launch lazy future ...
[17:03:50.596] Packages needed by the future expression (n = 0): <none>
[17:03:50.596] Packages needed by future strategies (n = 0): <none>
[17:03:50.596] {
[17:03:50.596]     {
[17:03:50.596]         {
[17:03:50.596]             ...future.startTime <- base::Sys.time()
[17:03:50.596]             {
[17:03:50.596]                 {
[17:03:50.596]                   {
[17:03:50.596]                     {
[17:03:50.596]                       base::local({
[17:03:50.596]                         has_future <- base::requireNamespace("future", 
[17:03:50.596]                           quietly = TRUE)
[17:03:50.596]                         if (has_future) {
[17:03:50.596]                           ns <- base::getNamespace("future")
[17:03:50.596]                           version <- ns[[".package"]][["version"]]
[17:03:50.596]                           if (is.null(version)) 
[17:03:50.596]                             version <- utils::packageVersion("future")
[17:03:50.596]                         }
[17:03:50.596]                         else {
[17:03:50.596]                           version <- NULL
[17:03:50.596]                         }
[17:03:50.596]                         if (!has_future || version < "1.8.0") {
[17:03:50.596]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:50.596]                             "", base::R.version$version.string), 
[17:03:50.596]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:50.596]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:50.596]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:50.596]                               "release", "version")], collapse = " "), 
[17:03:50.596]                             hostname = base::Sys.info()[["nodename"]])
[17:03:50.596]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:50.596]                             info)
[17:03:50.596]                           info <- base::paste(info, collapse = "; ")
[17:03:50.596]                           if (!has_future) {
[17:03:50.596]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:50.596]                               info)
[17:03:50.596]                           }
[17:03:50.596]                           else {
[17:03:50.596]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:50.596]                               info, version)
[17:03:50.596]                           }
[17:03:50.596]                           base::stop(msg)
[17:03:50.596]                         }
[17:03:50.596]                       })
[17:03:50.596]                     }
[17:03:50.596]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:50.596]                     base::options(mc.cores = 1L)
[17:03:50.596]                   }
[17:03:50.596]                   ...future.strategy.old <- future::plan("list")
[17:03:50.596]                   options(future.plan = NULL)
[17:03:50.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:50.596]                 }
[17:03:50.596]                 ...future.workdir <- getwd()
[17:03:50.596]             }
[17:03:50.596]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:50.596]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:50.596]         }
[17:03:50.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:50.596]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:50.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:50.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:50.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:50.596]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:50.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:50.596]             base::names(...future.oldOptions))
[17:03:50.596]     }
[17:03:50.596]     if (FALSE) {
[17:03:50.596]     }
[17:03:50.596]     else {
[17:03:50.596]         if (TRUE) {
[17:03:50.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:50.596]                 open = "w")
[17:03:50.596]         }
[17:03:50.596]         else {
[17:03:50.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:50.596]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:50.596]         }
[17:03:50.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:50.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:50.596]             base::sink(type = "output", split = FALSE)
[17:03:50.596]             base::close(...future.stdout)
[17:03:50.596]         }, add = TRUE)
[17:03:50.596]     }
[17:03:50.596]     ...future.frame <- base::sys.nframe()
[17:03:50.596]     ...future.conditions <- base::list()
[17:03:50.596]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:50.596]     if (FALSE) {
[17:03:50.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:50.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:50.596]     }
[17:03:50.596]     ...future.result <- base::tryCatch({
[17:03:50.596]         base::withCallingHandlers({
[17:03:50.596]             ...future.value <- base::withVisible(base::local({
[17:03:50.596]                 ...future.makeSendCondition <- base::local({
[17:03:50.596]                   sendCondition <- NULL
[17:03:50.596]                   function(frame = 1L) {
[17:03:50.596]                     if (is.function(sendCondition)) 
[17:03:50.596]                       return(sendCondition)
[17:03:50.596]                     ns <- getNamespace("parallel")
[17:03:50.596]                     if (exists("sendData", mode = "function", 
[17:03:50.596]                       envir = ns)) {
[17:03:50.596]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:50.596]                         envir = ns)
[17:03:50.596]                       envir <- sys.frame(frame)
[17:03:50.596]                       master <- NULL
[17:03:50.596]                       while (!identical(envir, .GlobalEnv) && 
[17:03:50.596]                         !identical(envir, emptyenv())) {
[17:03:50.596]                         if (exists("master", mode = "list", envir = envir, 
[17:03:50.596]                           inherits = FALSE)) {
[17:03:50.596]                           master <- get("master", mode = "list", 
[17:03:50.596]                             envir = envir, inherits = FALSE)
[17:03:50.596]                           if (inherits(master, c("SOCKnode", 
[17:03:50.596]                             "SOCK0node"))) {
[17:03:50.596]                             sendCondition <<- function(cond) {
[17:03:50.596]                               data <- list(type = "VALUE", value = cond, 
[17:03:50.596]                                 success = TRUE)
[17:03:50.596]                               parallel_sendData(master, data)
[17:03:50.596]                             }
[17:03:50.596]                             return(sendCondition)
[17:03:50.596]                           }
[17:03:50.596]                         }
[17:03:50.596]                         frame <- frame + 1L
[17:03:50.596]                         envir <- sys.frame(frame)
[17:03:50.596]                       }
[17:03:50.596]                     }
[17:03:50.596]                     sendCondition <<- function(cond) NULL
[17:03:50.596]                   }
[17:03:50.596]                 })
[17:03:50.596]                 withCallingHandlers({
[17:03:50.596]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:50.596]                 }, immediateCondition = function(cond) {
[17:03:50.596]                   sendCondition <- ...future.makeSendCondition()
[17:03:50.596]                   sendCondition(cond)
[17:03:50.596]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.596]                   {
[17:03:50.596]                     inherits <- base::inherits
[17:03:50.596]                     invokeRestart <- base::invokeRestart
[17:03:50.596]                     is.null <- base::is.null
[17:03:50.596]                     muffled <- FALSE
[17:03:50.596]                     if (inherits(cond, "message")) {
[17:03:50.596]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:50.596]                       if (muffled) 
[17:03:50.596]                         invokeRestart("muffleMessage")
[17:03:50.596]                     }
[17:03:50.596]                     else if (inherits(cond, "warning")) {
[17:03:50.596]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:50.596]                       if (muffled) 
[17:03:50.596]                         invokeRestart("muffleWarning")
[17:03:50.596]                     }
[17:03:50.596]                     else if (inherits(cond, "condition")) {
[17:03:50.596]                       if (!is.null(pattern)) {
[17:03:50.596]                         computeRestarts <- base::computeRestarts
[17:03:50.596]                         grepl <- base::grepl
[17:03:50.596]                         restarts <- computeRestarts(cond)
[17:03:50.596]                         for (restart in restarts) {
[17:03:50.596]                           name <- restart$name
[17:03:50.596]                           if (is.null(name)) 
[17:03:50.596]                             next
[17:03:50.596]                           if (!grepl(pattern, name)) 
[17:03:50.596]                             next
[17:03:50.596]                           invokeRestart(restart)
[17:03:50.596]                           muffled <- TRUE
[17:03:50.596]                           break
[17:03:50.596]                         }
[17:03:50.596]                       }
[17:03:50.596]                     }
[17:03:50.596]                     invisible(muffled)
[17:03:50.596]                   }
[17:03:50.596]                   muffleCondition(cond)
[17:03:50.596]                 })
[17:03:50.596]             }))
[17:03:50.596]             future::FutureResult(value = ...future.value$value, 
[17:03:50.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.596]                   ...future.rng), globalenv = if (FALSE) 
[17:03:50.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:50.596]                     ...future.globalenv.names))
[17:03:50.596]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:50.596]         }, condition = base::local({
[17:03:50.596]             c <- base::c
[17:03:50.596]             inherits <- base::inherits
[17:03:50.596]             invokeRestart <- base::invokeRestart
[17:03:50.596]             length <- base::length
[17:03:50.596]             list <- base::list
[17:03:50.596]             seq.int <- base::seq.int
[17:03:50.596]             signalCondition <- base::signalCondition
[17:03:50.596]             sys.calls <- base::sys.calls
[17:03:50.596]             `[[` <- base::`[[`
[17:03:50.596]             `+` <- base::`+`
[17:03:50.596]             `<<-` <- base::`<<-`
[17:03:50.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:50.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:50.596]                   3L)]
[17:03:50.596]             }
[17:03:50.596]             function(cond) {
[17:03:50.596]                 is_error <- inherits(cond, "error")
[17:03:50.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:50.596]                   NULL)
[17:03:50.596]                 if (is_error) {
[17:03:50.596]                   sessionInformation <- function() {
[17:03:50.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:50.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:50.596]                       search = base::search(), system = base::Sys.info())
[17:03:50.596]                   }
[17:03:50.596]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:50.596]                     cond$call), session = sessionInformation(), 
[17:03:50.596]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:50.596]                   signalCondition(cond)
[17:03:50.596]                 }
[17:03:50.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:50.596]                 "immediateCondition"))) {
[17:03:50.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:50.596]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:50.596]                   if (TRUE && !signal) {
[17:03:50.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.596]                     {
[17:03:50.596]                       inherits <- base::inherits
[17:03:50.596]                       invokeRestart <- base::invokeRestart
[17:03:50.596]                       is.null <- base::is.null
[17:03:50.596]                       muffled <- FALSE
[17:03:50.596]                       if (inherits(cond, "message")) {
[17:03:50.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.596]                         if (muffled) 
[17:03:50.596]                           invokeRestart("muffleMessage")
[17:03:50.596]                       }
[17:03:50.596]                       else if (inherits(cond, "warning")) {
[17:03:50.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.596]                         if (muffled) 
[17:03:50.596]                           invokeRestart("muffleWarning")
[17:03:50.596]                       }
[17:03:50.596]                       else if (inherits(cond, "condition")) {
[17:03:50.596]                         if (!is.null(pattern)) {
[17:03:50.596]                           computeRestarts <- base::computeRestarts
[17:03:50.596]                           grepl <- base::grepl
[17:03:50.596]                           restarts <- computeRestarts(cond)
[17:03:50.596]                           for (restart in restarts) {
[17:03:50.596]                             name <- restart$name
[17:03:50.596]                             if (is.null(name)) 
[17:03:50.596]                               next
[17:03:50.596]                             if (!grepl(pattern, name)) 
[17:03:50.596]                               next
[17:03:50.596]                             invokeRestart(restart)
[17:03:50.596]                             muffled <- TRUE
[17:03:50.596]                             break
[17:03:50.596]                           }
[17:03:50.596]                         }
[17:03:50.596]                       }
[17:03:50.596]                       invisible(muffled)
[17:03:50.596]                     }
[17:03:50.596]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.596]                   }
[17:03:50.596]                 }
[17:03:50.596]                 else {
[17:03:50.596]                   if (TRUE) {
[17:03:50.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.596]                     {
[17:03:50.596]                       inherits <- base::inherits
[17:03:50.596]                       invokeRestart <- base::invokeRestart
[17:03:50.596]                       is.null <- base::is.null
[17:03:50.596]                       muffled <- FALSE
[17:03:50.596]                       if (inherits(cond, "message")) {
[17:03:50.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.596]                         if (muffled) 
[17:03:50.596]                           invokeRestart("muffleMessage")
[17:03:50.596]                       }
[17:03:50.596]                       else if (inherits(cond, "warning")) {
[17:03:50.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.596]                         if (muffled) 
[17:03:50.596]                           invokeRestart("muffleWarning")
[17:03:50.596]                       }
[17:03:50.596]                       else if (inherits(cond, "condition")) {
[17:03:50.596]                         if (!is.null(pattern)) {
[17:03:50.596]                           computeRestarts <- base::computeRestarts
[17:03:50.596]                           grepl <- base::grepl
[17:03:50.596]                           restarts <- computeRestarts(cond)
[17:03:50.596]                           for (restart in restarts) {
[17:03:50.596]                             name <- restart$name
[17:03:50.596]                             if (is.null(name)) 
[17:03:50.596]                               next
[17:03:50.596]                             if (!grepl(pattern, name)) 
[17:03:50.596]                               next
[17:03:50.596]                             invokeRestart(restart)
[17:03:50.596]                             muffled <- TRUE
[17:03:50.596]                             break
[17:03:50.596]                           }
[17:03:50.596]                         }
[17:03:50.596]                       }
[17:03:50.596]                       invisible(muffled)
[17:03:50.596]                     }
[17:03:50.596]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.596]                   }
[17:03:50.596]                 }
[17:03:50.596]             }
[17:03:50.596]         }))
[17:03:50.596]     }, error = function(ex) {
[17:03:50.596]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:50.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.596]                 ...future.rng), started = ...future.startTime, 
[17:03:50.596]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:50.596]             version = "1.8"), class = "FutureResult")
[17:03:50.596]     }, finally = {
[17:03:50.596]         if (!identical(...future.workdir, getwd())) 
[17:03:50.596]             setwd(...future.workdir)
[17:03:50.596]         {
[17:03:50.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:50.596]                 ...future.oldOptions$nwarnings <- NULL
[17:03:50.596]             }
[17:03:50.596]             base::options(...future.oldOptions)
[17:03:50.596]             if (.Platform$OS.type == "windows") {
[17:03:50.596]                 old_names <- names(...future.oldEnvVars)
[17:03:50.596]                 envs <- base::Sys.getenv()
[17:03:50.596]                 names <- names(envs)
[17:03:50.596]                 common <- intersect(names, old_names)
[17:03:50.596]                 added <- setdiff(names, old_names)
[17:03:50.596]                 removed <- setdiff(old_names, names)
[17:03:50.596]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:50.596]                   envs[common]]
[17:03:50.596]                 NAMES <- toupper(changed)
[17:03:50.596]                 args <- list()
[17:03:50.596]                 for (kk in seq_along(NAMES)) {
[17:03:50.596]                   name <- changed[[kk]]
[17:03:50.596]                   NAME <- NAMES[[kk]]
[17:03:50.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.596]                     next
[17:03:50.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.596]                 }
[17:03:50.596]                 NAMES <- toupper(added)
[17:03:50.596]                 for (kk in seq_along(NAMES)) {
[17:03:50.596]                   name <- added[[kk]]
[17:03:50.596]                   NAME <- NAMES[[kk]]
[17:03:50.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.596]                     next
[17:03:50.596]                   args[[name]] <- ""
[17:03:50.596]                 }
[17:03:50.596]                 NAMES <- toupper(removed)
[17:03:50.596]                 for (kk in seq_along(NAMES)) {
[17:03:50.596]                   name <- removed[[kk]]
[17:03:50.596]                   NAME <- NAMES[[kk]]
[17:03:50.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.596]                     next
[17:03:50.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.596]                 }
[17:03:50.596]                 if (length(args) > 0) 
[17:03:50.596]                   base::do.call(base::Sys.setenv, args = args)
[17:03:50.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:50.596]             }
[17:03:50.596]             else {
[17:03:50.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:50.596]             }
[17:03:50.596]             {
[17:03:50.596]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:50.596]                   0L) {
[17:03:50.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:50.596]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:50.596]                   base::options(opts)
[17:03:50.596]                 }
[17:03:50.596]                 {
[17:03:50.596]                   {
[17:03:50.596]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:50.596]                     NULL
[17:03:50.596]                   }
[17:03:50.596]                   options(future.plan = NULL)
[17:03:50.596]                   if (is.na(NA_character_)) 
[17:03:50.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:50.596]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:50.596]                     .init = FALSE)
[17:03:50.596]                 }
[17:03:50.596]             }
[17:03:50.596]         }
[17:03:50.596]     })
[17:03:50.596]     if (TRUE) {
[17:03:50.596]         base::sink(type = "output", split = FALSE)
[17:03:50.596]         if (TRUE) {
[17:03:50.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:50.596]         }
[17:03:50.596]         else {
[17:03:50.596]             ...future.result["stdout"] <- base::list(NULL)
[17:03:50.596]         }
[17:03:50.596]         base::close(...future.stdout)
[17:03:50.596]         ...future.stdout <- NULL
[17:03:50.596]     }
[17:03:50.596]     ...future.result$conditions <- ...future.conditions
[17:03:50.596]     ...future.result$finished <- base::Sys.time()
[17:03:50.596]     ...future.result
[17:03:50.596] }
[17:03:50.601] MultisessionFuture started
[17:03:50.602] - Launch lazy future ... done
[17:03:50.602] run() for ‘MultisessionFuture’ ... done
[17:03:50.603] receiveMessageFromWorker() for ClusterFuture ...
[17:03:50.604] - Validating connection of MultisessionFuture
[17:03:50.604] - received message: FutureResult
[17:03:50.604] - Received FutureResult
[17:03:50.604] - Erased future from FutureRegistry
[17:03:50.604] result() for ClusterFuture ...
[17:03:50.604] - result already collected: FutureResult
[17:03:50.605] result() for ClusterFuture ... done
[17:03:50.605] signalConditions() ...
[17:03:50.605]  - include = ‘immediateCondition’
[17:03:50.605]  - exclude = 
[17:03:50.605]  - resignal = FALSE
[17:03:50.605]  - Number of conditions: 1
[17:03:50.605] signalConditions() ... done
[17:03:50.605] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:50.605] A MultisessionFuture was resolved (and resolved itself)
[17:03:50.605] getGlobalsAndPackages() ...
[17:03:50.605] Searching for globals...
[17:03:50.606] - globals found: [2] ‘list’, ‘stop’
[17:03:50.606] Searching for globals ... DONE
[17:03:50.606] Resolving globals: FALSE
[17:03:50.607] 
[17:03:50.607] 
[17:03:50.607] getGlobalsAndPackages() ... DONE
[17:03:50.607] run() for ‘Future’ ...
[17:03:50.607] - state: ‘created’
[17:03:50.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:50.621] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:50.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:50.621]   - Field: ‘node’
[17:03:50.621]   - Field: ‘label’
[17:03:50.621]   - Field: ‘local’
[17:03:50.621]   - Field: ‘owner’
[17:03:50.622]   - Field: ‘envir’
[17:03:50.622]   - Field: ‘workers’
[17:03:50.622]   - Field: ‘packages’
[17:03:50.622]   - Field: ‘gc’
[17:03:50.622]   - Field: ‘conditions’
[17:03:50.622]   - Field: ‘persistent’
[17:03:50.622]   - Field: ‘expr’
[17:03:50.622]   - Field: ‘uuid’
[17:03:50.622]   - Field: ‘seed’
[17:03:50.622]   - Field: ‘version’
[17:03:50.622]   - Field: ‘result’
[17:03:50.623]   - Field: ‘asynchronous’
[17:03:50.623]   - Field: ‘calls’
[17:03:50.623]   - Field: ‘globals’
[17:03:50.623]   - Field: ‘stdout’
[17:03:50.623]   - Field: ‘earlySignal’
[17:03:50.623]   - Field: ‘lazy’
[17:03:50.623]   - Field: ‘state’
[17:03:50.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:50.623] - Launch lazy future ...
[17:03:50.623] Packages needed by the future expression (n = 0): <none>
[17:03:50.624] Packages needed by future strategies (n = 0): <none>
[17:03:50.624] {
[17:03:50.624]     {
[17:03:50.624]         {
[17:03:50.624]             ...future.startTime <- base::Sys.time()
[17:03:50.624]             {
[17:03:50.624]                 {
[17:03:50.624]                   {
[17:03:50.624]                     {
[17:03:50.624]                       base::local({
[17:03:50.624]                         has_future <- base::requireNamespace("future", 
[17:03:50.624]                           quietly = TRUE)
[17:03:50.624]                         if (has_future) {
[17:03:50.624]                           ns <- base::getNamespace("future")
[17:03:50.624]                           version <- ns[[".package"]][["version"]]
[17:03:50.624]                           if (is.null(version)) 
[17:03:50.624]                             version <- utils::packageVersion("future")
[17:03:50.624]                         }
[17:03:50.624]                         else {
[17:03:50.624]                           version <- NULL
[17:03:50.624]                         }
[17:03:50.624]                         if (!has_future || version < "1.8.0") {
[17:03:50.624]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:50.624]                             "", base::R.version$version.string), 
[17:03:50.624]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:50.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:50.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:50.624]                               "release", "version")], collapse = " "), 
[17:03:50.624]                             hostname = base::Sys.info()[["nodename"]])
[17:03:50.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:50.624]                             info)
[17:03:50.624]                           info <- base::paste(info, collapse = "; ")
[17:03:50.624]                           if (!has_future) {
[17:03:50.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:50.624]                               info)
[17:03:50.624]                           }
[17:03:50.624]                           else {
[17:03:50.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:50.624]                               info, version)
[17:03:50.624]                           }
[17:03:50.624]                           base::stop(msg)
[17:03:50.624]                         }
[17:03:50.624]                       })
[17:03:50.624]                     }
[17:03:50.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:50.624]                     base::options(mc.cores = 1L)
[17:03:50.624]                   }
[17:03:50.624]                   ...future.strategy.old <- future::plan("list")
[17:03:50.624]                   options(future.plan = NULL)
[17:03:50.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:50.624]                 }
[17:03:50.624]                 ...future.workdir <- getwd()
[17:03:50.624]             }
[17:03:50.624]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:50.624]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:50.624]         }
[17:03:50.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:50.624]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:50.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:50.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:50.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:50.624]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:50.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:50.624]             base::names(...future.oldOptions))
[17:03:50.624]     }
[17:03:50.624]     if (FALSE) {
[17:03:50.624]     }
[17:03:50.624]     else {
[17:03:50.624]         if (TRUE) {
[17:03:50.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:50.624]                 open = "w")
[17:03:50.624]         }
[17:03:50.624]         else {
[17:03:50.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:50.624]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:50.624]         }
[17:03:50.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:50.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:50.624]             base::sink(type = "output", split = FALSE)
[17:03:50.624]             base::close(...future.stdout)
[17:03:50.624]         }, add = TRUE)
[17:03:50.624]     }
[17:03:50.624]     ...future.frame <- base::sys.nframe()
[17:03:50.624]     ...future.conditions <- base::list()
[17:03:50.624]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:50.624]     if (FALSE) {
[17:03:50.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:50.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:50.624]     }
[17:03:50.624]     ...future.result <- base::tryCatch({
[17:03:50.624]         base::withCallingHandlers({
[17:03:50.624]             ...future.value <- base::withVisible(base::local({
[17:03:50.624]                 ...future.makeSendCondition <- base::local({
[17:03:50.624]                   sendCondition <- NULL
[17:03:50.624]                   function(frame = 1L) {
[17:03:50.624]                     if (is.function(sendCondition)) 
[17:03:50.624]                       return(sendCondition)
[17:03:50.624]                     ns <- getNamespace("parallel")
[17:03:50.624]                     if (exists("sendData", mode = "function", 
[17:03:50.624]                       envir = ns)) {
[17:03:50.624]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:50.624]                         envir = ns)
[17:03:50.624]                       envir <- sys.frame(frame)
[17:03:50.624]                       master <- NULL
[17:03:50.624]                       while (!identical(envir, .GlobalEnv) && 
[17:03:50.624]                         !identical(envir, emptyenv())) {
[17:03:50.624]                         if (exists("master", mode = "list", envir = envir, 
[17:03:50.624]                           inherits = FALSE)) {
[17:03:50.624]                           master <- get("master", mode = "list", 
[17:03:50.624]                             envir = envir, inherits = FALSE)
[17:03:50.624]                           if (inherits(master, c("SOCKnode", 
[17:03:50.624]                             "SOCK0node"))) {
[17:03:50.624]                             sendCondition <<- function(cond) {
[17:03:50.624]                               data <- list(type = "VALUE", value = cond, 
[17:03:50.624]                                 success = TRUE)
[17:03:50.624]                               parallel_sendData(master, data)
[17:03:50.624]                             }
[17:03:50.624]                             return(sendCondition)
[17:03:50.624]                           }
[17:03:50.624]                         }
[17:03:50.624]                         frame <- frame + 1L
[17:03:50.624]                         envir <- sys.frame(frame)
[17:03:50.624]                       }
[17:03:50.624]                     }
[17:03:50.624]                     sendCondition <<- function(cond) NULL
[17:03:50.624]                   }
[17:03:50.624]                 })
[17:03:50.624]                 withCallingHandlers({
[17:03:50.624]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:50.624]                 }, immediateCondition = function(cond) {
[17:03:50.624]                   sendCondition <- ...future.makeSendCondition()
[17:03:50.624]                   sendCondition(cond)
[17:03:50.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.624]                   {
[17:03:50.624]                     inherits <- base::inherits
[17:03:50.624]                     invokeRestart <- base::invokeRestart
[17:03:50.624]                     is.null <- base::is.null
[17:03:50.624]                     muffled <- FALSE
[17:03:50.624]                     if (inherits(cond, "message")) {
[17:03:50.624]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:50.624]                       if (muffled) 
[17:03:50.624]                         invokeRestart("muffleMessage")
[17:03:50.624]                     }
[17:03:50.624]                     else if (inherits(cond, "warning")) {
[17:03:50.624]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:50.624]                       if (muffled) 
[17:03:50.624]                         invokeRestart("muffleWarning")
[17:03:50.624]                     }
[17:03:50.624]                     else if (inherits(cond, "condition")) {
[17:03:50.624]                       if (!is.null(pattern)) {
[17:03:50.624]                         computeRestarts <- base::computeRestarts
[17:03:50.624]                         grepl <- base::grepl
[17:03:50.624]                         restarts <- computeRestarts(cond)
[17:03:50.624]                         for (restart in restarts) {
[17:03:50.624]                           name <- restart$name
[17:03:50.624]                           if (is.null(name)) 
[17:03:50.624]                             next
[17:03:50.624]                           if (!grepl(pattern, name)) 
[17:03:50.624]                             next
[17:03:50.624]                           invokeRestart(restart)
[17:03:50.624]                           muffled <- TRUE
[17:03:50.624]                           break
[17:03:50.624]                         }
[17:03:50.624]                       }
[17:03:50.624]                     }
[17:03:50.624]                     invisible(muffled)
[17:03:50.624]                   }
[17:03:50.624]                   muffleCondition(cond)
[17:03:50.624]                 })
[17:03:50.624]             }))
[17:03:50.624]             future::FutureResult(value = ...future.value$value, 
[17:03:50.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.624]                   ...future.rng), globalenv = if (FALSE) 
[17:03:50.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:50.624]                     ...future.globalenv.names))
[17:03:50.624]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:50.624]         }, condition = base::local({
[17:03:50.624]             c <- base::c
[17:03:50.624]             inherits <- base::inherits
[17:03:50.624]             invokeRestart <- base::invokeRestart
[17:03:50.624]             length <- base::length
[17:03:50.624]             list <- base::list
[17:03:50.624]             seq.int <- base::seq.int
[17:03:50.624]             signalCondition <- base::signalCondition
[17:03:50.624]             sys.calls <- base::sys.calls
[17:03:50.624]             `[[` <- base::`[[`
[17:03:50.624]             `+` <- base::`+`
[17:03:50.624]             `<<-` <- base::`<<-`
[17:03:50.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:50.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:50.624]                   3L)]
[17:03:50.624]             }
[17:03:50.624]             function(cond) {
[17:03:50.624]                 is_error <- inherits(cond, "error")
[17:03:50.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:50.624]                   NULL)
[17:03:50.624]                 if (is_error) {
[17:03:50.624]                   sessionInformation <- function() {
[17:03:50.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:50.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:50.624]                       search = base::search(), system = base::Sys.info())
[17:03:50.624]                   }
[17:03:50.624]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:50.624]                     cond$call), session = sessionInformation(), 
[17:03:50.624]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:50.624]                   signalCondition(cond)
[17:03:50.624]                 }
[17:03:50.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:50.624]                 "immediateCondition"))) {
[17:03:50.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:50.624]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:50.624]                   if (TRUE && !signal) {
[17:03:50.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.624]                     {
[17:03:50.624]                       inherits <- base::inherits
[17:03:50.624]                       invokeRestart <- base::invokeRestart
[17:03:50.624]                       is.null <- base::is.null
[17:03:50.624]                       muffled <- FALSE
[17:03:50.624]                       if (inherits(cond, "message")) {
[17:03:50.624]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.624]                         if (muffled) 
[17:03:50.624]                           invokeRestart("muffleMessage")
[17:03:50.624]                       }
[17:03:50.624]                       else if (inherits(cond, "warning")) {
[17:03:50.624]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.624]                         if (muffled) 
[17:03:50.624]                           invokeRestart("muffleWarning")
[17:03:50.624]                       }
[17:03:50.624]                       else if (inherits(cond, "condition")) {
[17:03:50.624]                         if (!is.null(pattern)) {
[17:03:50.624]                           computeRestarts <- base::computeRestarts
[17:03:50.624]                           grepl <- base::grepl
[17:03:50.624]                           restarts <- computeRestarts(cond)
[17:03:50.624]                           for (restart in restarts) {
[17:03:50.624]                             name <- restart$name
[17:03:50.624]                             if (is.null(name)) 
[17:03:50.624]                               next
[17:03:50.624]                             if (!grepl(pattern, name)) 
[17:03:50.624]                               next
[17:03:50.624]                             invokeRestart(restart)
[17:03:50.624]                             muffled <- TRUE
[17:03:50.624]                             break
[17:03:50.624]                           }
[17:03:50.624]                         }
[17:03:50.624]                       }
[17:03:50.624]                       invisible(muffled)
[17:03:50.624]                     }
[17:03:50.624]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.624]                   }
[17:03:50.624]                 }
[17:03:50.624]                 else {
[17:03:50.624]                   if (TRUE) {
[17:03:50.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.624]                     {
[17:03:50.624]                       inherits <- base::inherits
[17:03:50.624]                       invokeRestart <- base::invokeRestart
[17:03:50.624]                       is.null <- base::is.null
[17:03:50.624]                       muffled <- FALSE
[17:03:50.624]                       if (inherits(cond, "message")) {
[17:03:50.624]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.624]                         if (muffled) 
[17:03:50.624]                           invokeRestart("muffleMessage")
[17:03:50.624]                       }
[17:03:50.624]                       else if (inherits(cond, "warning")) {
[17:03:50.624]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.624]                         if (muffled) 
[17:03:50.624]                           invokeRestart("muffleWarning")
[17:03:50.624]                       }
[17:03:50.624]                       else if (inherits(cond, "condition")) {
[17:03:50.624]                         if (!is.null(pattern)) {
[17:03:50.624]                           computeRestarts <- base::computeRestarts
[17:03:50.624]                           grepl <- base::grepl
[17:03:50.624]                           restarts <- computeRestarts(cond)
[17:03:50.624]                           for (restart in restarts) {
[17:03:50.624]                             name <- restart$name
[17:03:50.624]                             if (is.null(name)) 
[17:03:50.624]                               next
[17:03:50.624]                             if (!grepl(pattern, name)) 
[17:03:50.624]                               next
[17:03:50.624]                             invokeRestart(restart)
[17:03:50.624]                             muffled <- TRUE
[17:03:50.624]                             break
[17:03:50.624]                           }
[17:03:50.624]                         }
[17:03:50.624]                       }
[17:03:50.624]                       invisible(muffled)
[17:03:50.624]                     }
[17:03:50.624]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.624]                   }
[17:03:50.624]                 }
[17:03:50.624]             }
[17:03:50.624]         }))
[17:03:50.624]     }, error = function(ex) {
[17:03:50.624]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:50.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.624]                 ...future.rng), started = ...future.startTime, 
[17:03:50.624]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:50.624]             version = "1.8"), class = "FutureResult")
[17:03:50.624]     }, finally = {
[17:03:50.624]         if (!identical(...future.workdir, getwd())) 
[17:03:50.624]             setwd(...future.workdir)
[17:03:50.624]         {
[17:03:50.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:50.624]                 ...future.oldOptions$nwarnings <- NULL
[17:03:50.624]             }
[17:03:50.624]             base::options(...future.oldOptions)
[17:03:50.624]             if (.Platform$OS.type == "windows") {
[17:03:50.624]                 old_names <- names(...future.oldEnvVars)
[17:03:50.624]                 envs <- base::Sys.getenv()
[17:03:50.624]                 names <- names(envs)
[17:03:50.624]                 common <- intersect(names, old_names)
[17:03:50.624]                 added <- setdiff(names, old_names)
[17:03:50.624]                 removed <- setdiff(old_names, names)
[17:03:50.624]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:50.624]                   envs[common]]
[17:03:50.624]                 NAMES <- toupper(changed)
[17:03:50.624]                 args <- list()
[17:03:50.624]                 for (kk in seq_along(NAMES)) {
[17:03:50.624]                   name <- changed[[kk]]
[17:03:50.624]                   NAME <- NAMES[[kk]]
[17:03:50.624]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.624]                     next
[17:03:50.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.624]                 }
[17:03:50.624]                 NAMES <- toupper(added)
[17:03:50.624]                 for (kk in seq_along(NAMES)) {
[17:03:50.624]                   name <- added[[kk]]
[17:03:50.624]                   NAME <- NAMES[[kk]]
[17:03:50.624]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.624]                     next
[17:03:50.624]                   args[[name]] <- ""
[17:03:50.624]                 }
[17:03:50.624]                 NAMES <- toupper(removed)
[17:03:50.624]                 for (kk in seq_along(NAMES)) {
[17:03:50.624]                   name <- removed[[kk]]
[17:03:50.624]                   NAME <- NAMES[[kk]]
[17:03:50.624]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.624]                     next
[17:03:50.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.624]                 }
[17:03:50.624]                 if (length(args) > 0) 
[17:03:50.624]                   base::do.call(base::Sys.setenv, args = args)
[17:03:50.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:50.624]             }
[17:03:50.624]             else {
[17:03:50.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:50.624]             }
[17:03:50.624]             {
[17:03:50.624]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:50.624]                   0L) {
[17:03:50.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:50.624]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:50.624]                   base::options(opts)
[17:03:50.624]                 }
[17:03:50.624]                 {
[17:03:50.624]                   {
[17:03:50.624]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:50.624]                     NULL
[17:03:50.624]                   }
[17:03:50.624]                   options(future.plan = NULL)
[17:03:50.624]                   if (is.na(NA_character_)) 
[17:03:50.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:50.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:50.624]                     .init = FALSE)
[17:03:50.624]                 }
[17:03:50.624]             }
[17:03:50.624]         }
[17:03:50.624]     })
[17:03:50.624]     if (TRUE) {
[17:03:50.624]         base::sink(type = "output", split = FALSE)
[17:03:50.624]         if (TRUE) {
[17:03:50.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:50.624]         }
[17:03:50.624]         else {
[17:03:50.624]             ...future.result["stdout"] <- base::list(NULL)
[17:03:50.624]         }
[17:03:50.624]         base::close(...future.stdout)
[17:03:50.624]         ...future.stdout <- NULL
[17:03:50.624]     }
[17:03:50.624]     ...future.result$conditions <- ...future.conditions
[17:03:50.624]     ...future.result$finished <- base::Sys.time()
[17:03:50.624]     ...future.result
[17:03:50.624] }
[17:03:50.627] MultisessionFuture started
[17:03:50.627] - Launch lazy future ... done
[17:03:50.627] run() for ‘MultisessionFuture’ ... done
[17:03:50.628] receiveMessageFromWorker() for ClusterFuture ...
[17:03:50.629] - Validating connection of MultisessionFuture
[17:03:50.629] - received message: FutureResult
[17:03:50.629] - Received FutureResult
[17:03:50.629] - Erased future from FutureRegistry
[17:03:50.629] result() for ClusterFuture ...
[17:03:50.629] - result already collected: FutureResult
[17:03:50.629] result() for ClusterFuture ... done
[17:03:50.630] signalConditions() ...
[17:03:50.630]  - include = ‘immediateCondition’
[17:03:50.630]  - exclude = 
[17:03:50.630]  - resignal = FALSE
[17:03:50.630]  - Number of conditions: 1
[17:03:50.630] signalConditions() ... done
[17:03:50.630] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:50.630] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[17:03:50.630] getGlobalsAndPackages() ...
[17:03:50.630] Searching for globals...
[17:03:50.632] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:50.632] Searching for globals ... DONE
[17:03:50.632] Resolving globals: FALSE
[17:03:50.632] 
[17:03:50.632] 
[17:03:50.632] getGlobalsAndPackages() ... DONE
[17:03:50.632] run() for ‘Future’ ...
[17:03:50.633] - state: ‘created’
[17:03:50.633] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:50.647] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:50.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:50.647]   - Field: ‘node’
[17:03:50.647]   - Field: ‘label’
[17:03:50.647]   - Field: ‘local’
[17:03:50.648]   - Field: ‘owner’
[17:03:50.648]   - Field: ‘envir’
[17:03:50.648]   - Field: ‘workers’
[17:03:50.648]   - Field: ‘packages’
[17:03:50.648]   - Field: ‘gc’
[17:03:50.648]   - Field: ‘conditions’
[17:03:50.648]   - Field: ‘persistent’
[17:03:50.648]   - Field: ‘expr’
[17:03:50.648]   - Field: ‘uuid’
[17:03:50.648]   - Field: ‘seed’
[17:03:50.648]   - Field: ‘version’
[17:03:50.649]   - Field: ‘result’
[17:03:50.649]   - Field: ‘asynchronous’
[17:03:50.649]   - Field: ‘calls’
[17:03:50.649]   - Field: ‘globals’
[17:03:50.649]   - Field: ‘stdout’
[17:03:50.649]   - Field: ‘earlySignal’
[17:03:50.649]   - Field: ‘lazy’
[17:03:50.649]   - Field: ‘state’
[17:03:50.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:50.649] - Launch lazy future ...
[17:03:50.650] Packages needed by the future expression (n = 0): <none>
[17:03:50.650] Packages needed by future strategies (n = 0): <none>
[17:03:50.650] {
[17:03:50.650]     {
[17:03:50.650]         {
[17:03:50.650]             ...future.startTime <- base::Sys.time()
[17:03:50.650]             {
[17:03:50.650]                 {
[17:03:50.650]                   {
[17:03:50.650]                     {
[17:03:50.650]                       base::local({
[17:03:50.650]                         has_future <- base::requireNamespace("future", 
[17:03:50.650]                           quietly = TRUE)
[17:03:50.650]                         if (has_future) {
[17:03:50.650]                           ns <- base::getNamespace("future")
[17:03:50.650]                           version <- ns[[".package"]][["version"]]
[17:03:50.650]                           if (is.null(version)) 
[17:03:50.650]                             version <- utils::packageVersion("future")
[17:03:50.650]                         }
[17:03:50.650]                         else {
[17:03:50.650]                           version <- NULL
[17:03:50.650]                         }
[17:03:50.650]                         if (!has_future || version < "1.8.0") {
[17:03:50.650]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:50.650]                             "", base::R.version$version.string), 
[17:03:50.650]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:50.650]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:50.650]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:50.650]                               "release", "version")], collapse = " "), 
[17:03:50.650]                             hostname = base::Sys.info()[["nodename"]])
[17:03:50.650]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:50.650]                             info)
[17:03:50.650]                           info <- base::paste(info, collapse = "; ")
[17:03:50.650]                           if (!has_future) {
[17:03:50.650]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:50.650]                               info)
[17:03:50.650]                           }
[17:03:50.650]                           else {
[17:03:50.650]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:50.650]                               info, version)
[17:03:50.650]                           }
[17:03:50.650]                           base::stop(msg)
[17:03:50.650]                         }
[17:03:50.650]                       })
[17:03:50.650]                     }
[17:03:50.650]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:50.650]                     base::options(mc.cores = 1L)
[17:03:50.650]                   }
[17:03:50.650]                   ...future.strategy.old <- future::plan("list")
[17:03:50.650]                   options(future.plan = NULL)
[17:03:50.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:50.650]                 }
[17:03:50.650]                 ...future.workdir <- getwd()
[17:03:50.650]             }
[17:03:50.650]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:50.650]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:50.650]         }
[17:03:50.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:50.650]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:50.650]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:50.650]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:50.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:50.650]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:50.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:50.650]             base::names(...future.oldOptions))
[17:03:50.650]     }
[17:03:50.650]     if (FALSE) {
[17:03:50.650]     }
[17:03:50.650]     else {
[17:03:50.650]         if (TRUE) {
[17:03:50.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:50.650]                 open = "w")
[17:03:50.650]         }
[17:03:50.650]         else {
[17:03:50.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:50.650]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:50.650]         }
[17:03:50.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:50.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:50.650]             base::sink(type = "output", split = FALSE)
[17:03:50.650]             base::close(...future.stdout)
[17:03:50.650]         }, add = TRUE)
[17:03:50.650]     }
[17:03:50.650]     ...future.frame <- base::sys.nframe()
[17:03:50.650]     ...future.conditions <- base::list()
[17:03:50.650]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:50.650]     if (FALSE) {
[17:03:50.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:50.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:50.650]     }
[17:03:50.650]     ...future.result <- base::tryCatch({
[17:03:50.650]         base::withCallingHandlers({
[17:03:50.650]             ...future.value <- base::withVisible(base::local({
[17:03:50.650]                 ...future.makeSendCondition <- base::local({
[17:03:50.650]                   sendCondition <- NULL
[17:03:50.650]                   function(frame = 1L) {
[17:03:50.650]                     if (is.function(sendCondition)) 
[17:03:50.650]                       return(sendCondition)
[17:03:50.650]                     ns <- getNamespace("parallel")
[17:03:50.650]                     if (exists("sendData", mode = "function", 
[17:03:50.650]                       envir = ns)) {
[17:03:50.650]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:50.650]                         envir = ns)
[17:03:50.650]                       envir <- sys.frame(frame)
[17:03:50.650]                       master <- NULL
[17:03:50.650]                       while (!identical(envir, .GlobalEnv) && 
[17:03:50.650]                         !identical(envir, emptyenv())) {
[17:03:50.650]                         if (exists("master", mode = "list", envir = envir, 
[17:03:50.650]                           inherits = FALSE)) {
[17:03:50.650]                           master <- get("master", mode = "list", 
[17:03:50.650]                             envir = envir, inherits = FALSE)
[17:03:50.650]                           if (inherits(master, c("SOCKnode", 
[17:03:50.650]                             "SOCK0node"))) {
[17:03:50.650]                             sendCondition <<- function(cond) {
[17:03:50.650]                               data <- list(type = "VALUE", value = cond, 
[17:03:50.650]                                 success = TRUE)
[17:03:50.650]                               parallel_sendData(master, data)
[17:03:50.650]                             }
[17:03:50.650]                             return(sendCondition)
[17:03:50.650]                           }
[17:03:50.650]                         }
[17:03:50.650]                         frame <- frame + 1L
[17:03:50.650]                         envir <- sys.frame(frame)
[17:03:50.650]                       }
[17:03:50.650]                     }
[17:03:50.650]                     sendCondition <<- function(cond) NULL
[17:03:50.650]                   }
[17:03:50.650]                 })
[17:03:50.650]                 withCallingHandlers({
[17:03:50.650]                   {
[17:03:50.650]                     Sys.sleep(0.5)
[17:03:50.650]                     list(a = 1, b = 42L)
[17:03:50.650]                   }
[17:03:50.650]                 }, immediateCondition = function(cond) {
[17:03:50.650]                   sendCondition <- ...future.makeSendCondition()
[17:03:50.650]                   sendCondition(cond)
[17:03:50.650]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.650]                   {
[17:03:50.650]                     inherits <- base::inherits
[17:03:50.650]                     invokeRestart <- base::invokeRestart
[17:03:50.650]                     is.null <- base::is.null
[17:03:50.650]                     muffled <- FALSE
[17:03:50.650]                     if (inherits(cond, "message")) {
[17:03:50.650]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:50.650]                       if (muffled) 
[17:03:50.650]                         invokeRestart("muffleMessage")
[17:03:50.650]                     }
[17:03:50.650]                     else if (inherits(cond, "warning")) {
[17:03:50.650]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:50.650]                       if (muffled) 
[17:03:50.650]                         invokeRestart("muffleWarning")
[17:03:50.650]                     }
[17:03:50.650]                     else if (inherits(cond, "condition")) {
[17:03:50.650]                       if (!is.null(pattern)) {
[17:03:50.650]                         computeRestarts <- base::computeRestarts
[17:03:50.650]                         grepl <- base::grepl
[17:03:50.650]                         restarts <- computeRestarts(cond)
[17:03:50.650]                         for (restart in restarts) {
[17:03:50.650]                           name <- restart$name
[17:03:50.650]                           if (is.null(name)) 
[17:03:50.650]                             next
[17:03:50.650]                           if (!grepl(pattern, name)) 
[17:03:50.650]                             next
[17:03:50.650]                           invokeRestart(restart)
[17:03:50.650]                           muffled <- TRUE
[17:03:50.650]                           break
[17:03:50.650]                         }
[17:03:50.650]                       }
[17:03:50.650]                     }
[17:03:50.650]                     invisible(muffled)
[17:03:50.650]                   }
[17:03:50.650]                   muffleCondition(cond)
[17:03:50.650]                 })
[17:03:50.650]             }))
[17:03:50.650]             future::FutureResult(value = ...future.value$value, 
[17:03:50.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.650]                   ...future.rng), globalenv = if (FALSE) 
[17:03:50.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:50.650]                     ...future.globalenv.names))
[17:03:50.650]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:50.650]         }, condition = base::local({
[17:03:50.650]             c <- base::c
[17:03:50.650]             inherits <- base::inherits
[17:03:50.650]             invokeRestart <- base::invokeRestart
[17:03:50.650]             length <- base::length
[17:03:50.650]             list <- base::list
[17:03:50.650]             seq.int <- base::seq.int
[17:03:50.650]             signalCondition <- base::signalCondition
[17:03:50.650]             sys.calls <- base::sys.calls
[17:03:50.650]             `[[` <- base::`[[`
[17:03:50.650]             `+` <- base::`+`
[17:03:50.650]             `<<-` <- base::`<<-`
[17:03:50.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:50.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:50.650]                   3L)]
[17:03:50.650]             }
[17:03:50.650]             function(cond) {
[17:03:50.650]                 is_error <- inherits(cond, "error")
[17:03:50.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:50.650]                   NULL)
[17:03:50.650]                 if (is_error) {
[17:03:50.650]                   sessionInformation <- function() {
[17:03:50.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:50.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:50.650]                       search = base::search(), system = base::Sys.info())
[17:03:50.650]                   }
[17:03:50.650]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:50.650]                     cond$call), session = sessionInformation(), 
[17:03:50.650]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:50.650]                   signalCondition(cond)
[17:03:50.650]                 }
[17:03:50.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:50.650]                 "immediateCondition"))) {
[17:03:50.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:50.650]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:50.650]                   if (TRUE && !signal) {
[17:03:50.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.650]                     {
[17:03:50.650]                       inherits <- base::inherits
[17:03:50.650]                       invokeRestart <- base::invokeRestart
[17:03:50.650]                       is.null <- base::is.null
[17:03:50.650]                       muffled <- FALSE
[17:03:50.650]                       if (inherits(cond, "message")) {
[17:03:50.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.650]                         if (muffled) 
[17:03:50.650]                           invokeRestart("muffleMessage")
[17:03:50.650]                       }
[17:03:50.650]                       else if (inherits(cond, "warning")) {
[17:03:50.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.650]                         if (muffled) 
[17:03:50.650]                           invokeRestart("muffleWarning")
[17:03:50.650]                       }
[17:03:50.650]                       else if (inherits(cond, "condition")) {
[17:03:50.650]                         if (!is.null(pattern)) {
[17:03:50.650]                           computeRestarts <- base::computeRestarts
[17:03:50.650]                           grepl <- base::grepl
[17:03:50.650]                           restarts <- computeRestarts(cond)
[17:03:50.650]                           for (restart in restarts) {
[17:03:50.650]                             name <- restart$name
[17:03:50.650]                             if (is.null(name)) 
[17:03:50.650]                               next
[17:03:50.650]                             if (!grepl(pattern, name)) 
[17:03:50.650]                               next
[17:03:50.650]                             invokeRestart(restart)
[17:03:50.650]                             muffled <- TRUE
[17:03:50.650]                             break
[17:03:50.650]                           }
[17:03:50.650]                         }
[17:03:50.650]                       }
[17:03:50.650]                       invisible(muffled)
[17:03:50.650]                     }
[17:03:50.650]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.650]                   }
[17:03:50.650]                 }
[17:03:50.650]                 else {
[17:03:50.650]                   if (TRUE) {
[17:03:50.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.650]                     {
[17:03:50.650]                       inherits <- base::inherits
[17:03:50.650]                       invokeRestart <- base::invokeRestart
[17:03:50.650]                       is.null <- base::is.null
[17:03:50.650]                       muffled <- FALSE
[17:03:50.650]                       if (inherits(cond, "message")) {
[17:03:50.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.650]                         if (muffled) 
[17:03:50.650]                           invokeRestart("muffleMessage")
[17:03:50.650]                       }
[17:03:50.650]                       else if (inherits(cond, "warning")) {
[17:03:50.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.650]                         if (muffled) 
[17:03:50.650]                           invokeRestart("muffleWarning")
[17:03:50.650]                       }
[17:03:50.650]                       else if (inherits(cond, "condition")) {
[17:03:50.650]                         if (!is.null(pattern)) {
[17:03:50.650]                           computeRestarts <- base::computeRestarts
[17:03:50.650]                           grepl <- base::grepl
[17:03:50.650]                           restarts <- computeRestarts(cond)
[17:03:50.650]                           for (restart in restarts) {
[17:03:50.650]                             name <- restart$name
[17:03:50.650]                             if (is.null(name)) 
[17:03:50.650]                               next
[17:03:50.650]                             if (!grepl(pattern, name)) 
[17:03:50.650]                               next
[17:03:50.650]                             invokeRestart(restart)
[17:03:50.650]                             muffled <- TRUE
[17:03:50.650]                             break
[17:03:50.650]                           }
[17:03:50.650]                         }
[17:03:50.650]                       }
[17:03:50.650]                       invisible(muffled)
[17:03:50.650]                     }
[17:03:50.650]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.650]                   }
[17:03:50.650]                 }
[17:03:50.650]             }
[17:03:50.650]         }))
[17:03:50.650]     }, error = function(ex) {
[17:03:50.650]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:50.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.650]                 ...future.rng), started = ...future.startTime, 
[17:03:50.650]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:50.650]             version = "1.8"), class = "FutureResult")
[17:03:50.650]     }, finally = {
[17:03:50.650]         if (!identical(...future.workdir, getwd())) 
[17:03:50.650]             setwd(...future.workdir)
[17:03:50.650]         {
[17:03:50.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:50.650]                 ...future.oldOptions$nwarnings <- NULL
[17:03:50.650]             }
[17:03:50.650]             base::options(...future.oldOptions)
[17:03:50.650]             if (.Platform$OS.type == "windows") {
[17:03:50.650]                 old_names <- names(...future.oldEnvVars)
[17:03:50.650]                 envs <- base::Sys.getenv()
[17:03:50.650]                 names <- names(envs)
[17:03:50.650]                 common <- intersect(names, old_names)
[17:03:50.650]                 added <- setdiff(names, old_names)
[17:03:50.650]                 removed <- setdiff(old_names, names)
[17:03:50.650]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:50.650]                   envs[common]]
[17:03:50.650]                 NAMES <- toupper(changed)
[17:03:50.650]                 args <- list()
[17:03:50.650]                 for (kk in seq_along(NAMES)) {
[17:03:50.650]                   name <- changed[[kk]]
[17:03:50.650]                   NAME <- NAMES[[kk]]
[17:03:50.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.650]                     next
[17:03:50.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.650]                 }
[17:03:50.650]                 NAMES <- toupper(added)
[17:03:50.650]                 for (kk in seq_along(NAMES)) {
[17:03:50.650]                   name <- added[[kk]]
[17:03:50.650]                   NAME <- NAMES[[kk]]
[17:03:50.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.650]                     next
[17:03:50.650]                   args[[name]] <- ""
[17:03:50.650]                 }
[17:03:50.650]                 NAMES <- toupper(removed)
[17:03:50.650]                 for (kk in seq_along(NAMES)) {
[17:03:50.650]                   name <- removed[[kk]]
[17:03:50.650]                   NAME <- NAMES[[kk]]
[17:03:50.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.650]                     next
[17:03:50.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.650]                 }
[17:03:50.650]                 if (length(args) > 0) 
[17:03:50.650]                   base::do.call(base::Sys.setenv, args = args)
[17:03:50.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:50.650]             }
[17:03:50.650]             else {
[17:03:50.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:50.650]             }
[17:03:50.650]             {
[17:03:50.650]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:50.650]                   0L) {
[17:03:50.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:50.650]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:50.650]                   base::options(opts)
[17:03:50.650]                 }
[17:03:50.650]                 {
[17:03:50.650]                   {
[17:03:50.650]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:50.650]                     NULL
[17:03:50.650]                   }
[17:03:50.650]                   options(future.plan = NULL)
[17:03:50.650]                   if (is.na(NA_character_)) 
[17:03:50.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:50.650]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:50.650]                     .init = FALSE)
[17:03:50.650]                 }
[17:03:50.650]             }
[17:03:50.650]         }
[17:03:50.650]     })
[17:03:50.650]     if (TRUE) {
[17:03:50.650]         base::sink(type = "output", split = FALSE)
[17:03:50.650]         if (TRUE) {
[17:03:50.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:50.650]         }
[17:03:50.650]         else {
[17:03:50.650]             ...future.result["stdout"] <- base::list(NULL)
[17:03:50.650]         }
[17:03:50.650]         base::close(...future.stdout)
[17:03:50.650]         ...future.stdout <- NULL
[17:03:50.650]     }
[17:03:50.650]     ...future.result$conditions <- ...future.conditions
[17:03:50.650]     ...future.result$finished <- base::Sys.time()
[17:03:50.650]     ...future.result
[17:03:50.650] }
[17:03:50.653] MultisessionFuture started
[17:03:50.653] - Launch lazy future ... done
[17:03:50.653] run() for ‘MultisessionFuture’ ... done
[17:03:50.654] getGlobalsAndPackages() ...
[17:03:50.654] Searching for globals...
[17:03:50.655] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:50.655] Searching for globals ... DONE
[17:03:50.655] Resolving globals: FALSE
[17:03:50.655] 
[17:03:50.655] 
[17:03:50.656] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:03:50.656] getGlobalsAndPackages() ...
[17:03:50.656] Searching for globals...
[17:03:50.657] - globals found: [2] ‘list’, ‘stop’
[17:03:50.657] Searching for globals ... DONE
[17:03:50.657] Resolving globals: FALSE
[17:03:50.657] 
[17:03:50.657] 
[17:03:50.657] getGlobalsAndPackages() ... DONE
[17:03:50.657] run() for ‘Future’ ...
[17:03:50.658] - state: ‘created’
[17:03:50.658] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:50.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:50.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:50.672]   - Field: ‘node’
[17:03:50.672]   - Field: ‘label’
[17:03:50.672]   - Field: ‘local’
[17:03:50.672]   - Field: ‘owner’
[17:03:50.672]   - Field: ‘envir’
[17:03:50.672]   - Field: ‘workers’
[17:03:50.672]   - Field: ‘packages’
[17:03:50.672]   - Field: ‘gc’
[17:03:50.673]   - Field: ‘conditions’
[17:03:50.673]   - Field: ‘persistent’
[17:03:50.673]   - Field: ‘expr’
[17:03:50.673]   - Field: ‘uuid’
[17:03:50.673]   - Field: ‘seed’
[17:03:50.673]   - Field: ‘version’
[17:03:50.673]   - Field: ‘result’
[17:03:50.673]   - Field: ‘asynchronous’
[17:03:50.673]   - Field: ‘calls’
[17:03:50.673]   - Field: ‘globals’
[17:03:50.673]   - Field: ‘stdout’
[17:03:50.673]   - Field: ‘earlySignal’
[17:03:50.674]   - Field: ‘lazy’
[17:03:50.674]   - Field: ‘state’
[17:03:50.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:50.674] - Launch lazy future ...
[17:03:50.674] Packages needed by the future expression (n = 0): <none>
[17:03:50.674] Packages needed by future strategies (n = 0): <none>
[17:03:50.675] {
[17:03:50.675]     {
[17:03:50.675]         {
[17:03:50.675]             ...future.startTime <- base::Sys.time()
[17:03:50.675]             {
[17:03:50.675]                 {
[17:03:50.675]                   {
[17:03:50.675]                     {
[17:03:50.675]                       base::local({
[17:03:50.675]                         has_future <- base::requireNamespace("future", 
[17:03:50.675]                           quietly = TRUE)
[17:03:50.675]                         if (has_future) {
[17:03:50.675]                           ns <- base::getNamespace("future")
[17:03:50.675]                           version <- ns[[".package"]][["version"]]
[17:03:50.675]                           if (is.null(version)) 
[17:03:50.675]                             version <- utils::packageVersion("future")
[17:03:50.675]                         }
[17:03:50.675]                         else {
[17:03:50.675]                           version <- NULL
[17:03:50.675]                         }
[17:03:50.675]                         if (!has_future || version < "1.8.0") {
[17:03:50.675]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:50.675]                             "", base::R.version$version.string), 
[17:03:50.675]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:50.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:50.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:50.675]                               "release", "version")], collapse = " "), 
[17:03:50.675]                             hostname = base::Sys.info()[["nodename"]])
[17:03:50.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:50.675]                             info)
[17:03:50.675]                           info <- base::paste(info, collapse = "; ")
[17:03:50.675]                           if (!has_future) {
[17:03:50.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:50.675]                               info)
[17:03:50.675]                           }
[17:03:50.675]                           else {
[17:03:50.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:50.675]                               info, version)
[17:03:50.675]                           }
[17:03:50.675]                           base::stop(msg)
[17:03:50.675]                         }
[17:03:50.675]                       })
[17:03:50.675]                     }
[17:03:50.675]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:50.675]                     base::options(mc.cores = 1L)
[17:03:50.675]                   }
[17:03:50.675]                   ...future.strategy.old <- future::plan("list")
[17:03:50.675]                   options(future.plan = NULL)
[17:03:50.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:50.675]                 }
[17:03:50.675]                 ...future.workdir <- getwd()
[17:03:50.675]             }
[17:03:50.675]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:50.675]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:50.675]         }
[17:03:50.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:50.675]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:50.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:50.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:50.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:50.675]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:50.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:50.675]             base::names(...future.oldOptions))
[17:03:50.675]     }
[17:03:50.675]     if (FALSE) {
[17:03:50.675]     }
[17:03:50.675]     else {
[17:03:50.675]         if (TRUE) {
[17:03:50.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:50.675]                 open = "w")
[17:03:50.675]         }
[17:03:50.675]         else {
[17:03:50.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:50.675]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:50.675]         }
[17:03:50.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:50.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:50.675]             base::sink(type = "output", split = FALSE)
[17:03:50.675]             base::close(...future.stdout)
[17:03:50.675]         }, add = TRUE)
[17:03:50.675]     }
[17:03:50.675]     ...future.frame <- base::sys.nframe()
[17:03:50.675]     ...future.conditions <- base::list()
[17:03:50.675]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:50.675]     if (FALSE) {
[17:03:50.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:50.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:50.675]     }
[17:03:50.675]     ...future.result <- base::tryCatch({
[17:03:50.675]         base::withCallingHandlers({
[17:03:50.675]             ...future.value <- base::withVisible(base::local({
[17:03:50.675]                 ...future.makeSendCondition <- base::local({
[17:03:50.675]                   sendCondition <- NULL
[17:03:50.675]                   function(frame = 1L) {
[17:03:50.675]                     if (is.function(sendCondition)) 
[17:03:50.675]                       return(sendCondition)
[17:03:50.675]                     ns <- getNamespace("parallel")
[17:03:50.675]                     if (exists("sendData", mode = "function", 
[17:03:50.675]                       envir = ns)) {
[17:03:50.675]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:50.675]                         envir = ns)
[17:03:50.675]                       envir <- sys.frame(frame)
[17:03:50.675]                       master <- NULL
[17:03:50.675]                       while (!identical(envir, .GlobalEnv) && 
[17:03:50.675]                         !identical(envir, emptyenv())) {
[17:03:50.675]                         if (exists("master", mode = "list", envir = envir, 
[17:03:50.675]                           inherits = FALSE)) {
[17:03:50.675]                           master <- get("master", mode = "list", 
[17:03:50.675]                             envir = envir, inherits = FALSE)
[17:03:50.675]                           if (inherits(master, c("SOCKnode", 
[17:03:50.675]                             "SOCK0node"))) {
[17:03:50.675]                             sendCondition <<- function(cond) {
[17:03:50.675]                               data <- list(type = "VALUE", value = cond, 
[17:03:50.675]                                 success = TRUE)
[17:03:50.675]                               parallel_sendData(master, data)
[17:03:50.675]                             }
[17:03:50.675]                             return(sendCondition)
[17:03:50.675]                           }
[17:03:50.675]                         }
[17:03:50.675]                         frame <- frame + 1L
[17:03:50.675]                         envir <- sys.frame(frame)
[17:03:50.675]                       }
[17:03:50.675]                     }
[17:03:50.675]                     sendCondition <<- function(cond) NULL
[17:03:50.675]                   }
[17:03:50.675]                 })
[17:03:50.675]                 withCallingHandlers({
[17:03:50.675]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:50.675]                 }, immediateCondition = function(cond) {
[17:03:50.675]                   sendCondition <- ...future.makeSendCondition()
[17:03:50.675]                   sendCondition(cond)
[17:03:50.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.675]                   {
[17:03:50.675]                     inherits <- base::inherits
[17:03:50.675]                     invokeRestart <- base::invokeRestart
[17:03:50.675]                     is.null <- base::is.null
[17:03:50.675]                     muffled <- FALSE
[17:03:50.675]                     if (inherits(cond, "message")) {
[17:03:50.675]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:50.675]                       if (muffled) 
[17:03:50.675]                         invokeRestart("muffleMessage")
[17:03:50.675]                     }
[17:03:50.675]                     else if (inherits(cond, "warning")) {
[17:03:50.675]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:50.675]                       if (muffled) 
[17:03:50.675]                         invokeRestart("muffleWarning")
[17:03:50.675]                     }
[17:03:50.675]                     else if (inherits(cond, "condition")) {
[17:03:50.675]                       if (!is.null(pattern)) {
[17:03:50.675]                         computeRestarts <- base::computeRestarts
[17:03:50.675]                         grepl <- base::grepl
[17:03:50.675]                         restarts <- computeRestarts(cond)
[17:03:50.675]                         for (restart in restarts) {
[17:03:50.675]                           name <- restart$name
[17:03:50.675]                           if (is.null(name)) 
[17:03:50.675]                             next
[17:03:50.675]                           if (!grepl(pattern, name)) 
[17:03:50.675]                             next
[17:03:50.675]                           invokeRestart(restart)
[17:03:50.675]                           muffled <- TRUE
[17:03:50.675]                           break
[17:03:50.675]                         }
[17:03:50.675]                       }
[17:03:50.675]                     }
[17:03:50.675]                     invisible(muffled)
[17:03:50.675]                   }
[17:03:50.675]                   muffleCondition(cond)
[17:03:50.675]                 })
[17:03:50.675]             }))
[17:03:50.675]             future::FutureResult(value = ...future.value$value, 
[17:03:50.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.675]                   ...future.rng), globalenv = if (FALSE) 
[17:03:50.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:50.675]                     ...future.globalenv.names))
[17:03:50.675]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:50.675]         }, condition = base::local({
[17:03:50.675]             c <- base::c
[17:03:50.675]             inherits <- base::inherits
[17:03:50.675]             invokeRestart <- base::invokeRestart
[17:03:50.675]             length <- base::length
[17:03:50.675]             list <- base::list
[17:03:50.675]             seq.int <- base::seq.int
[17:03:50.675]             signalCondition <- base::signalCondition
[17:03:50.675]             sys.calls <- base::sys.calls
[17:03:50.675]             `[[` <- base::`[[`
[17:03:50.675]             `+` <- base::`+`
[17:03:50.675]             `<<-` <- base::`<<-`
[17:03:50.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:50.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:50.675]                   3L)]
[17:03:50.675]             }
[17:03:50.675]             function(cond) {
[17:03:50.675]                 is_error <- inherits(cond, "error")
[17:03:50.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:50.675]                   NULL)
[17:03:50.675]                 if (is_error) {
[17:03:50.675]                   sessionInformation <- function() {
[17:03:50.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:50.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:50.675]                       search = base::search(), system = base::Sys.info())
[17:03:50.675]                   }
[17:03:50.675]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:50.675]                     cond$call), session = sessionInformation(), 
[17:03:50.675]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:50.675]                   signalCondition(cond)
[17:03:50.675]                 }
[17:03:50.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:50.675]                 "immediateCondition"))) {
[17:03:50.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:50.675]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:50.675]                   if (TRUE && !signal) {
[17:03:50.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.675]                     {
[17:03:50.675]                       inherits <- base::inherits
[17:03:50.675]                       invokeRestart <- base::invokeRestart
[17:03:50.675]                       is.null <- base::is.null
[17:03:50.675]                       muffled <- FALSE
[17:03:50.675]                       if (inherits(cond, "message")) {
[17:03:50.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.675]                         if (muffled) 
[17:03:50.675]                           invokeRestart("muffleMessage")
[17:03:50.675]                       }
[17:03:50.675]                       else if (inherits(cond, "warning")) {
[17:03:50.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.675]                         if (muffled) 
[17:03:50.675]                           invokeRestart("muffleWarning")
[17:03:50.675]                       }
[17:03:50.675]                       else if (inherits(cond, "condition")) {
[17:03:50.675]                         if (!is.null(pattern)) {
[17:03:50.675]                           computeRestarts <- base::computeRestarts
[17:03:50.675]                           grepl <- base::grepl
[17:03:50.675]                           restarts <- computeRestarts(cond)
[17:03:50.675]                           for (restart in restarts) {
[17:03:50.675]                             name <- restart$name
[17:03:50.675]                             if (is.null(name)) 
[17:03:50.675]                               next
[17:03:50.675]                             if (!grepl(pattern, name)) 
[17:03:50.675]                               next
[17:03:50.675]                             invokeRestart(restart)
[17:03:50.675]                             muffled <- TRUE
[17:03:50.675]                             break
[17:03:50.675]                           }
[17:03:50.675]                         }
[17:03:50.675]                       }
[17:03:50.675]                       invisible(muffled)
[17:03:50.675]                     }
[17:03:50.675]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.675]                   }
[17:03:50.675]                 }
[17:03:50.675]                 else {
[17:03:50.675]                   if (TRUE) {
[17:03:50.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.675]                     {
[17:03:50.675]                       inherits <- base::inherits
[17:03:50.675]                       invokeRestart <- base::invokeRestart
[17:03:50.675]                       is.null <- base::is.null
[17:03:50.675]                       muffled <- FALSE
[17:03:50.675]                       if (inherits(cond, "message")) {
[17:03:50.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.675]                         if (muffled) 
[17:03:50.675]                           invokeRestart("muffleMessage")
[17:03:50.675]                       }
[17:03:50.675]                       else if (inherits(cond, "warning")) {
[17:03:50.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.675]                         if (muffled) 
[17:03:50.675]                           invokeRestart("muffleWarning")
[17:03:50.675]                       }
[17:03:50.675]                       else if (inherits(cond, "condition")) {
[17:03:50.675]                         if (!is.null(pattern)) {
[17:03:50.675]                           computeRestarts <- base::computeRestarts
[17:03:50.675]                           grepl <- base::grepl
[17:03:50.675]                           restarts <- computeRestarts(cond)
[17:03:50.675]                           for (restart in restarts) {
[17:03:50.675]                             name <- restart$name
[17:03:50.675]                             if (is.null(name)) 
[17:03:50.675]                               next
[17:03:50.675]                             if (!grepl(pattern, name)) 
[17:03:50.675]                               next
[17:03:50.675]                             invokeRestart(restart)
[17:03:50.675]                             muffled <- TRUE
[17:03:50.675]                             break
[17:03:50.675]                           }
[17:03:50.675]                         }
[17:03:50.675]                       }
[17:03:50.675]                       invisible(muffled)
[17:03:50.675]                     }
[17:03:50.675]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.675]                   }
[17:03:50.675]                 }
[17:03:50.675]             }
[17:03:50.675]         }))
[17:03:50.675]     }, error = function(ex) {
[17:03:50.675]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:50.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.675]                 ...future.rng), started = ...future.startTime, 
[17:03:50.675]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:50.675]             version = "1.8"), class = "FutureResult")
[17:03:50.675]     }, finally = {
[17:03:50.675]         if (!identical(...future.workdir, getwd())) 
[17:03:50.675]             setwd(...future.workdir)
[17:03:50.675]         {
[17:03:50.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:50.675]                 ...future.oldOptions$nwarnings <- NULL
[17:03:50.675]             }
[17:03:50.675]             base::options(...future.oldOptions)
[17:03:50.675]             if (.Platform$OS.type == "windows") {
[17:03:50.675]                 old_names <- names(...future.oldEnvVars)
[17:03:50.675]                 envs <- base::Sys.getenv()
[17:03:50.675]                 names <- names(envs)
[17:03:50.675]                 common <- intersect(names, old_names)
[17:03:50.675]                 added <- setdiff(names, old_names)
[17:03:50.675]                 removed <- setdiff(old_names, names)
[17:03:50.675]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:50.675]                   envs[common]]
[17:03:50.675]                 NAMES <- toupper(changed)
[17:03:50.675]                 args <- list()
[17:03:50.675]                 for (kk in seq_along(NAMES)) {
[17:03:50.675]                   name <- changed[[kk]]
[17:03:50.675]                   NAME <- NAMES[[kk]]
[17:03:50.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.675]                     next
[17:03:50.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.675]                 }
[17:03:50.675]                 NAMES <- toupper(added)
[17:03:50.675]                 for (kk in seq_along(NAMES)) {
[17:03:50.675]                   name <- added[[kk]]
[17:03:50.675]                   NAME <- NAMES[[kk]]
[17:03:50.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.675]                     next
[17:03:50.675]                   args[[name]] <- ""
[17:03:50.675]                 }
[17:03:50.675]                 NAMES <- toupper(removed)
[17:03:50.675]                 for (kk in seq_along(NAMES)) {
[17:03:50.675]                   name <- removed[[kk]]
[17:03:50.675]                   NAME <- NAMES[[kk]]
[17:03:50.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.675]                     next
[17:03:50.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.675]                 }
[17:03:50.675]                 if (length(args) > 0) 
[17:03:50.675]                   base::do.call(base::Sys.setenv, args = args)
[17:03:50.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:50.675]             }
[17:03:50.675]             else {
[17:03:50.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:50.675]             }
[17:03:50.675]             {
[17:03:50.675]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:50.675]                   0L) {
[17:03:50.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:50.675]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:50.675]                   base::options(opts)
[17:03:50.675]                 }
[17:03:50.675]                 {
[17:03:50.675]                   {
[17:03:50.675]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:50.675]                     NULL
[17:03:50.675]                   }
[17:03:50.675]                   options(future.plan = NULL)
[17:03:50.675]                   if (is.na(NA_character_)) 
[17:03:50.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:50.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:50.675]                     .init = FALSE)
[17:03:50.675]                 }
[17:03:50.675]             }
[17:03:50.675]         }
[17:03:50.675]     })
[17:03:50.675]     if (TRUE) {
[17:03:50.675]         base::sink(type = "output", split = FALSE)
[17:03:50.675]         if (TRUE) {
[17:03:50.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:50.675]         }
[17:03:50.675]         else {
[17:03:50.675]             ...future.result["stdout"] <- base::list(NULL)
[17:03:50.675]         }
[17:03:50.675]         base::close(...future.stdout)
[17:03:50.675]         ...future.stdout <- NULL
[17:03:50.675]     }
[17:03:50.675]     ...future.result$conditions <- ...future.conditions
[17:03:50.675]     ...future.result$finished <- base::Sys.time()
[17:03:50.675]     ...future.result
[17:03:50.675] }
[17:03:50.677] Poll #1 (0): usedNodes() = 2, workers = 2
[17:03:50.688] receiveMessageFromWorker() for ClusterFuture ...
[17:03:50.688] - Validating connection of MultisessionFuture
[17:03:50.688] - received message: FutureResult
[17:03:50.688] - Received FutureResult
[17:03:50.688] - Erased future from FutureRegistry
[17:03:50.688] result() for ClusterFuture ...
[17:03:50.688] - result already collected: FutureResult
[17:03:50.688] result() for ClusterFuture ... done
[17:03:50.688] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:50.689] result() for ClusterFuture ...
[17:03:50.689] - result already collected: FutureResult
[17:03:50.689] result() for ClusterFuture ... done
[17:03:50.689] result() for ClusterFuture ...
[17:03:50.689] - result already collected: FutureResult
[17:03:50.689] result() for ClusterFuture ... done
[17:03:50.690] MultisessionFuture started
[17:03:50.690] - Launch lazy future ... done
[17:03:50.690] run() for ‘MultisessionFuture’ ... done
[17:03:50.691] getGlobalsAndPackages() ...
[17:03:50.691] Searching for globals...
[17:03:50.692] - globals found: [2] ‘list’, ‘stop’
[17:03:50.692] Searching for globals ... DONE
[17:03:50.692] Resolving globals: FALSE
[17:03:50.693] 
[17:03:50.693] 
[17:03:50.693] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[17:03:50.693] getGlobalsAndPackages() ...
[17:03:50.694] Searching for globals...
[17:03:50.695] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:50.695] Searching for globals ... DONE
[17:03:50.695] Resolving globals: FALSE
[17:03:50.695] 
[17:03:50.695] 
[17:03:50.695] getGlobalsAndPackages() ... DONE
[17:03:50.695] run() for ‘Future’ ...
[17:03:50.696] - state: ‘created’
[17:03:50.696] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:50.709] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:50.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:50.709]   - Field: ‘node’
[17:03:50.710]   - Field: ‘label’
[17:03:50.710]   - Field: ‘local’
[17:03:50.710]   - Field: ‘owner’
[17:03:50.710]   - Field: ‘envir’
[17:03:50.710]   - Field: ‘workers’
[17:03:50.710]   - Field: ‘packages’
[17:03:50.710]   - Field: ‘gc’
[17:03:50.710]   - Field: ‘conditions’
[17:03:50.710]   - Field: ‘persistent’
[17:03:50.710]   - Field: ‘expr’
[17:03:50.710]   - Field: ‘uuid’
[17:03:50.711]   - Field: ‘seed’
[17:03:50.711]   - Field: ‘version’
[17:03:50.711]   - Field: ‘result’
[17:03:50.711]   - Field: ‘asynchronous’
[17:03:50.711]   - Field: ‘calls’
[17:03:50.711]   - Field: ‘globals’
[17:03:50.711]   - Field: ‘stdout’
[17:03:50.711]   - Field: ‘earlySignal’
[17:03:50.711]   - Field: ‘lazy’
[17:03:50.711]   - Field: ‘state’
[17:03:50.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:50.712] - Launch lazy future ...
[17:03:50.712] Packages needed by the future expression (n = 0): <none>
[17:03:50.712] Packages needed by future strategies (n = 0): <none>
[17:03:50.712] {
[17:03:50.712]     {
[17:03:50.712]         {
[17:03:50.712]             ...future.startTime <- base::Sys.time()
[17:03:50.712]             {
[17:03:50.712]                 {
[17:03:50.712]                   {
[17:03:50.712]                     {
[17:03:50.712]                       base::local({
[17:03:50.712]                         has_future <- base::requireNamespace("future", 
[17:03:50.712]                           quietly = TRUE)
[17:03:50.712]                         if (has_future) {
[17:03:50.712]                           ns <- base::getNamespace("future")
[17:03:50.712]                           version <- ns[[".package"]][["version"]]
[17:03:50.712]                           if (is.null(version)) 
[17:03:50.712]                             version <- utils::packageVersion("future")
[17:03:50.712]                         }
[17:03:50.712]                         else {
[17:03:50.712]                           version <- NULL
[17:03:50.712]                         }
[17:03:50.712]                         if (!has_future || version < "1.8.0") {
[17:03:50.712]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:50.712]                             "", base::R.version$version.string), 
[17:03:50.712]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:50.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:50.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:50.712]                               "release", "version")], collapse = " "), 
[17:03:50.712]                             hostname = base::Sys.info()[["nodename"]])
[17:03:50.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:50.712]                             info)
[17:03:50.712]                           info <- base::paste(info, collapse = "; ")
[17:03:50.712]                           if (!has_future) {
[17:03:50.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:50.712]                               info)
[17:03:50.712]                           }
[17:03:50.712]                           else {
[17:03:50.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:50.712]                               info, version)
[17:03:50.712]                           }
[17:03:50.712]                           base::stop(msg)
[17:03:50.712]                         }
[17:03:50.712]                       })
[17:03:50.712]                     }
[17:03:50.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:50.712]                     base::options(mc.cores = 1L)
[17:03:50.712]                   }
[17:03:50.712]                   ...future.strategy.old <- future::plan("list")
[17:03:50.712]                   options(future.plan = NULL)
[17:03:50.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:50.712]                 }
[17:03:50.712]                 ...future.workdir <- getwd()
[17:03:50.712]             }
[17:03:50.712]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:50.712]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:50.712]         }
[17:03:50.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:50.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:50.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:50.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:50.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:50.712]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:50.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:50.712]             base::names(...future.oldOptions))
[17:03:50.712]     }
[17:03:50.712]     if (FALSE) {
[17:03:50.712]     }
[17:03:50.712]     else {
[17:03:50.712]         if (TRUE) {
[17:03:50.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:50.712]                 open = "w")
[17:03:50.712]         }
[17:03:50.712]         else {
[17:03:50.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:50.712]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:50.712]         }
[17:03:50.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:50.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:50.712]             base::sink(type = "output", split = FALSE)
[17:03:50.712]             base::close(...future.stdout)
[17:03:50.712]         }, add = TRUE)
[17:03:50.712]     }
[17:03:50.712]     ...future.frame <- base::sys.nframe()
[17:03:50.712]     ...future.conditions <- base::list()
[17:03:50.712]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:50.712]     if (FALSE) {
[17:03:50.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:50.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:50.712]     }
[17:03:50.712]     ...future.result <- base::tryCatch({
[17:03:50.712]         base::withCallingHandlers({
[17:03:50.712]             ...future.value <- base::withVisible(base::local({
[17:03:50.712]                 ...future.makeSendCondition <- base::local({
[17:03:50.712]                   sendCondition <- NULL
[17:03:50.712]                   function(frame = 1L) {
[17:03:50.712]                     if (is.function(sendCondition)) 
[17:03:50.712]                       return(sendCondition)
[17:03:50.712]                     ns <- getNamespace("parallel")
[17:03:50.712]                     if (exists("sendData", mode = "function", 
[17:03:50.712]                       envir = ns)) {
[17:03:50.712]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:50.712]                         envir = ns)
[17:03:50.712]                       envir <- sys.frame(frame)
[17:03:50.712]                       master <- NULL
[17:03:50.712]                       while (!identical(envir, .GlobalEnv) && 
[17:03:50.712]                         !identical(envir, emptyenv())) {
[17:03:50.712]                         if (exists("master", mode = "list", envir = envir, 
[17:03:50.712]                           inherits = FALSE)) {
[17:03:50.712]                           master <- get("master", mode = "list", 
[17:03:50.712]                             envir = envir, inherits = FALSE)
[17:03:50.712]                           if (inherits(master, c("SOCKnode", 
[17:03:50.712]                             "SOCK0node"))) {
[17:03:50.712]                             sendCondition <<- function(cond) {
[17:03:50.712]                               data <- list(type = "VALUE", value = cond, 
[17:03:50.712]                                 success = TRUE)
[17:03:50.712]                               parallel_sendData(master, data)
[17:03:50.712]                             }
[17:03:50.712]                             return(sendCondition)
[17:03:50.712]                           }
[17:03:50.712]                         }
[17:03:50.712]                         frame <- frame + 1L
[17:03:50.712]                         envir <- sys.frame(frame)
[17:03:50.712]                       }
[17:03:50.712]                     }
[17:03:50.712]                     sendCondition <<- function(cond) NULL
[17:03:50.712]                   }
[17:03:50.712]                 })
[17:03:50.712]                 withCallingHandlers({
[17:03:50.712]                   {
[17:03:50.712]                     Sys.sleep(0.5)
[17:03:50.712]                     list(a = 1, b = 42L)
[17:03:50.712]                   }
[17:03:50.712]                 }, immediateCondition = function(cond) {
[17:03:50.712]                   sendCondition <- ...future.makeSendCondition()
[17:03:50.712]                   sendCondition(cond)
[17:03:50.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.712]                   {
[17:03:50.712]                     inherits <- base::inherits
[17:03:50.712]                     invokeRestart <- base::invokeRestart
[17:03:50.712]                     is.null <- base::is.null
[17:03:50.712]                     muffled <- FALSE
[17:03:50.712]                     if (inherits(cond, "message")) {
[17:03:50.712]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:50.712]                       if (muffled) 
[17:03:50.712]                         invokeRestart("muffleMessage")
[17:03:50.712]                     }
[17:03:50.712]                     else if (inherits(cond, "warning")) {
[17:03:50.712]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:50.712]                       if (muffled) 
[17:03:50.712]                         invokeRestart("muffleWarning")
[17:03:50.712]                     }
[17:03:50.712]                     else if (inherits(cond, "condition")) {
[17:03:50.712]                       if (!is.null(pattern)) {
[17:03:50.712]                         computeRestarts <- base::computeRestarts
[17:03:50.712]                         grepl <- base::grepl
[17:03:50.712]                         restarts <- computeRestarts(cond)
[17:03:50.712]                         for (restart in restarts) {
[17:03:50.712]                           name <- restart$name
[17:03:50.712]                           if (is.null(name)) 
[17:03:50.712]                             next
[17:03:50.712]                           if (!grepl(pattern, name)) 
[17:03:50.712]                             next
[17:03:50.712]                           invokeRestart(restart)
[17:03:50.712]                           muffled <- TRUE
[17:03:50.712]                           break
[17:03:50.712]                         }
[17:03:50.712]                       }
[17:03:50.712]                     }
[17:03:50.712]                     invisible(muffled)
[17:03:50.712]                   }
[17:03:50.712]                   muffleCondition(cond)
[17:03:50.712]                 })
[17:03:50.712]             }))
[17:03:50.712]             future::FutureResult(value = ...future.value$value, 
[17:03:50.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.712]                   ...future.rng), globalenv = if (FALSE) 
[17:03:50.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:50.712]                     ...future.globalenv.names))
[17:03:50.712]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:50.712]         }, condition = base::local({
[17:03:50.712]             c <- base::c
[17:03:50.712]             inherits <- base::inherits
[17:03:50.712]             invokeRestart <- base::invokeRestart
[17:03:50.712]             length <- base::length
[17:03:50.712]             list <- base::list
[17:03:50.712]             seq.int <- base::seq.int
[17:03:50.712]             signalCondition <- base::signalCondition
[17:03:50.712]             sys.calls <- base::sys.calls
[17:03:50.712]             `[[` <- base::`[[`
[17:03:50.712]             `+` <- base::`+`
[17:03:50.712]             `<<-` <- base::`<<-`
[17:03:50.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:50.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:50.712]                   3L)]
[17:03:50.712]             }
[17:03:50.712]             function(cond) {
[17:03:50.712]                 is_error <- inherits(cond, "error")
[17:03:50.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:50.712]                   NULL)
[17:03:50.712]                 if (is_error) {
[17:03:50.712]                   sessionInformation <- function() {
[17:03:50.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:50.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:50.712]                       search = base::search(), system = base::Sys.info())
[17:03:50.712]                   }
[17:03:50.712]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:50.712]                     cond$call), session = sessionInformation(), 
[17:03:50.712]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:50.712]                   signalCondition(cond)
[17:03:50.712]                 }
[17:03:50.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:50.712]                 "immediateCondition"))) {
[17:03:50.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:50.712]                   ...future.conditions[[length(...future.conditions) + 
[17:03:50.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:50.712]                   if (TRUE && !signal) {
[17:03:50.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.712]                     {
[17:03:50.712]                       inherits <- base::inherits
[17:03:50.712]                       invokeRestart <- base::invokeRestart
[17:03:50.712]                       is.null <- base::is.null
[17:03:50.712]                       muffled <- FALSE
[17:03:50.712]                       if (inherits(cond, "message")) {
[17:03:50.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.712]                         if (muffled) 
[17:03:50.712]                           invokeRestart("muffleMessage")
[17:03:50.712]                       }
[17:03:50.712]                       else if (inherits(cond, "warning")) {
[17:03:50.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.712]                         if (muffled) 
[17:03:50.712]                           invokeRestart("muffleWarning")
[17:03:50.712]                       }
[17:03:50.712]                       else if (inherits(cond, "condition")) {
[17:03:50.712]                         if (!is.null(pattern)) {
[17:03:50.712]                           computeRestarts <- base::computeRestarts
[17:03:50.712]                           grepl <- base::grepl
[17:03:50.712]                           restarts <- computeRestarts(cond)
[17:03:50.712]                           for (restart in restarts) {
[17:03:50.712]                             name <- restart$name
[17:03:50.712]                             if (is.null(name)) 
[17:03:50.712]                               next
[17:03:50.712]                             if (!grepl(pattern, name)) 
[17:03:50.712]                               next
[17:03:50.712]                             invokeRestart(restart)
[17:03:50.712]                             muffled <- TRUE
[17:03:50.712]                             break
[17:03:50.712]                           }
[17:03:50.712]                         }
[17:03:50.712]                       }
[17:03:50.712]                       invisible(muffled)
[17:03:50.712]                     }
[17:03:50.712]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.712]                   }
[17:03:50.712]                 }
[17:03:50.712]                 else {
[17:03:50.712]                   if (TRUE) {
[17:03:50.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:50.712]                     {
[17:03:50.712]                       inherits <- base::inherits
[17:03:50.712]                       invokeRestart <- base::invokeRestart
[17:03:50.712]                       is.null <- base::is.null
[17:03:50.712]                       muffled <- FALSE
[17:03:50.712]                       if (inherits(cond, "message")) {
[17:03:50.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:50.712]                         if (muffled) 
[17:03:50.712]                           invokeRestart("muffleMessage")
[17:03:50.712]                       }
[17:03:50.712]                       else if (inherits(cond, "warning")) {
[17:03:50.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:50.712]                         if (muffled) 
[17:03:50.712]                           invokeRestart("muffleWarning")
[17:03:50.712]                       }
[17:03:50.712]                       else if (inherits(cond, "condition")) {
[17:03:50.712]                         if (!is.null(pattern)) {
[17:03:50.712]                           computeRestarts <- base::computeRestarts
[17:03:50.712]                           grepl <- base::grepl
[17:03:50.712]                           restarts <- computeRestarts(cond)
[17:03:50.712]                           for (restart in restarts) {
[17:03:50.712]                             name <- restart$name
[17:03:50.712]                             if (is.null(name)) 
[17:03:50.712]                               next
[17:03:50.712]                             if (!grepl(pattern, name)) 
[17:03:50.712]                               next
[17:03:50.712]                             invokeRestart(restart)
[17:03:50.712]                             muffled <- TRUE
[17:03:50.712]                             break
[17:03:50.712]                           }
[17:03:50.712]                         }
[17:03:50.712]                       }
[17:03:50.712]                       invisible(muffled)
[17:03:50.712]                     }
[17:03:50.712]                     muffleCondition(cond, pattern = "^muffle")
[17:03:50.712]                   }
[17:03:50.712]                 }
[17:03:50.712]             }
[17:03:50.712]         }))
[17:03:50.712]     }, error = function(ex) {
[17:03:50.712]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:50.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:50.712]                 ...future.rng), started = ...future.startTime, 
[17:03:50.712]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:50.712]             version = "1.8"), class = "FutureResult")
[17:03:50.712]     }, finally = {
[17:03:50.712]         if (!identical(...future.workdir, getwd())) 
[17:03:50.712]             setwd(...future.workdir)
[17:03:50.712]         {
[17:03:50.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:50.712]                 ...future.oldOptions$nwarnings <- NULL
[17:03:50.712]             }
[17:03:50.712]             base::options(...future.oldOptions)
[17:03:50.712]             if (.Platform$OS.type == "windows") {
[17:03:50.712]                 old_names <- names(...future.oldEnvVars)
[17:03:50.712]                 envs <- base::Sys.getenv()
[17:03:50.712]                 names <- names(envs)
[17:03:50.712]                 common <- intersect(names, old_names)
[17:03:50.712]                 added <- setdiff(names, old_names)
[17:03:50.712]                 removed <- setdiff(old_names, names)
[17:03:50.712]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:50.712]                   envs[common]]
[17:03:50.712]                 NAMES <- toupper(changed)
[17:03:50.712]                 args <- list()
[17:03:50.712]                 for (kk in seq_along(NAMES)) {
[17:03:50.712]                   name <- changed[[kk]]
[17:03:50.712]                   NAME <- NAMES[[kk]]
[17:03:50.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.712]                     next
[17:03:50.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.712]                 }
[17:03:50.712]                 NAMES <- toupper(added)
[17:03:50.712]                 for (kk in seq_along(NAMES)) {
[17:03:50.712]                   name <- added[[kk]]
[17:03:50.712]                   NAME <- NAMES[[kk]]
[17:03:50.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.712]                     next
[17:03:50.712]                   args[[name]] <- ""
[17:03:50.712]                 }
[17:03:50.712]                 NAMES <- toupper(removed)
[17:03:50.712]                 for (kk in seq_along(NAMES)) {
[17:03:50.712]                   name <- removed[[kk]]
[17:03:50.712]                   NAME <- NAMES[[kk]]
[17:03:50.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:50.712]                     next
[17:03:50.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:50.712]                 }
[17:03:50.712]                 if (length(args) > 0) 
[17:03:50.712]                   base::do.call(base::Sys.setenv, args = args)
[17:03:50.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:50.712]             }
[17:03:50.712]             else {
[17:03:50.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:50.712]             }
[17:03:50.712]             {
[17:03:50.712]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:50.712]                   0L) {
[17:03:50.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:50.712]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:50.712]                   base::options(opts)
[17:03:50.712]                 }
[17:03:50.712]                 {
[17:03:50.712]                   {
[17:03:50.712]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:50.712]                     NULL
[17:03:50.712]                   }
[17:03:50.712]                   options(future.plan = NULL)
[17:03:50.712]                   if (is.na(NA_character_)) 
[17:03:50.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:50.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:50.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:50.712]                     .init = FALSE)
[17:03:50.712]                 }
[17:03:50.712]             }
[17:03:50.712]         }
[17:03:50.712]     })
[17:03:50.712]     if (TRUE) {
[17:03:50.712]         base::sink(type = "output", split = FALSE)
[17:03:50.712]         if (TRUE) {
[17:03:50.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:50.712]         }
[17:03:50.712]         else {
[17:03:50.712]             ...future.result["stdout"] <- base::list(NULL)
[17:03:50.712]         }
[17:03:50.712]         base::close(...future.stdout)
[17:03:50.712]         ...future.stdout <- NULL
[17:03:50.712]     }
[17:03:50.712]     ...future.result$conditions <- ...future.conditions
[17:03:50.712]     ...future.result$finished <- base::Sys.time()
[17:03:50.712]     ...future.result
[17:03:50.712] }
[17:03:50.715] Poll #1 (0): usedNodes() = 2, workers = 2
[17:03:50.736] receiveMessageFromWorker() for ClusterFuture ...
[17:03:50.736] - Validating connection of MultisessionFuture
[17:03:50.737] - received message: FutureResult
[17:03:50.737] - Received FutureResult
[17:03:50.737] - Erased future from FutureRegistry
[17:03:50.737] result() for ClusterFuture ...
[17:03:50.737] - result already collected: FutureResult
[17:03:50.737] result() for ClusterFuture ... done
[17:03:50.737] signalConditions() ...
[17:03:50.737]  - include = ‘immediateCondition’
[17:03:50.737]  - exclude = 
[17:03:50.737]  - resignal = FALSE
[17:03:50.737]  - Number of conditions: 1
[17:03:50.738] signalConditions() ... done
[17:03:50.738] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:50.738] result() for ClusterFuture ...
[17:03:50.738] - result already collected: FutureResult
[17:03:50.738] result() for ClusterFuture ... done
[17:03:50.738] result() for ClusterFuture ...
[17:03:50.738] - result already collected: FutureResult
[17:03:50.738] result() for ClusterFuture ... done
[17:03:50.738] signalConditions() ...
[17:03:50.738]  - include = ‘immediateCondition’
[17:03:50.738]  - exclude = 
[17:03:50.738]  - resignal = FALSE
[17:03:50.739]  - Number of conditions: 1
[17:03:50.739] signalConditions() ... done
[17:03:50.740] MultisessionFuture started
[17:03:50.740] - Launch lazy future ... done
[17:03:50.740] run() for ‘MultisessionFuture’ ... done
[17:03:51.243] receiveMessageFromWorker() for ClusterFuture ...
[17:03:51.243] - Validating connection of MultisessionFuture
[17:03:51.243] - received message: FutureResult
[17:03:51.243] - Received FutureResult
[17:03:51.243] - Erased future from FutureRegistry
[17:03:51.244] result() for ClusterFuture ...
[17:03:51.244] - result already collected: FutureResult
[17:03:51.244] result() for ClusterFuture ... done
[17:03:51.244] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:51.244] A MultisessionFuture was resolved
[17:03:51.244] getGlobalsAndPackages() ...
[17:03:51.244] Searching for globals...
[17:03:51.245] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:51.245] Searching for globals ... DONE
[17:03:51.246] Resolving globals: FALSE
[17:03:51.246] 
[17:03:51.246] 
[17:03:51.246] getGlobalsAndPackages() ... DONE
[17:03:51.246] run() for ‘Future’ ...
[17:03:51.246] - state: ‘created’
[17:03:51.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:51.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:51.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:51.261]   - Field: ‘node’
[17:03:51.261]   - Field: ‘label’
[17:03:51.261]   - Field: ‘local’
[17:03:51.261]   - Field: ‘owner’
[17:03:51.261]   - Field: ‘envir’
[17:03:51.261]   - Field: ‘workers’
[17:03:51.261]   - Field: ‘packages’
[17:03:51.262]   - Field: ‘gc’
[17:03:51.262]   - Field: ‘conditions’
[17:03:51.262]   - Field: ‘persistent’
[17:03:51.262]   - Field: ‘expr’
[17:03:51.262]   - Field: ‘uuid’
[17:03:51.262]   - Field: ‘seed’
[17:03:51.262]   - Field: ‘version’
[17:03:51.262]   - Field: ‘result’
[17:03:51.262]   - Field: ‘asynchronous’
[17:03:51.262]   - Field: ‘calls’
[17:03:51.262]   - Field: ‘globals’
[17:03:51.263]   - Field: ‘stdout’
[17:03:51.263]   - Field: ‘earlySignal’
[17:03:51.263]   - Field: ‘lazy’
[17:03:51.263]   - Field: ‘state’
[17:03:51.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:51.263] - Launch lazy future ...
[17:03:51.263] Packages needed by the future expression (n = 0): <none>
[17:03:51.263] Packages needed by future strategies (n = 0): <none>
[17:03:51.264] {
[17:03:51.264]     {
[17:03:51.264]         {
[17:03:51.264]             ...future.startTime <- base::Sys.time()
[17:03:51.264]             {
[17:03:51.264]                 {
[17:03:51.264]                   {
[17:03:51.264]                     {
[17:03:51.264]                       base::local({
[17:03:51.264]                         has_future <- base::requireNamespace("future", 
[17:03:51.264]                           quietly = TRUE)
[17:03:51.264]                         if (has_future) {
[17:03:51.264]                           ns <- base::getNamespace("future")
[17:03:51.264]                           version <- ns[[".package"]][["version"]]
[17:03:51.264]                           if (is.null(version)) 
[17:03:51.264]                             version <- utils::packageVersion("future")
[17:03:51.264]                         }
[17:03:51.264]                         else {
[17:03:51.264]                           version <- NULL
[17:03:51.264]                         }
[17:03:51.264]                         if (!has_future || version < "1.8.0") {
[17:03:51.264]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:51.264]                             "", base::R.version$version.string), 
[17:03:51.264]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:51.264]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:51.264]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:51.264]                               "release", "version")], collapse = " "), 
[17:03:51.264]                             hostname = base::Sys.info()[["nodename"]])
[17:03:51.264]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:51.264]                             info)
[17:03:51.264]                           info <- base::paste(info, collapse = "; ")
[17:03:51.264]                           if (!has_future) {
[17:03:51.264]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:51.264]                               info)
[17:03:51.264]                           }
[17:03:51.264]                           else {
[17:03:51.264]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:51.264]                               info, version)
[17:03:51.264]                           }
[17:03:51.264]                           base::stop(msg)
[17:03:51.264]                         }
[17:03:51.264]                       })
[17:03:51.264]                     }
[17:03:51.264]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:51.264]                     base::options(mc.cores = 1L)
[17:03:51.264]                   }
[17:03:51.264]                   ...future.strategy.old <- future::plan("list")
[17:03:51.264]                   options(future.plan = NULL)
[17:03:51.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:51.264]                 }
[17:03:51.264]                 ...future.workdir <- getwd()
[17:03:51.264]             }
[17:03:51.264]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:51.264]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:51.264]         }
[17:03:51.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:51.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:51.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:51.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:51.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:51.264]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:51.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:51.264]             base::names(...future.oldOptions))
[17:03:51.264]     }
[17:03:51.264]     if (FALSE) {
[17:03:51.264]     }
[17:03:51.264]     else {
[17:03:51.264]         if (TRUE) {
[17:03:51.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:51.264]                 open = "w")
[17:03:51.264]         }
[17:03:51.264]         else {
[17:03:51.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:51.264]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:51.264]         }
[17:03:51.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:51.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:51.264]             base::sink(type = "output", split = FALSE)
[17:03:51.264]             base::close(...future.stdout)
[17:03:51.264]         }, add = TRUE)
[17:03:51.264]     }
[17:03:51.264]     ...future.frame <- base::sys.nframe()
[17:03:51.264]     ...future.conditions <- base::list()
[17:03:51.264]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:51.264]     if (FALSE) {
[17:03:51.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:51.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:51.264]     }
[17:03:51.264]     ...future.result <- base::tryCatch({
[17:03:51.264]         base::withCallingHandlers({
[17:03:51.264]             ...future.value <- base::withVisible(base::local({
[17:03:51.264]                 ...future.makeSendCondition <- base::local({
[17:03:51.264]                   sendCondition <- NULL
[17:03:51.264]                   function(frame = 1L) {
[17:03:51.264]                     if (is.function(sendCondition)) 
[17:03:51.264]                       return(sendCondition)
[17:03:51.264]                     ns <- getNamespace("parallel")
[17:03:51.264]                     if (exists("sendData", mode = "function", 
[17:03:51.264]                       envir = ns)) {
[17:03:51.264]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:51.264]                         envir = ns)
[17:03:51.264]                       envir <- sys.frame(frame)
[17:03:51.264]                       master <- NULL
[17:03:51.264]                       while (!identical(envir, .GlobalEnv) && 
[17:03:51.264]                         !identical(envir, emptyenv())) {
[17:03:51.264]                         if (exists("master", mode = "list", envir = envir, 
[17:03:51.264]                           inherits = FALSE)) {
[17:03:51.264]                           master <- get("master", mode = "list", 
[17:03:51.264]                             envir = envir, inherits = FALSE)
[17:03:51.264]                           if (inherits(master, c("SOCKnode", 
[17:03:51.264]                             "SOCK0node"))) {
[17:03:51.264]                             sendCondition <<- function(cond) {
[17:03:51.264]                               data <- list(type = "VALUE", value = cond, 
[17:03:51.264]                                 success = TRUE)
[17:03:51.264]                               parallel_sendData(master, data)
[17:03:51.264]                             }
[17:03:51.264]                             return(sendCondition)
[17:03:51.264]                           }
[17:03:51.264]                         }
[17:03:51.264]                         frame <- frame + 1L
[17:03:51.264]                         envir <- sys.frame(frame)
[17:03:51.264]                       }
[17:03:51.264]                     }
[17:03:51.264]                     sendCondition <<- function(cond) NULL
[17:03:51.264]                   }
[17:03:51.264]                 })
[17:03:51.264]                 withCallingHandlers({
[17:03:51.264]                   {
[17:03:51.264]                     Sys.sleep(0.5)
[17:03:51.264]                     list(a = 1, b = 42L)
[17:03:51.264]                   }
[17:03:51.264]                 }, immediateCondition = function(cond) {
[17:03:51.264]                   sendCondition <- ...future.makeSendCondition()
[17:03:51.264]                   sendCondition(cond)
[17:03:51.264]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.264]                   {
[17:03:51.264]                     inherits <- base::inherits
[17:03:51.264]                     invokeRestart <- base::invokeRestart
[17:03:51.264]                     is.null <- base::is.null
[17:03:51.264]                     muffled <- FALSE
[17:03:51.264]                     if (inherits(cond, "message")) {
[17:03:51.264]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:51.264]                       if (muffled) 
[17:03:51.264]                         invokeRestart("muffleMessage")
[17:03:51.264]                     }
[17:03:51.264]                     else if (inherits(cond, "warning")) {
[17:03:51.264]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:51.264]                       if (muffled) 
[17:03:51.264]                         invokeRestart("muffleWarning")
[17:03:51.264]                     }
[17:03:51.264]                     else if (inherits(cond, "condition")) {
[17:03:51.264]                       if (!is.null(pattern)) {
[17:03:51.264]                         computeRestarts <- base::computeRestarts
[17:03:51.264]                         grepl <- base::grepl
[17:03:51.264]                         restarts <- computeRestarts(cond)
[17:03:51.264]                         for (restart in restarts) {
[17:03:51.264]                           name <- restart$name
[17:03:51.264]                           if (is.null(name)) 
[17:03:51.264]                             next
[17:03:51.264]                           if (!grepl(pattern, name)) 
[17:03:51.264]                             next
[17:03:51.264]                           invokeRestart(restart)
[17:03:51.264]                           muffled <- TRUE
[17:03:51.264]                           break
[17:03:51.264]                         }
[17:03:51.264]                       }
[17:03:51.264]                     }
[17:03:51.264]                     invisible(muffled)
[17:03:51.264]                   }
[17:03:51.264]                   muffleCondition(cond)
[17:03:51.264]                 })
[17:03:51.264]             }))
[17:03:51.264]             future::FutureResult(value = ...future.value$value, 
[17:03:51.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.264]                   ...future.rng), globalenv = if (FALSE) 
[17:03:51.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:51.264]                     ...future.globalenv.names))
[17:03:51.264]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:51.264]         }, condition = base::local({
[17:03:51.264]             c <- base::c
[17:03:51.264]             inherits <- base::inherits
[17:03:51.264]             invokeRestart <- base::invokeRestart
[17:03:51.264]             length <- base::length
[17:03:51.264]             list <- base::list
[17:03:51.264]             seq.int <- base::seq.int
[17:03:51.264]             signalCondition <- base::signalCondition
[17:03:51.264]             sys.calls <- base::sys.calls
[17:03:51.264]             `[[` <- base::`[[`
[17:03:51.264]             `+` <- base::`+`
[17:03:51.264]             `<<-` <- base::`<<-`
[17:03:51.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:51.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:51.264]                   3L)]
[17:03:51.264]             }
[17:03:51.264]             function(cond) {
[17:03:51.264]                 is_error <- inherits(cond, "error")
[17:03:51.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:51.264]                   NULL)
[17:03:51.264]                 if (is_error) {
[17:03:51.264]                   sessionInformation <- function() {
[17:03:51.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:51.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:51.264]                       search = base::search(), system = base::Sys.info())
[17:03:51.264]                   }
[17:03:51.264]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:51.264]                     cond$call), session = sessionInformation(), 
[17:03:51.264]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:51.264]                   signalCondition(cond)
[17:03:51.264]                 }
[17:03:51.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:51.264]                 "immediateCondition"))) {
[17:03:51.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:51.264]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:51.264]                   if (TRUE && !signal) {
[17:03:51.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.264]                     {
[17:03:51.264]                       inherits <- base::inherits
[17:03:51.264]                       invokeRestart <- base::invokeRestart
[17:03:51.264]                       is.null <- base::is.null
[17:03:51.264]                       muffled <- FALSE
[17:03:51.264]                       if (inherits(cond, "message")) {
[17:03:51.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.264]                         if (muffled) 
[17:03:51.264]                           invokeRestart("muffleMessage")
[17:03:51.264]                       }
[17:03:51.264]                       else if (inherits(cond, "warning")) {
[17:03:51.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.264]                         if (muffled) 
[17:03:51.264]                           invokeRestart("muffleWarning")
[17:03:51.264]                       }
[17:03:51.264]                       else if (inherits(cond, "condition")) {
[17:03:51.264]                         if (!is.null(pattern)) {
[17:03:51.264]                           computeRestarts <- base::computeRestarts
[17:03:51.264]                           grepl <- base::grepl
[17:03:51.264]                           restarts <- computeRestarts(cond)
[17:03:51.264]                           for (restart in restarts) {
[17:03:51.264]                             name <- restart$name
[17:03:51.264]                             if (is.null(name)) 
[17:03:51.264]                               next
[17:03:51.264]                             if (!grepl(pattern, name)) 
[17:03:51.264]                               next
[17:03:51.264]                             invokeRestart(restart)
[17:03:51.264]                             muffled <- TRUE
[17:03:51.264]                             break
[17:03:51.264]                           }
[17:03:51.264]                         }
[17:03:51.264]                       }
[17:03:51.264]                       invisible(muffled)
[17:03:51.264]                     }
[17:03:51.264]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.264]                   }
[17:03:51.264]                 }
[17:03:51.264]                 else {
[17:03:51.264]                   if (TRUE) {
[17:03:51.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.264]                     {
[17:03:51.264]                       inherits <- base::inherits
[17:03:51.264]                       invokeRestart <- base::invokeRestart
[17:03:51.264]                       is.null <- base::is.null
[17:03:51.264]                       muffled <- FALSE
[17:03:51.264]                       if (inherits(cond, "message")) {
[17:03:51.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.264]                         if (muffled) 
[17:03:51.264]                           invokeRestart("muffleMessage")
[17:03:51.264]                       }
[17:03:51.264]                       else if (inherits(cond, "warning")) {
[17:03:51.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.264]                         if (muffled) 
[17:03:51.264]                           invokeRestart("muffleWarning")
[17:03:51.264]                       }
[17:03:51.264]                       else if (inherits(cond, "condition")) {
[17:03:51.264]                         if (!is.null(pattern)) {
[17:03:51.264]                           computeRestarts <- base::computeRestarts
[17:03:51.264]                           grepl <- base::grepl
[17:03:51.264]                           restarts <- computeRestarts(cond)
[17:03:51.264]                           for (restart in restarts) {
[17:03:51.264]                             name <- restart$name
[17:03:51.264]                             if (is.null(name)) 
[17:03:51.264]                               next
[17:03:51.264]                             if (!grepl(pattern, name)) 
[17:03:51.264]                               next
[17:03:51.264]                             invokeRestart(restart)
[17:03:51.264]                             muffled <- TRUE
[17:03:51.264]                             break
[17:03:51.264]                           }
[17:03:51.264]                         }
[17:03:51.264]                       }
[17:03:51.264]                       invisible(muffled)
[17:03:51.264]                     }
[17:03:51.264]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.264]                   }
[17:03:51.264]                 }
[17:03:51.264]             }
[17:03:51.264]         }))
[17:03:51.264]     }, error = function(ex) {
[17:03:51.264]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:51.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.264]                 ...future.rng), started = ...future.startTime, 
[17:03:51.264]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:51.264]             version = "1.8"), class = "FutureResult")
[17:03:51.264]     }, finally = {
[17:03:51.264]         if (!identical(...future.workdir, getwd())) 
[17:03:51.264]             setwd(...future.workdir)
[17:03:51.264]         {
[17:03:51.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:51.264]                 ...future.oldOptions$nwarnings <- NULL
[17:03:51.264]             }
[17:03:51.264]             base::options(...future.oldOptions)
[17:03:51.264]             if (.Platform$OS.type == "windows") {
[17:03:51.264]                 old_names <- names(...future.oldEnvVars)
[17:03:51.264]                 envs <- base::Sys.getenv()
[17:03:51.264]                 names <- names(envs)
[17:03:51.264]                 common <- intersect(names, old_names)
[17:03:51.264]                 added <- setdiff(names, old_names)
[17:03:51.264]                 removed <- setdiff(old_names, names)
[17:03:51.264]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:51.264]                   envs[common]]
[17:03:51.264]                 NAMES <- toupper(changed)
[17:03:51.264]                 args <- list()
[17:03:51.264]                 for (kk in seq_along(NAMES)) {
[17:03:51.264]                   name <- changed[[kk]]
[17:03:51.264]                   NAME <- NAMES[[kk]]
[17:03:51.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.264]                     next
[17:03:51.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.264]                 }
[17:03:51.264]                 NAMES <- toupper(added)
[17:03:51.264]                 for (kk in seq_along(NAMES)) {
[17:03:51.264]                   name <- added[[kk]]
[17:03:51.264]                   NAME <- NAMES[[kk]]
[17:03:51.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.264]                     next
[17:03:51.264]                   args[[name]] <- ""
[17:03:51.264]                 }
[17:03:51.264]                 NAMES <- toupper(removed)
[17:03:51.264]                 for (kk in seq_along(NAMES)) {
[17:03:51.264]                   name <- removed[[kk]]
[17:03:51.264]                   NAME <- NAMES[[kk]]
[17:03:51.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.264]                     next
[17:03:51.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.264]                 }
[17:03:51.264]                 if (length(args) > 0) 
[17:03:51.264]                   base::do.call(base::Sys.setenv, args = args)
[17:03:51.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:51.264]             }
[17:03:51.264]             else {
[17:03:51.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:51.264]             }
[17:03:51.264]             {
[17:03:51.264]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:51.264]                   0L) {
[17:03:51.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:51.264]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:51.264]                   base::options(opts)
[17:03:51.264]                 }
[17:03:51.264]                 {
[17:03:51.264]                   {
[17:03:51.264]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:51.264]                     NULL
[17:03:51.264]                   }
[17:03:51.264]                   options(future.plan = NULL)
[17:03:51.264]                   if (is.na(NA_character_)) 
[17:03:51.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:51.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:51.264]                     .init = FALSE)
[17:03:51.264]                 }
[17:03:51.264]             }
[17:03:51.264]         }
[17:03:51.264]     })
[17:03:51.264]     if (TRUE) {
[17:03:51.264]         base::sink(type = "output", split = FALSE)
[17:03:51.264]         if (TRUE) {
[17:03:51.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:51.264]         }
[17:03:51.264]         else {
[17:03:51.264]             ...future.result["stdout"] <- base::list(NULL)
[17:03:51.264]         }
[17:03:51.264]         base::close(...future.stdout)
[17:03:51.264]         ...future.stdout <- NULL
[17:03:51.264]     }
[17:03:51.264]     ...future.result$conditions <- ...future.conditions
[17:03:51.264]     ...future.result$finished <- base::Sys.time()
[17:03:51.264]     ...future.result
[17:03:51.264] }
[17:03:51.267] MultisessionFuture started
[17:03:51.267] - Launch lazy future ... done
[17:03:51.267] run() for ‘MultisessionFuture’ ... done
[17:03:51.770] receiveMessageFromWorker() for ClusterFuture ...
[17:03:51.770] - Validating connection of MultisessionFuture
[17:03:51.770] - received message: FutureResult
[17:03:51.770] - Received FutureResult
[17:03:51.770] - Erased future from FutureRegistry
[17:03:51.771] result() for ClusterFuture ...
[17:03:51.771] - result already collected: FutureResult
[17:03:51.771] result() for ClusterFuture ... done
[17:03:51.771] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:51.771] A MultisessionFuture was resolved
- w/ exception ...
[17:03:51.771] getGlobalsAndPackages() ...
[17:03:51.771] Searching for globals...
[17:03:51.772] - globals found: [2] ‘list’, ‘stop’
[17:03:51.772] Searching for globals ... DONE
[17:03:51.772] Resolving globals: FALSE
[17:03:51.772] 
[17:03:51.772] 
[17:03:51.773] getGlobalsAndPackages() ... DONE
[17:03:51.773] run() for ‘Future’ ...
[17:03:51.773] - state: ‘created’
[17:03:51.773] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:51.787] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:51.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:51.787]   - Field: ‘node’
[17:03:51.787]   - Field: ‘label’
[17:03:51.787]   - Field: ‘local’
[17:03:51.787]   - Field: ‘owner’
[17:03:51.788]   - Field: ‘envir’
[17:03:51.788]   - Field: ‘workers’
[17:03:51.788]   - Field: ‘packages’
[17:03:51.788]   - Field: ‘gc’
[17:03:51.788]   - Field: ‘conditions’
[17:03:51.788]   - Field: ‘persistent’
[17:03:51.788]   - Field: ‘expr’
[17:03:51.788]   - Field: ‘uuid’
[17:03:51.788]   - Field: ‘seed’
[17:03:51.788]   - Field: ‘version’
[17:03:51.788]   - Field: ‘result’
[17:03:51.788]   - Field: ‘asynchronous’
[17:03:51.789]   - Field: ‘calls’
[17:03:51.789]   - Field: ‘globals’
[17:03:51.789]   - Field: ‘stdout’
[17:03:51.789]   - Field: ‘earlySignal’
[17:03:51.789]   - Field: ‘lazy’
[17:03:51.789]   - Field: ‘state’
[17:03:51.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:51.789] - Launch lazy future ...
[17:03:51.789] Packages needed by the future expression (n = 0): <none>
[17:03:51.790] Packages needed by future strategies (n = 0): <none>
[17:03:51.790] {
[17:03:51.790]     {
[17:03:51.790]         {
[17:03:51.790]             ...future.startTime <- base::Sys.time()
[17:03:51.790]             {
[17:03:51.790]                 {
[17:03:51.790]                   {
[17:03:51.790]                     {
[17:03:51.790]                       base::local({
[17:03:51.790]                         has_future <- base::requireNamespace("future", 
[17:03:51.790]                           quietly = TRUE)
[17:03:51.790]                         if (has_future) {
[17:03:51.790]                           ns <- base::getNamespace("future")
[17:03:51.790]                           version <- ns[[".package"]][["version"]]
[17:03:51.790]                           if (is.null(version)) 
[17:03:51.790]                             version <- utils::packageVersion("future")
[17:03:51.790]                         }
[17:03:51.790]                         else {
[17:03:51.790]                           version <- NULL
[17:03:51.790]                         }
[17:03:51.790]                         if (!has_future || version < "1.8.0") {
[17:03:51.790]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:51.790]                             "", base::R.version$version.string), 
[17:03:51.790]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:51.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:51.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:51.790]                               "release", "version")], collapse = " "), 
[17:03:51.790]                             hostname = base::Sys.info()[["nodename"]])
[17:03:51.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:51.790]                             info)
[17:03:51.790]                           info <- base::paste(info, collapse = "; ")
[17:03:51.790]                           if (!has_future) {
[17:03:51.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:51.790]                               info)
[17:03:51.790]                           }
[17:03:51.790]                           else {
[17:03:51.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:51.790]                               info, version)
[17:03:51.790]                           }
[17:03:51.790]                           base::stop(msg)
[17:03:51.790]                         }
[17:03:51.790]                       })
[17:03:51.790]                     }
[17:03:51.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:51.790]                     base::options(mc.cores = 1L)
[17:03:51.790]                   }
[17:03:51.790]                   ...future.strategy.old <- future::plan("list")
[17:03:51.790]                   options(future.plan = NULL)
[17:03:51.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:51.790]                 }
[17:03:51.790]                 ...future.workdir <- getwd()
[17:03:51.790]             }
[17:03:51.790]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:51.790]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:51.790]         }
[17:03:51.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:51.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:51.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:51.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:51.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:51.790]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:51.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:51.790]             base::names(...future.oldOptions))
[17:03:51.790]     }
[17:03:51.790]     if (FALSE) {
[17:03:51.790]     }
[17:03:51.790]     else {
[17:03:51.790]         if (TRUE) {
[17:03:51.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:51.790]                 open = "w")
[17:03:51.790]         }
[17:03:51.790]         else {
[17:03:51.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:51.790]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:51.790]         }
[17:03:51.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:51.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:51.790]             base::sink(type = "output", split = FALSE)
[17:03:51.790]             base::close(...future.stdout)
[17:03:51.790]         }, add = TRUE)
[17:03:51.790]     }
[17:03:51.790]     ...future.frame <- base::sys.nframe()
[17:03:51.790]     ...future.conditions <- base::list()
[17:03:51.790]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:51.790]     if (FALSE) {
[17:03:51.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:51.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:51.790]     }
[17:03:51.790]     ...future.result <- base::tryCatch({
[17:03:51.790]         base::withCallingHandlers({
[17:03:51.790]             ...future.value <- base::withVisible(base::local({
[17:03:51.790]                 ...future.makeSendCondition <- base::local({
[17:03:51.790]                   sendCondition <- NULL
[17:03:51.790]                   function(frame = 1L) {
[17:03:51.790]                     if (is.function(sendCondition)) 
[17:03:51.790]                       return(sendCondition)
[17:03:51.790]                     ns <- getNamespace("parallel")
[17:03:51.790]                     if (exists("sendData", mode = "function", 
[17:03:51.790]                       envir = ns)) {
[17:03:51.790]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:51.790]                         envir = ns)
[17:03:51.790]                       envir <- sys.frame(frame)
[17:03:51.790]                       master <- NULL
[17:03:51.790]                       while (!identical(envir, .GlobalEnv) && 
[17:03:51.790]                         !identical(envir, emptyenv())) {
[17:03:51.790]                         if (exists("master", mode = "list", envir = envir, 
[17:03:51.790]                           inherits = FALSE)) {
[17:03:51.790]                           master <- get("master", mode = "list", 
[17:03:51.790]                             envir = envir, inherits = FALSE)
[17:03:51.790]                           if (inherits(master, c("SOCKnode", 
[17:03:51.790]                             "SOCK0node"))) {
[17:03:51.790]                             sendCondition <<- function(cond) {
[17:03:51.790]                               data <- list(type = "VALUE", value = cond, 
[17:03:51.790]                                 success = TRUE)
[17:03:51.790]                               parallel_sendData(master, data)
[17:03:51.790]                             }
[17:03:51.790]                             return(sendCondition)
[17:03:51.790]                           }
[17:03:51.790]                         }
[17:03:51.790]                         frame <- frame + 1L
[17:03:51.790]                         envir <- sys.frame(frame)
[17:03:51.790]                       }
[17:03:51.790]                     }
[17:03:51.790]                     sendCondition <<- function(cond) NULL
[17:03:51.790]                   }
[17:03:51.790]                 })
[17:03:51.790]                 withCallingHandlers({
[17:03:51.790]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:51.790]                 }, immediateCondition = function(cond) {
[17:03:51.790]                   sendCondition <- ...future.makeSendCondition()
[17:03:51.790]                   sendCondition(cond)
[17:03:51.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.790]                   {
[17:03:51.790]                     inherits <- base::inherits
[17:03:51.790]                     invokeRestart <- base::invokeRestart
[17:03:51.790]                     is.null <- base::is.null
[17:03:51.790]                     muffled <- FALSE
[17:03:51.790]                     if (inherits(cond, "message")) {
[17:03:51.790]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:51.790]                       if (muffled) 
[17:03:51.790]                         invokeRestart("muffleMessage")
[17:03:51.790]                     }
[17:03:51.790]                     else if (inherits(cond, "warning")) {
[17:03:51.790]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:51.790]                       if (muffled) 
[17:03:51.790]                         invokeRestart("muffleWarning")
[17:03:51.790]                     }
[17:03:51.790]                     else if (inherits(cond, "condition")) {
[17:03:51.790]                       if (!is.null(pattern)) {
[17:03:51.790]                         computeRestarts <- base::computeRestarts
[17:03:51.790]                         grepl <- base::grepl
[17:03:51.790]                         restarts <- computeRestarts(cond)
[17:03:51.790]                         for (restart in restarts) {
[17:03:51.790]                           name <- restart$name
[17:03:51.790]                           if (is.null(name)) 
[17:03:51.790]                             next
[17:03:51.790]                           if (!grepl(pattern, name)) 
[17:03:51.790]                             next
[17:03:51.790]                           invokeRestart(restart)
[17:03:51.790]                           muffled <- TRUE
[17:03:51.790]                           break
[17:03:51.790]                         }
[17:03:51.790]                       }
[17:03:51.790]                     }
[17:03:51.790]                     invisible(muffled)
[17:03:51.790]                   }
[17:03:51.790]                   muffleCondition(cond)
[17:03:51.790]                 })
[17:03:51.790]             }))
[17:03:51.790]             future::FutureResult(value = ...future.value$value, 
[17:03:51.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.790]                   ...future.rng), globalenv = if (FALSE) 
[17:03:51.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:51.790]                     ...future.globalenv.names))
[17:03:51.790]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:51.790]         }, condition = base::local({
[17:03:51.790]             c <- base::c
[17:03:51.790]             inherits <- base::inherits
[17:03:51.790]             invokeRestart <- base::invokeRestart
[17:03:51.790]             length <- base::length
[17:03:51.790]             list <- base::list
[17:03:51.790]             seq.int <- base::seq.int
[17:03:51.790]             signalCondition <- base::signalCondition
[17:03:51.790]             sys.calls <- base::sys.calls
[17:03:51.790]             `[[` <- base::`[[`
[17:03:51.790]             `+` <- base::`+`
[17:03:51.790]             `<<-` <- base::`<<-`
[17:03:51.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:51.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:51.790]                   3L)]
[17:03:51.790]             }
[17:03:51.790]             function(cond) {
[17:03:51.790]                 is_error <- inherits(cond, "error")
[17:03:51.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:51.790]                   NULL)
[17:03:51.790]                 if (is_error) {
[17:03:51.790]                   sessionInformation <- function() {
[17:03:51.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:51.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:51.790]                       search = base::search(), system = base::Sys.info())
[17:03:51.790]                   }
[17:03:51.790]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:51.790]                     cond$call), session = sessionInformation(), 
[17:03:51.790]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:51.790]                   signalCondition(cond)
[17:03:51.790]                 }
[17:03:51.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:51.790]                 "immediateCondition"))) {
[17:03:51.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:51.790]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:51.790]                   if (TRUE && !signal) {
[17:03:51.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.790]                     {
[17:03:51.790]                       inherits <- base::inherits
[17:03:51.790]                       invokeRestart <- base::invokeRestart
[17:03:51.790]                       is.null <- base::is.null
[17:03:51.790]                       muffled <- FALSE
[17:03:51.790]                       if (inherits(cond, "message")) {
[17:03:51.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.790]                         if (muffled) 
[17:03:51.790]                           invokeRestart("muffleMessage")
[17:03:51.790]                       }
[17:03:51.790]                       else if (inherits(cond, "warning")) {
[17:03:51.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.790]                         if (muffled) 
[17:03:51.790]                           invokeRestart("muffleWarning")
[17:03:51.790]                       }
[17:03:51.790]                       else if (inherits(cond, "condition")) {
[17:03:51.790]                         if (!is.null(pattern)) {
[17:03:51.790]                           computeRestarts <- base::computeRestarts
[17:03:51.790]                           grepl <- base::grepl
[17:03:51.790]                           restarts <- computeRestarts(cond)
[17:03:51.790]                           for (restart in restarts) {
[17:03:51.790]                             name <- restart$name
[17:03:51.790]                             if (is.null(name)) 
[17:03:51.790]                               next
[17:03:51.790]                             if (!grepl(pattern, name)) 
[17:03:51.790]                               next
[17:03:51.790]                             invokeRestart(restart)
[17:03:51.790]                             muffled <- TRUE
[17:03:51.790]                             break
[17:03:51.790]                           }
[17:03:51.790]                         }
[17:03:51.790]                       }
[17:03:51.790]                       invisible(muffled)
[17:03:51.790]                     }
[17:03:51.790]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.790]                   }
[17:03:51.790]                 }
[17:03:51.790]                 else {
[17:03:51.790]                   if (TRUE) {
[17:03:51.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.790]                     {
[17:03:51.790]                       inherits <- base::inherits
[17:03:51.790]                       invokeRestart <- base::invokeRestart
[17:03:51.790]                       is.null <- base::is.null
[17:03:51.790]                       muffled <- FALSE
[17:03:51.790]                       if (inherits(cond, "message")) {
[17:03:51.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.790]                         if (muffled) 
[17:03:51.790]                           invokeRestart("muffleMessage")
[17:03:51.790]                       }
[17:03:51.790]                       else if (inherits(cond, "warning")) {
[17:03:51.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.790]                         if (muffled) 
[17:03:51.790]                           invokeRestart("muffleWarning")
[17:03:51.790]                       }
[17:03:51.790]                       else if (inherits(cond, "condition")) {
[17:03:51.790]                         if (!is.null(pattern)) {
[17:03:51.790]                           computeRestarts <- base::computeRestarts
[17:03:51.790]                           grepl <- base::grepl
[17:03:51.790]                           restarts <- computeRestarts(cond)
[17:03:51.790]                           for (restart in restarts) {
[17:03:51.790]                             name <- restart$name
[17:03:51.790]                             if (is.null(name)) 
[17:03:51.790]                               next
[17:03:51.790]                             if (!grepl(pattern, name)) 
[17:03:51.790]                               next
[17:03:51.790]                             invokeRestart(restart)
[17:03:51.790]                             muffled <- TRUE
[17:03:51.790]                             break
[17:03:51.790]                           }
[17:03:51.790]                         }
[17:03:51.790]                       }
[17:03:51.790]                       invisible(muffled)
[17:03:51.790]                     }
[17:03:51.790]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.790]                   }
[17:03:51.790]                 }
[17:03:51.790]             }
[17:03:51.790]         }))
[17:03:51.790]     }, error = function(ex) {
[17:03:51.790]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:51.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.790]                 ...future.rng), started = ...future.startTime, 
[17:03:51.790]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:51.790]             version = "1.8"), class = "FutureResult")
[17:03:51.790]     }, finally = {
[17:03:51.790]         if (!identical(...future.workdir, getwd())) 
[17:03:51.790]             setwd(...future.workdir)
[17:03:51.790]         {
[17:03:51.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:51.790]                 ...future.oldOptions$nwarnings <- NULL
[17:03:51.790]             }
[17:03:51.790]             base::options(...future.oldOptions)
[17:03:51.790]             if (.Platform$OS.type == "windows") {
[17:03:51.790]                 old_names <- names(...future.oldEnvVars)
[17:03:51.790]                 envs <- base::Sys.getenv()
[17:03:51.790]                 names <- names(envs)
[17:03:51.790]                 common <- intersect(names, old_names)
[17:03:51.790]                 added <- setdiff(names, old_names)
[17:03:51.790]                 removed <- setdiff(old_names, names)
[17:03:51.790]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:51.790]                   envs[common]]
[17:03:51.790]                 NAMES <- toupper(changed)
[17:03:51.790]                 args <- list()
[17:03:51.790]                 for (kk in seq_along(NAMES)) {
[17:03:51.790]                   name <- changed[[kk]]
[17:03:51.790]                   NAME <- NAMES[[kk]]
[17:03:51.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.790]                     next
[17:03:51.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.790]                 }
[17:03:51.790]                 NAMES <- toupper(added)
[17:03:51.790]                 for (kk in seq_along(NAMES)) {
[17:03:51.790]                   name <- added[[kk]]
[17:03:51.790]                   NAME <- NAMES[[kk]]
[17:03:51.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.790]                     next
[17:03:51.790]                   args[[name]] <- ""
[17:03:51.790]                 }
[17:03:51.790]                 NAMES <- toupper(removed)
[17:03:51.790]                 for (kk in seq_along(NAMES)) {
[17:03:51.790]                   name <- removed[[kk]]
[17:03:51.790]                   NAME <- NAMES[[kk]]
[17:03:51.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.790]                     next
[17:03:51.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.790]                 }
[17:03:51.790]                 if (length(args) > 0) 
[17:03:51.790]                   base::do.call(base::Sys.setenv, args = args)
[17:03:51.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:51.790]             }
[17:03:51.790]             else {
[17:03:51.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:51.790]             }
[17:03:51.790]             {
[17:03:51.790]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:51.790]                   0L) {
[17:03:51.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:51.790]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:51.790]                   base::options(opts)
[17:03:51.790]                 }
[17:03:51.790]                 {
[17:03:51.790]                   {
[17:03:51.790]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:51.790]                     NULL
[17:03:51.790]                   }
[17:03:51.790]                   options(future.plan = NULL)
[17:03:51.790]                   if (is.na(NA_character_)) 
[17:03:51.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:51.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:51.790]                     .init = FALSE)
[17:03:51.790]                 }
[17:03:51.790]             }
[17:03:51.790]         }
[17:03:51.790]     })
[17:03:51.790]     if (TRUE) {
[17:03:51.790]         base::sink(type = "output", split = FALSE)
[17:03:51.790]         if (TRUE) {
[17:03:51.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:51.790]         }
[17:03:51.790]         else {
[17:03:51.790]             ...future.result["stdout"] <- base::list(NULL)
[17:03:51.790]         }
[17:03:51.790]         base::close(...future.stdout)
[17:03:51.790]         ...future.stdout <- NULL
[17:03:51.790]     }
[17:03:51.790]     ...future.result$conditions <- ...future.conditions
[17:03:51.790]     ...future.result$finished <- base::Sys.time()
[17:03:51.790]     ...future.result
[17:03:51.790] }
[17:03:51.793] MultisessionFuture started
[17:03:51.793] - Launch lazy future ... done
[17:03:51.793] run() for ‘MultisessionFuture’ ... done
[17:03:51.795] receiveMessageFromWorker() for ClusterFuture ...
[17:03:51.796] - Validating connection of MultisessionFuture
[17:03:51.796] - received message: FutureResult
[17:03:51.796] - Received FutureResult
[17:03:51.796] - Erased future from FutureRegistry
[17:03:51.796] result() for ClusterFuture ...
[17:03:51.796] - result already collected: FutureResult
[17:03:51.797] result() for ClusterFuture ... done
[17:03:51.797] signalConditions() ...
[17:03:51.797]  - include = ‘immediateCondition’
[17:03:51.797]  - exclude = 
[17:03:51.797]  - resignal = FALSE
[17:03:51.797]  - Number of conditions: 1
[17:03:51.797] signalConditions() ... done
[17:03:51.797] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:51.797] A MultisessionFuture was resolved
[17:03:51.797] getGlobalsAndPackages() ...
[17:03:51.797] Searching for globals...
[17:03:51.798] - globals found: [2] ‘list’, ‘stop’
[17:03:51.798] Searching for globals ... DONE
[17:03:51.798] Resolving globals: FALSE
[17:03:51.799] 
[17:03:51.799] 
[17:03:51.799] getGlobalsAndPackages() ... DONE
[17:03:51.799] run() for ‘Future’ ...
[17:03:51.799] - state: ‘created’
[17:03:51.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:51.815] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:51.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:51.816]   - Field: ‘node’
[17:03:51.816]   - Field: ‘label’
[17:03:51.816]   - Field: ‘local’
[17:03:51.816]   - Field: ‘owner’
[17:03:51.816]   - Field: ‘envir’
[17:03:51.816]   - Field: ‘workers’
[17:03:51.816]   - Field: ‘packages’
[17:03:51.816]   - Field: ‘gc’
[17:03:51.816]   - Field: ‘conditions’
[17:03:51.817]   - Field: ‘persistent’
[17:03:51.817]   - Field: ‘expr’
[17:03:51.817]   - Field: ‘uuid’
[17:03:51.817]   - Field: ‘seed’
[17:03:51.817]   - Field: ‘version’
[17:03:51.817]   - Field: ‘result’
[17:03:51.817]   - Field: ‘asynchronous’
[17:03:51.817]   - Field: ‘calls’
[17:03:51.817]   - Field: ‘globals’
[17:03:51.817]   - Field: ‘stdout’
[17:03:51.817]   - Field: ‘earlySignal’
[17:03:51.818]   - Field: ‘lazy’
[17:03:51.818]   - Field: ‘state’
[17:03:51.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:51.818] - Launch lazy future ...
[17:03:51.818] Packages needed by the future expression (n = 0): <none>
[17:03:51.818] Packages needed by future strategies (n = 0): <none>
[17:03:51.819] {
[17:03:51.819]     {
[17:03:51.819]         {
[17:03:51.819]             ...future.startTime <- base::Sys.time()
[17:03:51.819]             {
[17:03:51.819]                 {
[17:03:51.819]                   {
[17:03:51.819]                     {
[17:03:51.819]                       base::local({
[17:03:51.819]                         has_future <- base::requireNamespace("future", 
[17:03:51.819]                           quietly = TRUE)
[17:03:51.819]                         if (has_future) {
[17:03:51.819]                           ns <- base::getNamespace("future")
[17:03:51.819]                           version <- ns[[".package"]][["version"]]
[17:03:51.819]                           if (is.null(version)) 
[17:03:51.819]                             version <- utils::packageVersion("future")
[17:03:51.819]                         }
[17:03:51.819]                         else {
[17:03:51.819]                           version <- NULL
[17:03:51.819]                         }
[17:03:51.819]                         if (!has_future || version < "1.8.0") {
[17:03:51.819]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:51.819]                             "", base::R.version$version.string), 
[17:03:51.819]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:51.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:51.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:51.819]                               "release", "version")], collapse = " "), 
[17:03:51.819]                             hostname = base::Sys.info()[["nodename"]])
[17:03:51.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:51.819]                             info)
[17:03:51.819]                           info <- base::paste(info, collapse = "; ")
[17:03:51.819]                           if (!has_future) {
[17:03:51.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:51.819]                               info)
[17:03:51.819]                           }
[17:03:51.819]                           else {
[17:03:51.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:51.819]                               info, version)
[17:03:51.819]                           }
[17:03:51.819]                           base::stop(msg)
[17:03:51.819]                         }
[17:03:51.819]                       })
[17:03:51.819]                     }
[17:03:51.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:51.819]                     base::options(mc.cores = 1L)
[17:03:51.819]                   }
[17:03:51.819]                   ...future.strategy.old <- future::plan("list")
[17:03:51.819]                   options(future.plan = NULL)
[17:03:51.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:51.819]                 }
[17:03:51.819]                 ...future.workdir <- getwd()
[17:03:51.819]             }
[17:03:51.819]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:51.819]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:51.819]         }
[17:03:51.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:51.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:51.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:51.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:51.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:51.819]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:51.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:51.819]             base::names(...future.oldOptions))
[17:03:51.819]     }
[17:03:51.819]     if (FALSE) {
[17:03:51.819]     }
[17:03:51.819]     else {
[17:03:51.819]         if (TRUE) {
[17:03:51.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:51.819]                 open = "w")
[17:03:51.819]         }
[17:03:51.819]         else {
[17:03:51.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:51.819]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:51.819]         }
[17:03:51.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:51.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:51.819]             base::sink(type = "output", split = FALSE)
[17:03:51.819]             base::close(...future.stdout)
[17:03:51.819]         }, add = TRUE)
[17:03:51.819]     }
[17:03:51.819]     ...future.frame <- base::sys.nframe()
[17:03:51.819]     ...future.conditions <- base::list()
[17:03:51.819]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:51.819]     if (FALSE) {
[17:03:51.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:51.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:51.819]     }
[17:03:51.819]     ...future.result <- base::tryCatch({
[17:03:51.819]         base::withCallingHandlers({
[17:03:51.819]             ...future.value <- base::withVisible(base::local({
[17:03:51.819]                 ...future.makeSendCondition <- base::local({
[17:03:51.819]                   sendCondition <- NULL
[17:03:51.819]                   function(frame = 1L) {
[17:03:51.819]                     if (is.function(sendCondition)) 
[17:03:51.819]                       return(sendCondition)
[17:03:51.819]                     ns <- getNamespace("parallel")
[17:03:51.819]                     if (exists("sendData", mode = "function", 
[17:03:51.819]                       envir = ns)) {
[17:03:51.819]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:51.819]                         envir = ns)
[17:03:51.819]                       envir <- sys.frame(frame)
[17:03:51.819]                       master <- NULL
[17:03:51.819]                       while (!identical(envir, .GlobalEnv) && 
[17:03:51.819]                         !identical(envir, emptyenv())) {
[17:03:51.819]                         if (exists("master", mode = "list", envir = envir, 
[17:03:51.819]                           inherits = FALSE)) {
[17:03:51.819]                           master <- get("master", mode = "list", 
[17:03:51.819]                             envir = envir, inherits = FALSE)
[17:03:51.819]                           if (inherits(master, c("SOCKnode", 
[17:03:51.819]                             "SOCK0node"))) {
[17:03:51.819]                             sendCondition <<- function(cond) {
[17:03:51.819]                               data <- list(type = "VALUE", value = cond, 
[17:03:51.819]                                 success = TRUE)
[17:03:51.819]                               parallel_sendData(master, data)
[17:03:51.819]                             }
[17:03:51.819]                             return(sendCondition)
[17:03:51.819]                           }
[17:03:51.819]                         }
[17:03:51.819]                         frame <- frame + 1L
[17:03:51.819]                         envir <- sys.frame(frame)
[17:03:51.819]                       }
[17:03:51.819]                     }
[17:03:51.819]                     sendCondition <<- function(cond) NULL
[17:03:51.819]                   }
[17:03:51.819]                 })
[17:03:51.819]                 withCallingHandlers({
[17:03:51.819]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:51.819]                 }, immediateCondition = function(cond) {
[17:03:51.819]                   sendCondition <- ...future.makeSendCondition()
[17:03:51.819]                   sendCondition(cond)
[17:03:51.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.819]                   {
[17:03:51.819]                     inherits <- base::inherits
[17:03:51.819]                     invokeRestart <- base::invokeRestart
[17:03:51.819]                     is.null <- base::is.null
[17:03:51.819]                     muffled <- FALSE
[17:03:51.819]                     if (inherits(cond, "message")) {
[17:03:51.819]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:51.819]                       if (muffled) 
[17:03:51.819]                         invokeRestart("muffleMessage")
[17:03:51.819]                     }
[17:03:51.819]                     else if (inherits(cond, "warning")) {
[17:03:51.819]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:51.819]                       if (muffled) 
[17:03:51.819]                         invokeRestart("muffleWarning")
[17:03:51.819]                     }
[17:03:51.819]                     else if (inherits(cond, "condition")) {
[17:03:51.819]                       if (!is.null(pattern)) {
[17:03:51.819]                         computeRestarts <- base::computeRestarts
[17:03:51.819]                         grepl <- base::grepl
[17:03:51.819]                         restarts <- computeRestarts(cond)
[17:03:51.819]                         for (restart in restarts) {
[17:03:51.819]                           name <- restart$name
[17:03:51.819]                           if (is.null(name)) 
[17:03:51.819]                             next
[17:03:51.819]                           if (!grepl(pattern, name)) 
[17:03:51.819]                             next
[17:03:51.819]                           invokeRestart(restart)
[17:03:51.819]                           muffled <- TRUE
[17:03:51.819]                           break
[17:03:51.819]                         }
[17:03:51.819]                       }
[17:03:51.819]                     }
[17:03:51.819]                     invisible(muffled)
[17:03:51.819]                   }
[17:03:51.819]                   muffleCondition(cond)
[17:03:51.819]                 })
[17:03:51.819]             }))
[17:03:51.819]             future::FutureResult(value = ...future.value$value, 
[17:03:51.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.819]                   ...future.rng), globalenv = if (FALSE) 
[17:03:51.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:51.819]                     ...future.globalenv.names))
[17:03:51.819]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:51.819]         }, condition = base::local({
[17:03:51.819]             c <- base::c
[17:03:51.819]             inherits <- base::inherits
[17:03:51.819]             invokeRestart <- base::invokeRestart
[17:03:51.819]             length <- base::length
[17:03:51.819]             list <- base::list
[17:03:51.819]             seq.int <- base::seq.int
[17:03:51.819]             signalCondition <- base::signalCondition
[17:03:51.819]             sys.calls <- base::sys.calls
[17:03:51.819]             `[[` <- base::`[[`
[17:03:51.819]             `+` <- base::`+`
[17:03:51.819]             `<<-` <- base::`<<-`
[17:03:51.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:51.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:51.819]                   3L)]
[17:03:51.819]             }
[17:03:51.819]             function(cond) {
[17:03:51.819]                 is_error <- inherits(cond, "error")
[17:03:51.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:51.819]                   NULL)
[17:03:51.819]                 if (is_error) {
[17:03:51.819]                   sessionInformation <- function() {
[17:03:51.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:51.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:51.819]                       search = base::search(), system = base::Sys.info())
[17:03:51.819]                   }
[17:03:51.819]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:51.819]                     cond$call), session = sessionInformation(), 
[17:03:51.819]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:51.819]                   signalCondition(cond)
[17:03:51.819]                 }
[17:03:51.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:51.819]                 "immediateCondition"))) {
[17:03:51.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:51.819]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:51.819]                   if (TRUE && !signal) {
[17:03:51.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.819]                     {
[17:03:51.819]                       inherits <- base::inherits
[17:03:51.819]                       invokeRestart <- base::invokeRestart
[17:03:51.819]                       is.null <- base::is.null
[17:03:51.819]                       muffled <- FALSE
[17:03:51.819]                       if (inherits(cond, "message")) {
[17:03:51.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.819]                         if (muffled) 
[17:03:51.819]                           invokeRestart("muffleMessage")
[17:03:51.819]                       }
[17:03:51.819]                       else if (inherits(cond, "warning")) {
[17:03:51.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.819]                         if (muffled) 
[17:03:51.819]                           invokeRestart("muffleWarning")
[17:03:51.819]                       }
[17:03:51.819]                       else if (inherits(cond, "condition")) {
[17:03:51.819]                         if (!is.null(pattern)) {
[17:03:51.819]                           computeRestarts <- base::computeRestarts
[17:03:51.819]                           grepl <- base::grepl
[17:03:51.819]                           restarts <- computeRestarts(cond)
[17:03:51.819]                           for (restart in restarts) {
[17:03:51.819]                             name <- restart$name
[17:03:51.819]                             if (is.null(name)) 
[17:03:51.819]                               next
[17:03:51.819]                             if (!grepl(pattern, name)) 
[17:03:51.819]                               next
[17:03:51.819]                             invokeRestart(restart)
[17:03:51.819]                             muffled <- TRUE
[17:03:51.819]                             break
[17:03:51.819]                           }
[17:03:51.819]                         }
[17:03:51.819]                       }
[17:03:51.819]                       invisible(muffled)
[17:03:51.819]                     }
[17:03:51.819]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.819]                   }
[17:03:51.819]                 }
[17:03:51.819]                 else {
[17:03:51.819]                   if (TRUE) {
[17:03:51.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.819]                     {
[17:03:51.819]                       inherits <- base::inherits
[17:03:51.819]                       invokeRestart <- base::invokeRestart
[17:03:51.819]                       is.null <- base::is.null
[17:03:51.819]                       muffled <- FALSE
[17:03:51.819]                       if (inherits(cond, "message")) {
[17:03:51.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.819]                         if (muffled) 
[17:03:51.819]                           invokeRestart("muffleMessage")
[17:03:51.819]                       }
[17:03:51.819]                       else if (inherits(cond, "warning")) {
[17:03:51.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.819]                         if (muffled) 
[17:03:51.819]                           invokeRestart("muffleWarning")
[17:03:51.819]                       }
[17:03:51.819]                       else if (inherits(cond, "condition")) {
[17:03:51.819]                         if (!is.null(pattern)) {
[17:03:51.819]                           computeRestarts <- base::computeRestarts
[17:03:51.819]                           grepl <- base::grepl
[17:03:51.819]                           restarts <- computeRestarts(cond)
[17:03:51.819]                           for (restart in restarts) {
[17:03:51.819]                             name <- restart$name
[17:03:51.819]                             if (is.null(name)) 
[17:03:51.819]                               next
[17:03:51.819]                             if (!grepl(pattern, name)) 
[17:03:51.819]                               next
[17:03:51.819]                             invokeRestart(restart)
[17:03:51.819]                             muffled <- TRUE
[17:03:51.819]                             break
[17:03:51.819]                           }
[17:03:51.819]                         }
[17:03:51.819]                       }
[17:03:51.819]                       invisible(muffled)
[17:03:51.819]                     }
[17:03:51.819]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.819]                   }
[17:03:51.819]                 }
[17:03:51.819]             }
[17:03:51.819]         }))
[17:03:51.819]     }, error = function(ex) {
[17:03:51.819]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:51.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.819]                 ...future.rng), started = ...future.startTime, 
[17:03:51.819]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:51.819]             version = "1.8"), class = "FutureResult")
[17:03:51.819]     }, finally = {
[17:03:51.819]         if (!identical(...future.workdir, getwd())) 
[17:03:51.819]             setwd(...future.workdir)
[17:03:51.819]         {
[17:03:51.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:51.819]                 ...future.oldOptions$nwarnings <- NULL
[17:03:51.819]             }
[17:03:51.819]             base::options(...future.oldOptions)
[17:03:51.819]             if (.Platform$OS.type == "windows") {
[17:03:51.819]                 old_names <- names(...future.oldEnvVars)
[17:03:51.819]                 envs <- base::Sys.getenv()
[17:03:51.819]                 names <- names(envs)
[17:03:51.819]                 common <- intersect(names, old_names)
[17:03:51.819]                 added <- setdiff(names, old_names)
[17:03:51.819]                 removed <- setdiff(old_names, names)
[17:03:51.819]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:51.819]                   envs[common]]
[17:03:51.819]                 NAMES <- toupper(changed)
[17:03:51.819]                 args <- list()
[17:03:51.819]                 for (kk in seq_along(NAMES)) {
[17:03:51.819]                   name <- changed[[kk]]
[17:03:51.819]                   NAME <- NAMES[[kk]]
[17:03:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.819]                     next
[17:03:51.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.819]                 }
[17:03:51.819]                 NAMES <- toupper(added)
[17:03:51.819]                 for (kk in seq_along(NAMES)) {
[17:03:51.819]                   name <- added[[kk]]
[17:03:51.819]                   NAME <- NAMES[[kk]]
[17:03:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.819]                     next
[17:03:51.819]                   args[[name]] <- ""
[17:03:51.819]                 }
[17:03:51.819]                 NAMES <- toupper(removed)
[17:03:51.819]                 for (kk in seq_along(NAMES)) {
[17:03:51.819]                   name <- removed[[kk]]
[17:03:51.819]                   NAME <- NAMES[[kk]]
[17:03:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.819]                     next
[17:03:51.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.819]                 }
[17:03:51.819]                 if (length(args) > 0) 
[17:03:51.819]                   base::do.call(base::Sys.setenv, args = args)
[17:03:51.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:51.819]             }
[17:03:51.819]             else {
[17:03:51.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:51.819]             }
[17:03:51.819]             {
[17:03:51.819]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:51.819]                   0L) {
[17:03:51.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:51.819]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:51.819]                   base::options(opts)
[17:03:51.819]                 }
[17:03:51.819]                 {
[17:03:51.819]                   {
[17:03:51.819]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:51.819]                     NULL
[17:03:51.819]                   }
[17:03:51.819]                   options(future.plan = NULL)
[17:03:51.819]                   if (is.na(NA_character_)) 
[17:03:51.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:51.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:51.819]                     .init = FALSE)
[17:03:51.819]                 }
[17:03:51.819]             }
[17:03:51.819]         }
[17:03:51.819]     })
[17:03:51.819]     if (TRUE) {
[17:03:51.819]         base::sink(type = "output", split = FALSE)
[17:03:51.819]         if (TRUE) {
[17:03:51.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:51.819]         }
[17:03:51.819]         else {
[17:03:51.819]             ...future.result["stdout"] <- base::list(NULL)
[17:03:51.819]         }
[17:03:51.819]         base::close(...future.stdout)
[17:03:51.819]         ...future.stdout <- NULL
[17:03:51.819]     }
[17:03:51.819]     ...future.result$conditions <- ...future.conditions
[17:03:51.819]     ...future.result$finished <- base::Sys.time()
[17:03:51.819]     ...future.result
[17:03:51.819] }
[17:03:51.822] MultisessionFuture started
[17:03:51.822] - Launch lazy future ... done
[17:03:51.822] run() for ‘MultisessionFuture’ ... done
[17:03:51.824] receiveMessageFromWorker() for ClusterFuture ...
[17:03:51.824] - Validating connection of MultisessionFuture
[17:03:51.825] - received message: FutureResult
[17:03:51.825] - Received FutureResult
[17:03:51.825] - Erased future from FutureRegistry
[17:03:51.825] result() for ClusterFuture ...
[17:03:51.825] - result already collected: FutureResult
[17:03:51.825] result() for ClusterFuture ... done
[17:03:51.825] signalConditions() ...
[17:03:51.825]  - include = ‘immediateCondition’
[17:03:51.825]  - exclude = 
[17:03:51.825]  - resignal = FALSE
[17:03:51.826]  - Number of conditions: 1
[17:03:51.826] signalConditions() ... done
[17:03:51.826] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:51.826] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[17:03:51.826] getGlobalsAndPackages() ...
[17:03:51.826] Searching for globals...
[17:03:51.827] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:51.827] Searching for globals ... DONE
[17:03:51.828] Resolving globals: FALSE
[17:03:51.828] 
[17:03:51.828] 
[17:03:51.828] getGlobalsAndPackages() ... DONE
[17:03:51.828] run() for ‘Future’ ...
[17:03:51.828] - state: ‘created’
[17:03:51.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:51.842] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:51.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:51.842]   - Field: ‘node’
[17:03:51.842]   - Field: ‘label’
[17:03:51.843]   - Field: ‘local’
[17:03:51.843]   - Field: ‘owner’
[17:03:51.843]   - Field: ‘envir’
[17:03:51.843]   - Field: ‘workers’
[17:03:51.843]   - Field: ‘packages’
[17:03:51.843]   - Field: ‘gc’
[17:03:51.843]   - Field: ‘conditions’
[17:03:51.843]   - Field: ‘persistent’
[17:03:51.843]   - Field: ‘expr’
[17:03:51.843]   - Field: ‘uuid’
[17:03:51.844]   - Field: ‘seed’
[17:03:51.844]   - Field: ‘version’
[17:03:51.844]   - Field: ‘result’
[17:03:51.844]   - Field: ‘asynchronous’
[17:03:51.844]   - Field: ‘calls’
[17:03:51.844]   - Field: ‘globals’
[17:03:51.844]   - Field: ‘stdout’
[17:03:51.844]   - Field: ‘earlySignal’
[17:03:51.844]   - Field: ‘lazy’
[17:03:51.844]   - Field: ‘state’
[17:03:51.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:51.845] - Launch lazy future ...
[17:03:51.845] Packages needed by the future expression (n = 0): <none>
[17:03:51.845] Packages needed by future strategies (n = 0): <none>
[17:03:51.845] {
[17:03:51.845]     {
[17:03:51.845]         {
[17:03:51.845]             ...future.startTime <- base::Sys.time()
[17:03:51.845]             {
[17:03:51.845]                 {
[17:03:51.845]                   {
[17:03:51.845]                     {
[17:03:51.845]                       base::local({
[17:03:51.845]                         has_future <- base::requireNamespace("future", 
[17:03:51.845]                           quietly = TRUE)
[17:03:51.845]                         if (has_future) {
[17:03:51.845]                           ns <- base::getNamespace("future")
[17:03:51.845]                           version <- ns[[".package"]][["version"]]
[17:03:51.845]                           if (is.null(version)) 
[17:03:51.845]                             version <- utils::packageVersion("future")
[17:03:51.845]                         }
[17:03:51.845]                         else {
[17:03:51.845]                           version <- NULL
[17:03:51.845]                         }
[17:03:51.845]                         if (!has_future || version < "1.8.0") {
[17:03:51.845]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:51.845]                             "", base::R.version$version.string), 
[17:03:51.845]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:51.845]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:51.845]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:51.845]                               "release", "version")], collapse = " "), 
[17:03:51.845]                             hostname = base::Sys.info()[["nodename"]])
[17:03:51.845]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:51.845]                             info)
[17:03:51.845]                           info <- base::paste(info, collapse = "; ")
[17:03:51.845]                           if (!has_future) {
[17:03:51.845]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:51.845]                               info)
[17:03:51.845]                           }
[17:03:51.845]                           else {
[17:03:51.845]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:51.845]                               info, version)
[17:03:51.845]                           }
[17:03:51.845]                           base::stop(msg)
[17:03:51.845]                         }
[17:03:51.845]                       })
[17:03:51.845]                     }
[17:03:51.845]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:51.845]                     base::options(mc.cores = 1L)
[17:03:51.845]                   }
[17:03:51.845]                   ...future.strategy.old <- future::plan("list")
[17:03:51.845]                   options(future.plan = NULL)
[17:03:51.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:51.845]                 }
[17:03:51.845]                 ...future.workdir <- getwd()
[17:03:51.845]             }
[17:03:51.845]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:51.845]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:51.845]         }
[17:03:51.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:51.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:51.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:51.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:51.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:51.845]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:51.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:51.845]             base::names(...future.oldOptions))
[17:03:51.845]     }
[17:03:51.845]     if (FALSE) {
[17:03:51.845]     }
[17:03:51.845]     else {
[17:03:51.845]         if (TRUE) {
[17:03:51.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:51.845]                 open = "w")
[17:03:51.845]         }
[17:03:51.845]         else {
[17:03:51.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:51.845]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:51.845]         }
[17:03:51.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:51.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:51.845]             base::sink(type = "output", split = FALSE)
[17:03:51.845]             base::close(...future.stdout)
[17:03:51.845]         }, add = TRUE)
[17:03:51.845]     }
[17:03:51.845]     ...future.frame <- base::sys.nframe()
[17:03:51.845]     ...future.conditions <- base::list()
[17:03:51.845]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:51.845]     if (FALSE) {
[17:03:51.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:51.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:51.845]     }
[17:03:51.845]     ...future.result <- base::tryCatch({
[17:03:51.845]         base::withCallingHandlers({
[17:03:51.845]             ...future.value <- base::withVisible(base::local({
[17:03:51.845]                 ...future.makeSendCondition <- base::local({
[17:03:51.845]                   sendCondition <- NULL
[17:03:51.845]                   function(frame = 1L) {
[17:03:51.845]                     if (is.function(sendCondition)) 
[17:03:51.845]                       return(sendCondition)
[17:03:51.845]                     ns <- getNamespace("parallel")
[17:03:51.845]                     if (exists("sendData", mode = "function", 
[17:03:51.845]                       envir = ns)) {
[17:03:51.845]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:51.845]                         envir = ns)
[17:03:51.845]                       envir <- sys.frame(frame)
[17:03:51.845]                       master <- NULL
[17:03:51.845]                       while (!identical(envir, .GlobalEnv) && 
[17:03:51.845]                         !identical(envir, emptyenv())) {
[17:03:51.845]                         if (exists("master", mode = "list", envir = envir, 
[17:03:51.845]                           inherits = FALSE)) {
[17:03:51.845]                           master <- get("master", mode = "list", 
[17:03:51.845]                             envir = envir, inherits = FALSE)
[17:03:51.845]                           if (inherits(master, c("SOCKnode", 
[17:03:51.845]                             "SOCK0node"))) {
[17:03:51.845]                             sendCondition <<- function(cond) {
[17:03:51.845]                               data <- list(type = "VALUE", value = cond, 
[17:03:51.845]                                 success = TRUE)
[17:03:51.845]                               parallel_sendData(master, data)
[17:03:51.845]                             }
[17:03:51.845]                             return(sendCondition)
[17:03:51.845]                           }
[17:03:51.845]                         }
[17:03:51.845]                         frame <- frame + 1L
[17:03:51.845]                         envir <- sys.frame(frame)
[17:03:51.845]                       }
[17:03:51.845]                     }
[17:03:51.845]                     sendCondition <<- function(cond) NULL
[17:03:51.845]                   }
[17:03:51.845]                 })
[17:03:51.845]                 withCallingHandlers({
[17:03:51.845]                   {
[17:03:51.845]                     Sys.sleep(0.5)
[17:03:51.845]                     list(a = 1, b = 42L)
[17:03:51.845]                   }
[17:03:51.845]                 }, immediateCondition = function(cond) {
[17:03:51.845]                   sendCondition <- ...future.makeSendCondition()
[17:03:51.845]                   sendCondition(cond)
[17:03:51.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.845]                   {
[17:03:51.845]                     inherits <- base::inherits
[17:03:51.845]                     invokeRestart <- base::invokeRestart
[17:03:51.845]                     is.null <- base::is.null
[17:03:51.845]                     muffled <- FALSE
[17:03:51.845]                     if (inherits(cond, "message")) {
[17:03:51.845]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:51.845]                       if (muffled) 
[17:03:51.845]                         invokeRestart("muffleMessage")
[17:03:51.845]                     }
[17:03:51.845]                     else if (inherits(cond, "warning")) {
[17:03:51.845]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:51.845]                       if (muffled) 
[17:03:51.845]                         invokeRestart("muffleWarning")
[17:03:51.845]                     }
[17:03:51.845]                     else if (inherits(cond, "condition")) {
[17:03:51.845]                       if (!is.null(pattern)) {
[17:03:51.845]                         computeRestarts <- base::computeRestarts
[17:03:51.845]                         grepl <- base::grepl
[17:03:51.845]                         restarts <- computeRestarts(cond)
[17:03:51.845]                         for (restart in restarts) {
[17:03:51.845]                           name <- restart$name
[17:03:51.845]                           if (is.null(name)) 
[17:03:51.845]                             next
[17:03:51.845]                           if (!grepl(pattern, name)) 
[17:03:51.845]                             next
[17:03:51.845]                           invokeRestart(restart)
[17:03:51.845]                           muffled <- TRUE
[17:03:51.845]                           break
[17:03:51.845]                         }
[17:03:51.845]                       }
[17:03:51.845]                     }
[17:03:51.845]                     invisible(muffled)
[17:03:51.845]                   }
[17:03:51.845]                   muffleCondition(cond)
[17:03:51.845]                 })
[17:03:51.845]             }))
[17:03:51.845]             future::FutureResult(value = ...future.value$value, 
[17:03:51.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.845]                   ...future.rng), globalenv = if (FALSE) 
[17:03:51.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:51.845]                     ...future.globalenv.names))
[17:03:51.845]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:51.845]         }, condition = base::local({
[17:03:51.845]             c <- base::c
[17:03:51.845]             inherits <- base::inherits
[17:03:51.845]             invokeRestart <- base::invokeRestart
[17:03:51.845]             length <- base::length
[17:03:51.845]             list <- base::list
[17:03:51.845]             seq.int <- base::seq.int
[17:03:51.845]             signalCondition <- base::signalCondition
[17:03:51.845]             sys.calls <- base::sys.calls
[17:03:51.845]             `[[` <- base::`[[`
[17:03:51.845]             `+` <- base::`+`
[17:03:51.845]             `<<-` <- base::`<<-`
[17:03:51.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:51.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:51.845]                   3L)]
[17:03:51.845]             }
[17:03:51.845]             function(cond) {
[17:03:51.845]                 is_error <- inherits(cond, "error")
[17:03:51.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:51.845]                   NULL)
[17:03:51.845]                 if (is_error) {
[17:03:51.845]                   sessionInformation <- function() {
[17:03:51.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:51.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:51.845]                       search = base::search(), system = base::Sys.info())
[17:03:51.845]                   }
[17:03:51.845]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:51.845]                     cond$call), session = sessionInformation(), 
[17:03:51.845]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:51.845]                   signalCondition(cond)
[17:03:51.845]                 }
[17:03:51.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:51.845]                 "immediateCondition"))) {
[17:03:51.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:51.845]                   ...future.conditions[[length(...future.conditions) + 
[17:03:51.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:51.845]                   if (TRUE && !signal) {
[17:03:51.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.845]                     {
[17:03:51.845]                       inherits <- base::inherits
[17:03:51.845]                       invokeRestart <- base::invokeRestart
[17:03:51.845]                       is.null <- base::is.null
[17:03:51.845]                       muffled <- FALSE
[17:03:51.845]                       if (inherits(cond, "message")) {
[17:03:51.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.845]                         if (muffled) 
[17:03:51.845]                           invokeRestart("muffleMessage")
[17:03:51.845]                       }
[17:03:51.845]                       else if (inherits(cond, "warning")) {
[17:03:51.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.845]                         if (muffled) 
[17:03:51.845]                           invokeRestart("muffleWarning")
[17:03:51.845]                       }
[17:03:51.845]                       else if (inherits(cond, "condition")) {
[17:03:51.845]                         if (!is.null(pattern)) {
[17:03:51.845]                           computeRestarts <- base::computeRestarts
[17:03:51.845]                           grepl <- base::grepl
[17:03:51.845]                           restarts <- computeRestarts(cond)
[17:03:51.845]                           for (restart in restarts) {
[17:03:51.845]                             name <- restart$name
[17:03:51.845]                             if (is.null(name)) 
[17:03:51.845]                               next
[17:03:51.845]                             if (!grepl(pattern, name)) 
[17:03:51.845]                               next
[17:03:51.845]                             invokeRestart(restart)
[17:03:51.845]                             muffled <- TRUE
[17:03:51.845]                             break
[17:03:51.845]                           }
[17:03:51.845]                         }
[17:03:51.845]                       }
[17:03:51.845]                       invisible(muffled)
[17:03:51.845]                     }
[17:03:51.845]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.845]                   }
[17:03:51.845]                 }
[17:03:51.845]                 else {
[17:03:51.845]                   if (TRUE) {
[17:03:51.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:51.845]                     {
[17:03:51.845]                       inherits <- base::inherits
[17:03:51.845]                       invokeRestart <- base::invokeRestart
[17:03:51.845]                       is.null <- base::is.null
[17:03:51.845]                       muffled <- FALSE
[17:03:51.845]                       if (inherits(cond, "message")) {
[17:03:51.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:51.845]                         if (muffled) 
[17:03:51.845]                           invokeRestart("muffleMessage")
[17:03:51.845]                       }
[17:03:51.845]                       else if (inherits(cond, "warning")) {
[17:03:51.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:51.845]                         if (muffled) 
[17:03:51.845]                           invokeRestart("muffleWarning")
[17:03:51.845]                       }
[17:03:51.845]                       else if (inherits(cond, "condition")) {
[17:03:51.845]                         if (!is.null(pattern)) {
[17:03:51.845]                           computeRestarts <- base::computeRestarts
[17:03:51.845]                           grepl <- base::grepl
[17:03:51.845]                           restarts <- computeRestarts(cond)
[17:03:51.845]                           for (restart in restarts) {
[17:03:51.845]                             name <- restart$name
[17:03:51.845]                             if (is.null(name)) 
[17:03:51.845]                               next
[17:03:51.845]                             if (!grepl(pattern, name)) 
[17:03:51.845]                               next
[17:03:51.845]                             invokeRestart(restart)
[17:03:51.845]                             muffled <- TRUE
[17:03:51.845]                             break
[17:03:51.845]                           }
[17:03:51.845]                         }
[17:03:51.845]                       }
[17:03:51.845]                       invisible(muffled)
[17:03:51.845]                     }
[17:03:51.845]                     muffleCondition(cond, pattern = "^muffle")
[17:03:51.845]                   }
[17:03:51.845]                 }
[17:03:51.845]             }
[17:03:51.845]         }))
[17:03:51.845]     }, error = function(ex) {
[17:03:51.845]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:51.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:51.845]                 ...future.rng), started = ...future.startTime, 
[17:03:51.845]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:51.845]             version = "1.8"), class = "FutureResult")
[17:03:51.845]     }, finally = {
[17:03:51.845]         if (!identical(...future.workdir, getwd())) 
[17:03:51.845]             setwd(...future.workdir)
[17:03:51.845]         {
[17:03:51.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:51.845]                 ...future.oldOptions$nwarnings <- NULL
[17:03:51.845]             }
[17:03:51.845]             base::options(...future.oldOptions)
[17:03:51.845]             if (.Platform$OS.type == "windows") {
[17:03:51.845]                 old_names <- names(...future.oldEnvVars)
[17:03:51.845]                 envs <- base::Sys.getenv()
[17:03:51.845]                 names <- names(envs)
[17:03:51.845]                 common <- intersect(names, old_names)
[17:03:51.845]                 added <- setdiff(names, old_names)
[17:03:51.845]                 removed <- setdiff(old_names, names)
[17:03:51.845]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:51.845]                   envs[common]]
[17:03:51.845]                 NAMES <- toupper(changed)
[17:03:51.845]                 args <- list()
[17:03:51.845]                 for (kk in seq_along(NAMES)) {
[17:03:51.845]                   name <- changed[[kk]]
[17:03:51.845]                   NAME <- NAMES[[kk]]
[17:03:51.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.845]                     next
[17:03:51.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.845]                 }
[17:03:51.845]                 NAMES <- toupper(added)
[17:03:51.845]                 for (kk in seq_along(NAMES)) {
[17:03:51.845]                   name <- added[[kk]]
[17:03:51.845]                   NAME <- NAMES[[kk]]
[17:03:51.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.845]                     next
[17:03:51.845]                   args[[name]] <- ""
[17:03:51.845]                 }
[17:03:51.845]                 NAMES <- toupper(removed)
[17:03:51.845]                 for (kk in seq_along(NAMES)) {
[17:03:51.845]                   name <- removed[[kk]]
[17:03:51.845]                   NAME <- NAMES[[kk]]
[17:03:51.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:51.845]                     next
[17:03:51.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:51.845]                 }
[17:03:51.845]                 if (length(args) > 0) 
[17:03:51.845]                   base::do.call(base::Sys.setenv, args = args)
[17:03:51.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:51.845]             }
[17:03:51.845]             else {
[17:03:51.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:51.845]             }
[17:03:51.845]             {
[17:03:51.845]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:51.845]                   0L) {
[17:03:51.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:51.845]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:51.845]                   base::options(opts)
[17:03:51.845]                 }
[17:03:51.845]                 {
[17:03:51.845]                   {
[17:03:51.845]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:51.845]                     NULL
[17:03:51.845]                   }
[17:03:51.845]                   options(future.plan = NULL)
[17:03:51.845]                   if (is.na(NA_character_)) 
[17:03:51.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:51.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:51.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:51.845]                     .init = FALSE)
[17:03:51.845]                 }
[17:03:51.845]             }
[17:03:51.845]         }
[17:03:51.845]     })
[17:03:51.845]     if (TRUE) {
[17:03:51.845]         base::sink(type = "output", split = FALSE)
[17:03:51.845]         if (TRUE) {
[17:03:51.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:51.845]         }
[17:03:51.845]         else {
[17:03:51.845]             ...future.result["stdout"] <- base::list(NULL)
[17:03:51.845]         }
[17:03:51.845]         base::close(...future.stdout)
[17:03:51.845]         ...future.stdout <- NULL
[17:03:51.845]     }
[17:03:51.845]     ...future.result$conditions <- ...future.conditions
[17:03:51.845]     ...future.result$finished <- base::Sys.time()
[17:03:51.845]     ...future.result
[17:03:51.845] }
[17:03:51.848] MultisessionFuture started
[17:03:51.848] - Launch lazy future ... done
[17:03:51.849] run() for ‘MultisessionFuture’ ... done
[17:03:52.351] receiveMessageFromWorker() for ClusterFuture ...
[17:03:52.351] - Validating connection of MultisessionFuture
[17:03:52.351] - received message: FutureResult
[17:03:52.352] - Received FutureResult
[17:03:52.352] - Erased future from FutureRegistry
[17:03:52.352] result() for ClusterFuture ...
[17:03:52.352] - result already collected: FutureResult
[17:03:52.352] result() for ClusterFuture ... done
[17:03:52.352] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:52.352] resolve() on list ...
[17:03:52.352]  recursive: 0
[17:03:52.352]  length: 2
[17:03:52.352]  elements: ‘a’, ‘b’
[17:03:52.353]  length: 1 (resolved future 1)
[17:03:52.353]  length: 0 (resolved future 2)
[17:03:52.353] resolve() on list ... DONE
[17:03:52.353] A MultisessionFuture was resolved (and resolved itself)
[17:03:52.353] getGlobalsAndPackages() ...
[17:03:52.353] Searching for globals...
[17:03:52.354] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:52.354] Searching for globals ... DONE
[17:03:52.354] Resolving globals: FALSE
[17:03:52.355] 
[17:03:52.355] 
[17:03:52.355] getGlobalsAndPackages() ... DONE
[17:03:52.355] run() for ‘Future’ ...
[17:03:52.355] - state: ‘created’
[17:03:52.355] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:52.369] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:52.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:52.369]   - Field: ‘node’
[17:03:52.370]   - Field: ‘label’
[17:03:52.370]   - Field: ‘local’
[17:03:52.370]   - Field: ‘owner’
[17:03:52.370]   - Field: ‘envir’
[17:03:52.370]   - Field: ‘workers’
[17:03:52.370]   - Field: ‘packages’
[17:03:52.370]   - Field: ‘gc’
[17:03:52.370]   - Field: ‘conditions’
[17:03:52.370]   - Field: ‘persistent’
[17:03:52.370]   - Field: ‘expr’
[17:03:52.370]   - Field: ‘uuid’
[17:03:52.371]   - Field: ‘seed’
[17:03:52.371]   - Field: ‘version’
[17:03:52.371]   - Field: ‘result’
[17:03:52.371]   - Field: ‘asynchronous’
[17:03:52.371]   - Field: ‘calls’
[17:03:52.371]   - Field: ‘globals’
[17:03:52.371]   - Field: ‘stdout’
[17:03:52.371]   - Field: ‘earlySignal’
[17:03:52.371]   - Field: ‘lazy’
[17:03:52.371]   - Field: ‘state’
[17:03:52.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:52.372] - Launch lazy future ...
[17:03:52.372] Packages needed by the future expression (n = 0): <none>
[17:03:52.372] Packages needed by future strategies (n = 0): <none>
[17:03:52.372] {
[17:03:52.372]     {
[17:03:52.372]         {
[17:03:52.372]             ...future.startTime <- base::Sys.time()
[17:03:52.372]             {
[17:03:52.372]                 {
[17:03:52.372]                   {
[17:03:52.372]                     {
[17:03:52.372]                       base::local({
[17:03:52.372]                         has_future <- base::requireNamespace("future", 
[17:03:52.372]                           quietly = TRUE)
[17:03:52.372]                         if (has_future) {
[17:03:52.372]                           ns <- base::getNamespace("future")
[17:03:52.372]                           version <- ns[[".package"]][["version"]]
[17:03:52.372]                           if (is.null(version)) 
[17:03:52.372]                             version <- utils::packageVersion("future")
[17:03:52.372]                         }
[17:03:52.372]                         else {
[17:03:52.372]                           version <- NULL
[17:03:52.372]                         }
[17:03:52.372]                         if (!has_future || version < "1.8.0") {
[17:03:52.372]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:52.372]                             "", base::R.version$version.string), 
[17:03:52.372]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:52.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:52.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:52.372]                               "release", "version")], collapse = " "), 
[17:03:52.372]                             hostname = base::Sys.info()[["nodename"]])
[17:03:52.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:52.372]                             info)
[17:03:52.372]                           info <- base::paste(info, collapse = "; ")
[17:03:52.372]                           if (!has_future) {
[17:03:52.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:52.372]                               info)
[17:03:52.372]                           }
[17:03:52.372]                           else {
[17:03:52.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:52.372]                               info, version)
[17:03:52.372]                           }
[17:03:52.372]                           base::stop(msg)
[17:03:52.372]                         }
[17:03:52.372]                       })
[17:03:52.372]                     }
[17:03:52.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:52.372]                     base::options(mc.cores = 1L)
[17:03:52.372]                   }
[17:03:52.372]                   ...future.strategy.old <- future::plan("list")
[17:03:52.372]                   options(future.plan = NULL)
[17:03:52.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:52.372]                 }
[17:03:52.372]                 ...future.workdir <- getwd()
[17:03:52.372]             }
[17:03:52.372]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:52.372]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:52.372]         }
[17:03:52.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:52.372]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:52.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:52.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:52.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:52.372]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:52.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:52.372]             base::names(...future.oldOptions))
[17:03:52.372]     }
[17:03:52.372]     if (FALSE) {
[17:03:52.372]     }
[17:03:52.372]     else {
[17:03:52.372]         if (TRUE) {
[17:03:52.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:52.372]                 open = "w")
[17:03:52.372]         }
[17:03:52.372]         else {
[17:03:52.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:52.372]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:52.372]         }
[17:03:52.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:52.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:52.372]             base::sink(type = "output", split = FALSE)
[17:03:52.372]             base::close(...future.stdout)
[17:03:52.372]         }, add = TRUE)
[17:03:52.372]     }
[17:03:52.372]     ...future.frame <- base::sys.nframe()
[17:03:52.372]     ...future.conditions <- base::list()
[17:03:52.372]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:52.372]     if (FALSE) {
[17:03:52.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:52.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:52.372]     }
[17:03:52.372]     ...future.result <- base::tryCatch({
[17:03:52.372]         base::withCallingHandlers({
[17:03:52.372]             ...future.value <- base::withVisible(base::local({
[17:03:52.372]                 ...future.makeSendCondition <- base::local({
[17:03:52.372]                   sendCondition <- NULL
[17:03:52.372]                   function(frame = 1L) {
[17:03:52.372]                     if (is.function(sendCondition)) 
[17:03:52.372]                       return(sendCondition)
[17:03:52.372]                     ns <- getNamespace("parallel")
[17:03:52.372]                     if (exists("sendData", mode = "function", 
[17:03:52.372]                       envir = ns)) {
[17:03:52.372]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:52.372]                         envir = ns)
[17:03:52.372]                       envir <- sys.frame(frame)
[17:03:52.372]                       master <- NULL
[17:03:52.372]                       while (!identical(envir, .GlobalEnv) && 
[17:03:52.372]                         !identical(envir, emptyenv())) {
[17:03:52.372]                         if (exists("master", mode = "list", envir = envir, 
[17:03:52.372]                           inherits = FALSE)) {
[17:03:52.372]                           master <- get("master", mode = "list", 
[17:03:52.372]                             envir = envir, inherits = FALSE)
[17:03:52.372]                           if (inherits(master, c("SOCKnode", 
[17:03:52.372]                             "SOCK0node"))) {
[17:03:52.372]                             sendCondition <<- function(cond) {
[17:03:52.372]                               data <- list(type = "VALUE", value = cond, 
[17:03:52.372]                                 success = TRUE)
[17:03:52.372]                               parallel_sendData(master, data)
[17:03:52.372]                             }
[17:03:52.372]                             return(sendCondition)
[17:03:52.372]                           }
[17:03:52.372]                         }
[17:03:52.372]                         frame <- frame + 1L
[17:03:52.372]                         envir <- sys.frame(frame)
[17:03:52.372]                       }
[17:03:52.372]                     }
[17:03:52.372]                     sendCondition <<- function(cond) NULL
[17:03:52.372]                   }
[17:03:52.372]                 })
[17:03:52.372]                 withCallingHandlers({
[17:03:52.372]                   {
[17:03:52.372]                     Sys.sleep(0.5)
[17:03:52.372]                     list(a = 1, b = 42L)
[17:03:52.372]                   }
[17:03:52.372]                 }, immediateCondition = function(cond) {
[17:03:52.372]                   sendCondition <- ...future.makeSendCondition()
[17:03:52.372]                   sendCondition(cond)
[17:03:52.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.372]                   {
[17:03:52.372]                     inherits <- base::inherits
[17:03:52.372]                     invokeRestart <- base::invokeRestart
[17:03:52.372]                     is.null <- base::is.null
[17:03:52.372]                     muffled <- FALSE
[17:03:52.372]                     if (inherits(cond, "message")) {
[17:03:52.372]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:52.372]                       if (muffled) 
[17:03:52.372]                         invokeRestart("muffleMessage")
[17:03:52.372]                     }
[17:03:52.372]                     else if (inherits(cond, "warning")) {
[17:03:52.372]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:52.372]                       if (muffled) 
[17:03:52.372]                         invokeRestart("muffleWarning")
[17:03:52.372]                     }
[17:03:52.372]                     else if (inherits(cond, "condition")) {
[17:03:52.372]                       if (!is.null(pattern)) {
[17:03:52.372]                         computeRestarts <- base::computeRestarts
[17:03:52.372]                         grepl <- base::grepl
[17:03:52.372]                         restarts <- computeRestarts(cond)
[17:03:52.372]                         for (restart in restarts) {
[17:03:52.372]                           name <- restart$name
[17:03:52.372]                           if (is.null(name)) 
[17:03:52.372]                             next
[17:03:52.372]                           if (!grepl(pattern, name)) 
[17:03:52.372]                             next
[17:03:52.372]                           invokeRestart(restart)
[17:03:52.372]                           muffled <- TRUE
[17:03:52.372]                           break
[17:03:52.372]                         }
[17:03:52.372]                       }
[17:03:52.372]                     }
[17:03:52.372]                     invisible(muffled)
[17:03:52.372]                   }
[17:03:52.372]                   muffleCondition(cond)
[17:03:52.372]                 })
[17:03:52.372]             }))
[17:03:52.372]             future::FutureResult(value = ...future.value$value, 
[17:03:52.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.372]                   ...future.rng), globalenv = if (FALSE) 
[17:03:52.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:52.372]                     ...future.globalenv.names))
[17:03:52.372]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:52.372]         }, condition = base::local({
[17:03:52.372]             c <- base::c
[17:03:52.372]             inherits <- base::inherits
[17:03:52.372]             invokeRestart <- base::invokeRestart
[17:03:52.372]             length <- base::length
[17:03:52.372]             list <- base::list
[17:03:52.372]             seq.int <- base::seq.int
[17:03:52.372]             signalCondition <- base::signalCondition
[17:03:52.372]             sys.calls <- base::sys.calls
[17:03:52.372]             `[[` <- base::`[[`
[17:03:52.372]             `+` <- base::`+`
[17:03:52.372]             `<<-` <- base::`<<-`
[17:03:52.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:52.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:52.372]                   3L)]
[17:03:52.372]             }
[17:03:52.372]             function(cond) {
[17:03:52.372]                 is_error <- inherits(cond, "error")
[17:03:52.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:52.372]                   NULL)
[17:03:52.372]                 if (is_error) {
[17:03:52.372]                   sessionInformation <- function() {
[17:03:52.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:52.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:52.372]                       search = base::search(), system = base::Sys.info())
[17:03:52.372]                   }
[17:03:52.372]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:52.372]                     cond$call), session = sessionInformation(), 
[17:03:52.372]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:52.372]                   signalCondition(cond)
[17:03:52.372]                 }
[17:03:52.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:52.372]                 "immediateCondition"))) {
[17:03:52.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:52.372]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:52.372]                   if (TRUE && !signal) {
[17:03:52.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.372]                     {
[17:03:52.372]                       inherits <- base::inherits
[17:03:52.372]                       invokeRestart <- base::invokeRestart
[17:03:52.372]                       is.null <- base::is.null
[17:03:52.372]                       muffled <- FALSE
[17:03:52.372]                       if (inherits(cond, "message")) {
[17:03:52.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.372]                         if (muffled) 
[17:03:52.372]                           invokeRestart("muffleMessage")
[17:03:52.372]                       }
[17:03:52.372]                       else if (inherits(cond, "warning")) {
[17:03:52.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.372]                         if (muffled) 
[17:03:52.372]                           invokeRestart("muffleWarning")
[17:03:52.372]                       }
[17:03:52.372]                       else if (inherits(cond, "condition")) {
[17:03:52.372]                         if (!is.null(pattern)) {
[17:03:52.372]                           computeRestarts <- base::computeRestarts
[17:03:52.372]                           grepl <- base::grepl
[17:03:52.372]                           restarts <- computeRestarts(cond)
[17:03:52.372]                           for (restart in restarts) {
[17:03:52.372]                             name <- restart$name
[17:03:52.372]                             if (is.null(name)) 
[17:03:52.372]                               next
[17:03:52.372]                             if (!grepl(pattern, name)) 
[17:03:52.372]                               next
[17:03:52.372]                             invokeRestart(restart)
[17:03:52.372]                             muffled <- TRUE
[17:03:52.372]                             break
[17:03:52.372]                           }
[17:03:52.372]                         }
[17:03:52.372]                       }
[17:03:52.372]                       invisible(muffled)
[17:03:52.372]                     }
[17:03:52.372]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.372]                   }
[17:03:52.372]                 }
[17:03:52.372]                 else {
[17:03:52.372]                   if (TRUE) {
[17:03:52.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.372]                     {
[17:03:52.372]                       inherits <- base::inherits
[17:03:52.372]                       invokeRestart <- base::invokeRestart
[17:03:52.372]                       is.null <- base::is.null
[17:03:52.372]                       muffled <- FALSE
[17:03:52.372]                       if (inherits(cond, "message")) {
[17:03:52.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.372]                         if (muffled) 
[17:03:52.372]                           invokeRestart("muffleMessage")
[17:03:52.372]                       }
[17:03:52.372]                       else if (inherits(cond, "warning")) {
[17:03:52.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.372]                         if (muffled) 
[17:03:52.372]                           invokeRestart("muffleWarning")
[17:03:52.372]                       }
[17:03:52.372]                       else if (inherits(cond, "condition")) {
[17:03:52.372]                         if (!is.null(pattern)) {
[17:03:52.372]                           computeRestarts <- base::computeRestarts
[17:03:52.372]                           grepl <- base::grepl
[17:03:52.372]                           restarts <- computeRestarts(cond)
[17:03:52.372]                           for (restart in restarts) {
[17:03:52.372]                             name <- restart$name
[17:03:52.372]                             if (is.null(name)) 
[17:03:52.372]                               next
[17:03:52.372]                             if (!grepl(pattern, name)) 
[17:03:52.372]                               next
[17:03:52.372]                             invokeRestart(restart)
[17:03:52.372]                             muffled <- TRUE
[17:03:52.372]                             break
[17:03:52.372]                           }
[17:03:52.372]                         }
[17:03:52.372]                       }
[17:03:52.372]                       invisible(muffled)
[17:03:52.372]                     }
[17:03:52.372]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.372]                   }
[17:03:52.372]                 }
[17:03:52.372]             }
[17:03:52.372]         }))
[17:03:52.372]     }, error = function(ex) {
[17:03:52.372]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:52.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.372]                 ...future.rng), started = ...future.startTime, 
[17:03:52.372]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:52.372]             version = "1.8"), class = "FutureResult")
[17:03:52.372]     }, finally = {
[17:03:52.372]         if (!identical(...future.workdir, getwd())) 
[17:03:52.372]             setwd(...future.workdir)
[17:03:52.372]         {
[17:03:52.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:52.372]                 ...future.oldOptions$nwarnings <- NULL
[17:03:52.372]             }
[17:03:52.372]             base::options(...future.oldOptions)
[17:03:52.372]             if (.Platform$OS.type == "windows") {
[17:03:52.372]                 old_names <- names(...future.oldEnvVars)
[17:03:52.372]                 envs <- base::Sys.getenv()
[17:03:52.372]                 names <- names(envs)
[17:03:52.372]                 common <- intersect(names, old_names)
[17:03:52.372]                 added <- setdiff(names, old_names)
[17:03:52.372]                 removed <- setdiff(old_names, names)
[17:03:52.372]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:52.372]                   envs[common]]
[17:03:52.372]                 NAMES <- toupper(changed)
[17:03:52.372]                 args <- list()
[17:03:52.372]                 for (kk in seq_along(NAMES)) {
[17:03:52.372]                   name <- changed[[kk]]
[17:03:52.372]                   NAME <- NAMES[[kk]]
[17:03:52.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.372]                     next
[17:03:52.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.372]                 }
[17:03:52.372]                 NAMES <- toupper(added)
[17:03:52.372]                 for (kk in seq_along(NAMES)) {
[17:03:52.372]                   name <- added[[kk]]
[17:03:52.372]                   NAME <- NAMES[[kk]]
[17:03:52.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.372]                     next
[17:03:52.372]                   args[[name]] <- ""
[17:03:52.372]                 }
[17:03:52.372]                 NAMES <- toupper(removed)
[17:03:52.372]                 for (kk in seq_along(NAMES)) {
[17:03:52.372]                   name <- removed[[kk]]
[17:03:52.372]                   NAME <- NAMES[[kk]]
[17:03:52.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.372]                     next
[17:03:52.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.372]                 }
[17:03:52.372]                 if (length(args) > 0) 
[17:03:52.372]                   base::do.call(base::Sys.setenv, args = args)
[17:03:52.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:52.372]             }
[17:03:52.372]             else {
[17:03:52.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:52.372]             }
[17:03:52.372]             {
[17:03:52.372]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:52.372]                   0L) {
[17:03:52.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:52.372]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:52.372]                   base::options(opts)
[17:03:52.372]                 }
[17:03:52.372]                 {
[17:03:52.372]                   {
[17:03:52.372]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:52.372]                     NULL
[17:03:52.372]                   }
[17:03:52.372]                   options(future.plan = NULL)
[17:03:52.372]                   if (is.na(NA_character_)) 
[17:03:52.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:52.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:52.372]                     .init = FALSE)
[17:03:52.372]                 }
[17:03:52.372]             }
[17:03:52.372]         }
[17:03:52.372]     })
[17:03:52.372]     if (TRUE) {
[17:03:52.372]         base::sink(type = "output", split = FALSE)
[17:03:52.372]         if (TRUE) {
[17:03:52.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:52.372]         }
[17:03:52.372]         else {
[17:03:52.372]             ...future.result["stdout"] <- base::list(NULL)
[17:03:52.372]         }
[17:03:52.372]         base::close(...future.stdout)
[17:03:52.372]         ...future.stdout <- NULL
[17:03:52.372]     }
[17:03:52.372]     ...future.result$conditions <- ...future.conditions
[17:03:52.372]     ...future.result$finished <- base::Sys.time()
[17:03:52.372]     ...future.result
[17:03:52.372] }
[17:03:52.375] MultisessionFuture started
[17:03:52.376] - Launch lazy future ... done
[17:03:52.376] run() for ‘MultisessionFuture’ ... done
[17:03:52.878] receiveMessageFromWorker() for ClusterFuture ...
[17:03:52.878] - Validating connection of MultisessionFuture
[17:03:52.879] - received message: FutureResult
[17:03:52.879] - Received FutureResult
[17:03:52.879] - Erased future from FutureRegistry
[17:03:52.879] result() for ClusterFuture ...
[17:03:52.879] - result already collected: FutureResult
[17:03:52.879] result() for ClusterFuture ... done
[17:03:52.879] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:52.879] resolve() on list ...
[17:03:52.879]  recursive: 0
[17:03:52.880]  length: 2
[17:03:52.880]  elements: ‘a’, ‘b’
[17:03:52.880]  length: 1 (resolved future 1)
[17:03:52.880]  length: 0 (resolved future 2)
[17:03:52.880] resolve() on list ... DONE
[17:03:52.880] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:03:52.880] getGlobalsAndPackages() ...
[17:03:52.880] Searching for globals...
[17:03:52.881] - globals found: [2] ‘list’, ‘stop’
[17:03:52.881] Searching for globals ... DONE
[17:03:52.881] Resolving globals: FALSE
[17:03:52.882] 
[17:03:52.882] 
[17:03:52.882] getGlobalsAndPackages() ... DONE
[17:03:52.882] run() for ‘Future’ ...
[17:03:52.882] - state: ‘created’
[17:03:52.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:52.907] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:52.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:52.907]   - Field: ‘node’
[17:03:52.907]   - Field: ‘label’
[17:03:52.907]   - Field: ‘local’
[17:03:52.907]   - Field: ‘owner’
[17:03:52.907]   - Field: ‘envir’
[17:03:52.907]   - Field: ‘workers’
[17:03:52.908]   - Field: ‘packages’
[17:03:52.908]   - Field: ‘gc’
[17:03:52.908]   - Field: ‘conditions’
[17:03:52.908]   - Field: ‘persistent’
[17:03:52.908]   - Field: ‘expr’
[17:03:52.908]   - Field: ‘uuid’
[17:03:52.908]   - Field: ‘seed’
[17:03:52.908]   - Field: ‘version’
[17:03:52.908]   - Field: ‘result’
[17:03:52.908]   - Field: ‘asynchronous’
[17:03:52.909]   - Field: ‘calls’
[17:03:52.909]   - Field: ‘globals’
[17:03:52.909]   - Field: ‘stdout’
[17:03:52.909]   - Field: ‘earlySignal’
[17:03:52.909]   - Field: ‘lazy’
[17:03:52.909]   - Field: ‘state’
[17:03:52.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:52.909] - Launch lazy future ...
[17:03:52.909] Packages needed by the future expression (n = 0): <none>
[17:03:52.910] Packages needed by future strategies (n = 0): <none>
[17:03:52.910] {
[17:03:52.910]     {
[17:03:52.910]         {
[17:03:52.910]             ...future.startTime <- base::Sys.time()
[17:03:52.910]             {
[17:03:52.910]                 {
[17:03:52.910]                   {
[17:03:52.910]                     {
[17:03:52.910]                       base::local({
[17:03:52.910]                         has_future <- base::requireNamespace("future", 
[17:03:52.910]                           quietly = TRUE)
[17:03:52.910]                         if (has_future) {
[17:03:52.910]                           ns <- base::getNamespace("future")
[17:03:52.910]                           version <- ns[[".package"]][["version"]]
[17:03:52.910]                           if (is.null(version)) 
[17:03:52.910]                             version <- utils::packageVersion("future")
[17:03:52.910]                         }
[17:03:52.910]                         else {
[17:03:52.910]                           version <- NULL
[17:03:52.910]                         }
[17:03:52.910]                         if (!has_future || version < "1.8.0") {
[17:03:52.910]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:52.910]                             "", base::R.version$version.string), 
[17:03:52.910]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:52.910]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:52.910]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:52.910]                               "release", "version")], collapse = " "), 
[17:03:52.910]                             hostname = base::Sys.info()[["nodename"]])
[17:03:52.910]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:52.910]                             info)
[17:03:52.910]                           info <- base::paste(info, collapse = "; ")
[17:03:52.910]                           if (!has_future) {
[17:03:52.910]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:52.910]                               info)
[17:03:52.910]                           }
[17:03:52.910]                           else {
[17:03:52.910]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:52.910]                               info, version)
[17:03:52.910]                           }
[17:03:52.910]                           base::stop(msg)
[17:03:52.910]                         }
[17:03:52.910]                       })
[17:03:52.910]                     }
[17:03:52.910]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:52.910]                     base::options(mc.cores = 1L)
[17:03:52.910]                   }
[17:03:52.910]                   ...future.strategy.old <- future::plan("list")
[17:03:52.910]                   options(future.plan = NULL)
[17:03:52.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:52.910]                 }
[17:03:52.910]                 ...future.workdir <- getwd()
[17:03:52.910]             }
[17:03:52.910]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:52.910]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:52.910]         }
[17:03:52.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:52.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:52.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:52.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:52.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:52.910]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:52.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:52.910]             base::names(...future.oldOptions))
[17:03:52.910]     }
[17:03:52.910]     if (FALSE) {
[17:03:52.910]     }
[17:03:52.910]     else {
[17:03:52.910]         if (TRUE) {
[17:03:52.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:52.910]                 open = "w")
[17:03:52.910]         }
[17:03:52.910]         else {
[17:03:52.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:52.910]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:52.910]         }
[17:03:52.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:52.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:52.910]             base::sink(type = "output", split = FALSE)
[17:03:52.910]             base::close(...future.stdout)
[17:03:52.910]         }, add = TRUE)
[17:03:52.910]     }
[17:03:52.910]     ...future.frame <- base::sys.nframe()
[17:03:52.910]     ...future.conditions <- base::list()
[17:03:52.910]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:52.910]     if (FALSE) {
[17:03:52.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:52.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:52.910]     }
[17:03:52.910]     ...future.result <- base::tryCatch({
[17:03:52.910]         base::withCallingHandlers({
[17:03:52.910]             ...future.value <- base::withVisible(base::local({
[17:03:52.910]                 ...future.makeSendCondition <- base::local({
[17:03:52.910]                   sendCondition <- NULL
[17:03:52.910]                   function(frame = 1L) {
[17:03:52.910]                     if (is.function(sendCondition)) 
[17:03:52.910]                       return(sendCondition)
[17:03:52.910]                     ns <- getNamespace("parallel")
[17:03:52.910]                     if (exists("sendData", mode = "function", 
[17:03:52.910]                       envir = ns)) {
[17:03:52.910]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:52.910]                         envir = ns)
[17:03:52.910]                       envir <- sys.frame(frame)
[17:03:52.910]                       master <- NULL
[17:03:52.910]                       while (!identical(envir, .GlobalEnv) && 
[17:03:52.910]                         !identical(envir, emptyenv())) {
[17:03:52.910]                         if (exists("master", mode = "list", envir = envir, 
[17:03:52.910]                           inherits = FALSE)) {
[17:03:52.910]                           master <- get("master", mode = "list", 
[17:03:52.910]                             envir = envir, inherits = FALSE)
[17:03:52.910]                           if (inherits(master, c("SOCKnode", 
[17:03:52.910]                             "SOCK0node"))) {
[17:03:52.910]                             sendCondition <<- function(cond) {
[17:03:52.910]                               data <- list(type = "VALUE", value = cond, 
[17:03:52.910]                                 success = TRUE)
[17:03:52.910]                               parallel_sendData(master, data)
[17:03:52.910]                             }
[17:03:52.910]                             return(sendCondition)
[17:03:52.910]                           }
[17:03:52.910]                         }
[17:03:52.910]                         frame <- frame + 1L
[17:03:52.910]                         envir <- sys.frame(frame)
[17:03:52.910]                       }
[17:03:52.910]                     }
[17:03:52.910]                     sendCondition <<- function(cond) NULL
[17:03:52.910]                   }
[17:03:52.910]                 })
[17:03:52.910]                 withCallingHandlers({
[17:03:52.910]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:52.910]                 }, immediateCondition = function(cond) {
[17:03:52.910]                   sendCondition <- ...future.makeSendCondition()
[17:03:52.910]                   sendCondition(cond)
[17:03:52.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.910]                   {
[17:03:52.910]                     inherits <- base::inherits
[17:03:52.910]                     invokeRestart <- base::invokeRestart
[17:03:52.910]                     is.null <- base::is.null
[17:03:52.910]                     muffled <- FALSE
[17:03:52.910]                     if (inherits(cond, "message")) {
[17:03:52.910]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:52.910]                       if (muffled) 
[17:03:52.910]                         invokeRestart("muffleMessage")
[17:03:52.910]                     }
[17:03:52.910]                     else if (inherits(cond, "warning")) {
[17:03:52.910]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:52.910]                       if (muffled) 
[17:03:52.910]                         invokeRestart("muffleWarning")
[17:03:52.910]                     }
[17:03:52.910]                     else if (inherits(cond, "condition")) {
[17:03:52.910]                       if (!is.null(pattern)) {
[17:03:52.910]                         computeRestarts <- base::computeRestarts
[17:03:52.910]                         grepl <- base::grepl
[17:03:52.910]                         restarts <- computeRestarts(cond)
[17:03:52.910]                         for (restart in restarts) {
[17:03:52.910]                           name <- restart$name
[17:03:52.910]                           if (is.null(name)) 
[17:03:52.910]                             next
[17:03:52.910]                           if (!grepl(pattern, name)) 
[17:03:52.910]                             next
[17:03:52.910]                           invokeRestart(restart)
[17:03:52.910]                           muffled <- TRUE
[17:03:52.910]                           break
[17:03:52.910]                         }
[17:03:52.910]                       }
[17:03:52.910]                     }
[17:03:52.910]                     invisible(muffled)
[17:03:52.910]                   }
[17:03:52.910]                   muffleCondition(cond)
[17:03:52.910]                 })
[17:03:52.910]             }))
[17:03:52.910]             future::FutureResult(value = ...future.value$value, 
[17:03:52.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.910]                   ...future.rng), globalenv = if (FALSE) 
[17:03:52.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:52.910]                     ...future.globalenv.names))
[17:03:52.910]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:52.910]         }, condition = base::local({
[17:03:52.910]             c <- base::c
[17:03:52.910]             inherits <- base::inherits
[17:03:52.910]             invokeRestart <- base::invokeRestart
[17:03:52.910]             length <- base::length
[17:03:52.910]             list <- base::list
[17:03:52.910]             seq.int <- base::seq.int
[17:03:52.910]             signalCondition <- base::signalCondition
[17:03:52.910]             sys.calls <- base::sys.calls
[17:03:52.910]             `[[` <- base::`[[`
[17:03:52.910]             `+` <- base::`+`
[17:03:52.910]             `<<-` <- base::`<<-`
[17:03:52.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:52.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:52.910]                   3L)]
[17:03:52.910]             }
[17:03:52.910]             function(cond) {
[17:03:52.910]                 is_error <- inherits(cond, "error")
[17:03:52.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:52.910]                   NULL)
[17:03:52.910]                 if (is_error) {
[17:03:52.910]                   sessionInformation <- function() {
[17:03:52.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:52.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:52.910]                       search = base::search(), system = base::Sys.info())
[17:03:52.910]                   }
[17:03:52.910]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:52.910]                     cond$call), session = sessionInformation(), 
[17:03:52.910]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:52.910]                   signalCondition(cond)
[17:03:52.910]                 }
[17:03:52.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:52.910]                 "immediateCondition"))) {
[17:03:52.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:52.910]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:52.910]                   if (TRUE && !signal) {
[17:03:52.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.910]                     {
[17:03:52.910]                       inherits <- base::inherits
[17:03:52.910]                       invokeRestart <- base::invokeRestart
[17:03:52.910]                       is.null <- base::is.null
[17:03:52.910]                       muffled <- FALSE
[17:03:52.910]                       if (inherits(cond, "message")) {
[17:03:52.910]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.910]                         if (muffled) 
[17:03:52.910]                           invokeRestart("muffleMessage")
[17:03:52.910]                       }
[17:03:52.910]                       else if (inherits(cond, "warning")) {
[17:03:52.910]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.910]                         if (muffled) 
[17:03:52.910]                           invokeRestart("muffleWarning")
[17:03:52.910]                       }
[17:03:52.910]                       else if (inherits(cond, "condition")) {
[17:03:52.910]                         if (!is.null(pattern)) {
[17:03:52.910]                           computeRestarts <- base::computeRestarts
[17:03:52.910]                           grepl <- base::grepl
[17:03:52.910]                           restarts <- computeRestarts(cond)
[17:03:52.910]                           for (restart in restarts) {
[17:03:52.910]                             name <- restart$name
[17:03:52.910]                             if (is.null(name)) 
[17:03:52.910]                               next
[17:03:52.910]                             if (!grepl(pattern, name)) 
[17:03:52.910]                               next
[17:03:52.910]                             invokeRestart(restart)
[17:03:52.910]                             muffled <- TRUE
[17:03:52.910]                             break
[17:03:52.910]                           }
[17:03:52.910]                         }
[17:03:52.910]                       }
[17:03:52.910]                       invisible(muffled)
[17:03:52.910]                     }
[17:03:52.910]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.910]                   }
[17:03:52.910]                 }
[17:03:52.910]                 else {
[17:03:52.910]                   if (TRUE) {
[17:03:52.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.910]                     {
[17:03:52.910]                       inherits <- base::inherits
[17:03:52.910]                       invokeRestart <- base::invokeRestart
[17:03:52.910]                       is.null <- base::is.null
[17:03:52.910]                       muffled <- FALSE
[17:03:52.910]                       if (inherits(cond, "message")) {
[17:03:52.910]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.910]                         if (muffled) 
[17:03:52.910]                           invokeRestart("muffleMessage")
[17:03:52.910]                       }
[17:03:52.910]                       else if (inherits(cond, "warning")) {
[17:03:52.910]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.910]                         if (muffled) 
[17:03:52.910]                           invokeRestart("muffleWarning")
[17:03:52.910]                       }
[17:03:52.910]                       else if (inherits(cond, "condition")) {
[17:03:52.910]                         if (!is.null(pattern)) {
[17:03:52.910]                           computeRestarts <- base::computeRestarts
[17:03:52.910]                           grepl <- base::grepl
[17:03:52.910]                           restarts <- computeRestarts(cond)
[17:03:52.910]                           for (restart in restarts) {
[17:03:52.910]                             name <- restart$name
[17:03:52.910]                             if (is.null(name)) 
[17:03:52.910]                               next
[17:03:52.910]                             if (!grepl(pattern, name)) 
[17:03:52.910]                               next
[17:03:52.910]                             invokeRestart(restart)
[17:03:52.910]                             muffled <- TRUE
[17:03:52.910]                             break
[17:03:52.910]                           }
[17:03:52.910]                         }
[17:03:52.910]                       }
[17:03:52.910]                       invisible(muffled)
[17:03:52.910]                     }
[17:03:52.910]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.910]                   }
[17:03:52.910]                 }
[17:03:52.910]             }
[17:03:52.910]         }))
[17:03:52.910]     }, error = function(ex) {
[17:03:52.910]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:52.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.910]                 ...future.rng), started = ...future.startTime, 
[17:03:52.910]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:52.910]             version = "1.8"), class = "FutureResult")
[17:03:52.910]     }, finally = {
[17:03:52.910]         if (!identical(...future.workdir, getwd())) 
[17:03:52.910]             setwd(...future.workdir)
[17:03:52.910]         {
[17:03:52.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:52.910]                 ...future.oldOptions$nwarnings <- NULL
[17:03:52.910]             }
[17:03:52.910]             base::options(...future.oldOptions)
[17:03:52.910]             if (.Platform$OS.type == "windows") {
[17:03:52.910]                 old_names <- names(...future.oldEnvVars)
[17:03:52.910]                 envs <- base::Sys.getenv()
[17:03:52.910]                 names <- names(envs)
[17:03:52.910]                 common <- intersect(names, old_names)
[17:03:52.910]                 added <- setdiff(names, old_names)
[17:03:52.910]                 removed <- setdiff(old_names, names)
[17:03:52.910]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:52.910]                   envs[common]]
[17:03:52.910]                 NAMES <- toupper(changed)
[17:03:52.910]                 args <- list()
[17:03:52.910]                 for (kk in seq_along(NAMES)) {
[17:03:52.910]                   name <- changed[[kk]]
[17:03:52.910]                   NAME <- NAMES[[kk]]
[17:03:52.910]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.910]                     next
[17:03:52.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.910]                 }
[17:03:52.910]                 NAMES <- toupper(added)
[17:03:52.910]                 for (kk in seq_along(NAMES)) {
[17:03:52.910]                   name <- added[[kk]]
[17:03:52.910]                   NAME <- NAMES[[kk]]
[17:03:52.910]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.910]                     next
[17:03:52.910]                   args[[name]] <- ""
[17:03:52.910]                 }
[17:03:52.910]                 NAMES <- toupper(removed)
[17:03:52.910]                 for (kk in seq_along(NAMES)) {
[17:03:52.910]                   name <- removed[[kk]]
[17:03:52.910]                   NAME <- NAMES[[kk]]
[17:03:52.910]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.910]                     next
[17:03:52.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.910]                 }
[17:03:52.910]                 if (length(args) > 0) 
[17:03:52.910]                   base::do.call(base::Sys.setenv, args = args)
[17:03:52.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:52.910]             }
[17:03:52.910]             else {
[17:03:52.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:52.910]             }
[17:03:52.910]             {
[17:03:52.910]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:52.910]                   0L) {
[17:03:52.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:52.910]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:52.910]                   base::options(opts)
[17:03:52.910]                 }
[17:03:52.910]                 {
[17:03:52.910]                   {
[17:03:52.910]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:52.910]                     NULL
[17:03:52.910]                   }
[17:03:52.910]                   options(future.plan = NULL)
[17:03:52.910]                   if (is.na(NA_character_)) 
[17:03:52.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:52.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:52.910]                     .init = FALSE)
[17:03:52.910]                 }
[17:03:52.910]             }
[17:03:52.910]         }
[17:03:52.910]     })
[17:03:52.910]     if (TRUE) {
[17:03:52.910]         base::sink(type = "output", split = FALSE)
[17:03:52.910]         if (TRUE) {
[17:03:52.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:52.910]         }
[17:03:52.910]         else {
[17:03:52.910]             ...future.result["stdout"] <- base::list(NULL)
[17:03:52.910]         }
[17:03:52.910]         base::close(...future.stdout)
[17:03:52.910]         ...future.stdout <- NULL
[17:03:52.910]     }
[17:03:52.910]     ...future.result$conditions <- ...future.conditions
[17:03:52.910]     ...future.result$finished <- base::Sys.time()
[17:03:52.910]     ...future.result
[17:03:52.910] }
[17:03:52.913] MultisessionFuture started
[17:03:52.913] - Launch lazy future ... done
[17:03:52.913] run() for ‘MultisessionFuture’ ... done
[17:03:52.915] receiveMessageFromWorker() for ClusterFuture ...
[17:03:52.915] - Validating connection of MultisessionFuture
[17:03:52.916] - received message: FutureResult
[17:03:52.916] - Received FutureResult
[17:03:52.916] - Erased future from FutureRegistry
[17:03:52.916] result() for ClusterFuture ...
[17:03:52.916] - result already collected: FutureResult
[17:03:52.916] result() for ClusterFuture ... done
[17:03:52.916] signalConditions() ...
[17:03:52.917]  - include = ‘immediateCondition’
[17:03:52.917]  - exclude = 
[17:03:52.917]  - resignal = FALSE
[17:03:52.917]  - Number of conditions: 1
[17:03:52.917] signalConditions() ... done
[17:03:52.917] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:52.917] A MultisessionFuture was resolved (and resolved itself)
[17:03:52.917] getGlobalsAndPackages() ...
[17:03:52.917] Searching for globals...
[17:03:52.918] - globals found: [2] ‘list’, ‘stop’
[17:03:52.918] Searching for globals ... DONE
[17:03:52.918] Resolving globals: FALSE
[17:03:52.918] 
[17:03:52.919] 
[17:03:52.919] getGlobalsAndPackages() ... DONE
[17:03:52.919] run() for ‘Future’ ...
[17:03:52.919] - state: ‘created’
[17:03:52.919] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:52.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:52.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:52.933]   - Field: ‘node’
[17:03:52.933]   - Field: ‘label’
[17:03:52.933]   - Field: ‘local’
[17:03:52.933]   - Field: ‘owner’
[17:03:52.933]   - Field: ‘envir’
[17:03:52.933]   - Field: ‘workers’
[17:03:52.934]   - Field: ‘packages’
[17:03:52.934]   - Field: ‘gc’
[17:03:52.934]   - Field: ‘conditions’
[17:03:52.934]   - Field: ‘persistent’
[17:03:52.934]   - Field: ‘expr’
[17:03:52.934]   - Field: ‘uuid’
[17:03:52.934]   - Field: ‘seed’
[17:03:52.934]   - Field: ‘version’
[17:03:52.934]   - Field: ‘result’
[17:03:52.934]   - Field: ‘asynchronous’
[17:03:52.934]   - Field: ‘calls’
[17:03:52.934]   - Field: ‘globals’
[17:03:52.935]   - Field: ‘stdout’
[17:03:52.935]   - Field: ‘earlySignal’
[17:03:52.935]   - Field: ‘lazy’
[17:03:52.935]   - Field: ‘state’
[17:03:52.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:52.935] - Launch lazy future ...
[17:03:52.935] Packages needed by the future expression (n = 0): <none>
[17:03:52.935] Packages needed by future strategies (n = 0): <none>
[17:03:52.936] {
[17:03:52.936]     {
[17:03:52.936]         {
[17:03:52.936]             ...future.startTime <- base::Sys.time()
[17:03:52.936]             {
[17:03:52.936]                 {
[17:03:52.936]                   {
[17:03:52.936]                     {
[17:03:52.936]                       base::local({
[17:03:52.936]                         has_future <- base::requireNamespace("future", 
[17:03:52.936]                           quietly = TRUE)
[17:03:52.936]                         if (has_future) {
[17:03:52.936]                           ns <- base::getNamespace("future")
[17:03:52.936]                           version <- ns[[".package"]][["version"]]
[17:03:52.936]                           if (is.null(version)) 
[17:03:52.936]                             version <- utils::packageVersion("future")
[17:03:52.936]                         }
[17:03:52.936]                         else {
[17:03:52.936]                           version <- NULL
[17:03:52.936]                         }
[17:03:52.936]                         if (!has_future || version < "1.8.0") {
[17:03:52.936]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:52.936]                             "", base::R.version$version.string), 
[17:03:52.936]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:52.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:52.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:52.936]                               "release", "version")], collapse = " "), 
[17:03:52.936]                             hostname = base::Sys.info()[["nodename"]])
[17:03:52.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:52.936]                             info)
[17:03:52.936]                           info <- base::paste(info, collapse = "; ")
[17:03:52.936]                           if (!has_future) {
[17:03:52.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:52.936]                               info)
[17:03:52.936]                           }
[17:03:52.936]                           else {
[17:03:52.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:52.936]                               info, version)
[17:03:52.936]                           }
[17:03:52.936]                           base::stop(msg)
[17:03:52.936]                         }
[17:03:52.936]                       })
[17:03:52.936]                     }
[17:03:52.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:52.936]                     base::options(mc.cores = 1L)
[17:03:52.936]                   }
[17:03:52.936]                   ...future.strategy.old <- future::plan("list")
[17:03:52.936]                   options(future.plan = NULL)
[17:03:52.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:52.936]                 }
[17:03:52.936]                 ...future.workdir <- getwd()
[17:03:52.936]             }
[17:03:52.936]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:52.936]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:52.936]         }
[17:03:52.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:52.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:52.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:52.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:52.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:52.936]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:52.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:52.936]             base::names(...future.oldOptions))
[17:03:52.936]     }
[17:03:52.936]     if (FALSE) {
[17:03:52.936]     }
[17:03:52.936]     else {
[17:03:52.936]         if (TRUE) {
[17:03:52.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:52.936]                 open = "w")
[17:03:52.936]         }
[17:03:52.936]         else {
[17:03:52.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:52.936]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:52.936]         }
[17:03:52.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:52.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:52.936]             base::sink(type = "output", split = FALSE)
[17:03:52.936]             base::close(...future.stdout)
[17:03:52.936]         }, add = TRUE)
[17:03:52.936]     }
[17:03:52.936]     ...future.frame <- base::sys.nframe()
[17:03:52.936]     ...future.conditions <- base::list()
[17:03:52.936]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:52.936]     if (FALSE) {
[17:03:52.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:52.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:52.936]     }
[17:03:52.936]     ...future.result <- base::tryCatch({
[17:03:52.936]         base::withCallingHandlers({
[17:03:52.936]             ...future.value <- base::withVisible(base::local({
[17:03:52.936]                 ...future.makeSendCondition <- base::local({
[17:03:52.936]                   sendCondition <- NULL
[17:03:52.936]                   function(frame = 1L) {
[17:03:52.936]                     if (is.function(sendCondition)) 
[17:03:52.936]                       return(sendCondition)
[17:03:52.936]                     ns <- getNamespace("parallel")
[17:03:52.936]                     if (exists("sendData", mode = "function", 
[17:03:52.936]                       envir = ns)) {
[17:03:52.936]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:52.936]                         envir = ns)
[17:03:52.936]                       envir <- sys.frame(frame)
[17:03:52.936]                       master <- NULL
[17:03:52.936]                       while (!identical(envir, .GlobalEnv) && 
[17:03:52.936]                         !identical(envir, emptyenv())) {
[17:03:52.936]                         if (exists("master", mode = "list", envir = envir, 
[17:03:52.936]                           inherits = FALSE)) {
[17:03:52.936]                           master <- get("master", mode = "list", 
[17:03:52.936]                             envir = envir, inherits = FALSE)
[17:03:52.936]                           if (inherits(master, c("SOCKnode", 
[17:03:52.936]                             "SOCK0node"))) {
[17:03:52.936]                             sendCondition <<- function(cond) {
[17:03:52.936]                               data <- list(type = "VALUE", value = cond, 
[17:03:52.936]                                 success = TRUE)
[17:03:52.936]                               parallel_sendData(master, data)
[17:03:52.936]                             }
[17:03:52.936]                             return(sendCondition)
[17:03:52.936]                           }
[17:03:52.936]                         }
[17:03:52.936]                         frame <- frame + 1L
[17:03:52.936]                         envir <- sys.frame(frame)
[17:03:52.936]                       }
[17:03:52.936]                     }
[17:03:52.936]                     sendCondition <<- function(cond) NULL
[17:03:52.936]                   }
[17:03:52.936]                 })
[17:03:52.936]                 withCallingHandlers({
[17:03:52.936]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:52.936]                 }, immediateCondition = function(cond) {
[17:03:52.936]                   sendCondition <- ...future.makeSendCondition()
[17:03:52.936]                   sendCondition(cond)
[17:03:52.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.936]                   {
[17:03:52.936]                     inherits <- base::inherits
[17:03:52.936]                     invokeRestart <- base::invokeRestart
[17:03:52.936]                     is.null <- base::is.null
[17:03:52.936]                     muffled <- FALSE
[17:03:52.936]                     if (inherits(cond, "message")) {
[17:03:52.936]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:52.936]                       if (muffled) 
[17:03:52.936]                         invokeRestart("muffleMessage")
[17:03:52.936]                     }
[17:03:52.936]                     else if (inherits(cond, "warning")) {
[17:03:52.936]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:52.936]                       if (muffled) 
[17:03:52.936]                         invokeRestart("muffleWarning")
[17:03:52.936]                     }
[17:03:52.936]                     else if (inherits(cond, "condition")) {
[17:03:52.936]                       if (!is.null(pattern)) {
[17:03:52.936]                         computeRestarts <- base::computeRestarts
[17:03:52.936]                         grepl <- base::grepl
[17:03:52.936]                         restarts <- computeRestarts(cond)
[17:03:52.936]                         for (restart in restarts) {
[17:03:52.936]                           name <- restart$name
[17:03:52.936]                           if (is.null(name)) 
[17:03:52.936]                             next
[17:03:52.936]                           if (!grepl(pattern, name)) 
[17:03:52.936]                             next
[17:03:52.936]                           invokeRestart(restart)
[17:03:52.936]                           muffled <- TRUE
[17:03:52.936]                           break
[17:03:52.936]                         }
[17:03:52.936]                       }
[17:03:52.936]                     }
[17:03:52.936]                     invisible(muffled)
[17:03:52.936]                   }
[17:03:52.936]                   muffleCondition(cond)
[17:03:52.936]                 })
[17:03:52.936]             }))
[17:03:52.936]             future::FutureResult(value = ...future.value$value, 
[17:03:52.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.936]                   ...future.rng), globalenv = if (FALSE) 
[17:03:52.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:52.936]                     ...future.globalenv.names))
[17:03:52.936]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:52.936]         }, condition = base::local({
[17:03:52.936]             c <- base::c
[17:03:52.936]             inherits <- base::inherits
[17:03:52.936]             invokeRestart <- base::invokeRestart
[17:03:52.936]             length <- base::length
[17:03:52.936]             list <- base::list
[17:03:52.936]             seq.int <- base::seq.int
[17:03:52.936]             signalCondition <- base::signalCondition
[17:03:52.936]             sys.calls <- base::sys.calls
[17:03:52.936]             `[[` <- base::`[[`
[17:03:52.936]             `+` <- base::`+`
[17:03:52.936]             `<<-` <- base::`<<-`
[17:03:52.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:52.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:52.936]                   3L)]
[17:03:52.936]             }
[17:03:52.936]             function(cond) {
[17:03:52.936]                 is_error <- inherits(cond, "error")
[17:03:52.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:52.936]                   NULL)
[17:03:52.936]                 if (is_error) {
[17:03:52.936]                   sessionInformation <- function() {
[17:03:52.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:52.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:52.936]                       search = base::search(), system = base::Sys.info())
[17:03:52.936]                   }
[17:03:52.936]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:52.936]                     cond$call), session = sessionInformation(), 
[17:03:52.936]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:52.936]                   signalCondition(cond)
[17:03:52.936]                 }
[17:03:52.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:52.936]                 "immediateCondition"))) {
[17:03:52.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:52.936]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:52.936]                   if (TRUE && !signal) {
[17:03:52.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.936]                     {
[17:03:52.936]                       inherits <- base::inherits
[17:03:52.936]                       invokeRestart <- base::invokeRestart
[17:03:52.936]                       is.null <- base::is.null
[17:03:52.936]                       muffled <- FALSE
[17:03:52.936]                       if (inherits(cond, "message")) {
[17:03:52.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.936]                         if (muffled) 
[17:03:52.936]                           invokeRestart("muffleMessage")
[17:03:52.936]                       }
[17:03:52.936]                       else if (inherits(cond, "warning")) {
[17:03:52.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.936]                         if (muffled) 
[17:03:52.936]                           invokeRestart("muffleWarning")
[17:03:52.936]                       }
[17:03:52.936]                       else if (inherits(cond, "condition")) {
[17:03:52.936]                         if (!is.null(pattern)) {
[17:03:52.936]                           computeRestarts <- base::computeRestarts
[17:03:52.936]                           grepl <- base::grepl
[17:03:52.936]                           restarts <- computeRestarts(cond)
[17:03:52.936]                           for (restart in restarts) {
[17:03:52.936]                             name <- restart$name
[17:03:52.936]                             if (is.null(name)) 
[17:03:52.936]                               next
[17:03:52.936]                             if (!grepl(pattern, name)) 
[17:03:52.936]                               next
[17:03:52.936]                             invokeRestart(restart)
[17:03:52.936]                             muffled <- TRUE
[17:03:52.936]                             break
[17:03:52.936]                           }
[17:03:52.936]                         }
[17:03:52.936]                       }
[17:03:52.936]                       invisible(muffled)
[17:03:52.936]                     }
[17:03:52.936]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.936]                   }
[17:03:52.936]                 }
[17:03:52.936]                 else {
[17:03:52.936]                   if (TRUE) {
[17:03:52.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.936]                     {
[17:03:52.936]                       inherits <- base::inherits
[17:03:52.936]                       invokeRestart <- base::invokeRestart
[17:03:52.936]                       is.null <- base::is.null
[17:03:52.936]                       muffled <- FALSE
[17:03:52.936]                       if (inherits(cond, "message")) {
[17:03:52.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.936]                         if (muffled) 
[17:03:52.936]                           invokeRestart("muffleMessage")
[17:03:52.936]                       }
[17:03:52.936]                       else if (inherits(cond, "warning")) {
[17:03:52.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.936]                         if (muffled) 
[17:03:52.936]                           invokeRestart("muffleWarning")
[17:03:52.936]                       }
[17:03:52.936]                       else if (inherits(cond, "condition")) {
[17:03:52.936]                         if (!is.null(pattern)) {
[17:03:52.936]                           computeRestarts <- base::computeRestarts
[17:03:52.936]                           grepl <- base::grepl
[17:03:52.936]                           restarts <- computeRestarts(cond)
[17:03:52.936]                           for (restart in restarts) {
[17:03:52.936]                             name <- restart$name
[17:03:52.936]                             if (is.null(name)) 
[17:03:52.936]                               next
[17:03:52.936]                             if (!grepl(pattern, name)) 
[17:03:52.936]                               next
[17:03:52.936]                             invokeRestart(restart)
[17:03:52.936]                             muffled <- TRUE
[17:03:52.936]                             break
[17:03:52.936]                           }
[17:03:52.936]                         }
[17:03:52.936]                       }
[17:03:52.936]                       invisible(muffled)
[17:03:52.936]                     }
[17:03:52.936]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.936]                   }
[17:03:52.936]                 }
[17:03:52.936]             }
[17:03:52.936]         }))
[17:03:52.936]     }, error = function(ex) {
[17:03:52.936]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:52.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.936]                 ...future.rng), started = ...future.startTime, 
[17:03:52.936]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:52.936]             version = "1.8"), class = "FutureResult")
[17:03:52.936]     }, finally = {
[17:03:52.936]         if (!identical(...future.workdir, getwd())) 
[17:03:52.936]             setwd(...future.workdir)
[17:03:52.936]         {
[17:03:52.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:52.936]                 ...future.oldOptions$nwarnings <- NULL
[17:03:52.936]             }
[17:03:52.936]             base::options(...future.oldOptions)
[17:03:52.936]             if (.Platform$OS.type == "windows") {
[17:03:52.936]                 old_names <- names(...future.oldEnvVars)
[17:03:52.936]                 envs <- base::Sys.getenv()
[17:03:52.936]                 names <- names(envs)
[17:03:52.936]                 common <- intersect(names, old_names)
[17:03:52.936]                 added <- setdiff(names, old_names)
[17:03:52.936]                 removed <- setdiff(old_names, names)
[17:03:52.936]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:52.936]                   envs[common]]
[17:03:52.936]                 NAMES <- toupper(changed)
[17:03:52.936]                 args <- list()
[17:03:52.936]                 for (kk in seq_along(NAMES)) {
[17:03:52.936]                   name <- changed[[kk]]
[17:03:52.936]                   NAME <- NAMES[[kk]]
[17:03:52.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.936]                     next
[17:03:52.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.936]                 }
[17:03:52.936]                 NAMES <- toupper(added)
[17:03:52.936]                 for (kk in seq_along(NAMES)) {
[17:03:52.936]                   name <- added[[kk]]
[17:03:52.936]                   NAME <- NAMES[[kk]]
[17:03:52.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.936]                     next
[17:03:52.936]                   args[[name]] <- ""
[17:03:52.936]                 }
[17:03:52.936]                 NAMES <- toupper(removed)
[17:03:52.936]                 for (kk in seq_along(NAMES)) {
[17:03:52.936]                   name <- removed[[kk]]
[17:03:52.936]                   NAME <- NAMES[[kk]]
[17:03:52.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.936]                     next
[17:03:52.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.936]                 }
[17:03:52.936]                 if (length(args) > 0) 
[17:03:52.936]                   base::do.call(base::Sys.setenv, args = args)
[17:03:52.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:52.936]             }
[17:03:52.936]             else {
[17:03:52.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:52.936]             }
[17:03:52.936]             {
[17:03:52.936]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:52.936]                   0L) {
[17:03:52.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:52.936]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:52.936]                   base::options(opts)
[17:03:52.936]                 }
[17:03:52.936]                 {
[17:03:52.936]                   {
[17:03:52.936]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:52.936]                     NULL
[17:03:52.936]                   }
[17:03:52.936]                   options(future.plan = NULL)
[17:03:52.936]                   if (is.na(NA_character_)) 
[17:03:52.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:52.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:52.936]                     .init = FALSE)
[17:03:52.936]                 }
[17:03:52.936]             }
[17:03:52.936]         }
[17:03:52.936]     })
[17:03:52.936]     if (TRUE) {
[17:03:52.936]         base::sink(type = "output", split = FALSE)
[17:03:52.936]         if (TRUE) {
[17:03:52.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:52.936]         }
[17:03:52.936]         else {
[17:03:52.936]             ...future.result["stdout"] <- base::list(NULL)
[17:03:52.936]         }
[17:03:52.936]         base::close(...future.stdout)
[17:03:52.936]         ...future.stdout <- NULL
[17:03:52.936]     }
[17:03:52.936]     ...future.result$conditions <- ...future.conditions
[17:03:52.936]     ...future.result$finished <- base::Sys.time()
[17:03:52.936]     ...future.result
[17:03:52.936] }
[17:03:52.939] MultisessionFuture started
[17:03:52.939] - Launch lazy future ... done
[17:03:52.939] run() for ‘MultisessionFuture’ ... done
[17:03:52.941] receiveMessageFromWorker() for ClusterFuture ...
[17:03:52.941] - Validating connection of MultisessionFuture
[17:03:52.942] - received message: FutureResult
[17:03:52.942] - Received FutureResult
[17:03:52.942] - Erased future from FutureRegistry
[17:03:52.942] result() for ClusterFuture ...
[17:03:52.942] - result already collected: FutureResult
[17:03:52.942] result() for ClusterFuture ... done
[17:03:52.942] signalConditions() ...
[17:03:52.942]  - include = ‘immediateCondition’
[17:03:52.942]  - exclude = 
[17:03:52.942]  - resignal = FALSE
[17:03:52.943]  - Number of conditions: 1
[17:03:52.943] signalConditions() ... done
[17:03:52.943] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:52.943] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[17:03:52.943] getGlobalsAndPackages() ...
[17:03:52.943] Searching for globals...
[17:03:52.944] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:52.944] Searching for globals ... DONE
[17:03:52.945] Resolving globals: FALSE
[17:03:52.945] 
[17:03:52.945] 
[17:03:52.945] getGlobalsAndPackages() ... DONE
[17:03:52.945] run() for ‘Future’ ...
[17:03:52.945] - state: ‘created’
[17:03:52.946] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:52.960] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:52.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:52.960]   - Field: ‘node’
[17:03:52.960]   - Field: ‘label’
[17:03:52.960]   - Field: ‘local’
[17:03:52.960]   - Field: ‘owner’
[17:03:52.960]   - Field: ‘envir’
[17:03:52.961]   - Field: ‘workers’
[17:03:52.961]   - Field: ‘packages’
[17:03:52.961]   - Field: ‘gc’
[17:03:52.961]   - Field: ‘conditions’
[17:03:52.961]   - Field: ‘persistent’
[17:03:52.961]   - Field: ‘expr’
[17:03:52.961]   - Field: ‘uuid’
[17:03:52.961]   - Field: ‘seed’
[17:03:52.961]   - Field: ‘version’
[17:03:52.961]   - Field: ‘result’
[17:03:52.961]   - Field: ‘asynchronous’
[17:03:52.962]   - Field: ‘calls’
[17:03:52.962]   - Field: ‘globals’
[17:03:52.962]   - Field: ‘stdout’
[17:03:52.962]   - Field: ‘earlySignal’
[17:03:52.962]   - Field: ‘lazy’
[17:03:52.962]   - Field: ‘state’
[17:03:52.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:52.962] - Launch lazy future ...
[17:03:52.962] Packages needed by the future expression (n = 0): <none>
[17:03:52.963] Packages needed by future strategies (n = 0): <none>
[17:03:52.963] {
[17:03:52.963]     {
[17:03:52.963]         {
[17:03:52.963]             ...future.startTime <- base::Sys.time()
[17:03:52.963]             {
[17:03:52.963]                 {
[17:03:52.963]                   {
[17:03:52.963]                     {
[17:03:52.963]                       base::local({
[17:03:52.963]                         has_future <- base::requireNamespace("future", 
[17:03:52.963]                           quietly = TRUE)
[17:03:52.963]                         if (has_future) {
[17:03:52.963]                           ns <- base::getNamespace("future")
[17:03:52.963]                           version <- ns[[".package"]][["version"]]
[17:03:52.963]                           if (is.null(version)) 
[17:03:52.963]                             version <- utils::packageVersion("future")
[17:03:52.963]                         }
[17:03:52.963]                         else {
[17:03:52.963]                           version <- NULL
[17:03:52.963]                         }
[17:03:52.963]                         if (!has_future || version < "1.8.0") {
[17:03:52.963]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:52.963]                             "", base::R.version$version.string), 
[17:03:52.963]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:52.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:52.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:52.963]                               "release", "version")], collapse = " "), 
[17:03:52.963]                             hostname = base::Sys.info()[["nodename"]])
[17:03:52.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:52.963]                             info)
[17:03:52.963]                           info <- base::paste(info, collapse = "; ")
[17:03:52.963]                           if (!has_future) {
[17:03:52.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:52.963]                               info)
[17:03:52.963]                           }
[17:03:52.963]                           else {
[17:03:52.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:52.963]                               info, version)
[17:03:52.963]                           }
[17:03:52.963]                           base::stop(msg)
[17:03:52.963]                         }
[17:03:52.963]                       })
[17:03:52.963]                     }
[17:03:52.963]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:52.963]                     base::options(mc.cores = 1L)
[17:03:52.963]                   }
[17:03:52.963]                   ...future.strategy.old <- future::plan("list")
[17:03:52.963]                   options(future.plan = NULL)
[17:03:52.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:52.963]                 }
[17:03:52.963]                 ...future.workdir <- getwd()
[17:03:52.963]             }
[17:03:52.963]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:52.963]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:52.963]         }
[17:03:52.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:52.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:52.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:52.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:52.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:52.963]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:52.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:52.963]             base::names(...future.oldOptions))
[17:03:52.963]     }
[17:03:52.963]     if (FALSE) {
[17:03:52.963]     }
[17:03:52.963]     else {
[17:03:52.963]         if (TRUE) {
[17:03:52.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:52.963]                 open = "w")
[17:03:52.963]         }
[17:03:52.963]         else {
[17:03:52.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:52.963]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:52.963]         }
[17:03:52.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:52.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:52.963]             base::sink(type = "output", split = FALSE)
[17:03:52.963]             base::close(...future.stdout)
[17:03:52.963]         }, add = TRUE)
[17:03:52.963]     }
[17:03:52.963]     ...future.frame <- base::sys.nframe()
[17:03:52.963]     ...future.conditions <- base::list()
[17:03:52.963]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:52.963]     if (FALSE) {
[17:03:52.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:52.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:52.963]     }
[17:03:52.963]     ...future.result <- base::tryCatch({
[17:03:52.963]         base::withCallingHandlers({
[17:03:52.963]             ...future.value <- base::withVisible(base::local({
[17:03:52.963]                 ...future.makeSendCondition <- base::local({
[17:03:52.963]                   sendCondition <- NULL
[17:03:52.963]                   function(frame = 1L) {
[17:03:52.963]                     if (is.function(sendCondition)) 
[17:03:52.963]                       return(sendCondition)
[17:03:52.963]                     ns <- getNamespace("parallel")
[17:03:52.963]                     if (exists("sendData", mode = "function", 
[17:03:52.963]                       envir = ns)) {
[17:03:52.963]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:52.963]                         envir = ns)
[17:03:52.963]                       envir <- sys.frame(frame)
[17:03:52.963]                       master <- NULL
[17:03:52.963]                       while (!identical(envir, .GlobalEnv) && 
[17:03:52.963]                         !identical(envir, emptyenv())) {
[17:03:52.963]                         if (exists("master", mode = "list", envir = envir, 
[17:03:52.963]                           inherits = FALSE)) {
[17:03:52.963]                           master <- get("master", mode = "list", 
[17:03:52.963]                             envir = envir, inherits = FALSE)
[17:03:52.963]                           if (inherits(master, c("SOCKnode", 
[17:03:52.963]                             "SOCK0node"))) {
[17:03:52.963]                             sendCondition <<- function(cond) {
[17:03:52.963]                               data <- list(type = "VALUE", value = cond, 
[17:03:52.963]                                 success = TRUE)
[17:03:52.963]                               parallel_sendData(master, data)
[17:03:52.963]                             }
[17:03:52.963]                             return(sendCondition)
[17:03:52.963]                           }
[17:03:52.963]                         }
[17:03:52.963]                         frame <- frame + 1L
[17:03:52.963]                         envir <- sys.frame(frame)
[17:03:52.963]                       }
[17:03:52.963]                     }
[17:03:52.963]                     sendCondition <<- function(cond) NULL
[17:03:52.963]                   }
[17:03:52.963]                 })
[17:03:52.963]                 withCallingHandlers({
[17:03:52.963]                   {
[17:03:52.963]                     Sys.sleep(0.5)
[17:03:52.963]                     list(a = 1, b = 42L)
[17:03:52.963]                   }
[17:03:52.963]                 }, immediateCondition = function(cond) {
[17:03:52.963]                   sendCondition <- ...future.makeSendCondition()
[17:03:52.963]                   sendCondition(cond)
[17:03:52.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.963]                   {
[17:03:52.963]                     inherits <- base::inherits
[17:03:52.963]                     invokeRestart <- base::invokeRestart
[17:03:52.963]                     is.null <- base::is.null
[17:03:52.963]                     muffled <- FALSE
[17:03:52.963]                     if (inherits(cond, "message")) {
[17:03:52.963]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:52.963]                       if (muffled) 
[17:03:52.963]                         invokeRestart("muffleMessage")
[17:03:52.963]                     }
[17:03:52.963]                     else if (inherits(cond, "warning")) {
[17:03:52.963]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:52.963]                       if (muffled) 
[17:03:52.963]                         invokeRestart("muffleWarning")
[17:03:52.963]                     }
[17:03:52.963]                     else if (inherits(cond, "condition")) {
[17:03:52.963]                       if (!is.null(pattern)) {
[17:03:52.963]                         computeRestarts <- base::computeRestarts
[17:03:52.963]                         grepl <- base::grepl
[17:03:52.963]                         restarts <- computeRestarts(cond)
[17:03:52.963]                         for (restart in restarts) {
[17:03:52.963]                           name <- restart$name
[17:03:52.963]                           if (is.null(name)) 
[17:03:52.963]                             next
[17:03:52.963]                           if (!grepl(pattern, name)) 
[17:03:52.963]                             next
[17:03:52.963]                           invokeRestart(restart)
[17:03:52.963]                           muffled <- TRUE
[17:03:52.963]                           break
[17:03:52.963]                         }
[17:03:52.963]                       }
[17:03:52.963]                     }
[17:03:52.963]                     invisible(muffled)
[17:03:52.963]                   }
[17:03:52.963]                   muffleCondition(cond)
[17:03:52.963]                 })
[17:03:52.963]             }))
[17:03:52.963]             future::FutureResult(value = ...future.value$value, 
[17:03:52.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.963]                   ...future.rng), globalenv = if (FALSE) 
[17:03:52.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:52.963]                     ...future.globalenv.names))
[17:03:52.963]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:52.963]         }, condition = base::local({
[17:03:52.963]             c <- base::c
[17:03:52.963]             inherits <- base::inherits
[17:03:52.963]             invokeRestart <- base::invokeRestart
[17:03:52.963]             length <- base::length
[17:03:52.963]             list <- base::list
[17:03:52.963]             seq.int <- base::seq.int
[17:03:52.963]             signalCondition <- base::signalCondition
[17:03:52.963]             sys.calls <- base::sys.calls
[17:03:52.963]             `[[` <- base::`[[`
[17:03:52.963]             `+` <- base::`+`
[17:03:52.963]             `<<-` <- base::`<<-`
[17:03:52.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:52.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:52.963]                   3L)]
[17:03:52.963]             }
[17:03:52.963]             function(cond) {
[17:03:52.963]                 is_error <- inherits(cond, "error")
[17:03:52.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:52.963]                   NULL)
[17:03:52.963]                 if (is_error) {
[17:03:52.963]                   sessionInformation <- function() {
[17:03:52.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:52.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:52.963]                       search = base::search(), system = base::Sys.info())
[17:03:52.963]                   }
[17:03:52.963]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:52.963]                     cond$call), session = sessionInformation(), 
[17:03:52.963]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:52.963]                   signalCondition(cond)
[17:03:52.963]                 }
[17:03:52.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:52.963]                 "immediateCondition"))) {
[17:03:52.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:52.963]                   ...future.conditions[[length(...future.conditions) + 
[17:03:52.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:52.963]                   if (TRUE && !signal) {
[17:03:52.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.963]                     {
[17:03:52.963]                       inherits <- base::inherits
[17:03:52.963]                       invokeRestart <- base::invokeRestart
[17:03:52.963]                       is.null <- base::is.null
[17:03:52.963]                       muffled <- FALSE
[17:03:52.963]                       if (inherits(cond, "message")) {
[17:03:52.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.963]                         if (muffled) 
[17:03:52.963]                           invokeRestart("muffleMessage")
[17:03:52.963]                       }
[17:03:52.963]                       else if (inherits(cond, "warning")) {
[17:03:52.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.963]                         if (muffled) 
[17:03:52.963]                           invokeRestart("muffleWarning")
[17:03:52.963]                       }
[17:03:52.963]                       else if (inherits(cond, "condition")) {
[17:03:52.963]                         if (!is.null(pattern)) {
[17:03:52.963]                           computeRestarts <- base::computeRestarts
[17:03:52.963]                           grepl <- base::grepl
[17:03:52.963]                           restarts <- computeRestarts(cond)
[17:03:52.963]                           for (restart in restarts) {
[17:03:52.963]                             name <- restart$name
[17:03:52.963]                             if (is.null(name)) 
[17:03:52.963]                               next
[17:03:52.963]                             if (!grepl(pattern, name)) 
[17:03:52.963]                               next
[17:03:52.963]                             invokeRestart(restart)
[17:03:52.963]                             muffled <- TRUE
[17:03:52.963]                             break
[17:03:52.963]                           }
[17:03:52.963]                         }
[17:03:52.963]                       }
[17:03:52.963]                       invisible(muffled)
[17:03:52.963]                     }
[17:03:52.963]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.963]                   }
[17:03:52.963]                 }
[17:03:52.963]                 else {
[17:03:52.963]                   if (TRUE) {
[17:03:52.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:52.963]                     {
[17:03:52.963]                       inherits <- base::inherits
[17:03:52.963]                       invokeRestart <- base::invokeRestart
[17:03:52.963]                       is.null <- base::is.null
[17:03:52.963]                       muffled <- FALSE
[17:03:52.963]                       if (inherits(cond, "message")) {
[17:03:52.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:52.963]                         if (muffled) 
[17:03:52.963]                           invokeRestart("muffleMessage")
[17:03:52.963]                       }
[17:03:52.963]                       else if (inherits(cond, "warning")) {
[17:03:52.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:52.963]                         if (muffled) 
[17:03:52.963]                           invokeRestart("muffleWarning")
[17:03:52.963]                       }
[17:03:52.963]                       else if (inherits(cond, "condition")) {
[17:03:52.963]                         if (!is.null(pattern)) {
[17:03:52.963]                           computeRestarts <- base::computeRestarts
[17:03:52.963]                           grepl <- base::grepl
[17:03:52.963]                           restarts <- computeRestarts(cond)
[17:03:52.963]                           for (restart in restarts) {
[17:03:52.963]                             name <- restart$name
[17:03:52.963]                             if (is.null(name)) 
[17:03:52.963]                               next
[17:03:52.963]                             if (!grepl(pattern, name)) 
[17:03:52.963]                               next
[17:03:52.963]                             invokeRestart(restart)
[17:03:52.963]                             muffled <- TRUE
[17:03:52.963]                             break
[17:03:52.963]                           }
[17:03:52.963]                         }
[17:03:52.963]                       }
[17:03:52.963]                       invisible(muffled)
[17:03:52.963]                     }
[17:03:52.963]                     muffleCondition(cond, pattern = "^muffle")
[17:03:52.963]                   }
[17:03:52.963]                 }
[17:03:52.963]             }
[17:03:52.963]         }))
[17:03:52.963]     }, error = function(ex) {
[17:03:52.963]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:52.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:52.963]                 ...future.rng), started = ...future.startTime, 
[17:03:52.963]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:52.963]             version = "1.8"), class = "FutureResult")
[17:03:52.963]     }, finally = {
[17:03:52.963]         if (!identical(...future.workdir, getwd())) 
[17:03:52.963]             setwd(...future.workdir)
[17:03:52.963]         {
[17:03:52.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:52.963]                 ...future.oldOptions$nwarnings <- NULL
[17:03:52.963]             }
[17:03:52.963]             base::options(...future.oldOptions)
[17:03:52.963]             if (.Platform$OS.type == "windows") {
[17:03:52.963]                 old_names <- names(...future.oldEnvVars)
[17:03:52.963]                 envs <- base::Sys.getenv()
[17:03:52.963]                 names <- names(envs)
[17:03:52.963]                 common <- intersect(names, old_names)
[17:03:52.963]                 added <- setdiff(names, old_names)
[17:03:52.963]                 removed <- setdiff(old_names, names)
[17:03:52.963]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:52.963]                   envs[common]]
[17:03:52.963]                 NAMES <- toupper(changed)
[17:03:52.963]                 args <- list()
[17:03:52.963]                 for (kk in seq_along(NAMES)) {
[17:03:52.963]                   name <- changed[[kk]]
[17:03:52.963]                   NAME <- NAMES[[kk]]
[17:03:52.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.963]                     next
[17:03:52.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.963]                 }
[17:03:52.963]                 NAMES <- toupper(added)
[17:03:52.963]                 for (kk in seq_along(NAMES)) {
[17:03:52.963]                   name <- added[[kk]]
[17:03:52.963]                   NAME <- NAMES[[kk]]
[17:03:52.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.963]                     next
[17:03:52.963]                   args[[name]] <- ""
[17:03:52.963]                 }
[17:03:52.963]                 NAMES <- toupper(removed)
[17:03:52.963]                 for (kk in seq_along(NAMES)) {
[17:03:52.963]                   name <- removed[[kk]]
[17:03:52.963]                   NAME <- NAMES[[kk]]
[17:03:52.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:52.963]                     next
[17:03:52.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:52.963]                 }
[17:03:52.963]                 if (length(args) > 0) 
[17:03:52.963]                   base::do.call(base::Sys.setenv, args = args)
[17:03:52.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:52.963]             }
[17:03:52.963]             else {
[17:03:52.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:52.963]             }
[17:03:52.963]             {
[17:03:52.963]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:52.963]                   0L) {
[17:03:52.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:52.963]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:52.963]                   base::options(opts)
[17:03:52.963]                 }
[17:03:52.963]                 {
[17:03:52.963]                   {
[17:03:52.963]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:52.963]                     NULL
[17:03:52.963]                   }
[17:03:52.963]                   options(future.plan = NULL)
[17:03:52.963]                   if (is.na(NA_character_)) 
[17:03:52.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:52.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:52.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:52.963]                     .init = FALSE)
[17:03:52.963]                 }
[17:03:52.963]             }
[17:03:52.963]         }
[17:03:52.963]     })
[17:03:52.963]     if (TRUE) {
[17:03:52.963]         base::sink(type = "output", split = FALSE)
[17:03:52.963]         if (TRUE) {
[17:03:52.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:52.963]         }
[17:03:52.963]         else {
[17:03:52.963]             ...future.result["stdout"] <- base::list(NULL)
[17:03:52.963]         }
[17:03:52.963]         base::close(...future.stdout)
[17:03:52.963]         ...future.stdout <- NULL
[17:03:52.963]     }
[17:03:52.963]     ...future.result$conditions <- ...future.conditions
[17:03:52.963]     ...future.result$finished <- base::Sys.time()
[17:03:52.963]     ...future.result
[17:03:52.963] }
[17:03:52.966] MultisessionFuture started
[17:03:52.966] - Launch lazy future ... done
[17:03:52.966] run() for ‘MultisessionFuture’ ... done
[17:03:53.469] receiveMessageFromWorker() for ClusterFuture ...
[17:03:53.469] - Validating connection of MultisessionFuture
[17:03:53.469] - received message: FutureResult
[17:03:53.469] - Received FutureResult
[17:03:53.470] - Erased future from FutureRegistry
[17:03:53.470] result() for ClusterFuture ...
[17:03:53.470] - result already collected: FutureResult
[17:03:53.470] result() for ClusterFuture ... done
[17:03:53.470] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:53.470] resolve() on list ...
[17:03:53.470]  recursive: 1
[17:03:53.470]  length: 2
[17:03:53.470]  elements: ‘a’, ‘b’
[17:03:53.470]  length: 1 (resolved future 1)
[17:03:53.471]  length: 0 (resolved future 2)
[17:03:53.471] resolve() on list ... DONE
[17:03:53.471] A MultisessionFuture was resolved (and resolved itself)
[17:03:53.471] getGlobalsAndPackages() ...
[17:03:53.471] Searching for globals...
[17:03:53.472] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:53.472] Searching for globals ... DONE
[17:03:53.472] Resolving globals: FALSE
[17:03:53.473] 
[17:03:53.473] 
[17:03:53.473] getGlobalsAndPackages() ... DONE
[17:03:53.473] run() for ‘Future’ ...
[17:03:53.473] - state: ‘created’
[17:03:53.473] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:53.487] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:53.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:53.487]   - Field: ‘node’
[17:03:53.487]   - Field: ‘label’
[17:03:53.488]   - Field: ‘local’
[17:03:53.488]   - Field: ‘owner’
[17:03:53.488]   - Field: ‘envir’
[17:03:53.488]   - Field: ‘workers’
[17:03:53.488]   - Field: ‘packages’
[17:03:53.488]   - Field: ‘gc’
[17:03:53.488]   - Field: ‘conditions’
[17:03:53.488]   - Field: ‘persistent’
[17:03:53.488]   - Field: ‘expr’
[17:03:53.488]   - Field: ‘uuid’
[17:03:53.488]   - Field: ‘seed’
[17:03:53.489]   - Field: ‘version’
[17:03:53.489]   - Field: ‘result’
[17:03:53.489]   - Field: ‘asynchronous’
[17:03:53.489]   - Field: ‘calls’
[17:03:53.489]   - Field: ‘globals’
[17:03:53.489]   - Field: ‘stdout’
[17:03:53.489]   - Field: ‘earlySignal’
[17:03:53.489]   - Field: ‘lazy’
[17:03:53.489]   - Field: ‘state’
[17:03:53.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:53.489] - Launch lazy future ...
[17:03:53.490] Packages needed by the future expression (n = 0): <none>
[17:03:53.490] Packages needed by future strategies (n = 0): <none>
[17:03:53.490] {
[17:03:53.490]     {
[17:03:53.490]         {
[17:03:53.490]             ...future.startTime <- base::Sys.time()
[17:03:53.490]             {
[17:03:53.490]                 {
[17:03:53.490]                   {
[17:03:53.490]                     {
[17:03:53.490]                       base::local({
[17:03:53.490]                         has_future <- base::requireNamespace("future", 
[17:03:53.490]                           quietly = TRUE)
[17:03:53.490]                         if (has_future) {
[17:03:53.490]                           ns <- base::getNamespace("future")
[17:03:53.490]                           version <- ns[[".package"]][["version"]]
[17:03:53.490]                           if (is.null(version)) 
[17:03:53.490]                             version <- utils::packageVersion("future")
[17:03:53.490]                         }
[17:03:53.490]                         else {
[17:03:53.490]                           version <- NULL
[17:03:53.490]                         }
[17:03:53.490]                         if (!has_future || version < "1.8.0") {
[17:03:53.490]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:53.490]                             "", base::R.version$version.string), 
[17:03:53.490]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:53.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:53.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:53.490]                               "release", "version")], collapse = " "), 
[17:03:53.490]                             hostname = base::Sys.info()[["nodename"]])
[17:03:53.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:53.490]                             info)
[17:03:53.490]                           info <- base::paste(info, collapse = "; ")
[17:03:53.490]                           if (!has_future) {
[17:03:53.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:53.490]                               info)
[17:03:53.490]                           }
[17:03:53.490]                           else {
[17:03:53.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:53.490]                               info, version)
[17:03:53.490]                           }
[17:03:53.490]                           base::stop(msg)
[17:03:53.490]                         }
[17:03:53.490]                       })
[17:03:53.490]                     }
[17:03:53.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:53.490]                     base::options(mc.cores = 1L)
[17:03:53.490]                   }
[17:03:53.490]                   ...future.strategy.old <- future::plan("list")
[17:03:53.490]                   options(future.plan = NULL)
[17:03:53.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:53.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:53.490]                 }
[17:03:53.490]                 ...future.workdir <- getwd()
[17:03:53.490]             }
[17:03:53.490]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:53.490]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:53.490]         }
[17:03:53.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:53.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:53.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:53.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:53.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:53.490]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:53.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:53.490]             base::names(...future.oldOptions))
[17:03:53.490]     }
[17:03:53.490]     if (FALSE) {
[17:03:53.490]     }
[17:03:53.490]     else {
[17:03:53.490]         if (TRUE) {
[17:03:53.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:53.490]                 open = "w")
[17:03:53.490]         }
[17:03:53.490]         else {
[17:03:53.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:53.490]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:53.490]         }
[17:03:53.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:53.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:53.490]             base::sink(type = "output", split = FALSE)
[17:03:53.490]             base::close(...future.stdout)
[17:03:53.490]         }, add = TRUE)
[17:03:53.490]     }
[17:03:53.490]     ...future.frame <- base::sys.nframe()
[17:03:53.490]     ...future.conditions <- base::list()
[17:03:53.490]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:53.490]     if (FALSE) {
[17:03:53.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:53.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:53.490]     }
[17:03:53.490]     ...future.result <- base::tryCatch({
[17:03:53.490]         base::withCallingHandlers({
[17:03:53.490]             ...future.value <- base::withVisible(base::local({
[17:03:53.490]                 ...future.makeSendCondition <- base::local({
[17:03:53.490]                   sendCondition <- NULL
[17:03:53.490]                   function(frame = 1L) {
[17:03:53.490]                     if (is.function(sendCondition)) 
[17:03:53.490]                       return(sendCondition)
[17:03:53.490]                     ns <- getNamespace("parallel")
[17:03:53.490]                     if (exists("sendData", mode = "function", 
[17:03:53.490]                       envir = ns)) {
[17:03:53.490]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:53.490]                         envir = ns)
[17:03:53.490]                       envir <- sys.frame(frame)
[17:03:53.490]                       master <- NULL
[17:03:53.490]                       while (!identical(envir, .GlobalEnv) && 
[17:03:53.490]                         !identical(envir, emptyenv())) {
[17:03:53.490]                         if (exists("master", mode = "list", envir = envir, 
[17:03:53.490]                           inherits = FALSE)) {
[17:03:53.490]                           master <- get("master", mode = "list", 
[17:03:53.490]                             envir = envir, inherits = FALSE)
[17:03:53.490]                           if (inherits(master, c("SOCKnode", 
[17:03:53.490]                             "SOCK0node"))) {
[17:03:53.490]                             sendCondition <<- function(cond) {
[17:03:53.490]                               data <- list(type = "VALUE", value = cond, 
[17:03:53.490]                                 success = TRUE)
[17:03:53.490]                               parallel_sendData(master, data)
[17:03:53.490]                             }
[17:03:53.490]                             return(sendCondition)
[17:03:53.490]                           }
[17:03:53.490]                         }
[17:03:53.490]                         frame <- frame + 1L
[17:03:53.490]                         envir <- sys.frame(frame)
[17:03:53.490]                       }
[17:03:53.490]                     }
[17:03:53.490]                     sendCondition <<- function(cond) NULL
[17:03:53.490]                   }
[17:03:53.490]                 })
[17:03:53.490]                 withCallingHandlers({
[17:03:53.490]                   {
[17:03:53.490]                     Sys.sleep(0.5)
[17:03:53.490]                     list(a = 1, b = 42L)
[17:03:53.490]                   }
[17:03:53.490]                 }, immediateCondition = function(cond) {
[17:03:53.490]                   sendCondition <- ...future.makeSendCondition()
[17:03:53.490]                   sendCondition(cond)
[17:03:53.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:53.490]                   {
[17:03:53.490]                     inherits <- base::inherits
[17:03:53.490]                     invokeRestart <- base::invokeRestart
[17:03:53.490]                     is.null <- base::is.null
[17:03:53.490]                     muffled <- FALSE
[17:03:53.490]                     if (inherits(cond, "message")) {
[17:03:53.490]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:53.490]                       if (muffled) 
[17:03:53.490]                         invokeRestart("muffleMessage")
[17:03:53.490]                     }
[17:03:53.490]                     else if (inherits(cond, "warning")) {
[17:03:53.490]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:53.490]                       if (muffled) 
[17:03:53.490]                         invokeRestart("muffleWarning")
[17:03:53.490]                     }
[17:03:53.490]                     else if (inherits(cond, "condition")) {
[17:03:53.490]                       if (!is.null(pattern)) {
[17:03:53.490]                         computeRestarts <- base::computeRestarts
[17:03:53.490]                         grepl <- base::grepl
[17:03:53.490]                         restarts <- computeRestarts(cond)
[17:03:53.490]                         for (restart in restarts) {
[17:03:53.490]                           name <- restart$name
[17:03:53.490]                           if (is.null(name)) 
[17:03:53.490]                             next
[17:03:53.490]                           if (!grepl(pattern, name)) 
[17:03:53.490]                             next
[17:03:53.490]                           invokeRestart(restart)
[17:03:53.490]                           muffled <- TRUE
[17:03:53.490]                           break
[17:03:53.490]                         }
[17:03:53.490]                       }
[17:03:53.490]                     }
[17:03:53.490]                     invisible(muffled)
[17:03:53.490]                   }
[17:03:53.490]                   muffleCondition(cond)
[17:03:53.490]                 })
[17:03:53.490]             }))
[17:03:53.490]             future::FutureResult(value = ...future.value$value, 
[17:03:53.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:53.490]                   ...future.rng), globalenv = if (FALSE) 
[17:03:53.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:53.490]                     ...future.globalenv.names))
[17:03:53.490]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:53.490]         }, condition = base::local({
[17:03:53.490]             c <- base::c
[17:03:53.490]             inherits <- base::inherits
[17:03:53.490]             invokeRestart <- base::invokeRestart
[17:03:53.490]             length <- base::length
[17:03:53.490]             list <- base::list
[17:03:53.490]             seq.int <- base::seq.int
[17:03:53.490]             signalCondition <- base::signalCondition
[17:03:53.490]             sys.calls <- base::sys.calls
[17:03:53.490]             `[[` <- base::`[[`
[17:03:53.490]             `+` <- base::`+`
[17:03:53.490]             `<<-` <- base::`<<-`
[17:03:53.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:53.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:53.490]                   3L)]
[17:03:53.490]             }
[17:03:53.490]             function(cond) {
[17:03:53.490]                 is_error <- inherits(cond, "error")
[17:03:53.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:53.490]                   NULL)
[17:03:53.490]                 if (is_error) {
[17:03:53.490]                   sessionInformation <- function() {
[17:03:53.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:53.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:53.490]                       search = base::search(), system = base::Sys.info())
[17:03:53.490]                   }
[17:03:53.490]                   ...future.conditions[[length(...future.conditions) + 
[17:03:53.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:53.490]                     cond$call), session = sessionInformation(), 
[17:03:53.490]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:53.490]                   signalCondition(cond)
[17:03:53.490]                 }
[17:03:53.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:53.490]                 "immediateCondition"))) {
[17:03:53.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:53.490]                   ...future.conditions[[length(...future.conditions) + 
[17:03:53.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:53.490]                   if (TRUE && !signal) {
[17:03:53.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:53.490]                     {
[17:03:53.490]                       inherits <- base::inherits
[17:03:53.490]                       invokeRestart <- base::invokeRestart
[17:03:53.490]                       is.null <- base::is.null
[17:03:53.490]                       muffled <- FALSE
[17:03:53.490]                       if (inherits(cond, "message")) {
[17:03:53.490]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:53.490]                         if (muffled) 
[17:03:53.490]                           invokeRestart("muffleMessage")
[17:03:53.490]                       }
[17:03:53.490]                       else if (inherits(cond, "warning")) {
[17:03:53.490]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:53.490]                         if (muffled) 
[17:03:53.490]                           invokeRestart("muffleWarning")
[17:03:53.490]                       }
[17:03:53.490]                       else if (inherits(cond, "condition")) {
[17:03:53.490]                         if (!is.null(pattern)) {
[17:03:53.490]                           computeRestarts <- base::computeRestarts
[17:03:53.490]                           grepl <- base::grepl
[17:03:53.490]                           restarts <- computeRestarts(cond)
[17:03:53.490]                           for (restart in restarts) {
[17:03:53.490]                             name <- restart$name
[17:03:53.490]                             if (is.null(name)) 
[17:03:53.490]                               next
[17:03:53.490]                             if (!grepl(pattern, name)) 
[17:03:53.490]                               next
[17:03:53.490]                             invokeRestart(restart)
[17:03:53.490]                             muffled <- TRUE
[17:03:53.490]                             break
[17:03:53.490]                           }
[17:03:53.490]                         }
[17:03:53.490]                       }
[17:03:53.490]                       invisible(muffled)
[17:03:53.490]                     }
[17:03:53.490]                     muffleCondition(cond, pattern = "^muffle")
[17:03:53.490]                   }
[17:03:53.490]                 }
[17:03:53.490]                 else {
[17:03:53.490]                   if (TRUE) {
[17:03:53.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:53.490]                     {
[17:03:53.490]                       inherits <- base::inherits
[17:03:53.490]                       invokeRestart <- base::invokeRestart
[17:03:53.490]                       is.null <- base::is.null
[17:03:53.490]                       muffled <- FALSE
[17:03:53.490]                       if (inherits(cond, "message")) {
[17:03:53.490]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:53.490]                         if (muffled) 
[17:03:53.490]                           invokeRestart("muffleMessage")
[17:03:53.490]                       }
[17:03:53.490]                       else if (inherits(cond, "warning")) {
[17:03:53.490]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:53.490]                         if (muffled) 
[17:03:53.490]                           invokeRestart("muffleWarning")
[17:03:53.490]                       }
[17:03:53.490]                       else if (inherits(cond, "condition")) {
[17:03:53.490]                         if (!is.null(pattern)) {
[17:03:53.490]                           computeRestarts <- base::computeRestarts
[17:03:53.490]                           grepl <- base::grepl
[17:03:53.490]                           restarts <- computeRestarts(cond)
[17:03:53.490]                           for (restart in restarts) {
[17:03:53.490]                             name <- restart$name
[17:03:53.490]                             if (is.null(name)) 
[17:03:53.490]                               next
[17:03:53.490]                             if (!grepl(pattern, name)) 
[17:03:53.490]                               next
[17:03:53.490]                             invokeRestart(restart)
[17:03:53.490]                             muffled <- TRUE
[17:03:53.490]                             break
[17:03:53.490]                           }
[17:03:53.490]                         }
[17:03:53.490]                       }
[17:03:53.490]                       invisible(muffled)
[17:03:53.490]                     }
[17:03:53.490]                     muffleCondition(cond, pattern = "^muffle")
[17:03:53.490]                   }
[17:03:53.490]                 }
[17:03:53.490]             }
[17:03:53.490]         }))
[17:03:53.490]     }, error = function(ex) {
[17:03:53.490]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:53.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:53.490]                 ...future.rng), started = ...future.startTime, 
[17:03:53.490]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:53.490]             version = "1.8"), class = "FutureResult")
[17:03:53.490]     }, finally = {
[17:03:53.490]         if (!identical(...future.workdir, getwd())) 
[17:03:53.490]             setwd(...future.workdir)
[17:03:53.490]         {
[17:03:53.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:53.490]                 ...future.oldOptions$nwarnings <- NULL
[17:03:53.490]             }
[17:03:53.490]             base::options(...future.oldOptions)
[17:03:53.490]             if (.Platform$OS.type == "windows") {
[17:03:53.490]                 old_names <- names(...future.oldEnvVars)
[17:03:53.490]                 envs <- base::Sys.getenv()
[17:03:53.490]                 names <- names(envs)
[17:03:53.490]                 common <- intersect(names, old_names)
[17:03:53.490]                 added <- setdiff(names, old_names)
[17:03:53.490]                 removed <- setdiff(old_names, names)
[17:03:53.490]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:53.490]                   envs[common]]
[17:03:53.490]                 NAMES <- toupper(changed)
[17:03:53.490]                 args <- list()
[17:03:53.490]                 for (kk in seq_along(NAMES)) {
[17:03:53.490]                   name <- changed[[kk]]
[17:03:53.490]                   NAME <- NAMES[[kk]]
[17:03:53.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:53.490]                     next
[17:03:53.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:53.490]                 }
[17:03:53.490]                 NAMES <- toupper(added)
[17:03:53.490]                 for (kk in seq_along(NAMES)) {
[17:03:53.490]                   name <- added[[kk]]
[17:03:53.490]                   NAME <- NAMES[[kk]]
[17:03:53.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:53.490]                     next
[17:03:53.490]                   args[[name]] <- ""
[17:03:53.490]                 }
[17:03:53.490]                 NAMES <- toupper(removed)
[17:03:53.490]                 for (kk in seq_along(NAMES)) {
[17:03:53.490]                   name <- removed[[kk]]
[17:03:53.490]                   NAME <- NAMES[[kk]]
[17:03:53.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:53.490]                     next
[17:03:53.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:53.490]                 }
[17:03:53.490]                 if (length(args) > 0) 
[17:03:53.490]                   base::do.call(base::Sys.setenv, args = args)
[17:03:53.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:53.490]             }
[17:03:53.490]             else {
[17:03:53.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:53.490]             }
[17:03:53.490]             {
[17:03:53.490]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:53.490]                   0L) {
[17:03:53.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:53.490]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:53.490]                   base::options(opts)
[17:03:53.490]                 }
[17:03:53.490]                 {
[17:03:53.490]                   {
[17:03:53.490]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:53.490]                     NULL
[17:03:53.490]                   }
[17:03:53.490]                   options(future.plan = NULL)
[17:03:53.490]                   if (is.na(NA_character_)) 
[17:03:53.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:53.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:53.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:53.490]                     .init = FALSE)
[17:03:53.490]                 }
[17:03:53.490]             }
[17:03:53.490]         }
[17:03:53.490]     })
[17:03:53.490]     if (TRUE) {
[17:03:53.490]         base::sink(type = "output", split = FALSE)
[17:03:53.490]         if (TRUE) {
[17:03:53.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:53.490]         }
[17:03:53.490]         else {
[17:03:53.490]             ...future.result["stdout"] <- base::list(NULL)
[17:03:53.490]         }
[17:03:53.490]         base::close(...future.stdout)
[17:03:53.490]         ...future.stdout <- NULL
[17:03:53.490]     }
[17:03:53.490]     ...future.result$conditions <- ...future.conditions
[17:03:53.490]     ...future.result$finished <- base::Sys.time()
[17:03:53.490]     ...future.result
[17:03:53.490] }
[17:03:53.493] MultisessionFuture started
[17:03:53.494] - Launch lazy future ... done
[17:03:53.494] run() for ‘MultisessionFuture’ ... done
[17:03:53.996] receiveMessageFromWorker() for ClusterFuture ...
[17:03:53.996] - Validating connection of MultisessionFuture
[17:03:53.997] - received message: FutureResult
[17:03:53.997] - Received FutureResult
[17:03:53.997] - Erased future from FutureRegistry
[17:03:53.997] result() for ClusterFuture ...
[17:03:53.997] - result already collected: FutureResult
[17:03:53.997] result() for ClusterFuture ... done
[17:03:53.997] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:53.997] resolve() on list ...
[17:03:53.997]  recursive: 1
[17:03:53.998]  length: 2
[17:03:53.998]  elements: ‘a’, ‘b’
[17:03:53.998]  length: 1 (resolved future 1)
[17:03:53.998]  length: 0 (resolved future 2)
[17:03:53.998] resolve() on list ... DONE
[17:03:53.998] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:03:53.998] getGlobalsAndPackages() ...
[17:03:53.998] Searching for globals...
[17:03:53.999] - globals found: [2] ‘list’, ‘stop’
[17:03:53.999] Searching for globals ... DONE
[17:03:53.999] Resolving globals: FALSE
[17:03:54.000] 
[17:03:54.000] 
[17:03:54.000] getGlobalsAndPackages() ... DONE
[17:03:54.000] run() for ‘Future’ ...
[17:03:54.000] - state: ‘created’
[17:03:54.000] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:54.014] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:54.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:54.014]   - Field: ‘node’
[17:03:54.015]   - Field: ‘label’
[17:03:54.015]   - Field: ‘local’
[17:03:54.015]   - Field: ‘owner’
[17:03:54.015]   - Field: ‘envir’
[17:03:54.015]   - Field: ‘workers’
[17:03:54.015]   - Field: ‘packages’
[17:03:54.015]   - Field: ‘gc’
[17:03:54.015]   - Field: ‘conditions’
[17:03:54.015]   - Field: ‘persistent’
[17:03:54.015]   - Field: ‘expr’
[17:03:54.015]   - Field: ‘uuid’
[17:03:54.016]   - Field: ‘seed’
[17:03:54.016]   - Field: ‘version’
[17:03:54.016]   - Field: ‘result’
[17:03:54.016]   - Field: ‘asynchronous’
[17:03:54.016]   - Field: ‘calls’
[17:03:54.016]   - Field: ‘globals’
[17:03:54.016]   - Field: ‘stdout’
[17:03:54.016]   - Field: ‘earlySignal’
[17:03:54.016]   - Field: ‘lazy’
[17:03:54.016]   - Field: ‘state’
[17:03:54.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:54.017] - Launch lazy future ...
[17:03:54.017] Packages needed by the future expression (n = 0): <none>
[17:03:54.017] Packages needed by future strategies (n = 0): <none>
[17:03:54.017] {
[17:03:54.017]     {
[17:03:54.017]         {
[17:03:54.017]             ...future.startTime <- base::Sys.time()
[17:03:54.017]             {
[17:03:54.017]                 {
[17:03:54.017]                   {
[17:03:54.017]                     {
[17:03:54.017]                       base::local({
[17:03:54.017]                         has_future <- base::requireNamespace("future", 
[17:03:54.017]                           quietly = TRUE)
[17:03:54.017]                         if (has_future) {
[17:03:54.017]                           ns <- base::getNamespace("future")
[17:03:54.017]                           version <- ns[[".package"]][["version"]]
[17:03:54.017]                           if (is.null(version)) 
[17:03:54.017]                             version <- utils::packageVersion("future")
[17:03:54.017]                         }
[17:03:54.017]                         else {
[17:03:54.017]                           version <- NULL
[17:03:54.017]                         }
[17:03:54.017]                         if (!has_future || version < "1.8.0") {
[17:03:54.017]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:54.017]                             "", base::R.version$version.string), 
[17:03:54.017]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:54.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:54.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:54.017]                               "release", "version")], collapse = " "), 
[17:03:54.017]                             hostname = base::Sys.info()[["nodename"]])
[17:03:54.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:54.017]                             info)
[17:03:54.017]                           info <- base::paste(info, collapse = "; ")
[17:03:54.017]                           if (!has_future) {
[17:03:54.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:54.017]                               info)
[17:03:54.017]                           }
[17:03:54.017]                           else {
[17:03:54.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:54.017]                               info, version)
[17:03:54.017]                           }
[17:03:54.017]                           base::stop(msg)
[17:03:54.017]                         }
[17:03:54.017]                       })
[17:03:54.017]                     }
[17:03:54.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:54.017]                     base::options(mc.cores = 1L)
[17:03:54.017]                   }
[17:03:54.017]                   ...future.strategy.old <- future::plan("list")
[17:03:54.017]                   options(future.plan = NULL)
[17:03:54.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:54.017]                 }
[17:03:54.017]                 ...future.workdir <- getwd()
[17:03:54.017]             }
[17:03:54.017]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:54.017]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:54.017]         }
[17:03:54.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:54.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:54.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:54.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:54.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:54.017]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:54.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:54.017]             base::names(...future.oldOptions))
[17:03:54.017]     }
[17:03:54.017]     if (FALSE) {
[17:03:54.017]     }
[17:03:54.017]     else {
[17:03:54.017]         if (TRUE) {
[17:03:54.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:54.017]                 open = "w")
[17:03:54.017]         }
[17:03:54.017]         else {
[17:03:54.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:54.017]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:54.017]         }
[17:03:54.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:54.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:54.017]             base::sink(type = "output", split = FALSE)
[17:03:54.017]             base::close(...future.stdout)
[17:03:54.017]         }, add = TRUE)
[17:03:54.017]     }
[17:03:54.017]     ...future.frame <- base::sys.nframe()
[17:03:54.017]     ...future.conditions <- base::list()
[17:03:54.017]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:54.017]     if (FALSE) {
[17:03:54.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:54.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:54.017]     }
[17:03:54.017]     ...future.result <- base::tryCatch({
[17:03:54.017]         base::withCallingHandlers({
[17:03:54.017]             ...future.value <- base::withVisible(base::local({
[17:03:54.017]                 ...future.makeSendCondition <- base::local({
[17:03:54.017]                   sendCondition <- NULL
[17:03:54.017]                   function(frame = 1L) {
[17:03:54.017]                     if (is.function(sendCondition)) 
[17:03:54.017]                       return(sendCondition)
[17:03:54.017]                     ns <- getNamespace("parallel")
[17:03:54.017]                     if (exists("sendData", mode = "function", 
[17:03:54.017]                       envir = ns)) {
[17:03:54.017]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:54.017]                         envir = ns)
[17:03:54.017]                       envir <- sys.frame(frame)
[17:03:54.017]                       master <- NULL
[17:03:54.017]                       while (!identical(envir, .GlobalEnv) && 
[17:03:54.017]                         !identical(envir, emptyenv())) {
[17:03:54.017]                         if (exists("master", mode = "list", envir = envir, 
[17:03:54.017]                           inherits = FALSE)) {
[17:03:54.017]                           master <- get("master", mode = "list", 
[17:03:54.017]                             envir = envir, inherits = FALSE)
[17:03:54.017]                           if (inherits(master, c("SOCKnode", 
[17:03:54.017]                             "SOCK0node"))) {
[17:03:54.017]                             sendCondition <<- function(cond) {
[17:03:54.017]                               data <- list(type = "VALUE", value = cond, 
[17:03:54.017]                                 success = TRUE)
[17:03:54.017]                               parallel_sendData(master, data)
[17:03:54.017]                             }
[17:03:54.017]                             return(sendCondition)
[17:03:54.017]                           }
[17:03:54.017]                         }
[17:03:54.017]                         frame <- frame + 1L
[17:03:54.017]                         envir <- sys.frame(frame)
[17:03:54.017]                       }
[17:03:54.017]                     }
[17:03:54.017]                     sendCondition <<- function(cond) NULL
[17:03:54.017]                   }
[17:03:54.017]                 })
[17:03:54.017]                 withCallingHandlers({
[17:03:54.017]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:54.017]                 }, immediateCondition = function(cond) {
[17:03:54.017]                   sendCondition <- ...future.makeSendCondition()
[17:03:54.017]                   sendCondition(cond)
[17:03:54.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.017]                   {
[17:03:54.017]                     inherits <- base::inherits
[17:03:54.017]                     invokeRestart <- base::invokeRestart
[17:03:54.017]                     is.null <- base::is.null
[17:03:54.017]                     muffled <- FALSE
[17:03:54.017]                     if (inherits(cond, "message")) {
[17:03:54.017]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:54.017]                       if (muffled) 
[17:03:54.017]                         invokeRestart("muffleMessage")
[17:03:54.017]                     }
[17:03:54.017]                     else if (inherits(cond, "warning")) {
[17:03:54.017]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:54.017]                       if (muffled) 
[17:03:54.017]                         invokeRestart("muffleWarning")
[17:03:54.017]                     }
[17:03:54.017]                     else if (inherits(cond, "condition")) {
[17:03:54.017]                       if (!is.null(pattern)) {
[17:03:54.017]                         computeRestarts <- base::computeRestarts
[17:03:54.017]                         grepl <- base::grepl
[17:03:54.017]                         restarts <- computeRestarts(cond)
[17:03:54.017]                         for (restart in restarts) {
[17:03:54.017]                           name <- restart$name
[17:03:54.017]                           if (is.null(name)) 
[17:03:54.017]                             next
[17:03:54.017]                           if (!grepl(pattern, name)) 
[17:03:54.017]                             next
[17:03:54.017]                           invokeRestart(restart)
[17:03:54.017]                           muffled <- TRUE
[17:03:54.017]                           break
[17:03:54.017]                         }
[17:03:54.017]                       }
[17:03:54.017]                     }
[17:03:54.017]                     invisible(muffled)
[17:03:54.017]                   }
[17:03:54.017]                   muffleCondition(cond)
[17:03:54.017]                 })
[17:03:54.017]             }))
[17:03:54.017]             future::FutureResult(value = ...future.value$value, 
[17:03:54.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.017]                   ...future.rng), globalenv = if (FALSE) 
[17:03:54.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:54.017]                     ...future.globalenv.names))
[17:03:54.017]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:54.017]         }, condition = base::local({
[17:03:54.017]             c <- base::c
[17:03:54.017]             inherits <- base::inherits
[17:03:54.017]             invokeRestart <- base::invokeRestart
[17:03:54.017]             length <- base::length
[17:03:54.017]             list <- base::list
[17:03:54.017]             seq.int <- base::seq.int
[17:03:54.017]             signalCondition <- base::signalCondition
[17:03:54.017]             sys.calls <- base::sys.calls
[17:03:54.017]             `[[` <- base::`[[`
[17:03:54.017]             `+` <- base::`+`
[17:03:54.017]             `<<-` <- base::`<<-`
[17:03:54.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:54.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:54.017]                   3L)]
[17:03:54.017]             }
[17:03:54.017]             function(cond) {
[17:03:54.017]                 is_error <- inherits(cond, "error")
[17:03:54.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:54.017]                   NULL)
[17:03:54.017]                 if (is_error) {
[17:03:54.017]                   sessionInformation <- function() {
[17:03:54.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:54.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:54.017]                       search = base::search(), system = base::Sys.info())
[17:03:54.017]                   }
[17:03:54.017]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:54.017]                     cond$call), session = sessionInformation(), 
[17:03:54.017]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:54.017]                   signalCondition(cond)
[17:03:54.017]                 }
[17:03:54.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:54.017]                 "immediateCondition"))) {
[17:03:54.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:54.017]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:54.017]                   if (TRUE && !signal) {
[17:03:54.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.017]                     {
[17:03:54.017]                       inherits <- base::inherits
[17:03:54.017]                       invokeRestart <- base::invokeRestart
[17:03:54.017]                       is.null <- base::is.null
[17:03:54.017]                       muffled <- FALSE
[17:03:54.017]                       if (inherits(cond, "message")) {
[17:03:54.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.017]                         if (muffled) 
[17:03:54.017]                           invokeRestart("muffleMessage")
[17:03:54.017]                       }
[17:03:54.017]                       else if (inherits(cond, "warning")) {
[17:03:54.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.017]                         if (muffled) 
[17:03:54.017]                           invokeRestart("muffleWarning")
[17:03:54.017]                       }
[17:03:54.017]                       else if (inherits(cond, "condition")) {
[17:03:54.017]                         if (!is.null(pattern)) {
[17:03:54.017]                           computeRestarts <- base::computeRestarts
[17:03:54.017]                           grepl <- base::grepl
[17:03:54.017]                           restarts <- computeRestarts(cond)
[17:03:54.017]                           for (restart in restarts) {
[17:03:54.017]                             name <- restart$name
[17:03:54.017]                             if (is.null(name)) 
[17:03:54.017]                               next
[17:03:54.017]                             if (!grepl(pattern, name)) 
[17:03:54.017]                               next
[17:03:54.017]                             invokeRestart(restart)
[17:03:54.017]                             muffled <- TRUE
[17:03:54.017]                             break
[17:03:54.017]                           }
[17:03:54.017]                         }
[17:03:54.017]                       }
[17:03:54.017]                       invisible(muffled)
[17:03:54.017]                     }
[17:03:54.017]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.017]                   }
[17:03:54.017]                 }
[17:03:54.017]                 else {
[17:03:54.017]                   if (TRUE) {
[17:03:54.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.017]                     {
[17:03:54.017]                       inherits <- base::inherits
[17:03:54.017]                       invokeRestart <- base::invokeRestart
[17:03:54.017]                       is.null <- base::is.null
[17:03:54.017]                       muffled <- FALSE
[17:03:54.017]                       if (inherits(cond, "message")) {
[17:03:54.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.017]                         if (muffled) 
[17:03:54.017]                           invokeRestart("muffleMessage")
[17:03:54.017]                       }
[17:03:54.017]                       else if (inherits(cond, "warning")) {
[17:03:54.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.017]                         if (muffled) 
[17:03:54.017]                           invokeRestart("muffleWarning")
[17:03:54.017]                       }
[17:03:54.017]                       else if (inherits(cond, "condition")) {
[17:03:54.017]                         if (!is.null(pattern)) {
[17:03:54.017]                           computeRestarts <- base::computeRestarts
[17:03:54.017]                           grepl <- base::grepl
[17:03:54.017]                           restarts <- computeRestarts(cond)
[17:03:54.017]                           for (restart in restarts) {
[17:03:54.017]                             name <- restart$name
[17:03:54.017]                             if (is.null(name)) 
[17:03:54.017]                               next
[17:03:54.017]                             if (!grepl(pattern, name)) 
[17:03:54.017]                               next
[17:03:54.017]                             invokeRestart(restart)
[17:03:54.017]                             muffled <- TRUE
[17:03:54.017]                             break
[17:03:54.017]                           }
[17:03:54.017]                         }
[17:03:54.017]                       }
[17:03:54.017]                       invisible(muffled)
[17:03:54.017]                     }
[17:03:54.017]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.017]                   }
[17:03:54.017]                 }
[17:03:54.017]             }
[17:03:54.017]         }))
[17:03:54.017]     }, error = function(ex) {
[17:03:54.017]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:54.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.017]                 ...future.rng), started = ...future.startTime, 
[17:03:54.017]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:54.017]             version = "1.8"), class = "FutureResult")
[17:03:54.017]     }, finally = {
[17:03:54.017]         if (!identical(...future.workdir, getwd())) 
[17:03:54.017]             setwd(...future.workdir)
[17:03:54.017]         {
[17:03:54.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:54.017]                 ...future.oldOptions$nwarnings <- NULL
[17:03:54.017]             }
[17:03:54.017]             base::options(...future.oldOptions)
[17:03:54.017]             if (.Platform$OS.type == "windows") {
[17:03:54.017]                 old_names <- names(...future.oldEnvVars)
[17:03:54.017]                 envs <- base::Sys.getenv()
[17:03:54.017]                 names <- names(envs)
[17:03:54.017]                 common <- intersect(names, old_names)
[17:03:54.017]                 added <- setdiff(names, old_names)
[17:03:54.017]                 removed <- setdiff(old_names, names)
[17:03:54.017]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:54.017]                   envs[common]]
[17:03:54.017]                 NAMES <- toupper(changed)
[17:03:54.017]                 args <- list()
[17:03:54.017]                 for (kk in seq_along(NAMES)) {
[17:03:54.017]                   name <- changed[[kk]]
[17:03:54.017]                   NAME <- NAMES[[kk]]
[17:03:54.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.017]                     next
[17:03:54.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.017]                 }
[17:03:54.017]                 NAMES <- toupper(added)
[17:03:54.017]                 for (kk in seq_along(NAMES)) {
[17:03:54.017]                   name <- added[[kk]]
[17:03:54.017]                   NAME <- NAMES[[kk]]
[17:03:54.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.017]                     next
[17:03:54.017]                   args[[name]] <- ""
[17:03:54.017]                 }
[17:03:54.017]                 NAMES <- toupper(removed)
[17:03:54.017]                 for (kk in seq_along(NAMES)) {
[17:03:54.017]                   name <- removed[[kk]]
[17:03:54.017]                   NAME <- NAMES[[kk]]
[17:03:54.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.017]                     next
[17:03:54.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.017]                 }
[17:03:54.017]                 if (length(args) > 0) 
[17:03:54.017]                   base::do.call(base::Sys.setenv, args = args)
[17:03:54.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:54.017]             }
[17:03:54.017]             else {
[17:03:54.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:54.017]             }
[17:03:54.017]             {
[17:03:54.017]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:54.017]                   0L) {
[17:03:54.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:54.017]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:54.017]                   base::options(opts)
[17:03:54.017]                 }
[17:03:54.017]                 {
[17:03:54.017]                   {
[17:03:54.017]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:54.017]                     NULL
[17:03:54.017]                   }
[17:03:54.017]                   options(future.plan = NULL)
[17:03:54.017]                   if (is.na(NA_character_)) 
[17:03:54.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:54.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:54.017]                     .init = FALSE)
[17:03:54.017]                 }
[17:03:54.017]             }
[17:03:54.017]         }
[17:03:54.017]     })
[17:03:54.017]     if (TRUE) {
[17:03:54.017]         base::sink(type = "output", split = FALSE)
[17:03:54.017]         if (TRUE) {
[17:03:54.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:54.017]         }
[17:03:54.017]         else {
[17:03:54.017]             ...future.result["stdout"] <- base::list(NULL)
[17:03:54.017]         }
[17:03:54.017]         base::close(...future.stdout)
[17:03:54.017]         ...future.stdout <- NULL
[17:03:54.017]     }
[17:03:54.017]     ...future.result$conditions <- ...future.conditions
[17:03:54.017]     ...future.result$finished <- base::Sys.time()
[17:03:54.017]     ...future.result
[17:03:54.017] }
[17:03:54.020] MultisessionFuture started
[17:03:54.021] - Launch lazy future ... done
[17:03:54.021] run() for ‘MultisessionFuture’ ... done
[17:03:54.022] receiveMessageFromWorker() for ClusterFuture ...
[17:03:54.023] - Validating connection of MultisessionFuture
[17:03:54.023] - received message: FutureResult
[17:03:54.023] - Received FutureResult
[17:03:54.023] - Erased future from FutureRegistry
[17:03:54.023] result() for ClusterFuture ...
[17:03:54.024] - result already collected: FutureResult
[17:03:54.024] result() for ClusterFuture ... done
[17:03:54.024] signalConditions() ...
[17:03:54.024]  - include = ‘immediateCondition’
[17:03:54.024]  - exclude = 
[17:03:54.024]  - resignal = FALSE
[17:03:54.024]  - Number of conditions: 1
[17:03:54.024] signalConditions() ... done
[17:03:54.024] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:54.024] A MultisessionFuture was resolved (and resolved itself)
[17:03:54.024] getGlobalsAndPackages() ...
[17:03:54.025] Searching for globals...
[17:03:54.025] - globals found: [2] ‘list’, ‘stop’
[17:03:54.025] Searching for globals ... DONE
[17:03:54.025] Resolving globals: FALSE
[17:03:54.026] 
[17:03:54.026] 
[17:03:54.026] getGlobalsAndPackages() ... DONE
[17:03:54.026] run() for ‘Future’ ...
[17:03:54.026] - state: ‘created’
[17:03:54.026] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:54.040] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:54.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:54.041]   - Field: ‘node’
[17:03:54.041]   - Field: ‘label’
[17:03:54.041]   - Field: ‘local’
[17:03:54.041]   - Field: ‘owner’
[17:03:54.041]   - Field: ‘envir’
[17:03:54.041]   - Field: ‘workers’
[17:03:54.041]   - Field: ‘packages’
[17:03:54.041]   - Field: ‘gc’
[17:03:54.041]   - Field: ‘conditions’
[17:03:54.041]   - Field: ‘persistent’
[17:03:54.042]   - Field: ‘expr’
[17:03:54.042]   - Field: ‘uuid’
[17:03:54.044]   - Field: ‘seed’
[17:03:54.044]   - Field: ‘version’
[17:03:54.044]   - Field: ‘result’
[17:03:54.045]   - Field: ‘asynchronous’
[17:03:54.045]   - Field: ‘calls’
[17:03:54.045]   - Field: ‘globals’
[17:03:54.045]   - Field: ‘stdout’
[17:03:54.045]   - Field: ‘earlySignal’
[17:03:54.045]   - Field: ‘lazy’
[17:03:54.045]   - Field: ‘state’
[17:03:54.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:54.045] - Launch lazy future ...
[17:03:54.046] Packages needed by the future expression (n = 0): <none>
[17:03:54.046] Packages needed by future strategies (n = 0): <none>
[17:03:54.046] {
[17:03:54.046]     {
[17:03:54.046]         {
[17:03:54.046]             ...future.startTime <- base::Sys.time()
[17:03:54.046]             {
[17:03:54.046]                 {
[17:03:54.046]                   {
[17:03:54.046]                     {
[17:03:54.046]                       base::local({
[17:03:54.046]                         has_future <- base::requireNamespace("future", 
[17:03:54.046]                           quietly = TRUE)
[17:03:54.046]                         if (has_future) {
[17:03:54.046]                           ns <- base::getNamespace("future")
[17:03:54.046]                           version <- ns[[".package"]][["version"]]
[17:03:54.046]                           if (is.null(version)) 
[17:03:54.046]                             version <- utils::packageVersion("future")
[17:03:54.046]                         }
[17:03:54.046]                         else {
[17:03:54.046]                           version <- NULL
[17:03:54.046]                         }
[17:03:54.046]                         if (!has_future || version < "1.8.0") {
[17:03:54.046]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:54.046]                             "", base::R.version$version.string), 
[17:03:54.046]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:54.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:54.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:54.046]                               "release", "version")], collapse = " "), 
[17:03:54.046]                             hostname = base::Sys.info()[["nodename"]])
[17:03:54.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:54.046]                             info)
[17:03:54.046]                           info <- base::paste(info, collapse = "; ")
[17:03:54.046]                           if (!has_future) {
[17:03:54.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:54.046]                               info)
[17:03:54.046]                           }
[17:03:54.046]                           else {
[17:03:54.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:54.046]                               info, version)
[17:03:54.046]                           }
[17:03:54.046]                           base::stop(msg)
[17:03:54.046]                         }
[17:03:54.046]                       })
[17:03:54.046]                     }
[17:03:54.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:54.046]                     base::options(mc.cores = 1L)
[17:03:54.046]                   }
[17:03:54.046]                   ...future.strategy.old <- future::plan("list")
[17:03:54.046]                   options(future.plan = NULL)
[17:03:54.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:54.046]                 }
[17:03:54.046]                 ...future.workdir <- getwd()
[17:03:54.046]             }
[17:03:54.046]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:54.046]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:54.046]         }
[17:03:54.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:54.046]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:54.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:54.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:54.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:54.046]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:54.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:54.046]             base::names(...future.oldOptions))
[17:03:54.046]     }
[17:03:54.046]     if (FALSE) {
[17:03:54.046]     }
[17:03:54.046]     else {
[17:03:54.046]         if (TRUE) {
[17:03:54.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:54.046]                 open = "w")
[17:03:54.046]         }
[17:03:54.046]         else {
[17:03:54.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:54.046]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:54.046]         }
[17:03:54.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:54.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:54.046]             base::sink(type = "output", split = FALSE)
[17:03:54.046]             base::close(...future.stdout)
[17:03:54.046]         }, add = TRUE)
[17:03:54.046]     }
[17:03:54.046]     ...future.frame <- base::sys.nframe()
[17:03:54.046]     ...future.conditions <- base::list()
[17:03:54.046]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:54.046]     if (FALSE) {
[17:03:54.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:54.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:54.046]     }
[17:03:54.046]     ...future.result <- base::tryCatch({
[17:03:54.046]         base::withCallingHandlers({
[17:03:54.046]             ...future.value <- base::withVisible(base::local({
[17:03:54.046]                 ...future.makeSendCondition <- base::local({
[17:03:54.046]                   sendCondition <- NULL
[17:03:54.046]                   function(frame = 1L) {
[17:03:54.046]                     if (is.function(sendCondition)) 
[17:03:54.046]                       return(sendCondition)
[17:03:54.046]                     ns <- getNamespace("parallel")
[17:03:54.046]                     if (exists("sendData", mode = "function", 
[17:03:54.046]                       envir = ns)) {
[17:03:54.046]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:54.046]                         envir = ns)
[17:03:54.046]                       envir <- sys.frame(frame)
[17:03:54.046]                       master <- NULL
[17:03:54.046]                       while (!identical(envir, .GlobalEnv) && 
[17:03:54.046]                         !identical(envir, emptyenv())) {
[17:03:54.046]                         if (exists("master", mode = "list", envir = envir, 
[17:03:54.046]                           inherits = FALSE)) {
[17:03:54.046]                           master <- get("master", mode = "list", 
[17:03:54.046]                             envir = envir, inherits = FALSE)
[17:03:54.046]                           if (inherits(master, c("SOCKnode", 
[17:03:54.046]                             "SOCK0node"))) {
[17:03:54.046]                             sendCondition <<- function(cond) {
[17:03:54.046]                               data <- list(type = "VALUE", value = cond, 
[17:03:54.046]                                 success = TRUE)
[17:03:54.046]                               parallel_sendData(master, data)
[17:03:54.046]                             }
[17:03:54.046]                             return(sendCondition)
[17:03:54.046]                           }
[17:03:54.046]                         }
[17:03:54.046]                         frame <- frame + 1L
[17:03:54.046]                         envir <- sys.frame(frame)
[17:03:54.046]                       }
[17:03:54.046]                     }
[17:03:54.046]                     sendCondition <<- function(cond) NULL
[17:03:54.046]                   }
[17:03:54.046]                 })
[17:03:54.046]                 withCallingHandlers({
[17:03:54.046]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:54.046]                 }, immediateCondition = function(cond) {
[17:03:54.046]                   sendCondition <- ...future.makeSendCondition()
[17:03:54.046]                   sendCondition(cond)
[17:03:54.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.046]                   {
[17:03:54.046]                     inherits <- base::inherits
[17:03:54.046]                     invokeRestart <- base::invokeRestart
[17:03:54.046]                     is.null <- base::is.null
[17:03:54.046]                     muffled <- FALSE
[17:03:54.046]                     if (inherits(cond, "message")) {
[17:03:54.046]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:54.046]                       if (muffled) 
[17:03:54.046]                         invokeRestart("muffleMessage")
[17:03:54.046]                     }
[17:03:54.046]                     else if (inherits(cond, "warning")) {
[17:03:54.046]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:54.046]                       if (muffled) 
[17:03:54.046]                         invokeRestart("muffleWarning")
[17:03:54.046]                     }
[17:03:54.046]                     else if (inherits(cond, "condition")) {
[17:03:54.046]                       if (!is.null(pattern)) {
[17:03:54.046]                         computeRestarts <- base::computeRestarts
[17:03:54.046]                         grepl <- base::grepl
[17:03:54.046]                         restarts <- computeRestarts(cond)
[17:03:54.046]                         for (restart in restarts) {
[17:03:54.046]                           name <- restart$name
[17:03:54.046]                           if (is.null(name)) 
[17:03:54.046]                             next
[17:03:54.046]                           if (!grepl(pattern, name)) 
[17:03:54.046]                             next
[17:03:54.046]                           invokeRestart(restart)
[17:03:54.046]                           muffled <- TRUE
[17:03:54.046]                           break
[17:03:54.046]                         }
[17:03:54.046]                       }
[17:03:54.046]                     }
[17:03:54.046]                     invisible(muffled)
[17:03:54.046]                   }
[17:03:54.046]                   muffleCondition(cond)
[17:03:54.046]                 })
[17:03:54.046]             }))
[17:03:54.046]             future::FutureResult(value = ...future.value$value, 
[17:03:54.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.046]                   ...future.rng), globalenv = if (FALSE) 
[17:03:54.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:54.046]                     ...future.globalenv.names))
[17:03:54.046]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:54.046]         }, condition = base::local({
[17:03:54.046]             c <- base::c
[17:03:54.046]             inherits <- base::inherits
[17:03:54.046]             invokeRestart <- base::invokeRestart
[17:03:54.046]             length <- base::length
[17:03:54.046]             list <- base::list
[17:03:54.046]             seq.int <- base::seq.int
[17:03:54.046]             signalCondition <- base::signalCondition
[17:03:54.046]             sys.calls <- base::sys.calls
[17:03:54.046]             `[[` <- base::`[[`
[17:03:54.046]             `+` <- base::`+`
[17:03:54.046]             `<<-` <- base::`<<-`
[17:03:54.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:54.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:54.046]                   3L)]
[17:03:54.046]             }
[17:03:54.046]             function(cond) {
[17:03:54.046]                 is_error <- inherits(cond, "error")
[17:03:54.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:54.046]                   NULL)
[17:03:54.046]                 if (is_error) {
[17:03:54.046]                   sessionInformation <- function() {
[17:03:54.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:54.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:54.046]                       search = base::search(), system = base::Sys.info())
[17:03:54.046]                   }
[17:03:54.046]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:54.046]                     cond$call), session = sessionInformation(), 
[17:03:54.046]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:54.046]                   signalCondition(cond)
[17:03:54.046]                 }
[17:03:54.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:54.046]                 "immediateCondition"))) {
[17:03:54.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:54.046]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:54.046]                   if (TRUE && !signal) {
[17:03:54.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.046]                     {
[17:03:54.046]                       inherits <- base::inherits
[17:03:54.046]                       invokeRestart <- base::invokeRestart
[17:03:54.046]                       is.null <- base::is.null
[17:03:54.046]                       muffled <- FALSE
[17:03:54.046]                       if (inherits(cond, "message")) {
[17:03:54.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.046]                         if (muffled) 
[17:03:54.046]                           invokeRestart("muffleMessage")
[17:03:54.046]                       }
[17:03:54.046]                       else if (inherits(cond, "warning")) {
[17:03:54.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.046]                         if (muffled) 
[17:03:54.046]                           invokeRestart("muffleWarning")
[17:03:54.046]                       }
[17:03:54.046]                       else if (inherits(cond, "condition")) {
[17:03:54.046]                         if (!is.null(pattern)) {
[17:03:54.046]                           computeRestarts <- base::computeRestarts
[17:03:54.046]                           grepl <- base::grepl
[17:03:54.046]                           restarts <- computeRestarts(cond)
[17:03:54.046]                           for (restart in restarts) {
[17:03:54.046]                             name <- restart$name
[17:03:54.046]                             if (is.null(name)) 
[17:03:54.046]                               next
[17:03:54.046]                             if (!grepl(pattern, name)) 
[17:03:54.046]                               next
[17:03:54.046]                             invokeRestart(restart)
[17:03:54.046]                             muffled <- TRUE
[17:03:54.046]                             break
[17:03:54.046]                           }
[17:03:54.046]                         }
[17:03:54.046]                       }
[17:03:54.046]                       invisible(muffled)
[17:03:54.046]                     }
[17:03:54.046]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.046]                   }
[17:03:54.046]                 }
[17:03:54.046]                 else {
[17:03:54.046]                   if (TRUE) {
[17:03:54.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.046]                     {
[17:03:54.046]                       inherits <- base::inherits
[17:03:54.046]                       invokeRestart <- base::invokeRestart
[17:03:54.046]                       is.null <- base::is.null
[17:03:54.046]                       muffled <- FALSE
[17:03:54.046]                       if (inherits(cond, "message")) {
[17:03:54.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.046]                         if (muffled) 
[17:03:54.046]                           invokeRestart("muffleMessage")
[17:03:54.046]                       }
[17:03:54.046]                       else if (inherits(cond, "warning")) {
[17:03:54.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.046]                         if (muffled) 
[17:03:54.046]                           invokeRestart("muffleWarning")
[17:03:54.046]                       }
[17:03:54.046]                       else if (inherits(cond, "condition")) {
[17:03:54.046]                         if (!is.null(pattern)) {
[17:03:54.046]                           computeRestarts <- base::computeRestarts
[17:03:54.046]                           grepl <- base::grepl
[17:03:54.046]                           restarts <- computeRestarts(cond)
[17:03:54.046]                           for (restart in restarts) {
[17:03:54.046]                             name <- restart$name
[17:03:54.046]                             if (is.null(name)) 
[17:03:54.046]                               next
[17:03:54.046]                             if (!grepl(pattern, name)) 
[17:03:54.046]                               next
[17:03:54.046]                             invokeRestart(restart)
[17:03:54.046]                             muffled <- TRUE
[17:03:54.046]                             break
[17:03:54.046]                           }
[17:03:54.046]                         }
[17:03:54.046]                       }
[17:03:54.046]                       invisible(muffled)
[17:03:54.046]                     }
[17:03:54.046]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.046]                   }
[17:03:54.046]                 }
[17:03:54.046]             }
[17:03:54.046]         }))
[17:03:54.046]     }, error = function(ex) {
[17:03:54.046]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:54.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.046]                 ...future.rng), started = ...future.startTime, 
[17:03:54.046]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:54.046]             version = "1.8"), class = "FutureResult")
[17:03:54.046]     }, finally = {
[17:03:54.046]         if (!identical(...future.workdir, getwd())) 
[17:03:54.046]             setwd(...future.workdir)
[17:03:54.046]         {
[17:03:54.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:54.046]                 ...future.oldOptions$nwarnings <- NULL
[17:03:54.046]             }
[17:03:54.046]             base::options(...future.oldOptions)
[17:03:54.046]             if (.Platform$OS.type == "windows") {
[17:03:54.046]                 old_names <- names(...future.oldEnvVars)
[17:03:54.046]                 envs <- base::Sys.getenv()
[17:03:54.046]                 names <- names(envs)
[17:03:54.046]                 common <- intersect(names, old_names)
[17:03:54.046]                 added <- setdiff(names, old_names)
[17:03:54.046]                 removed <- setdiff(old_names, names)
[17:03:54.046]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:54.046]                   envs[common]]
[17:03:54.046]                 NAMES <- toupper(changed)
[17:03:54.046]                 args <- list()
[17:03:54.046]                 for (kk in seq_along(NAMES)) {
[17:03:54.046]                   name <- changed[[kk]]
[17:03:54.046]                   NAME <- NAMES[[kk]]
[17:03:54.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.046]                     next
[17:03:54.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.046]                 }
[17:03:54.046]                 NAMES <- toupper(added)
[17:03:54.046]                 for (kk in seq_along(NAMES)) {
[17:03:54.046]                   name <- added[[kk]]
[17:03:54.046]                   NAME <- NAMES[[kk]]
[17:03:54.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.046]                     next
[17:03:54.046]                   args[[name]] <- ""
[17:03:54.046]                 }
[17:03:54.046]                 NAMES <- toupper(removed)
[17:03:54.046]                 for (kk in seq_along(NAMES)) {
[17:03:54.046]                   name <- removed[[kk]]
[17:03:54.046]                   NAME <- NAMES[[kk]]
[17:03:54.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.046]                     next
[17:03:54.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.046]                 }
[17:03:54.046]                 if (length(args) > 0) 
[17:03:54.046]                   base::do.call(base::Sys.setenv, args = args)
[17:03:54.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:54.046]             }
[17:03:54.046]             else {
[17:03:54.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:54.046]             }
[17:03:54.046]             {
[17:03:54.046]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:54.046]                   0L) {
[17:03:54.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:54.046]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:54.046]                   base::options(opts)
[17:03:54.046]                 }
[17:03:54.046]                 {
[17:03:54.046]                   {
[17:03:54.046]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:54.046]                     NULL
[17:03:54.046]                   }
[17:03:54.046]                   options(future.plan = NULL)
[17:03:54.046]                   if (is.na(NA_character_)) 
[17:03:54.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:54.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:54.046]                     .init = FALSE)
[17:03:54.046]                 }
[17:03:54.046]             }
[17:03:54.046]         }
[17:03:54.046]     })
[17:03:54.046]     if (TRUE) {
[17:03:54.046]         base::sink(type = "output", split = FALSE)
[17:03:54.046]         if (TRUE) {
[17:03:54.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:54.046]         }
[17:03:54.046]         else {
[17:03:54.046]             ...future.result["stdout"] <- base::list(NULL)
[17:03:54.046]         }
[17:03:54.046]         base::close(...future.stdout)
[17:03:54.046]         ...future.stdout <- NULL
[17:03:54.046]     }
[17:03:54.046]     ...future.result$conditions <- ...future.conditions
[17:03:54.046]     ...future.result$finished <- base::Sys.time()
[17:03:54.046]     ...future.result
[17:03:54.046] }
[17:03:54.049] MultisessionFuture started
[17:03:54.050] - Launch lazy future ... done
[17:03:54.050] run() for ‘MultisessionFuture’ ... done
[17:03:54.051] receiveMessageFromWorker() for ClusterFuture ...
[17:03:54.052] - Validating connection of MultisessionFuture
[17:03:54.052] - received message: FutureResult
[17:03:54.052] - Received FutureResult
[17:03:54.052] - Erased future from FutureRegistry
[17:03:54.052] result() for ClusterFuture ...
[17:03:54.053] - result already collected: FutureResult
[17:03:54.053] result() for ClusterFuture ... done
[17:03:54.053] signalConditions() ...
[17:03:54.053]  - include = ‘immediateCondition’
[17:03:54.053]  - exclude = 
[17:03:54.053]  - resignal = FALSE
[17:03:54.053]  - Number of conditions: 1
[17:03:54.053] signalConditions() ... done
[17:03:54.053] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:54.053] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[17:03:54.054] getGlobalsAndPackages() ...
[17:03:54.054] Searching for globals...
[17:03:54.055] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:54.055] Searching for globals ... DONE
[17:03:54.055] Resolving globals: FALSE
[17:03:54.055] 
[17:03:54.055] 
[17:03:54.056] getGlobalsAndPackages() ... DONE
[17:03:54.056] run() for ‘Future’ ...
[17:03:54.056] - state: ‘created’
[17:03:54.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:54.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:54.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:54.070]   - Field: ‘node’
[17:03:54.070]   - Field: ‘label’
[17:03:54.070]   - Field: ‘local’
[17:03:54.070]   - Field: ‘owner’
[17:03:54.070]   - Field: ‘envir’
[17:03:54.070]   - Field: ‘workers’
[17:03:54.070]   - Field: ‘packages’
[17:03:54.071]   - Field: ‘gc’
[17:03:54.071]   - Field: ‘conditions’
[17:03:54.071]   - Field: ‘persistent’
[17:03:54.071]   - Field: ‘expr’
[17:03:54.071]   - Field: ‘uuid’
[17:03:54.071]   - Field: ‘seed’
[17:03:54.071]   - Field: ‘version’
[17:03:54.071]   - Field: ‘result’
[17:03:54.071]   - Field: ‘asynchronous’
[17:03:54.071]   - Field: ‘calls’
[17:03:54.071]   - Field: ‘globals’
[17:03:54.072]   - Field: ‘stdout’
[17:03:54.072]   - Field: ‘earlySignal’
[17:03:54.072]   - Field: ‘lazy’
[17:03:54.072]   - Field: ‘state’
[17:03:54.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:54.072] - Launch lazy future ...
[17:03:54.072] Packages needed by the future expression (n = 0): <none>
[17:03:54.072] Packages needed by future strategies (n = 0): <none>
[17:03:54.073] {
[17:03:54.073]     {
[17:03:54.073]         {
[17:03:54.073]             ...future.startTime <- base::Sys.time()
[17:03:54.073]             {
[17:03:54.073]                 {
[17:03:54.073]                   {
[17:03:54.073]                     {
[17:03:54.073]                       base::local({
[17:03:54.073]                         has_future <- base::requireNamespace("future", 
[17:03:54.073]                           quietly = TRUE)
[17:03:54.073]                         if (has_future) {
[17:03:54.073]                           ns <- base::getNamespace("future")
[17:03:54.073]                           version <- ns[[".package"]][["version"]]
[17:03:54.073]                           if (is.null(version)) 
[17:03:54.073]                             version <- utils::packageVersion("future")
[17:03:54.073]                         }
[17:03:54.073]                         else {
[17:03:54.073]                           version <- NULL
[17:03:54.073]                         }
[17:03:54.073]                         if (!has_future || version < "1.8.0") {
[17:03:54.073]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:54.073]                             "", base::R.version$version.string), 
[17:03:54.073]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:54.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:54.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:54.073]                               "release", "version")], collapse = " "), 
[17:03:54.073]                             hostname = base::Sys.info()[["nodename"]])
[17:03:54.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:54.073]                             info)
[17:03:54.073]                           info <- base::paste(info, collapse = "; ")
[17:03:54.073]                           if (!has_future) {
[17:03:54.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:54.073]                               info)
[17:03:54.073]                           }
[17:03:54.073]                           else {
[17:03:54.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:54.073]                               info, version)
[17:03:54.073]                           }
[17:03:54.073]                           base::stop(msg)
[17:03:54.073]                         }
[17:03:54.073]                       })
[17:03:54.073]                     }
[17:03:54.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:54.073]                     base::options(mc.cores = 1L)
[17:03:54.073]                   }
[17:03:54.073]                   ...future.strategy.old <- future::plan("list")
[17:03:54.073]                   options(future.plan = NULL)
[17:03:54.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:54.073]                 }
[17:03:54.073]                 ...future.workdir <- getwd()
[17:03:54.073]             }
[17:03:54.073]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:54.073]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:54.073]         }
[17:03:54.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:54.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:54.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:54.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:54.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:54.073]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:54.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:54.073]             base::names(...future.oldOptions))
[17:03:54.073]     }
[17:03:54.073]     if (FALSE) {
[17:03:54.073]     }
[17:03:54.073]     else {
[17:03:54.073]         if (TRUE) {
[17:03:54.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:54.073]                 open = "w")
[17:03:54.073]         }
[17:03:54.073]         else {
[17:03:54.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:54.073]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:54.073]         }
[17:03:54.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:54.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:54.073]             base::sink(type = "output", split = FALSE)
[17:03:54.073]             base::close(...future.stdout)
[17:03:54.073]         }, add = TRUE)
[17:03:54.073]     }
[17:03:54.073]     ...future.frame <- base::sys.nframe()
[17:03:54.073]     ...future.conditions <- base::list()
[17:03:54.073]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:54.073]     if (FALSE) {
[17:03:54.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:54.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:54.073]     }
[17:03:54.073]     ...future.result <- base::tryCatch({
[17:03:54.073]         base::withCallingHandlers({
[17:03:54.073]             ...future.value <- base::withVisible(base::local({
[17:03:54.073]                 ...future.makeSendCondition <- base::local({
[17:03:54.073]                   sendCondition <- NULL
[17:03:54.073]                   function(frame = 1L) {
[17:03:54.073]                     if (is.function(sendCondition)) 
[17:03:54.073]                       return(sendCondition)
[17:03:54.073]                     ns <- getNamespace("parallel")
[17:03:54.073]                     if (exists("sendData", mode = "function", 
[17:03:54.073]                       envir = ns)) {
[17:03:54.073]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:54.073]                         envir = ns)
[17:03:54.073]                       envir <- sys.frame(frame)
[17:03:54.073]                       master <- NULL
[17:03:54.073]                       while (!identical(envir, .GlobalEnv) && 
[17:03:54.073]                         !identical(envir, emptyenv())) {
[17:03:54.073]                         if (exists("master", mode = "list", envir = envir, 
[17:03:54.073]                           inherits = FALSE)) {
[17:03:54.073]                           master <- get("master", mode = "list", 
[17:03:54.073]                             envir = envir, inherits = FALSE)
[17:03:54.073]                           if (inherits(master, c("SOCKnode", 
[17:03:54.073]                             "SOCK0node"))) {
[17:03:54.073]                             sendCondition <<- function(cond) {
[17:03:54.073]                               data <- list(type = "VALUE", value = cond, 
[17:03:54.073]                                 success = TRUE)
[17:03:54.073]                               parallel_sendData(master, data)
[17:03:54.073]                             }
[17:03:54.073]                             return(sendCondition)
[17:03:54.073]                           }
[17:03:54.073]                         }
[17:03:54.073]                         frame <- frame + 1L
[17:03:54.073]                         envir <- sys.frame(frame)
[17:03:54.073]                       }
[17:03:54.073]                     }
[17:03:54.073]                     sendCondition <<- function(cond) NULL
[17:03:54.073]                   }
[17:03:54.073]                 })
[17:03:54.073]                 withCallingHandlers({
[17:03:54.073]                   {
[17:03:54.073]                     Sys.sleep(0.5)
[17:03:54.073]                     list(a = 1, b = 42L)
[17:03:54.073]                   }
[17:03:54.073]                 }, immediateCondition = function(cond) {
[17:03:54.073]                   sendCondition <- ...future.makeSendCondition()
[17:03:54.073]                   sendCondition(cond)
[17:03:54.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.073]                   {
[17:03:54.073]                     inherits <- base::inherits
[17:03:54.073]                     invokeRestart <- base::invokeRestart
[17:03:54.073]                     is.null <- base::is.null
[17:03:54.073]                     muffled <- FALSE
[17:03:54.073]                     if (inherits(cond, "message")) {
[17:03:54.073]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:54.073]                       if (muffled) 
[17:03:54.073]                         invokeRestart("muffleMessage")
[17:03:54.073]                     }
[17:03:54.073]                     else if (inherits(cond, "warning")) {
[17:03:54.073]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:54.073]                       if (muffled) 
[17:03:54.073]                         invokeRestart("muffleWarning")
[17:03:54.073]                     }
[17:03:54.073]                     else if (inherits(cond, "condition")) {
[17:03:54.073]                       if (!is.null(pattern)) {
[17:03:54.073]                         computeRestarts <- base::computeRestarts
[17:03:54.073]                         grepl <- base::grepl
[17:03:54.073]                         restarts <- computeRestarts(cond)
[17:03:54.073]                         for (restart in restarts) {
[17:03:54.073]                           name <- restart$name
[17:03:54.073]                           if (is.null(name)) 
[17:03:54.073]                             next
[17:03:54.073]                           if (!grepl(pattern, name)) 
[17:03:54.073]                             next
[17:03:54.073]                           invokeRestart(restart)
[17:03:54.073]                           muffled <- TRUE
[17:03:54.073]                           break
[17:03:54.073]                         }
[17:03:54.073]                       }
[17:03:54.073]                     }
[17:03:54.073]                     invisible(muffled)
[17:03:54.073]                   }
[17:03:54.073]                   muffleCondition(cond)
[17:03:54.073]                 })
[17:03:54.073]             }))
[17:03:54.073]             future::FutureResult(value = ...future.value$value, 
[17:03:54.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.073]                   ...future.rng), globalenv = if (FALSE) 
[17:03:54.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:54.073]                     ...future.globalenv.names))
[17:03:54.073]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:54.073]         }, condition = base::local({
[17:03:54.073]             c <- base::c
[17:03:54.073]             inherits <- base::inherits
[17:03:54.073]             invokeRestart <- base::invokeRestart
[17:03:54.073]             length <- base::length
[17:03:54.073]             list <- base::list
[17:03:54.073]             seq.int <- base::seq.int
[17:03:54.073]             signalCondition <- base::signalCondition
[17:03:54.073]             sys.calls <- base::sys.calls
[17:03:54.073]             `[[` <- base::`[[`
[17:03:54.073]             `+` <- base::`+`
[17:03:54.073]             `<<-` <- base::`<<-`
[17:03:54.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:54.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:54.073]                   3L)]
[17:03:54.073]             }
[17:03:54.073]             function(cond) {
[17:03:54.073]                 is_error <- inherits(cond, "error")
[17:03:54.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:54.073]                   NULL)
[17:03:54.073]                 if (is_error) {
[17:03:54.073]                   sessionInformation <- function() {
[17:03:54.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:54.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:54.073]                       search = base::search(), system = base::Sys.info())
[17:03:54.073]                   }
[17:03:54.073]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:54.073]                     cond$call), session = sessionInformation(), 
[17:03:54.073]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:54.073]                   signalCondition(cond)
[17:03:54.073]                 }
[17:03:54.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:54.073]                 "immediateCondition"))) {
[17:03:54.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:54.073]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:54.073]                   if (TRUE && !signal) {
[17:03:54.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.073]                     {
[17:03:54.073]                       inherits <- base::inherits
[17:03:54.073]                       invokeRestart <- base::invokeRestart
[17:03:54.073]                       is.null <- base::is.null
[17:03:54.073]                       muffled <- FALSE
[17:03:54.073]                       if (inherits(cond, "message")) {
[17:03:54.073]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.073]                         if (muffled) 
[17:03:54.073]                           invokeRestart("muffleMessage")
[17:03:54.073]                       }
[17:03:54.073]                       else if (inherits(cond, "warning")) {
[17:03:54.073]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.073]                         if (muffled) 
[17:03:54.073]                           invokeRestart("muffleWarning")
[17:03:54.073]                       }
[17:03:54.073]                       else if (inherits(cond, "condition")) {
[17:03:54.073]                         if (!is.null(pattern)) {
[17:03:54.073]                           computeRestarts <- base::computeRestarts
[17:03:54.073]                           grepl <- base::grepl
[17:03:54.073]                           restarts <- computeRestarts(cond)
[17:03:54.073]                           for (restart in restarts) {
[17:03:54.073]                             name <- restart$name
[17:03:54.073]                             if (is.null(name)) 
[17:03:54.073]                               next
[17:03:54.073]                             if (!grepl(pattern, name)) 
[17:03:54.073]                               next
[17:03:54.073]                             invokeRestart(restart)
[17:03:54.073]                             muffled <- TRUE
[17:03:54.073]                             break
[17:03:54.073]                           }
[17:03:54.073]                         }
[17:03:54.073]                       }
[17:03:54.073]                       invisible(muffled)
[17:03:54.073]                     }
[17:03:54.073]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.073]                   }
[17:03:54.073]                 }
[17:03:54.073]                 else {
[17:03:54.073]                   if (TRUE) {
[17:03:54.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.073]                     {
[17:03:54.073]                       inherits <- base::inherits
[17:03:54.073]                       invokeRestart <- base::invokeRestart
[17:03:54.073]                       is.null <- base::is.null
[17:03:54.073]                       muffled <- FALSE
[17:03:54.073]                       if (inherits(cond, "message")) {
[17:03:54.073]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.073]                         if (muffled) 
[17:03:54.073]                           invokeRestart("muffleMessage")
[17:03:54.073]                       }
[17:03:54.073]                       else if (inherits(cond, "warning")) {
[17:03:54.073]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.073]                         if (muffled) 
[17:03:54.073]                           invokeRestart("muffleWarning")
[17:03:54.073]                       }
[17:03:54.073]                       else if (inherits(cond, "condition")) {
[17:03:54.073]                         if (!is.null(pattern)) {
[17:03:54.073]                           computeRestarts <- base::computeRestarts
[17:03:54.073]                           grepl <- base::grepl
[17:03:54.073]                           restarts <- computeRestarts(cond)
[17:03:54.073]                           for (restart in restarts) {
[17:03:54.073]                             name <- restart$name
[17:03:54.073]                             if (is.null(name)) 
[17:03:54.073]                               next
[17:03:54.073]                             if (!grepl(pattern, name)) 
[17:03:54.073]                               next
[17:03:54.073]                             invokeRestart(restart)
[17:03:54.073]                             muffled <- TRUE
[17:03:54.073]                             break
[17:03:54.073]                           }
[17:03:54.073]                         }
[17:03:54.073]                       }
[17:03:54.073]                       invisible(muffled)
[17:03:54.073]                     }
[17:03:54.073]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.073]                   }
[17:03:54.073]                 }
[17:03:54.073]             }
[17:03:54.073]         }))
[17:03:54.073]     }, error = function(ex) {
[17:03:54.073]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:54.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.073]                 ...future.rng), started = ...future.startTime, 
[17:03:54.073]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:54.073]             version = "1.8"), class = "FutureResult")
[17:03:54.073]     }, finally = {
[17:03:54.073]         if (!identical(...future.workdir, getwd())) 
[17:03:54.073]             setwd(...future.workdir)
[17:03:54.073]         {
[17:03:54.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:54.073]                 ...future.oldOptions$nwarnings <- NULL
[17:03:54.073]             }
[17:03:54.073]             base::options(...future.oldOptions)
[17:03:54.073]             if (.Platform$OS.type == "windows") {
[17:03:54.073]                 old_names <- names(...future.oldEnvVars)
[17:03:54.073]                 envs <- base::Sys.getenv()
[17:03:54.073]                 names <- names(envs)
[17:03:54.073]                 common <- intersect(names, old_names)
[17:03:54.073]                 added <- setdiff(names, old_names)
[17:03:54.073]                 removed <- setdiff(old_names, names)
[17:03:54.073]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:54.073]                   envs[common]]
[17:03:54.073]                 NAMES <- toupper(changed)
[17:03:54.073]                 args <- list()
[17:03:54.073]                 for (kk in seq_along(NAMES)) {
[17:03:54.073]                   name <- changed[[kk]]
[17:03:54.073]                   NAME <- NAMES[[kk]]
[17:03:54.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.073]                     next
[17:03:54.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.073]                 }
[17:03:54.073]                 NAMES <- toupper(added)
[17:03:54.073]                 for (kk in seq_along(NAMES)) {
[17:03:54.073]                   name <- added[[kk]]
[17:03:54.073]                   NAME <- NAMES[[kk]]
[17:03:54.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.073]                     next
[17:03:54.073]                   args[[name]] <- ""
[17:03:54.073]                 }
[17:03:54.073]                 NAMES <- toupper(removed)
[17:03:54.073]                 for (kk in seq_along(NAMES)) {
[17:03:54.073]                   name <- removed[[kk]]
[17:03:54.073]                   NAME <- NAMES[[kk]]
[17:03:54.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.073]                     next
[17:03:54.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.073]                 }
[17:03:54.073]                 if (length(args) > 0) 
[17:03:54.073]                   base::do.call(base::Sys.setenv, args = args)
[17:03:54.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:54.073]             }
[17:03:54.073]             else {
[17:03:54.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:54.073]             }
[17:03:54.073]             {
[17:03:54.073]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:54.073]                   0L) {
[17:03:54.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:54.073]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:54.073]                   base::options(opts)
[17:03:54.073]                 }
[17:03:54.073]                 {
[17:03:54.073]                   {
[17:03:54.073]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:54.073]                     NULL
[17:03:54.073]                   }
[17:03:54.073]                   options(future.plan = NULL)
[17:03:54.073]                   if (is.na(NA_character_)) 
[17:03:54.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:54.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:54.073]                     .init = FALSE)
[17:03:54.073]                 }
[17:03:54.073]             }
[17:03:54.073]         }
[17:03:54.073]     })
[17:03:54.073]     if (TRUE) {
[17:03:54.073]         base::sink(type = "output", split = FALSE)
[17:03:54.073]         if (TRUE) {
[17:03:54.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:54.073]         }
[17:03:54.073]         else {
[17:03:54.073]             ...future.result["stdout"] <- base::list(NULL)
[17:03:54.073]         }
[17:03:54.073]         base::close(...future.stdout)
[17:03:54.073]         ...future.stdout <- NULL
[17:03:54.073]     }
[17:03:54.073]     ...future.result$conditions <- ...future.conditions
[17:03:54.073]     ...future.result$finished <- base::Sys.time()
[17:03:54.073]     ...future.result
[17:03:54.073] }
[17:03:54.076] MultisessionFuture started
[17:03:54.076] - Launch lazy future ... done
[17:03:54.076] run() for ‘MultisessionFuture’ ... done
[17:03:54.578] receiveMessageFromWorker() for ClusterFuture ...
[17:03:54.579] - Validating connection of MultisessionFuture
[17:03:54.579] - received message: FutureResult
[17:03:54.579] - Received FutureResult
[17:03:54.579] - Erased future from FutureRegistry
[17:03:54.579] result() for ClusterFuture ...
[17:03:54.579] - result already collected: FutureResult
[17:03:54.579] result() for ClusterFuture ... done
[17:03:54.580] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:54.580] resolve() on list ...
[17:03:54.580]  recursive: Inf
[17:03:54.580]  length: 2
[17:03:54.580]  elements: ‘a’, ‘b’
[17:03:54.580]  length: 1 (resolved future 1)
[17:03:54.580]  length: 0 (resolved future 2)
[17:03:54.580] resolve() on list ... DONE
[17:03:54.580] A MultisessionFuture was resolved (and resolved itself)
[17:03:54.581] getGlobalsAndPackages() ...
[17:03:54.581] Searching for globals...
[17:03:54.582] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:03:54.582] Searching for globals ... DONE
[17:03:54.582] Resolving globals: FALSE
[17:03:54.582] 
[17:03:54.582] 
[17:03:54.582] getGlobalsAndPackages() ... DONE
[17:03:54.583] run() for ‘Future’ ...
[17:03:54.583] - state: ‘created’
[17:03:54.583] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:54.597] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:54.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:54.598]   - Field: ‘node’
[17:03:54.598]   - Field: ‘label’
[17:03:54.598]   - Field: ‘local’
[17:03:54.598]   - Field: ‘owner’
[17:03:54.598]   - Field: ‘envir’
[17:03:54.598]   - Field: ‘workers’
[17:03:54.598]   - Field: ‘packages’
[17:03:54.598]   - Field: ‘gc’
[17:03:54.598]   - Field: ‘conditions’
[17:03:54.599]   - Field: ‘persistent’
[17:03:54.599]   - Field: ‘expr’
[17:03:54.599]   - Field: ‘uuid’
[17:03:54.599]   - Field: ‘seed’
[17:03:54.599]   - Field: ‘version’
[17:03:54.599]   - Field: ‘result’
[17:03:54.599]   - Field: ‘asynchronous’
[17:03:54.599]   - Field: ‘calls’
[17:03:54.599]   - Field: ‘globals’
[17:03:54.599]   - Field: ‘stdout’
[17:03:54.599]   - Field: ‘earlySignal’
[17:03:54.600]   - Field: ‘lazy’
[17:03:54.600]   - Field: ‘state’
[17:03:54.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:54.600] - Launch lazy future ...
[17:03:54.600] Packages needed by the future expression (n = 0): <none>
[17:03:54.600] Packages needed by future strategies (n = 0): <none>
[17:03:54.601] {
[17:03:54.601]     {
[17:03:54.601]         {
[17:03:54.601]             ...future.startTime <- base::Sys.time()
[17:03:54.601]             {
[17:03:54.601]                 {
[17:03:54.601]                   {
[17:03:54.601]                     {
[17:03:54.601]                       base::local({
[17:03:54.601]                         has_future <- base::requireNamespace("future", 
[17:03:54.601]                           quietly = TRUE)
[17:03:54.601]                         if (has_future) {
[17:03:54.601]                           ns <- base::getNamespace("future")
[17:03:54.601]                           version <- ns[[".package"]][["version"]]
[17:03:54.601]                           if (is.null(version)) 
[17:03:54.601]                             version <- utils::packageVersion("future")
[17:03:54.601]                         }
[17:03:54.601]                         else {
[17:03:54.601]                           version <- NULL
[17:03:54.601]                         }
[17:03:54.601]                         if (!has_future || version < "1.8.0") {
[17:03:54.601]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:54.601]                             "", base::R.version$version.string), 
[17:03:54.601]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:54.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:54.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:54.601]                               "release", "version")], collapse = " "), 
[17:03:54.601]                             hostname = base::Sys.info()[["nodename"]])
[17:03:54.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:54.601]                             info)
[17:03:54.601]                           info <- base::paste(info, collapse = "; ")
[17:03:54.601]                           if (!has_future) {
[17:03:54.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:54.601]                               info)
[17:03:54.601]                           }
[17:03:54.601]                           else {
[17:03:54.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:54.601]                               info, version)
[17:03:54.601]                           }
[17:03:54.601]                           base::stop(msg)
[17:03:54.601]                         }
[17:03:54.601]                       })
[17:03:54.601]                     }
[17:03:54.601]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:54.601]                     base::options(mc.cores = 1L)
[17:03:54.601]                   }
[17:03:54.601]                   ...future.strategy.old <- future::plan("list")
[17:03:54.601]                   options(future.plan = NULL)
[17:03:54.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:54.601]                 }
[17:03:54.601]                 ...future.workdir <- getwd()
[17:03:54.601]             }
[17:03:54.601]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:54.601]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:54.601]         }
[17:03:54.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:54.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:54.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:54.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:54.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:54.601]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:54.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:54.601]             base::names(...future.oldOptions))
[17:03:54.601]     }
[17:03:54.601]     if (FALSE) {
[17:03:54.601]     }
[17:03:54.601]     else {
[17:03:54.601]         if (TRUE) {
[17:03:54.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:54.601]                 open = "w")
[17:03:54.601]         }
[17:03:54.601]         else {
[17:03:54.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:54.601]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:54.601]         }
[17:03:54.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:54.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:54.601]             base::sink(type = "output", split = FALSE)
[17:03:54.601]             base::close(...future.stdout)
[17:03:54.601]         }, add = TRUE)
[17:03:54.601]     }
[17:03:54.601]     ...future.frame <- base::sys.nframe()
[17:03:54.601]     ...future.conditions <- base::list()
[17:03:54.601]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:54.601]     if (FALSE) {
[17:03:54.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:54.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:54.601]     }
[17:03:54.601]     ...future.result <- base::tryCatch({
[17:03:54.601]         base::withCallingHandlers({
[17:03:54.601]             ...future.value <- base::withVisible(base::local({
[17:03:54.601]                 ...future.makeSendCondition <- base::local({
[17:03:54.601]                   sendCondition <- NULL
[17:03:54.601]                   function(frame = 1L) {
[17:03:54.601]                     if (is.function(sendCondition)) 
[17:03:54.601]                       return(sendCondition)
[17:03:54.601]                     ns <- getNamespace("parallel")
[17:03:54.601]                     if (exists("sendData", mode = "function", 
[17:03:54.601]                       envir = ns)) {
[17:03:54.601]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:54.601]                         envir = ns)
[17:03:54.601]                       envir <- sys.frame(frame)
[17:03:54.601]                       master <- NULL
[17:03:54.601]                       while (!identical(envir, .GlobalEnv) && 
[17:03:54.601]                         !identical(envir, emptyenv())) {
[17:03:54.601]                         if (exists("master", mode = "list", envir = envir, 
[17:03:54.601]                           inherits = FALSE)) {
[17:03:54.601]                           master <- get("master", mode = "list", 
[17:03:54.601]                             envir = envir, inherits = FALSE)
[17:03:54.601]                           if (inherits(master, c("SOCKnode", 
[17:03:54.601]                             "SOCK0node"))) {
[17:03:54.601]                             sendCondition <<- function(cond) {
[17:03:54.601]                               data <- list(type = "VALUE", value = cond, 
[17:03:54.601]                                 success = TRUE)
[17:03:54.601]                               parallel_sendData(master, data)
[17:03:54.601]                             }
[17:03:54.601]                             return(sendCondition)
[17:03:54.601]                           }
[17:03:54.601]                         }
[17:03:54.601]                         frame <- frame + 1L
[17:03:54.601]                         envir <- sys.frame(frame)
[17:03:54.601]                       }
[17:03:54.601]                     }
[17:03:54.601]                     sendCondition <<- function(cond) NULL
[17:03:54.601]                   }
[17:03:54.601]                 })
[17:03:54.601]                 withCallingHandlers({
[17:03:54.601]                   {
[17:03:54.601]                     Sys.sleep(0.5)
[17:03:54.601]                     list(a = 1, b = 42L)
[17:03:54.601]                   }
[17:03:54.601]                 }, immediateCondition = function(cond) {
[17:03:54.601]                   sendCondition <- ...future.makeSendCondition()
[17:03:54.601]                   sendCondition(cond)
[17:03:54.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.601]                   {
[17:03:54.601]                     inherits <- base::inherits
[17:03:54.601]                     invokeRestart <- base::invokeRestart
[17:03:54.601]                     is.null <- base::is.null
[17:03:54.601]                     muffled <- FALSE
[17:03:54.601]                     if (inherits(cond, "message")) {
[17:03:54.601]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:54.601]                       if (muffled) 
[17:03:54.601]                         invokeRestart("muffleMessage")
[17:03:54.601]                     }
[17:03:54.601]                     else if (inherits(cond, "warning")) {
[17:03:54.601]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:54.601]                       if (muffled) 
[17:03:54.601]                         invokeRestart("muffleWarning")
[17:03:54.601]                     }
[17:03:54.601]                     else if (inherits(cond, "condition")) {
[17:03:54.601]                       if (!is.null(pattern)) {
[17:03:54.601]                         computeRestarts <- base::computeRestarts
[17:03:54.601]                         grepl <- base::grepl
[17:03:54.601]                         restarts <- computeRestarts(cond)
[17:03:54.601]                         for (restart in restarts) {
[17:03:54.601]                           name <- restart$name
[17:03:54.601]                           if (is.null(name)) 
[17:03:54.601]                             next
[17:03:54.601]                           if (!grepl(pattern, name)) 
[17:03:54.601]                             next
[17:03:54.601]                           invokeRestart(restart)
[17:03:54.601]                           muffled <- TRUE
[17:03:54.601]                           break
[17:03:54.601]                         }
[17:03:54.601]                       }
[17:03:54.601]                     }
[17:03:54.601]                     invisible(muffled)
[17:03:54.601]                   }
[17:03:54.601]                   muffleCondition(cond)
[17:03:54.601]                 })
[17:03:54.601]             }))
[17:03:54.601]             future::FutureResult(value = ...future.value$value, 
[17:03:54.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.601]                   ...future.rng), globalenv = if (FALSE) 
[17:03:54.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:54.601]                     ...future.globalenv.names))
[17:03:54.601]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:54.601]         }, condition = base::local({
[17:03:54.601]             c <- base::c
[17:03:54.601]             inherits <- base::inherits
[17:03:54.601]             invokeRestart <- base::invokeRestart
[17:03:54.601]             length <- base::length
[17:03:54.601]             list <- base::list
[17:03:54.601]             seq.int <- base::seq.int
[17:03:54.601]             signalCondition <- base::signalCondition
[17:03:54.601]             sys.calls <- base::sys.calls
[17:03:54.601]             `[[` <- base::`[[`
[17:03:54.601]             `+` <- base::`+`
[17:03:54.601]             `<<-` <- base::`<<-`
[17:03:54.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:54.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:54.601]                   3L)]
[17:03:54.601]             }
[17:03:54.601]             function(cond) {
[17:03:54.601]                 is_error <- inherits(cond, "error")
[17:03:54.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:54.601]                   NULL)
[17:03:54.601]                 if (is_error) {
[17:03:54.601]                   sessionInformation <- function() {
[17:03:54.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:54.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:54.601]                       search = base::search(), system = base::Sys.info())
[17:03:54.601]                   }
[17:03:54.601]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:54.601]                     cond$call), session = sessionInformation(), 
[17:03:54.601]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:54.601]                   signalCondition(cond)
[17:03:54.601]                 }
[17:03:54.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:54.601]                 "immediateCondition"))) {
[17:03:54.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:54.601]                   ...future.conditions[[length(...future.conditions) + 
[17:03:54.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:54.601]                   if (TRUE && !signal) {
[17:03:54.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.601]                     {
[17:03:54.601]                       inherits <- base::inherits
[17:03:54.601]                       invokeRestart <- base::invokeRestart
[17:03:54.601]                       is.null <- base::is.null
[17:03:54.601]                       muffled <- FALSE
[17:03:54.601]                       if (inherits(cond, "message")) {
[17:03:54.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.601]                         if (muffled) 
[17:03:54.601]                           invokeRestart("muffleMessage")
[17:03:54.601]                       }
[17:03:54.601]                       else if (inherits(cond, "warning")) {
[17:03:54.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.601]                         if (muffled) 
[17:03:54.601]                           invokeRestart("muffleWarning")
[17:03:54.601]                       }
[17:03:54.601]                       else if (inherits(cond, "condition")) {
[17:03:54.601]                         if (!is.null(pattern)) {
[17:03:54.601]                           computeRestarts <- base::computeRestarts
[17:03:54.601]                           grepl <- base::grepl
[17:03:54.601]                           restarts <- computeRestarts(cond)
[17:03:54.601]                           for (restart in restarts) {
[17:03:54.601]                             name <- restart$name
[17:03:54.601]                             if (is.null(name)) 
[17:03:54.601]                               next
[17:03:54.601]                             if (!grepl(pattern, name)) 
[17:03:54.601]                               next
[17:03:54.601]                             invokeRestart(restart)
[17:03:54.601]                             muffled <- TRUE
[17:03:54.601]                             break
[17:03:54.601]                           }
[17:03:54.601]                         }
[17:03:54.601]                       }
[17:03:54.601]                       invisible(muffled)
[17:03:54.601]                     }
[17:03:54.601]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.601]                   }
[17:03:54.601]                 }
[17:03:54.601]                 else {
[17:03:54.601]                   if (TRUE) {
[17:03:54.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:54.601]                     {
[17:03:54.601]                       inherits <- base::inherits
[17:03:54.601]                       invokeRestart <- base::invokeRestart
[17:03:54.601]                       is.null <- base::is.null
[17:03:54.601]                       muffled <- FALSE
[17:03:54.601]                       if (inherits(cond, "message")) {
[17:03:54.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:54.601]                         if (muffled) 
[17:03:54.601]                           invokeRestart("muffleMessage")
[17:03:54.601]                       }
[17:03:54.601]                       else if (inherits(cond, "warning")) {
[17:03:54.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:54.601]                         if (muffled) 
[17:03:54.601]                           invokeRestart("muffleWarning")
[17:03:54.601]                       }
[17:03:54.601]                       else if (inherits(cond, "condition")) {
[17:03:54.601]                         if (!is.null(pattern)) {
[17:03:54.601]                           computeRestarts <- base::computeRestarts
[17:03:54.601]                           grepl <- base::grepl
[17:03:54.601]                           restarts <- computeRestarts(cond)
[17:03:54.601]                           for (restart in restarts) {
[17:03:54.601]                             name <- restart$name
[17:03:54.601]                             if (is.null(name)) 
[17:03:54.601]                               next
[17:03:54.601]                             if (!grepl(pattern, name)) 
[17:03:54.601]                               next
[17:03:54.601]                             invokeRestart(restart)
[17:03:54.601]                             muffled <- TRUE
[17:03:54.601]                             break
[17:03:54.601]                           }
[17:03:54.601]                         }
[17:03:54.601]                       }
[17:03:54.601]                       invisible(muffled)
[17:03:54.601]                     }
[17:03:54.601]                     muffleCondition(cond, pattern = "^muffle")
[17:03:54.601]                   }
[17:03:54.601]                 }
[17:03:54.601]             }
[17:03:54.601]         }))
[17:03:54.601]     }, error = function(ex) {
[17:03:54.601]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:54.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:54.601]                 ...future.rng), started = ...future.startTime, 
[17:03:54.601]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:54.601]             version = "1.8"), class = "FutureResult")
[17:03:54.601]     }, finally = {
[17:03:54.601]         if (!identical(...future.workdir, getwd())) 
[17:03:54.601]             setwd(...future.workdir)
[17:03:54.601]         {
[17:03:54.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:54.601]                 ...future.oldOptions$nwarnings <- NULL
[17:03:54.601]             }
[17:03:54.601]             base::options(...future.oldOptions)
[17:03:54.601]             if (.Platform$OS.type == "windows") {
[17:03:54.601]                 old_names <- names(...future.oldEnvVars)
[17:03:54.601]                 envs <- base::Sys.getenv()
[17:03:54.601]                 names <- names(envs)
[17:03:54.601]                 common <- intersect(names, old_names)
[17:03:54.601]                 added <- setdiff(names, old_names)
[17:03:54.601]                 removed <- setdiff(old_names, names)
[17:03:54.601]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:54.601]                   envs[common]]
[17:03:54.601]                 NAMES <- toupper(changed)
[17:03:54.601]                 args <- list()
[17:03:54.601]                 for (kk in seq_along(NAMES)) {
[17:03:54.601]                   name <- changed[[kk]]
[17:03:54.601]                   NAME <- NAMES[[kk]]
[17:03:54.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.601]                     next
[17:03:54.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.601]                 }
[17:03:54.601]                 NAMES <- toupper(added)
[17:03:54.601]                 for (kk in seq_along(NAMES)) {
[17:03:54.601]                   name <- added[[kk]]
[17:03:54.601]                   NAME <- NAMES[[kk]]
[17:03:54.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.601]                     next
[17:03:54.601]                   args[[name]] <- ""
[17:03:54.601]                 }
[17:03:54.601]                 NAMES <- toupper(removed)
[17:03:54.601]                 for (kk in seq_along(NAMES)) {
[17:03:54.601]                   name <- removed[[kk]]
[17:03:54.601]                   NAME <- NAMES[[kk]]
[17:03:54.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:54.601]                     next
[17:03:54.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:54.601]                 }
[17:03:54.601]                 if (length(args) > 0) 
[17:03:54.601]                   base::do.call(base::Sys.setenv, args = args)
[17:03:54.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:54.601]             }
[17:03:54.601]             else {
[17:03:54.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:54.601]             }
[17:03:54.601]             {
[17:03:54.601]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:54.601]                   0L) {
[17:03:54.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:54.601]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:54.601]                   base::options(opts)
[17:03:54.601]                 }
[17:03:54.601]                 {
[17:03:54.601]                   {
[17:03:54.601]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:54.601]                     NULL
[17:03:54.601]                   }
[17:03:54.601]                   options(future.plan = NULL)
[17:03:54.601]                   if (is.na(NA_character_)) 
[17:03:54.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:54.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:54.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:54.601]                     .init = FALSE)
[17:03:54.601]                 }
[17:03:54.601]             }
[17:03:54.601]         }
[17:03:54.601]     })
[17:03:54.601]     if (TRUE) {
[17:03:54.601]         base::sink(type = "output", split = FALSE)
[17:03:54.601]         if (TRUE) {
[17:03:54.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:54.601]         }
[17:03:54.601]         else {
[17:03:54.601]             ...future.result["stdout"] <- base::list(NULL)
[17:03:54.601]         }
[17:03:54.601]         base::close(...future.stdout)
[17:03:54.601]         ...future.stdout <- NULL
[17:03:54.601]     }
[17:03:54.601]     ...future.result$conditions <- ...future.conditions
[17:03:54.601]     ...future.result$finished <- base::Sys.time()
[17:03:54.601]     ...future.result
[17:03:54.601] }
[17:03:54.604] MultisessionFuture started
[17:03:54.604] - Launch lazy future ... done
[17:03:54.604] run() for ‘MultisessionFuture’ ... done
[17:03:55.106] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.107] - Validating connection of MultisessionFuture
[17:03:55.107] - received message: FutureResult
[17:03:55.107] - Received FutureResult
[17:03:55.107] - Erased future from FutureRegistry
[17:03:55.107] result() for ClusterFuture ...
[17:03:55.107] - result already collected: FutureResult
[17:03:55.107] result() for ClusterFuture ... done
[17:03:55.107] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.108] resolve() on list ...
[17:03:55.108]  recursive: Inf
[17:03:55.108]  length: 2
[17:03:55.108]  elements: ‘a’, ‘b’
[17:03:55.108]  length: 1 (resolved future 1)
[17:03:55.108]  length: 0 (resolved future 2)
[17:03:55.108] resolve() on list ... DONE
[17:03:55.108] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:03:55.108] getGlobalsAndPackages() ...
[17:03:55.109] Searching for globals...
[17:03:55.109] - globals found: [2] ‘list’, ‘stop’
[17:03:55.109] Searching for globals ... DONE
[17:03:55.109] Resolving globals: FALSE
[17:03:55.110] 
[17:03:55.110] 
[17:03:55.110] getGlobalsAndPackages() ... DONE
[17:03:55.110] run() for ‘Future’ ...
[17:03:55.110] - state: ‘created’
[17:03:55.110] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.124] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.124] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.125]   - Field: ‘node’
[17:03:55.125]   - Field: ‘label’
[17:03:55.125]   - Field: ‘local’
[17:03:55.125]   - Field: ‘owner’
[17:03:55.125]   - Field: ‘envir’
[17:03:55.125]   - Field: ‘workers’
[17:03:55.125]   - Field: ‘packages’
[17:03:55.125]   - Field: ‘gc’
[17:03:55.125]   - Field: ‘conditions’
[17:03:55.125]   - Field: ‘persistent’
[17:03:55.125]   - Field: ‘expr’
[17:03:55.126]   - Field: ‘uuid’
[17:03:55.126]   - Field: ‘seed’
[17:03:55.126]   - Field: ‘version’
[17:03:55.126]   - Field: ‘result’
[17:03:55.126]   - Field: ‘asynchronous’
[17:03:55.126]   - Field: ‘calls’
[17:03:55.126]   - Field: ‘globals’
[17:03:55.126]   - Field: ‘stdout’
[17:03:55.126]   - Field: ‘earlySignal’
[17:03:55.126]   - Field: ‘lazy’
[17:03:55.126]   - Field: ‘state’
[17:03:55.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.127] - Launch lazy future ...
[17:03:55.127] Packages needed by the future expression (n = 0): <none>
[17:03:55.127] Packages needed by future strategies (n = 0): <none>
[17:03:55.127] {
[17:03:55.127]     {
[17:03:55.127]         {
[17:03:55.127]             ...future.startTime <- base::Sys.time()
[17:03:55.127]             {
[17:03:55.127]                 {
[17:03:55.127]                   {
[17:03:55.127]                     {
[17:03:55.127]                       base::local({
[17:03:55.127]                         has_future <- base::requireNamespace("future", 
[17:03:55.127]                           quietly = TRUE)
[17:03:55.127]                         if (has_future) {
[17:03:55.127]                           ns <- base::getNamespace("future")
[17:03:55.127]                           version <- ns[[".package"]][["version"]]
[17:03:55.127]                           if (is.null(version)) 
[17:03:55.127]                             version <- utils::packageVersion("future")
[17:03:55.127]                         }
[17:03:55.127]                         else {
[17:03:55.127]                           version <- NULL
[17:03:55.127]                         }
[17:03:55.127]                         if (!has_future || version < "1.8.0") {
[17:03:55.127]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.127]                             "", base::R.version$version.string), 
[17:03:55.127]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.127]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.127]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.127]                               "release", "version")], collapse = " "), 
[17:03:55.127]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.127]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.127]                             info)
[17:03:55.127]                           info <- base::paste(info, collapse = "; ")
[17:03:55.127]                           if (!has_future) {
[17:03:55.127]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.127]                               info)
[17:03:55.127]                           }
[17:03:55.127]                           else {
[17:03:55.127]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.127]                               info, version)
[17:03:55.127]                           }
[17:03:55.127]                           base::stop(msg)
[17:03:55.127]                         }
[17:03:55.127]                       })
[17:03:55.127]                     }
[17:03:55.127]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.127]                     base::options(mc.cores = 1L)
[17:03:55.127]                   }
[17:03:55.127]                   ...future.strategy.old <- future::plan("list")
[17:03:55.127]                   options(future.plan = NULL)
[17:03:55.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.127]                 }
[17:03:55.127]                 ...future.workdir <- getwd()
[17:03:55.127]             }
[17:03:55.127]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.127]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.127]         }
[17:03:55.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.127]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.127]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.127]             base::names(...future.oldOptions))
[17:03:55.127]     }
[17:03:55.127]     if (FALSE) {
[17:03:55.127]     }
[17:03:55.127]     else {
[17:03:55.127]         if (TRUE) {
[17:03:55.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.127]                 open = "w")
[17:03:55.127]         }
[17:03:55.127]         else {
[17:03:55.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.127]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.127]         }
[17:03:55.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.127]             base::sink(type = "output", split = FALSE)
[17:03:55.127]             base::close(...future.stdout)
[17:03:55.127]         }, add = TRUE)
[17:03:55.127]     }
[17:03:55.127]     ...future.frame <- base::sys.nframe()
[17:03:55.127]     ...future.conditions <- base::list()
[17:03:55.127]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.127]     if (FALSE) {
[17:03:55.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.127]     }
[17:03:55.127]     ...future.result <- base::tryCatch({
[17:03:55.127]         base::withCallingHandlers({
[17:03:55.127]             ...future.value <- base::withVisible(base::local({
[17:03:55.127]                 ...future.makeSendCondition <- base::local({
[17:03:55.127]                   sendCondition <- NULL
[17:03:55.127]                   function(frame = 1L) {
[17:03:55.127]                     if (is.function(sendCondition)) 
[17:03:55.127]                       return(sendCondition)
[17:03:55.127]                     ns <- getNamespace("parallel")
[17:03:55.127]                     if (exists("sendData", mode = "function", 
[17:03:55.127]                       envir = ns)) {
[17:03:55.127]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.127]                         envir = ns)
[17:03:55.127]                       envir <- sys.frame(frame)
[17:03:55.127]                       master <- NULL
[17:03:55.127]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.127]                         !identical(envir, emptyenv())) {
[17:03:55.127]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.127]                           inherits = FALSE)) {
[17:03:55.127]                           master <- get("master", mode = "list", 
[17:03:55.127]                             envir = envir, inherits = FALSE)
[17:03:55.127]                           if (inherits(master, c("SOCKnode", 
[17:03:55.127]                             "SOCK0node"))) {
[17:03:55.127]                             sendCondition <<- function(cond) {
[17:03:55.127]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.127]                                 success = TRUE)
[17:03:55.127]                               parallel_sendData(master, data)
[17:03:55.127]                             }
[17:03:55.127]                             return(sendCondition)
[17:03:55.127]                           }
[17:03:55.127]                         }
[17:03:55.127]                         frame <- frame + 1L
[17:03:55.127]                         envir <- sys.frame(frame)
[17:03:55.127]                       }
[17:03:55.127]                     }
[17:03:55.127]                     sendCondition <<- function(cond) NULL
[17:03:55.127]                   }
[17:03:55.127]                 })
[17:03:55.127]                 withCallingHandlers({
[17:03:55.127]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:55.127]                 }, immediateCondition = function(cond) {
[17:03:55.127]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.127]                   sendCondition(cond)
[17:03:55.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.127]                   {
[17:03:55.127]                     inherits <- base::inherits
[17:03:55.127]                     invokeRestart <- base::invokeRestart
[17:03:55.127]                     is.null <- base::is.null
[17:03:55.127]                     muffled <- FALSE
[17:03:55.127]                     if (inherits(cond, "message")) {
[17:03:55.127]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.127]                       if (muffled) 
[17:03:55.127]                         invokeRestart("muffleMessage")
[17:03:55.127]                     }
[17:03:55.127]                     else if (inherits(cond, "warning")) {
[17:03:55.127]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.127]                       if (muffled) 
[17:03:55.127]                         invokeRestart("muffleWarning")
[17:03:55.127]                     }
[17:03:55.127]                     else if (inherits(cond, "condition")) {
[17:03:55.127]                       if (!is.null(pattern)) {
[17:03:55.127]                         computeRestarts <- base::computeRestarts
[17:03:55.127]                         grepl <- base::grepl
[17:03:55.127]                         restarts <- computeRestarts(cond)
[17:03:55.127]                         for (restart in restarts) {
[17:03:55.127]                           name <- restart$name
[17:03:55.127]                           if (is.null(name)) 
[17:03:55.127]                             next
[17:03:55.127]                           if (!grepl(pattern, name)) 
[17:03:55.127]                             next
[17:03:55.127]                           invokeRestart(restart)
[17:03:55.127]                           muffled <- TRUE
[17:03:55.127]                           break
[17:03:55.127]                         }
[17:03:55.127]                       }
[17:03:55.127]                     }
[17:03:55.127]                     invisible(muffled)
[17:03:55.127]                   }
[17:03:55.127]                   muffleCondition(cond)
[17:03:55.127]                 })
[17:03:55.127]             }))
[17:03:55.127]             future::FutureResult(value = ...future.value$value, 
[17:03:55.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.127]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.127]                     ...future.globalenv.names))
[17:03:55.127]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.127]         }, condition = base::local({
[17:03:55.127]             c <- base::c
[17:03:55.127]             inherits <- base::inherits
[17:03:55.127]             invokeRestart <- base::invokeRestart
[17:03:55.127]             length <- base::length
[17:03:55.127]             list <- base::list
[17:03:55.127]             seq.int <- base::seq.int
[17:03:55.127]             signalCondition <- base::signalCondition
[17:03:55.127]             sys.calls <- base::sys.calls
[17:03:55.127]             `[[` <- base::`[[`
[17:03:55.127]             `+` <- base::`+`
[17:03:55.127]             `<<-` <- base::`<<-`
[17:03:55.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.127]                   3L)]
[17:03:55.127]             }
[17:03:55.127]             function(cond) {
[17:03:55.127]                 is_error <- inherits(cond, "error")
[17:03:55.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.127]                   NULL)
[17:03:55.127]                 if (is_error) {
[17:03:55.127]                   sessionInformation <- function() {
[17:03:55.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.127]                       search = base::search(), system = base::Sys.info())
[17:03:55.127]                   }
[17:03:55.127]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.127]                     cond$call), session = sessionInformation(), 
[17:03:55.127]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.127]                   signalCondition(cond)
[17:03:55.127]                 }
[17:03:55.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.127]                 "immediateCondition"))) {
[17:03:55.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.127]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.127]                   if (TRUE && !signal) {
[17:03:55.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.127]                     {
[17:03:55.127]                       inherits <- base::inherits
[17:03:55.127]                       invokeRestart <- base::invokeRestart
[17:03:55.127]                       is.null <- base::is.null
[17:03:55.127]                       muffled <- FALSE
[17:03:55.127]                       if (inherits(cond, "message")) {
[17:03:55.127]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.127]                         if (muffled) 
[17:03:55.127]                           invokeRestart("muffleMessage")
[17:03:55.127]                       }
[17:03:55.127]                       else if (inherits(cond, "warning")) {
[17:03:55.127]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.127]                         if (muffled) 
[17:03:55.127]                           invokeRestart("muffleWarning")
[17:03:55.127]                       }
[17:03:55.127]                       else if (inherits(cond, "condition")) {
[17:03:55.127]                         if (!is.null(pattern)) {
[17:03:55.127]                           computeRestarts <- base::computeRestarts
[17:03:55.127]                           grepl <- base::grepl
[17:03:55.127]                           restarts <- computeRestarts(cond)
[17:03:55.127]                           for (restart in restarts) {
[17:03:55.127]                             name <- restart$name
[17:03:55.127]                             if (is.null(name)) 
[17:03:55.127]                               next
[17:03:55.127]                             if (!grepl(pattern, name)) 
[17:03:55.127]                               next
[17:03:55.127]                             invokeRestart(restart)
[17:03:55.127]                             muffled <- TRUE
[17:03:55.127]                             break
[17:03:55.127]                           }
[17:03:55.127]                         }
[17:03:55.127]                       }
[17:03:55.127]                       invisible(muffled)
[17:03:55.127]                     }
[17:03:55.127]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.127]                   }
[17:03:55.127]                 }
[17:03:55.127]                 else {
[17:03:55.127]                   if (TRUE) {
[17:03:55.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.127]                     {
[17:03:55.127]                       inherits <- base::inherits
[17:03:55.127]                       invokeRestart <- base::invokeRestart
[17:03:55.127]                       is.null <- base::is.null
[17:03:55.127]                       muffled <- FALSE
[17:03:55.127]                       if (inherits(cond, "message")) {
[17:03:55.127]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.127]                         if (muffled) 
[17:03:55.127]                           invokeRestart("muffleMessage")
[17:03:55.127]                       }
[17:03:55.127]                       else if (inherits(cond, "warning")) {
[17:03:55.127]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.127]                         if (muffled) 
[17:03:55.127]                           invokeRestart("muffleWarning")
[17:03:55.127]                       }
[17:03:55.127]                       else if (inherits(cond, "condition")) {
[17:03:55.127]                         if (!is.null(pattern)) {
[17:03:55.127]                           computeRestarts <- base::computeRestarts
[17:03:55.127]                           grepl <- base::grepl
[17:03:55.127]                           restarts <- computeRestarts(cond)
[17:03:55.127]                           for (restart in restarts) {
[17:03:55.127]                             name <- restart$name
[17:03:55.127]                             if (is.null(name)) 
[17:03:55.127]                               next
[17:03:55.127]                             if (!grepl(pattern, name)) 
[17:03:55.127]                               next
[17:03:55.127]                             invokeRestart(restart)
[17:03:55.127]                             muffled <- TRUE
[17:03:55.127]                             break
[17:03:55.127]                           }
[17:03:55.127]                         }
[17:03:55.127]                       }
[17:03:55.127]                       invisible(muffled)
[17:03:55.127]                     }
[17:03:55.127]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.127]                   }
[17:03:55.127]                 }
[17:03:55.127]             }
[17:03:55.127]         }))
[17:03:55.127]     }, error = function(ex) {
[17:03:55.127]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.127]                 ...future.rng), started = ...future.startTime, 
[17:03:55.127]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.127]             version = "1.8"), class = "FutureResult")
[17:03:55.127]     }, finally = {
[17:03:55.127]         if (!identical(...future.workdir, getwd())) 
[17:03:55.127]             setwd(...future.workdir)
[17:03:55.127]         {
[17:03:55.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.127]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.127]             }
[17:03:55.127]             base::options(...future.oldOptions)
[17:03:55.127]             if (.Platform$OS.type == "windows") {
[17:03:55.127]                 old_names <- names(...future.oldEnvVars)
[17:03:55.127]                 envs <- base::Sys.getenv()
[17:03:55.127]                 names <- names(envs)
[17:03:55.127]                 common <- intersect(names, old_names)
[17:03:55.127]                 added <- setdiff(names, old_names)
[17:03:55.127]                 removed <- setdiff(old_names, names)
[17:03:55.127]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.127]                   envs[common]]
[17:03:55.127]                 NAMES <- toupper(changed)
[17:03:55.127]                 args <- list()
[17:03:55.127]                 for (kk in seq_along(NAMES)) {
[17:03:55.127]                   name <- changed[[kk]]
[17:03:55.127]                   NAME <- NAMES[[kk]]
[17:03:55.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.127]                     next
[17:03:55.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.127]                 }
[17:03:55.127]                 NAMES <- toupper(added)
[17:03:55.127]                 for (kk in seq_along(NAMES)) {
[17:03:55.127]                   name <- added[[kk]]
[17:03:55.127]                   NAME <- NAMES[[kk]]
[17:03:55.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.127]                     next
[17:03:55.127]                   args[[name]] <- ""
[17:03:55.127]                 }
[17:03:55.127]                 NAMES <- toupper(removed)
[17:03:55.127]                 for (kk in seq_along(NAMES)) {
[17:03:55.127]                   name <- removed[[kk]]
[17:03:55.127]                   NAME <- NAMES[[kk]]
[17:03:55.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.127]                     next
[17:03:55.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.127]                 }
[17:03:55.127]                 if (length(args) > 0) 
[17:03:55.127]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.127]             }
[17:03:55.127]             else {
[17:03:55.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.127]             }
[17:03:55.127]             {
[17:03:55.127]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.127]                   0L) {
[17:03:55.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.127]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.127]                   base::options(opts)
[17:03:55.127]                 }
[17:03:55.127]                 {
[17:03:55.127]                   {
[17:03:55.127]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.127]                     NULL
[17:03:55.127]                   }
[17:03:55.127]                   options(future.plan = NULL)
[17:03:55.127]                   if (is.na(NA_character_)) 
[17:03:55.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.127]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.127]                     .init = FALSE)
[17:03:55.127]                 }
[17:03:55.127]             }
[17:03:55.127]         }
[17:03:55.127]     })
[17:03:55.127]     if (TRUE) {
[17:03:55.127]         base::sink(type = "output", split = FALSE)
[17:03:55.127]         if (TRUE) {
[17:03:55.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.127]         }
[17:03:55.127]         else {
[17:03:55.127]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.127]         }
[17:03:55.127]         base::close(...future.stdout)
[17:03:55.127]         ...future.stdout <- NULL
[17:03:55.127]     }
[17:03:55.127]     ...future.result$conditions <- ...future.conditions
[17:03:55.127]     ...future.result$finished <- base::Sys.time()
[17:03:55.127]     ...future.result
[17:03:55.127] }
[17:03:55.130] MultisessionFuture started
[17:03:55.131] - Launch lazy future ... done
[17:03:55.131] run() for ‘MultisessionFuture’ ... done
[17:03:55.133] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.133] - Validating connection of MultisessionFuture
[17:03:55.133] - received message: FutureResult
[17:03:55.133] - Received FutureResult
[17:03:55.134] - Erased future from FutureRegistry
[17:03:55.134] result() for ClusterFuture ...
[17:03:55.134] - result already collected: FutureResult
[17:03:55.134] result() for ClusterFuture ... done
[17:03:55.134] signalConditions() ...
[17:03:55.134]  - include = ‘immediateCondition’
[17:03:55.134]  - exclude = 
[17:03:55.134]  - resignal = FALSE
[17:03:55.134]  - Number of conditions: 1
[17:03:55.134] signalConditions() ... done
[17:03:55.134] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.135] A MultisessionFuture was resolved (and resolved itself)
[17:03:55.135] getGlobalsAndPackages() ...
[17:03:55.135] Searching for globals...
[17:03:55.135] - globals found: [2] ‘list’, ‘stop’
[17:03:55.136] Searching for globals ... DONE
[17:03:55.136] Resolving globals: FALSE
[17:03:55.136] 
[17:03:55.136] 
[17:03:55.136] getGlobalsAndPackages() ... DONE
[17:03:55.136] run() for ‘Future’ ...
[17:03:55.136] - state: ‘created’
[17:03:55.137] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.150] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.150]   - Field: ‘node’
[17:03:55.151]   - Field: ‘label’
[17:03:55.151]   - Field: ‘local’
[17:03:55.151]   - Field: ‘owner’
[17:03:55.151]   - Field: ‘envir’
[17:03:55.151]   - Field: ‘workers’
[17:03:55.151]   - Field: ‘packages’
[17:03:55.151]   - Field: ‘gc’
[17:03:55.151]   - Field: ‘conditions’
[17:03:55.151]   - Field: ‘persistent’
[17:03:55.151]   - Field: ‘expr’
[17:03:55.152]   - Field: ‘uuid’
[17:03:55.152]   - Field: ‘seed’
[17:03:55.152]   - Field: ‘version’
[17:03:55.152]   - Field: ‘result’
[17:03:55.152]   - Field: ‘asynchronous’
[17:03:55.152]   - Field: ‘calls’
[17:03:55.152]   - Field: ‘globals’
[17:03:55.152]   - Field: ‘stdout’
[17:03:55.152]   - Field: ‘earlySignal’
[17:03:55.152]   - Field: ‘lazy’
[17:03:55.152]   - Field: ‘state’
[17:03:55.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.153] - Launch lazy future ...
[17:03:55.153] Packages needed by the future expression (n = 0): <none>
[17:03:55.153] Packages needed by future strategies (n = 0): <none>
[17:03:55.153] {
[17:03:55.153]     {
[17:03:55.153]         {
[17:03:55.153]             ...future.startTime <- base::Sys.time()
[17:03:55.153]             {
[17:03:55.153]                 {
[17:03:55.153]                   {
[17:03:55.153]                     {
[17:03:55.153]                       base::local({
[17:03:55.153]                         has_future <- base::requireNamespace("future", 
[17:03:55.153]                           quietly = TRUE)
[17:03:55.153]                         if (has_future) {
[17:03:55.153]                           ns <- base::getNamespace("future")
[17:03:55.153]                           version <- ns[[".package"]][["version"]]
[17:03:55.153]                           if (is.null(version)) 
[17:03:55.153]                             version <- utils::packageVersion("future")
[17:03:55.153]                         }
[17:03:55.153]                         else {
[17:03:55.153]                           version <- NULL
[17:03:55.153]                         }
[17:03:55.153]                         if (!has_future || version < "1.8.0") {
[17:03:55.153]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.153]                             "", base::R.version$version.string), 
[17:03:55.153]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.153]                               "release", "version")], collapse = " "), 
[17:03:55.153]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.153]                             info)
[17:03:55.153]                           info <- base::paste(info, collapse = "; ")
[17:03:55.153]                           if (!has_future) {
[17:03:55.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.153]                               info)
[17:03:55.153]                           }
[17:03:55.153]                           else {
[17:03:55.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.153]                               info, version)
[17:03:55.153]                           }
[17:03:55.153]                           base::stop(msg)
[17:03:55.153]                         }
[17:03:55.153]                       })
[17:03:55.153]                     }
[17:03:55.153]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.153]                     base::options(mc.cores = 1L)
[17:03:55.153]                   }
[17:03:55.153]                   ...future.strategy.old <- future::plan("list")
[17:03:55.153]                   options(future.plan = NULL)
[17:03:55.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.153]                 }
[17:03:55.153]                 ...future.workdir <- getwd()
[17:03:55.153]             }
[17:03:55.153]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.153]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.153]         }
[17:03:55.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.153]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.153]             base::names(...future.oldOptions))
[17:03:55.153]     }
[17:03:55.153]     if (FALSE) {
[17:03:55.153]     }
[17:03:55.153]     else {
[17:03:55.153]         if (TRUE) {
[17:03:55.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.153]                 open = "w")
[17:03:55.153]         }
[17:03:55.153]         else {
[17:03:55.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.153]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.153]         }
[17:03:55.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.153]             base::sink(type = "output", split = FALSE)
[17:03:55.153]             base::close(...future.stdout)
[17:03:55.153]         }, add = TRUE)
[17:03:55.153]     }
[17:03:55.153]     ...future.frame <- base::sys.nframe()
[17:03:55.153]     ...future.conditions <- base::list()
[17:03:55.153]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.153]     if (FALSE) {
[17:03:55.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.153]     }
[17:03:55.153]     ...future.result <- base::tryCatch({
[17:03:55.153]         base::withCallingHandlers({
[17:03:55.153]             ...future.value <- base::withVisible(base::local({
[17:03:55.153]                 ...future.makeSendCondition <- base::local({
[17:03:55.153]                   sendCondition <- NULL
[17:03:55.153]                   function(frame = 1L) {
[17:03:55.153]                     if (is.function(sendCondition)) 
[17:03:55.153]                       return(sendCondition)
[17:03:55.153]                     ns <- getNamespace("parallel")
[17:03:55.153]                     if (exists("sendData", mode = "function", 
[17:03:55.153]                       envir = ns)) {
[17:03:55.153]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.153]                         envir = ns)
[17:03:55.153]                       envir <- sys.frame(frame)
[17:03:55.153]                       master <- NULL
[17:03:55.153]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.153]                         !identical(envir, emptyenv())) {
[17:03:55.153]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.153]                           inherits = FALSE)) {
[17:03:55.153]                           master <- get("master", mode = "list", 
[17:03:55.153]                             envir = envir, inherits = FALSE)
[17:03:55.153]                           if (inherits(master, c("SOCKnode", 
[17:03:55.153]                             "SOCK0node"))) {
[17:03:55.153]                             sendCondition <<- function(cond) {
[17:03:55.153]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.153]                                 success = TRUE)
[17:03:55.153]                               parallel_sendData(master, data)
[17:03:55.153]                             }
[17:03:55.153]                             return(sendCondition)
[17:03:55.153]                           }
[17:03:55.153]                         }
[17:03:55.153]                         frame <- frame + 1L
[17:03:55.153]                         envir <- sys.frame(frame)
[17:03:55.153]                       }
[17:03:55.153]                     }
[17:03:55.153]                     sendCondition <<- function(cond) NULL
[17:03:55.153]                   }
[17:03:55.153]                 })
[17:03:55.153]                 withCallingHandlers({
[17:03:55.153]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:03:55.153]                 }, immediateCondition = function(cond) {
[17:03:55.153]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.153]                   sendCondition(cond)
[17:03:55.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.153]                   {
[17:03:55.153]                     inherits <- base::inherits
[17:03:55.153]                     invokeRestart <- base::invokeRestart
[17:03:55.153]                     is.null <- base::is.null
[17:03:55.153]                     muffled <- FALSE
[17:03:55.153]                     if (inherits(cond, "message")) {
[17:03:55.153]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.153]                       if (muffled) 
[17:03:55.153]                         invokeRestart("muffleMessage")
[17:03:55.153]                     }
[17:03:55.153]                     else if (inherits(cond, "warning")) {
[17:03:55.153]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.153]                       if (muffled) 
[17:03:55.153]                         invokeRestart("muffleWarning")
[17:03:55.153]                     }
[17:03:55.153]                     else if (inherits(cond, "condition")) {
[17:03:55.153]                       if (!is.null(pattern)) {
[17:03:55.153]                         computeRestarts <- base::computeRestarts
[17:03:55.153]                         grepl <- base::grepl
[17:03:55.153]                         restarts <- computeRestarts(cond)
[17:03:55.153]                         for (restart in restarts) {
[17:03:55.153]                           name <- restart$name
[17:03:55.153]                           if (is.null(name)) 
[17:03:55.153]                             next
[17:03:55.153]                           if (!grepl(pattern, name)) 
[17:03:55.153]                             next
[17:03:55.153]                           invokeRestart(restart)
[17:03:55.153]                           muffled <- TRUE
[17:03:55.153]                           break
[17:03:55.153]                         }
[17:03:55.153]                       }
[17:03:55.153]                     }
[17:03:55.153]                     invisible(muffled)
[17:03:55.153]                   }
[17:03:55.153]                   muffleCondition(cond)
[17:03:55.153]                 })
[17:03:55.153]             }))
[17:03:55.153]             future::FutureResult(value = ...future.value$value, 
[17:03:55.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.153]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.153]                     ...future.globalenv.names))
[17:03:55.153]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.153]         }, condition = base::local({
[17:03:55.153]             c <- base::c
[17:03:55.153]             inherits <- base::inherits
[17:03:55.153]             invokeRestart <- base::invokeRestart
[17:03:55.153]             length <- base::length
[17:03:55.153]             list <- base::list
[17:03:55.153]             seq.int <- base::seq.int
[17:03:55.153]             signalCondition <- base::signalCondition
[17:03:55.153]             sys.calls <- base::sys.calls
[17:03:55.153]             `[[` <- base::`[[`
[17:03:55.153]             `+` <- base::`+`
[17:03:55.153]             `<<-` <- base::`<<-`
[17:03:55.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.153]                   3L)]
[17:03:55.153]             }
[17:03:55.153]             function(cond) {
[17:03:55.153]                 is_error <- inherits(cond, "error")
[17:03:55.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.153]                   NULL)
[17:03:55.153]                 if (is_error) {
[17:03:55.153]                   sessionInformation <- function() {
[17:03:55.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.153]                       search = base::search(), system = base::Sys.info())
[17:03:55.153]                   }
[17:03:55.153]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.153]                     cond$call), session = sessionInformation(), 
[17:03:55.153]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.153]                   signalCondition(cond)
[17:03:55.153]                 }
[17:03:55.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.153]                 "immediateCondition"))) {
[17:03:55.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.153]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.153]                   if (TRUE && !signal) {
[17:03:55.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.153]                     {
[17:03:55.153]                       inherits <- base::inherits
[17:03:55.153]                       invokeRestart <- base::invokeRestart
[17:03:55.153]                       is.null <- base::is.null
[17:03:55.153]                       muffled <- FALSE
[17:03:55.153]                       if (inherits(cond, "message")) {
[17:03:55.153]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.153]                         if (muffled) 
[17:03:55.153]                           invokeRestart("muffleMessage")
[17:03:55.153]                       }
[17:03:55.153]                       else if (inherits(cond, "warning")) {
[17:03:55.153]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.153]                         if (muffled) 
[17:03:55.153]                           invokeRestart("muffleWarning")
[17:03:55.153]                       }
[17:03:55.153]                       else if (inherits(cond, "condition")) {
[17:03:55.153]                         if (!is.null(pattern)) {
[17:03:55.153]                           computeRestarts <- base::computeRestarts
[17:03:55.153]                           grepl <- base::grepl
[17:03:55.153]                           restarts <- computeRestarts(cond)
[17:03:55.153]                           for (restart in restarts) {
[17:03:55.153]                             name <- restart$name
[17:03:55.153]                             if (is.null(name)) 
[17:03:55.153]                               next
[17:03:55.153]                             if (!grepl(pattern, name)) 
[17:03:55.153]                               next
[17:03:55.153]                             invokeRestart(restart)
[17:03:55.153]                             muffled <- TRUE
[17:03:55.153]                             break
[17:03:55.153]                           }
[17:03:55.153]                         }
[17:03:55.153]                       }
[17:03:55.153]                       invisible(muffled)
[17:03:55.153]                     }
[17:03:55.153]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.153]                   }
[17:03:55.153]                 }
[17:03:55.153]                 else {
[17:03:55.153]                   if (TRUE) {
[17:03:55.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.153]                     {
[17:03:55.153]                       inherits <- base::inherits
[17:03:55.153]                       invokeRestart <- base::invokeRestart
[17:03:55.153]                       is.null <- base::is.null
[17:03:55.153]                       muffled <- FALSE
[17:03:55.153]                       if (inherits(cond, "message")) {
[17:03:55.153]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.153]                         if (muffled) 
[17:03:55.153]                           invokeRestart("muffleMessage")
[17:03:55.153]                       }
[17:03:55.153]                       else if (inherits(cond, "warning")) {
[17:03:55.153]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.153]                         if (muffled) 
[17:03:55.153]                           invokeRestart("muffleWarning")
[17:03:55.153]                       }
[17:03:55.153]                       else if (inherits(cond, "condition")) {
[17:03:55.153]                         if (!is.null(pattern)) {
[17:03:55.153]                           computeRestarts <- base::computeRestarts
[17:03:55.153]                           grepl <- base::grepl
[17:03:55.153]                           restarts <- computeRestarts(cond)
[17:03:55.153]                           for (restart in restarts) {
[17:03:55.153]                             name <- restart$name
[17:03:55.153]                             if (is.null(name)) 
[17:03:55.153]                               next
[17:03:55.153]                             if (!grepl(pattern, name)) 
[17:03:55.153]                               next
[17:03:55.153]                             invokeRestart(restart)
[17:03:55.153]                             muffled <- TRUE
[17:03:55.153]                             break
[17:03:55.153]                           }
[17:03:55.153]                         }
[17:03:55.153]                       }
[17:03:55.153]                       invisible(muffled)
[17:03:55.153]                     }
[17:03:55.153]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.153]                   }
[17:03:55.153]                 }
[17:03:55.153]             }
[17:03:55.153]         }))
[17:03:55.153]     }, error = function(ex) {
[17:03:55.153]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.153]                 ...future.rng), started = ...future.startTime, 
[17:03:55.153]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.153]             version = "1.8"), class = "FutureResult")
[17:03:55.153]     }, finally = {
[17:03:55.153]         if (!identical(...future.workdir, getwd())) 
[17:03:55.153]             setwd(...future.workdir)
[17:03:55.153]         {
[17:03:55.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.153]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.153]             }
[17:03:55.153]             base::options(...future.oldOptions)
[17:03:55.153]             if (.Platform$OS.type == "windows") {
[17:03:55.153]                 old_names <- names(...future.oldEnvVars)
[17:03:55.153]                 envs <- base::Sys.getenv()
[17:03:55.153]                 names <- names(envs)
[17:03:55.153]                 common <- intersect(names, old_names)
[17:03:55.153]                 added <- setdiff(names, old_names)
[17:03:55.153]                 removed <- setdiff(old_names, names)
[17:03:55.153]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.153]                   envs[common]]
[17:03:55.153]                 NAMES <- toupper(changed)
[17:03:55.153]                 args <- list()
[17:03:55.153]                 for (kk in seq_along(NAMES)) {
[17:03:55.153]                   name <- changed[[kk]]
[17:03:55.153]                   NAME <- NAMES[[kk]]
[17:03:55.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.153]                     next
[17:03:55.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.153]                 }
[17:03:55.153]                 NAMES <- toupper(added)
[17:03:55.153]                 for (kk in seq_along(NAMES)) {
[17:03:55.153]                   name <- added[[kk]]
[17:03:55.153]                   NAME <- NAMES[[kk]]
[17:03:55.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.153]                     next
[17:03:55.153]                   args[[name]] <- ""
[17:03:55.153]                 }
[17:03:55.153]                 NAMES <- toupper(removed)
[17:03:55.153]                 for (kk in seq_along(NAMES)) {
[17:03:55.153]                   name <- removed[[kk]]
[17:03:55.153]                   NAME <- NAMES[[kk]]
[17:03:55.153]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.153]                     next
[17:03:55.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.153]                 }
[17:03:55.153]                 if (length(args) > 0) 
[17:03:55.153]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.153]             }
[17:03:55.153]             else {
[17:03:55.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.153]             }
[17:03:55.153]             {
[17:03:55.153]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.153]                   0L) {
[17:03:55.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.153]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.153]                   base::options(opts)
[17:03:55.153]                 }
[17:03:55.153]                 {
[17:03:55.153]                   {
[17:03:55.153]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.153]                     NULL
[17:03:55.153]                   }
[17:03:55.153]                   options(future.plan = NULL)
[17:03:55.153]                   if (is.na(NA_character_)) 
[17:03:55.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.153]                     .init = FALSE)
[17:03:55.153]                 }
[17:03:55.153]             }
[17:03:55.153]         }
[17:03:55.153]     })
[17:03:55.153]     if (TRUE) {
[17:03:55.153]         base::sink(type = "output", split = FALSE)
[17:03:55.153]         if (TRUE) {
[17:03:55.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.153]         }
[17:03:55.153]         else {
[17:03:55.153]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.153]         }
[17:03:55.153]         base::close(...future.stdout)
[17:03:55.153]         ...future.stdout <- NULL
[17:03:55.153]     }
[17:03:55.153]     ...future.result$conditions <- ...future.conditions
[17:03:55.153]     ...future.result$finished <- base::Sys.time()
[17:03:55.153]     ...future.result
[17:03:55.153] }
[17:03:55.156] MultisessionFuture started
[17:03:55.156] - Launch lazy future ... done
[17:03:55.157] run() for ‘MultisessionFuture’ ... done
[17:03:55.158] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.159] - Validating connection of MultisessionFuture
[17:03:55.159] - received message: FutureResult
[17:03:55.159] - Received FutureResult
[17:03:55.159] - Erased future from FutureRegistry
[17:03:55.159] result() for ClusterFuture ...
[17:03:55.159] - result already collected: FutureResult
[17:03:55.160] result() for ClusterFuture ... done
[17:03:55.160] signalConditions() ...
[17:03:55.160]  - include = ‘immediateCondition’
[17:03:55.160]  - exclude = 
[17:03:55.160]  - resignal = FALSE
[17:03:55.160]  - Number of conditions: 1
[17:03:55.160] signalConditions() ... done
[17:03:55.160] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.160] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[17:03:55.161] resolve() on list ...
[17:03:55.161]  recursive: 0
[17:03:55.161]  length: 2
[17:03:55.161]  elements: ‘a’, ‘b’
[17:03:55.161]  length: 1 (resolved future 1)
[17:03:55.161]  length: 0 (resolved future 2)
[17:03:55.161] resolve() on list ... DONE
[17:03:55.161] getGlobalsAndPackages() ...
[17:03:55.161] Searching for globals...
[17:03:55.162] 
[17:03:55.162] Searching for globals ... DONE
[17:03:55.162] - globals: [0] <none>
[17:03:55.162] getGlobalsAndPackages() ... DONE
[17:03:55.162] run() for ‘Future’ ...
[17:03:55.162] - state: ‘created’
[17:03:55.162] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.176]   - Field: ‘node’
[17:03:55.176]   - Field: ‘label’
[17:03:55.176]   - Field: ‘local’
[17:03:55.176]   - Field: ‘owner’
[17:03:55.176]   - Field: ‘envir’
[17:03:55.177]   - Field: ‘workers’
[17:03:55.177]   - Field: ‘packages’
[17:03:55.177]   - Field: ‘gc’
[17:03:55.177]   - Field: ‘conditions’
[17:03:55.177]   - Field: ‘persistent’
[17:03:55.177]   - Field: ‘expr’
[17:03:55.177]   - Field: ‘uuid’
[17:03:55.177]   - Field: ‘seed’
[17:03:55.177]   - Field: ‘version’
[17:03:55.177]   - Field: ‘result’
[17:03:55.177]   - Field: ‘asynchronous’
[17:03:55.178]   - Field: ‘calls’
[17:03:55.178]   - Field: ‘globals’
[17:03:55.178]   - Field: ‘stdout’
[17:03:55.178]   - Field: ‘earlySignal’
[17:03:55.180]   - Field: ‘lazy’
[17:03:55.180]   - Field: ‘state’
[17:03:55.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.181] - Launch lazy future ...
[17:03:55.181] Packages needed by the future expression (n = 0): <none>
[17:03:55.181] Packages needed by future strategies (n = 0): <none>
[17:03:55.182] {
[17:03:55.182]     {
[17:03:55.182]         {
[17:03:55.182]             ...future.startTime <- base::Sys.time()
[17:03:55.182]             {
[17:03:55.182]                 {
[17:03:55.182]                   {
[17:03:55.182]                     {
[17:03:55.182]                       base::local({
[17:03:55.182]                         has_future <- base::requireNamespace("future", 
[17:03:55.182]                           quietly = TRUE)
[17:03:55.182]                         if (has_future) {
[17:03:55.182]                           ns <- base::getNamespace("future")
[17:03:55.182]                           version <- ns[[".package"]][["version"]]
[17:03:55.182]                           if (is.null(version)) 
[17:03:55.182]                             version <- utils::packageVersion("future")
[17:03:55.182]                         }
[17:03:55.182]                         else {
[17:03:55.182]                           version <- NULL
[17:03:55.182]                         }
[17:03:55.182]                         if (!has_future || version < "1.8.0") {
[17:03:55.182]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.182]                             "", base::R.version$version.string), 
[17:03:55.182]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.182]                               "release", "version")], collapse = " "), 
[17:03:55.182]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.182]                             info)
[17:03:55.182]                           info <- base::paste(info, collapse = "; ")
[17:03:55.182]                           if (!has_future) {
[17:03:55.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.182]                               info)
[17:03:55.182]                           }
[17:03:55.182]                           else {
[17:03:55.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.182]                               info, version)
[17:03:55.182]                           }
[17:03:55.182]                           base::stop(msg)
[17:03:55.182]                         }
[17:03:55.182]                       })
[17:03:55.182]                     }
[17:03:55.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.182]                     base::options(mc.cores = 1L)
[17:03:55.182]                   }
[17:03:55.182]                   ...future.strategy.old <- future::plan("list")
[17:03:55.182]                   options(future.plan = NULL)
[17:03:55.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.182]                 }
[17:03:55.182]                 ...future.workdir <- getwd()
[17:03:55.182]             }
[17:03:55.182]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.182]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.182]         }
[17:03:55.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.182]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.182]             base::names(...future.oldOptions))
[17:03:55.182]     }
[17:03:55.182]     if (FALSE) {
[17:03:55.182]     }
[17:03:55.182]     else {
[17:03:55.182]         if (TRUE) {
[17:03:55.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.182]                 open = "w")
[17:03:55.182]         }
[17:03:55.182]         else {
[17:03:55.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.182]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.182]         }
[17:03:55.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.182]             base::sink(type = "output", split = FALSE)
[17:03:55.182]             base::close(...future.stdout)
[17:03:55.182]         }, add = TRUE)
[17:03:55.182]     }
[17:03:55.182]     ...future.frame <- base::sys.nframe()
[17:03:55.182]     ...future.conditions <- base::list()
[17:03:55.182]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.182]     if (FALSE) {
[17:03:55.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.182]     }
[17:03:55.182]     ...future.result <- base::tryCatch({
[17:03:55.182]         base::withCallingHandlers({
[17:03:55.182]             ...future.value <- base::withVisible(base::local({
[17:03:55.182]                 ...future.makeSendCondition <- base::local({
[17:03:55.182]                   sendCondition <- NULL
[17:03:55.182]                   function(frame = 1L) {
[17:03:55.182]                     if (is.function(sendCondition)) 
[17:03:55.182]                       return(sendCondition)
[17:03:55.182]                     ns <- getNamespace("parallel")
[17:03:55.182]                     if (exists("sendData", mode = "function", 
[17:03:55.182]                       envir = ns)) {
[17:03:55.182]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.182]                         envir = ns)
[17:03:55.182]                       envir <- sys.frame(frame)
[17:03:55.182]                       master <- NULL
[17:03:55.182]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.182]                         !identical(envir, emptyenv())) {
[17:03:55.182]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.182]                           inherits = FALSE)) {
[17:03:55.182]                           master <- get("master", mode = "list", 
[17:03:55.182]                             envir = envir, inherits = FALSE)
[17:03:55.182]                           if (inherits(master, c("SOCKnode", 
[17:03:55.182]                             "SOCK0node"))) {
[17:03:55.182]                             sendCondition <<- function(cond) {
[17:03:55.182]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.182]                                 success = TRUE)
[17:03:55.182]                               parallel_sendData(master, data)
[17:03:55.182]                             }
[17:03:55.182]                             return(sendCondition)
[17:03:55.182]                           }
[17:03:55.182]                         }
[17:03:55.182]                         frame <- frame + 1L
[17:03:55.182]                         envir <- sys.frame(frame)
[17:03:55.182]                       }
[17:03:55.182]                     }
[17:03:55.182]                     sendCondition <<- function(cond) NULL
[17:03:55.182]                   }
[17:03:55.182]                 })
[17:03:55.182]                 withCallingHandlers({
[17:03:55.182]                   1
[17:03:55.182]                 }, immediateCondition = function(cond) {
[17:03:55.182]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.182]                   sendCondition(cond)
[17:03:55.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.182]                   {
[17:03:55.182]                     inherits <- base::inherits
[17:03:55.182]                     invokeRestart <- base::invokeRestart
[17:03:55.182]                     is.null <- base::is.null
[17:03:55.182]                     muffled <- FALSE
[17:03:55.182]                     if (inherits(cond, "message")) {
[17:03:55.182]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.182]                       if (muffled) 
[17:03:55.182]                         invokeRestart("muffleMessage")
[17:03:55.182]                     }
[17:03:55.182]                     else if (inherits(cond, "warning")) {
[17:03:55.182]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.182]                       if (muffled) 
[17:03:55.182]                         invokeRestart("muffleWarning")
[17:03:55.182]                     }
[17:03:55.182]                     else if (inherits(cond, "condition")) {
[17:03:55.182]                       if (!is.null(pattern)) {
[17:03:55.182]                         computeRestarts <- base::computeRestarts
[17:03:55.182]                         grepl <- base::grepl
[17:03:55.182]                         restarts <- computeRestarts(cond)
[17:03:55.182]                         for (restart in restarts) {
[17:03:55.182]                           name <- restart$name
[17:03:55.182]                           if (is.null(name)) 
[17:03:55.182]                             next
[17:03:55.182]                           if (!grepl(pattern, name)) 
[17:03:55.182]                             next
[17:03:55.182]                           invokeRestart(restart)
[17:03:55.182]                           muffled <- TRUE
[17:03:55.182]                           break
[17:03:55.182]                         }
[17:03:55.182]                       }
[17:03:55.182]                     }
[17:03:55.182]                     invisible(muffled)
[17:03:55.182]                   }
[17:03:55.182]                   muffleCondition(cond)
[17:03:55.182]                 })
[17:03:55.182]             }))
[17:03:55.182]             future::FutureResult(value = ...future.value$value, 
[17:03:55.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.182]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.182]                     ...future.globalenv.names))
[17:03:55.182]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.182]         }, condition = base::local({
[17:03:55.182]             c <- base::c
[17:03:55.182]             inherits <- base::inherits
[17:03:55.182]             invokeRestart <- base::invokeRestart
[17:03:55.182]             length <- base::length
[17:03:55.182]             list <- base::list
[17:03:55.182]             seq.int <- base::seq.int
[17:03:55.182]             signalCondition <- base::signalCondition
[17:03:55.182]             sys.calls <- base::sys.calls
[17:03:55.182]             `[[` <- base::`[[`
[17:03:55.182]             `+` <- base::`+`
[17:03:55.182]             `<<-` <- base::`<<-`
[17:03:55.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.182]                   3L)]
[17:03:55.182]             }
[17:03:55.182]             function(cond) {
[17:03:55.182]                 is_error <- inherits(cond, "error")
[17:03:55.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.182]                   NULL)
[17:03:55.182]                 if (is_error) {
[17:03:55.182]                   sessionInformation <- function() {
[17:03:55.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.182]                       search = base::search(), system = base::Sys.info())
[17:03:55.182]                   }
[17:03:55.182]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.182]                     cond$call), session = sessionInformation(), 
[17:03:55.182]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.182]                   signalCondition(cond)
[17:03:55.182]                 }
[17:03:55.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.182]                 "immediateCondition"))) {
[17:03:55.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.182]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.182]                   if (TRUE && !signal) {
[17:03:55.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.182]                     {
[17:03:55.182]                       inherits <- base::inherits
[17:03:55.182]                       invokeRestart <- base::invokeRestart
[17:03:55.182]                       is.null <- base::is.null
[17:03:55.182]                       muffled <- FALSE
[17:03:55.182]                       if (inherits(cond, "message")) {
[17:03:55.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.182]                         if (muffled) 
[17:03:55.182]                           invokeRestart("muffleMessage")
[17:03:55.182]                       }
[17:03:55.182]                       else if (inherits(cond, "warning")) {
[17:03:55.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.182]                         if (muffled) 
[17:03:55.182]                           invokeRestart("muffleWarning")
[17:03:55.182]                       }
[17:03:55.182]                       else if (inherits(cond, "condition")) {
[17:03:55.182]                         if (!is.null(pattern)) {
[17:03:55.182]                           computeRestarts <- base::computeRestarts
[17:03:55.182]                           grepl <- base::grepl
[17:03:55.182]                           restarts <- computeRestarts(cond)
[17:03:55.182]                           for (restart in restarts) {
[17:03:55.182]                             name <- restart$name
[17:03:55.182]                             if (is.null(name)) 
[17:03:55.182]                               next
[17:03:55.182]                             if (!grepl(pattern, name)) 
[17:03:55.182]                               next
[17:03:55.182]                             invokeRestart(restart)
[17:03:55.182]                             muffled <- TRUE
[17:03:55.182]                             break
[17:03:55.182]                           }
[17:03:55.182]                         }
[17:03:55.182]                       }
[17:03:55.182]                       invisible(muffled)
[17:03:55.182]                     }
[17:03:55.182]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.182]                   }
[17:03:55.182]                 }
[17:03:55.182]                 else {
[17:03:55.182]                   if (TRUE) {
[17:03:55.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.182]                     {
[17:03:55.182]                       inherits <- base::inherits
[17:03:55.182]                       invokeRestart <- base::invokeRestart
[17:03:55.182]                       is.null <- base::is.null
[17:03:55.182]                       muffled <- FALSE
[17:03:55.182]                       if (inherits(cond, "message")) {
[17:03:55.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.182]                         if (muffled) 
[17:03:55.182]                           invokeRestart("muffleMessage")
[17:03:55.182]                       }
[17:03:55.182]                       else if (inherits(cond, "warning")) {
[17:03:55.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.182]                         if (muffled) 
[17:03:55.182]                           invokeRestart("muffleWarning")
[17:03:55.182]                       }
[17:03:55.182]                       else if (inherits(cond, "condition")) {
[17:03:55.182]                         if (!is.null(pattern)) {
[17:03:55.182]                           computeRestarts <- base::computeRestarts
[17:03:55.182]                           grepl <- base::grepl
[17:03:55.182]                           restarts <- computeRestarts(cond)
[17:03:55.182]                           for (restart in restarts) {
[17:03:55.182]                             name <- restart$name
[17:03:55.182]                             if (is.null(name)) 
[17:03:55.182]                               next
[17:03:55.182]                             if (!grepl(pattern, name)) 
[17:03:55.182]                               next
[17:03:55.182]                             invokeRestart(restart)
[17:03:55.182]                             muffled <- TRUE
[17:03:55.182]                             break
[17:03:55.182]                           }
[17:03:55.182]                         }
[17:03:55.182]                       }
[17:03:55.182]                       invisible(muffled)
[17:03:55.182]                     }
[17:03:55.182]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.182]                   }
[17:03:55.182]                 }
[17:03:55.182]             }
[17:03:55.182]         }))
[17:03:55.182]     }, error = function(ex) {
[17:03:55.182]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.182]                 ...future.rng), started = ...future.startTime, 
[17:03:55.182]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.182]             version = "1.8"), class = "FutureResult")
[17:03:55.182]     }, finally = {
[17:03:55.182]         if (!identical(...future.workdir, getwd())) 
[17:03:55.182]             setwd(...future.workdir)
[17:03:55.182]         {
[17:03:55.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.182]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.182]             }
[17:03:55.182]             base::options(...future.oldOptions)
[17:03:55.182]             if (.Platform$OS.type == "windows") {
[17:03:55.182]                 old_names <- names(...future.oldEnvVars)
[17:03:55.182]                 envs <- base::Sys.getenv()
[17:03:55.182]                 names <- names(envs)
[17:03:55.182]                 common <- intersect(names, old_names)
[17:03:55.182]                 added <- setdiff(names, old_names)
[17:03:55.182]                 removed <- setdiff(old_names, names)
[17:03:55.182]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.182]                   envs[common]]
[17:03:55.182]                 NAMES <- toupper(changed)
[17:03:55.182]                 args <- list()
[17:03:55.182]                 for (kk in seq_along(NAMES)) {
[17:03:55.182]                   name <- changed[[kk]]
[17:03:55.182]                   NAME <- NAMES[[kk]]
[17:03:55.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.182]                     next
[17:03:55.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.182]                 }
[17:03:55.182]                 NAMES <- toupper(added)
[17:03:55.182]                 for (kk in seq_along(NAMES)) {
[17:03:55.182]                   name <- added[[kk]]
[17:03:55.182]                   NAME <- NAMES[[kk]]
[17:03:55.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.182]                     next
[17:03:55.182]                   args[[name]] <- ""
[17:03:55.182]                 }
[17:03:55.182]                 NAMES <- toupper(removed)
[17:03:55.182]                 for (kk in seq_along(NAMES)) {
[17:03:55.182]                   name <- removed[[kk]]
[17:03:55.182]                   NAME <- NAMES[[kk]]
[17:03:55.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.182]                     next
[17:03:55.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.182]                 }
[17:03:55.182]                 if (length(args) > 0) 
[17:03:55.182]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.182]             }
[17:03:55.182]             else {
[17:03:55.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.182]             }
[17:03:55.182]             {
[17:03:55.182]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.182]                   0L) {
[17:03:55.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.182]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.182]                   base::options(opts)
[17:03:55.182]                 }
[17:03:55.182]                 {
[17:03:55.182]                   {
[17:03:55.182]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.182]                     NULL
[17:03:55.182]                   }
[17:03:55.182]                   options(future.plan = NULL)
[17:03:55.182]                   if (is.na(NA_character_)) 
[17:03:55.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.182]                     .init = FALSE)
[17:03:55.182]                 }
[17:03:55.182]             }
[17:03:55.182]         }
[17:03:55.182]     })
[17:03:55.182]     if (TRUE) {
[17:03:55.182]         base::sink(type = "output", split = FALSE)
[17:03:55.182]         if (TRUE) {
[17:03:55.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.182]         }
[17:03:55.182]         else {
[17:03:55.182]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.182]         }
[17:03:55.182]         base::close(...future.stdout)
[17:03:55.182]         ...future.stdout <- NULL
[17:03:55.182]     }
[17:03:55.182]     ...future.result$conditions <- ...future.conditions
[17:03:55.182]     ...future.result$finished <- base::Sys.time()
[17:03:55.182]     ...future.result
[17:03:55.182] }
[17:03:55.185] MultisessionFuture started
[17:03:55.185] - Launch lazy future ... done
[17:03:55.185] run() for ‘MultisessionFuture’ ... done
[17:03:55.185] getGlobalsAndPackages() ...
[17:03:55.185] Searching for globals...
[17:03:55.186] 
[17:03:55.186] Searching for globals ... DONE
[17:03:55.186] - globals: [0] <none>
[17:03:55.186] getGlobalsAndPackages() ... DONE
[17:03:55.187] run() for ‘Future’ ...
[17:03:55.187] - state: ‘created’
[17:03:55.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.202]   - Field: ‘node’
[17:03:55.202]   - Field: ‘label’
[17:03:55.202]   - Field: ‘local’
[17:03:55.202]   - Field: ‘owner’
[17:03:55.202]   - Field: ‘envir’
[17:03:55.202]   - Field: ‘workers’
[17:03:55.202]   - Field: ‘packages’
[17:03:55.202]   - Field: ‘gc’
[17:03:55.202]   - Field: ‘conditions’
[17:03:55.203]   - Field: ‘persistent’
[17:03:55.203]   - Field: ‘expr’
[17:03:55.203]   - Field: ‘uuid’
[17:03:55.203]   - Field: ‘seed’
[17:03:55.203]   - Field: ‘version’
[17:03:55.203]   - Field: ‘result’
[17:03:55.203]   - Field: ‘asynchronous’
[17:03:55.203]   - Field: ‘calls’
[17:03:55.203]   - Field: ‘globals’
[17:03:55.203]   - Field: ‘stdout’
[17:03:55.203]   - Field: ‘earlySignal’
[17:03:55.204]   - Field: ‘lazy’
[17:03:55.204]   - Field: ‘state’
[17:03:55.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.204] - Launch lazy future ...
[17:03:55.204] Packages needed by the future expression (n = 0): <none>
[17:03:55.204] Packages needed by future strategies (n = 0): <none>
[17:03:55.205] {
[17:03:55.205]     {
[17:03:55.205]         {
[17:03:55.205]             ...future.startTime <- base::Sys.time()
[17:03:55.205]             {
[17:03:55.205]                 {
[17:03:55.205]                   {
[17:03:55.205]                     {
[17:03:55.205]                       base::local({
[17:03:55.205]                         has_future <- base::requireNamespace("future", 
[17:03:55.205]                           quietly = TRUE)
[17:03:55.205]                         if (has_future) {
[17:03:55.205]                           ns <- base::getNamespace("future")
[17:03:55.205]                           version <- ns[[".package"]][["version"]]
[17:03:55.205]                           if (is.null(version)) 
[17:03:55.205]                             version <- utils::packageVersion("future")
[17:03:55.205]                         }
[17:03:55.205]                         else {
[17:03:55.205]                           version <- NULL
[17:03:55.205]                         }
[17:03:55.205]                         if (!has_future || version < "1.8.0") {
[17:03:55.205]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.205]                             "", base::R.version$version.string), 
[17:03:55.205]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.205]                               "release", "version")], collapse = " "), 
[17:03:55.205]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.205]                             info)
[17:03:55.205]                           info <- base::paste(info, collapse = "; ")
[17:03:55.205]                           if (!has_future) {
[17:03:55.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.205]                               info)
[17:03:55.205]                           }
[17:03:55.205]                           else {
[17:03:55.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.205]                               info, version)
[17:03:55.205]                           }
[17:03:55.205]                           base::stop(msg)
[17:03:55.205]                         }
[17:03:55.205]                       })
[17:03:55.205]                     }
[17:03:55.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.205]                     base::options(mc.cores = 1L)
[17:03:55.205]                   }
[17:03:55.205]                   ...future.strategy.old <- future::plan("list")
[17:03:55.205]                   options(future.plan = NULL)
[17:03:55.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.205]                 }
[17:03:55.205]                 ...future.workdir <- getwd()
[17:03:55.205]             }
[17:03:55.205]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.205]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.205]         }
[17:03:55.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.205]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.205]             base::names(...future.oldOptions))
[17:03:55.205]     }
[17:03:55.205]     if (FALSE) {
[17:03:55.205]     }
[17:03:55.205]     else {
[17:03:55.205]         if (TRUE) {
[17:03:55.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.205]                 open = "w")
[17:03:55.205]         }
[17:03:55.205]         else {
[17:03:55.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.205]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.205]         }
[17:03:55.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.205]             base::sink(type = "output", split = FALSE)
[17:03:55.205]             base::close(...future.stdout)
[17:03:55.205]         }, add = TRUE)
[17:03:55.205]     }
[17:03:55.205]     ...future.frame <- base::sys.nframe()
[17:03:55.205]     ...future.conditions <- base::list()
[17:03:55.205]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.205]     if (FALSE) {
[17:03:55.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.205]     }
[17:03:55.205]     ...future.result <- base::tryCatch({
[17:03:55.205]         base::withCallingHandlers({
[17:03:55.205]             ...future.value <- base::withVisible(base::local({
[17:03:55.205]                 ...future.makeSendCondition <- base::local({
[17:03:55.205]                   sendCondition <- NULL
[17:03:55.205]                   function(frame = 1L) {
[17:03:55.205]                     if (is.function(sendCondition)) 
[17:03:55.205]                       return(sendCondition)
[17:03:55.205]                     ns <- getNamespace("parallel")
[17:03:55.205]                     if (exists("sendData", mode = "function", 
[17:03:55.205]                       envir = ns)) {
[17:03:55.205]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.205]                         envir = ns)
[17:03:55.205]                       envir <- sys.frame(frame)
[17:03:55.205]                       master <- NULL
[17:03:55.205]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.205]                         !identical(envir, emptyenv())) {
[17:03:55.205]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.205]                           inherits = FALSE)) {
[17:03:55.205]                           master <- get("master", mode = "list", 
[17:03:55.205]                             envir = envir, inherits = FALSE)
[17:03:55.205]                           if (inherits(master, c("SOCKnode", 
[17:03:55.205]                             "SOCK0node"))) {
[17:03:55.205]                             sendCondition <<- function(cond) {
[17:03:55.205]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.205]                                 success = TRUE)
[17:03:55.205]                               parallel_sendData(master, data)
[17:03:55.205]                             }
[17:03:55.205]                             return(sendCondition)
[17:03:55.205]                           }
[17:03:55.205]                         }
[17:03:55.205]                         frame <- frame + 1L
[17:03:55.205]                         envir <- sys.frame(frame)
[17:03:55.205]                       }
[17:03:55.205]                     }
[17:03:55.205]                     sendCondition <<- function(cond) NULL
[17:03:55.205]                   }
[17:03:55.205]                 })
[17:03:55.205]                 withCallingHandlers({
[17:03:55.205]                   2
[17:03:55.205]                 }, immediateCondition = function(cond) {
[17:03:55.205]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.205]                   sendCondition(cond)
[17:03:55.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.205]                   {
[17:03:55.205]                     inherits <- base::inherits
[17:03:55.205]                     invokeRestart <- base::invokeRestart
[17:03:55.205]                     is.null <- base::is.null
[17:03:55.205]                     muffled <- FALSE
[17:03:55.205]                     if (inherits(cond, "message")) {
[17:03:55.205]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.205]                       if (muffled) 
[17:03:55.205]                         invokeRestart("muffleMessage")
[17:03:55.205]                     }
[17:03:55.205]                     else if (inherits(cond, "warning")) {
[17:03:55.205]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.205]                       if (muffled) 
[17:03:55.205]                         invokeRestart("muffleWarning")
[17:03:55.205]                     }
[17:03:55.205]                     else if (inherits(cond, "condition")) {
[17:03:55.205]                       if (!is.null(pattern)) {
[17:03:55.205]                         computeRestarts <- base::computeRestarts
[17:03:55.205]                         grepl <- base::grepl
[17:03:55.205]                         restarts <- computeRestarts(cond)
[17:03:55.205]                         for (restart in restarts) {
[17:03:55.205]                           name <- restart$name
[17:03:55.205]                           if (is.null(name)) 
[17:03:55.205]                             next
[17:03:55.205]                           if (!grepl(pattern, name)) 
[17:03:55.205]                             next
[17:03:55.205]                           invokeRestart(restart)
[17:03:55.205]                           muffled <- TRUE
[17:03:55.205]                           break
[17:03:55.205]                         }
[17:03:55.205]                       }
[17:03:55.205]                     }
[17:03:55.205]                     invisible(muffled)
[17:03:55.205]                   }
[17:03:55.205]                   muffleCondition(cond)
[17:03:55.205]                 })
[17:03:55.205]             }))
[17:03:55.205]             future::FutureResult(value = ...future.value$value, 
[17:03:55.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.205]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.205]                     ...future.globalenv.names))
[17:03:55.205]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.205]         }, condition = base::local({
[17:03:55.205]             c <- base::c
[17:03:55.205]             inherits <- base::inherits
[17:03:55.205]             invokeRestart <- base::invokeRestart
[17:03:55.205]             length <- base::length
[17:03:55.205]             list <- base::list
[17:03:55.205]             seq.int <- base::seq.int
[17:03:55.205]             signalCondition <- base::signalCondition
[17:03:55.205]             sys.calls <- base::sys.calls
[17:03:55.205]             `[[` <- base::`[[`
[17:03:55.205]             `+` <- base::`+`
[17:03:55.205]             `<<-` <- base::`<<-`
[17:03:55.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.205]                   3L)]
[17:03:55.205]             }
[17:03:55.205]             function(cond) {
[17:03:55.205]                 is_error <- inherits(cond, "error")
[17:03:55.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.205]                   NULL)
[17:03:55.205]                 if (is_error) {
[17:03:55.205]                   sessionInformation <- function() {
[17:03:55.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.205]                       search = base::search(), system = base::Sys.info())
[17:03:55.205]                   }
[17:03:55.205]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.205]                     cond$call), session = sessionInformation(), 
[17:03:55.205]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.205]                   signalCondition(cond)
[17:03:55.205]                 }
[17:03:55.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.205]                 "immediateCondition"))) {
[17:03:55.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.205]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.205]                   if (TRUE && !signal) {
[17:03:55.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.205]                     {
[17:03:55.205]                       inherits <- base::inherits
[17:03:55.205]                       invokeRestart <- base::invokeRestart
[17:03:55.205]                       is.null <- base::is.null
[17:03:55.205]                       muffled <- FALSE
[17:03:55.205]                       if (inherits(cond, "message")) {
[17:03:55.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.205]                         if (muffled) 
[17:03:55.205]                           invokeRestart("muffleMessage")
[17:03:55.205]                       }
[17:03:55.205]                       else if (inherits(cond, "warning")) {
[17:03:55.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.205]                         if (muffled) 
[17:03:55.205]                           invokeRestart("muffleWarning")
[17:03:55.205]                       }
[17:03:55.205]                       else if (inherits(cond, "condition")) {
[17:03:55.205]                         if (!is.null(pattern)) {
[17:03:55.205]                           computeRestarts <- base::computeRestarts
[17:03:55.205]                           grepl <- base::grepl
[17:03:55.205]                           restarts <- computeRestarts(cond)
[17:03:55.205]                           for (restart in restarts) {
[17:03:55.205]                             name <- restart$name
[17:03:55.205]                             if (is.null(name)) 
[17:03:55.205]                               next
[17:03:55.205]                             if (!grepl(pattern, name)) 
[17:03:55.205]                               next
[17:03:55.205]                             invokeRestart(restart)
[17:03:55.205]                             muffled <- TRUE
[17:03:55.205]                             break
[17:03:55.205]                           }
[17:03:55.205]                         }
[17:03:55.205]                       }
[17:03:55.205]                       invisible(muffled)
[17:03:55.205]                     }
[17:03:55.205]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.205]                   }
[17:03:55.205]                 }
[17:03:55.205]                 else {
[17:03:55.205]                   if (TRUE) {
[17:03:55.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.205]                     {
[17:03:55.205]                       inherits <- base::inherits
[17:03:55.205]                       invokeRestart <- base::invokeRestart
[17:03:55.205]                       is.null <- base::is.null
[17:03:55.205]                       muffled <- FALSE
[17:03:55.205]                       if (inherits(cond, "message")) {
[17:03:55.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.205]                         if (muffled) 
[17:03:55.205]                           invokeRestart("muffleMessage")
[17:03:55.205]                       }
[17:03:55.205]                       else if (inherits(cond, "warning")) {
[17:03:55.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.205]                         if (muffled) 
[17:03:55.205]                           invokeRestart("muffleWarning")
[17:03:55.205]                       }
[17:03:55.205]                       else if (inherits(cond, "condition")) {
[17:03:55.205]                         if (!is.null(pattern)) {
[17:03:55.205]                           computeRestarts <- base::computeRestarts
[17:03:55.205]                           grepl <- base::grepl
[17:03:55.205]                           restarts <- computeRestarts(cond)
[17:03:55.205]                           for (restart in restarts) {
[17:03:55.205]                             name <- restart$name
[17:03:55.205]                             if (is.null(name)) 
[17:03:55.205]                               next
[17:03:55.205]                             if (!grepl(pattern, name)) 
[17:03:55.205]                               next
[17:03:55.205]                             invokeRestart(restart)
[17:03:55.205]                             muffled <- TRUE
[17:03:55.205]                             break
[17:03:55.205]                           }
[17:03:55.205]                         }
[17:03:55.205]                       }
[17:03:55.205]                       invisible(muffled)
[17:03:55.205]                     }
[17:03:55.205]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.205]                   }
[17:03:55.205]                 }
[17:03:55.205]             }
[17:03:55.205]         }))
[17:03:55.205]     }, error = function(ex) {
[17:03:55.205]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.205]                 ...future.rng), started = ...future.startTime, 
[17:03:55.205]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.205]             version = "1.8"), class = "FutureResult")
[17:03:55.205]     }, finally = {
[17:03:55.205]         if (!identical(...future.workdir, getwd())) 
[17:03:55.205]             setwd(...future.workdir)
[17:03:55.205]         {
[17:03:55.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.205]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.205]             }
[17:03:55.205]             base::options(...future.oldOptions)
[17:03:55.205]             if (.Platform$OS.type == "windows") {
[17:03:55.205]                 old_names <- names(...future.oldEnvVars)
[17:03:55.205]                 envs <- base::Sys.getenv()
[17:03:55.205]                 names <- names(envs)
[17:03:55.205]                 common <- intersect(names, old_names)
[17:03:55.205]                 added <- setdiff(names, old_names)
[17:03:55.205]                 removed <- setdiff(old_names, names)
[17:03:55.205]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.205]                   envs[common]]
[17:03:55.205]                 NAMES <- toupper(changed)
[17:03:55.205]                 args <- list()
[17:03:55.205]                 for (kk in seq_along(NAMES)) {
[17:03:55.205]                   name <- changed[[kk]]
[17:03:55.205]                   NAME <- NAMES[[kk]]
[17:03:55.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.205]                     next
[17:03:55.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.205]                 }
[17:03:55.205]                 NAMES <- toupper(added)
[17:03:55.205]                 for (kk in seq_along(NAMES)) {
[17:03:55.205]                   name <- added[[kk]]
[17:03:55.205]                   NAME <- NAMES[[kk]]
[17:03:55.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.205]                     next
[17:03:55.205]                   args[[name]] <- ""
[17:03:55.205]                 }
[17:03:55.205]                 NAMES <- toupper(removed)
[17:03:55.205]                 for (kk in seq_along(NAMES)) {
[17:03:55.205]                   name <- removed[[kk]]
[17:03:55.205]                   NAME <- NAMES[[kk]]
[17:03:55.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.205]                     next
[17:03:55.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.205]                 }
[17:03:55.205]                 if (length(args) > 0) 
[17:03:55.205]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.205]             }
[17:03:55.205]             else {
[17:03:55.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.205]             }
[17:03:55.205]             {
[17:03:55.205]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.205]                   0L) {
[17:03:55.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.205]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.205]                   base::options(opts)
[17:03:55.205]                 }
[17:03:55.205]                 {
[17:03:55.205]                   {
[17:03:55.205]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.205]                     NULL
[17:03:55.205]                   }
[17:03:55.205]                   options(future.plan = NULL)
[17:03:55.205]                   if (is.na(NA_character_)) 
[17:03:55.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.205]                     .init = FALSE)
[17:03:55.205]                 }
[17:03:55.205]             }
[17:03:55.205]         }
[17:03:55.205]     })
[17:03:55.205]     if (TRUE) {
[17:03:55.205]         base::sink(type = "output", split = FALSE)
[17:03:55.205]         if (TRUE) {
[17:03:55.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.205]         }
[17:03:55.205]         else {
[17:03:55.205]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.205]         }
[17:03:55.205]         base::close(...future.stdout)
[17:03:55.205]         ...future.stdout <- NULL
[17:03:55.205]     }
[17:03:55.205]     ...future.result$conditions <- ...future.conditions
[17:03:55.205]     ...future.result$finished <- base::Sys.time()
[17:03:55.205]     ...future.result
[17:03:55.205] }
[17:03:55.207] Poll #1 (0): usedNodes() = 2, workers = 2
[17:03:55.217] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.218] - Validating connection of MultisessionFuture
[17:03:55.218] - received message: FutureResult
[17:03:55.218] - Received FutureResult
[17:03:55.218] - Erased future from FutureRegistry
[17:03:55.218] result() for ClusterFuture ...
[17:03:55.218] - result already collected: FutureResult
[17:03:55.218] result() for ClusterFuture ... done
[17:03:55.218] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.219] result() for ClusterFuture ...
[17:03:55.219] - result already collected: FutureResult
[17:03:55.219] result() for ClusterFuture ... done
[17:03:55.219] result() for ClusterFuture ...
[17:03:55.219] - result already collected: FutureResult
[17:03:55.219] result() for ClusterFuture ... done
[17:03:55.220] MultisessionFuture started
[17:03:55.220] - Launch lazy future ... done
[17:03:55.220] run() for ‘MultisessionFuture’ ... done
[17:03:55.220] resolve() on list ...
[17:03:55.220]  recursive: 0
[17:03:55.220]  length: 3
[17:03:55.221]  elements: ‘a’, ‘b’, ‘’
[17:03:55.221] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.221] - Validating connection of MultisessionFuture
[17:03:55.221] - received message: FutureResult
[17:03:55.221] - Received FutureResult
[17:03:55.221] - Erased future from FutureRegistry
[17:03:55.222] result() for ClusterFuture ...
[17:03:55.222] - result already collected: FutureResult
[17:03:55.222] result() for ClusterFuture ... done
[17:03:55.222] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.222] Future #1
[17:03:55.222]  length: 2 (resolved future 1)
[17:03:55.222] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.223] - Validating connection of MultisessionFuture
[17:03:55.223] - received message: FutureResult
[17:03:55.223] - Received FutureResult
[17:03:55.223] - Erased future from FutureRegistry
[17:03:55.223] result() for ClusterFuture ...
[17:03:55.223] - result already collected: FutureResult
[17:03:55.223] result() for ClusterFuture ... done
[17:03:55.223] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.223] Future #2
[17:03:55.223]  length: 1 (resolved future 2)
[17:03:55.224]  length: 0 (resolved future 3)
[17:03:55.224] resolve() on list ... DONE
[17:03:55.224] getGlobalsAndPackages() ...
[17:03:55.224] Searching for globals...
[17:03:55.224] 
[17:03:55.224] Searching for globals ... DONE
[17:03:55.224] - globals: [0] <none>
[17:03:55.224] getGlobalsAndPackages() ... DONE
[17:03:55.225] getGlobalsAndPackages() ...
[17:03:55.225] Searching for globals...
[17:03:55.225] 
[17:03:55.225] Searching for globals ... DONE
[17:03:55.225] - globals: [0] <none>
[17:03:55.225] getGlobalsAndPackages() ... DONE
[17:03:55.225] run() for ‘Future’ ...
[17:03:55.226] - state: ‘created’
[17:03:55.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.240]   - Field: ‘node’
[17:03:55.240]   - Field: ‘label’
[17:03:55.240]   - Field: ‘local’
[17:03:55.240]   - Field: ‘owner’
[17:03:55.240]   - Field: ‘envir’
[17:03:55.240]   - Field: ‘workers’
[17:03:55.241]   - Field: ‘packages’
[17:03:55.241]   - Field: ‘gc’
[17:03:55.241]   - Field: ‘conditions’
[17:03:55.241]   - Field: ‘persistent’
[17:03:55.241]   - Field: ‘expr’
[17:03:55.241]   - Field: ‘uuid’
[17:03:55.241]   - Field: ‘seed’
[17:03:55.241]   - Field: ‘version’
[17:03:55.241]   - Field: ‘result’
[17:03:55.241]   - Field: ‘asynchronous’
[17:03:55.241]   - Field: ‘calls’
[17:03:55.241]   - Field: ‘globals’
[17:03:55.242]   - Field: ‘stdout’
[17:03:55.242]   - Field: ‘earlySignal’
[17:03:55.242]   - Field: ‘lazy’
[17:03:55.242]   - Field: ‘state’
[17:03:55.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.242] - Launch lazy future ...
[17:03:55.242] Packages needed by the future expression (n = 0): <none>
[17:03:55.242] Packages needed by future strategies (n = 0): <none>
[17:03:55.243] {
[17:03:55.243]     {
[17:03:55.243]         {
[17:03:55.243]             ...future.startTime <- base::Sys.time()
[17:03:55.243]             {
[17:03:55.243]                 {
[17:03:55.243]                   {
[17:03:55.243]                     {
[17:03:55.243]                       base::local({
[17:03:55.243]                         has_future <- base::requireNamespace("future", 
[17:03:55.243]                           quietly = TRUE)
[17:03:55.243]                         if (has_future) {
[17:03:55.243]                           ns <- base::getNamespace("future")
[17:03:55.243]                           version <- ns[[".package"]][["version"]]
[17:03:55.243]                           if (is.null(version)) 
[17:03:55.243]                             version <- utils::packageVersion("future")
[17:03:55.243]                         }
[17:03:55.243]                         else {
[17:03:55.243]                           version <- NULL
[17:03:55.243]                         }
[17:03:55.243]                         if (!has_future || version < "1.8.0") {
[17:03:55.243]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.243]                             "", base::R.version$version.string), 
[17:03:55.243]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.243]                               "release", "version")], collapse = " "), 
[17:03:55.243]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.243]                             info)
[17:03:55.243]                           info <- base::paste(info, collapse = "; ")
[17:03:55.243]                           if (!has_future) {
[17:03:55.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.243]                               info)
[17:03:55.243]                           }
[17:03:55.243]                           else {
[17:03:55.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.243]                               info, version)
[17:03:55.243]                           }
[17:03:55.243]                           base::stop(msg)
[17:03:55.243]                         }
[17:03:55.243]                       })
[17:03:55.243]                     }
[17:03:55.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.243]                     base::options(mc.cores = 1L)
[17:03:55.243]                   }
[17:03:55.243]                   ...future.strategy.old <- future::plan("list")
[17:03:55.243]                   options(future.plan = NULL)
[17:03:55.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.243]                 }
[17:03:55.243]                 ...future.workdir <- getwd()
[17:03:55.243]             }
[17:03:55.243]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.243]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.243]         }
[17:03:55.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.243]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.243]             base::names(...future.oldOptions))
[17:03:55.243]     }
[17:03:55.243]     if (FALSE) {
[17:03:55.243]     }
[17:03:55.243]     else {
[17:03:55.243]         if (TRUE) {
[17:03:55.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.243]                 open = "w")
[17:03:55.243]         }
[17:03:55.243]         else {
[17:03:55.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.243]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.243]         }
[17:03:55.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.243]             base::sink(type = "output", split = FALSE)
[17:03:55.243]             base::close(...future.stdout)
[17:03:55.243]         }, add = TRUE)
[17:03:55.243]     }
[17:03:55.243]     ...future.frame <- base::sys.nframe()
[17:03:55.243]     ...future.conditions <- base::list()
[17:03:55.243]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.243]     if (FALSE) {
[17:03:55.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.243]     }
[17:03:55.243]     ...future.result <- base::tryCatch({
[17:03:55.243]         base::withCallingHandlers({
[17:03:55.243]             ...future.value <- base::withVisible(base::local({
[17:03:55.243]                 ...future.makeSendCondition <- base::local({
[17:03:55.243]                   sendCondition <- NULL
[17:03:55.243]                   function(frame = 1L) {
[17:03:55.243]                     if (is.function(sendCondition)) 
[17:03:55.243]                       return(sendCondition)
[17:03:55.243]                     ns <- getNamespace("parallel")
[17:03:55.243]                     if (exists("sendData", mode = "function", 
[17:03:55.243]                       envir = ns)) {
[17:03:55.243]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.243]                         envir = ns)
[17:03:55.243]                       envir <- sys.frame(frame)
[17:03:55.243]                       master <- NULL
[17:03:55.243]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.243]                         !identical(envir, emptyenv())) {
[17:03:55.243]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.243]                           inherits = FALSE)) {
[17:03:55.243]                           master <- get("master", mode = "list", 
[17:03:55.243]                             envir = envir, inherits = FALSE)
[17:03:55.243]                           if (inherits(master, c("SOCKnode", 
[17:03:55.243]                             "SOCK0node"))) {
[17:03:55.243]                             sendCondition <<- function(cond) {
[17:03:55.243]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.243]                                 success = TRUE)
[17:03:55.243]                               parallel_sendData(master, data)
[17:03:55.243]                             }
[17:03:55.243]                             return(sendCondition)
[17:03:55.243]                           }
[17:03:55.243]                         }
[17:03:55.243]                         frame <- frame + 1L
[17:03:55.243]                         envir <- sys.frame(frame)
[17:03:55.243]                       }
[17:03:55.243]                     }
[17:03:55.243]                     sendCondition <<- function(cond) NULL
[17:03:55.243]                   }
[17:03:55.243]                 })
[17:03:55.243]                 withCallingHandlers({
[17:03:55.243]                   2
[17:03:55.243]                 }, immediateCondition = function(cond) {
[17:03:55.243]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.243]                   sendCondition(cond)
[17:03:55.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.243]                   {
[17:03:55.243]                     inherits <- base::inherits
[17:03:55.243]                     invokeRestart <- base::invokeRestart
[17:03:55.243]                     is.null <- base::is.null
[17:03:55.243]                     muffled <- FALSE
[17:03:55.243]                     if (inherits(cond, "message")) {
[17:03:55.243]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.243]                       if (muffled) 
[17:03:55.243]                         invokeRestart("muffleMessage")
[17:03:55.243]                     }
[17:03:55.243]                     else if (inherits(cond, "warning")) {
[17:03:55.243]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.243]                       if (muffled) 
[17:03:55.243]                         invokeRestart("muffleWarning")
[17:03:55.243]                     }
[17:03:55.243]                     else if (inherits(cond, "condition")) {
[17:03:55.243]                       if (!is.null(pattern)) {
[17:03:55.243]                         computeRestarts <- base::computeRestarts
[17:03:55.243]                         grepl <- base::grepl
[17:03:55.243]                         restarts <- computeRestarts(cond)
[17:03:55.243]                         for (restart in restarts) {
[17:03:55.243]                           name <- restart$name
[17:03:55.243]                           if (is.null(name)) 
[17:03:55.243]                             next
[17:03:55.243]                           if (!grepl(pattern, name)) 
[17:03:55.243]                             next
[17:03:55.243]                           invokeRestart(restart)
[17:03:55.243]                           muffled <- TRUE
[17:03:55.243]                           break
[17:03:55.243]                         }
[17:03:55.243]                       }
[17:03:55.243]                     }
[17:03:55.243]                     invisible(muffled)
[17:03:55.243]                   }
[17:03:55.243]                   muffleCondition(cond)
[17:03:55.243]                 })
[17:03:55.243]             }))
[17:03:55.243]             future::FutureResult(value = ...future.value$value, 
[17:03:55.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.243]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.243]                     ...future.globalenv.names))
[17:03:55.243]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.243]         }, condition = base::local({
[17:03:55.243]             c <- base::c
[17:03:55.243]             inherits <- base::inherits
[17:03:55.243]             invokeRestart <- base::invokeRestart
[17:03:55.243]             length <- base::length
[17:03:55.243]             list <- base::list
[17:03:55.243]             seq.int <- base::seq.int
[17:03:55.243]             signalCondition <- base::signalCondition
[17:03:55.243]             sys.calls <- base::sys.calls
[17:03:55.243]             `[[` <- base::`[[`
[17:03:55.243]             `+` <- base::`+`
[17:03:55.243]             `<<-` <- base::`<<-`
[17:03:55.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.243]                   3L)]
[17:03:55.243]             }
[17:03:55.243]             function(cond) {
[17:03:55.243]                 is_error <- inherits(cond, "error")
[17:03:55.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.243]                   NULL)
[17:03:55.243]                 if (is_error) {
[17:03:55.243]                   sessionInformation <- function() {
[17:03:55.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.243]                       search = base::search(), system = base::Sys.info())
[17:03:55.243]                   }
[17:03:55.243]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.243]                     cond$call), session = sessionInformation(), 
[17:03:55.243]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.243]                   signalCondition(cond)
[17:03:55.243]                 }
[17:03:55.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.243]                 "immediateCondition"))) {
[17:03:55.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.243]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.243]                   if (TRUE && !signal) {
[17:03:55.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.243]                     {
[17:03:55.243]                       inherits <- base::inherits
[17:03:55.243]                       invokeRestart <- base::invokeRestart
[17:03:55.243]                       is.null <- base::is.null
[17:03:55.243]                       muffled <- FALSE
[17:03:55.243]                       if (inherits(cond, "message")) {
[17:03:55.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.243]                         if (muffled) 
[17:03:55.243]                           invokeRestart("muffleMessage")
[17:03:55.243]                       }
[17:03:55.243]                       else if (inherits(cond, "warning")) {
[17:03:55.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.243]                         if (muffled) 
[17:03:55.243]                           invokeRestart("muffleWarning")
[17:03:55.243]                       }
[17:03:55.243]                       else if (inherits(cond, "condition")) {
[17:03:55.243]                         if (!is.null(pattern)) {
[17:03:55.243]                           computeRestarts <- base::computeRestarts
[17:03:55.243]                           grepl <- base::grepl
[17:03:55.243]                           restarts <- computeRestarts(cond)
[17:03:55.243]                           for (restart in restarts) {
[17:03:55.243]                             name <- restart$name
[17:03:55.243]                             if (is.null(name)) 
[17:03:55.243]                               next
[17:03:55.243]                             if (!grepl(pattern, name)) 
[17:03:55.243]                               next
[17:03:55.243]                             invokeRestart(restart)
[17:03:55.243]                             muffled <- TRUE
[17:03:55.243]                             break
[17:03:55.243]                           }
[17:03:55.243]                         }
[17:03:55.243]                       }
[17:03:55.243]                       invisible(muffled)
[17:03:55.243]                     }
[17:03:55.243]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.243]                   }
[17:03:55.243]                 }
[17:03:55.243]                 else {
[17:03:55.243]                   if (TRUE) {
[17:03:55.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.243]                     {
[17:03:55.243]                       inherits <- base::inherits
[17:03:55.243]                       invokeRestart <- base::invokeRestart
[17:03:55.243]                       is.null <- base::is.null
[17:03:55.243]                       muffled <- FALSE
[17:03:55.243]                       if (inherits(cond, "message")) {
[17:03:55.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.243]                         if (muffled) 
[17:03:55.243]                           invokeRestart("muffleMessage")
[17:03:55.243]                       }
[17:03:55.243]                       else if (inherits(cond, "warning")) {
[17:03:55.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.243]                         if (muffled) 
[17:03:55.243]                           invokeRestart("muffleWarning")
[17:03:55.243]                       }
[17:03:55.243]                       else if (inherits(cond, "condition")) {
[17:03:55.243]                         if (!is.null(pattern)) {
[17:03:55.243]                           computeRestarts <- base::computeRestarts
[17:03:55.243]                           grepl <- base::grepl
[17:03:55.243]                           restarts <- computeRestarts(cond)
[17:03:55.243]                           for (restart in restarts) {
[17:03:55.243]                             name <- restart$name
[17:03:55.243]                             if (is.null(name)) 
[17:03:55.243]                               next
[17:03:55.243]                             if (!grepl(pattern, name)) 
[17:03:55.243]                               next
[17:03:55.243]                             invokeRestart(restart)
[17:03:55.243]                             muffled <- TRUE
[17:03:55.243]                             break
[17:03:55.243]                           }
[17:03:55.243]                         }
[17:03:55.243]                       }
[17:03:55.243]                       invisible(muffled)
[17:03:55.243]                     }
[17:03:55.243]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.243]                   }
[17:03:55.243]                 }
[17:03:55.243]             }
[17:03:55.243]         }))
[17:03:55.243]     }, error = function(ex) {
[17:03:55.243]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.243]                 ...future.rng), started = ...future.startTime, 
[17:03:55.243]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.243]             version = "1.8"), class = "FutureResult")
[17:03:55.243]     }, finally = {
[17:03:55.243]         if (!identical(...future.workdir, getwd())) 
[17:03:55.243]             setwd(...future.workdir)
[17:03:55.243]         {
[17:03:55.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.243]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.243]             }
[17:03:55.243]             base::options(...future.oldOptions)
[17:03:55.243]             if (.Platform$OS.type == "windows") {
[17:03:55.243]                 old_names <- names(...future.oldEnvVars)
[17:03:55.243]                 envs <- base::Sys.getenv()
[17:03:55.243]                 names <- names(envs)
[17:03:55.243]                 common <- intersect(names, old_names)
[17:03:55.243]                 added <- setdiff(names, old_names)
[17:03:55.243]                 removed <- setdiff(old_names, names)
[17:03:55.243]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.243]                   envs[common]]
[17:03:55.243]                 NAMES <- toupper(changed)
[17:03:55.243]                 args <- list()
[17:03:55.243]                 for (kk in seq_along(NAMES)) {
[17:03:55.243]                   name <- changed[[kk]]
[17:03:55.243]                   NAME <- NAMES[[kk]]
[17:03:55.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.243]                     next
[17:03:55.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.243]                 }
[17:03:55.243]                 NAMES <- toupper(added)
[17:03:55.243]                 for (kk in seq_along(NAMES)) {
[17:03:55.243]                   name <- added[[kk]]
[17:03:55.243]                   NAME <- NAMES[[kk]]
[17:03:55.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.243]                     next
[17:03:55.243]                   args[[name]] <- ""
[17:03:55.243]                 }
[17:03:55.243]                 NAMES <- toupper(removed)
[17:03:55.243]                 for (kk in seq_along(NAMES)) {
[17:03:55.243]                   name <- removed[[kk]]
[17:03:55.243]                   NAME <- NAMES[[kk]]
[17:03:55.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.243]                     next
[17:03:55.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.243]                 }
[17:03:55.243]                 if (length(args) > 0) 
[17:03:55.243]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.243]             }
[17:03:55.243]             else {
[17:03:55.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.243]             }
[17:03:55.243]             {
[17:03:55.243]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.243]                   0L) {
[17:03:55.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.243]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.243]                   base::options(opts)
[17:03:55.243]                 }
[17:03:55.243]                 {
[17:03:55.243]                   {
[17:03:55.243]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.243]                     NULL
[17:03:55.243]                   }
[17:03:55.243]                   options(future.plan = NULL)
[17:03:55.243]                   if (is.na(NA_character_)) 
[17:03:55.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.243]                     .init = FALSE)
[17:03:55.243]                 }
[17:03:55.243]             }
[17:03:55.243]         }
[17:03:55.243]     })
[17:03:55.243]     if (TRUE) {
[17:03:55.243]         base::sink(type = "output", split = FALSE)
[17:03:55.243]         if (TRUE) {
[17:03:55.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.243]         }
[17:03:55.243]         else {
[17:03:55.243]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.243]         }
[17:03:55.243]         base::close(...future.stdout)
[17:03:55.243]         ...future.stdout <- NULL
[17:03:55.243]     }
[17:03:55.243]     ...future.result$conditions <- ...future.conditions
[17:03:55.243]     ...future.result$finished <- base::Sys.time()
[17:03:55.243]     ...future.result
[17:03:55.243] }
[17:03:55.246] MultisessionFuture started
[17:03:55.246] - Launch lazy future ... done
[17:03:55.246] run() for ‘MultisessionFuture’ ... done
[17:03:55.246] resolve() on list ...
[17:03:55.246]  recursive: 0
[17:03:55.246]  length: 3
[17:03:55.246]  elements: ‘a’, ‘b’, ‘’
[17:03:55.247] run() for ‘Future’ ...
[17:03:55.247] - state: ‘created’
[17:03:55.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.262]   - Field: ‘node’
[17:03:55.262]   - Field: ‘label’
[17:03:55.262]   - Field: ‘local’
[17:03:55.262]   - Field: ‘owner’
[17:03:55.262]   - Field: ‘envir’
[17:03:55.262]   - Field: ‘workers’
[17:03:55.262]   - Field: ‘packages’
[17:03:55.262]   - Field: ‘gc’
[17:03:55.262]   - Field: ‘conditions’
[17:03:55.262]   - Field: ‘persistent’
[17:03:55.262]   - Field: ‘expr’
[17:03:55.263]   - Field: ‘uuid’
[17:03:55.263]   - Field: ‘seed’
[17:03:55.263]   - Field: ‘version’
[17:03:55.263]   - Field: ‘result’
[17:03:55.263]   - Field: ‘asynchronous’
[17:03:55.263]   - Field: ‘calls’
[17:03:55.263]   - Field: ‘globals’
[17:03:55.263]   - Field: ‘stdout’
[17:03:55.263]   - Field: ‘earlySignal’
[17:03:55.263]   - Field: ‘lazy’
[17:03:55.264]   - Field: ‘state’
[17:03:55.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.264] - Launch lazy future ...
[17:03:55.264] Packages needed by the future expression (n = 0): <none>
[17:03:55.264] Packages needed by future strategies (n = 0): <none>
[17:03:55.265] {
[17:03:55.265]     {
[17:03:55.265]         {
[17:03:55.265]             ...future.startTime <- base::Sys.time()
[17:03:55.265]             {
[17:03:55.265]                 {
[17:03:55.265]                   {
[17:03:55.265]                     {
[17:03:55.265]                       base::local({
[17:03:55.265]                         has_future <- base::requireNamespace("future", 
[17:03:55.265]                           quietly = TRUE)
[17:03:55.265]                         if (has_future) {
[17:03:55.265]                           ns <- base::getNamespace("future")
[17:03:55.265]                           version <- ns[[".package"]][["version"]]
[17:03:55.265]                           if (is.null(version)) 
[17:03:55.265]                             version <- utils::packageVersion("future")
[17:03:55.265]                         }
[17:03:55.265]                         else {
[17:03:55.265]                           version <- NULL
[17:03:55.265]                         }
[17:03:55.265]                         if (!has_future || version < "1.8.0") {
[17:03:55.265]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.265]                             "", base::R.version$version.string), 
[17:03:55.265]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.265]                               "release", "version")], collapse = " "), 
[17:03:55.265]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.265]                             info)
[17:03:55.265]                           info <- base::paste(info, collapse = "; ")
[17:03:55.265]                           if (!has_future) {
[17:03:55.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.265]                               info)
[17:03:55.265]                           }
[17:03:55.265]                           else {
[17:03:55.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.265]                               info, version)
[17:03:55.265]                           }
[17:03:55.265]                           base::stop(msg)
[17:03:55.265]                         }
[17:03:55.265]                       })
[17:03:55.265]                     }
[17:03:55.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.265]                     base::options(mc.cores = 1L)
[17:03:55.265]                   }
[17:03:55.265]                   ...future.strategy.old <- future::plan("list")
[17:03:55.265]                   options(future.plan = NULL)
[17:03:55.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.265]                 }
[17:03:55.265]                 ...future.workdir <- getwd()
[17:03:55.265]             }
[17:03:55.265]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.265]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.265]         }
[17:03:55.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.265]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.265]             base::names(...future.oldOptions))
[17:03:55.265]     }
[17:03:55.265]     if (FALSE) {
[17:03:55.265]     }
[17:03:55.265]     else {
[17:03:55.265]         if (TRUE) {
[17:03:55.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.265]                 open = "w")
[17:03:55.265]         }
[17:03:55.265]         else {
[17:03:55.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.265]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.265]         }
[17:03:55.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.265]             base::sink(type = "output", split = FALSE)
[17:03:55.265]             base::close(...future.stdout)
[17:03:55.265]         }, add = TRUE)
[17:03:55.265]     }
[17:03:55.265]     ...future.frame <- base::sys.nframe()
[17:03:55.265]     ...future.conditions <- base::list()
[17:03:55.265]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.265]     if (FALSE) {
[17:03:55.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.265]     }
[17:03:55.265]     ...future.result <- base::tryCatch({
[17:03:55.265]         base::withCallingHandlers({
[17:03:55.265]             ...future.value <- base::withVisible(base::local({
[17:03:55.265]                 ...future.makeSendCondition <- base::local({
[17:03:55.265]                   sendCondition <- NULL
[17:03:55.265]                   function(frame = 1L) {
[17:03:55.265]                     if (is.function(sendCondition)) 
[17:03:55.265]                       return(sendCondition)
[17:03:55.265]                     ns <- getNamespace("parallel")
[17:03:55.265]                     if (exists("sendData", mode = "function", 
[17:03:55.265]                       envir = ns)) {
[17:03:55.265]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.265]                         envir = ns)
[17:03:55.265]                       envir <- sys.frame(frame)
[17:03:55.265]                       master <- NULL
[17:03:55.265]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.265]                         !identical(envir, emptyenv())) {
[17:03:55.265]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.265]                           inherits = FALSE)) {
[17:03:55.265]                           master <- get("master", mode = "list", 
[17:03:55.265]                             envir = envir, inherits = FALSE)
[17:03:55.265]                           if (inherits(master, c("SOCKnode", 
[17:03:55.265]                             "SOCK0node"))) {
[17:03:55.265]                             sendCondition <<- function(cond) {
[17:03:55.265]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.265]                                 success = TRUE)
[17:03:55.265]                               parallel_sendData(master, data)
[17:03:55.265]                             }
[17:03:55.265]                             return(sendCondition)
[17:03:55.265]                           }
[17:03:55.265]                         }
[17:03:55.265]                         frame <- frame + 1L
[17:03:55.265]                         envir <- sys.frame(frame)
[17:03:55.265]                       }
[17:03:55.265]                     }
[17:03:55.265]                     sendCondition <<- function(cond) NULL
[17:03:55.265]                   }
[17:03:55.265]                 })
[17:03:55.265]                 withCallingHandlers({
[17:03:55.265]                   1
[17:03:55.265]                 }, immediateCondition = function(cond) {
[17:03:55.265]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.265]                   sendCondition(cond)
[17:03:55.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.265]                   {
[17:03:55.265]                     inherits <- base::inherits
[17:03:55.265]                     invokeRestart <- base::invokeRestart
[17:03:55.265]                     is.null <- base::is.null
[17:03:55.265]                     muffled <- FALSE
[17:03:55.265]                     if (inherits(cond, "message")) {
[17:03:55.265]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.265]                       if (muffled) 
[17:03:55.265]                         invokeRestart("muffleMessage")
[17:03:55.265]                     }
[17:03:55.265]                     else if (inherits(cond, "warning")) {
[17:03:55.265]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.265]                       if (muffled) 
[17:03:55.265]                         invokeRestart("muffleWarning")
[17:03:55.265]                     }
[17:03:55.265]                     else if (inherits(cond, "condition")) {
[17:03:55.265]                       if (!is.null(pattern)) {
[17:03:55.265]                         computeRestarts <- base::computeRestarts
[17:03:55.265]                         grepl <- base::grepl
[17:03:55.265]                         restarts <- computeRestarts(cond)
[17:03:55.265]                         for (restart in restarts) {
[17:03:55.265]                           name <- restart$name
[17:03:55.265]                           if (is.null(name)) 
[17:03:55.265]                             next
[17:03:55.265]                           if (!grepl(pattern, name)) 
[17:03:55.265]                             next
[17:03:55.265]                           invokeRestart(restart)
[17:03:55.265]                           muffled <- TRUE
[17:03:55.265]                           break
[17:03:55.265]                         }
[17:03:55.265]                       }
[17:03:55.265]                     }
[17:03:55.265]                     invisible(muffled)
[17:03:55.265]                   }
[17:03:55.265]                   muffleCondition(cond)
[17:03:55.265]                 })
[17:03:55.265]             }))
[17:03:55.265]             future::FutureResult(value = ...future.value$value, 
[17:03:55.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.265]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.265]                     ...future.globalenv.names))
[17:03:55.265]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.265]         }, condition = base::local({
[17:03:55.265]             c <- base::c
[17:03:55.265]             inherits <- base::inherits
[17:03:55.265]             invokeRestart <- base::invokeRestart
[17:03:55.265]             length <- base::length
[17:03:55.265]             list <- base::list
[17:03:55.265]             seq.int <- base::seq.int
[17:03:55.265]             signalCondition <- base::signalCondition
[17:03:55.265]             sys.calls <- base::sys.calls
[17:03:55.265]             `[[` <- base::`[[`
[17:03:55.265]             `+` <- base::`+`
[17:03:55.265]             `<<-` <- base::`<<-`
[17:03:55.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.265]                   3L)]
[17:03:55.265]             }
[17:03:55.265]             function(cond) {
[17:03:55.265]                 is_error <- inherits(cond, "error")
[17:03:55.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.265]                   NULL)
[17:03:55.265]                 if (is_error) {
[17:03:55.265]                   sessionInformation <- function() {
[17:03:55.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.265]                       search = base::search(), system = base::Sys.info())
[17:03:55.265]                   }
[17:03:55.265]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.265]                     cond$call), session = sessionInformation(), 
[17:03:55.265]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.265]                   signalCondition(cond)
[17:03:55.265]                 }
[17:03:55.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.265]                 "immediateCondition"))) {
[17:03:55.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.265]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.265]                   if (TRUE && !signal) {
[17:03:55.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.265]                     {
[17:03:55.265]                       inherits <- base::inherits
[17:03:55.265]                       invokeRestart <- base::invokeRestart
[17:03:55.265]                       is.null <- base::is.null
[17:03:55.265]                       muffled <- FALSE
[17:03:55.265]                       if (inherits(cond, "message")) {
[17:03:55.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.265]                         if (muffled) 
[17:03:55.265]                           invokeRestart("muffleMessage")
[17:03:55.265]                       }
[17:03:55.265]                       else if (inherits(cond, "warning")) {
[17:03:55.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.265]                         if (muffled) 
[17:03:55.265]                           invokeRestart("muffleWarning")
[17:03:55.265]                       }
[17:03:55.265]                       else if (inherits(cond, "condition")) {
[17:03:55.265]                         if (!is.null(pattern)) {
[17:03:55.265]                           computeRestarts <- base::computeRestarts
[17:03:55.265]                           grepl <- base::grepl
[17:03:55.265]                           restarts <- computeRestarts(cond)
[17:03:55.265]                           for (restart in restarts) {
[17:03:55.265]                             name <- restart$name
[17:03:55.265]                             if (is.null(name)) 
[17:03:55.265]                               next
[17:03:55.265]                             if (!grepl(pattern, name)) 
[17:03:55.265]                               next
[17:03:55.265]                             invokeRestart(restart)
[17:03:55.265]                             muffled <- TRUE
[17:03:55.265]                             break
[17:03:55.265]                           }
[17:03:55.265]                         }
[17:03:55.265]                       }
[17:03:55.265]                       invisible(muffled)
[17:03:55.265]                     }
[17:03:55.265]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.265]                   }
[17:03:55.265]                 }
[17:03:55.265]                 else {
[17:03:55.265]                   if (TRUE) {
[17:03:55.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.265]                     {
[17:03:55.265]                       inherits <- base::inherits
[17:03:55.265]                       invokeRestart <- base::invokeRestart
[17:03:55.265]                       is.null <- base::is.null
[17:03:55.265]                       muffled <- FALSE
[17:03:55.265]                       if (inherits(cond, "message")) {
[17:03:55.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.265]                         if (muffled) 
[17:03:55.265]                           invokeRestart("muffleMessage")
[17:03:55.265]                       }
[17:03:55.265]                       else if (inherits(cond, "warning")) {
[17:03:55.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.265]                         if (muffled) 
[17:03:55.265]                           invokeRestart("muffleWarning")
[17:03:55.265]                       }
[17:03:55.265]                       else if (inherits(cond, "condition")) {
[17:03:55.265]                         if (!is.null(pattern)) {
[17:03:55.265]                           computeRestarts <- base::computeRestarts
[17:03:55.265]                           grepl <- base::grepl
[17:03:55.265]                           restarts <- computeRestarts(cond)
[17:03:55.265]                           for (restart in restarts) {
[17:03:55.265]                             name <- restart$name
[17:03:55.265]                             if (is.null(name)) 
[17:03:55.265]                               next
[17:03:55.265]                             if (!grepl(pattern, name)) 
[17:03:55.265]                               next
[17:03:55.265]                             invokeRestart(restart)
[17:03:55.265]                             muffled <- TRUE
[17:03:55.265]                             break
[17:03:55.265]                           }
[17:03:55.265]                         }
[17:03:55.265]                       }
[17:03:55.265]                       invisible(muffled)
[17:03:55.265]                     }
[17:03:55.265]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.265]                   }
[17:03:55.265]                 }
[17:03:55.265]             }
[17:03:55.265]         }))
[17:03:55.265]     }, error = function(ex) {
[17:03:55.265]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.265]                 ...future.rng), started = ...future.startTime, 
[17:03:55.265]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.265]             version = "1.8"), class = "FutureResult")
[17:03:55.265]     }, finally = {
[17:03:55.265]         if (!identical(...future.workdir, getwd())) 
[17:03:55.265]             setwd(...future.workdir)
[17:03:55.265]         {
[17:03:55.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.265]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.265]             }
[17:03:55.265]             base::options(...future.oldOptions)
[17:03:55.265]             if (.Platform$OS.type == "windows") {
[17:03:55.265]                 old_names <- names(...future.oldEnvVars)
[17:03:55.265]                 envs <- base::Sys.getenv()
[17:03:55.265]                 names <- names(envs)
[17:03:55.265]                 common <- intersect(names, old_names)
[17:03:55.265]                 added <- setdiff(names, old_names)
[17:03:55.265]                 removed <- setdiff(old_names, names)
[17:03:55.265]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.265]                   envs[common]]
[17:03:55.265]                 NAMES <- toupper(changed)
[17:03:55.265]                 args <- list()
[17:03:55.265]                 for (kk in seq_along(NAMES)) {
[17:03:55.265]                   name <- changed[[kk]]
[17:03:55.265]                   NAME <- NAMES[[kk]]
[17:03:55.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.265]                     next
[17:03:55.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.265]                 }
[17:03:55.265]                 NAMES <- toupper(added)
[17:03:55.265]                 for (kk in seq_along(NAMES)) {
[17:03:55.265]                   name <- added[[kk]]
[17:03:55.265]                   NAME <- NAMES[[kk]]
[17:03:55.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.265]                     next
[17:03:55.265]                   args[[name]] <- ""
[17:03:55.265]                 }
[17:03:55.265]                 NAMES <- toupper(removed)
[17:03:55.265]                 for (kk in seq_along(NAMES)) {
[17:03:55.265]                   name <- removed[[kk]]
[17:03:55.265]                   NAME <- NAMES[[kk]]
[17:03:55.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.265]                     next
[17:03:55.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.265]                 }
[17:03:55.265]                 if (length(args) > 0) 
[17:03:55.265]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.265]             }
[17:03:55.265]             else {
[17:03:55.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.265]             }
[17:03:55.265]             {
[17:03:55.265]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.265]                   0L) {
[17:03:55.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.265]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.265]                   base::options(opts)
[17:03:55.265]                 }
[17:03:55.265]                 {
[17:03:55.265]                   {
[17:03:55.265]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.265]                     NULL
[17:03:55.265]                   }
[17:03:55.265]                   options(future.plan = NULL)
[17:03:55.265]                   if (is.na(NA_character_)) 
[17:03:55.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.265]                     .init = FALSE)
[17:03:55.265]                 }
[17:03:55.265]             }
[17:03:55.265]         }
[17:03:55.265]     })
[17:03:55.265]     if (TRUE) {
[17:03:55.265]         base::sink(type = "output", split = FALSE)
[17:03:55.265]         if (TRUE) {
[17:03:55.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.265]         }
[17:03:55.265]         else {
[17:03:55.265]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.265]         }
[17:03:55.265]         base::close(...future.stdout)
[17:03:55.265]         ...future.stdout <- NULL
[17:03:55.265]     }
[17:03:55.265]     ...future.result$conditions <- ...future.conditions
[17:03:55.265]     ...future.result$finished <- base::Sys.time()
[17:03:55.265]     ...future.result
[17:03:55.265] }
[17:03:55.267] MultisessionFuture started
[17:03:55.268] - Launch lazy future ... done
[17:03:55.268] run() for ‘MultisessionFuture’ ... done
[17:03:55.269] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.269] - Validating connection of MultisessionFuture
[17:03:55.269] - received message: FutureResult
[17:03:55.269] - Received FutureResult
[17:03:55.269] - Erased future from FutureRegistry
[17:03:55.270] result() for ClusterFuture ...
[17:03:55.270] - result already collected: FutureResult
[17:03:55.270] result() for ClusterFuture ... done
[17:03:55.270] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.270] Future #1
[17:03:55.270]  length: 2 (resolved future 1)
[17:03:55.270] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.271] - Validating connection of MultisessionFuture
[17:03:55.271] - received message: FutureResult
[17:03:55.271] - Received FutureResult
[17:03:55.271] - Erased future from FutureRegistry
[17:03:55.271] result() for ClusterFuture ...
[17:03:55.271] - result already collected: FutureResult
[17:03:55.271] result() for ClusterFuture ... done
[17:03:55.271] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.271] Future #2
[17:03:55.272]  length: 1 (resolved future 2)
[17:03:55.272]  length: 0 (resolved future 3)
[17:03:55.272] resolve() on list ... DONE
[17:03:55.272] getGlobalsAndPackages() ...
[17:03:55.272] Searching for globals...
[17:03:55.272] 
[17:03:55.272] Searching for globals ... DONE
[17:03:55.272] - globals: [0] <none>
[17:03:55.273] getGlobalsAndPackages() ... DONE
[17:03:55.273] getGlobalsAndPackages() ...
[17:03:55.273] Searching for globals...
[17:03:55.273] 
[17:03:55.273] Searching for globals ... DONE
[17:03:55.273] - globals: [0] <none>
[17:03:55.273] getGlobalsAndPackages() ... DONE
[17:03:55.274] resolve() on list ...
[17:03:55.274]  recursive: 0
[17:03:55.274]  length: 3
[17:03:55.274]  elements: ‘a’, ‘b’, ‘’
[17:03:55.274] run() for ‘Future’ ...
[17:03:55.274] - state: ‘created’
[17:03:55.274] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.288] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.288]   - Field: ‘node’
[17:03:55.288]   - Field: ‘label’
[17:03:55.288]   - Field: ‘local’
[17:03:55.288]   - Field: ‘owner’
[17:03:55.288]   - Field: ‘envir’
[17:03:55.288]   - Field: ‘workers’
[17:03:55.288]   - Field: ‘packages’
[17:03:55.288]   - Field: ‘gc’
[17:03:55.289]   - Field: ‘conditions’
[17:03:55.289]   - Field: ‘persistent’
[17:03:55.289]   - Field: ‘expr’
[17:03:55.289]   - Field: ‘uuid’
[17:03:55.289]   - Field: ‘seed’
[17:03:55.289]   - Field: ‘version’
[17:03:55.289]   - Field: ‘result’
[17:03:55.289]   - Field: ‘asynchronous’
[17:03:55.289]   - Field: ‘calls’
[17:03:55.289]   - Field: ‘globals’
[17:03:55.289]   - Field: ‘stdout’
[17:03:55.289]   - Field: ‘earlySignal’
[17:03:55.290]   - Field: ‘lazy’
[17:03:55.290]   - Field: ‘state’
[17:03:55.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.290] - Launch lazy future ...
[17:03:55.290] Packages needed by the future expression (n = 0): <none>
[17:03:55.290] Packages needed by future strategies (n = 0): <none>
[17:03:55.291] {
[17:03:55.291]     {
[17:03:55.291]         {
[17:03:55.291]             ...future.startTime <- base::Sys.time()
[17:03:55.291]             {
[17:03:55.291]                 {
[17:03:55.291]                   {
[17:03:55.291]                     {
[17:03:55.291]                       base::local({
[17:03:55.291]                         has_future <- base::requireNamespace("future", 
[17:03:55.291]                           quietly = TRUE)
[17:03:55.291]                         if (has_future) {
[17:03:55.291]                           ns <- base::getNamespace("future")
[17:03:55.291]                           version <- ns[[".package"]][["version"]]
[17:03:55.291]                           if (is.null(version)) 
[17:03:55.291]                             version <- utils::packageVersion("future")
[17:03:55.291]                         }
[17:03:55.291]                         else {
[17:03:55.291]                           version <- NULL
[17:03:55.291]                         }
[17:03:55.291]                         if (!has_future || version < "1.8.0") {
[17:03:55.291]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.291]                             "", base::R.version$version.string), 
[17:03:55.291]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.291]                               "release", "version")], collapse = " "), 
[17:03:55.291]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.291]                             info)
[17:03:55.291]                           info <- base::paste(info, collapse = "; ")
[17:03:55.291]                           if (!has_future) {
[17:03:55.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.291]                               info)
[17:03:55.291]                           }
[17:03:55.291]                           else {
[17:03:55.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.291]                               info, version)
[17:03:55.291]                           }
[17:03:55.291]                           base::stop(msg)
[17:03:55.291]                         }
[17:03:55.291]                       })
[17:03:55.291]                     }
[17:03:55.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.291]                     base::options(mc.cores = 1L)
[17:03:55.291]                   }
[17:03:55.291]                   ...future.strategy.old <- future::plan("list")
[17:03:55.291]                   options(future.plan = NULL)
[17:03:55.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.291]                 }
[17:03:55.291]                 ...future.workdir <- getwd()
[17:03:55.291]             }
[17:03:55.291]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.291]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.291]         }
[17:03:55.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.291]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.291]             base::names(...future.oldOptions))
[17:03:55.291]     }
[17:03:55.291]     if (FALSE) {
[17:03:55.291]     }
[17:03:55.291]     else {
[17:03:55.291]         if (TRUE) {
[17:03:55.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.291]                 open = "w")
[17:03:55.291]         }
[17:03:55.291]         else {
[17:03:55.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.291]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.291]         }
[17:03:55.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.291]             base::sink(type = "output", split = FALSE)
[17:03:55.291]             base::close(...future.stdout)
[17:03:55.291]         }, add = TRUE)
[17:03:55.291]     }
[17:03:55.291]     ...future.frame <- base::sys.nframe()
[17:03:55.291]     ...future.conditions <- base::list()
[17:03:55.291]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.291]     if (FALSE) {
[17:03:55.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.291]     }
[17:03:55.291]     ...future.result <- base::tryCatch({
[17:03:55.291]         base::withCallingHandlers({
[17:03:55.291]             ...future.value <- base::withVisible(base::local({
[17:03:55.291]                 ...future.makeSendCondition <- base::local({
[17:03:55.291]                   sendCondition <- NULL
[17:03:55.291]                   function(frame = 1L) {
[17:03:55.291]                     if (is.function(sendCondition)) 
[17:03:55.291]                       return(sendCondition)
[17:03:55.291]                     ns <- getNamespace("parallel")
[17:03:55.291]                     if (exists("sendData", mode = "function", 
[17:03:55.291]                       envir = ns)) {
[17:03:55.291]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.291]                         envir = ns)
[17:03:55.291]                       envir <- sys.frame(frame)
[17:03:55.291]                       master <- NULL
[17:03:55.291]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.291]                         !identical(envir, emptyenv())) {
[17:03:55.291]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.291]                           inherits = FALSE)) {
[17:03:55.291]                           master <- get("master", mode = "list", 
[17:03:55.291]                             envir = envir, inherits = FALSE)
[17:03:55.291]                           if (inherits(master, c("SOCKnode", 
[17:03:55.291]                             "SOCK0node"))) {
[17:03:55.291]                             sendCondition <<- function(cond) {
[17:03:55.291]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.291]                                 success = TRUE)
[17:03:55.291]                               parallel_sendData(master, data)
[17:03:55.291]                             }
[17:03:55.291]                             return(sendCondition)
[17:03:55.291]                           }
[17:03:55.291]                         }
[17:03:55.291]                         frame <- frame + 1L
[17:03:55.291]                         envir <- sys.frame(frame)
[17:03:55.291]                       }
[17:03:55.291]                     }
[17:03:55.291]                     sendCondition <<- function(cond) NULL
[17:03:55.291]                   }
[17:03:55.291]                 })
[17:03:55.291]                 withCallingHandlers({
[17:03:55.291]                   1
[17:03:55.291]                 }, immediateCondition = function(cond) {
[17:03:55.291]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.291]                   sendCondition(cond)
[17:03:55.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.291]                   {
[17:03:55.291]                     inherits <- base::inherits
[17:03:55.291]                     invokeRestart <- base::invokeRestart
[17:03:55.291]                     is.null <- base::is.null
[17:03:55.291]                     muffled <- FALSE
[17:03:55.291]                     if (inherits(cond, "message")) {
[17:03:55.291]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.291]                       if (muffled) 
[17:03:55.291]                         invokeRestart("muffleMessage")
[17:03:55.291]                     }
[17:03:55.291]                     else if (inherits(cond, "warning")) {
[17:03:55.291]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.291]                       if (muffled) 
[17:03:55.291]                         invokeRestart("muffleWarning")
[17:03:55.291]                     }
[17:03:55.291]                     else if (inherits(cond, "condition")) {
[17:03:55.291]                       if (!is.null(pattern)) {
[17:03:55.291]                         computeRestarts <- base::computeRestarts
[17:03:55.291]                         grepl <- base::grepl
[17:03:55.291]                         restarts <- computeRestarts(cond)
[17:03:55.291]                         for (restart in restarts) {
[17:03:55.291]                           name <- restart$name
[17:03:55.291]                           if (is.null(name)) 
[17:03:55.291]                             next
[17:03:55.291]                           if (!grepl(pattern, name)) 
[17:03:55.291]                             next
[17:03:55.291]                           invokeRestart(restart)
[17:03:55.291]                           muffled <- TRUE
[17:03:55.291]                           break
[17:03:55.291]                         }
[17:03:55.291]                       }
[17:03:55.291]                     }
[17:03:55.291]                     invisible(muffled)
[17:03:55.291]                   }
[17:03:55.291]                   muffleCondition(cond)
[17:03:55.291]                 })
[17:03:55.291]             }))
[17:03:55.291]             future::FutureResult(value = ...future.value$value, 
[17:03:55.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.291]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.291]                     ...future.globalenv.names))
[17:03:55.291]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.291]         }, condition = base::local({
[17:03:55.291]             c <- base::c
[17:03:55.291]             inherits <- base::inherits
[17:03:55.291]             invokeRestart <- base::invokeRestart
[17:03:55.291]             length <- base::length
[17:03:55.291]             list <- base::list
[17:03:55.291]             seq.int <- base::seq.int
[17:03:55.291]             signalCondition <- base::signalCondition
[17:03:55.291]             sys.calls <- base::sys.calls
[17:03:55.291]             `[[` <- base::`[[`
[17:03:55.291]             `+` <- base::`+`
[17:03:55.291]             `<<-` <- base::`<<-`
[17:03:55.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.291]                   3L)]
[17:03:55.291]             }
[17:03:55.291]             function(cond) {
[17:03:55.291]                 is_error <- inherits(cond, "error")
[17:03:55.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.291]                   NULL)
[17:03:55.291]                 if (is_error) {
[17:03:55.291]                   sessionInformation <- function() {
[17:03:55.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.291]                       search = base::search(), system = base::Sys.info())
[17:03:55.291]                   }
[17:03:55.291]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.291]                     cond$call), session = sessionInformation(), 
[17:03:55.291]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.291]                   signalCondition(cond)
[17:03:55.291]                 }
[17:03:55.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.291]                 "immediateCondition"))) {
[17:03:55.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.291]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.291]                   if (TRUE && !signal) {
[17:03:55.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.291]                     {
[17:03:55.291]                       inherits <- base::inherits
[17:03:55.291]                       invokeRestart <- base::invokeRestart
[17:03:55.291]                       is.null <- base::is.null
[17:03:55.291]                       muffled <- FALSE
[17:03:55.291]                       if (inherits(cond, "message")) {
[17:03:55.291]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.291]                         if (muffled) 
[17:03:55.291]                           invokeRestart("muffleMessage")
[17:03:55.291]                       }
[17:03:55.291]                       else if (inherits(cond, "warning")) {
[17:03:55.291]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.291]                         if (muffled) 
[17:03:55.291]                           invokeRestart("muffleWarning")
[17:03:55.291]                       }
[17:03:55.291]                       else if (inherits(cond, "condition")) {
[17:03:55.291]                         if (!is.null(pattern)) {
[17:03:55.291]                           computeRestarts <- base::computeRestarts
[17:03:55.291]                           grepl <- base::grepl
[17:03:55.291]                           restarts <- computeRestarts(cond)
[17:03:55.291]                           for (restart in restarts) {
[17:03:55.291]                             name <- restart$name
[17:03:55.291]                             if (is.null(name)) 
[17:03:55.291]                               next
[17:03:55.291]                             if (!grepl(pattern, name)) 
[17:03:55.291]                               next
[17:03:55.291]                             invokeRestart(restart)
[17:03:55.291]                             muffled <- TRUE
[17:03:55.291]                             break
[17:03:55.291]                           }
[17:03:55.291]                         }
[17:03:55.291]                       }
[17:03:55.291]                       invisible(muffled)
[17:03:55.291]                     }
[17:03:55.291]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.291]                   }
[17:03:55.291]                 }
[17:03:55.291]                 else {
[17:03:55.291]                   if (TRUE) {
[17:03:55.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.291]                     {
[17:03:55.291]                       inherits <- base::inherits
[17:03:55.291]                       invokeRestart <- base::invokeRestart
[17:03:55.291]                       is.null <- base::is.null
[17:03:55.291]                       muffled <- FALSE
[17:03:55.291]                       if (inherits(cond, "message")) {
[17:03:55.291]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.291]                         if (muffled) 
[17:03:55.291]                           invokeRestart("muffleMessage")
[17:03:55.291]                       }
[17:03:55.291]                       else if (inherits(cond, "warning")) {
[17:03:55.291]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.291]                         if (muffled) 
[17:03:55.291]                           invokeRestart("muffleWarning")
[17:03:55.291]                       }
[17:03:55.291]                       else if (inherits(cond, "condition")) {
[17:03:55.291]                         if (!is.null(pattern)) {
[17:03:55.291]                           computeRestarts <- base::computeRestarts
[17:03:55.291]                           grepl <- base::grepl
[17:03:55.291]                           restarts <- computeRestarts(cond)
[17:03:55.291]                           for (restart in restarts) {
[17:03:55.291]                             name <- restart$name
[17:03:55.291]                             if (is.null(name)) 
[17:03:55.291]                               next
[17:03:55.291]                             if (!grepl(pattern, name)) 
[17:03:55.291]                               next
[17:03:55.291]                             invokeRestart(restart)
[17:03:55.291]                             muffled <- TRUE
[17:03:55.291]                             break
[17:03:55.291]                           }
[17:03:55.291]                         }
[17:03:55.291]                       }
[17:03:55.291]                       invisible(muffled)
[17:03:55.291]                     }
[17:03:55.291]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.291]                   }
[17:03:55.291]                 }
[17:03:55.291]             }
[17:03:55.291]         }))
[17:03:55.291]     }, error = function(ex) {
[17:03:55.291]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.291]                 ...future.rng), started = ...future.startTime, 
[17:03:55.291]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.291]             version = "1.8"), class = "FutureResult")
[17:03:55.291]     }, finally = {
[17:03:55.291]         if (!identical(...future.workdir, getwd())) 
[17:03:55.291]             setwd(...future.workdir)
[17:03:55.291]         {
[17:03:55.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.291]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.291]             }
[17:03:55.291]             base::options(...future.oldOptions)
[17:03:55.291]             if (.Platform$OS.type == "windows") {
[17:03:55.291]                 old_names <- names(...future.oldEnvVars)
[17:03:55.291]                 envs <- base::Sys.getenv()
[17:03:55.291]                 names <- names(envs)
[17:03:55.291]                 common <- intersect(names, old_names)
[17:03:55.291]                 added <- setdiff(names, old_names)
[17:03:55.291]                 removed <- setdiff(old_names, names)
[17:03:55.291]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.291]                   envs[common]]
[17:03:55.291]                 NAMES <- toupper(changed)
[17:03:55.291]                 args <- list()
[17:03:55.291]                 for (kk in seq_along(NAMES)) {
[17:03:55.291]                   name <- changed[[kk]]
[17:03:55.291]                   NAME <- NAMES[[kk]]
[17:03:55.291]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.291]                     next
[17:03:55.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.291]                 }
[17:03:55.291]                 NAMES <- toupper(added)
[17:03:55.291]                 for (kk in seq_along(NAMES)) {
[17:03:55.291]                   name <- added[[kk]]
[17:03:55.291]                   NAME <- NAMES[[kk]]
[17:03:55.291]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.291]                     next
[17:03:55.291]                   args[[name]] <- ""
[17:03:55.291]                 }
[17:03:55.291]                 NAMES <- toupper(removed)
[17:03:55.291]                 for (kk in seq_along(NAMES)) {
[17:03:55.291]                   name <- removed[[kk]]
[17:03:55.291]                   NAME <- NAMES[[kk]]
[17:03:55.291]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.291]                     next
[17:03:55.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.291]                 }
[17:03:55.291]                 if (length(args) > 0) 
[17:03:55.291]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.291]             }
[17:03:55.291]             else {
[17:03:55.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.291]             }
[17:03:55.291]             {
[17:03:55.291]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.291]                   0L) {
[17:03:55.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.291]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.291]                   base::options(opts)
[17:03:55.291]                 }
[17:03:55.291]                 {
[17:03:55.291]                   {
[17:03:55.291]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.291]                     NULL
[17:03:55.291]                   }
[17:03:55.291]                   options(future.plan = NULL)
[17:03:55.291]                   if (is.na(NA_character_)) 
[17:03:55.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.291]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.291]                     .init = FALSE)
[17:03:55.291]                 }
[17:03:55.291]             }
[17:03:55.291]         }
[17:03:55.291]     })
[17:03:55.291]     if (TRUE) {
[17:03:55.291]         base::sink(type = "output", split = FALSE)
[17:03:55.291]         if (TRUE) {
[17:03:55.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.291]         }
[17:03:55.291]         else {
[17:03:55.291]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.291]         }
[17:03:55.291]         base::close(...future.stdout)
[17:03:55.291]         ...future.stdout <- NULL
[17:03:55.291]     }
[17:03:55.291]     ...future.result$conditions <- ...future.conditions
[17:03:55.291]     ...future.result$finished <- base::Sys.time()
[17:03:55.291]     ...future.result
[17:03:55.291] }
[17:03:55.294] MultisessionFuture started
[17:03:55.294] - Launch lazy future ... done
[17:03:55.294] run() for ‘MultisessionFuture’ ... done
[17:03:55.295] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.295] - Validating connection of MultisessionFuture
[17:03:55.295] - received message: FutureResult
[17:03:55.296] - Received FutureResult
[17:03:55.296] - Erased future from FutureRegistry
[17:03:55.296] result() for ClusterFuture ...
[17:03:55.296] - result already collected: FutureResult
[17:03:55.296] result() for ClusterFuture ... done
[17:03:55.296] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.296] Future #1
[17:03:55.296]  length: 2 (resolved future 1)
[17:03:55.296] run() for ‘Future’ ...
[17:03:55.296] - state: ‘created’
[17:03:55.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.310] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.310] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.310]   - Field: ‘node’
[17:03:55.311]   - Field: ‘label’
[17:03:55.311]   - Field: ‘local’
[17:03:55.311]   - Field: ‘owner’
[17:03:55.311]   - Field: ‘envir’
[17:03:55.311]   - Field: ‘workers’
[17:03:55.311]   - Field: ‘packages’
[17:03:55.311]   - Field: ‘gc’
[17:03:55.311]   - Field: ‘conditions’
[17:03:55.311]   - Field: ‘persistent’
[17:03:55.311]   - Field: ‘expr’
[17:03:55.312]   - Field: ‘uuid’
[17:03:55.312]   - Field: ‘seed’
[17:03:55.312]   - Field: ‘version’
[17:03:55.312]   - Field: ‘result’
[17:03:55.312]   - Field: ‘asynchronous’
[17:03:55.312]   - Field: ‘calls’
[17:03:55.312]   - Field: ‘globals’
[17:03:55.312]   - Field: ‘stdout’
[17:03:55.312]   - Field: ‘earlySignal’
[17:03:55.312]   - Field: ‘lazy’
[17:03:55.312]   - Field: ‘state’
[17:03:55.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.313] - Launch lazy future ...
[17:03:55.313] Packages needed by the future expression (n = 0): <none>
[17:03:55.313] Packages needed by future strategies (n = 0): <none>
[17:03:55.313] {
[17:03:55.313]     {
[17:03:55.313]         {
[17:03:55.313]             ...future.startTime <- base::Sys.time()
[17:03:55.313]             {
[17:03:55.313]                 {
[17:03:55.313]                   {
[17:03:55.313]                     {
[17:03:55.313]                       base::local({
[17:03:55.313]                         has_future <- base::requireNamespace("future", 
[17:03:55.313]                           quietly = TRUE)
[17:03:55.313]                         if (has_future) {
[17:03:55.313]                           ns <- base::getNamespace("future")
[17:03:55.313]                           version <- ns[[".package"]][["version"]]
[17:03:55.313]                           if (is.null(version)) 
[17:03:55.313]                             version <- utils::packageVersion("future")
[17:03:55.313]                         }
[17:03:55.313]                         else {
[17:03:55.313]                           version <- NULL
[17:03:55.313]                         }
[17:03:55.313]                         if (!has_future || version < "1.8.0") {
[17:03:55.313]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.313]                             "", base::R.version$version.string), 
[17:03:55.313]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.313]                               "release", "version")], collapse = " "), 
[17:03:55.313]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.313]                             info)
[17:03:55.313]                           info <- base::paste(info, collapse = "; ")
[17:03:55.313]                           if (!has_future) {
[17:03:55.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.313]                               info)
[17:03:55.313]                           }
[17:03:55.313]                           else {
[17:03:55.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.313]                               info, version)
[17:03:55.313]                           }
[17:03:55.313]                           base::stop(msg)
[17:03:55.313]                         }
[17:03:55.313]                       })
[17:03:55.313]                     }
[17:03:55.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.313]                     base::options(mc.cores = 1L)
[17:03:55.313]                   }
[17:03:55.313]                   ...future.strategy.old <- future::plan("list")
[17:03:55.313]                   options(future.plan = NULL)
[17:03:55.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.313]                 }
[17:03:55.313]                 ...future.workdir <- getwd()
[17:03:55.313]             }
[17:03:55.313]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.313]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.313]         }
[17:03:55.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.313]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.313]             base::names(...future.oldOptions))
[17:03:55.313]     }
[17:03:55.313]     if (FALSE) {
[17:03:55.313]     }
[17:03:55.313]     else {
[17:03:55.313]         if (TRUE) {
[17:03:55.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.313]                 open = "w")
[17:03:55.313]         }
[17:03:55.313]         else {
[17:03:55.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.313]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.313]         }
[17:03:55.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.313]             base::sink(type = "output", split = FALSE)
[17:03:55.313]             base::close(...future.stdout)
[17:03:55.313]         }, add = TRUE)
[17:03:55.313]     }
[17:03:55.313]     ...future.frame <- base::sys.nframe()
[17:03:55.313]     ...future.conditions <- base::list()
[17:03:55.313]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.313]     if (FALSE) {
[17:03:55.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.313]     }
[17:03:55.313]     ...future.result <- base::tryCatch({
[17:03:55.313]         base::withCallingHandlers({
[17:03:55.313]             ...future.value <- base::withVisible(base::local({
[17:03:55.313]                 ...future.makeSendCondition <- base::local({
[17:03:55.313]                   sendCondition <- NULL
[17:03:55.313]                   function(frame = 1L) {
[17:03:55.313]                     if (is.function(sendCondition)) 
[17:03:55.313]                       return(sendCondition)
[17:03:55.313]                     ns <- getNamespace("parallel")
[17:03:55.313]                     if (exists("sendData", mode = "function", 
[17:03:55.313]                       envir = ns)) {
[17:03:55.313]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.313]                         envir = ns)
[17:03:55.313]                       envir <- sys.frame(frame)
[17:03:55.313]                       master <- NULL
[17:03:55.313]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.313]                         !identical(envir, emptyenv())) {
[17:03:55.313]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.313]                           inherits = FALSE)) {
[17:03:55.313]                           master <- get("master", mode = "list", 
[17:03:55.313]                             envir = envir, inherits = FALSE)
[17:03:55.313]                           if (inherits(master, c("SOCKnode", 
[17:03:55.313]                             "SOCK0node"))) {
[17:03:55.313]                             sendCondition <<- function(cond) {
[17:03:55.313]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.313]                                 success = TRUE)
[17:03:55.313]                               parallel_sendData(master, data)
[17:03:55.313]                             }
[17:03:55.313]                             return(sendCondition)
[17:03:55.313]                           }
[17:03:55.313]                         }
[17:03:55.313]                         frame <- frame + 1L
[17:03:55.313]                         envir <- sys.frame(frame)
[17:03:55.313]                       }
[17:03:55.313]                     }
[17:03:55.313]                     sendCondition <<- function(cond) NULL
[17:03:55.313]                   }
[17:03:55.313]                 })
[17:03:55.313]                 withCallingHandlers({
[17:03:55.313]                   2
[17:03:55.313]                 }, immediateCondition = function(cond) {
[17:03:55.313]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.313]                   sendCondition(cond)
[17:03:55.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.313]                   {
[17:03:55.313]                     inherits <- base::inherits
[17:03:55.313]                     invokeRestart <- base::invokeRestart
[17:03:55.313]                     is.null <- base::is.null
[17:03:55.313]                     muffled <- FALSE
[17:03:55.313]                     if (inherits(cond, "message")) {
[17:03:55.313]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.313]                       if (muffled) 
[17:03:55.313]                         invokeRestart("muffleMessage")
[17:03:55.313]                     }
[17:03:55.313]                     else if (inherits(cond, "warning")) {
[17:03:55.313]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.313]                       if (muffled) 
[17:03:55.313]                         invokeRestart("muffleWarning")
[17:03:55.313]                     }
[17:03:55.313]                     else if (inherits(cond, "condition")) {
[17:03:55.313]                       if (!is.null(pattern)) {
[17:03:55.313]                         computeRestarts <- base::computeRestarts
[17:03:55.313]                         grepl <- base::grepl
[17:03:55.313]                         restarts <- computeRestarts(cond)
[17:03:55.313]                         for (restart in restarts) {
[17:03:55.313]                           name <- restart$name
[17:03:55.313]                           if (is.null(name)) 
[17:03:55.313]                             next
[17:03:55.313]                           if (!grepl(pattern, name)) 
[17:03:55.313]                             next
[17:03:55.313]                           invokeRestart(restart)
[17:03:55.313]                           muffled <- TRUE
[17:03:55.313]                           break
[17:03:55.313]                         }
[17:03:55.313]                       }
[17:03:55.313]                     }
[17:03:55.313]                     invisible(muffled)
[17:03:55.313]                   }
[17:03:55.313]                   muffleCondition(cond)
[17:03:55.313]                 })
[17:03:55.313]             }))
[17:03:55.313]             future::FutureResult(value = ...future.value$value, 
[17:03:55.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.313]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.313]                     ...future.globalenv.names))
[17:03:55.313]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.313]         }, condition = base::local({
[17:03:55.313]             c <- base::c
[17:03:55.313]             inherits <- base::inherits
[17:03:55.313]             invokeRestart <- base::invokeRestart
[17:03:55.313]             length <- base::length
[17:03:55.313]             list <- base::list
[17:03:55.313]             seq.int <- base::seq.int
[17:03:55.313]             signalCondition <- base::signalCondition
[17:03:55.313]             sys.calls <- base::sys.calls
[17:03:55.313]             `[[` <- base::`[[`
[17:03:55.313]             `+` <- base::`+`
[17:03:55.313]             `<<-` <- base::`<<-`
[17:03:55.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.313]                   3L)]
[17:03:55.313]             }
[17:03:55.313]             function(cond) {
[17:03:55.313]                 is_error <- inherits(cond, "error")
[17:03:55.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.313]                   NULL)
[17:03:55.313]                 if (is_error) {
[17:03:55.313]                   sessionInformation <- function() {
[17:03:55.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.313]                       search = base::search(), system = base::Sys.info())
[17:03:55.313]                   }
[17:03:55.313]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.313]                     cond$call), session = sessionInformation(), 
[17:03:55.313]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.313]                   signalCondition(cond)
[17:03:55.313]                 }
[17:03:55.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.313]                 "immediateCondition"))) {
[17:03:55.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.313]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.313]                   if (TRUE && !signal) {
[17:03:55.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.313]                     {
[17:03:55.313]                       inherits <- base::inherits
[17:03:55.313]                       invokeRestart <- base::invokeRestart
[17:03:55.313]                       is.null <- base::is.null
[17:03:55.313]                       muffled <- FALSE
[17:03:55.313]                       if (inherits(cond, "message")) {
[17:03:55.313]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.313]                         if (muffled) 
[17:03:55.313]                           invokeRestart("muffleMessage")
[17:03:55.313]                       }
[17:03:55.313]                       else if (inherits(cond, "warning")) {
[17:03:55.313]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.313]                         if (muffled) 
[17:03:55.313]                           invokeRestart("muffleWarning")
[17:03:55.313]                       }
[17:03:55.313]                       else if (inherits(cond, "condition")) {
[17:03:55.313]                         if (!is.null(pattern)) {
[17:03:55.313]                           computeRestarts <- base::computeRestarts
[17:03:55.313]                           grepl <- base::grepl
[17:03:55.313]                           restarts <- computeRestarts(cond)
[17:03:55.313]                           for (restart in restarts) {
[17:03:55.313]                             name <- restart$name
[17:03:55.313]                             if (is.null(name)) 
[17:03:55.313]                               next
[17:03:55.313]                             if (!grepl(pattern, name)) 
[17:03:55.313]                               next
[17:03:55.313]                             invokeRestart(restart)
[17:03:55.313]                             muffled <- TRUE
[17:03:55.313]                             break
[17:03:55.313]                           }
[17:03:55.313]                         }
[17:03:55.313]                       }
[17:03:55.313]                       invisible(muffled)
[17:03:55.313]                     }
[17:03:55.313]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.313]                   }
[17:03:55.313]                 }
[17:03:55.313]                 else {
[17:03:55.313]                   if (TRUE) {
[17:03:55.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.313]                     {
[17:03:55.313]                       inherits <- base::inherits
[17:03:55.313]                       invokeRestart <- base::invokeRestart
[17:03:55.313]                       is.null <- base::is.null
[17:03:55.313]                       muffled <- FALSE
[17:03:55.313]                       if (inherits(cond, "message")) {
[17:03:55.313]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.313]                         if (muffled) 
[17:03:55.313]                           invokeRestart("muffleMessage")
[17:03:55.313]                       }
[17:03:55.313]                       else if (inherits(cond, "warning")) {
[17:03:55.313]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.313]                         if (muffled) 
[17:03:55.313]                           invokeRestart("muffleWarning")
[17:03:55.313]                       }
[17:03:55.313]                       else if (inherits(cond, "condition")) {
[17:03:55.313]                         if (!is.null(pattern)) {
[17:03:55.313]                           computeRestarts <- base::computeRestarts
[17:03:55.313]                           grepl <- base::grepl
[17:03:55.313]                           restarts <- computeRestarts(cond)
[17:03:55.313]                           for (restart in restarts) {
[17:03:55.313]                             name <- restart$name
[17:03:55.313]                             if (is.null(name)) 
[17:03:55.313]                               next
[17:03:55.313]                             if (!grepl(pattern, name)) 
[17:03:55.313]                               next
[17:03:55.313]                             invokeRestart(restart)
[17:03:55.313]                             muffled <- TRUE
[17:03:55.313]                             break
[17:03:55.313]                           }
[17:03:55.313]                         }
[17:03:55.313]                       }
[17:03:55.313]                       invisible(muffled)
[17:03:55.313]                     }
[17:03:55.313]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.313]                   }
[17:03:55.313]                 }
[17:03:55.313]             }
[17:03:55.313]         }))
[17:03:55.313]     }, error = function(ex) {
[17:03:55.313]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.313]                 ...future.rng), started = ...future.startTime, 
[17:03:55.313]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.313]             version = "1.8"), class = "FutureResult")
[17:03:55.313]     }, finally = {
[17:03:55.313]         if (!identical(...future.workdir, getwd())) 
[17:03:55.313]             setwd(...future.workdir)
[17:03:55.313]         {
[17:03:55.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.313]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.313]             }
[17:03:55.313]             base::options(...future.oldOptions)
[17:03:55.313]             if (.Platform$OS.type == "windows") {
[17:03:55.313]                 old_names <- names(...future.oldEnvVars)
[17:03:55.313]                 envs <- base::Sys.getenv()
[17:03:55.313]                 names <- names(envs)
[17:03:55.313]                 common <- intersect(names, old_names)
[17:03:55.313]                 added <- setdiff(names, old_names)
[17:03:55.313]                 removed <- setdiff(old_names, names)
[17:03:55.313]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.313]                   envs[common]]
[17:03:55.313]                 NAMES <- toupper(changed)
[17:03:55.313]                 args <- list()
[17:03:55.313]                 for (kk in seq_along(NAMES)) {
[17:03:55.313]                   name <- changed[[kk]]
[17:03:55.313]                   NAME <- NAMES[[kk]]
[17:03:55.313]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.313]                     next
[17:03:55.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.313]                 }
[17:03:55.313]                 NAMES <- toupper(added)
[17:03:55.313]                 for (kk in seq_along(NAMES)) {
[17:03:55.313]                   name <- added[[kk]]
[17:03:55.313]                   NAME <- NAMES[[kk]]
[17:03:55.313]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.313]                     next
[17:03:55.313]                   args[[name]] <- ""
[17:03:55.313]                 }
[17:03:55.313]                 NAMES <- toupper(removed)
[17:03:55.313]                 for (kk in seq_along(NAMES)) {
[17:03:55.313]                   name <- removed[[kk]]
[17:03:55.313]                   NAME <- NAMES[[kk]]
[17:03:55.313]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.313]                     next
[17:03:55.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.313]                 }
[17:03:55.313]                 if (length(args) > 0) 
[17:03:55.313]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.313]             }
[17:03:55.313]             else {
[17:03:55.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.313]             }
[17:03:55.313]             {
[17:03:55.313]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.313]                   0L) {
[17:03:55.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.313]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.313]                   base::options(opts)
[17:03:55.313]                 }
[17:03:55.313]                 {
[17:03:55.313]                   {
[17:03:55.313]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.313]                     NULL
[17:03:55.313]                   }
[17:03:55.313]                   options(future.plan = NULL)
[17:03:55.313]                   if (is.na(NA_character_)) 
[17:03:55.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.313]                     .init = FALSE)
[17:03:55.313]                 }
[17:03:55.313]             }
[17:03:55.313]         }
[17:03:55.313]     })
[17:03:55.313]     if (TRUE) {
[17:03:55.313]         base::sink(type = "output", split = FALSE)
[17:03:55.313]         if (TRUE) {
[17:03:55.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.313]         }
[17:03:55.313]         else {
[17:03:55.313]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.313]         }
[17:03:55.313]         base::close(...future.stdout)
[17:03:55.313]         ...future.stdout <- NULL
[17:03:55.313]     }
[17:03:55.313]     ...future.result$conditions <- ...future.conditions
[17:03:55.313]     ...future.result$finished <- base::Sys.time()
[17:03:55.313]     ...future.result
[17:03:55.313] }
[17:03:55.316] MultisessionFuture started
[17:03:55.317] - Launch lazy future ... done
[17:03:55.317] run() for ‘MultisessionFuture’ ... done
[17:03:55.318] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.318] - Validating connection of MultisessionFuture
[17:03:55.318] - received message: FutureResult
[17:03:55.318] - Received FutureResult
[17:03:55.318] - Erased future from FutureRegistry
[17:03:55.319] result() for ClusterFuture ...
[17:03:55.319] - result already collected: FutureResult
[17:03:55.319] result() for ClusterFuture ... done
[17:03:55.319] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.319] Future #2
[17:03:55.319]  length: 1 (resolved future 2)
[17:03:55.319]  length: 0 (resolved future 3)
[17:03:55.319] resolve() on list ... DONE
[17:03:55.319] getGlobalsAndPackages() ...
[17:03:55.319] Searching for globals...
[17:03:55.320] 
[17:03:55.320] Searching for globals ... DONE
[17:03:55.320] - globals: [0] <none>
[17:03:55.320] getGlobalsAndPackages() ... DONE
[17:03:55.320] run() for ‘Future’ ...
[17:03:55.320] - state: ‘created’
[17:03:55.321] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.334] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.335]   - Field: ‘node’
[17:03:55.335]   - Field: ‘label’
[17:03:55.335]   - Field: ‘local’
[17:03:55.335]   - Field: ‘owner’
[17:03:55.335]   - Field: ‘envir’
[17:03:55.335]   - Field: ‘workers’
[17:03:55.335]   - Field: ‘packages’
[17:03:55.335]   - Field: ‘gc’
[17:03:55.335]   - Field: ‘conditions’
[17:03:55.335]   - Field: ‘persistent’
[17:03:55.335]   - Field: ‘expr’
[17:03:55.336]   - Field: ‘uuid’
[17:03:55.336]   - Field: ‘seed’
[17:03:55.336]   - Field: ‘version’
[17:03:55.336]   - Field: ‘result’
[17:03:55.336]   - Field: ‘asynchronous’
[17:03:55.336]   - Field: ‘calls’
[17:03:55.336]   - Field: ‘globals’
[17:03:55.336]   - Field: ‘stdout’
[17:03:55.336]   - Field: ‘earlySignal’
[17:03:55.336]   - Field: ‘lazy’
[17:03:55.336]   - Field: ‘state’
[17:03:55.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.337] - Launch lazy future ...
[17:03:55.337] Packages needed by the future expression (n = 0): <none>
[17:03:55.337] Packages needed by future strategies (n = 0): <none>
[17:03:55.337] {
[17:03:55.337]     {
[17:03:55.337]         {
[17:03:55.337]             ...future.startTime <- base::Sys.time()
[17:03:55.337]             {
[17:03:55.337]                 {
[17:03:55.337]                   {
[17:03:55.337]                     {
[17:03:55.337]                       base::local({
[17:03:55.337]                         has_future <- base::requireNamespace("future", 
[17:03:55.337]                           quietly = TRUE)
[17:03:55.337]                         if (has_future) {
[17:03:55.337]                           ns <- base::getNamespace("future")
[17:03:55.337]                           version <- ns[[".package"]][["version"]]
[17:03:55.337]                           if (is.null(version)) 
[17:03:55.337]                             version <- utils::packageVersion("future")
[17:03:55.337]                         }
[17:03:55.337]                         else {
[17:03:55.337]                           version <- NULL
[17:03:55.337]                         }
[17:03:55.337]                         if (!has_future || version < "1.8.0") {
[17:03:55.337]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.337]                             "", base::R.version$version.string), 
[17:03:55.337]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.337]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.337]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.337]                               "release", "version")], collapse = " "), 
[17:03:55.337]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.337]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.337]                             info)
[17:03:55.337]                           info <- base::paste(info, collapse = "; ")
[17:03:55.337]                           if (!has_future) {
[17:03:55.337]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.337]                               info)
[17:03:55.337]                           }
[17:03:55.337]                           else {
[17:03:55.337]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.337]                               info, version)
[17:03:55.337]                           }
[17:03:55.337]                           base::stop(msg)
[17:03:55.337]                         }
[17:03:55.337]                       })
[17:03:55.337]                     }
[17:03:55.337]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.337]                     base::options(mc.cores = 1L)
[17:03:55.337]                   }
[17:03:55.337]                   ...future.strategy.old <- future::plan("list")
[17:03:55.337]                   options(future.plan = NULL)
[17:03:55.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.337]                 }
[17:03:55.337]                 ...future.workdir <- getwd()
[17:03:55.337]             }
[17:03:55.337]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.337]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.337]         }
[17:03:55.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.337]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.337]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.337]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.337]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.337]             base::names(...future.oldOptions))
[17:03:55.337]     }
[17:03:55.337]     if (FALSE) {
[17:03:55.337]     }
[17:03:55.337]     else {
[17:03:55.337]         if (TRUE) {
[17:03:55.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.337]                 open = "w")
[17:03:55.337]         }
[17:03:55.337]         else {
[17:03:55.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.337]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.337]         }
[17:03:55.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.337]             base::sink(type = "output", split = FALSE)
[17:03:55.337]             base::close(...future.stdout)
[17:03:55.337]         }, add = TRUE)
[17:03:55.337]     }
[17:03:55.337]     ...future.frame <- base::sys.nframe()
[17:03:55.337]     ...future.conditions <- base::list()
[17:03:55.337]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.337]     if (FALSE) {
[17:03:55.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.337]     }
[17:03:55.337]     ...future.result <- base::tryCatch({
[17:03:55.337]         base::withCallingHandlers({
[17:03:55.337]             ...future.value <- base::withVisible(base::local({
[17:03:55.337]                 ...future.makeSendCondition <- base::local({
[17:03:55.337]                   sendCondition <- NULL
[17:03:55.337]                   function(frame = 1L) {
[17:03:55.337]                     if (is.function(sendCondition)) 
[17:03:55.337]                       return(sendCondition)
[17:03:55.337]                     ns <- getNamespace("parallel")
[17:03:55.337]                     if (exists("sendData", mode = "function", 
[17:03:55.337]                       envir = ns)) {
[17:03:55.337]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.337]                         envir = ns)
[17:03:55.337]                       envir <- sys.frame(frame)
[17:03:55.337]                       master <- NULL
[17:03:55.337]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.337]                         !identical(envir, emptyenv())) {
[17:03:55.337]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.337]                           inherits = FALSE)) {
[17:03:55.337]                           master <- get("master", mode = "list", 
[17:03:55.337]                             envir = envir, inherits = FALSE)
[17:03:55.337]                           if (inherits(master, c("SOCKnode", 
[17:03:55.337]                             "SOCK0node"))) {
[17:03:55.337]                             sendCondition <<- function(cond) {
[17:03:55.337]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.337]                                 success = TRUE)
[17:03:55.337]                               parallel_sendData(master, data)
[17:03:55.337]                             }
[17:03:55.337]                             return(sendCondition)
[17:03:55.337]                           }
[17:03:55.337]                         }
[17:03:55.337]                         frame <- frame + 1L
[17:03:55.337]                         envir <- sys.frame(frame)
[17:03:55.337]                       }
[17:03:55.337]                     }
[17:03:55.337]                     sendCondition <<- function(cond) NULL
[17:03:55.337]                   }
[17:03:55.337]                 })
[17:03:55.337]                 withCallingHandlers({
[17:03:55.337]                   1
[17:03:55.337]                 }, immediateCondition = function(cond) {
[17:03:55.337]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.337]                   sendCondition(cond)
[17:03:55.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.337]                   {
[17:03:55.337]                     inherits <- base::inherits
[17:03:55.337]                     invokeRestart <- base::invokeRestart
[17:03:55.337]                     is.null <- base::is.null
[17:03:55.337]                     muffled <- FALSE
[17:03:55.337]                     if (inherits(cond, "message")) {
[17:03:55.337]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.337]                       if (muffled) 
[17:03:55.337]                         invokeRestart("muffleMessage")
[17:03:55.337]                     }
[17:03:55.337]                     else if (inherits(cond, "warning")) {
[17:03:55.337]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.337]                       if (muffled) 
[17:03:55.337]                         invokeRestart("muffleWarning")
[17:03:55.337]                     }
[17:03:55.337]                     else if (inherits(cond, "condition")) {
[17:03:55.337]                       if (!is.null(pattern)) {
[17:03:55.337]                         computeRestarts <- base::computeRestarts
[17:03:55.337]                         grepl <- base::grepl
[17:03:55.337]                         restarts <- computeRestarts(cond)
[17:03:55.337]                         for (restart in restarts) {
[17:03:55.337]                           name <- restart$name
[17:03:55.337]                           if (is.null(name)) 
[17:03:55.337]                             next
[17:03:55.337]                           if (!grepl(pattern, name)) 
[17:03:55.337]                             next
[17:03:55.337]                           invokeRestart(restart)
[17:03:55.337]                           muffled <- TRUE
[17:03:55.337]                           break
[17:03:55.337]                         }
[17:03:55.337]                       }
[17:03:55.337]                     }
[17:03:55.337]                     invisible(muffled)
[17:03:55.337]                   }
[17:03:55.337]                   muffleCondition(cond)
[17:03:55.337]                 })
[17:03:55.337]             }))
[17:03:55.337]             future::FutureResult(value = ...future.value$value, 
[17:03:55.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.337]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.337]                     ...future.globalenv.names))
[17:03:55.337]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.337]         }, condition = base::local({
[17:03:55.337]             c <- base::c
[17:03:55.337]             inherits <- base::inherits
[17:03:55.337]             invokeRestart <- base::invokeRestart
[17:03:55.337]             length <- base::length
[17:03:55.337]             list <- base::list
[17:03:55.337]             seq.int <- base::seq.int
[17:03:55.337]             signalCondition <- base::signalCondition
[17:03:55.337]             sys.calls <- base::sys.calls
[17:03:55.337]             `[[` <- base::`[[`
[17:03:55.337]             `+` <- base::`+`
[17:03:55.337]             `<<-` <- base::`<<-`
[17:03:55.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.337]                   3L)]
[17:03:55.337]             }
[17:03:55.337]             function(cond) {
[17:03:55.337]                 is_error <- inherits(cond, "error")
[17:03:55.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.337]                   NULL)
[17:03:55.337]                 if (is_error) {
[17:03:55.337]                   sessionInformation <- function() {
[17:03:55.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.337]                       search = base::search(), system = base::Sys.info())
[17:03:55.337]                   }
[17:03:55.337]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.337]                     cond$call), session = sessionInformation(), 
[17:03:55.337]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.337]                   signalCondition(cond)
[17:03:55.337]                 }
[17:03:55.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.337]                 "immediateCondition"))) {
[17:03:55.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.337]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.337]                   if (TRUE && !signal) {
[17:03:55.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.337]                     {
[17:03:55.337]                       inherits <- base::inherits
[17:03:55.337]                       invokeRestart <- base::invokeRestart
[17:03:55.337]                       is.null <- base::is.null
[17:03:55.337]                       muffled <- FALSE
[17:03:55.337]                       if (inherits(cond, "message")) {
[17:03:55.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.337]                         if (muffled) 
[17:03:55.337]                           invokeRestart("muffleMessage")
[17:03:55.337]                       }
[17:03:55.337]                       else if (inherits(cond, "warning")) {
[17:03:55.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.337]                         if (muffled) 
[17:03:55.337]                           invokeRestart("muffleWarning")
[17:03:55.337]                       }
[17:03:55.337]                       else if (inherits(cond, "condition")) {
[17:03:55.337]                         if (!is.null(pattern)) {
[17:03:55.337]                           computeRestarts <- base::computeRestarts
[17:03:55.337]                           grepl <- base::grepl
[17:03:55.337]                           restarts <- computeRestarts(cond)
[17:03:55.337]                           for (restart in restarts) {
[17:03:55.337]                             name <- restart$name
[17:03:55.337]                             if (is.null(name)) 
[17:03:55.337]                               next
[17:03:55.337]                             if (!grepl(pattern, name)) 
[17:03:55.337]                               next
[17:03:55.337]                             invokeRestart(restart)
[17:03:55.337]                             muffled <- TRUE
[17:03:55.337]                             break
[17:03:55.337]                           }
[17:03:55.337]                         }
[17:03:55.337]                       }
[17:03:55.337]                       invisible(muffled)
[17:03:55.337]                     }
[17:03:55.337]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.337]                   }
[17:03:55.337]                 }
[17:03:55.337]                 else {
[17:03:55.337]                   if (TRUE) {
[17:03:55.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.337]                     {
[17:03:55.337]                       inherits <- base::inherits
[17:03:55.337]                       invokeRestart <- base::invokeRestart
[17:03:55.337]                       is.null <- base::is.null
[17:03:55.337]                       muffled <- FALSE
[17:03:55.337]                       if (inherits(cond, "message")) {
[17:03:55.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.337]                         if (muffled) 
[17:03:55.337]                           invokeRestart("muffleMessage")
[17:03:55.337]                       }
[17:03:55.337]                       else if (inherits(cond, "warning")) {
[17:03:55.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.337]                         if (muffled) 
[17:03:55.337]                           invokeRestart("muffleWarning")
[17:03:55.337]                       }
[17:03:55.337]                       else if (inherits(cond, "condition")) {
[17:03:55.337]                         if (!is.null(pattern)) {
[17:03:55.337]                           computeRestarts <- base::computeRestarts
[17:03:55.337]                           grepl <- base::grepl
[17:03:55.337]                           restarts <- computeRestarts(cond)
[17:03:55.337]                           for (restart in restarts) {
[17:03:55.337]                             name <- restart$name
[17:03:55.337]                             if (is.null(name)) 
[17:03:55.337]                               next
[17:03:55.337]                             if (!grepl(pattern, name)) 
[17:03:55.337]                               next
[17:03:55.337]                             invokeRestart(restart)
[17:03:55.337]                             muffled <- TRUE
[17:03:55.337]                             break
[17:03:55.337]                           }
[17:03:55.337]                         }
[17:03:55.337]                       }
[17:03:55.337]                       invisible(muffled)
[17:03:55.337]                     }
[17:03:55.337]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.337]                   }
[17:03:55.337]                 }
[17:03:55.337]             }
[17:03:55.337]         }))
[17:03:55.337]     }, error = function(ex) {
[17:03:55.337]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.337]                 ...future.rng), started = ...future.startTime, 
[17:03:55.337]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.337]             version = "1.8"), class = "FutureResult")
[17:03:55.337]     }, finally = {
[17:03:55.337]         if (!identical(...future.workdir, getwd())) 
[17:03:55.337]             setwd(...future.workdir)
[17:03:55.337]         {
[17:03:55.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.337]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.337]             }
[17:03:55.337]             base::options(...future.oldOptions)
[17:03:55.337]             if (.Platform$OS.type == "windows") {
[17:03:55.337]                 old_names <- names(...future.oldEnvVars)
[17:03:55.337]                 envs <- base::Sys.getenv()
[17:03:55.337]                 names <- names(envs)
[17:03:55.337]                 common <- intersect(names, old_names)
[17:03:55.337]                 added <- setdiff(names, old_names)
[17:03:55.337]                 removed <- setdiff(old_names, names)
[17:03:55.337]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.337]                   envs[common]]
[17:03:55.337]                 NAMES <- toupper(changed)
[17:03:55.337]                 args <- list()
[17:03:55.337]                 for (kk in seq_along(NAMES)) {
[17:03:55.337]                   name <- changed[[kk]]
[17:03:55.337]                   NAME <- NAMES[[kk]]
[17:03:55.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.337]                     next
[17:03:55.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.337]                 }
[17:03:55.337]                 NAMES <- toupper(added)
[17:03:55.337]                 for (kk in seq_along(NAMES)) {
[17:03:55.337]                   name <- added[[kk]]
[17:03:55.337]                   NAME <- NAMES[[kk]]
[17:03:55.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.337]                     next
[17:03:55.337]                   args[[name]] <- ""
[17:03:55.337]                 }
[17:03:55.337]                 NAMES <- toupper(removed)
[17:03:55.337]                 for (kk in seq_along(NAMES)) {
[17:03:55.337]                   name <- removed[[kk]]
[17:03:55.337]                   NAME <- NAMES[[kk]]
[17:03:55.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.337]                     next
[17:03:55.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.337]                 }
[17:03:55.337]                 if (length(args) > 0) 
[17:03:55.337]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.337]             }
[17:03:55.337]             else {
[17:03:55.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.337]             }
[17:03:55.337]             {
[17:03:55.337]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.337]                   0L) {
[17:03:55.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.337]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.337]                   base::options(opts)
[17:03:55.337]                 }
[17:03:55.337]                 {
[17:03:55.337]                   {
[17:03:55.337]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.337]                     NULL
[17:03:55.337]                   }
[17:03:55.337]                   options(future.plan = NULL)
[17:03:55.337]                   if (is.na(NA_character_)) 
[17:03:55.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.337]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.337]                     .init = FALSE)
[17:03:55.337]                 }
[17:03:55.337]             }
[17:03:55.337]         }
[17:03:55.337]     })
[17:03:55.337]     if (TRUE) {
[17:03:55.337]         base::sink(type = "output", split = FALSE)
[17:03:55.337]         if (TRUE) {
[17:03:55.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.337]         }
[17:03:55.337]         else {
[17:03:55.337]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.337]         }
[17:03:55.337]         base::close(...future.stdout)
[17:03:55.337]         ...future.stdout <- NULL
[17:03:55.337]     }
[17:03:55.337]     ...future.result$conditions <- ...future.conditions
[17:03:55.337]     ...future.result$finished <- base::Sys.time()
[17:03:55.337]     ...future.result
[17:03:55.337] }
[17:03:55.340] MultisessionFuture started
[17:03:55.341] - Launch lazy future ... done
[17:03:55.341] run() for ‘MultisessionFuture’ ... done
[17:03:55.341] getGlobalsAndPackages() ...
[17:03:55.341] Searching for globals...
[17:03:55.342] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:03:55.342] Searching for globals ... DONE
[17:03:55.342] Resolving globals: FALSE
[17:03:55.342] 
[17:03:55.343] 
[17:03:55.343] getGlobalsAndPackages() ... DONE
[17:03:55.343] run() for ‘Future’ ...
[17:03:55.343] - state: ‘created’
[17:03:55.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.357]   - Field: ‘node’
[17:03:55.357]   - Field: ‘label’
[17:03:55.357]   - Field: ‘local’
[17:03:55.357]   - Field: ‘owner’
[17:03:55.357]   - Field: ‘envir’
[17:03:55.357]   - Field: ‘workers’
[17:03:55.358]   - Field: ‘packages’
[17:03:55.360]   - Field: ‘gc’
[17:03:55.360]   - Field: ‘conditions’
[17:03:55.361]   - Field: ‘persistent’
[17:03:55.361]   - Field: ‘expr’
[17:03:55.361]   - Field: ‘uuid’
[17:03:55.361]   - Field: ‘seed’
[17:03:55.361]   - Field: ‘version’
[17:03:55.361]   - Field: ‘result’
[17:03:55.361]   - Field: ‘asynchronous’
[17:03:55.361]   - Field: ‘calls’
[17:03:55.361]   - Field: ‘globals’
[17:03:55.361]   - Field: ‘stdout’
[17:03:55.362]   - Field: ‘earlySignal’
[17:03:55.362]   - Field: ‘lazy’
[17:03:55.362]   - Field: ‘state’
[17:03:55.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.362] - Launch lazy future ...
[17:03:55.362] Packages needed by the future expression (n = 0): <none>
[17:03:55.362] Packages needed by future strategies (n = 0): <none>
[17:03:55.363] {
[17:03:55.363]     {
[17:03:55.363]         {
[17:03:55.363]             ...future.startTime <- base::Sys.time()
[17:03:55.363]             {
[17:03:55.363]                 {
[17:03:55.363]                   {
[17:03:55.363]                     {
[17:03:55.363]                       base::local({
[17:03:55.363]                         has_future <- base::requireNamespace("future", 
[17:03:55.363]                           quietly = TRUE)
[17:03:55.363]                         if (has_future) {
[17:03:55.363]                           ns <- base::getNamespace("future")
[17:03:55.363]                           version <- ns[[".package"]][["version"]]
[17:03:55.363]                           if (is.null(version)) 
[17:03:55.363]                             version <- utils::packageVersion("future")
[17:03:55.363]                         }
[17:03:55.363]                         else {
[17:03:55.363]                           version <- NULL
[17:03:55.363]                         }
[17:03:55.363]                         if (!has_future || version < "1.8.0") {
[17:03:55.363]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.363]                             "", base::R.version$version.string), 
[17:03:55.363]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.363]                               "release", "version")], collapse = " "), 
[17:03:55.363]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.363]                             info)
[17:03:55.363]                           info <- base::paste(info, collapse = "; ")
[17:03:55.363]                           if (!has_future) {
[17:03:55.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.363]                               info)
[17:03:55.363]                           }
[17:03:55.363]                           else {
[17:03:55.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.363]                               info, version)
[17:03:55.363]                           }
[17:03:55.363]                           base::stop(msg)
[17:03:55.363]                         }
[17:03:55.363]                       })
[17:03:55.363]                     }
[17:03:55.363]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.363]                     base::options(mc.cores = 1L)
[17:03:55.363]                   }
[17:03:55.363]                   ...future.strategy.old <- future::plan("list")
[17:03:55.363]                   options(future.plan = NULL)
[17:03:55.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.363]                 }
[17:03:55.363]                 ...future.workdir <- getwd()
[17:03:55.363]             }
[17:03:55.363]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.363]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.363]         }
[17:03:55.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.363]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.363]             base::names(...future.oldOptions))
[17:03:55.363]     }
[17:03:55.363]     if (FALSE) {
[17:03:55.363]     }
[17:03:55.363]     else {
[17:03:55.363]         if (TRUE) {
[17:03:55.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.363]                 open = "w")
[17:03:55.363]         }
[17:03:55.363]         else {
[17:03:55.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.363]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.363]         }
[17:03:55.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.363]             base::sink(type = "output", split = FALSE)
[17:03:55.363]             base::close(...future.stdout)
[17:03:55.363]         }, add = TRUE)
[17:03:55.363]     }
[17:03:55.363]     ...future.frame <- base::sys.nframe()
[17:03:55.363]     ...future.conditions <- base::list()
[17:03:55.363]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.363]     if (FALSE) {
[17:03:55.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.363]     }
[17:03:55.363]     ...future.result <- base::tryCatch({
[17:03:55.363]         base::withCallingHandlers({
[17:03:55.363]             ...future.value <- base::withVisible(base::local({
[17:03:55.363]                 ...future.makeSendCondition <- base::local({
[17:03:55.363]                   sendCondition <- NULL
[17:03:55.363]                   function(frame = 1L) {
[17:03:55.363]                     if (is.function(sendCondition)) 
[17:03:55.363]                       return(sendCondition)
[17:03:55.363]                     ns <- getNamespace("parallel")
[17:03:55.363]                     if (exists("sendData", mode = "function", 
[17:03:55.363]                       envir = ns)) {
[17:03:55.363]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.363]                         envir = ns)
[17:03:55.363]                       envir <- sys.frame(frame)
[17:03:55.363]                       master <- NULL
[17:03:55.363]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.363]                         !identical(envir, emptyenv())) {
[17:03:55.363]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.363]                           inherits = FALSE)) {
[17:03:55.363]                           master <- get("master", mode = "list", 
[17:03:55.363]                             envir = envir, inherits = FALSE)
[17:03:55.363]                           if (inherits(master, c("SOCKnode", 
[17:03:55.363]                             "SOCK0node"))) {
[17:03:55.363]                             sendCondition <<- function(cond) {
[17:03:55.363]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.363]                                 success = TRUE)
[17:03:55.363]                               parallel_sendData(master, data)
[17:03:55.363]                             }
[17:03:55.363]                             return(sendCondition)
[17:03:55.363]                           }
[17:03:55.363]                         }
[17:03:55.363]                         frame <- frame + 1L
[17:03:55.363]                         envir <- sys.frame(frame)
[17:03:55.363]                       }
[17:03:55.363]                     }
[17:03:55.363]                     sendCondition <<- function(cond) NULL
[17:03:55.363]                   }
[17:03:55.363]                 })
[17:03:55.363]                 withCallingHandlers({
[17:03:55.363]                   {
[17:03:55.363]                     Sys.sleep(0.5)
[17:03:55.363]                     2
[17:03:55.363]                   }
[17:03:55.363]                 }, immediateCondition = function(cond) {
[17:03:55.363]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.363]                   sendCondition(cond)
[17:03:55.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.363]                   {
[17:03:55.363]                     inherits <- base::inherits
[17:03:55.363]                     invokeRestart <- base::invokeRestart
[17:03:55.363]                     is.null <- base::is.null
[17:03:55.363]                     muffled <- FALSE
[17:03:55.363]                     if (inherits(cond, "message")) {
[17:03:55.363]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.363]                       if (muffled) 
[17:03:55.363]                         invokeRestart("muffleMessage")
[17:03:55.363]                     }
[17:03:55.363]                     else if (inherits(cond, "warning")) {
[17:03:55.363]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.363]                       if (muffled) 
[17:03:55.363]                         invokeRestart("muffleWarning")
[17:03:55.363]                     }
[17:03:55.363]                     else if (inherits(cond, "condition")) {
[17:03:55.363]                       if (!is.null(pattern)) {
[17:03:55.363]                         computeRestarts <- base::computeRestarts
[17:03:55.363]                         grepl <- base::grepl
[17:03:55.363]                         restarts <- computeRestarts(cond)
[17:03:55.363]                         for (restart in restarts) {
[17:03:55.363]                           name <- restart$name
[17:03:55.363]                           if (is.null(name)) 
[17:03:55.363]                             next
[17:03:55.363]                           if (!grepl(pattern, name)) 
[17:03:55.363]                             next
[17:03:55.363]                           invokeRestart(restart)
[17:03:55.363]                           muffled <- TRUE
[17:03:55.363]                           break
[17:03:55.363]                         }
[17:03:55.363]                       }
[17:03:55.363]                     }
[17:03:55.363]                     invisible(muffled)
[17:03:55.363]                   }
[17:03:55.363]                   muffleCondition(cond)
[17:03:55.363]                 })
[17:03:55.363]             }))
[17:03:55.363]             future::FutureResult(value = ...future.value$value, 
[17:03:55.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.363]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.363]                     ...future.globalenv.names))
[17:03:55.363]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.363]         }, condition = base::local({
[17:03:55.363]             c <- base::c
[17:03:55.363]             inherits <- base::inherits
[17:03:55.363]             invokeRestart <- base::invokeRestart
[17:03:55.363]             length <- base::length
[17:03:55.363]             list <- base::list
[17:03:55.363]             seq.int <- base::seq.int
[17:03:55.363]             signalCondition <- base::signalCondition
[17:03:55.363]             sys.calls <- base::sys.calls
[17:03:55.363]             `[[` <- base::`[[`
[17:03:55.363]             `+` <- base::`+`
[17:03:55.363]             `<<-` <- base::`<<-`
[17:03:55.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.363]                   3L)]
[17:03:55.363]             }
[17:03:55.363]             function(cond) {
[17:03:55.363]                 is_error <- inherits(cond, "error")
[17:03:55.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.363]                   NULL)
[17:03:55.363]                 if (is_error) {
[17:03:55.363]                   sessionInformation <- function() {
[17:03:55.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.363]                       search = base::search(), system = base::Sys.info())
[17:03:55.363]                   }
[17:03:55.363]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.363]                     cond$call), session = sessionInformation(), 
[17:03:55.363]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.363]                   signalCondition(cond)
[17:03:55.363]                 }
[17:03:55.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.363]                 "immediateCondition"))) {
[17:03:55.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.363]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.363]                   if (TRUE && !signal) {
[17:03:55.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.363]                     {
[17:03:55.363]                       inherits <- base::inherits
[17:03:55.363]                       invokeRestart <- base::invokeRestart
[17:03:55.363]                       is.null <- base::is.null
[17:03:55.363]                       muffled <- FALSE
[17:03:55.363]                       if (inherits(cond, "message")) {
[17:03:55.363]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.363]                         if (muffled) 
[17:03:55.363]                           invokeRestart("muffleMessage")
[17:03:55.363]                       }
[17:03:55.363]                       else if (inherits(cond, "warning")) {
[17:03:55.363]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.363]                         if (muffled) 
[17:03:55.363]                           invokeRestart("muffleWarning")
[17:03:55.363]                       }
[17:03:55.363]                       else if (inherits(cond, "condition")) {
[17:03:55.363]                         if (!is.null(pattern)) {
[17:03:55.363]                           computeRestarts <- base::computeRestarts
[17:03:55.363]                           grepl <- base::grepl
[17:03:55.363]                           restarts <- computeRestarts(cond)
[17:03:55.363]                           for (restart in restarts) {
[17:03:55.363]                             name <- restart$name
[17:03:55.363]                             if (is.null(name)) 
[17:03:55.363]                               next
[17:03:55.363]                             if (!grepl(pattern, name)) 
[17:03:55.363]                               next
[17:03:55.363]                             invokeRestart(restart)
[17:03:55.363]                             muffled <- TRUE
[17:03:55.363]                             break
[17:03:55.363]                           }
[17:03:55.363]                         }
[17:03:55.363]                       }
[17:03:55.363]                       invisible(muffled)
[17:03:55.363]                     }
[17:03:55.363]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.363]                   }
[17:03:55.363]                 }
[17:03:55.363]                 else {
[17:03:55.363]                   if (TRUE) {
[17:03:55.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.363]                     {
[17:03:55.363]                       inherits <- base::inherits
[17:03:55.363]                       invokeRestart <- base::invokeRestart
[17:03:55.363]                       is.null <- base::is.null
[17:03:55.363]                       muffled <- FALSE
[17:03:55.363]                       if (inherits(cond, "message")) {
[17:03:55.363]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.363]                         if (muffled) 
[17:03:55.363]                           invokeRestart("muffleMessage")
[17:03:55.363]                       }
[17:03:55.363]                       else if (inherits(cond, "warning")) {
[17:03:55.363]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.363]                         if (muffled) 
[17:03:55.363]                           invokeRestart("muffleWarning")
[17:03:55.363]                       }
[17:03:55.363]                       else if (inherits(cond, "condition")) {
[17:03:55.363]                         if (!is.null(pattern)) {
[17:03:55.363]                           computeRestarts <- base::computeRestarts
[17:03:55.363]                           grepl <- base::grepl
[17:03:55.363]                           restarts <- computeRestarts(cond)
[17:03:55.363]                           for (restart in restarts) {
[17:03:55.363]                             name <- restart$name
[17:03:55.363]                             if (is.null(name)) 
[17:03:55.363]                               next
[17:03:55.363]                             if (!grepl(pattern, name)) 
[17:03:55.363]                               next
[17:03:55.363]                             invokeRestart(restart)
[17:03:55.363]                             muffled <- TRUE
[17:03:55.363]                             break
[17:03:55.363]                           }
[17:03:55.363]                         }
[17:03:55.363]                       }
[17:03:55.363]                       invisible(muffled)
[17:03:55.363]                     }
[17:03:55.363]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.363]                   }
[17:03:55.363]                 }
[17:03:55.363]             }
[17:03:55.363]         }))
[17:03:55.363]     }, error = function(ex) {
[17:03:55.363]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.363]                 ...future.rng), started = ...future.startTime, 
[17:03:55.363]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.363]             version = "1.8"), class = "FutureResult")
[17:03:55.363]     }, finally = {
[17:03:55.363]         if (!identical(...future.workdir, getwd())) 
[17:03:55.363]             setwd(...future.workdir)
[17:03:55.363]         {
[17:03:55.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.363]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.363]             }
[17:03:55.363]             base::options(...future.oldOptions)
[17:03:55.363]             if (.Platform$OS.type == "windows") {
[17:03:55.363]                 old_names <- names(...future.oldEnvVars)
[17:03:55.363]                 envs <- base::Sys.getenv()
[17:03:55.363]                 names <- names(envs)
[17:03:55.363]                 common <- intersect(names, old_names)
[17:03:55.363]                 added <- setdiff(names, old_names)
[17:03:55.363]                 removed <- setdiff(old_names, names)
[17:03:55.363]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.363]                   envs[common]]
[17:03:55.363]                 NAMES <- toupper(changed)
[17:03:55.363]                 args <- list()
[17:03:55.363]                 for (kk in seq_along(NAMES)) {
[17:03:55.363]                   name <- changed[[kk]]
[17:03:55.363]                   NAME <- NAMES[[kk]]
[17:03:55.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.363]                     next
[17:03:55.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.363]                 }
[17:03:55.363]                 NAMES <- toupper(added)
[17:03:55.363]                 for (kk in seq_along(NAMES)) {
[17:03:55.363]                   name <- added[[kk]]
[17:03:55.363]                   NAME <- NAMES[[kk]]
[17:03:55.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.363]                     next
[17:03:55.363]                   args[[name]] <- ""
[17:03:55.363]                 }
[17:03:55.363]                 NAMES <- toupper(removed)
[17:03:55.363]                 for (kk in seq_along(NAMES)) {
[17:03:55.363]                   name <- removed[[kk]]
[17:03:55.363]                   NAME <- NAMES[[kk]]
[17:03:55.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.363]                     next
[17:03:55.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.363]                 }
[17:03:55.363]                 if (length(args) > 0) 
[17:03:55.363]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.363]             }
[17:03:55.363]             else {
[17:03:55.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.363]             }
[17:03:55.363]             {
[17:03:55.363]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.363]                   0L) {
[17:03:55.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.363]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.363]                   base::options(opts)
[17:03:55.363]                 }
[17:03:55.363]                 {
[17:03:55.363]                   {
[17:03:55.363]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.363]                     NULL
[17:03:55.363]                   }
[17:03:55.363]                   options(future.plan = NULL)
[17:03:55.363]                   if (is.na(NA_character_)) 
[17:03:55.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.363]                     .init = FALSE)
[17:03:55.363]                 }
[17:03:55.363]             }
[17:03:55.363]         }
[17:03:55.363]     })
[17:03:55.363]     if (TRUE) {
[17:03:55.363]         base::sink(type = "output", split = FALSE)
[17:03:55.363]         if (TRUE) {
[17:03:55.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.363]         }
[17:03:55.363]         else {
[17:03:55.363]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.363]         }
[17:03:55.363]         base::close(...future.stdout)
[17:03:55.363]         ...future.stdout <- NULL
[17:03:55.363]     }
[17:03:55.363]     ...future.result$conditions <- ...future.conditions
[17:03:55.363]     ...future.result$finished <- base::Sys.time()
[17:03:55.363]     ...future.result
[17:03:55.363] }
[17:03:55.366] MultisessionFuture started
[17:03:55.366] - Launch lazy future ... done
[17:03:55.366] run() for ‘MultisessionFuture’ ... done
[17:03:55.366] resolve() on list ...
[17:03:55.366]  recursive: 0
[17:03:55.366]  length: 1
[17:03:55.367] 
[17:03:55.367] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.367] - Validating connection of MultisessionFuture
[17:03:55.367] - received message: FutureResult
[17:03:55.367] - Received FutureResult
[17:03:55.367] - Erased future from FutureRegistry
[17:03:55.368] result() for ClusterFuture ...
[17:03:55.368] - result already collected: FutureResult
[17:03:55.368] result() for ClusterFuture ... done
[17:03:55.368] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.368] Future #1
[17:03:55.368]  length: 0 (resolved future 1)
[17:03:55.368] resolve() on list ... DONE
[17:03:55.368] resolve() on list ...
[17:03:55.368]  recursive: 0
[17:03:55.369]  length: 1
[17:03:55.369] 
[17:03:55.868] receiveMessageFromWorker() for ClusterFuture ...
[17:03:55.868] - Validating connection of MultisessionFuture
[17:03:55.869] - received message: FutureResult
[17:03:55.869] - Received FutureResult
[17:03:55.869] - Erased future from FutureRegistry
[17:03:55.869] result() for ClusterFuture ...
[17:03:55.869] - result already collected: FutureResult
[17:03:55.869] result() for ClusterFuture ... done
[17:03:55.869] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:55.870] Future #1
[17:03:55.870]  length: 0 (resolved future 1)
[17:03:55.870] resolve() on list ... DONE
[17:03:55.870] resolve() on list ...
[17:03:55.870]  recursive: 0
[17:03:55.870]  length: 1
[17:03:55.870] 
[17:03:55.870]  length: 0 (resolved future 1)
[17:03:55.870] resolve() on list ... DONE
[17:03:55.871] resolve() on list ...
[17:03:55.871]  recursive: 0
[17:03:55.871]  length: 4
[17:03:55.871] 
[17:03:55.871] Future #1
[17:03:55.871]  length: 3 (resolved future 1)
[17:03:55.871] Future #2
[17:03:55.871]  length: 2 (resolved future 2)
[17:03:55.871]  length: 1 (resolved future 3)
[17:03:55.872]  length: 0 (resolved future 4)
[17:03:55.872] resolve() on list ... DONE
[17:03:55.872] resolve() on list ...
[17:03:55.872]  recursive: 0
[17:03:55.872]  length: 4
[17:03:55.872] 
[17:03:55.872] Future #1
[17:03:55.872]  length: 3 (resolved future 1)
[17:03:55.872] Future #2
[17:03:55.872]  length: 2 (resolved future 2)
[17:03:55.872]  length: 1 (resolved future 3)
[17:03:55.873]  length: 0 (resolved future 4)
[17:03:55.873] resolve() on list ... DONE
[17:03:55.873] resolve() on list ...
[17:03:55.873]  recursive: 0
[17:03:55.873]  length: 1
[17:03:55.873] 
[17:03:55.873]  length: 0 (resolved future 1)
[17:03:55.873] resolve() on list ... DONE
[17:03:55.873] getGlobalsAndPackages() ...
[17:03:55.873] Searching for globals...
[17:03:55.874] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:55.875] Searching for globals ... DONE
[17:03:55.875] Resolving globals: FALSE
[17:03:55.875] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:55.875] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:55.876] - globals: [1] ‘kk’
[17:03:55.876] 
[17:03:55.876] getGlobalsAndPackages() ... DONE
[17:03:55.876] run() for ‘Future’ ...
[17:03:55.876] - state: ‘created’
[17:03:55.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.891] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.891]   - Field: ‘node’
[17:03:55.892]   - Field: ‘label’
[17:03:55.892]   - Field: ‘local’
[17:03:55.892]   - Field: ‘owner’
[17:03:55.892]   - Field: ‘envir’
[17:03:55.892]   - Field: ‘workers’
[17:03:55.892]   - Field: ‘packages’
[17:03:55.892]   - Field: ‘gc’
[17:03:55.892]   - Field: ‘conditions’
[17:03:55.892]   - Field: ‘persistent’
[17:03:55.892]   - Field: ‘expr’
[17:03:55.892]   - Field: ‘uuid’
[17:03:55.893]   - Field: ‘seed’
[17:03:55.893]   - Field: ‘version’
[17:03:55.893]   - Field: ‘result’
[17:03:55.893]   - Field: ‘asynchronous’
[17:03:55.893]   - Field: ‘calls’
[17:03:55.893]   - Field: ‘globals’
[17:03:55.893]   - Field: ‘stdout’
[17:03:55.893]   - Field: ‘earlySignal’
[17:03:55.893]   - Field: ‘lazy’
[17:03:55.893]   - Field: ‘state’
[17:03:55.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.894] - Launch lazy future ...
[17:03:55.894] Packages needed by the future expression (n = 0): <none>
[17:03:55.894] Packages needed by future strategies (n = 0): <none>
[17:03:55.894] {
[17:03:55.894]     {
[17:03:55.894]         {
[17:03:55.894]             ...future.startTime <- base::Sys.time()
[17:03:55.894]             {
[17:03:55.894]                 {
[17:03:55.894]                   {
[17:03:55.894]                     {
[17:03:55.894]                       base::local({
[17:03:55.894]                         has_future <- base::requireNamespace("future", 
[17:03:55.894]                           quietly = TRUE)
[17:03:55.894]                         if (has_future) {
[17:03:55.894]                           ns <- base::getNamespace("future")
[17:03:55.894]                           version <- ns[[".package"]][["version"]]
[17:03:55.894]                           if (is.null(version)) 
[17:03:55.894]                             version <- utils::packageVersion("future")
[17:03:55.894]                         }
[17:03:55.894]                         else {
[17:03:55.894]                           version <- NULL
[17:03:55.894]                         }
[17:03:55.894]                         if (!has_future || version < "1.8.0") {
[17:03:55.894]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.894]                             "", base::R.version$version.string), 
[17:03:55.894]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.894]                               "release", "version")], collapse = " "), 
[17:03:55.894]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.894]                             info)
[17:03:55.894]                           info <- base::paste(info, collapse = "; ")
[17:03:55.894]                           if (!has_future) {
[17:03:55.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.894]                               info)
[17:03:55.894]                           }
[17:03:55.894]                           else {
[17:03:55.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.894]                               info, version)
[17:03:55.894]                           }
[17:03:55.894]                           base::stop(msg)
[17:03:55.894]                         }
[17:03:55.894]                       })
[17:03:55.894]                     }
[17:03:55.894]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.894]                     base::options(mc.cores = 1L)
[17:03:55.894]                   }
[17:03:55.894]                   ...future.strategy.old <- future::plan("list")
[17:03:55.894]                   options(future.plan = NULL)
[17:03:55.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.894]                 }
[17:03:55.894]                 ...future.workdir <- getwd()
[17:03:55.894]             }
[17:03:55.894]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.894]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.894]         }
[17:03:55.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.894]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.894]             base::names(...future.oldOptions))
[17:03:55.894]     }
[17:03:55.894]     if (FALSE) {
[17:03:55.894]     }
[17:03:55.894]     else {
[17:03:55.894]         if (TRUE) {
[17:03:55.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.894]                 open = "w")
[17:03:55.894]         }
[17:03:55.894]         else {
[17:03:55.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.894]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.894]         }
[17:03:55.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.894]             base::sink(type = "output", split = FALSE)
[17:03:55.894]             base::close(...future.stdout)
[17:03:55.894]         }, add = TRUE)
[17:03:55.894]     }
[17:03:55.894]     ...future.frame <- base::sys.nframe()
[17:03:55.894]     ...future.conditions <- base::list()
[17:03:55.894]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.894]     if (FALSE) {
[17:03:55.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.894]     }
[17:03:55.894]     ...future.result <- base::tryCatch({
[17:03:55.894]         base::withCallingHandlers({
[17:03:55.894]             ...future.value <- base::withVisible(base::local({
[17:03:55.894]                 ...future.makeSendCondition <- base::local({
[17:03:55.894]                   sendCondition <- NULL
[17:03:55.894]                   function(frame = 1L) {
[17:03:55.894]                     if (is.function(sendCondition)) 
[17:03:55.894]                       return(sendCondition)
[17:03:55.894]                     ns <- getNamespace("parallel")
[17:03:55.894]                     if (exists("sendData", mode = "function", 
[17:03:55.894]                       envir = ns)) {
[17:03:55.894]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.894]                         envir = ns)
[17:03:55.894]                       envir <- sys.frame(frame)
[17:03:55.894]                       master <- NULL
[17:03:55.894]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.894]                         !identical(envir, emptyenv())) {
[17:03:55.894]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.894]                           inherits = FALSE)) {
[17:03:55.894]                           master <- get("master", mode = "list", 
[17:03:55.894]                             envir = envir, inherits = FALSE)
[17:03:55.894]                           if (inherits(master, c("SOCKnode", 
[17:03:55.894]                             "SOCK0node"))) {
[17:03:55.894]                             sendCondition <<- function(cond) {
[17:03:55.894]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.894]                                 success = TRUE)
[17:03:55.894]                               parallel_sendData(master, data)
[17:03:55.894]                             }
[17:03:55.894]                             return(sendCondition)
[17:03:55.894]                           }
[17:03:55.894]                         }
[17:03:55.894]                         frame <- frame + 1L
[17:03:55.894]                         envir <- sys.frame(frame)
[17:03:55.894]                       }
[17:03:55.894]                     }
[17:03:55.894]                     sendCondition <<- function(cond) NULL
[17:03:55.894]                   }
[17:03:55.894]                 })
[17:03:55.894]                 withCallingHandlers({
[17:03:55.894]                   {
[17:03:55.894]                     Sys.sleep(0.1)
[17:03:55.894]                     kk
[17:03:55.894]                   }
[17:03:55.894]                 }, immediateCondition = function(cond) {
[17:03:55.894]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.894]                   sendCondition(cond)
[17:03:55.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.894]                   {
[17:03:55.894]                     inherits <- base::inherits
[17:03:55.894]                     invokeRestart <- base::invokeRestart
[17:03:55.894]                     is.null <- base::is.null
[17:03:55.894]                     muffled <- FALSE
[17:03:55.894]                     if (inherits(cond, "message")) {
[17:03:55.894]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.894]                       if (muffled) 
[17:03:55.894]                         invokeRestart("muffleMessage")
[17:03:55.894]                     }
[17:03:55.894]                     else if (inherits(cond, "warning")) {
[17:03:55.894]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.894]                       if (muffled) 
[17:03:55.894]                         invokeRestart("muffleWarning")
[17:03:55.894]                     }
[17:03:55.894]                     else if (inherits(cond, "condition")) {
[17:03:55.894]                       if (!is.null(pattern)) {
[17:03:55.894]                         computeRestarts <- base::computeRestarts
[17:03:55.894]                         grepl <- base::grepl
[17:03:55.894]                         restarts <- computeRestarts(cond)
[17:03:55.894]                         for (restart in restarts) {
[17:03:55.894]                           name <- restart$name
[17:03:55.894]                           if (is.null(name)) 
[17:03:55.894]                             next
[17:03:55.894]                           if (!grepl(pattern, name)) 
[17:03:55.894]                             next
[17:03:55.894]                           invokeRestart(restart)
[17:03:55.894]                           muffled <- TRUE
[17:03:55.894]                           break
[17:03:55.894]                         }
[17:03:55.894]                       }
[17:03:55.894]                     }
[17:03:55.894]                     invisible(muffled)
[17:03:55.894]                   }
[17:03:55.894]                   muffleCondition(cond)
[17:03:55.894]                 })
[17:03:55.894]             }))
[17:03:55.894]             future::FutureResult(value = ...future.value$value, 
[17:03:55.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.894]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.894]                     ...future.globalenv.names))
[17:03:55.894]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.894]         }, condition = base::local({
[17:03:55.894]             c <- base::c
[17:03:55.894]             inherits <- base::inherits
[17:03:55.894]             invokeRestart <- base::invokeRestart
[17:03:55.894]             length <- base::length
[17:03:55.894]             list <- base::list
[17:03:55.894]             seq.int <- base::seq.int
[17:03:55.894]             signalCondition <- base::signalCondition
[17:03:55.894]             sys.calls <- base::sys.calls
[17:03:55.894]             `[[` <- base::`[[`
[17:03:55.894]             `+` <- base::`+`
[17:03:55.894]             `<<-` <- base::`<<-`
[17:03:55.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.894]                   3L)]
[17:03:55.894]             }
[17:03:55.894]             function(cond) {
[17:03:55.894]                 is_error <- inherits(cond, "error")
[17:03:55.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.894]                   NULL)
[17:03:55.894]                 if (is_error) {
[17:03:55.894]                   sessionInformation <- function() {
[17:03:55.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.894]                       search = base::search(), system = base::Sys.info())
[17:03:55.894]                   }
[17:03:55.894]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.894]                     cond$call), session = sessionInformation(), 
[17:03:55.894]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.894]                   signalCondition(cond)
[17:03:55.894]                 }
[17:03:55.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.894]                 "immediateCondition"))) {
[17:03:55.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.894]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.894]                   if (TRUE && !signal) {
[17:03:55.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.894]                     {
[17:03:55.894]                       inherits <- base::inherits
[17:03:55.894]                       invokeRestart <- base::invokeRestart
[17:03:55.894]                       is.null <- base::is.null
[17:03:55.894]                       muffled <- FALSE
[17:03:55.894]                       if (inherits(cond, "message")) {
[17:03:55.894]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.894]                         if (muffled) 
[17:03:55.894]                           invokeRestart("muffleMessage")
[17:03:55.894]                       }
[17:03:55.894]                       else if (inherits(cond, "warning")) {
[17:03:55.894]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.894]                         if (muffled) 
[17:03:55.894]                           invokeRestart("muffleWarning")
[17:03:55.894]                       }
[17:03:55.894]                       else if (inherits(cond, "condition")) {
[17:03:55.894]                         if (!is.null(pattern)) {
[17:03:55.894]                           computeRestarts <- base::computeRestarts
[17:03:55.894]                           grepl <- base::grepl
[17:03:55.894]                           restarts <- computeRestarts(cond)
[17:03:55.894]                           for (restart in restarts) {
[17:03:55.894]                             name <- restart$name
[17:03:55.894]                             if (is.null(name)) 
[17:03:55.894]                               next
[17:03:55.894]                             if (!grepl(pattern, name)) 
[17:03:55.894]                               next
[17:03:55.894]                             invokeRestart(restart)
[17:03:55.894]                             muffled <- TRUE
[17:03:55.894]                             break
[17:03:55.894]                           }
[17:03:55.894]                         }
[17:03:55.894]                       }
[17:03:55.894]                       invisible(muffled)
[17:03:55.894]                     }
[17:03:55.894]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.894]                   }
[17:03:55.894]                 }
[17:03:55.894]                 else {
[17:03:55.894]                   if (TRUE) {
[17:03:55.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.894]                     {
[17:03:55.894]                       inherits <- base::inherits
[17:03:55.894]                       invokeRestart <- base::invokeRestart
[17:03:55.894]                       is.null <- base::is.null
[17:03:55.894]                       muffled <- FALSE
[17:03:55.894]                       if (inherits(cond, "message")) {
[17:03:55.894]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.894]                         if (muffled) 
[17:03:55.894]                           invokeRestart("muffleMessage")
[17:03:55.894]                       }
[17:03:55.894]                       else if (inherits(cond, "warning")) {
[17:03:55.894]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.894]                         if (muffled) 
[17:03:55.894]                           invokeRestart("muffleWarning")
[17:03:55.894]                       }
[17:03:55.894]                       else if (inherits(cond, "condition")) {
[17:03:55.894]                         if (!is.null(pattern)) {
[17:03:55.894]                           computeRestarts <- base::computeRestarts
[17:03:55.894]                           grepl <- base::grepl
[17:03:55.894]                           restarts <- computeRestarts(cond)
[17:03:55.894]                           for (restart in restarts) {
[17:03:55.894]                             name <- restart$name
[17:03:55.894]                             if (is.null(name)) 
[17:03:55.894]                               next
[17:03:55.894]                             if (!grepl(pattern, name)) 
[17:03:55.894]                               next
[17:03:55.894]                             invokeRestart(restart)
[17:03:55.894]                             muffled <- TRUE
[17:03:55.894]                             break
[17:03:55.894]                           }
[17:03:55.894]                         }
[17:03:55.894]                       }
[17:03:55.894]                       invisible(muffled)
[17:03:55.894]                     }
[17:03:55.894]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.894]                   }
[17:03:55.894]                 }
[17:03:55.894]             }
[17:03:55.894]         }))
[17:03:55.894]     }, error = function(ex) {
[17:03:55.894]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.894]                 ...future.rng), started = ...future.startTime, 
[17:03:55.894]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.894]             version = "1.8"), class = "FutureResult")
[17:03:55.894]     }, finally = {
[17:03:55.894]         if (!identical(...future.workdir, getwd())) 
[17:03:55.894]             setwd(...future.workdir)
[17:03:55.894]         {
[17:03:55.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.894]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.894]             }
[17:03:55.894]             base::options(...future.oldOptions)
[17:03:55.894]             if (.Platform$OS.type == "windows") {
[17:03:55.894]                 old_names <- names(...future.oldEnvVars)
[17:03:55.894]                 envs <- base::Sys.getenv()
[17:03:55.894]                 names <- names(envs)
[17:03:55.894]                 common <- intersect(names, old_names)
[17:03:55.894]                 added <- setdiff(names, old_names)
[17:03:55.894]                 removed <- setdiff(old_names, names)
[17:03:55.894]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.894]                   envs[common]]
[17:03:55.894]                 NAMES <- toupper(changed)
[17:03:55.894]                 args <- list()
[17:03:55.894]                 for (kk in seq_along(NAMES)) {
[17:03:55.894]                   name <- changed[[kk]]
[17:03:55.894]                   NAME <- NAMES[[kk]]
[17:03:55.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.894]                     next
[17:03:55.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.894]                 }
[17:03:55.894]                 NAMES <- toupper(added)
[17:03:55.894]                 for (kk in seq_along(NAMES)) {
[17:03:55.894]                   name <- added[[kk]]
[17:03:55.894]                   NAME <- NAMES[[kk]]
[17:03:55.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.894]                     next
[17:03:55.894]                   args[[name]] <- ""
[17:03:55.894]                 }
[17:03:55.894]                 NAMES <- toupper(removed)
[17:03:55.894]                 for (kk in seq_along(NAMES)) {
[17:03:55.894]                   name <- removed[[kk]]
[17:03:55.894]                   NAME <- NAMES[[kk]]
[17:03:55.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.894]                     next
[17:03:55.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.894]                 }
[17:03:55.894]                 if (length(args) > 0) 
[17:03:55.894]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.894]             }
[17:03:55.894]             else {
[17:03:55.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.894]             }
[17:03:55.894]             {
[17:03:55.894]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.894]                   0L) {
[17:03:55.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.894]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.894]                   base::options(opts)
[17:03:55.894]                 }
[17:03:55.894]                 {
[17:03:55.894]                   {
[17:03:55.894]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.894]                     NULL
[17:03:55.894]                   }
[17:03:55.894]                   options(future.plan = NULL)
[17:03:55.894]                   if (is.na(NA_character_)) 
[17:03:55.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.894]                     .init = FALSE)
[17:03:55.894]                 }
[17:03:55.894]             }
[17:03:55.894]         }
[17:03:55.894]     })
[17:03:55.894]     if (TRUE) {
[17:03:55.894]         base::sink(type = "output", split = FALSE)
[17:03:55.894]         if (TRUE) {
[17:03:55.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.894]         }
[17:03:55.894]         else {
[17:03:55.894]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.894]         }
[17:03:55.894]         base::close(...future.stdout)
[17:03:55.894]         ...future.stdout <- NULL
[17:03:55.894]     }
[17:03:55.894]     ...future.result$conditions <- ...future.conditions
[17:03:55.894]     ...future.result$finished <- base::Sys.time()
[17:03:55.894]     ...future.result
[17:03:55.894] }
[17:03:55.897] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:03:55.897] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:03:55.898] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:03:55.898] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:03:55.898] MultisessionFuture started
[17:03:55.898] - Launch lazy future ... done
[17:03:55.898] run() for ‘MultisessionFuture’ ... done
[17:03:55.899] getGlobalsAndPackages() ...
[17:03:55.899] Searching for globals...
[17:03:55.900] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:55.900] Searching for globals ... DONE
[17:03:55.900] Resolving globals: FALSE
[17:03:55.900] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:55.901] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:55.901] - globals: [1] ‘kk’
[17:03:55.901] 
[17:03:55.901] getGlobalsAndPackages() ... DONE
[17:03:55.901] run() for ‘Future’ ...
[17:03:55.901] - state: ‘created’
[17:03:55.901] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.915] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.915]   - Field: ‘node’
[17:03:55.915]   - Field: ‘label’
[17:03:55.915]   - Field: ‘local’
[17:03:55.916]   - Field: ‘owner’
[17:03:55.916]   - Field: ‘envir’
[17:03:55.916]   - Field: ‘workers’
[17:03:55.916]   - Field: ‘packages’
[17:03:55.916]   - Field: ‘gc’
[17:03:55.916]   - Field: ‘conditions’
[17:03:55.916]   - Field: ‘persistent’
[17:03:55.916]   - Field: ‘expr’
[17:03:55.916]   - Field: ‘uuid’
[17:03:55.916]   - Field: ‘seed’
[17:03:55.916]   - Field: ‘version’
[17:03:55.917]   - Field: ‘result’
[17:03:55.917]   - Field: ‘asynchronous’
[17:03:55.917]   - Field: ‘calls’
[17:03:55.917]   - Field: ‘globals’
[17:03:55.917]   - Field: ‘stdout’
[17:03:55.917]   - Field: ‘earlySignal’
[17:03:55.917]   - Field: ‘lazy’
[17:03:55.917]   - Field: ‘state’
[17:03:55.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.917] - Launch lazy future ...
[17:03:55.918] Packages needed by the future expression (n = 0): <none>
[17:03:55.918] Packages needed by future strategies (n = 0): <none>
[17:03:55.918] {
[17:03:55.918]     {
[17:03:55.918]         {
[17:03:55.918]             ...future.startTime <- base::Sys.time()
[17:03:55.918]             {
[17:03:55.918]                 {
[17:03:55.918]                   {
[17:03:55.918]                     {
[17:03:55.918]                       base::local({
[17:03:55.918]                         has_future <- base::requireNamespace("future", 
[17:03:55.918]                           quietly = TRUE)
[17:03:55.918]                         if (has_future) {
[17:03:55.918]                           ns <- base::getNamespace("future")
[17:03:55.918]                           version <- ns[[".package"]][["version"]]
[17:03:55.918]                           if (is.null(version)) 
[17:03:55.918]                             version <- utils::packageVersion("future")
[17:03:55.918]                         }
[17:03:55.918]                         else {
[17:03:55.918]                           version <- NULL
[17:03:55.918]                         }
[17:03:55.918]                         if (!has_future || version < "1.8.0") {
[17:03:55.918]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.918]                             "", base::R.version$version.string), 
[17:03:55.918]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.918]                               "release", "version")], collapse = " "), 
[17:03:55.918]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.918]                             info)
[17:03:55.918]                           info <- base::paste(info, collapse = "; ")
[17:03:55.918]                           if (!has_future) {
[17:03:55.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.918]                               info)
[17:03:55.918]                           }
[17:03:55.918]                           else {
[17:03:55.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.918]                               info, version)
[17:03:55.918]                           }
[17:03:55.918]                           base::stop(msg)
[17:03:55.918]                         }
[17:03:55.918]                       })
[17:03:55.918]                     }
[17:03:55.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.918]                     base::options(mc.cores = 1L)
[17:03:55.918]                   }
[17:03:55.918]                   ...future.strategy.old <- future::plan("list")
[17:03:55.918]                   options(future.plan = NULL)
[17:03:55.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.918]                 }
[17:03:55.918]                 ...future.workdir <- getwd()
[17:03:55.918]             }
[17:03:55.918]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.918]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.918]         }
[17:03:55.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.918]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.918]             base::names(...future.oldOptions))
[17:03:55.918]     }
[17:03:55.918]     if (FALSE) {
[17:03:55.918]     }
[17:03:55.918]     else {
[17:03:55.918]         if (TRUE) {
[17:03:55.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.918]                 open = "w")
[17:03:55.918]         }
[17:03:55.918]         else {
[17:03:55.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.918]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.918]         }
[17:03:55.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.918]             base::sink(type = "output", split = FALSE)
[17:03:55.918]             base::close(...future.stdout)
[17:03:55.918]         }, add = TRUE)
[17:03:55.918]     }
[17:03:55.918]     ...future.frame <- base::sys.nframe()
[17:03:55.918]     ...future.conditions <- base::list()
[17:03:55.918]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.918]     if (FALSE) {
[17:03:55.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.918]     }
[17:03:55.918]     ...future.result <- base::tryCatch({
[17:03:55.918]         base::withCallingHandlers({
[17:03:55.918]             ...future.value <- base::withVisible(base::local({
[17:03:55.918]                 ...future.makeSendCondition <- base::local({
[17:03:55.918]                   sendCondition <- NULL
[17:03:55.918]                   function(frame = 1L) {
[17:03:55.918]                     if (is.function(sendCondition)) 
[17:03:55.918]                       return(sendCondition)
[17:03:55.918]                     ns <- getNamespace("parallel")
[17:03:55.918]                     if (exists("sendData", mode = "function", 
[17:03:55.918]                       envir = ns)) {
[17:03:55.918]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.918]                         envir = ns)
[17:03:55.918]                       envir <- sys.frame(frame)
[17:03:55.918]                       master <- NULL
[17:03:55.918]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.918]                         !identical(envir, emptyenv())) {
[17:03:55.918]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.918]                           inherits = FALSE)) {
[17:03:55.918]                           master <- get("master", mode = "list", 
[17:03:55.918]                             envir = envir, inherits = FALSE)
[17:03:55.918]                           if (inherits(master, c("SOCKnode", 
[17:03:55.918]                             "SOCK0node"))) {
[17:03:55.918]                             sendCondition <<- function(cond) {
[17:03:55.918]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.918]                                 success = TRUE)
[17:03:55.918]                               parallel_sendData(master, data)
[17:03:55.918]                             }
[17:03:55.918]                             return(sendCondition)
[17:03:55.918]                           }
[17:03:55.918]                         }
[17:03:55.918]                         frame <- frame + 1L
[17:03:55.918]                         envir <- sys.frame(frame)
[17:03:55.918]                       }
[17:03:55.918]                     }
[17:03:55.918]                     sendCondition <<- function(cond) NULL
[17:03:55.918]                   }
[17:03:55.918]                 })
[17:03:55.918]                 withCallingHandlers({
[17:03:55.918]                   {
[17:03:55.918]                     Sys.sleep(0.1)
[17:03:55.918]                     kk
[17:03:55.918]                   }
[17:03:55.918]                 }, immediateCondition = function(cond) {
[17:03:55.918]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.918]                   sendCondition(cond)
[17:03:55.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.918]                   {
[17:03:55.918]                     inherits <- base::inherits
[17:03:55.918]                     invokeRestart <- base::invokeRestart
[17:03:55.918]                     is.null <- base::is.null
[17:03:55.918]                     muffled <- FALSE
[17:03:55.918]                     if (inherits(cond, "message")) {
[17:03:55.918]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.918]                       if (muffled) 
[17:03:55.918]                         invokeRestart("muffleMessage")
[17:03:55.918]                     }
[17:03:55.918]                     else if (inherits(cond, "warning")) {
[17:03:55.918]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.918]                       if (muffled) 
[17:03:55.918]                         invokeRestart("muffleWarning")
[17:03:55.918]                     }
[17:03:55.918]                     else if (inherits(cond, "condition")) {
[17:03:55.918]                       if (!is.null(pattern)) {
[17:03:55.918]                         computeRestarts <- base::computeRestarts
[17:03:55.918]                         grepl <- base::grepl
[17:03:55.918]                         restarts <- computeRestarts(cond)
[17:03:55.918]                         for (restart in restarts) {
[17:03:55.918]                           name <- restart$name
[17:03:55.918]                           if (is.null(name)) 
[17:03:55.918]                             next
[17:03:55.918]                           if (!grepl(pattern, name)) 
[17:03:55.918]                             next
[17:03:55.918]                           invokeRestart(restart)
[17:03:55.918]                           muffled <- TRUE
[17:03:55.918]                           break
[17:03:55.918]                         }
[17:03:55.918]                       }
[17:03:55.918]                     }
[17:03:55.918]                     invisible(muffled)
[17:03:55.918]                   }
[17:03:55.918]                   muffleCondition(cond)
[17:03:55.918]                 })
[17:03:55.918]             }))
[17:03:55.918]             future::FutureResult(value = ...future.value$value, 
[17:03:55.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.918]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.918]                     ...future.globalenv.names))
[17:03:55.918]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.918]         }, condition = base::local({
[17:03:55.918]             c <- base::c
[17:03:55.918]             inherits <- base::inherits
[17:03:55.918]             invokeRestart <- base::invokeRestart
[17:03:55.918]             length <- base::length
[17:03:55.918]             list <- base::list
[17:03:55.918]             seq.int <- base::seq.int
[17:03:55.918]             signalCondition <- base::signalCondition
[17:03:55.918]             sys.calls <- base::sys.calls
[17:03:55.918]             `[[` <- base::`[[`
[17:03:55.918]             `+` <- base::`+`
[17:03:55.918]             `<<-` <- base::`<<-`
[17:03:55.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.918]                   3L)]
[17:03:55.918]             }
[17:03:55.918]             function(cond) {
[17:03:55.918]                 is_error <- inherits(cond, "error")
[17:03:55.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.918]                   NULL)
[17:03:55.918]                 if (is_error) {
[17:03:55.918]                   sessionInformation <- function() {
[17:03:55.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.918]                       search = base::search(), system = base::Sys.info())
[17:03:55.918]                   }
[17:03:55.918]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.918]                     cond$call), session = sessionInformation(), 
[17:03:55.918]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.918]                   signalCondition(cond)
[17:03:55.918]                 }
[17:03:55.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.918]                 "immediateCondition"))) {
[17:03:55.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.918]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.918]                   if (TRUE && !signal) {
[17:03:55.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.918]                     {
[17:03:55.918]                       inherits <- base::inherits
[17:03:55.918]                       invokeRestart <- base::invokeRestart
[17:03:55.918]                       is.null <- base::is.null
[17:03:55.918]                       muffled <- FALSE
[17:03:55.918]                       if (inherits(cond, "message")) {
[17:03:55.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.918]                         if (muffled) 
[17:03:55.918]                           invokeRestart("muffleMessage")
[17:03:55.918]                       }
[17:03:55.918]                       else if (inherits(cond, "warning")) {
[17:03:55.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.918]                         if (muffled) 
[17:03:55.918]                           invokeRestart("muffleWarning")
[17:03:55.918]                       }
[17:03:55.918]                       else if (inherits(cond, "condition")) {
[17:03:55.918]                         if (!is.null(pattern)) {
[17:03:55.918]                           computeRestarts <- base::computeRestarts
[17:03:55.918]                           grepl <- base::grepl
[17:03:55.918]                           restarts <- computeRestarts(cond)
[17:03:55.918]                           for (restart in restarts) {
[17:03:55.918]                             name <- restart$name
[17:03:55.918]                             if (is.null(name)) 
[17:03:55.918]                               next
[17:03:55.918]                             if (!grepl(pattern, name)) 
[17:03:55.918]                               next
[17:03:55.918]                             invokeRestart(restart)
[17:03:55.918]                             muffled <- TRUE
[17:03:55.918]                             break
[17:03:55.918]                           }
[17:03:55.918]                         }
[17:03:55.918]                       }
[17:03:55.918]                       invisible(muffled)
[17:03:55.918]                     }
[17:03:55.918]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.918]                   }
[17:03:55.918]                 }
[17:03:55.918]                 else {
[17:03:55.918]                   if (TRUE) {
[17:03:55.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.918]                     {
[17:03:55.918]                       inherits <- base::inherits
[17:03:55.918]                       invokeRestart <- base::invokeRestart
[17:03:55.918]                       is.null <- base::is.null
[17:03:55.918]                       muffled <- FALSE
[17:03:55.918]                       if (inherits(cond, "message")) {
[17:03:55.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.918]                         if (muffled) 
[17:03:55.918]                           invokeRestart("muffleMessage")
[17:03:55.918]                       }
[17:03:55.918]                       else if (inherits(cond, "warning")) {
[17:03:55.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.918]                         if (muffled) 
[17:03:55.918]                           invokeRestart("muffleWarning")
[17:03:55.918]                       }
[17:03:55.918]                       else if (inherits(cond, "condition")) {
[17:03:55.918]                         if (!is.null(pattern)) {
[17:03:55.918]                           computeRestarts <- base::computeRestarts
[17:03:55.918]                           grepl <- base::grepl
[17:03:55.918]                           restarts <- computeRestarts(cond)
[17:03:55.918]                           for (restart in restarts) {
[17:03:55.918]                             name <- restart$name
[17:03:55.918]                             if (is.null(name)) 
[17:03:55.918]                               next
[17:03:55.918]                             if (!grepl(pattern, name)) 
[17:03:55.918]                               next
[17:03:55.918]                             invokeRestart(restart)
[17:03:55.918]                             muffled <- TRUE
[17:03:55.918]                             break
[17:03:55.918]                           }
[17:03:55.918]                         }
[17:03:55.918]                       }
[17:03:55.918]                       invisible(muffled)
[17:03:55.918]                     }
[17:03:55.918]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.918]                   }
[17:03:55.918]                 }
[17:03:55.918]             }
[17:03:55.918]         }))
[17:03:55.918]     }, error = function(ex) {
[17:03:55.918]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.918]                 ...future.rng), started = ...future.startTime, 
[17:03:55.918]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.918]             version = "1.8"), class = "FutureResult")
[17:03:55.918]     }, finally = {
[17:03:55.918]         if (!identical(...future.workdir, getwd())) 
[17:03:55.918]             setwd(...future.workdir)
[17:03:55.918]         {
[17:03:55.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.918]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.918]             }
[17:03:55.918]             base::options(...future.oldOptions)
[17:03:55.918]             if (.Platform$OS.type == "windows") {
[17:03:55.918]                 old_names <- names(...future.oldEnvVars)
[17:03:55.918]                 envs <- base::Sys.getenv()
[17:03:55.918]                 names <- names(envs)
[17:03:55.918]                 common <- intersect(names, old_names)
[17:03:55.918]                 added <- setdiff(names, old_names)
[17:03:55.918]                 removed <- setdiff(old_names, names)
[17:03:55.918]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.918]                   envs[common]]
[17:03:55.918]                 NAMES <- toupper(changed)
[17:03:55.918]                 args <- list()
[17:03:55.918]                 for (kk in seq_along(NAMES)) {
[17:03:55.918]                   name <- changed[[kk]]
[17:03:55.918]                   NAME <- NAMES[[kk]]
[17:03:55.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.918]                     next
[17:03:55.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.918]                 }
[17:03:55.918]                 NAMES <- toupper(added)
[17:03:55.918]                 for (kk in seq_along(NAMES)) {
[17:03:55.918]                   name <- added[[kk]]
[17:03:55.918]                   NAME <- NAMES[[kk]]
[17:03:55.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.918]                     next
[17:03:55.918]                   args[[name]] <- ""
[17:03:55.918]                 }
[17:03:55.918]                 NAMES <- toupper(removed)
[17:03:55.918]                 for (kk in seq_along(NAMES)) {
[17:03:55.918]                   name <- removed[[kk]]
[17:03:55.918]                   NAME <- NAMES[[kk]]
[17:03:55.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.918]                     next
[17:03:55.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.918]                 }
[17:03:55.918]                 if (length(args) > 0) 
[17:03:55.918]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.918]             }
[17:03:55.918]             else {
[17:03:55.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.918]             }
[17:03:55.918]             {
[17:03:55.918]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.918]                   0L) {
[17:03:55.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.918]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.918]                   base::options(opts)
[17:03:55.918]                 }
[17:03:55.918]                 {
[17:03:55.918]                   {
[17:03:55.918]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.918]                     NULL
[17:03:55.918]                   }
[17:03:55.918]                   options(future.plan = NULL)
[17:03:55.918]                   if (is.na(NA_character_)) 
[17:03:55.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.918]                     .init = FALSE)
[17:03:55.918]                 }
[17:03:55.918]             }
[17:03:55.918]         }
[17:03:55.918]     })
[17:03:55.918]     if (TRUE) {
[17:03:55.918]         base::sink(type = "output", split = FALSE)
[17:03:55.918]         if (TRUE) {
[17:03:55.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.918]         }
[17:03:55.918]         else {
[17:03:55.918]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.918]         }
[17:03:55.918]         base::close(...future.stdout)
[17:03:55.918]         ...future.stdout <- NULL
[17:03:55.918]     }
[17:03:55.918]     ...future.result$conditions <- ...future.conditions
[17:03:55.918]     ...future.result$finished <- base::Sys.time()
[17:03:55.918]     ...future.result
[17:03:55.918] }
[17:03:55.921] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:03:55.921] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:03:55.921] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:03:55.921] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:03:55.922] MultisessionFuture started
[17:03:55.922] - Launch lazy future ... done
[17:03:55.922] run() for ‘MultisessionFuture’ ... done
[17:03:55.922] getGlobalsAndPackages() ...
[17:03:55.922] Searching for globals...
[17:03:55.923] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:55.923] Searching for globals ... DONE
[17:03:55.924] Resolving globals: FALSE
[17:03:55.924] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:55.924] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:55.924] - globals: [1] ‘kk’
[17:03:55.924] 
[17:03:55.925] getGlobalsAndPackages() ... DONE
[17:03:55.925] run() for ‘Future’ ...
[17:03:55.925] - state: ‘created’
[17:03:55.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:55.938] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:55.939] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:55.939]   - Field: ‘node’
[17:03:55.939]   - Field: ‘label’
[17:03:55.939]   - Field: ‘local’
[17:03:55.939]   - Field: ‘owner’
[17:03:55.939]   - Field: ‘envir’
[17:03:55.939]   - Field: ‘workers’
[17:03:55.939]   - Field: ‘packages’
[17:03:55.939]   - Field: ‘gc’
[17:03:55.940]   - Field: ‘conditions’
[17:03:55.940]   - Field: ‘persistent’
[17:03:55.940]   - Field: ‘expr’
[17:03:55.940]   - Field: ‘uuid’
[17:03:55.940]   - Field: ‘seed’
[17:03:55.940]   - Field: ‘version’
[17:03:55.940]   - Field: ‘result’
[17:03:55.940]   - Field: ‘asynchronous’
[17:03:55.940]   - Field: ‘calls’
[17:03:55.940]   - Field: ‘globals’
[17:03:55.940]   - Field: ‘stdout’
[17:03:55.941]   - Field: ‘earlySignal’
[17:03:55.941]   - Field: ‘lazy’
[17:03:55.941]   - Field: ‘state’
[17:03:55.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:55.941] - Launch lazy future ...
[17:03:55.941] Packages needed by the future expression (n = 0): <none>
[17:03:55.941] Packages needed by future strategies (n = 0): <none>
[17:03:55.942] {
[17:03:55.942]     {
[17:03:55.942]         {
[17:03:55.942]             ...future.startTime <- base::Sys.time()
[17:03:55.942]             {
[17:03:55.942]                 {
[17:03:55.942]                   {
[17:03:55.942]                     {
[17:03:55.942]                       base::local({
[17:03:55.942]                         has_future <- base::requireNamespace("future", 
[17:03:55.942]                           quietly = TRUE)
[17:03:55.942]                         if (has_future) {
[17:03:55.942]                           ns <- base::getNamespace("future")
[17:03:55.942]                           version <- ns[[".package"]][["version"]]
[17:03:55.942]                           if (is.null(version)) 
[17:03:55.942]                             version <- utils::packageVersion("future")
[17:03:55.942]                         }
[17:03:55.942]                         else {
[17:03:55.942]                           version <- NULL
[17:03:55.942]                         }
[17:03:55.942]                         if (!has_future || version < "1.8.0") {
[17:03:55.942]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:55.942]                             "", base::R.version$version.string), 
[17:03:55.942]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:55.942]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:55.942]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:55.942]                               "release", "version")], collapse = " "), 
[17:03:55.942]                             hostname = base::Sys.info()[["nodename"]])
[17:03:55.942]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:55.942]                             info)
[17:03:55.942]                           info <- base::paste(info, collapse = "; ")
[17:03:55.942]                           if (!has_future) {
[17:03:55.942]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:55.942]                               info)
[17:03:55.942]                           }
[17:03:55.942]                           else {
[17:03:55.942]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:55.942]                               info, version)
[17:03:55.942]                           }
[17:03:55.942]                           base::stop(msg)
[17:03:55.942]                         }
[17:03:55.942]                       })
[17:03:55.942]                     }
[17:03:55.942]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:55.942]                     base::options(mc.cores = 1L)
[17:03:55.942]                   }
[17:03:55.942]                   ...future.strategy.old <- future::plan("list")
[17:03:55.942]                   options(future.plan = NULL)
[17:03:55.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:55.942]                 }
[17:03:55.942]                 ...future.workdir <- getwd()
[17:03:55.942]             }
[17:03:55.942]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:55.942]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:55.942]         }
[17:03:55.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:55.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:55.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:55.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:55.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:55.942]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:55.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:55.942]             base::names(...future.oldOptions))
[17:03:55.942]     }
[17:03:55.942]     if (FALSE) {
[17:03:55.942]     }
[17:03:55.942]     else {
[17:03:55.942]         if (TRUE) {
[17:03:55.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:55.942]                 open = "w")
[17:03:55.942]         }
[17:03:55.942]         else {
[17:03:55.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:55.942]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:55.942]         }
[17:03:55.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:55.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:55.942]             base::sink(type = "output", split = FALSE)
[17:03:55.942]             base::close(...future.stdout)
[17:03:55.942]         }, add = TRUE)
[17:03:55.942]     }
[17:03:55.942]     ...future.frame <- base::sys.nframe()
[17:03:55.942]     ...future.conditions <- base::list()
[17:03:55.942]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:55.942]     if (FALSE) {
[17:03:55.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:55.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:55.942]     }
[17:03:55.942]     ...future.result <- base::tryCatch({
[17:03:55.942]         base::withCallingHandlers({
[17:03:55.942]             ...future.value <- base::withVisible(base::local({
[17:03:55.942]                 ...future.makeSendCondition <- base::local({
[17:03:55.942]                   sendCondition <- NULL
[17:03:55.942]                   function(frame = 1L) {
[17:03:55.942]                     if (is.function(sendCondition)) 
[17:03:55.942]                       return(sendCondition)
[17:03:55.942]                     ns <- getNamespace("parallel")
[17:03:55.942]                     if (exists("sendData", mode = "function", 
[17:03:55.942]                       envir = ns)) {
[17:03:55.942]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:55.942]                         envir = ns)
[17:03:55.942]                       envir <- sys.frame(frame)
[17:03:55.942]                       master <- NULL
[17:03:55.942]                       while (!identical(envir, .GlobalEnv) && 
[17:03:55.942]                         !identical(envir, emptyenv())) {
[17:03:55.942]                         if (exists("master", mode = "list", envir = envir, 
[17:03:55.942]                           inherits = FALSE)) {
[17:03:55.942]                           master <- get("master", mode = "list", 
[17:03:55.942]                             envir = envir, inherits = FALSE)
[17:03:55.942]                           if (inherits(master, c("SOCKnode", 
[17:03:55.942]                             "SOCK0node"))) {
[17:03:55.942]                             sendCondition <<- function(cond) {
[17:03:55.942]                               data <- list(type = "VALUE", value = cond, 
[17:03:55.942]                                 success = TRUE)
[17:03:55.942]                               parallel_sendData(master, data)
[17:03:55.942]                             }
[17:03:55.942]                             return(sendCondition)
[17:03:55.942]                           }
[17:03:55.942]                         }
[17:03:55.942]                         frame <- frame + 1L
[17:03:55.942]                         envir <- sys.frame(frame)
[17:03:55.942]                       }
[17:03:55.942]                     }
[17:03:55.942]                     sendCondition <<- function(cond) NULL
[17:03:55.942]                   }
[17:03:55.942]                 })
[17:03:55.942]                 withCallingHandlers({
[17:03:55.942]                   {
[17:03:55.942]                     Sys.sleep(0.1)
[17:03:55.942]                     kk
[17:03:55.942]                   }
[17:03:55.942]                 }, immediateCondition = function(cond) {
[17:03:55.942]                   sendCondition <- ...future.makeSendCondition()
[17:03:55.942]                   sendCondition(cond)
[17:03:55.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.942]                   {
[17:03:55.942]                     inherits <- base::inherits
[17:03:55.942]                     invokeRestart <- base::invokeRestart
[17:03:55.942]                     is.null <- base::is.null
[17:03:55.942]                     muffled <- FALSE
[17:03:55.942]                     if (inherits(cond, "message")) {
[17:03:55.942]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:55.942]                       if (muffled) 
[17:03:55.942]                         invokeRestart("muffleMessage")
[17:03:55.942]                     }
[17:03:55.942]                     else if (inherits(cond, "warning")) {
[17:03:55.942]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:55.942]                       if (muffled) 
[17:03:55.942]                         invokeRestart("muffleWarning")
[17:03:55.942]                     }
[17:03:55.942]                     else if (inherits(cond, "condition")) {
[17:03:55.942]                       if (!is.null(pattern)) {
[17:03:55.942]                         computeRestarts <- base::computeRestarts
[17:03:55.942]                         grepl <- base::grepl
[17:03:55.942]                         restarts <- computeRestarts(cond)
[17:03:55.942]                         for (restart in restarts) {
[17:03:55.942]                           name <- restart$name
[17:03:55.942]                           if (is.null(name)) 
[17:03:55.942]                             next
[17:03:55.942]                           if (!grepl(pattern, name)) 
[17:03:55.942]                             next
[17:03:55.942]                           invokeRestart(restart)
[17:03:55.942]                           muffled <- TRUE
[17:03:55.942]                           break
[17:03:55.942]                         }
[17:03:55.942]                       }
[17:03:55.942]                     }
[17:03:55.942]                     invisible(muffled)
[17:03:55.942]                   }
[17:03:55.942]                   muffleCondition(cond)
[17:03:55.942]                 })
[17:03:55.942]             }))
[17:03:55.942]             future::FutureResult(value = ...future.value$value, 
[17:03:55.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.942]                   ...future.rng), globalenv = if (FALSE) 
[17:03:55.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:55.942]                     ...future.globalenv.names))
[17:03:55.942]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:55.942]         }, condition = base::local({
[17:03:55.942]             c <- base::c
[17:03:55.942]             inherits <- base::inherits
[17:03:55.942]             invokeRestart <- base::invokeRestart
[17:03:55.942]             length <- base::length
[17:03:55.942]             list <- base::list
[17:03:55.942]             seq.int <- base::seq.int
[17:03:55.942]             signalCondition <- base::signalCondition
[17:03:55.942]             sys.calls <- base::sys.calls
[17:03:55.942]             `[[` <- base::`[[`
[17:03:55.942]             `+` <- base::`+`
[17:03:55.942]             `<<-` <- base::`<<-`
[17:03:55.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:55.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:55.942]                   3L)]
[17:03:55.942]             }
[17:03:55.942]             function(cond) {
[17:03:55.942]                 is_error <- inherits(cond, "error")
[17:03:55.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:55.942]                   NULL)
[17:03:55.942]                 if (is_error) {
[17:03:55.942]                   sessionInformation <- function() {
[17:03:55.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:55.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:55.942]                       search = base::search(), system = base::Sys.info())
[17:03:55.942]                   }
[17:03:55.942]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:55.942]                     cond$call), session = sessionInformation(), 
[17:03:55.942]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:55.942]                   signalCondition(cond)
[17:03:55.942]                 }
[17:03:55.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:55.942]                 "immediateCondition"))) {
[17:03:55.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:55.942]                   ...future.conditions[[length(...future.conditions) + 
[17:03:55.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:55.942]                   if (TRUE && !signal) {
[17:03:55.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.942]                     {
[17:03:55.942]                       inherits <- base::inherits
[17:03:55.942]                       invokeRestart <- base::invokeRestart
[17:03:55.942]                       is.null <- base::is.null
[17:03:55.942]                       muffled <- FALSE
[17:03:55.942]                       if (inherits(cond, "message")) {
[17:03:55.942]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.942]                         if (muffled) 
[17:03:55.942]                           invokeRestart("muffleMessage")
[17:03:55.942]                       }
[17:03:55.942]                       else if (inherits(cond, "warning")) {
[17:03:55.942]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.942]                         if (muffled) 
[17:03:55.942]                           invokeRestart("muffleWarning")
[17:03:55.942]                       }
[17:03:55.942]                       else if (inherits(cond, "condition")) {
[17:03:55.942]                         if (!is.null(pattern)) {
[17:03:55.942]                           computeRestarts <- base::computeRestarts
[17:03:55.942]                           grepl <- base::grepl
[17:03:55.942]                           restarts <- computeRestarts(cond)
[17:03:55.942]                           for (restart in restarts) {
[17:03:55.942]                             name <- restart$name
[17:03:55.942]                             if (is.null(name)) 
[17:03:55.942]                               next
[17:03:55.942]                             if (!grepl(pattern, name)) 
[17:03:55.942]                               next
[17:03:55.942]                             invokeRestart(restart)
[17:03:55.942]                             muffled <- TRUE
[17:03:55.942]                             break
[17:03:55.942]                           }
[17:03:55.942]                         }
[17:03:55.942]                       }
[17:03:55.942]                       invisible(muffled)
[17:03:55.942]                     }
[17:03:55.942]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.942]                   }
[17:03:55.942]                 }
[17:03:55.942]                 else {
[17:03:55.942]                   if (TRUE) {
[17:03:55.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:55.942]                     {
[17:03:55.942]                       inherits <- base::inherits
[17:03:55.942]                       invokeRestart <- base::invokeRestart
[17:03:55.942]                       is.null <- base::is.null
[17:03:55.942]                       muffled <- FALSE
[17:03:55.942]                       if (inherits(cond, "message")) {
[17:03:55.942]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:55.942]                         if (muffled) 
[17:03:55.942]                           invokeRestart("muffleMessage")
[17:03:55.942]                       }
[17:03:55.942]                       else if (inherits(cond, "warning")) {
[17:03:55.942]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:55.942]                         if (muffled) 
[17:03:55.942]                           invokeRestart("muffleWarning")
[17:03:55.942]                       }
[17:03:55.942]                       else if (inherits(cond, "condition")) {
[17:03:55.942]                         if (!is.null(pattern)) {
[17:03:55.942]                           computeRestarts <- base::computeRestarts
[17:03:55.942]                           grepl <- base::grepl
[17:03:55.942]                           restarts <- computeRestarts(cond)
[17:03:55.942]                           for (restart in restarts) {
[17:03:55.942]                             name <- restart$name
[17:03:55.942]                             if (is.null(name)) 
[17:03:55.942]                               next
[17:03:55.942]                             if (!grepl(pattern, name)) 
[17:03:55.942]                               next
[17:03:55.942]                             invokeRestart(restart)
[17:03:55.942]                             muffled <- TRUE
[17:03:55.942]                             break
[17:03:55.942]                           }
[17:03:55.942]                         }
[17:03:55.942]                       }
[17:03:55.942]                       invisible(muffled)
[17:03:55.942]                     }
[17:03:55.942]                     muffleCondition(cond, pattern = "^muffle")
[17:03:55.942]                   }
[17:03:55.942]                 }
[17:03:55.942]             }
[17:03:55.942]         }))
[17:03:55.942]     }, error = function(ex) {
[17:03:55.942]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:55.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:55.942]                 ...future.rng), started = ...future.startTime, 
[17:03:55.942]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:55.942]             version = "1.8"), class = "FutureResult")
[17:03:55.942]     }, finally = {
[17:03:55.942]         if (!identical(...future.workdir, getwd())) 
[17:03:55.942]             setwd(...future.workdir)
[17:03:55.942]         {
[17:03:55.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:55.942]                 ...future.oldOptions$nwarnings <- NULL
[17:03:55.942]             }
[17:03:55.942]             base::options(...future.oldOptions)
[17:03:55.942]             if (.Platform$OS.type == "windows") {
[17:03:55.942]                 old_names <- names(...future.oldEnvVars)
[17:03:55.942]                 envs <- base::Sys.getenv()
[17:03:55.942]                 names <- names(envs)
[17:03:55.942]                 common <- intersect(names, old_names)
[17:03:55.942]                 added <- setdiff(names, old_names)
[17:03:55.942]                 removed <- setdiff(old_names, names)
[17:03:55.942]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:55.942]                   envs[common]]
[17:03:55.942]                 NAMES <- toupper(changed)
[17:03:55.942]                 args <- list()
[17:03:55.942]                 for (kk in seq_along(NAMES)) {
[17:03:55.942]                   name <- changed[[kk]]
[17:03:55.942]                   NAME <- NAMES[[kk]]
[17:03:55.942]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.942]                     next
[17:03:55.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.942]                 }
[17:03:55.942]                 NAMES <- toupper(added)
[17:03:55.942]                 for (kk in seq_along(NAMES)) {
[17:03:55.942]                   name <- added[[kk]]
[17:03:55.942]                   NAME <- NAMES[[kk]]
[17:03:55.942]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.942]                     next
[17:03:55.942]                   args[[name]] <- ""
[17:03:55.942]                 }
[17:03:55.942]                 NAMES <- toupper(removed)
[17:03:55.942]                 for (kk in seq_along(NAMES)) {
[17:03:55.942]                   name <- removed[[kk]]
[17:03:55.942]                   NAME <- NAMES[[kk]]
[17:03:55.942]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:55.942]                     next
[17:03:55.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:55.942]                 }
[17:03:55.942]                 if (length(args) > 0) 
[17:03:55.942]                   base::do.call(base::Sys.setenv, args = args)
[17:03:55.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:55.942]             }
[17:03:55.942]             else {
[17:03:55.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:55.942]             }
[17:03:55.942]             {
[17:03:55.942]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:55.942]                   0L) {
[17:03:55.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:55.942]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:55.942]                   base::options(opts)
[17:03:55.942]                 }
[17:03:55.942]                 {
[17:03:55.942]                   {
[17:03:55.942]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:55.942]                     NULL
[17:03:55.942]                   }
[17:03:55.942]                   options(future.plan = NULL)
[17:03:55.942]                   if (is.na(NA_character_)) 
[17:03:55.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:55.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:55.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:55.942]                     .init = FALSE)
[17:03:55.942]                 }
[17:03:55.942]             }
[17:03:55.942]         }
[17:03:55.942]     })
[17:03:55.942]     if (TRUE) {
[17:03:55.942]         base::sink(type = "output", split = FALSE)
[17:03:55.942]         if (TRUE) {
[17:03:55.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:55.942]         }
[17:03:55.942]         else {
[17:03:55.942]             ...future.result["stdout"] <- base::list(NULL)
[17:03:55.942]         }
[17:03:55.942]         base::close(...future.stdout)
[17:03:55.942]         ...future.stdout <- NULL
[17:03:55.942]     }
[17:03:55.942]     ...future.result$conditions <- ...future.conditions
[17:03:55.942]     ...future.result$finished <- base::Sys.time()
[17:03:55.942]     ...future.result
[17:03:55.942] }
[17:03:55.944] Poll #1 (0): usedNodes() = 2, workers = 2
[17:03:55.975] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:03:56.007] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[17:03:56.018] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.018] - Validating connection of MultisessionFuture
[17:03:56.018] - received message: FutureResult
[17:03:56.018] - Received FutureResult
[17:03:56.018] - Erased future from FutureRegistry
[17:03:56.018] result() for ClusterFuture ...
[17:03:56.019] - result already collected: FutureResult
[17:03:56.019] result() for ClusterFuture ... done
[17:03:56.019] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.019] result() for ClusterFuture ...
[17:03:56.019] - result already collected: FutureResult
[17:03:56.019] result() for ClusterFuture ... done
[17:03:56.019] result() for ClusterFuture ...
[17:03:56.019] - result already collected: FutureResult
[17:03:56.019] result() for ClusterFuture ... done
[17:03:56.020] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:03:56.020] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:03:56.021] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:03:56.021] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:03:56.021] MultisessionFuture started
[17:03:56.021] - Launch lazy future ... done
[17:03:56.021] run() for ‘MultisessionFuture’ ... done
[17:03:56.021] resolve() on list ...
[17:03:56.022]  recursive: 0
[17:03:56.022]  length: 3
[17:03:56.022] 
[17:03:56.022] Future #1
[17:03:56.022]  length: 2 (resolved future 1)
[17:03:56.024] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.024] - Validating connection of MultisessionFuture
[17:03:56.024] - received message: FutureResult
[17:03:56.024] - Received FutureResult
[17:03:56.024] - Erased future from FutureRegistry
[17:03:56.024] result() for ClusterFuture ...
[17:03:56.024] - result already collected: FutureResult
[17:03:56.025] result() for ClusterFuture ... done
[17:03:56.025] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.025] Future #2
[17:03:56.025]  length: 1 (resolved future 2)
[17:03:56.128] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.129] - Validating connection of MultisessionFuture
[17:03:56.129] - received message: FutureResult
[17:03:56.129] - Received FutureResult
[17:03:56.129] - Erased future from FutureRegistry
[17:03:56.129] result() for ClusterFuture ...
[17:03:56.129] - result already collected: FutureResult
[17:03:56.129] result() for ClusterFuture ... done
[17:03:56.129] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.130] Future #3
[17:03:56.130]  length: 0 (resolved future 3)
[17:03:56.130] resolve() on list ... DONE
[17:03:56.130] getGlobalsAndPackages() ...
[17:03:56.130] Searching for globals...
[17:03:56.131] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:56.131] Searching for globals ... DONE
[17:03:56.131] Resolving globals: FALSE
[17:03:56.132] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:56.132] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:56.132] - globals: [1] ‘kk’
[17:03:56.132] 
[17:03:56.132] getGlobalsAndPackages() ... DONE
[17:03:56.133] getGlobalsAndPackages() ...
[17:03:56.133] Searching for globals...
[17:03:56.133] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:56.134] Searching for globals ... DONE
[17:03:56.134] Resolving globals: FALSE
[17:03:56.134] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:56.134] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:56.134] - globals: [1] ‘kk’
[17:03:56.135] 
[17:03:56.135] getGlobalsAndPackages() ... DONE
[17:03:56.135] getGlobalsAndPackages() ...
[17:03:56.135] Searching for globals...
[17:03:56.136] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:03:56.136] Searching for globals ... DONE
[17:03:56.136] Resolving globals: FALSE
[17:03:56.136] The total size of the 1 globals is 56 bytes (56 bytes)
[17:03:56.137] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:03:56.137] - globals: [1] ‘kk’
[17:03:56.137] 
[17:03:56.137] getGlobalsAndPackages() ... DONE
[17:03:56.137] resolve() on list ...
[17:03:56.137]  recursive: 0
[17:03:56.137]  length: 3
[17:03:56.137] 
[17:03:56.138] run() for ‘Future’ ...
[17:03:56.138] - state: ‘created’
[17:03:56.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.151] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.152]   - Field: ‘node’
[17:03:56.154]   - Field: ‘label’
[17:03:56.154]   - Field: ‘local’
[17:03:56.155]   - Field: ‘owner’
[17:03:56.155]   - Field: ‘envir’
[17:03:56.155]   - Field: ‘workers’
[17:03:56.155]   - Field: ‘packages’
[17:03:56.155]   - Field: ‘gc’
[17:03:56.155]   - Field: ‘conditions’
[17:03:56.155]   - Field: ‘persistent’
[17:03:56.155]   - Field: ‘expr’
[17:03:56.155]   - Field: ‘uuid’
[17:03:56.156]   - Field: ‘seed’
[17:03:56.156]   - Field: ‘version’
[17:03:56.156]   - Field: ‘result’
[17:03:56.156]   - Field: ‘asynchronous’
[17:03:56.156]   - Field: ‘calls’
[17:03:56.156]   - Field: ‘globals’
[17:03:56.156]   - Field: ‘stdout’
[17:03:56.156]   - Field: ‘earlySignal’
[17:03:56.156]   - Field: ‘lazy’
[17:03:56.156]   - Field: ‘state’
[17:03:56.157] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.157] - Launch lazy future ...
[17:03:56.157] Packages needed by the future expression (n = 0): <none>
[17:03:56.157] Packages needed by future strategies (n = 0): <none>
[17:03:56.157] {
[17:03:56.157]     {
[17:03:56.157]         {
[17:03:56.157]             ...future.startTime <- base::Sys.time()
[17:03:56.157]             {
[17:03:56.157]                 {
[17:03:56.157]                   {
[17:03:56.157]                     {
[17:03:56.157]                       base::local({
[17:03:56.157]                         has_future <- base::requireNamespace("future", 
[17:03:56.157]                           quietly = TRUE)
[17:03:56.157]                         if (has_future) {
[17:03:56.157]                           ns <- base::getNamespace("future")
[17:03:56.157]                           version <- ns[[".package"]][["version"]]
[17:03:56.157]                           if (is.null(version)) 
[17:03:56.157]                             version <- utils::packageVersion("future")
[17:03:56.157]                         }
[17:03:56.157]                         else {
[17:03:56.157]                           version <- NULL
[17:03:56.157]                         }
[17:03:56.157]                         if (!has_future || version < "1.8.0") {
[17:03:56.157]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.157]                             "", base::R.version$version.string), 
[17:03:56.157]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.157]                               "release", "version")], collapse = " "), 
[17:03:56.157]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.157]                             info)
[17:03:56.157]                           info <- base::paste(info, collapse = "; ")
[17:03:56.157]                           if (!has_future) {
[17:03:56.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.157]                               info)
[17:03:56.157]                           }
[17:03:56.157]                           else {
[17:03:56.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.157]                               info, version)
[17:03:56.157]                           }
[17:03:56.157]                           base::stop(msg)
[17:03:56.157]                         }
[17:03:56.157]                       })
[17:03:56.157]                     }
[17:03:56.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.157]                     base::options(mc.cores = 1L)
[17:03:56.157]                   }
[17:03:56.157]                   ...future.strategy.old <- future::plan("list")
[17:03:56.157]                   options(future.plan = NULL)
[17:03:56.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.157]                 }
[17:03:56.157]                 ...future.workdir <- getwd()
[17:03:56.157]             }
[17:03:56.157]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.157]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.157]         }
[17:03:56.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.157]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.157]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.157]             base::names(...future.oldOptions))
[17:03:56.157]     }
[17:03:56.157]     if (FALSE) {
[17:03:56.157]     }
[17:03:56.157]     else {
[17:03:56.157]         if (TRUE) {
[17:03:56.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.157]                 open = "w")
[17:03:56.157]         }
[17:03:56.157]         else {
[17:03:56.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.157]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.157]         }
[17:03:56.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.157]             base::sink(type = "output", split = FALSE)
[17:03:56.157]             base::close(...future.stdout)
[17:03:56.157]         }, add = TRUE)
[17:03:56.157]     }
[17:03:56.157]     ...future.frame <- base::sys.nframe()
[17:03:56.157]     ...future.conditions <- base::list()
[17:03:56.157]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.157]     if (FALSE) {
[17:03:56.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.157]     }
[17:03:56.157]     ...future.result <- base::tryCatch({
[17:03:56.157]         base::withCallingHandlers({
[17:03:56.157]             ...future.value <- base::withVisible(base::local({
[17:03:56.157]                 ...future.makeSendCondition <- base::local({
[17:03:56.157]                   sendCondition <- NULL
[17:03:56.157]                   function(frame = 1L) {
[17:03:56.157]                     if (is.function(sendCondition)) 
[17:03:56.157]                       return(sendCondition)
[17:03:56.157]                     ns <- getNamespace("parallel")
[17:03:56.157]                     if (exists("sendData", mode = "function", 
[17:03:56.157]                       envir = ns)) {
[17:03:56.157]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.157]                         envir = ns)
[17:03:56.157]                       envir <- sys.frame(frame)
[17:03:56.157]                       master <- NULL
[17:03:56.157]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.157]                         !identical(envir, emptyenv())) {
[17:03:56.157]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.157]                           inherits = FALSE)) {
[17:03:56.157]                           master <- get("master", mode = "list", 
[17:03:56.157]                             envir = envir, inherits = FALSE)
[17:03:56.157]                           if (inherits(master, c("SOCKnode", 
[17:03:56.157]                             "SOCK0node"))) {
[17:03:56.157]                             sendCondition <<- function(cond) {
[17:03:56.157]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.157]                                 success = TRUE)
[17:03:56.157]                               parallel_sendData(master, data)
[17:03:56.157]                             }
[17:03:56.157]                             return(sendCondition)
[17:03:56.157]                           }
[17:03:56.157]                         }
[17:03:56.157]                         frame <- frame + 1L
[17:03:56.157]                         envir <- sys.frame(frame)
[17:03:56.157]                       }
[17:03:56.157]                     }
[17:03:56.157]                     sendCondition <<- function(cond) NULL
[17:03:56.157]                   }
[17:03:56.157]                 })
[17:03:56.157]                 withCallingHandlers({
[17:03:56.157]                   {
[17:03:56.157]                     Sys.sleep(0.1)
[17:03:56.157]                     kk
[17:03:56.157]                   }
[17:03:56.157]                 }, immediateCondition = function(cond) {
[17:03:56.157]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.157]                   sendCondition(cond)
[17:03:56.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.157]                   {
[17:03:56.157]                     inherits <- base::inherits
[17:03:56.157]                     invokeRestart <- base::invokeRestart
[17:03:56.157]                     is.null <- base::is.null
[17:03:56.157]                     muffled <- FALSE
[17:03:56.157]                     if (inherits(cond, "message")) {
[17:03:56.157]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.157]                       if (muffled) 
[17:03:56.157]                         invokeRestart("muffleMessage")
[17:03:56.157]                     }
[17:03:56.157]                     else if (inherits(cond, "warning")) {
[17:03:56.157]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.157]                       if (muffled) 
[17:03:56.157]                         invokeRestart("muffleWarning")
[17:03:56.157]                     }
[17:03:56.157]                     else if (inherits(cond, "condition")) {
[17:03:56.157]                       if (!is.null(pattern)) {
[17:03:56.157]                         computeRestarts <- base::computeRestarts
[17:03:56.157]                         grepl <- base::grepl
[17:03:56.157]                         restarts <- computeRestarts(cond)
[17:03:56.157]                         for (restart in restarts) {
[17:03:56.157]                           name <- restart$name
[17:03:56.157]                           if (is.null(name)) 
[17:03:56.157]                             next
[17:03:56.157]                           if (!grepl(pattern, name)) 
[17:03:56.157]                             next
[17:03:56.157]                           invokeRestart(restart)
[17:03:56.157]                           muffled <- TRUE
[17:03:56.157]                           break
[17:03:56.157]                         }
[17:03:56.157]                       }
[17:03:56.157]                     }
[17:03:56.157]                     invisible(muffled)
[17:03:56.157]                   }
[17:03:56.157]                   muffleCondition(cond)
[17:03:56.157]                 })
[17:03:56.157]             }))
[17:03:56.157]             future::FutureResult(value = ...future.value$value, 
[17:03:56.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.157]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.157]                     ...future.globalenv.names))
[17:03:56.157]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.157]         }, condition = base::local({
[17:03:56.157]             c <- base::c
[17:03:56.157]             inherits <- base::inherits
[17:03:56.157]             invokeRestart <- base::invokeRestart
[17:03:56.157]             length <- base::length
[17:03:56.157]             list <- base::list
[17:03:56.157]             seq.int <- base::seq.int
[17:03:56.157]             signalCondition <- base::signalCondition
[17:03:56.157]             sys.calls <- base::sys.calls
[17:03:56.157]             `[[` <- base::`[[`
[17:03:56.157]             `+` <- base::`+`
[17:03:56.157]             `<<-` <- base::`<<-`
[17:03:56.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.157]                   3L)]
[17:03:56.157]             }
[17:03:56.157]             function(cond) {
[17:03:56.157]                 is_error <- inherits(cond, "error")
[17:03:56.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.157]                   NULL)
[17:03:56.157]                 if (is_error) {
[17:03:56.157]                   sessionInformation <- function() {
[17:03:56.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.157]                       search = base::search(), system = base::Sys.info())
[17:03:56.157]                   }
[17:03:56.157]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.157]                     cond$call), session = sessionInformation(), 
[17:03:56.157]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.157]                   signalCondition(cond)
[17:03:56.157]                 }
[17:03:56.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.157]                 "immediateCondition"))) {
[17:03:56.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.157]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.157]                   if (TRUE && !signal) {
[17:03:56.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.157]                     {
[17:03:56.157]                       inherits <- base::inherits
[17:03:56.157]                       invokeRestart <- base::invokeRestart
[17:03:56.157]                       is.null <- base::is.null
[17:03:56.157]                       muffled <- FALSE
[17:03:56.157]                       if (inherits(cond, "message")) {
[17:03:56.157]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.157]                         if (muffled) 
[17:03:56.157]                           invokeRestart("muffleMessage")
[17:03:56.157]                       }
[17:03:56.157]                       else if (inherits(cond, "warning")) {
[17:03:56.157]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.157]                         if (muffled) 
[17:03:56.157]                           invokeRestart("muffleWarning")
[17:03:56.157]                       }
[17:03:56.157]                       else if (inherits(cond, "condition")) {
[17:03:56.157]                         if (!is.null(pattern)) {
[17:03:56.157]                           computeRestarts <- base::computeRestarts
[17:03:56.157]                           grepl <- base::grepl
[17:03:56.157]                           restarts <- computeRestarts(cond)
[17:03:56.157]                           for (restart in restarts) {
[17:03:56.157]                             name <- restart$name
[17:03:56.157]                             if (is.null(name)) 
[17:03:56.157]                               next
[17:03:56.157]                             if (!grepl(pattern, name)) 
[17:03:56.157]                               next
[17:03:56.157]                             invokeRestart(restart)
[17:03:56.157]                             muffled <- TRUE
[17:03:56.157]                             break
[17:03:56.157]                           }
[17:03:56.157]                         }
[17:03:56.157]                       }
[17:03:56.157]                       invisible(muffled)
[17:03:56.157]                     }
[17:03:56.157]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.157]                   }
[17:03:56.157]                 }
[17:03:56.157]                 else {
[17:03:56.157]                   if (TRUE) {
[17:03:56.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.157]                     {
[17:03:56.157]                       inherits <- base::inherits
[17:03:56.157]                       invokeRestart <- base::invokeRestart
[17:03:56.157]                       is.null <- base::is.null
[17:03:56.157]                       muffled <- FALSE
[17:03:56.157]                       if (inherits(cond, "message")) {
[17:03:56.157]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.157]                         if (muffled) 
[17:03:56.157]                           invokeRestart("muffleMessage")
[17:03:56.157]                       }
[17:03:56.157]                       else if (inherits(cond, "warning")) {
[17:03:56.157]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.157]                         if (muffled) 
[17:03:56.157]                           invokeRestart("muffleWarning")
[17:03:56.157]                       }
[17:03:56.157]                       else if (inherits(cond, "condition")) {
[17:03:56.157]                         if (!is.null(pattern)) {
[17:03:56.157]                           computeRestarts <- base::computeRestarts
[17:03:56.157]                           grepl <- base::grepl
[17:03:56.157]                           restarts <- computeRestarts(cond)
[17:03:56.157]                           for (restart in restarts) {
[17:03:56.157]                             name <- restart$name
[17:03:56.157]                             if (is.null(name)) 
[17:03:56.157]                               next
[17:03:56.157]                             if (!grepl(pattern, name)) 
[17:03:56.157]                               next
[17:03:56.157]                             invokeRestart(restart)
[17:03:56.157]                             muffled <- TRUE
[17:03:56.157]                             break
[17:03:56.157]                           }
[17:03:56.157]                         }
[17:03:56.157]                       }
[17:03:56.157]                       invisible(muffled)
[17:03:56.157]                     }
[17:03:56.157]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.157]                   }
[17:03:56.157]                 }
[17:03:56.157]             }
[17:03:56.157]         }))
[17:03:56.157]     }, error = function(ex) {
[17:03:56.157]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.157]                 ...future.rng), started = ...future.startTime, 
[17:03:56.157]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.157]             version = "1.8"), class = "FutureResult")
[17:03:56.157]     }, finally = {
[17:03:56.157]         if (!identical(...future.workdir, getwd())) 
[17:03:56.157]             setwd(...future.workdir)
[17:03:56.157]         {
[17:03:56.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.157]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.157]             }
[17:03:56.157]             base::options(...future.oldOptions)
[17:03:56.157]             if (.Platform$OS.type == "windows") {
[17:03:56.157]                 old_names <- names(...future.oldEnvVars)
[17:03:56.157]                 envs <- base::Sys.getenv()
[17:03:56.157]                 names <- names(envs)
[17:03:56.157]                 common <- intersect(names, old_names)
[17:03:56.157]                 added <- setdiff(names, old_names)
[17:03:56.157]                 removed <- setdiff(old_names, names)
[17:03:56.157]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.157]                   envs[common]]
[17:03:56.157]                 NAMES <- toupper(changed)
[17:03:56.157]                 args <- list()
[17:03:56.157]                 for (kk in seq_along(NAMES)) {
[17:03:56.157]                   name <- changed[[kk]]
[17:03:56.157]                   NAME <- NAMES[[kk]]
[17:03:56.157]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.157]                     next
[17:03:56.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.157]                 }
[17:03:56.157]                 NAMES <- toupper(added)
[17:03:56.157]                 for (kk in seq_along(NAMES)) {
[17:03:56.157]                   name <- added[[kk]]
[17:03:56.157]                   NAME <- NAMES[[kk]]
[17:03:56.157]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.157]                     next
[17:03:56.157]                   args[[name]] <- ""
[17:03:56.157]                 }
[17:03:56.157]                 NAMES <- toupper(removed)
[17:03:56.157]                 for (kk in seq_along(NAMES)) {
[17:03:56.157]                   name <- removed[[kk]]
[17:03:56.157]                   NAME <- NAMES[[kk]]
[17:03:56.157]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.157]                     next
[17:03:56.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.157]                 }
[17:03:56.157]                 if (length(args) > 0) 
[17:03:56.157]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.157]             }
[17:03:56.157]             else {
[17:03:56.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.157]             }
[17:03:56.157]             {
[17:03:56.157]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.157]                   0L) {
[17:03:56.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.157]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.157]                   base::options(opts)
[17:03:56.157]                 }
[17:03:56.157]                 {
[17:03:56.157]                   {
[17:03:56.157]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.157]                     NULL
[17:03:56.157]                   }
[17:03:56.157]                   options(future.plan = NULL)
[17:03:56.157]                   if (is.na(NA_character_)) 
[17:03:56.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.157]                     .init = FALSE)
[17:03:56.157]                 }
[17:03:56.157]             }
[17:03:56.157]         }
[17:03:56.157]     })
[17:03:56.157]     if (TRUE) {
[17:03:56.157]         base::sink(type = "output", split = FALSE)
[17:03:56.157]         if (TRUE) {
[17:03:56.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.157]         }
[17:03:56.157]         else {
[17:03:56.157]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.157]         }
[17:03:56.157]         base::close(...future.stdout)
[17:03:56.157]         ...future.stdout <- NULL
[17:03:56.157]     }
[17:03:56.157]     ...future.result$conditions <- ...future.conditions
[17:03:56.157]     ...future.result$finished <- base::Sys.time()
[17:03:56.157]     ...future.result
[17:03:56.157] }
[17:03:56.160] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:03:56.160] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:03:56.161] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:03:56.161] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:03:56.161] MultisessionFuture started
[17:03:56.161] - Launch lazy future ... done
[17:03:56.161] run() for ‘MultisessionFuture’ ... done
[17:03:56.172] run() for ‘Future’ ...
[17:03:56.172] - state: ‘created’
[17:03:56.172] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.186] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.187]   - Field: ‘node’
[17:03:56.187]   - Field: ‘label’
[17:03:56.187]   - Field: ‘local’
[17:03:56.187]   - Field: ‘owner’
[17:03:56.187]   - Field: ‘envir’
[17:03:56.187]   - Field: ‘workers’
[17:03:56.187]   - Field: ‘packages’
[17:03:56.187]   - Field: ‘gc’
[17:03:56.187]   - Field: ‘conditions’
[17:03:56.188]   - Field: ‘persistent’
[17:03:56.188]   - Field: ‘expr’
[17:03:56.188]   - Field: ‘uuid’
[17:03:56.188]   - Field: ‘seed’
[17:03:56.188]   - Field: ‘version’
[17:03:56.188]   - Field: ‘result’
[17:03:56.188]   - Field: ‘asynchronous’
[17:03:56.188]   - Field: ‘calls’
[17:03:56.188]   - Field: ‘globals’
[17:03:56.188]   - Field: ‘stdout’
[17:03:56.188]   - Field: ‘earlySignal’
[17:03:56.188]   - Field: ‘lazy’
[17:03:56.189]   - Field: ‘state’
[17:03:56.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.189] - Launch lazy future ...
[17:03:56.189] Packages needed by the future expression (n = 0): <none>
[17:03:56.189] Packages needed by future strategies (n = 0): <none>
[17:03:56.190] {
[17:03:56.190]     {
[17:03:56.190]         {
[17:03:56.190]             ...future.startTime <- base::Sys.time()
[17:03:56.190]             {
[17:03:56.190]                 {
[17:03:56.190]                   {
[17:03:56.190]                     {
[17:03:56.190]                       base::local({
[17:03:56.190]                         has_future <- base::requireNamespace("future", 
[17:03:56.190]                           quietly = TRUE)
[17:03:56.190]                         if (has_future) {
[17:03:56.190]                           ns <- base::getNamespace("future")
[17:03:56.190]                           version <- ns[[".package"]][["version"]]
[17:03:56.190]                           if (is.null(version)) 
[17:03:56.190]                             version <- utils::packageVersion("future")
[17:03:56.190]                         }
[17:03:56.190]                         else {
[17:03:56.190]                           version <- NULL
[17:03:56.190]                         }
[17:03:56.190]                         if (!has_future || version < "1.8.0") {
[17:03:56.190]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.190]                             "", base::R.version$version.string), 
[17:03:56.190]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.190]                               "release", "version")], collapse = " "), 
[17:03:56.190]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.190]                             info)
[17:03:56.190]                           info <- base::paste(info, collapse = "; ")
[17:03:56.190]                           if (!has_future) {
[17:03:56.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.190]                               info)
[17:03:56.190]                           }
[17:03:56.190]                           else {
[17:03:56.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.190]                               info, version)
[17:03:56.190]                           }
[17:03:56.190]                           base::stop(msg)
[17:03:56.190]                         }
[17:03:56.190]                       })
[17:03:56.190]                     }
[17:03:56.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.190]                     base::options(mc.cores = 1L)
[17:03:56.190]                   }
[17:03:56.190]                   ...future.strategy.old <- future::plan("list")
[17:03:56.190]                   options(future.plan = NULL)
[17:03:56.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.190]                 }
[17:03:56.190]                 ...future.workdir <- getwd()
[17:03:56.190]             }
[17:03:56.190]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.190]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.190]         }
[17:03:56.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.190]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.190]             base::names(...future.oldOptions))
[17:03:56.190]     }
[17:03:56.190]     if (FALSE) {
[17:03:56.190]     }
[17:03:56.190]     else {
[17:03:56.190]         if (TRUE) {
[17:03:56.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.190]                 open = "w")
[17:03:56.190]         }
[17:03:56.190]         else {
[17:03:56.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.190]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.190]         }
[17:03:56.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.190]             base::sink(type = "output", split = FALSE)
[17:03:56.190]             base::close(...future.stdout)
[17:03:56.190]         }, add = TRUE)
[17:03:56.190]     }
[17:03:56.190]     ...future.frame <- base::sys.nframe()
[17:03:56.190]     ...future.conditions <- base::list()
[17:03:56.190]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.190]     if (FALSE) {
[17:03:56.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.190]     }
[17:03:56.190]     ...future.result <- base::tryCatch({
[17:03:56.190]         base::withCallingHandlers({
[17:03:56.190]             ...future.value <- base::withVisible(base::local({
[17:03:56.190]                 ...future.makeSendCondition <- base::local({
[17:03:56.190]                   sendCondition <- NULL
[17:03:56.190]                   function(frame = 1L) {
[17:03:56.190]                     if (is.function(sendCondition)) 
[17:03:56.190]                       return(sendCondition)
[17:03:56.190]                     ns <- getNamespace("parallel")
[17:03:56.190]                     if (exists("sendData", mode = "function", 
[17:03:56.190]                       envir = ns)) {
[17:03:56.190]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.190]                         envir = ns)
[17:03:56.190]                       envir <- sys.frame(frame)
[17:03:56.190]                       master <- NULL
[17:03:56.190]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.190]                         !identical(envir, emptyenv())) {
[17:03:56.190]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.190]                           inherits = FALSE)) {
[17:03:56.190]                           master <- get("master", mode = "list", 
[17:03:56.190]                             envir = envir, inherits = FALSE)
[17:03:56.190]                           if (inherits(master, c("SOCKnode", 
[17:03:56.190]                             "SOCK0node"))) {
[17:03:56.190]                             sendCondition <<- function(cond) {
[17:03:56.190]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.190]                                 success = TRUE)
[17:03:56.190]                               parallel_sendData(master, data)
[17:03:56.190]                             }
[17:03:56.190]                             return(sendCondition)
[17:03:56.190]                           }
[17:03:56.190]                         }
[17:03:56.190]                         frame <- frame + 1L
[17:03:56.190]                         envir <- sys.frame(frame)
[17:03:56.190]                       }
[17:03:56.190]                     }
[17:03:56.190]                     sendCondition <<- function(cond) NULL
[17:03:56.190]                   }
[17:03:56.190]                 })
[17:03:56.190]                 withCallingHandlers({
[17:03:56.190]                   {
[17:03:56.190]                     Sys.sleep(0.1)
[17:03:56.190]                     kk
[17:03:56.190]                   }
[17:03:56.190]                 }, immediateCondition = function(cond) {
[17:03:56.190]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.190]                   sendCondition(cond)
[17:03:56.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.190]                   {
[17:03:56.190]                     inherits <- base::inherits
[17:03:56.190]                     invokeRestart <- base::invokeRestart
[17:03:56.190]                     is.null <- base::is.null
[17:03:56.190]                     muffled <- FALSE
[17:03:56.190]                     if (inherits(cond, "message")) {
[17:03:56.190]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.190]                       if (muffled) 
[17:03:56.190]                         invokeRestart("muffleMessage")
[17:03:56.190]                     }
[17:03:56.190]                     else if (inherits(cond, "warning")) {
[17:03:56.190]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.190]                       if (muffled) 
[17:03:56.190]                         invokeRestart("muffleWarning")
[17:03:56.190]                     }
[17:03:56.190]                     else if (inherits(cond, "condition")) {
[17:03:56.190]                       if (!is.null(pattern)) {
[17:03:56.190]                         computeRestarts <- base::computeRestarts
[17:03:56.190]                         grepl <- base::grepl
[17:03:56.190]                         restarts <- computeRestarts(cond)
[17:03:56.190]                         for (restart in restarts) {
[17:03:56.190]                           name <- restart$name
[17:03:56.190]                           if (is.null(name)) 
[17:03:56.190]                             next
[17:03:56.190]                           if (!grepl(pattern, name)) 
[17:03:56.190]                             next
[17:03:56.190]                           invokeRestart(restart)
[17:03:56.190]                           muffled <- TRUE
[17:03:56.190]                           break
[17:03:56.190]                         }
[17:03:56.190]                       }
[17:03:56.190]                     }
[17:03:56.190]                     invisible(muffled)
[17:03:56.190]                   }
[17:03:56.190]                   muffleCondition(cond)
[17:03:56.190]                 })
[17:03:56.190]             }))
[17:03:56.190]             future::FutureResult(value = ...future.value$value, 
[17:03:56.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.190]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.190]                     ...future.globalenv.names))
[17:03:56.190]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.190]         }, condition = base::local({
[17:03:56.190]             c <- base::c
[17:03:56.190]             inherits <- base::inherits
[17:03:56.190]             invokeRestart <- base::invokeRestart
[17:03:56.190]             length <- base::length
[17:03:56.190]             list <- base::list
[17:03:56.190]             seq.int <- base::seq.int
[17:03:56.190]             signalCondition <- base::signalCondition
[17:03:56.190]             sys.calls <- base::sys.calls
[17:03:56.190]             `[[` <- base::`[[`
[17:03:56.190]             `+` <- base::`+`
[17:03:56.190]             `<<-` <- base::`<<-`
[17:03:56.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.190]                   3L)]
[17:03:56.190]             }
[17:03:56.190]             function(cond) {
[17:03:56.190]                 is_error <- inherits(cond, "error")
[17:03:56.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.190]                   NULL)
[17:03:56.190]                 if (is_error) {
[17:03:56.190]                   sessionInformation <- function() {
[17:03:56.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.190]                       search = base::search(), system = base::Sys.info())
[17:03:56.190]                   }
[17:03:56.190]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.190]                     cond$call), session = sessionInformation(), 
[17:03:56.190]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.190]                   signalCondition(cond)
[17:03:56.190]                 }
[17:03:56.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.190]                 "immediateCondition"))) {
[17:03:56.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.190]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.190]                   if (TRUE && !signal) {
[17:03:56.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.190]                     {
[17:03:56.190]                       inherits <- base::inherits
[17:03:56.190]                       invokeRestart <- base::invokeRestart
[17:03:56.190]                       is.null <- base::is.null
[17:03:56.190]                       muffled <- FALSE
[17:03:56.190]                       if (inherits(cond, "message")) {
[17:03:56.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.190]                         if (muffled) 
[17:03:56.190]                           invokeRestart("muffleMessage")
[17:03:56.190]                       }
[17:03:56.190]                       else if (inherits(cond, "warning")) {
[17:03:56.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.190]                         if (muffled) 
[17:03:56.190]                           invokeRestart("muffleWarning")
[17:03:56.190]                       }
[17:03:56.190]                       else if (inherits(cond, "condition")) {
[17:03:56.190]                         if (!is.null(pattern)) {
[17:03:56.190]                           computeRestarts <- base::computeRestarts
[17:03:56.190]                           grepl <- base::grepl
[17:03:56.190]                           restarts <- computeRestarts(cond)
[17:03:56.190]                           for (restart in restarts) {
[17:03:56.190]                             name <- restart$name
[17:03:56.190]                             if (is.null(name)) 
[17:03:56.190]                               next
[17:03:56.190]                             if (!grepl(pattern, name)) 
[17:03:56.190]                               next
[17:03:56.190]                             invokeRestart(restart)
[17:03:56.190]                             muffled <- TRUE
[17:03:56.190]                             break
[17:03:56.190]                           }
[17:03:56.190]                         }
[17:03:56.190]                       }
[17:03:56.190]                       invisible(muffled)
[17:03:56.190]                     }
[17:03:56.190]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.190]                   }
[17:03:56.190]                 }
[17:03:56.190]                 else {
[17:03:56.190]                   if (TRUE) {
[17:03:56.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.190]                     {
[17:03:56.190]                       inherits <- base::inherits
[17:03:56.190]                       invokeRestart <- base::invokeRestart
[17:03:56.190]                       is.null <- base::is.null
[17:03:56.190]                       muffled <- FALSE
[17:03:56.190]                       if (inherits(cond, "message")) {
[17:03:56.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.190]                         if (muffled) 
[17:03:56.190]                           invokeRestart("muffleMessage")
[17:03:56.190]                       }
[17:03:56.190]                       else if (inherits(cond, "warning")) {
[17:03:56.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.190]                         if (muffled) 
[17:03:56.190]                           invokeRestart("muffleWarning")
[17:03:56.190]                       }
[17:03:56.190]                       else if (inherits(cond, "condition")) {
[17:03:56.190]                         if (!is.null(pattern)) {
[17:03:56.190]                           computeRestarts <- base::computeRestarts
[17:03:56.190]                           grepl <- base::grepl
[17:03:56.190]                           restarts <- computeRestarts(cond)
[17:03:56.190]                           for (restart in restarts) {
[17:03:56.190]                             name <- restart$name
[17:03:56.190]                             if (is.null(name)) 
[17:03:56.190]                               next
[17:03:56.190]                             if (!grepl(pattern, name)) 
[17:03:56.190]                               next
[17:03:56.190]                             invokeRestart(restart)
[17:03:56.190]                             muffled <- TRUE
[17:03:56.190]                             break
[17:03:56.190]                           }
[17:03:56.190]                         }
[17:03:56.190]                       }
[17:03:56.190]                       invisible(muffled)
[17:03:56.190]                     }
[17:03:56.190]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.190]                   }
[17:03:56.190]                 }
[17:03:56.190]             }
[17:03:56.190]         }))
[17:03:56.190]     }, error = function(ex) {
[17:03:56.190]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.190]                 ...future.rng), started = ...future.startTime, 
[17:03:56.190]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.190]             version = "1.8"), class = "FutureResult")
[17:03:56.190]     }, finally = {
[17:03:56.190]         if (!identical(...future.workdir, getwd())) 
[17:03:56.190]             setwd(...future.workdir)
[17:03:56.190]         {
[17:03:56.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.190]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.190]             }
[17:03:56.190]             base::options(...future.oldOptions)
[17:03:56.190]             if (.Platform$OS.type == "windows") {
[17:03:56.190]                 old_names <- names(...future.oldEnvVars)
[17:03:56.190]                 envs <- base::Sys.getenv()
[17:03:56.190]                 names <- names(envs)
[17:03:56.190]                 common <- intersect(names, old_names)
[17:03:56.190]                 added <- setdiff(names, old_names)
[17:03:56.190]                 removed <- setdiff(old_names, names)
[17:03:56.190]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.190]                   envs[common]]
[17:03:56.190]                 NAMES <- toupper(changed)
[17:03:56.190]                 args <- list()
[17:03:56.190]                 for (kk in seq_along(NAMES)) {
[17:03:56.190]                   name <- changed[[kk]]
[17:03:56.190]                   NAME <- NAMES[[kk]]
[17:03:56.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.190]                     next
[17:03:56.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.190]                 }
[17:03:56.190]                 NAMES <- toupper(added)
[17:03:56.190]                 for (kk in seq_along(NAMES)) {
[17:03:56.190]                   name <- added[[kk]]
[17:03:56.190]                   NAME <- NAMES[[kk]]
[17:03:56.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.190]                     next
[17:03:56.190]                   args[[name]] <- ""
[17:03:56.190]                 }
[17:03:56.190]                 NAMES <- toupper(removed)
[17:03:56.190]                 for (kk in seq_along(NAMES)) {
[17:03:56.190]                   name <- removed[[kk]]
[17:03:56.190]                   NAME <- NAMES[[kk]]
[17:03:56.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.190]                     next
[17:03:56.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.190]                 }
[17:03:56.190]                 if (length(args) > 0) 
[17:03:56.190]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.190]             }
[17:03:56.190]             else {
[17:03:56.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.190]             }
[17:03:56.190]             {
[17:03:56.190]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.190]                   0L) {
[17:03:56.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.190]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.190]                   base::options(opts)
[17:03:56.190]                 }
[17:03:56.190]                 {
[17:03:56.190]                   {
[17:03:56.190]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.190]                     NULL
[17:03:56.190]                   }
[17:03:56.190]                   options(future.plan = NULL)
[17:03:56.190]                   if (is.na(NA_character_)) 
[17:03:56.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.190]                     .init = FALSE)
[17:03:56.190]                 }
[17:03:56.190]             }
[17:03:56.190]         }
[17:03:56.190]     })
[17:03:56.190]     if (TRUE) {
[17:03:56.190]         base::sink(type = "output", split = FALSE)
[17:03:56.190]         if (TRUE) {
[17:03:56.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.190]         }
[17:03:56.190]         else {
[17:03:56.190]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.190]         }
[17:03:56.190]         base::close(...future.stdout)
[17:03:56.190]         ...future.stdout <- NULL
[17:03:56.190]     }
[17:03:56.190]     ...future.result$conditions <- ...future.conditions
[17:03:56.190]     ...future.result$finished <- base::Sys.time()
[17:03:56.190]     ...future.result
[17:03:56.190] }
[17:03:56.192] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:03:56.192] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:03:56.193] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:03:56.193] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:03:56.193] MultisessionFuture started
[17:03:56.193] - Launch lazy future ... done
[17:03:56.194] run() for ‘MultisessionFuture’ ... done
[17:03:56.204] run() for ‘Future’ ...
[17:03:56.204] - state: ‘created’
[17:03:56.204] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.218] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.218]   - Field: ‘node’
[17:03:56.219]   - Field: ‘label’
[17:03:56.219]   - Field: ‘local’
[17:03:56.219]   - Field: ‘owner’
[17:03:56.219]   - Field: ‘envir’
[17:03:56.219]   - Field: ‘workers’
[17:03:56.219]   - Field: ‘packages’
[17:03:56.219]   - Field: ‘gc’
[17:03:56.219]   - Field: ‘conditions’
[17:03:56.219]   - Field: ‘persistent’
[17:03:56.219]   - Field: ‘expr’
[17:03:56.220]   - Field: ‘uuid’
[17:03:56.220]   - Field: ‘seed’
[17:03:56.220]   - Field: ‘version’
[17:03:56.220]   - Field: ‘result’
[17:03:56.220]   - Field: ‘asynchronous’
[17:03:56.220]   - Field: ‘calls’
[17:03:56.220]   - Field: ‘globals’
[17:03:56.220]   - Field: ‘stdout’
[17:03:56.220]   - Field: ‘earlySignal’
[17:03:56.220]   - Field: ‘lazy’
[17:03:56.220]   - Field: ‘state’
[17:03:56.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.221] - Launch lazy future ...
[17:03:56.221] Packages needed by the future expression (n = 0): <none>
[17:03:56.221] Packages needed by future strategies (n = 0): <none>
[17:03:56.221] {
[17:03:56.221]     {
[17:03:56.221]         {
[17:03:56.221]             ...future.startTime <- base::Sys.time()
[17:03:56.221]             {
[17:03:56.221]                 {
[17:03:56.221]                   {
[17:03:56.221]                     {
[17:03:56.221]                       base::local({
[17:03:56.221]                         has_future <- base::requireNamespace("future", 
[17:03:56.221]                           quietly = TRUE)
[17:03:56.221]                         if (has_future) {
[17:03:56.221]                           ns <- base::getNamespace("future")
[17:03:56.221]                           version <- ns[[".package"]][["version"]]
[17:03:56.221]                           if (is.null(version)) 
[17:03:56.221]                             version <- utils::packageVersion("future")
[17:03:56.221]                         }
[17:03:56.221]                         else {
[17:03:56.221]                           version <- NULL
[17:03:56.221]                         }
[17:03:56.221]                         if (!has_future || version < "1.8.0") {
[17:03:56.221]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.221]                             "", base::R.version$version.string), 
[17:03:56.221]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.221]                               "release", "version")], collapse = " "), 
[17:03:56.221]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.221]                             info)
[17:03:56.221]                           info <- base::paste(info, collapse = "; ")
[17:03:56.221]                           if (!has_future) {
[17:03:56.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.221]                               info)
[17:03:56.221]                           }
[17:03:56.221]                           else {
[17:03:56.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.221]                               info, version)
[17:03:56.221]                           }
[17:03:56.221]                           base::stop(msg)
[17:03:56.221]                         }
[17:03:56.221]                       })
[17:03:56.221]                     }
[17:03:56.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.221]                     base::options(mc.cores = 1L)
[17:03:56.221]                   }
[17:03:56.221]                   ...future.strategy.old <- future::plan("list")
[17:03:56.221]                   options(future.plan = NULL)
[17:03:56.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.221]                 }
[17:03:56.221]                 ...future.workdir <- getwd()
[17:03:56.221]             }
[17:03:56.221]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.221]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.221]         }
[17:03:56.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.221]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.221]             base::names(...future.oldOptions))
[17:03:56.221]     }
[17:03:56.221]     if (FALSE) {
[17:03:56.221]     }
[17:03:56.221]     else {
[17:03:56.221]         if (TRUE) {
[17:03:56.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.221]                 open = "w")
[17:03:56.221]         }
[17:03:56.221]         else {
[17:03:56.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.221]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.221]         }
[17:03:56.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.221]             base::sink(type = "output", split = FALSE)
[17:03:56.221]             base::close(...future.stdout)
[17:03:56.221]         }, add = TRUE)
[17:03:56.221]     }
[17:03:56.221]     ...future.frame <- base::sys.nframe()
[17:03:56.221]     ...future.conditions <- base::list()
[17:03:56.221]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.221]     if (FALSE) {
[17:03:56.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.221]     }
[17:03:56.221]     ...future.result <- base::tryCatch({
[17:03:56.221]         base::withCallingHandlers({
[17:03:56.221]             ...future.value <- base::withVisible(base::local({
[17:03:56.221]                 ...future.makeSendCondition <- base::local({
[17:03:56.221]                   sendCondition <- NULL
[17:03:56.221]                   function(frame = 1L) {
[17:03:56.221]                     if (is.function(sendCondition)) 
[17:03:56.221]                       return(sendCondition)
[17:03:56.221]                     ns <- getNamespace("parallel")
[17:03:56.221]                     if (exists("sendData", mode = "function", 
[17:03:56.221]                       envir = ns)) {
[17:03:56.221]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.221]                         envir = ns)
[17:03:56.221]                       envir <- sys.frame(frame)
[17:03:56.221]                       master <- NULL
[17:03:56.221]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.221]                         !identical(envir, emptyenv())) {
[17:03:56.221]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.221]                           inherits = FALSE)) {
[17:03:56.221]                           master <- get("master", mode = "list", 
[17:03:56.221]                             envir = envir, inherits = FALSE)
[17:03:56.221]                           if (inherits(master, c("SOCKnode", 
[17:03:56.221]                             "SOCK0node"))) {
[17:03:56.221]                             sendCondition <<- function(cond) {
[17:03:56.221]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.221]                                 success = TRUE)
[17:03:56.221]                               parallel_sendData(master, data)
[17:03:56.221]                             }
[17:03:56.221]                             return(sendCondition)
[17:03:56.221]                           }
[17:03:56.221]                         }
[17:03:56.221]                         frame <- frame + 1L
[17:03:56.221]                         envir <- sys.frame(frame)
[17:03:56.221]                       }
[17:03:56.221]                     }
[17:03:56.221]                     sendCondition <<- function(cond) NULL
[17:03:56.221]                   }
[17:03:56.221]                 })
[17:03:56.221]                 withCallingHandlers({
[17:03:56.221]                   {
[17:03:56.221]                     Sys.sleep(0.1)
[17:03:56.221]                     kk
[17:03:56.221]                   }
[17:03:56.221]                 }, immediateCondition = function(cond) {
[17:03:56.221]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.221]                   sendCondition(cond)
[17:03:56.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.221]                   {
[17:03:56.221]                     inherits <- base::inherits
[17:03:56.221]                     invokeRestart <- base::invokeRestart
[17:03:56.221]                     is.null <- base::is.null
[17:03:56.221]                     muffled <- FALSE
[17:03:56.221]                     if (inherits(cond, "message")) {
[17:03:56.221]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.221]                       if (muffled) 
[17:03:56.221]                         invokeRestart("muffleMessage")
[17:03:56.221]                     }
[17:03:56.221]                     else if (inherits(cond, "warning")) {
[17:03:56.221]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.221]                       if (muffled) 
[17:03:56.221]                         invokeRestart("muffleWarning")
[17:03:56.221]                     }
[17:03:56.221]                     else if (inherits(cond, "condition")) {
[17:03:56.221]                       if (!is.null(pattern)) {
[17:03:56.221]                         computeRestarts <- base::computeRestarts
[17:03:56.221]                         grepl <- base::grepl
[17:03:56.221]                         restarts <- computeRestarts(cond)
[17:03:56.221]                         for (restart in restarts) {
[17:03:56.221]                           name <- restart$name
[17:03:56.221]                           if (is.null(name)) 
[17:03:56.221]                             next
[17:03:56.221]                           if (!grepl(pattern, name)) 
[17:03:56.221]                             next
[17:03:56.221]                           invokeRestart(restart)
[17:03:56.221]                           muffled <- TRUE
[17:03:56.221]                           break
[17:03:56.221]                         }
[17:03:56.221]                       }
[17:03:56.221]                     }
[17:03:56.221]                     invisible(muffled)
[17:03:56.221]                   }
[17:03:56.221]                   muffleCondition(cond)
[17:03:56.221]                 })
[17:03:56.221]             }))
[17:03:56.221]             future::FutureResult(value = ...future.value$value, 
[17:03:56.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.221]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.221]                     ...future.globalenv.names))
[17:03:56.221]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.221]         }, condition = base::local({
[17:03:56.221]             c <- base::c
[17:03:56.221]             inherits <- base::inherits
[17:03:56.221]             invokeRestart <- base::invokeRestart
[17:03:56.221]             length <- base::length
[17:03:56.221]             list <- base::list
[17:03:56.221]             seq.int <- base::seq.int
[17:03:56.221]             signalCondition <- base::signalCondition
[17:03:56.221]             sys.calls <- base::sys.calls
[17:03:56.221]             `[[` <- base::`[[`
[17:03:56.221]             `+` <- base::`+`
[17:03:56.221]             `<<-` <- base::`<<-`
[17:03:56.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.221]                   3L)]
[17:03:56.221]             }
[17:03:56.221]             function(cond) {
[17:03:56.221]                 is_error <- inherits(cond, "error")
[17:03:56.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.221]                   NULL)
[17:03:56.221]                 if (is_error) {
[17:03:56.221]                   sessionInformation <- function() {
[17:03:56.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.221]                       search = base::search(), system = base::Sys.info())
[17:03:56.221]                   }
[17:03:56.221]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.221]                     cond$call), session = sessionInformation(), 
[17:03:56.221]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.221]                   signalCondition(cond)
[17:03:56.221]                 }
[17:03:56.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.221]                 "immediateCondition"))) {
[17:03:56.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.221]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.221]                   if (TRUE && !signal) {
[17:03:56.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.221]                     {
[17:03:56.221]                       inherits <- base::inherits
[17:03:56.221]                       invokeRestart <- base::invokeRestart
[17:03:56.221]                       is.null <- base::is.null
[17:03:56.221]                       muffled <- FALSE
[17:03:56.221]                       if (inherits(cond, "message")) {
[17:03:56.221]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.221]                         if (muffled) 
[17:03:56.221]                           invokeRestart("muffleMessage")
[17:03:56.221]                       }
[17:03:56.221]                       else if (inherits(cond, "warning")) {
[17:03:56.221]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.221]                         if (muffled) 
[17:03:56.221]                           invokeRestart("muffleWarning")
[17:03:56.221]                       }
[17:03:56.221]                       else if (inherits(cond, "condition")) {
[17:03:56.221]                         if (!is.null(pattern)) {
[17:03:56.221]                           computeRestarts <- base::computeRestarts
[17:03:56.221]                           grepl <- base::grepl
[17:03:56.221]                           restarts <- computeRestarts(cond)
[17:03:56.221]                           for (restart in restarts) {
[17:03:56.221]                             name <- restart$name
[17:03:56.221]                             if (is.null(name)) 
[17:03:56.221]                               next
[17:03:56.221]                             if (!grepl(pattern, name)) 
[17:03:56.221]                               next
[17:03:56.221]                             invokeRestart(restart)
[17:03:56.221]                             muffled <- TRUE
[17:03:56.221]                             break
[17:03:56.221]                           }
[17:03:56.221]                         }
[17:03:56.221]                       }
[17:03:56.221]                       invisible(muffled)
[17:03:56.221]                     }
[17:03:56.221]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.221]                   }
[17:03:56.221]                 }
[17:03:56.221]                 else {
[17:03:56.221]                   if (TRUE) {
[17:03:56.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.221]                     {
[17:03:56.221]                       inherits <- base::inherits
[17:03:56.221]                       invokeRestart <- base::invokeRestart
[17:03:56.221]                       is.null <- base::is.null
[17:03:56.221]                       muffled <- FALSE
[17:03:56.221]                       if (inherits(cond, "message")) {
[17:03:56.221]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.221]                         if (muffled) 
[17:03:56.221]                           invokeRestart("muffleMessage")
[17:03:56.221]                       }
[17:03:56.221]                       else if (inherits(cond, "warning")) {
[17:03:56.221]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.221]                         if (muffled) 
[17:03:56.221]                           invokeRestart("muffleWarning")
[17:03:56.221]                       }
[17:03:56.221]                       else if (inherits(cond, "condition")) {
[17:03:56.221]                         if (!is.null(pattern)) {
[17:03:56.221]                           computeRestarts <- base::computeRestarts
[17:03:56.221]                           grepl <- base::grepl
[17:03:56.221]                           restarts <- computeRestarts(cond)
[17:03:56.221]                           for (restart in restarts) {
[17:03:56.221]                             name <- restart$name
[17:03:56.221]                             if (is.null(name)) 
[17:03:56.221]                               next
[17:03:56.221]                             if (!grepl(pattern, name)) 
[17:03:56.221]                               next
[17:03:56.221]                             invokeRestart(restart)
[17:03:56.221]                             muffled <- TRUE
[17:03:56.221]                             break
[17:03:56.221]                           }
[17:03:56.221]                         }
[17:03:56.221]                       }
[17:03:56.221]                       invisible(muffled)
[17:03:56.221]                     }
[17:03:56.221]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.221]                   }
[17:03:56.221]                 }
[17:03:56.221]             }
[17:03:56.221]         }))
[17:03:56.221]     }, error = function(ex) {
[17:03:56.221]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.221]                 ...future.rng), started = ...future.startTime, 
[17:03:56.221]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.221]             version = "1.8"), class = "FutureResult")
[17:03:56.221]     }, finally = {
[17:03:56.221]         if (!identical(...future.workdir, getwd())) 
[17:03:56.221]             setwd(...future.workdir)
[17:03:56.221]         {
[17:03:56.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.221]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.221]             }
[17:03:56.221]             base::options(...future.oldOptions)
[17:03:56.221]             if (.Platform$OS.type == "windows") {
[17:03:56.221]                 old_names <- names(...future.oldEnvVars)
[17:03:56.221]                 envs <- base::Sys.getenv()
[17:03:56.221]                 names <- names(envs)
[17:03:56.221]                 common <- intersect(names, old_names)
[17:03:56.221]                 added <- setdiff(names, old_names)
[17:03:56.221]                 removed <- setdiff(old_names, names)
[17:03:56.221]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.221]                   envs[common]]
[17:03:56.221]                 NAMES <- toupper(changed)
[17:03:56.221]                 args <- list()
[17:03:56.221]                 for (kk in seq_along(NAMES)) {
[17:03:56.221]                   name <- changed[[kk]]
[17:03:56.221]                   NAME <- NAMES[[kk]]
[17:03:56.221]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.221]                     next
[17:03:56.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.221]                 }
[17:03:56.221]                 NAMES <- toupper(added)
[17:03:56.221]                 for (kk in seq_along(NAMES)) {
[17:03:56.221]                   name <- added[[kk]]
[17:03:56.221]                   NAME <- NAMES[[kk]]
[17:03:56.221]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.221]                     next
[17:03:56.221]                   args[[name]] <- ""
[17:03:56.221]                 }
[17:03:56.221]                 NAMES <- toupper(removed)
[17:03:56.221]                 for (kk in seq_along(NAMES)) {
[17:03:56.221]                   name <- removed[[kk]]
[17:03:56.221]                   NAME <- NAMES[[kk]]
[17:03:56.221]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.221]                     next
[17:03:56.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.221]                 }
[17:03:56.221]                 if (length(args) > 0) 
[17:03:56.221]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.221]             }
[17:03:56.221]             else {
[17:03:56.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.221]             }
[17:03:56.221]             {
[17:03:56.221]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.221]                   0L) {
[17:03:56.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.221]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.221]                   base::options(opts)
[17:03:56.221]                 }
[17:03:56.221]                 {
[17:03:56.221]                   {
[17:03:56.221]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.221]                     NULL
[17:03:56.221]                   }
[17:03:56.221]                   options(future.plan = NULL)
[17:03:56.221]                   if (is.na(NA_character_)) 
[17:03:56.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.221]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.221]                     .init = FALSE)
[17:03:56.221]                 }
[17:03:56.221]             }
[17:03:56.221]         }
[17:03:56.221]     })
[17:03:56.221]     if (TRUE) {
[17:03:56.221]         base::sink(type = "output", split = FALSE)
[17:03:56.221]         if (TRUE) {
[17:03:56.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.221]         }
[17:03:56.221]         else {
[17:03:56.221]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.221]         }
[17:03:56.221]         base::close(...future.stdout)
[17:03:56.221]         ...future.stdout <- NULL
[17:03:56.221]     }
[17:03:56.221]     ...future.result$conditions <- ...future.conditions
[17:03:56.221]     ...future.result$finished <- base::Sys.time()
[17:03:56.221]     ...future.result
[17:03:56.221] }
[17:03:56.224] Poll #1 (0): usedNodes() = 2, workers = 2
[17:03:56.255] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:03:56.266] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.266] - Validating connection of MultisessionFuture
[17:03:56.266] - received message: FutureResult
[17:03:56.266] - Received FutureResult
[17:03:56.267] - Erased future from FutureRegistry
[17:03:56.267] result() for ClusterFuture ...
[17:03:56.267] - result already collected: FutureResult
[17:03:56.267] result() for ClusterFuture ... done
[17:03:56.267] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.267] result() for ClusterFuture ...
[17:03:56.267] - result already collected: FutureResult
[17:03:56.267] result() for ClusterFuture ... done
[17:03:56.267] result() for ClusterFuture ...
[17:03:56.267] - result already collected: FutureResult
[17:03:56.267] result() for ClusterFuture ... done
[17:03:56.268] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:03:56.268] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:03:56.269] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:03:56.269] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:03:56.269] MultisessionFuture started
[17:03:56.269] - Launch lazy future ... done
[17:03:56.269] run() for ‘MultisessionFuture’ ... done
[17:03:56.290] Future #1
[17:03:56.290]  length: 2 (resolved future 1)
[17:03:56.295] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.296] - Validating connection of MultisessionFuture
[17:03:56.296] - received message: FutureResult
[17:03:56.296] - Received FutureResult
[17:03:56.296] - Erased future from FutureRegistry
[17:03:56.296] result() for ClusterFuture ...
[17:03:56.296] - result already collected: FutureResult
[17:03:56.296] result() for ClusterFuture ... done
[17:03:56.296] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.296] Future #2
[17:03:56.297]  length: 1 (resolved future 2)
[17:03:56.380] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.380] - Validating connection of MultisessionFuture
[17:03:56.380] - received message: FutureResult
[17:03:56.380] - Received FutureResult
[17:03:56.380] - Erased future from FutureRegistry
[17:03:56.380] result() for ClusterFuture ...
[17:03:56.380] - result already collected: FutureResult
[17:03:56.380] result() for ClusterFuture ... done
[17:03:56.381] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.381] Future #3
[17:03:56.381]  length: 0 (resolved future 3)
[17:03:56.381] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:03:56.381] resolve() on environment ...
[17:03:56.381]  recursive: 0
[17:03:56.382]  elements: [2] ‘a’, ‘b’
[17:03:56.382]  length: 1 (resolved future 1)
[17:03:56.382]  length: 0 (resolved future 2)
[17:03:56.382] resolve() on environment ... DONE
[17:03:56.383] getGlobalsAndPackages() ...
[17:03:56.383] Searching for globals...
[17:03:56.383] 
[17:03:56.383] Searching for globals ... DONE
[17:03:56.383] - globals: [0] <none>
[17:03:56.383] getGlobalsAndPackages() ... DONE
[17:03:56.384] run() for ‘Future’ ...
[17:03:56.384] - state: ‘created’
[17:03:56.384] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.398] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.398]   - Field: ‘node’
[17:03:56.398]   - Field: ‘label’
[17:03:56.398]   - Field: ‘local’
[17:03:56.398]   - Field: ‘owner’
[17:03:56.399]   - Field: ‘envir’
[17:03:56.399]   - Field: ‘workers’
[17:03:56.399]   - Field: ‘packages’
[17:03:56.399]   - Field: ‘gc’
[17:03:56.399]   - Field: ‘conditions’
[17:03:56.399]   - Field: ‘persistent’
[17:03:56.399]   - Field: ‘expr’
[17:03:56.399]   - Field: ‘uuid’
[17:03:56.399]   - Field: ‘seed’
[17:03:56.399]   - Field: ‘version’
[17:03:56.400]   - Field: ‘result’
[17:03:56.400]   - Field: ‘asynchronous’
[17:03:56.400]   - Field: ‘calls’
[17:03:56.400]   - Field: ‘globals’
[17:03:56.400]   - Field: ‘stdout’
[17:03:56.400]   - Field: ‘earlySignal’
[17:03:56.400]   - Field: ‘lazy’
[17:03:56.400]   - Field: ‘state’
[17:03:56.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.400] - Launch lazy future ...
[17:03:56.401] Packages needed by the future expression (n = 0): <none>
[17:03:56.401] Packages needed by future strategies (n = 0): <none>
[17:03:56.401] {
[17:03:56.401]     {
[17:03:56.401]         {
[17:03:56.401]             ...future.startTime <- base::Sys.time()
[17:03:56.401]             {
[17:03:56.401]                 {
[17:03:56.401]                   {
[17:03:56.401]                     {
[17:03:56.401]                       base::local({
[17:03:56.401]                         has_future <- base::requireNamespace("future", 
[17:03:56.401]                           quietly = TRUE)
[17:03:56.401]                         if (has_future) {
[17:03:56.401]                           ns <- base::getNamespace("future")
[17:03:56.401]                           version <- ns[[".package"]][["version"]]
[17:03:56.401]                           if (is.null(version)) 
[17:03:56.401]                             version <- utils::packageVersion("future")
[17:03:56.401]                         }
[17:03:56.401]                         else {
[17:03:56.401]                           version <- NULL
[17:03:56.401]                         }
[17:03:56.401]                         if (!has_future || version < "1.8.0") {
[17:03:56.401]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.401]                             "", base::R.version$version.string), 
[17:03:56.401]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.401]                               "release", "version")], collapse = " "), 
[17:03:56.401]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.401]                             info)
[17:03:56.401]                           info <- base::paste(info, collapse = "; ")
[17:03:56.401]                           if (!has_future) {
[17:03:56.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.401]                               info)
[17:03:56.401]                           }
[17:03:56.401]                           else {
[17:03:56.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.401]                               info, version)
[17:03:56.401]                           }
[17:03:56.401]                           base::stop(msg)
[17:03:56.401]                         }
[17:03:56.401]                       })
[17:03:56.401]                     }
[17:03:56.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.401]                     base::options(mc.cores = 1L)
[17:03:56.401]                   }
[17:03:56.401]                   ...future.strategy.old <- future::plan("list")
[17:03:56.401]                   options(future.plan = NULL)
[17:03:56.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.401]                 }
[17:03:56.401]                 ...future.workdir <- getwd()
[17:03:56.401]             }
[17:03:56.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.401]         }
[17:03:56.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.401]             base::names(...future.oldOptions))
[17:03:56.401]     }
[17:03:56.401]     if (FALSE) {
[17:03:56.401]     }
[17:03:56.401]     else {
[17:03:56.401]         if (TRUE) {
[17:03:56.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.401]                 open = "w")
[17:03:56.401]         }
[17:03:56.401]         else {
[17:03:56.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.401]         }
[17:03:56.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.401]             base::sink(type = "output", split = FALSE)
[17:03:56.401]             base::close(...future.stdout)
[17:03:56.401]         }, add = TRUE)
[17:03:56.401]     }
[17:03:56.401]     ...future.frame <- base::sys.nframe()
[17:03:56.401]     ...future.conditions <- base::list()
[17:03:56.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.401]     if (FALSE) {
[17:03:56.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.401]     }
[17:03:56.401]     ...future.result <- base::tryCatch({
[17:03:56.401]         base::withCallingHandlers({
[17:03:56.401]             ...future.value <- base::withVisible(base::local({
[17:03:56.401]                 ...future.makeSendCondition <- base::local({
[17:03:56.401]                   sendCondition <- NULL
[17:03:56.401]                   function(frame = 1L) {
[17:03:56.401]                     if (is.function(sendCondition)) 
[17:03:56.401]                       return(sendCondition)
[17:03:56.401]                     ns <- getNamespace("parallel")
[17:03:56.401]                     if (exists("sendData", mode = "function", 
[17:03:56.401]                       envir = ns)) {
[17:03:56.401]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.401]                         envir = ns)
[17:03:56.401]                       envir <- sys.frame(frame)
[17:03:56.401]                       master <- NULL
[17:03:56.401]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.401]                         !identical(envir, emptyenv())) {
[17:03:56.401]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.401]                           inherits = FALSE)) {
[17:03:56.401]                           master <- get("master", mode = "list", 
[17:03:56.401]                             envir = envir, inherits = FALSE)
[17:03:56.401]                           if (inherits(master, c("SOCKnode", 
[17:03:56.401]                             "SOCK0node"))) {
[17:03:56.401]                             sendCondition <<- function(cond) {
[17:03:56.401]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.401]                                 success = TRUE)
[17:03:56.401]                               parallel_sendData(master, data)
[17:03:56.401]                             }
[17:03:56.401]                             return(sendCondition)
[17:03:56.401]                           }
[17:03:56.401]                         }
[17:03:56.401]                         frame <- frame + 1L
[17:03:56.401]                         envir <- sys.frame(frame)
[17:03:56.401]                       }
[17:03:56.401]                     }
[17:03:56.401]                     sendCondition <<- function(cond) NULL
[17:03:56.401]                   }
[17:03:56.401]                 })
[17:03:56.401]                 withCallingHandlers({
[17:03:56.401]                   1
[17:03:56.401]                 }, immediateCondition = function(cond) {
[17:03:56.401]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.401]                   sendCondition(cond)
[17:03:56.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.401]                   {
[17:03:56.401]                     inherits <- base::inherits
[17:03:56.401]                     invokeRestart <- base::invokeRestart
[17:03:56.401]                     is.null <- base::is.null
[17:03:56.401]                     muffled <- FALSE
[17:03:56.401]                     if (inherits(cond, "message")) {
[17:03:56.401]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.401]                       if (muffled) 
[17:03:56.401]                         invokeRestart("muffleMessage")
[17:03:56.401]                     }
[17:03:56.401]                     else if (inherits(cond, "warning")) {
[17:03:56.401]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.401]                       if (muffled) 
[17:03:56.401]                         invokeRestart("muffleWarning")
[17:03:56.401]                     }
[17:03:56.401]                     else if (inherits(cond, "condition")) {
[17:03:56.401]                       if (!is.null(pattern)) {
[17:03:56.401]                         computeRestarts <- base::computeRestarts
[17:03:56.401]                         grepl <- base::grepl
[17:03:56.401]                         restarts <- computeRestarts(cond)
[17:03:56.401]                         for (restart in restarts) {
[17:03:56.401]                           name <- restart$name
[17:03:56.401]                           if (is.null(name)) 
[17:03:56.401]                             next
[17:03:56.401]                           if (!grepl(pattern, name)) 
[17:03:56.401]                             next
[17:03:56.401]                           invokeRestart(restart)
[17:03:56.401]                           muffled <- TRUE
[17:03:56.401]                           break
[17:03:56.401]                         }
[17:03:56.401]                       }
[17:03:56.401]                     }
[17:03:56.401]                     invisible(muffled)
[17:03:56.401]                   }
[17:03:56.401]                   muffleCondition(cond)
[17:03:56.401]                 })
[17:03:56.401]             }))
[17:03:56.401]             future::FutureResult(value = ...future.value$value, 
[17:03:56.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.401]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.401]                     ...future.globalenv.names))
[17:03:56.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.401]         }, condition = base::local({
[17:03:56.401]             c <- base::c
[17:03:56.401]             inherits <- base::inherits
[17:03:56.401]             invokeRestart <- base::invokeRestart
[17:03:56.401]             length <- base::length
[17:03:56.401]             list <- base::list
[17:03:56.401]             seq.int <- base::seq.int
[17:03:56.401]             signalCondition <- base::signalCondition
[17:03:56.401]             sys.calls <- base::sys.calls
[17:03:56.401]             `[[` <- base::`[[`
[17:03:56.401]             `+` <- base::`+`
[17:03:56.401]             `<<-` <- base::`<<-`
[17:03:56.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.401]                   3L)]
[17:03:56.401]             }
[17:03:56.401]             function(cond) {
[17:03:56.401]                 is_error <- inherits(cond, "error")
[17:03:56.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.401]                   NULL)
[17:03:56.401]                 if (is_error) {
[17:03:56.401]                   sessionInformation <- function() {
[17:03:56.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.401]                       search = base::search(), system = base::Sys.info())
[17:03:56.401]                   }
[17:03:56.401]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.401]                     cond$call), session = sessionInformation(), 
[17:03:56.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.401]                   signalCondition(cond)
[17:03:56.401]                 }
[17:03:56.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.401]                 "immediateCondition"))) {
[17:03:56.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.401]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.401]                   if (TRUE && !signal) {
[17:03:56.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.401]                     {
[17:03:56.401]                       inherits <- base::inherits
[17:03:56.401]                       invokeRestart <- base::invokeRestart
[17:03:56.401]                       is.null <- base::is.null
[17:03:56.401]                       muffled <- FALSE
[17:03:56.401]                       if (inherits(cond, "message")) {
[17:03:56.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.401]                         if (muffled) 
[17:03:56.401]                           invokeRestart("muffleMessage")
[17:03:56.401]                       }
[17:03:56.401]                       else if (inherits(cond, "warning")) {
[17:03:56.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.401]                         if (muffled) 
[17:03:56.401]                           invokeRestart("muffleWarning")
[17:03:56.401]                       }
[17:03:56.401]                       else if (inherits(cond, "condition")) {
[17:03:56.401]                         if (!is.null(pattern)) {
[17:03:56.401]                           computeRestarts <- base::computeRestarts
[17:03:56.401]                           grepl <- base::grepl
[17:03:56.401]                           restarts <- computeRestarts(cond)
[17:03:56.401]                           for (restart in restarts) {
[17:03:56.401]                             name <- restart$name
[17:03:56.401]                             if (is.null(name)) 
[17:03:56.401]                               next
[17:03:56.401]                             if (!grepl(pattern, name)) 
[17:03:56.401]                               next
[17:03:56.401]                             invokeRestart(restart)
[17:03:56.401]                             muffled <- TRUE
[17:03:56.401]                             break
[17:03:56.401]                           }
[17:03:56.401]                         }
[17:03:56.401]                       }
[17:03:56.401]                       invisible(muffled)
[17:03:56.401]                     }
[17:03:56.401]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.401]                   }
[17:03:56.401]                 }
[17:03:56.401]                 else {
[17:03:56.401]                   if (TRUE) {
[17:03:56.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.401]                     {
[17:03:56.401]                       inherits <- base::inherits
[17:03:56.401]                       invokeRestart <- base::invokeRestart
[17:03:56.401]                       is.null <- base::is.null
[17:03:56.401]                       muffled <- FALSE
[17:03:56.401]                       if (inherits(cond, "message")) {
[17:03:56.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.401]                         if (muffled) 
[17:03:56.401]                           invokeRestart("muffleMessage")
[17:03:56.401]                       }
[17:03:56.401]                       else if (inherits(cond, "warning")) {
[17:03:56.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.401]                         if (muffled) 
[17:03:56.401]                           invokeRestart("muffleWarning")
[17:03:56.401]                       }
[17:03:56.401]                       else if (inherits(cond, "condition")) {
[17:03:56.401]                         if (!is.null(pattern)) {
[17:03:56.401]                           computeRestarts <- base::computeRestarts
[17:03:56.401]                           grepl <- base::grepl
[17:03:56.401]                           restarts <- computeRestarts(cond)
[17:03:56.401]                           for (restart in restarts) {
[17:03:56.401]                             name <- restart$name
[17:03:56.401]                             if (is.null(name)) 
[17:03:56.401]                               next
[17:03:56.401]                             if (!grepl(pattern, name)) 
[17:03:56.401]                               next
[17:03:56.401]                             invokeRestart(restart)
[17:03:56.401]                             muffled <- TRUE
[17:03:56.401]                             break
[17:03:56.401]                           }
[17:03:56.401]                         }
[17:03:56.401]                       }
[17:03:56.401]                       invisible(muffled)
[17:03:56.401]                     }
[17:03:56.401]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.401]                   }
[17:03:56.401]                 }
[17:03:56.401]             }
[17:03:56.401]         }))
[17:03:56.401]     }, error = function(ex) {
[17:03:56.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.401]                 ...future.rng), started = ...future.startTime, 
[17:03:56.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.401]             version = "1.8"), class = "FutureResult")
[17:03:56.401]     }, finally = {
[17:03:56.401]         if (!identical(...future.workdir, getwd())) 
[17:03:56.401]             setwd(...future.workdir)
[17:03:56.401]         {
[17:03:56.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.401]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.401]             }
[17:03:56.401]             base::options(...future.oldOptions)
[17:03:56.401]             if (.Platform$OS.type == "windows") {
[17:03:56.401]                 old_names <- names(...future.oldEnvVars)
[17:03:56.401]                 envs <- base::Sys.getenv()
[17:03:56.401]                 names <- names(envs)
[17:03:56.401]                 common <- intersect(names, old_names)
[17:03:56.401]                 added <- setdiff(names, old_names)
[17:03:56.401]                 removed <- setdiff(old_names, names)
[17:03:56.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.401]                   envs[common]]
[17:03:56.401]                 NAMES <- toupper(changed)
[17:03:56.401]                 args <- list()
[17:03:56.401]                 for (kk in seq_along(NAMES)) {
[17:03:56.401]                   name <- changed[[kk]]
[17:03:56.401]                   NAME <- NAMES[[kk]]
[17:03:56.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.401]                     next
[17:03:56.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.401]                 }
[17:03:56.401]                 NAMES <- toupper(added)
[17:03:56.401]                 for (kk in seq_along(NAMES)) {
[17:03:56.401]                   name <- added[[kk]]
[17:03:56.401]                   NAME <- NAMES[[kk]]
[17:03:56.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.401]                     next
[17:03:56.401]                   args[[name]] <- ""
[17:03:56.401]                 }
[17:03:56.401]                 NAMES <- toupper(removed)
[17:03:56.401]                 for (kk in seq_along(NAMES)) {
[17:03:56.401]                   name <- removed[[kk]]
[17:03:56.401]                   NAME <- NAMES[[kk]]
[17:03:56.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.401]                     next
[17:03:56.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.401]                 }
[17:03:56.401]                 if (length(args) > 0) 
[17:03:56.401]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.401]             }
[17:03:56.401]             else {
[17:03:56.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.401]             }
[17:03:56.401]             {
[17:03:56.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.401]                   0L) {
[17:03:56.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.401]                   base::options(opts)
[17:03:56.401]                 }
[17:03:56.401]                 {
[17:03:56.401]                   {
[17:03:56.401]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.401]                     NULL
[17:03:56.401]                   }
[17:03:56.401]                   options(future.plan = NULL)
[17:03:56.401]                   if (is.na(NA_character_)) 
[17:03:56.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.401]                     .init = FALSE)
[17:03:56.401]                 }
[17:03:56.401]             }
[17:03:56.401]         }
[17:03:56.401]     })
[17:03:56.401]     if (TRUE) {
[17:03:56.401]         base::sink(type = "output", split = FALSE)
[17:03:56.401]         if (TRUE) {
[17:03:56.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.401]         }
[17:03:56.401]         else {
[17:03:56.401]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.401]         }
[17:03:56.401]         base::close(...future.stdout)
[17:03:56.401]         ...future.stdout <- NULL
[17:03:56.401]     }
[17:03:56.401]     ...future.result$conditions <- ...future.conditions
[17:03:56.401]     ...future.result$finished <- base::Sys.time()
[17:03:56.401]     ...future.result
[17:03:56.401] }
[17:03:56.404] MultisessionFuture started
[17:03:56.404] - Launch lazy future ... done
[17:03:56.405] run() for ‘MultisessionFuture’ ... done
[17:03:56.405] getGlobalsAndPackages() ...
[17:03:56.405] Searching for globals...
[17:03:56.405] 
[17:03:56.405] Searching for globals ... DONE
[17:03:56.405] - globals: [0] <none>
[17:03:56.405] getGlobalsAndPackages() ... DONE
[17:03:56.406] run() for ‘Future’ ...
[17:03:56.406] - state: ‘created’
[17:03:56.406] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.420] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.420]   - Field: ‘node’
[17:03:56.420]   - Field: ‘label’
[17:03:56.420]   - Field: ‘local’
[17:03:56.420]   - Field: ‘owner’
[17:03:56.420]   - Field: ‘envir’
[17:03:56.420]   - Field: ‘workers’
[17:03:56.420]   - Field: ‘packages’
[17:03:56.420]   - Field: ‘gc’
[17:03:56.420]   - Field: ‘conditions’
[17:03:56.420]   - Field: ‘persistent’
[17:03:56.421]   - Field: ‘expr’
[17:03:56.421]   - Field: ‘uuid’
[17:03:56.421]   - Field: ‘seed’
[17:03:56.421]   - Field: ‘version’
[17:03:56.421]   - Field: ‘result’
[17:03:56.421]   - Field: ‘asynchronous’
[17:03:56.421]   - Field: ‘calls’
[17:03:56.421]   - Field: ‘globals’
[17:03:56.421]   - Field: ‘stdout’
[17:03:56.421]   - Field: ‘earlySignal’
[17:03:56.421]   - Field: ‘lazy’
[17:03:56.422]   - Field: ‘state’
[17:03:56.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.422] - Launch lazy future ...
[17:03:56.422] Packages needed by the future expression (n = 0): <none>
[17:03:56.422] Packages needed by future strategies (n = 0): <none>
[17:03:56.422] {
[17:03:56.422]     {
[17:03:56.422]         {
[17:03:56.422]             ...future.startTime <- base::Sys.time()
[17:03:56.422]             {
[17:03:56.422]                 {
[17:03:56.422]                   {
[17:03:56.422]                     {
[17:03:56.422]                       base::local({
[17:03:56.422]                         has_future <- base::requireNamespace("future", 
[17:03:56.422]                           quietly = TRUE)
[17:03:56.422]                         if (has_future) {
[17:03:56.422]                           ns <- base::getNamespace("future")
[17:03:56.422]                           version <- ns[[".package"]][["version"]]
[17:03:56.422]                           if (is.null(version)) 
[17:03:56.422]                             version <- utils::packageVersion("future")
[17:03:56.422]                         }
[17:03:56.422]                         else {
[17:03:56.422]                           version <- NULL
[17:03:56.422]                         }
[17:03:56.422]                         if (!has_future || version < "1.8.0") {
[17:03:56.422]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.422]                             "", base::R.version$version.string), 
[17:03:56.422]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.422]                               "release", "version")], collapse = " "), 
[17:03:56.422]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.422]                             info)
[17:03:56.422]                           info <- base::paste(info, collapse = "; ")
[17:03:56.422]                           if (!has_future) {
[17:03:56.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.422]                               info)
[17:03:56.422]                           }
[17:03:56.422]                           else {
[17:03:56.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.422]                               info, version)
[17:03:56.422]                           }
[17:03:56.422]                           base::stop(msg)
[17:03:56.422]                         }
[17:03:56.422]                       })
[17:03:56.422]                     }
[17:03:56.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.422]                     base::options(mc.cores = 1L)
[17:03:56.422]                   }
[17:03:56.422]                   ...future.strategy.old <- future::plan("list")
[17:03:56.422]                   options(future.plan = NULL)
[17:03:56.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.422]                 }
[17:03:56.422]                 ...future.workdir <- getwd()
[17:03:56.422]             }
[17:03:56.422]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.422]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.422]         }
[17:03:56.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.422]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.422]             base::names(...future.oldOptions))
[17:03:56.422]     }
[17:03:56.422]     if (FALSE) {
[17:03:56.422]     }
[17:03:56.422]     else {
[17:03:56.422]         if (TRUE) {
[17:03:56.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.422]                 open = "w")
[17:03:56.422]         }
[17:03:56.422]         else {
[17:03:56.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.422]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.422]         }
[17:03:56.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.422]             base::sink(type = "output", split = FALSE)
[17:03:56.422]             base::close(...future.stdout)
[17:03:56.422]         }, add = TRUE)
[17:03:56.422]     }
[17:03:56.422]     ...future.frame <- base::sys.nframe()
[17:03:56.422]     ...future.conditions <- base::list()
[17:03:56.422]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.422]     if (FALSE) {
[17:03:56.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.422]     }
[17:03:56.422]     ...future.result <- base::tryCatch({
[17:03:56.422]         base::withCallingHandlers({
[17:03:56.422]             ...future.value <- base::withVisible(base::local({
[17:03:56.422]                 ...future.makeSendCondition <- base::local({
[17:03:56.422]                   sendCondition <- NULL
[17:03:56.422]                   function(frame = 1L) {
[17:03:56.422]                     if (is.function(sendCondition)) 
[17:03:56.422]                       return(sendCondition)
[17:03:56.422]                     ns <- getNamespace("parallel")
[17:03:56.422]                     if (exists("sendData", mode = "function", 
[17:03:56.422]                       envir = ns)) {
[17:03:56.422]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.422]                         envir = ns)
[17:03:56.422]                       envir <- sys.frame(frame)
[17:03:56.422]                       master <- NULL
[17:03:56.422]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.422]                         !identical(envir, emptyenv())) {
[17:03:56.422]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.422]                           inherits = FALSE)) {
[17:03:56.422]                           master <- get("master", mode = "list", 
[17:03:56.422]                             envir = envir, inherits = FALSE)
[17:03:56.422]                           if (inherits(master, c("SOCKnode", 
[17:03:56.422]                             "SOCK0node"))) {
[17:03:56.422]                             sendCondition <<- function(cond) {
[17:03:56.422]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.422]                                 success = TRUE)
[17:03:56.422]                               parallel_sendData(master, data)
[17:03:56.422]                             }
[17:03:56.422]                             return(sendCondition)
[17:03:56.422]                           }
[17:03:56.422]                         }
[17:03:56.422]                         frame <- frame + 1L
[17:03:56.422]                         envir <- sys.frame(frame)
[17:03:56.422]                       }
[17:03:56.422]                     }
[17:03:56.422]                     sendCondition <<- function(cond) NULL
[17:03:56.422]                   }
[17:03:56.422]                 })
[17:03:56.422]                 withCallingHandlers({
[17:03:56.422]                   2
[17:03:56.422]                 }, immediateCondition = function(cond) {
[17:03:56.422]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.422]                   sendCondition(cond)
[17:03:56.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.422]                   {
[17:03:56.422]                     inherits <- base::inherits
[17:03:56.422]                     invokeRestart <- base::invokeRestart
[17:03:56.422]                     is.null <- base::is.null
[17:03:56.422]                     muffled <- FALSE
[17:03:56.422]                     if (inherits(cond, "message")) {
[17:03:56.422]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.422]                       if (muffled) 
[17:03:56.422]                         invokeRestart("muffleMessage")
[17:03:56.422]                     }
[17:03:56.422]                     else if (inherits(cond, "warning")) {
[17:03:56.422]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.422]                       if (muffled) 
[17:03:56.422]                         invokeRestart("muffleWarning")
[17:03:56.422]                     }
[17:03:56.422]                     else if (inherits(cond, "condition")) {
[17:03:56.422]                       if (!is.null(pattern)) {
[17:03:56.422]                         computeRestarts <- base::computeRestarts
[17:03:56.422]                         grepl <- base::grepl
[17:03:56.422]                         restarts <- computeRestarts(cond)
[17:03:56.422]                         for (restart in restarts) {
[17:03:56.422]                           name <- restart$name
[17:03:56.422]                           if (is.null(name)) 
[17:03:56.422]                             next
[17:03:56.422]                           if (!grepl(pattern, name)) 
[17:03:56.422]                             next
[17:03:56.422]                           invokeRestart(restart)
[17:03:56.422]                           muffled <- TRUE
[17:03:56.422]                           break
[17:03:56.422]                         }
[17:03:56.422]                       }
[17:03:56.422]                     }
[17:03:56.422]                     invisible(muffled)
[17:03:56.422]                   }
[17:03:56.422]                   muffleCondition(cond)
[17:03:56.422]                 })
[17:03:56.422]             }))
[17:03:56.422]             future::FutureResult(value = ...future.value$value, 
[17:03:56.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.422]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.422]                     ...future.globalenv.names))
[17:03:56.422]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.422]         }, condition = base::local({
[17:03:56.422]             c <- base::c
[17:03:56.422]             inherits <- base::inherits
[17:03:56.422]             invokeRestart <- base::invokeRestart
[17:03:56.422]             length <- base::length
[17:03:56.422]             list <- base::list
[17:03:56.422]             seq.int <- base::seq.int
[17:03:56.422]             signalCondition <- base::signalCondition
[17:03:56.422]             sys.calls <- base::sys.calls
[17:03:56.422]             `[[` <- base::`[[`
[17:03:56.422]             `+` <- base::`+`
[17:03:56.422]             `<<-` <- base::`<<-`
[17:03:56.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.422]                   3L)]
[17:03:56.422]             }
[17:03:56.422]             function(cond) {
[17:03:56.422]                 is_error <- inherits(cond, "error")
[17:03:56.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.422]                   NULL)
[17:03:56.422]                 if (is_error) {
[17:03:56.422]                   sessionInformation <- function() {
[17:03:56.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.422]                       search = base::search(), system = base::Sys.info())
[17:03:56.422]                   }
[17:03:56.422]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.422]                     cond$call), session = sessionInformation(), 
[17:03:56.422]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.422]                   signalCondition(cond)
[17:03:56.422]                 }
[17:03:56.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.422]                 "immediateCondition"))) {
[17:03:56.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.422]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.422]                   if (TRUE && !signal) {
[17:03:56.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.422]                     {
[17:03:56.422]                       inherits <- base::inherits
[17:03:56.422]                       invokeRestart <- base::invokeRestart
[17:03:56.422]                       is.null <- base::is.null
[17:03:56.422]                       muffled <- FALSE
[17:03:56.422]                       if (inherits(cond, "message")) {
[17:03:56.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.422]                         if (muffled) 
[17:03:56.422]                           invokeRestart("muffleMessage")
[17:03:56.422]                       }
[17:03:56.422]                       else if (inherits(cond, "warning")) {
[17:03:56.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.422]                         if (muffled) 
[17:03:56.422]                           invokeRestart("muffleWarning")
[17:03:56.422]                       }
[17:03:56.422]                       else if (inherits(cond, "condition")) {
[17:03:56.422]                         if (!is.null(pattern)) {
[17:03:56.422]                           computeRestarts <- base::computeRestarts
[17:03:56.422]                           grepl <- base::grepl
[17:03:56.422]                           restarts <- computeRestarts(cond)
[17:03:56.422]                           for (restart in restarts) {
[17:03:56.422]                             name <- restart$name
[17:03:56.422]                             if (is.null(name)) 
[17:03:56.422]                               next
[17:03:56.422]                             if (!grepl(pattern, name)) 
[17:03:56.422]                               next
[17:03:56.422]                             invokeRestart(restart)
[17:03:56.422]                             muffled <- TRUE
[17:03:56.422]                             break
[17:03:56.422]                           }
[17:03:56.422]                         }
[17:03:56.422]                       }
[17:03:56.422]                       invisible(muffled)
[17:03:56.422]                     }
[17:03:56.422]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.422]                   }
[17:03:56.422]                 }
[17:03:56.422]                 else {
[17:03:56.422]                   if (TRUE) {
[17:03:56.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.422]                     {
[17:03:56.422]                       inherits <- base::inherits
[17:03:56.422]                       invokeRestart <- base::invokeRestart
[17:03:56.422]                       is.null <- base::is.null
[17:03:56.422]                       muffled <- FALSE
[17:03:56.422]                       if (inherits(cond, "message")) {
[17:03:56.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.422]                         if (muffled) 
[17:03:56.422]                           invokeRestart("muffleMessage")
[17:03:56.422]                       }
[17:03:56.422]                       else if (inherits(cond, "warning")) {
[17:03:56.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.422]                         if (muffled) 
[17:03:56.422]                           invokeRestart("muffleWarning")
[17:03:56.422]                       }
[17:03:56.422]                       else if (inherits(cond, "condition")) {
[17:03:56.422]                         if (!is.null(pattern)) {
[17:03:56.422]                           computeRestarts <- base::computeRestarts
[17:03:56.422]                           grepl <- base::grepl
[17:03:56.422]                           restarts <- computeRestarts(cond)
[17:03:56.422]                           for (restart in restarts) {
[17:03:56.422]                             name <- restart$name
[17:03:56.422]                             if (is.null(name)) 
[17:03:56.422]                               next
[17:03:56.422]                             if (!grepl(pattern, name)) 
[17:03:56.422]                               next
[17:03:56.422]                             invokeRestart(restart)
[17:03:56.422]                             muffled <- TRUE
[17:03:56.422]                             break
[17:03:56.422]                           }
[17:03:56.422]                         }
[17:03:56.422]                       }
[17:03:56.422]                       invisible(muffled)
[17:03:56.422]                     }
[17:03:56.422]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.422]                   }
[17:03:56.422]                 }
[17:03:56.422]             }
[17:03:56.422]         }))
[17:03:56.422]     }, error = function(ex) {
[17:03:56.422]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.422]                 ...future.rng), started = ...future.startTime, 
[17:03:56.422]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.422]             version = "1.8"), class = "FutureResult")
[17:03:56.422]     }, finally = {
[17:03:56.422]         if (!identical(...future.workdir, getwd())) 
[17:03:56.422]             setwd(...future.workdir)
[17:03:56.422]         {
[17:03:56.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.422]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.422]             }
[17:03:56.422]             base::options(...future.oldOptions)
[17:03:56.422]             if (.Platform$OS.type == "windows") {
[17:03:56.422]                 old_names <- names(...future.oldEnvVars)
[17:03:56.422]                 envs <- base::Sys.getenv()
[17:03:56.422]                 names <- names(envs)
[17:03:56.422]                 common <- intersect(names, old_names)
[17:03:56.422]                 added <- setdiff(names, old_names)
[17:03:56.422]                 removed <- setdiff(old_names, names)
[17:03:56.422]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.422]                   envs[common]]
[17:03:56.422]                 NAMES <- toupper(changed)
[17:03:56.422]                 args <- list()
[17:03:56.422]                 for (kk in seq_along(NAMES)) {
[17:03:56.422]                   name <- changed[[kk]]
[17:03:56.422]                   NAME <- NAMES[[kk]]
[17:03:56.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.422]                     next
[17:03:56.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.422]                 }
[17:03:56.422]                 NAMES <- toupper(added)
[17:03:56.422]                 for (kk in seq_along(NAMES)) {
[17:03:56.422]                   name <- added[[kk]]
[17:03:56.422]                   NAME <- NAMES[[kk]]
[17:03:56.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.422]                     next
[17:03:56.422]                   args[[name]] <- ""
[17:03:56.422]                 }
[17:03:56.422]                 NAMES <- toupper(removed)
[17:03:56.422]                 for (kk in seq_along(NAMES)) {
[17:03:56.422]                   name <- removed[[kk]]
[17:03:56.422]                   NAME <- NAMES[[kk]]
[17:03:56.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.422]                     next
[17:03:56.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.422]                 }
[17:03:56.422]                 if (length(args) > 0) 
[17:03:56.422]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.422]             }
[17:03:56.422]             else {
[17:03:56.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.422]             }
[17:03:56.422]             {
[17:03:56.422]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.422]                   0L) {
[17:03:56.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.422]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.422]                   base::options(opts)
[17:03:56.422]                 }
[17:03:56.422]                 {
[17:03:56.422]                   {
[17:03:56.422]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.422]                     NULL
[17:03:56.422]                   }
[17:03:56.422]                   options(future.plan = NULL)
[17:03:56.422]                   if (is.na(NA_character_)) 
[17:03:56.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.422]                     .init = FALSE)
[17:03:56.422]                 }
[17:03:56.422]             }
[17:03:56.422]         }
[17:03:56.422]     })
[17:03:56.422]     if (TRUE) {
[17:03:56.422]         base::sink(type = "output", split = FALSE)
[17:03:56.422]         if (TRUE) {
[17:03:56.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.422]         }
[17:03:56.422]         else {
[17:03:56.422]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.422]         }
[17:03:56.422]         base::close(...future.stdout)
[17:03:56.422]         ...future.stdout <- NULL
[17:03:56.422]     }
[17:03:56.422]     ...future.result$conditions <- ...future.conditions
[17:03:56.422]     ...future.result$finished <- base::Sys.time()
[17:03:56.422]     ...future.result
[17:03:56.422] }
[17:03:56.425] MultisessionFuture started
[17:03:56.426] - Launch lazy future ... done
[17:03:56.426] run() for ‘MultisessionFuture’ ... done
[17:03:56.426] resolve() on environment ...
[17:03:56.426]  recursive: 0
[17:03:56.427]  elements: [3] ‘a’, ‘b’, ‘c’
[17:03:56.427] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.427] - Validating connection of MultisessionFuture
[17:03:56.428] - received message: FutureResult
[17:03:56.428] - Received FutureResult
[17:03:56.428] - Erased future from FutureRegistry
[17:03:56.428] result() for ClusterFuture ...
[17:03:56.428] - result already collected: FutureResult
[17:03:56.428] result() for ClusterFuture ... done
[17:03:56.428] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.428] Future #1
[17:03:56.428]  length: 2 (resolved future 1)
[17:03:56.429] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.429] - Validating connection of MultisessionFuture
[17:03:56.429] - received message: FutureResult
[17:03:56.429] - Received FutureResult
[17:03:56.429] - Erased future from FutureRegistry
[17:03:56.429] result() for ClusterFuture ...
[17:03:56.429] - result already collected: FutureResult
[17:03:56.430] result() for ClusterFuture ... done
[17:03:56.430] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.430] Future #2
[17:03:56.430]  length: 1 (resolved future 2)
[17:03:56.430]  length: 0 (resolved future 3)
[17:03:56.430] resolve() on environment ... DONE
[17:03:56.431] getGlobalsAndPackages() ...
[17:03:56.431] Searching for globals...
[17:03:56.431] - globals found: [1] ‘{’
[17:03:56.431] Searching for globals ... DONE
[17:03:56.432] Resolving globals: FALSE
[17:03:56.432] 
[17:03:56.432] 
[17:03:56.432] getGlobalsAndPackages() ... DONE
[17:03:56.432] run() for ‘Future’ ...
[17:03:56.432] - state: ‘created’
[17:03:56.432] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.446] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.446]   - Field: ‘node’
[17:03:56.446]   - Field: ‘label’
[17:03:56.446]   - Field: ‘local’
[17:03:56.447]   - Field: ‘owner’
[17:03:56.447]   - Field: ‘envir’
[17:03:56.447]   - Field: ‘workers’
[17:03:56.447]   - Field: ‘packages’
[17:03:56.447]   - Field: ‘gc’
[17:03:56.447]   - Field: ‘conditions’
[17:03:56.447]   - Field: ‘persistent’
[17:03:56.447]   - Field: ‘expr’
[17:03:56.447]   - Field: ‘uuid’
[17:03:56.447]   - Field: ‘seed’
[17:03:56.448]   - Field: ‘version’
[17:03:56.448]   - Field: ‘result’
[17:03:56.448]   - Field: ‘asynchronous’
[17:03:56.448]   - Field: ‘calls’
[17:03:56.448]   - Field: ‘globals’
[17:03:56.448]   - Field: ‘stdout’
[17:03:56.448]   - Field: ‘earlySignal’
[17:03:56.448]   - Field: ‘lazy’
[17:03:56.448]   - Field: ‘state’
[17:03:56.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.448] - Launch lazy future ...
[17:03:56.449] Packages needed by the future expression (n = 0): <none>
[17:03:56.449] Packages needed by future strategies (n = 0): <none>
[17:03:56.449] {
[17:03:56.449]     {
[17:03:56.449]         {
[17:03:56.449]             ...future.startTime <- base::Sys.time()
[17:03:56.449]             {
[17:03:56.449]                 {
[17:03:56.449]                   {
[17:03:56.449]                     {
[17:03:56.449]                       base::local({
[17:03:56.449]                         has_future <- base::requireNamespace("future", 
[17:03:56.449]                           quietly = TRUE)
[17:03:56.449]                         if (has_future) {
[17:03:56.449]                           ns <- base::getNamespace("future")
[17:03:56.449]                           version <- ns[[".package"]][["version"]]
[17:03:56.449]                           if (is.null(version)) 
[17:03:56.449]                             version <- utils::packageVersion("future")
[17:03:56.449]                         }
[17:03:56.449]                         else {
[17:03:56.449]                           version <- NULL
[17:03:56.449]                         }
[17:03:56.449]                         if (!has_future || version < "1.8.0") {
[17:03:56.449]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.449]                             "", base::R.version$version.string), 
[17:03:56.449]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.449]                               "release", "version")], collapse = " "), 
[17:03:56.449]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.449]                             info)
[17:03:56.449]                           info <- base::paste(info, collapse = "; ")
[17:03:56.449]                           if (!has_future) {
[17:03:56.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.449]                               info)
[17:03:56.449]                           }
[17:03:56.449]                           else {
[17:03:56.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.449]                               info, version)
[17:03:56.449]                           }
[17:03:56.449]                           base::stop(msg)
[17:03:56.449]                         }
[17:03:56.449]                       })
[17:03:56.449]                     }
[17:03:56.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.449]                     base::options(mc.cores = 1L)
[17:03:56.449]                   }
[17:03:56.449]                   ...future.strategy.old <- future::plan("list")
[17:03:56.449]                   options(future.plan = NULL)
[17:03:56.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.449]                 }
[17:03:56.449]                 ...future.workdir <- getwd()
[17:03:56.449]             }
[17:03:56.449]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.449]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.449]         }
[17:03:56.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.449]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.449]             base::names(...future.oldOptions))
[17:03:56.449]     }
[17:03:56.449]     if (FALSE) {
[17:03:56.449]     }
[17:03:56.449]     else {
[17:03:56.449]         if (TRUE) {
[17:03:56.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.449]                 open = "w")
[17:03:56.449]         }
[17:03:56.449]         else {
[17:03:56.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.449]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.449]         }
[17:03:56.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.449]             base::sink(type = "output", split = FALSE)
[17:03:56.449]             base::close(...future.stdout)
[17:03:56.449]         }, add = TRUE)
[17:03:56.449]     }
[17:03:56.449]     ...future.frame <- base::sys.nframe()
[17:03:56.449]     ...future.conditions <- base::list()
[17:03:56.449]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.449]     if (FALSE) {
[17:03:56.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.449]     }
[17:03:56.449]     ...future.result <- base::tryCatch({
[17:03:56.449]         base::withCallingHandlers({
[17:03:56.449]             ...future.value <- base::withVisible(base::local({
[17:03:56.449]                 ...future.makeSendCondition <- base::local({
[17:03:56.449]                   sendCondition <- NULL
[17:03:56.449]                   function(frame = 1L) {
[17:03:56.449]                     if (is.function(sendCondition)) 
[17:03:56.449]                       return(sendCondition)
[17:03:56.449]                     ns <- getNamespace("parallel")
[17:03:56.449]                     if (exists("sendData", mode = "function", 
[17:03:56.449]                       envir = ns)) {
[17:03:56.449]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.449]                         envir = ns)
[17:03:56.449]                       envir <- sys.frame(frame)
[17:03:56.449]                       master <- NULL
[17:03:56.449]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.449]                         !identical(envir, emptyenv())) {
[17:03:56.449]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.449]                           inherits = FALSE)) {
[17:03:56.449]                           master <- get("master", mode = "list", 
[17:03:56.449]                             envir = envir, inherits = FALSE)
[17:03:56.449]                           if (inherits(master, c("SOCKnode", 
[17:03:56.449]                             "SOCK0node"))) {
[17:03:56.449]                             sendCondition <<- function(cond) {
[17:03:56.449]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.449]                                 success = TRUE)
[17:03:56.449]                               parallel_sendData(master, data)
[17:03:56.449]                             }
[17:03:56.449]                             return(sendCondition)
[17:03:56.449]                           }
[17:03:56.449]                         }
[17:03:56.449]                         frame <- frame + 1L
[17:03:56.449]                         envir <- sys.frame(frame)
[17:03:56.449]                       }
[17:03:56.449]                     }
[17:03:56.449]                     sendCondition <<- function(cond) NULL
[17:03:56.449]                   }
[17:03:56.449]                 })
[17:03:56.449]                 withCallingHandlers({
[17:03:56.449]                   {
[17:03:56.449]                     1
[17:03:56.449]                   }
[17:03:56.449]                 }, immediateCondition = function(cond) {
[17:03:56.449]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.449]                   sendCondition(cond)
[17:03:56.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.449]                   {
[17:03:56.449]                     inherits <- base::inherits
[17:03:56.449]                     invokeRestart <- base::invokeRestart
[17:03:56.449]                     is.null <- base::is.null
[17:03:56.449]                     muffled <- FALSE
[17:03:56.449]                     if (inherits(cond, "message")) {
[17:03:56.449]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.449]                       if (muffled) 
[17:03:56.449]                         invokeRestart("muffleMessage")
[17:03:56.449]                     }
[17:03:56.449]                     else if (inherits(cond, "warning")) {
[17:03:56.449]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.449]                       if (muffled) 
[17:03:56.449]                         invokeRestart("muffleWarning")
[17:03:56.449]                     }
[17:03:56.449]                     else if (inherits(cond, "condition")) {
[17:03:56.449]                       if (!is.null(pattern)) {
[17:03:56.449]                         computeRestarts <- base::computeRestarts
[17:03:56.449]                         grepl <- base::grepl
[17:03:56.449]                         restarts <- computeRestarts(cond)
[17:03:56.449]                         for (restart in restarts) {
[17:03:56.449]                           name <- restart$name
[17:03:56.449]                           if (is.null(name)) 
[17:03:56.449]                             next
[17:03:56.449]                           if (!grepl(pattern, name)) 
[17:03:56.449]                             next
[17:03:56.449]                           invokeRestart(restart)
[17:03:56.449]                           muffled <- TRUE
[17:03:56.449]                           break
[17:03:56.449]                         }
[17:03:56.449]                       }
[17:03:56.449]                     }
[17:03:56.449]                     invisible(muffled)
[17:03:56.449]                   }
[17:03:56.449]                   muffleCondition(cond)
[17:03:56.449]                 })
[17:03:56.449]             }))
[17:03:56.449]             future::FutureResult(value = ...future.value$value, 
[17:03:56.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.449]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.449]                     ...future.globalenv.names))
[17:03:56.449]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.449]         }, condition = base::local({
[17:03:56.449]             c <- base::c
[17:03:56.449]             inherits <- base::inherits
[17:03:56.449]             invokeRestart <- base::invokeRestart
[17:03:56.449]             length <- base::length
[17:03:56.449]             list <- base::list
[17:03:56.449]             seq.int <- base::seq.int
[17:03:56.449]             signalCondition <- base::signalCondition
[17:03:56.449]             sys.calls <- base::sys.calls
[17:03:56.449]             `[[` <- base::`[[`
[17:03:56.449]             `+` <- base::`+`
[17:03:56.449]             `<<-` <- base::`<<-`
[17:03:56.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.449]                   3L)]
[17:03:56.449]             }
[17:03:56.449]             function(cond) {
[17:03:56.449]                 is_error <- inherits(cond, "error")
[17:03:56.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.449]                   NULL)
[17:03:56.449]                 if (is_error) {
[17:03:56.449]                   sessionInformation <- function() {
[17:03:56.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.449]                       search = base::search(), system = base::Sys.info())
[17:03:56.449]                   }
[17:03:56.449]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.449]                     cond$call), session = sessionInformation(), 
[17:03:56.449]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.449]                   signalCondition(cond)
[17:03:56.449]                 }
[17:03:56.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.449]                 "immediateCondition"))) {
[17:03:56.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.449]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.449]                   if (TRUE && !signal) {
[17:03:56.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.449]                     {
[17:03:56.449]                       inherits <- base::inherits
[17:03:56.449]                       invokeRestart <- base::invokeRestart
[17:03:56.449]                       is.null <- base::is.null
[17:03:56.449]                       muffled <- FALSE
[17:03:56.449]                       if (inherits(cond, "message")) {
[17:03:56.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.449]                         if (muffled) 
[17:03:56.449]                           invokeRestart("muffleMessage")
[17:03:56.449]                       }
[17:03:56.449]                       else if (inherits(cond, "warning")) {
[17:03:56.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.449]                         if (muffled) 
[17:03:56.449]                           invokeRestart("muffleWarning")
[17:03:56.449]                       }
[17:03:56.449]                       else if (inherits(cond, "condition")) {
[17:03:56.449]                         if (!is.null(pattern)) {
[17:03:56.449]                           computeRestarts <- base::computeRestarts
[17:03:56.449]                           grepl <- base::grepl
[17:03:56.449]                           restarts <- computeRestarts(cond)
[17:03:56.449]                           for (restart in restarts) {
[17:03:56.449]                             name <- restart$name
[17:03:56.449]                             if (is.null(name)) 
[17:03:56.449]                               next
[17:03:56.449]                             if (!grepl(pattern, name)) 
[17:03:56.449]                               next
[17:03:56.449]                             invokeRestart(restart)
[17:03:56.449]                             muffled <- TRUE
[17:03:56.449]                             break
[17:03:56.449]                           }
[17:03:56.449]                         }
[17:03:56.449]                       }
[17:03:56.449]                       invisible(muffled)
[17:03:56.449]                     }
[17:03:56.449]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.449]                   }
[17:03:56.449]                 }
[17:03:56.449]                 else {
[17:03:56.449]                   if (TRUE) {
[17:03:56.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.449]                     {
[17:03:56.449]                       inherits <- base::inherits
[17:03:56.449]                       invokeRestart <- base::invokeRestart
[17:03:56.449]                       is.null <- base::is.null
[17:03:56.449]                       muffled <- FALSE
[17:03:56.449]                       if (inherits(cond, "message")) {
[17:03:56.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.449]                         if (muffled) 
[17:03:56.449]                           invokeRestart("muffleMessage")
[17:03:56.449]                       }
[17:03:56.449]                       else if (inherits(cond, "warning")) {
[17:03:56.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.449]                         if (muffled) 
[17:03:56.449]                           invokeRestart("muffleWarning")
[17:03:56.449]                       }
[17:03:56.449]                       else if (inherits(cond, "condition")) {
[17:03:56.449]                         if (!is.null(pattern)) {
[17:03:56.449]                           computeRestarts <- base::computeRestarts
[17:03:56.449]                           grepl <- base::grepl
[17:03:56.449]                           restarts <- computeRestarts(cond)
[17:03:56.449]                           for (restart in restarts) {
[17:03:56.449]                             name <- restart$name
[17:03:56.449]                             if (is.null(name)) 
[17:03:56.449]                               next
[17:03:56.449]                             if (!grepl(pattern, name)) 
[17:03:56.449]                               next
[17:03:56.449]                             invokeRestart(restart)
[17:03:56.449]                             muffled <- TRUE
[17:03:56.449]                             break
[17:03:56.449]                           }
[17:03:56.449]                         }
[17:03:56.449]                       }
[17:03:56.449]                       invisible(muffled)
[17:03:56.449]                     }
[17:03:56.449]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.449]                   }
[17:03:56.449]                 }
[17:03:56.449]             }
[17:03:56.449]         }))
[17:03:56.449]     }, error = function(ex) {
[17:03:56.449]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.449]                 ...future.rng), started = ...future.startTime, 
[17:03:56.449]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.449]             version = "1.8"), class = "FutureResult")
[17:03:56.449]     }, finally = {
[17:03:56.449]         if (!identical(...future.workdir, getwd())) 
[17:03:56.449]             setwd(...future.workdir)
[17:03:56.449]         {
[17:03:56.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.449]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.449]             }
[17:03:56.449]             base::options(...future.oldOptions)
[17:03:56.449]             if (.Platform$OS.type == "windows") {
[17:03:56.449]                 old_names <- names(...future.oldEnvVars)
[17:03:56.449]                 envs <- base::Sys.getenv()
[17:03:56.449]                 names <- names(envs)
[17:03:56.449]                 common <- intersect(names, old_names)
[17:03:56.449]                 added <- setdiff(names, old_names)
[17:03:56.449]                 removed <- setdiff(old_names, names)
[17:03:56.449]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.449]                   envs[common]]
[17:03:56.449]                 NAMES <- toupper(changed)
[17:03:56.449]                 args <- list()
[17:03:56.449]                 for (kk in seq_along(NAMES)) {
[17:03:56.449]                   name <- changed[[kk]]
[17:03:56.449]                   NAME <- NAMES[[kk]]
[17:03:56.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.449]                     next
[17:03:56.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.449]                 }
[17:03:56.449]                 NAMES <- toupper(added)
[17:03:56.449]                 for (kk in seq_along(NAMES)) {
[17:03:56.449]                   name <- added[[kk]]
[17:03:56.449]                   NAME <- NAMES[[kk]]
[17:03:56.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.449]                     next
[17:03:56.449]                   args[[name]] <- ""
[17:03:56.449]                 }
[17:03:56.449]                 NAMES <- toupper(removed)
[17:03:56.449]                 for (kk in seq_along(NAMES)) {
[17:03:56.449]                   name <- removed[[kk]]
[17:03:56.449]                   NAME <- NAMES[[kk]]
[17:03:56.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.449]                     next
[17:03:56.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.449]                 }
[17:03:56.449]                 if (length(args) > 0) 
[17:03:56.449]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.449]             }
[17:03:56.449]             else {
[17:03:56.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.449]             }
[17:03:56.449]             {
[17:03:56.449]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.449]                   0L) {
[17:03:56.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.449]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.449]                   base::options(opts)
[17:03:56.449]                 }
[17:03:56.449]                 {
[17:03:56.449]                   {
[17:03:56.449]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.449]                     NULL
[17:03:56.449]                   }
[17:03:56.449]                   options(future.plan = NULL)
[17:03:56.449]                   if (is.na(NA_character_)) 
[17:03:56.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.449]                     .init = FALSE)
[17:03:56.449]                 }
[17:03:56.449]             }
[17:03:56.449]         }
[17:03:56.449]     })
[17:03:56.449]     if (TRUE) {
[17:03:56.449]         base::sink(type = "output", split = FALSE)
[17:03:56.449]         if (TRUE) {
[17:03:56.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.449]         }
[17:03:56.449]         else {
[17:03:56.449]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.449]         }
[17:03:56.449]         base::close(...future.stdout)
[17:03:56.449]         ...future.stdout <- NULL
[17:03:56.449]     }
[17:03:56.449]     ...future.result$conditions <- ...future.conditions
[17:03:56.449]     ...future.result$finished <- base::Sys.time()
[17:03:56.449]     ...future.result
[17:03:56.449] }
[17:03:56.453] MultisessionFuture started
[17:03:56.453] - Launch lazy future ... done
[17:03:56.453] run() for ‘MultisessionFuture’ ... done
[17:03:56.454] getGlobalsAndPackages() ...
[17:03:56.454] Searching for globals...
[17:03:56.455] - globals found: [1] ‘{’
[17:03:56.455] Searching for globals ... DONE
[17:03:56.455] Resolving globals: FALSE
[17:03:56.456] 
[17:03:56.456] 
[17:03:56.456] getGlobalsAndPackages() ... DONE
[17:03:56.456] run() for ‘Future’ ...
[17:03:56.456] - state: ‘created’
[17:03:56.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.471] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.471]   - Field: ‘node’
[17:03:56.471]   - Field: ‘label’
[17:03:56.472]   - Field: ‘local’
[17:03:56.472]   - Field: ‘owner’
[17:03:56.472]   - Field: ‘envir’
[17:03:56.472]   - Field: ‘workers’
[17:03:56.472]   - Field: ‘packages’
[17:03:56.472]   - Field: ‘gc’
[17:03:56.472]   - Field: ‘conditions’
[17:03:56.472]   - Field: ‘persistent’
[17:03:56.472]   - Field: ‘expr’
[17:03:56.472]   - Field: ‘uuid’
[17:03:56.472]   - Field: ‘seed’
[17:03:56.473]   - Field: ‘version’
[17:03:56.473]   - Field: ‘result’
[17:03:56.473]   - Field: ‘asynchronous’
[17:03:56.473]   - Field: ‘calls’
[17:03:56.473]   - Field: ‘globals’
[17:03:56.473]   - Field: ‘stdout’
[17:03:56.473]   - Field: ‘earlySignal’
[17:03:56.473]   - Field: ‘lazy’
[17:03:56.473]   - Field: ‘state’
[17:03:56.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.473] - Launch lazy future ...
[17:03:56.474] Packages needed by the future expression (n = 0): <none>
[17:03:56.474] Packages needed by future strategies (n = 0): <none>
[17:03:56.474] {
[17:03:56.474]     {
[17:03:56.474]         {
[17:03:56.474]             ...future.startTime <- base::Sys.time()
[17:03:56.474]             {
[17:03:56.474]                 {
[17:03:56.474]                   {
[17:03:56.474]                     {
[17:03:56.474]                       base::local({
[17:03:56.474]                         has_future <- base::requireNamespace("future", 
[17:03:56.474]                           quietly = TRUE)
[17:03:56.474]                         if (has_future) {
[17:03:56.474]                           ns <- base::getNamespace("future")
[17:03:56.474]                           version <- ns[[".package"]][["version"]]
[17:03:56.474]                           if (is.null(version)) 
[17:03:56.474]                             version <- utils::packageVersion("future")
[17:03:56.474]                         }
[17:03:56.474]                         else {
[17:03:56.474]                           version <- NULL
[17:03:56.474]                         }
[17:03:56.474]                         if (!has_future || version < "1.8.0") {
[17:03:56.474]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.474]                             "", base::R.version$version.string), 
[17:03:56.474]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.474]                               "release", "version")], collapse = " "), 
[17:03:56.474]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.474]                             info)
[17:03:56.474]                           info <- base::paste(info, collapse = "; ")
[17:03:56.474]                           if (!has_future) {
[17:03:56.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.474]                               info)
[17:03:56.474]                           }
[17:03:56.474]                           else {
[17:03:56.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.474]                               info, version)
[17:03:56.474]                           }
[17:03:56.474]                           base::stop(msg)
[17:03:56.474]                         }
[17:03:56.474]                       })
[17:03:56.474]                     }
[17:03:56.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.474]                     base::options(mc.cores = 1L)
[17:03:56.474]                   }
[17:03:56.474]                   ...future.strategy.old <- future::plan("list")
[17:03:56.474]                   options(future.plan = NULL)
[17:03:56.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.474]                 }
[17:03:56.474]                 ...future.workdir <- getwd()
[17:03:56.474]             }
[17:03:56.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.474]         }
[17:03:56.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.474]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.474]             base::names(...future.oldOptions))
[17:03:56.474]     }
[17:03:56.474]     if (FALSE) {
[17:03:56.474]     }
[17:03:56.474]     else {
[17:03:56.474]         if (TRUE) {
[17:03:56.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.474]                 open = "w")
[17:03:56.474]         }
[17:03:56.474]         else {
[17:03:56.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.474]         }
[17:03:56.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.474]             base::sink(type = "output", split = FALSE)
[17:03:56.474]             base::close(...future.stdout)
[17:03:56.474]         }, add = TRUE)
[17:03:56.474]     }
[17:03:56.474]     ...future.frame <- base::sys.nframe()
[17:03:56.474]     ...future.conditions <- base::list()
[17:03:56.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.474]     if (FALSE) {
[17:03:56.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.474]     }
[17:03:56.474]     ...future.result <- base::tryCatch({
[17:03:56.474]         base::withCallingHandlers({
[17:03:56.474]             ...future.value <- base::withVisible(base::local({
[17:03:56.474]                 ...future.makeSendCondition <- base::local({
[17:03:56.474]                   sendCondition <- NULL
[17:03:56.474]                   function(frame = 1L) {
[17:03:56.474]                     if (is.function(sendCondition)) 
[17:03:56.474]                       return(sendCondition)
[17:03:56.474]                     ns <- getNamespace("parallel")
[17:03:56.474]                     if (exists("sendData", mode = "function", 
[17:03:56.474]                       envir = ns)) {
[17:03:56.474]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.474]                         envir = ns)
[17:03:56.474]                       envir <- sys.frame(frame)
[17:03:56.474]                       master <- NULL
[17:03:56.474]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.474]                         !identical(envir, emptyenv())) {
[17:03:56.474]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.474]                           inherits = FALSE)) {
[17:03:56.474]                           master <- get("master", mode = "list", 
[17:03:56.474]                             envir = envir, inherits = FALSE)
[17:03:56.474]                           if (inherits(master, c("SOCKnode", 
[17:03:56.474]                             "SOCK0node"))) {
[17:03:56.474]                             sendCondition <<- function(cond) {
[17:03:56.474]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.474]                                 success = TRUE)
[17:03:56.474]                               parallel_sendData(master, data)
[17:03:56.474]                             }
[17:03:56.474]                             return(sendCondition)
[17:03:56.474]                           }
[17:03:56.474]                         }
[17:03:56.474]                         frame <- frame + 1L
[17:03:56.474]                         envir <- sys.frame(frame)
[17:03:56.474]                       }
[17:03:56.474]                     }
[17:03:56.474]                     sendCondition <<- function(cond) NULL
[17:03:56.474]                   }
[17:03:56.474]                 })
[17:03:56.474]                 withCallingHandlers({
[17:03:56.474]                   {
[17:03:56.474]                     2
[17:03:56.474]                   }
[17:03:56.474]                 }, immediateCondition = function(cond) {
[17:03:56.474]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.474]                   sendCondition(cond)
[17:03:56.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.474]                   {
[17:03:56.474]                     inherits <- base::inherits
[17:03:56.474]                     invokeRestart <- base::invokeRestart
[17:03:56.474]                     is.null <- base::is.null
[17:03:56.474]                     muffled <- FALSE
[17:03:56.474]                     if (inherits(cond, "message")) {
[17:03:56.474]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.474]                       if (muffled) 
[17:03:56.474]                         invokeRestart("muffleMessage")
[17:03:56.474]                     }
[17:03:56.474]                     else if (inherits(cond, "warning")) {
[17:03:56.474]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.474]                       if (muffled) 
[17:03:56.474]                         invokeRestart("muffleWarning")
[17:03:56.474]                     }
[17:03:56.474]                     else if (inherits(cond, "condition")) {
[17:03:56.474]                       if (!is.null(pattern)) {
[17:03:56.474]                         computeRestarts <- base::computeRestarts
[17:03:56.474]                         grepl <- base::grepl
[17:03:56.474]                         restarts <- computeRestarts(cond)
[17:03:56.474]                         for (restart in restarts) {
[17:03:56.474]                           name <- restart$name
[17:03:56.474]                           if (is.null(name)) 
[17:03:56.474]                             next
[17:03:56.474]                           if (!grepl(pattern, name)) 
[17:03:56.474]                             next
[17:03:56.474]                           invokeRestart(restart)
[17:03:56.474]                           muffled <- TRUE
[17:03:56.474]                           break
[17:03:56.474]                         }
[17:03:56.474]                       }
[17:03:56.474]                     }
[17:03:56.474]                     invisible(muffled)
[17:03:56.474]                   }
[17:03:56.474]                   muffleCondition(cond)
[17:03:56.474]                 })
[17:03:56.474]             }))
[17:03:56.474]             future::FutureResult(value = ...future.value$value, 
[17:03:56.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.474]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.474]                     ...future.globalenv.names))
[17:03:56.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.474]         }, condition = base::local({
[17:03:56.474]             c <- base::c
[17:03:56.474]             inherits <- base::inherits
[17:03:56.474]             invokeRestart <- base::invokeRestart
[17:03:56.474]             length <- base::length
[17:03:56.474]             list <- base::list
[17:03:56.474]             seq.int <- base::seq.int
[17:03:56.474]             signalCondition <- base::signalCondition
[17:03:56.474]             sys.calls <- base::sys.calls
[17:03:56.474]             `[[` <- base::`[[`
[17:03:56.474]             `+` <- base::`+`
[17:03:56.474]             `<<-` <- base::`<<-`
[17:03:56.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.474]                   3L)]
[17:03:56.474]             }
[17:03:56.474]             function(cond) {
[17:03:56.474]                 is_error <- inherits(cond, "error")
[17:03:56.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.474]                   NULL)
[17:03:56.474]                 if (is_error) {
[17:03:56.474]                   sessionInformation <- function() {
[17:03:56.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.474]                       search = base::search(), system = base::Sys.info())
[17:03:56.474]                   }
[17:03:56.474]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.474]                     cond$call), session = sessionInformation(), 
[17:03:56.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.474]                   signalCondition(cond)
[17:03:56.474]                 }
[17:03:56.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.474]                 "immediateCondition"))) {
[17:03:56.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.474]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.474]                   if (TRUE && !signal) {
[17:03:56.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.474]                     {
[17:03:56.474]                       inherits <- base::inherits
[17:03:56.474]                       invokeRestart <- base::invokeRestart
[17:03:56.474]                       is.null <- base::is.null
[17:03:56.474]                       muffled <- FALSE
[17:03:56.474]                       if (inherits(cond, "message")) {
[17:03:56.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.474]                         if (muffled) 
[17:03:56.474]                           invokeRestart("muffleMessage")
[17:03:56.474]                       }
[17:03:56.474]                       else if (inherits(cond, "warning")) {
[17:03:56.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.474]                         if (muffled) 
[17:03:56.474]                           invokeRestart("muffleWarning")
[17:03:56.474]                       }
[17:03:56.474]                       else if (inherits(cond, "condition")) {
[17:03:56.474]                         if (!is.null(pattern)) {
[17:03:56.474]                           computeRestarts <- base::computeRestarts
[17:03:56.474]                           grepl <- base::grepl
[17:03:56.474]                           restarts <- computeRestarts(cond)
[17:03:56.474]                           for (restart in restarts) {
[17:03:56.474]                             name <- restart$name
[17:03:56.474]                             if (is.null(name)) 
[17:03:56.474]                               next
[17:03:56.474]                             if (!grepl(pattern, name)) 
[17:03:56.474]                               next
[17:03:56.474]                             invokeRestart(restart)
[17:03:56.474]                             muffled <- TRUE
[17:03:56.474]                             break
[17:03:56.474]                           }
[17:03:56.474]                         }
[17:03:56.474]                       }
[17:03:56.474]                       invisible(muffled)
[17:03:56.474]                     }
[17:03:56.474]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.474]                   }
[17:03:56.474]                 }
[17:03:56.474]                 else {
[17:03:56.474]                   if (TRUE) {
[17:03:56.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.474]                     {
[17:03:56.474]                       inherits <- base::inherits
[17:03:56.474]                       invokeRestart <- base::invokeRestart
[17:03:56.474]                       is.null <- base::is.null
[17:03:56.474]                       muffled <- FALSE
[17:03:56.474]                       if (inherits(cond, "message")) {
[17:03:56.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.474]                         if (muffled) 
[17:03:56.474]                           invokeRestart("muffleMessage")
[17:03:56.474]                       }
[17:03:56.474]                       else if (inherits(cond, "warning")) {
[17:03:56.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.474]                         if (muffled) 
[17:03:56.474]                           invokeRestart("muffleWarning")
[17:03:56.474]                       }
[17:03:56.474]                       else if (inherits(cond, "condition")) {
[17:03:56.474]                         if (!is.null(pattern)) {
[17:03:56.474]                           computeRestarts <- base::computeRestarts
[17:03:56.474]                           grepl <- base::grepl
[17:03:56.474]                           restarts <- computeRestarts(cond)
[17:03:56.474]                           for (restart in restarts) {
[17:03:56.474]                             name <- restart$name
[17:03:56.474]                             if (is.null(name)) 
[17:03:56.474]                               next
[17:03:56.474]                             if (!grepl(pattern, name)) 
[17:03:56.474]                               next
[17:03:56.474]                             invokeRestart(restart)
[17:03:56.474]                             muffled <- TRUE
[17:03:56.474]                             break
[17:03:56.474]                           }
[17:03:56.474]                         }
[17:03:56.474]                       }
[17:03:56.474]                       invisible(muffled)
[17:03:56.474]                     }
[17:03:56.474]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.474]                   }
[17:03:56.474]                 }
[17:03:56.474]             }
[17:03:56.474]         }))
[17:03:56.474]     }, error = function(ex) {
[17:03:56.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.474]                 ...future.rng), started = ...future.startTime, 
[17:03:56.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.474]             version = "1.8"), class = "FutureResult")
[17:03:56.474]     }, finally = {
[17:03:56.474]         if (!identical(...future.workdir, getwd())) 
[17:03:56.474]             setwd(...future.workdir)
[17:03:56.474]         {
[17:03:56.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.474]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.474]             }
[17:03:56.474]             base::options(...future.oldOptions)
[17:03:56.474]             if (.Platform$OS.type == "windows") {
[17:03:56.474]                 old_names <- names(...future.oldEnvVars)
[17:03:56.474]                 envs <- base::Sys.getenv()
[17:03:56.474]                 names <- names(envs)
[17:03:56.474]                 common <- intersect(names, old_names)
[17:03:56.474]                 added <- setdiff(names, old_names)
[17:03:56.474]                 removed <- setdiff(old_names, names)
[17:03:56.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.474]                   envs[common]]
[17:03:56.474]                 NAMES <- toupper(changed)
[17:03:56.474]                 args <- list()
[17:03:56.474]                 for (kk in seq_along(NAMES)) {
[17:03:56.474]                   name <- changed[[kk]]
[17:03:56.474]                   NAME <- NAMES[[kk]]
[17:03:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.474]                     next
[17:03:56.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.474]                 }
[17:03:56.474]                 NAMES <- toupper(added)
[17:03:56.474]                 for (kk in seq_along(NAMES)) {
[17:03:56.474]                   name <- added[[kk]]
[17:03:56.474]                   NAME <- NAMES[[kk]]
[17:03:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.474]                     next
[17:03:56.474]                   args[[name]] <- ""
[17:03:56.474]                 }
[17:03:56.474]                 NAMES <- toupper(removed)
[17:03:56.474]                 for (kk in seq_along(NAMES)) {
[17:03:56.474]                   name <- removed[[kk]]
[17:03:56.474]                   NAME <- NAMES[[kk]]
[17:03:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.474]                     next
[17:03:56.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.474]                 }
[17:03:56.474]                 if (length(args) > 0) 
[17:03:56.474]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.474]             }
[17:03:56.474]             else {
[17:03:56.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.474]             }
[17:03:56.474]             {
[17:03:56.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.474]                   0L) {
[17:03:56.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.474]                   base::options(opts)
[17:03:56.474]                 }
[17:03:56.474]                 {
[17:03:56.474]                   {
[17:03:56.474]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.474]                     NULL
[17:03:56.474]                   }
[17:03:56.474]                   options(future.plan = NULL)
[17:03:56.474]                   if (is.na(NA_character_)) 
[17:03:56.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.474]                     .init = FALSE)
[17:03:56.474]                 }
[17:03:56.474]             }
[17:03:56.474]         }
[17:03:56.474]     })
[17:03:56.474]     if (TRUE) {
[17:03:56.474]         base::sink(type = "output", split = FALSE)
[17:03:56.474]         if (TRUE) {
[17:03:56.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.474]         }
[17:03:56.474]         else {
[17:03:56.474]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.474]         }
[17:03:56.474]         base::close(...future.stdout)
[17:03:56.474]         ...future.stdout <- NULL
[17:03:56.474]     }
[17:03:56.474]     ...future.result$conditions <- ...future.conditions
[17:03:56.474]     ...future.result$finished <- base::Sys.time()
[17:03:56.474]     ...future.result
[17:03:56.474] }
[17:03:56.477] MultisessionFuture started
[17:03:56.478] - Launch lazy future ... done
[17:03:56.480] run() for ‘MultisessionFuture’ ... done
[17:03:56.481] resolve() on environment ...
[17:03:56.481]  recursive: 0
[17:03:56.482]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:03:56.482] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.482] - Validating connection of MultisessionFuture
[17:03:56.483] - received message: FutureResult
[17:03:56.483] - Received FutureResult
[17:03:56.483] - Erased future from FutureRegistry
[17:03:56.483] result() for ClusterFuture ...
[17:03:56.483] - result already collected: FutureResult
[17:03:56.483] result() for ClusterFuture ... done
[17:03:56.483] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.483] Future #1
[17:03:56.483]  length: 2 (resolved future 1)
[17:03:56.484] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.484] - Validating connection of MultisessionFuture
[17:03:56.484] - received message: FutureResult
[17:03:56.484] - Received FutureResult
[17:03:56.484] - Erased future from FutureRegistry
[17:03:56.484] result() for ClusterFuture ...
[17:03:56.484] - result already collected: FutureResult
[17:03:56.485] result() for ClusterFuture ... done
[17:03:56.485] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.485] Future #2
[17:03:56.485]  length: 1 (resolved future 2)
[17:03:56.485]  length: 0 (resolved future 3)
[17:03:56.485] resolve() on environment ... DONE
[17:03:56.485] getGlobalsAndPackages() ...
[17:03:56.485] Searching for globals...
[17:03:56.486] - globals found: [1] ‘{’
[17:03:56.486] Searching for globals ... DONE
[17:03:56.486] Resolving globals: FALSE
[17:03:56.487] 
[17:03:56.487] 
[17:03:56.487] getGlobalsAndPackages() ... DONE
[17:03:56.487] run() for ‘Future’ ...
[17:03:56.487] - state: ‘created’
[17:03:56.487] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.501] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.501]   - Field: ‘node’
[17:03:56.501]   - Field: ‘label’
[17:03:56.501]   - Field: ‘local’
[17:03:56.501]   - Field: ‘owner’
[17:03:56.501]   - Field: ‘envir’
[17:03:56.502]   - Field: ‘workers’
[17:03:56.502]   - Field: ‘packages’
[17:03:56.502]   - Field: ‘gc’
[17:03:56.502]   - Field: ‘conditions’
[17:03:56.502]   - Field: ‘persistent’
[17:03:56.502]   - Field: ‘expr’
[17:03:56.502]   - Field: ‘uuid’
[17:03:56.502]   - Field: ‘seed’
[17:03:56.502]   - Field: ‘version’
[17:03:56.502]   - Field: ‘result’
[17:03:56.502]   - Field: ‘asynchronous’
[17:03:56.503]   - Field: ‘calls’
[17:03:56.503]   - Field: ‘globals’
[17:03:56.503]   - Field: ‘stdout’
[17:03:56.503]   - Field: ‘earlySignal’
[17:03:56.503]   - Field: ‘lazy’
[17:03:56.503]   - Field: ‘state’
[17:03:56.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.503] - Launch lazy future ...
[17:03:56.503] Packages needed by the future expression (n = 0): <none>
[17:03:56.504] Packages needed by future strategies (n = 0): <none>
[17:03:56.504] {
[17:03:56.504]     {
[17:03:56.504]         {
[17:03:56.504]             ...future.startTime <- base::Sys.time()
[17:03:56.504]             {
[17:03:56.504]                 {
[17:03:56.504]                   {
[17:03:56.504]                     {
[17:03:56.504]                       base::local({
[17:03:56.504]                         has_future <- base::requireNamespace("future", 
[17:03:56.504]                           quietly = TRUE)
[17:03:56.504]                         if (has_future) {
[17:03:56.504]                           ns <- base::getNamespace("future")
[17:03:56.504]                           version <- ns[[".package"]][["version"]]
[17:03:56.504]                           if (is.null(version)) 
[17:03:56.504]                             version <- utils::packageVersion("future")
[17:03:56.504]                         }
[17:03:56.504]                         else {
[17:03:56.504]                           version <- NULL
[17:03:56.504]                         }
[17:03:56.504]                         if (!has_future || version < "1.8.0") {
[17:03:56.504]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.504]                             "", base::R.version$version.string), 
[17:03:56.504]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.504]                               "release", "version")], collapse = " "), 
[17:03:56.504]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.504]                             info)
[17:03:56.504]                           info <- base::paste(info, collapse = "; ")
[17:03:56.504]                           if (!has_future) {
[17:03:56.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.504]                               info)
[17:03:56.504]                           }
[17:03:56.504]                           else {
[17:03:56.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.504]                               info, version)
[17:03:56.504]                           }
[17:03:56.504]                           base::stop(msg)
[17:03:56.504]                         }
[17:03:56.504]                       })
[17:03:56.504]                     }
[17:03:56.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.504]                     base::options(mc.cores = 1L)
[17:03:56.504]                   }
[17:03:56.504]                   ...future.strategy.old <- future::plan("list")
[17:03:56.504]                   options(future.plan = NULL)
[17:03:56.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.504]                 }
[17:03:56.504]                 ...future.workdir <- getwd()
[17:03:56.504]             }
[17:03:56.504]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.504]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.504]         }
[17:03:56.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.504]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.504]             base::names(...future.oldOptions))
[17:03:56.504]     }
[17:03:56.504]     if (FALSE) {
[17:03:56.504]     }
[17:03:56.504]     else {
[17:03:56.504]         if (TRUE) {
[17:03:56.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.504]                 open = "w")
[17:03:56.504]         }
[17:03:56.504]         else {
[17:03:56.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.504]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.504]         }
[17:03:56.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.504]             base::sink(type = "output", split = FALSE)
[17:03:56.504]             base::close(...future.stdout)
[17:03:56.504]         }, add = TRUE)
[17:03:56.504]     }
[17:03:56.504]     ...future.frame <- base::sys.nframe()
[17:03:56.504]     ...future.conditions <- base::list()
[17:03:56.504]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.504]     if (FALSE) {
[17:03:56.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.504]     }
[17:03:56.504]     ...future.result <- base::tryCatch({
[17:03:56.504]         base::withCallingHandlers({
[17:03:56.504]             ...future.value <- base::withVisible(base::local({
[17:03:56.504]                 ...future.makeSendCondition <- base::local({
[17:03:56.504]                   sendCondition <- NULL
[17:03:56.504]                   function(frame = 1L) {
[17:03:56.504]                     if (is.function(sendCondition)) 
[17:03:56.504]                       return(sendCondition)
[17:03:56.504]                     ns <- getNamespace("parallel")
[17:03:56.504]                     if (exists("sendData", mode = "function", 
[17:03:56.504]                       envir = ns)) {
[17:03:56.504]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.504]                         envir = ns)
[17:03:56.504]                       envir <- sys.frame(frame)
[17:03:56.504]                       master <- NULL
[17:03:56.504]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.504]                         !identical(envir, emptyenv())) {
[17:03:56.504]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.504]                           inherits = FALSE)) {
[17:03:56.504]                           master <- get("master", mode = "list", 
[17:03:56.504]                             envir = envir, inherits = FALSE)
[17:03:56.504]                           if (inherits(master, c("SOCKnode", 
[17:03:56.504]                             "SOCK0node"))) {
[17:03:56.504]                             sendCondition <<- function(cond) {
[17:03:56.504]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.504]                                 success = TRUE)
[17:03:56.504]                               parallel_sendData(master, data)
[17:03:56.504]                             }
[17:03:56.504]                             return(sendCondition)
[17:03:56.504]                           }
[17:03:56.504]                         }
[17:03:56.504]                         frame <- frame + 1L
[17:03:56.504]                         envir <- sys.frame(frame)
[17:03:56.504]                       }
[17:03:56.504]                     }
[17:03:56.504]                     sendCondition <<- function(cond) NULL
[17:03:56.504]                   }
[17:03:56.504]                 })
[17:03:56.504]                 withCallingHandlers({
[17:03:56.504]                   {
[17:03:56.504]                     1
[17:03:56.504]                   }
[17:03:56.504]                 }, immediateCondition = function(cond) {
[17:03:56.504]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.504]                   sendCondition(cond)
[17:03:56.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.504]                   {
[17:03:56.504]                     inherits <- base::inherits
[17:03:56.504]                     invokeRestart <- base::invokeRestart
[17:03:56.504]                     is.null <- base::is.null
[17:03:56.504]                     muffled <- FALSE
[17:03:56.504]                     if (inherits(cond, "message")) {
[17:03:56.504]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.504]                       if (muffled) 
[17:03:56.504]                         invokeRestart("muffleMessage")
[17:03:56.504]                     }
[17:03:56.504]                     else if (inherits(cond, "warning")) {
[17:03:56.504]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.504]                       if (muffled) 
[17:03:56.504]                         invokeRestart("muffleWarning")
[17:03:56.504]                     }
[17:03:56.504]                     else if (inherits(cond, "condition")) {
[17:03:56.504]                       if (!is.null(pattern)) {
[17:03:56.504]                         computeRestarts <- base::computeRestarts
[17:03:56.504]                         grepl <- base::grepl
[17:03:56.504]                         restarts <- computeRestarts(cond)
[17:03:56.504]                         for (restart in restarts) {
[17:03:56.504]                           name <- restart$name
[17:03:56.504]                           if (is.null(name)) 
[17:03:56.504]                             next
[17:03:56.504]                           if (!grepl(pattern, name)) 
[17:03:56.504]                             next
[17:03:56.504]                           invokeRestart(restart)
[17:03:56.504]                           muffled <- TRUE
[17:03:56.504]                           break
[17:03:56.504]                         }
[17:03:56.504]                       }
[17:03:56.504]                     }
[17:03:56.504]                     invisible(muffled)
[17:03:56.504]                   }
[17:03:56.504]                   muffleCondition(cond)
[17:03:56.504]                 })
[17:03:56.504]             }))
[17:03:56.504]             future::FutureResult(value = ...future.value$value, 
[17:03:56.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.504]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.504]                     ...future.globalenv.names))
[17:03:56.504]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.504]         }, condition = base::local({
[17:03:56.504]             c <- base::c
[17:03:56.504]             inherits <- base::inherits
[17:03:56.504]             invokeRestart <- base::invokeRestart
[17:03:56.504]             length <- base::length
[17:03:56.504]             list <- base::list
[17:03:56.504]             seq.int <- base::seq.int
[17:03:56.504]             signalCondition <- base::signalCondition
[17:03:56.504]             sys.calls <- base::sys.calls
[17:03:56.504]             `[[` <- base::`[[`
[17:03:56.504]             `+` <- base::`+`
[17:03:56.504]             `<<-` <- base::`<<-`
[17:03:56.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.504]                   3L)]
[17:03:56.504]             }
[17:03:56.504]             function(cond) {
[17:03:56.504]                 is_error <- inherits(cond, "error")
[17:03:56.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.504]                   NULL)
[17:03:56.504]                 if (is_error) {
[17:03:56.504]                   sessionInformation <- function() {
[17:03:56.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.504]                       search = base::search(), system = base::Sys.info())
[17:03:56.504]                   }
[17:03:56.504]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.504]                     cond$call), session = sessionInformation(), 
[17:03:56.504]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.504]                   signalCondition(cond)
[17:03:56.504]                 }
[17:03:56.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.504]                 "immediateCondition"))) {
[17:03:56.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.504]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.504]                   if (TRUE && !signal) {
[17:03:56.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.504]                     {
[17:03:56.504]                       inherits <- base::inherits
[17:03:56.504]                       invokeRestart <- base::invokeRestart
[17:03:56.504]                       is.null <- base::is.null
[17:03:56.504]                       muffled <- FALSE
[17:03:56.504]                       if (inherits(cond, "message")) {
[17:03:56.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.504]                         if (muffled) 
[17:03:56.504]                           invokeRestart("muffleMessage")
[17:03:56.504]                       }
[17:03:56.504]                       else if (inherits(cond, "warning")) {
[17:03:56.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.504]                         if (muffled) 
[17:03:56.504]                           invokeRestart("muffleWarning")
[17:03:56.504]                       }
[17:03:56.504]                       else if (inherits(cond, "condition")) {
[17:03:56.504]                         if (!is.null(pattern)) {
[17:03:56.504]                           computeRestarts <- base::computeRestarts
[17:03:56.504]                           grepl <- base::grepl
[17:03:56.504]                           restarts <- computeRestarts(cond)
[17:03:56.504]                           for (restart in restarts) {
[17:03:56.504]                             name <- restart$name
[17:03:56.504]                             if (is.null(name)) 
[17:03:56.504]                               next
[17:03:56.504]                             if (!grepl(pattern, name)) 
[17:03:56.504]                               next
[17:03:56.504]                             invokeRestart(restart)
[17:03:56.504]                             muffled <- TRUE
[17:03:56.504]                             break
[17:03:56.504]                           }
[17:03:56.504]                         }
[17:03:56.504]                       }
[17:03:56.504]                       invisible(muffled)
[17:03:56.504]                     }
[17:03:56.504]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.504]                   }
[17:03:56.504]                 }
[17:03:56.504]                 else {
[17:03:56.504]                   if (TRUE) {
[17:03:56.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.504]                     {
[17:03:56.504]                       inherits <- base::inherits
[17:03:56.504]                       invokeRestart <- base::invokeRestart
[17:03:56.504]                       is.null <- base::is.null
[17:03:56.504]                       muffled <- FALSE
[17:03:56.504]                       if (inherits(cond, "message")) {
[17:03:56.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.504]                         if (muffled) 
[17:03:56.504]                           invokeRestart("muffleMessage")
[17:03:56.504]                       }
[17:03:56.504]                       else if (inherits(cond, "warning")) {
[17:03:56.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.504]                         if (muffled) 
[17:03:56.504]                           invokeRestart("muffleWarning")
[17:03:56.504]                       }
[17:03:56.504]                       else if (inherits(cond, "condition")) {
[17:03:56.504]                         if (!is.null(pattern)) {
[17:03:56.504]                           computeRestarts <- base::computeRestarts
[17:03:56.504]                           grepl <- base::grepl
[17:03:56.504]                           restarts <- computeRestarts(cond)
[17:03:56.504]                           for (restart in restarts) {
[17:03:56.504]                             name <- restart$name
[17:03:56.504]                             if (is.null(name)) 
[17:03:56.504]                               next
[17:03:56.504]                             if (!grepl(pattern, name)) 
[17:03:56.504]                               next
[17:03:56.504]                             invokeRestart(restart)
[17:03:56.504]                             muffled <- TRUE
[17:03:56.504]                             break
[17:03:56.504]                           }
[17:03:56.504]                         }
[17:03:56.504]                       }
[17:03:56.504]                       invisible(muffled)
[17:03:56.504]                     }
[17:03:56.504]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.504]                   }
[17:03:56.504]                 }
[17:03:56.504]             }
[17:03:56.504]         }))
[17:03:56.504]     }, error = function(ex) {
[17:03:56.504]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.504]                 ...future.rng), started = ...future.startTime, 
[17:03:56.504]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.504]             version = "1.8"), class = "FutureResult")
[17:03:56.504]     }, finally = {
[17:03:56.504]         if (!identical(...future.workdir, getwd())) 
[17:03:56.504]             setwd(...future.workdir)
[17:03:56.504]         {
[17:03:56.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.504]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.504]             }
[17:03:56.504]             base::options(...future.oldOptions)
[17:03:56.504]             if (.Platform$OS.type == "windows") {
[17:03:56.504]                 old_names <- names(...future.oldEnvVars)
[17:03:56.504]                 envs <- base::Sys.getenv()
[17:03:56.504]                 names <- names(envs)
[17:03:56.504]                 common <- intersect(names, old_names)
[17:03:56.504]                 added <- setdiff(names, old_names)
[17:03:56.504]                 removed <- setdiff(old_names, names)
[17:03:56.504]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.504]                   envs[common]]
[17:03:56.504]                 NAMES <- toupper(changed)
[17:03:56.504]                 args <- list()
[17:03:56.504]                 for (kk in seq_along(NAMES)) {
[17:03:56.504]                   name <- changed[[kk]]
[17:03:56.504]                   NAME <- NAMES[[kk]]
[17:03:56.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.504]                     next
[17:03:56.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.504]                 }
[17:03:56.504]                 NAMES <- toupper(added)
[17:03:56.504]                 for (kk in seq_along(NAMES)) {
[17:03:56.504]                   name <- added[[kk]]
[17:03:56.504]                   NAME <- NAMES[[kk]]
[17:03:56.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.504]                     next
[17:03:56.504]                   args[[name]] <- ""
[17:03:56.504]                 }
[17:03:56.504]                 NAMES <- toupper(removed)
[17:03:56.504]                 for (kk in seq_along(NAMES)) {
[17:03:56.504]                   name <- removed[[kk]]
[17:03:56.504]                   NAME <- NAMES[[kk]]
[17:03:56.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.504]                     next
[17:03:56.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.504]                 }
[17:03:56.504]                 if (length(args) > 0) 
[17:03:56.504]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.504]             }
[17:03:56.504]             else {
[17:03:56.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.504]             }
[17:03:56.504]             {
[17:03:56.504]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.504]                   0L) {
[17:03:56.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.504]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.504]                   base::options(opts)
[17:03:56.504]                 }
[17:03:56.504]                 {
[17:03:56.504]                   {
[17:03:56.504]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.504]                     NULL
[17:03:56.504]                   }
[17:03:56.504]                   options(future.plan = NULL)
[17:03:56.504]                   if (is.na(NA_character_)) 
[17:03:56.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.504]                     .init = FALSE)
[17:03:56.504]                 }
[17:03:56.504]             }
[17:03:56.504]         }
[17:03:56.504]     })
[17:03:56.504]     if (TRUE) {
[17:03:56.504]         base::sink(type = "output", split = FALSE)
[17:03:56.504]         if (TRUE) {
[17:03:56.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.504]         }
[17:03:56.504]         else {
[17:03:56.504]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.504]         }
[17:03:56.504]         base::close(...future.stdout)
[17:03:56.504]         ...future.stdout <- NULL
[17:03:56.504]     }
[17:03:56.504]     ...future.result$conditions <- ...future.conditions
[17:03:56.504]     ...future.result$finished <- base::Sys.time()
[17:03:56.504]     ...future.result
[17:03:56.504] }
[17:03:56.507] MultisessionFuture started
[17:03:56.507] - Launch lazy future ... done
[17:03:56.507] run() for ‘MultisessionFuture’ ... done
[17:03:56.507] getGlobalsAndPackages() ...
[17:03:56.508] Searching for globals...
[17:03:56.508] - globals found: [1] ‘{’
[17:03:56.508] Searching for globals ... DONE
[17:03:56.508] Resolving globals: FALSE
[17:03:56.509] 
[17:03:56.509] 
[17:03:56.509] getGlobalsAndPackages() ... DONE
[17:03:56.509] run() for ‘Future’ ...
[17:03:56.509] - state: ‘created’
[17:03:56.509] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.523]   - Field: ‘node’
[17:03:56.523]   - Field: ‘label’
[17:03:56.524]   - Field: ‘local’
[17:03:56.524]   - Field: ‘owner’
[17:03:56.524]   - Field: ‘envir’
[17:03:56.524]   - Field: ‘workers’
[17:03:56.524]   - Field: ‘packages’
[17:03:56.524]   - Field: ‘gc’
[17:03:56.524]   - Field: ‘conditions’
[17:03:56.524]   - Field: ‘persistent’
[17:03:56.525]   - Field: ‘expr’
[17:03:56.525]   - Field: ‘uuid’
[17:03:56.525]   - Field: ‘seed’
[17:03:56.525]   - Field: ‘version’
[17:03:56.525]   - Field: ‘result’
[17:03:56.525]   - Field: ‘asynchronous’
[17:03:56.525]   - Field: ‘calls’
[17:03:56.525]   - Field: ‘globals’
[17:03:56.525]   - Field: ‘stdout’
[17:03:56.526]   - Field: ‘earlySignal’
[17:03:56.526]   - Field: ‘lazy’
[17:03:56.526]   - Field: ‘state’
[17:03:56.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.526] - Launch lazy future ...
[17:03:56.526] Packages needed by the future expression (n = 0): <none>
[17:03:56.526] Packages needed by future strategies (n = 0): <none>
[17:03:56.527] {
[17:03:56.527]     {
[17:03:56.527]         {
[17:03:56.527]             ...future.startTime <- base::Sys.time()
[17:03:56.527]             {
[17:03:56.527]                 {
[17:03:56.527]                   {
[17:03:56.527]                     {
[17:03:56.527]                       base::local({
[17:03:56.527]                         has_future <- base::requireNamespace("future", 
[17:03:56.527]                           quietly = TRUE)
[17:03:56.527]                         if (has_future) {
[17:03:56.527]                           ns <- base::getNamespace("future")
[17:03:56.527]                           version <- ns[[".package"]][["version"]]
[17:03:56.527]                           if (is.null(version)) 
[17:03:56.527]                             version <- utils::packageVersion("future")
[17:03:56.527]                         }
[17:03:56.527]                         else {
[17:03:56.527]                           version <- NULL
[17:03:56.527]                         }
[17:03:56.527]                         if (!has_future || version < "1.8.0") {
[17:03:56.527]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.527]                             "", base::R.version$version.string), 
[17:03:56.527]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.527]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.527]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.527]                               "release", "version")], collapse = " "), 
[17:03:56.527]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.527]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.527]                             info)
[17:03:56.527]                           info <- base::paste(info, collapse = "; ")
[17:03:56.527]                           if (!has_future) {
[17:03:56.527]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.527]                               info)
[17:03:56.527]                           }
[17:03:56.527]                           else {
[17:03:56.527]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.527]                               info, version)
[17:03:56.527]                           }
[17:03:56.527]                           base::stop(msg)
[17:03:56.527]                         }
[17:03:56.527]                       })
[17:03:56.527]                     }
[17:03:56.527]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.527]                     base::options(mc.cores = 1L)
[17:03:56.527]                   }
[17:03:56.527]                   ...future.strategy.old <- future::plan("list")
[17:03:56.527]                   options(future.plan = NULL)
[17:03:56.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.527]                 }
[17:03:56.527]                 ...future.workdir <- getwd()
[17:03:56.527]             }
[17:03:56.527]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.527]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.527]         }
[17:03:56.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.527]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.527]             base::names(...future.oldOptions))
[17:03:56.527]     }
[17:03:56.527]     if (FALSE) {
[17:03:56.527]     }
[17:03:56.527]     else {
[17:03:56.527]         if (TRUE) {
[17:03:56.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.527]                 open = "w")
[17:03:56.527]         }
[17:03:56.527]         else {
[17:03:56.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.527]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.527]         }
[17:03:56.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.527]             base::sink(type = "output", split = FALSE)
[17:03:56.527]             base::close(...future.stdout)
[17:03:56.527]         }, add = TRUE)
[17:03:56.527]     }
[17:03:56.527]     ...future.frame <- base::sys.nframe()
[17:03:56.527]     ...future.conditions <- base::list()
[17:03:56.527]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.527]     if (FALSE) {
[17:03:56.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.527]     }
[17:03:56.527]     ...future.result <- base::tryCatch({
[17:03:56.527]         base::withCallingHandlers({
[17:03:56.527]             ...future.value <- base::withVisible(base::local({
[17:03:56.527]                 ...future.makeSendCondition <- base::local({
[17:03:56.527]                   sendCondition <- NULL
[17:03:56.527]                   function(frame = 1L) {
[17:03:56.527]                     if (is.function(sendCondition)) 
[17:03:56.527]                       return(sendCondition)
[17:03:56.527]                     ns <- getNamespace("parallel")
[17:03:56.527]                     if (exists("sendData", mode = "function", 
[17:03:56.527]                       envir = ns)) {
[17:03:56.527]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.527]                         envir = ns)
[17:03:56.527]                       envir <- sys.frame(frame)
[17:03:56.527]                       master <- NULL
[17:03:56.527]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.527]                         !identical(envir, emptyenv())) {
[17:03:56.527]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.527]                           inherits = FALSE)) {
[17:03:56.527]                           master <- get("master", mode = "list", 
[17:03:56.527]                             envir = envir, inherits = FALSE)
[17:03:56.527]                           if (inherits(master, c("SOCKnode", 
[17:03:56.527]                             "SOCK0node"))) {
[17:03:56.527]                             sendCondition <<- function(cond) {
[17:03:56.527]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.527]                                 success = TRUE)
[17:03:56.527]                               parallel_sendData(master, data)
[17:03:56.527]                             }
[17:03:56.527]                             return(sendCondition)
[17:03:56.527]                           }
[17:03:56.527]                         }
[17:03:56.527]                         frame <- frame + 1L
[17:03:56.527]                         envir <- sys.frame(frame)
[17:03:56.527]                       }
[17:03:56.527]                     }
[17:03:56.527]                     sendCondition <<- function(cond) NULL
[17:03:56.527]                   }
[17:03:56.527]                 })
[17:03:56.527]                 withCallingHandlers({
[17:03:56.527]                   {
[17:03:56.527]                     2
[17:03:56.527]                   }
[17:03:56.527]                 }, immediateCondition = function(cond) {
[17:03:56.527]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.527]                   sendCondition(cond)
[17:03:56.527]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.527]                   {
[17:03:56.527]                     inherits <- base::inherits
[17:03:56.527]                     invokeRestart <- base::invokeRestart
[17:03:56.527]                     is.null <- base::is.null
[17:03:56.527]                     muffled <- FALSE
[17:03:56.527]                     if (inherits(cond, "message")) {
[17:03:56.527]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.527]                       if (muffled) 
[17:03:56.527]                         invokeRestart("muffleMessage")
[17:03:56.527]                     }
[17:03:56.527]                     else if (inherits(cond, "warning")) {
[17:03:56.527]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.527]                       if (muffled) 
[17:03:56.527]                         invokeRestart("muffleWarning")
[17:03:56.527]                     }
[17:03:56.527]                     else if (inherits(cond, "condition")) {
[17:03:56.527]                       if (!is.null(pattern)) {
[17:03:56.527]                         computeRestarts <- base::computeRestarts
[17:03:56.527]                         grepl <- base::grepl
[17:03:56.527]                         restarts <- computeRestarts(cond)
[17:03:56.527]                         for (restart in restarts) {
[17:03:56.527]                           name <- restart$name
[17:03:56.527]                           if (is.null(name)) 
[17:03:56.527]                             next
[17:03:56.527]                           if (!grepl(pattern, name)) 
[17:03:56.527]                             next
[17:03:56.527]                           invokeRestart(restart)
[17:03:56.527]                           muffled <- TRUE
[17:03:56.527]                           break
[17:03:56.527]                         }
[17:03:56.527]                       }
[17:03:56.527]                     }
[17:03:56.527]                     invisible(muffled)
[17:03:56.527]                   }
[17:03:56.527]                   muffleCondition(cond)
[17:03:56.527]                 })
[17:03:56.527]             }))
[17:03:56.527]             future::FutureResult(value = ...future.value$value, 
[17:03:56.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.527]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.527]                     ...future.globalenv.names))
[17:03:56.527]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.527]         }, condition = base::local({
[17:03:56.527]             c <- base::c
[17:03:56.527]             inherits <- base::inherits
[17:03:56.527]             invokeRestart <- base::invokeRestart
[17:03:56.527]             length <- base::length
[17:03:56.527]             list <- base::list
[17:03:56.527]             seq.int <- base::seq.int
[17:03:56.527]             signalCondition <- base::signalCondition
[17:03:56.527]             sys.calls <- base::sys.calls
[17:03:56.527]             `[[` <- base::`[[`
[17:03:56.527]             `+` <- base::`+`
[17:03:56.527]             `<<-` <- base::`<<-`
[17:03:56.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.527]                   3L)]
[17:03:56.527]             }
[17:03:56.527]             function(cond) {
[17:03:56.527]                 is_error <- inherits(cond, "error")
[17:03:56.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.527]                   NULL)
[17:03:56.527]                 if (is_error) {
[17:03:56.527]                   sessionInformation <- function() {
[17:03:56.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.527]                       search = base::search(), system = base::Sys.info())
[17:03:56.527]                   }
[17:03:56.527]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.527]                     cond$call), session = sessionInformation(), 
[17:03:56.527]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.527]                   signalCondition(cond)
[17:03:56.527]                 }
[17:03:56.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.527]                 "immediateCondition"))) {
[17:03:56.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.527]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.527]                   if (TRUE && !signal) {
[17:03:56.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.527]                     {
[17:03:56.527]                       inherits <- base::inherits
[17:03:56.527]                       invokeRestart <- base::invokeRestart
[17:03:56.527]                       is.null <- base::is.null
[17:03:56.527]                       muffled <- FALSE
[17:03:56.527]                       if (inherits(cond, "message")) {
[17:03:56.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.527]                         if (muffled) 
[17:03:56.527]                           invokeRestart("muffleMessage")
[17:03:56.527]                       }
[17:03:56.527]                       else if (inherits(cond, "warning")) {
[17:03:56.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.527]                         if (muffled) 
[17:03:56.527]                           invokeRestart("muffleWarning")
[17:03:56.527]                       }
[17:03:56.527]                       else if (inherits(cond, "condition")) {
[17:03:56.527]                         if (!is.null(pattern)) {
[17:03:56.527]                           computeRestarts <- base::computeRestarts
[17:03:56.527]                           grepl <- base::grepl
[17:03:56.527]                           restarts <- computeRestarts(cond)
[17:03:56.527]                           for (restart in restarts) {
[17:03:56.527]                             name <- restart$name
[17:03:56.527]                             if (is.null(name)) 
[17:03:56.527]                               next
[17:03:56.527]                             if (!grepl(pattern, name)) 
[17:03:56.527]                               next
[17:03:56.527]                             invokeRestart(restart)
[17:03:56.527]                             muffled <- TRUE
[17:03:56.527]                             break
[17:03:56.527]                           }
[17:03:56.527]                         }
[17:03:56.527]                       }
[17:03:56.527]                       invisible(muffled)
[17:03:56.527]                     }
[17:03:56.527]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.527]                   }
[17:03:56.527]                 }
[17:03:56.527]                 else {
[17:03:56.527]                   if (TRUE) {
[17:03:56.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.527]                     {
[17:03:56.527]                       inherits <- base::inherits
[17:03:56.527]                       invokeRestart <- base::invokeRestart
[17:03:56.527]                       is.null <- base::is.null
[17:03:56.527]                       muffled <- FALSE
[17:03:56.527]                       if (inherits(cond, "message")) {
[17:03:56.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.527]                         if (muffled) 
[17:03:56.527]                           invokeRestart("muffleMessage")
[17:03:56.527]                       }
[17:03:56.527]                       else if (inherits(cond, "warning")) {
[17:03:56.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.527]                         if (muffled) 
[17:03:56.527]                           invokeRestart("muffleWarning")
[17:03:56.527]                       }
[17:03:56.527]                       else if (inherits(cond, "condition")) {
[17:03:56.527]                         if (!is.null(pattern)) {
[17:03:56.527]                           computeRestarts <- base::computeRestarts
[17:03:56.527]                           grepl <- base::grepl
[17:03:56.527]                           restarts <- computeRestarts(cond)
[17:03:56.527]                           for (restart in restarts) {
[17:03:56.527]                             name <- restart$name
[17:03:56.527]                             if (is.null(name)) 
[17:03:56.527]                               next
[17:03:56.527]                             if (!grepl(pattern, name)) 
[17:03:56.527]                               next
[17:03:56.527]                             invokeRestart(restart)
[17:03:56.527]                             muffled <- TRUE
[17:03:56.527]                             break
[17:03:56.527]                           }
[17:03:56.527]                         }
[17:03:56.527]                       }
[17:03:56.527]                       invisible(muffled)
[17:03:56.527]                     }
[17:03:56.527]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.527]                   }
[17:03:56.527]                 }
[17:03:56.527]             }
[17:03:56.527]         }))
[17:03:56.527]     }, error = function(ex) {
[17:03:56.527]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.527]                 ...future.rng), started = ...future.startTime, 
[17:03:56.527]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.527]             version = "1.8"), class = "FutureResult")
[17:03:56.527]     }, finally = {
[17:03:56.527]         if (!identical(...future.workdir, getwd())) 
[17:03:56.527]             setwd(...future.workdir)
[17:03:56.527]         {
[17:03:56.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.527]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.527]             }
[17:03:56.527]             base::options(...future.oldOptions)
[17:03:56.527]             if (.Platform$OS.type == "windows") {
[17:03:56.527]                 old_names <- names(...future.oldEnvVars)
[17:03:56.527]                 envs <- base::Sys.getenv()
[17:03:56.527]                 names <- names(envs)
[17:03:56.527]                 common <- intersect(names, old_names)
[17:03:56.527]                 added <- setdiff(names, old_names)
[17:03:56.527]                 removed <- setdiff(old_names, names)
[17:03:56.527]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.527]                   envs[common]]
[17:03:56.527]                 NAMES <- toupper(changed)
[17:03:56.527]                 args <- list()
[17:03:56.527]                 for (kk in seq_along(NAMES)) {
[17:03:56.527]                   name <- changed[[kk]]
[17:03:56.527]                   NAME <- NAMES[[kk]]
[17:03:56.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.527]                     next
[17:03:56.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.527]                 }
[17:03:56.527]                 NAMES <- toupper(added)
[17:03:56.527]                 for (kk in seq_along(NAMES)) {
[17:03:56.527]                   name <- added[[kk]]
[17:03:56.527]                   NAME <- NAMES[[kk]]
[17:03:56.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.527]                     next
[17:03:56.527]                   args[[name]] <- ""
[17:03:56.527]                 }
[17:03:56.527]                 NAMES <- toupper(removed)
[17:03:56.527]                 for (kk in seq_along(NAMES)) {
[17:03:56.527]                   name <- removed[[kk]]
[17:03:56.527]                   NAME <- NAMES[[kk]]
[17:03:56.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.527]                     next
[17:03:56.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.527]                 }
[17:03:56.527]                 if (length(args) > 0) 
[17:03:56.527]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.527]             }
[17:03:56.527]             else {
[17:03:56.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.527]             }
[17:03:56.527]             {
[17:03:56.527]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.527]                   0L) {
[17:03:56.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.527]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.527]                   base::options(opts)
[17:03:56.527]                 }
[17:03:56.527]                 {
[17:03:56.527]                   {
[17:03:56.527]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.527]                     NULL
[17:03:56.527]                   }
[17:03:56.527]                   options(future.plan = NULL)
[17:03:56.527]                   if (is.na(NA_character_)) 
[17:03:56.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.527]                     .init = FALSE)
[17:03:56.527]                 }
[17:03:56.527]             }
[17:03:56.527]         }
[17:03:56.527]     })
[17:03:56.527]     if (TRUE) {
[17:03:56.527]         base::sink(type = "output", split = FALSE)
[17:03:56.527]         if (TRUE) {
[17:03:56.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.527]         }
[17:03:56.527]         else {
[17:03:56.527]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.527]         }
[17:03:56.527]         base::close(...future.stdout)
[17:03:56.527]         ...future.stdout <- NULL
[17:03:56.527]     }
[17:03:56.527]     ...future.result$conditions <- ...future.conditions
[17:03:56.527]     ...future.result$finished <- base::Sys.time()
[17:03:56.527]     ...future.result
[17:03:56.527] }
[17:03:56.530] MultisessionFuture started
[17:03:56.530] - Launch lazy future ... done
[17:03:56.530] run() for ‘MultisessionFuture’ ... done
[17:03:56.531] resolve() on environment ...
[17:03:56.531]  recursive: 0
[17:03:56.531]  elements: [3] ‘a’
[17:03:56.532] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.532] - Validating connection of MultisessionFuture
[17:03:56.532] - received message: FutureResult
[17:03:56.532] - Received FutureResult
[17:03:56.532] - Erased future from FutureRegistry
[17:03:56.532] result() for ClusterFuture ...
[17:03:56.532] - result already collected: FutureResult
[17:03:56.532] result() for ClusterFuture ... done
[17:03:56.533] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.533] Future #1
[17:03:56.533]  length: 2 (resolved future 1)
[17:03:56.533] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.533] - Validating connection of MultisessionFuture
[17:03:56.533] - received message: FutureResult
[17:03:56.534] - Received FutureResult
[17:03:56.534] - Erased future from FutureRegistry
[17:03:56.534] result() for ClusterFuture ...
[17:03:56.534] - result already collected: FutureResult
[17:03:56.534] result() for ClusterFuture ... done
[17:03:56.534] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.534] Future #2
[17:03:56.534]  length: 1 (resolved future 2)
[17:03:56.534]  length: 0 (resolved future 3)
[17:03:56.534] resolve() on environment ... DONE
[17:03:56.535] resolve() on environment ...
[17:03:56.535]  recursive: 0
[17:03:56.535]  elements: [3] ‘b’
[17:03:56.536] Future #1
[17:03:56.536]  length: 2 (resolved future 1)
[17:03:56.536] Future #2
[17:03:56.536]  length: 1 (resolved future 2)
[17:03:56.536]  length: 0 (resolved future 3)
[17:03:56.536] resolve() on environment ... DONE
[17:03:56.536] resolve() on environment ...
[17:03:56.537]  recursive: 0
[17:03:56.537]  elements: [3] ‘c’
[17:03:56.537] Future #1
[17:03:56.537]  length: 2 (resolved future 1)
[17:03:56.537] Future #2
[17:03:56.537]  length: 1 (resolved future 2)
[17:03:56.537]  length: 0 (resolved future 3)
[17:03:56.538] resolve() on environment ... DONE
[17:03:56.538] resolve() on environment ...
[17:03:56.538]  recursive: 0
[17:03:56.538]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:03:56.539] Future #1
[17:03:56.539] result() for ClusterFuture ...
[17:03:56.539] - result already collected: FutureResult
[17:03:56.539] result() for ClusterFuture ... done
[17:03:56.539] result() for ClusterFuture ...
[17:03:56.539] - result already collected: FutureResult
[17:03:56.539] result() for ClusterFuture ... done
[17:03:56.539]  length: 2 (resolved future 1)
[17:03:56.539] Future #2
[17:03:56.539] result() for ClusterFuture ...
[17:03:56.540] - result already collected: FutureResult
[17:03:56.540] result() for ClusterFuture ... done
[17:03:56.540] result() for ClusterFuture ...
[17:03:56.540] - result already collected: FutureResult
[17:03:56.540] result() for ClusterFuture ... done
[17:03:56.540]  length: 1 (resolved future 2)
[17:03:56.540]  length: 0 (resolved future 3)
[17:03:56.540] resolve() on environment ... DONE
[17:03:56.541] resolve() on environment ...
[17:03:56.541]  recursive: 99
[17:03:56.541]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:03:56.541] Future #1
[17:03:56.541] result() for ClusterFuture ...
[17:03:56.541] - result already collected: FutureResult
[17:03:56.542] result() for ClusterFuture ... done
[17:03:56.542] result() for ClusterFuture ...
[17:03:56.542] - result already collected: FutureResult
[17:03:56.542] result() for ClusterFuture ... done
[17:03:56.542] A MultisessionFuture was resolved
[17:03:56.542]  length: 2 (resolved future 1)
[17:03:56.542] Future #2
[17:03:56.542] result() for ClusterFuture ...
[17:03:56.542] - result already collected: FutureResult
[17:03:56.542] result() for ClusterFuture ... done
[17:03:56.542] result() for ClusterFuture ...
[17:03:56.543] - result already collected: FutureResult
[17:03:56.543] result() for ClusterFuture ... done
[17:03:56.543] A MultisessionFuture was resolved
[17:03:56.543]  length: 1 (resolved future 2)
[17:03:56.543]  length: 0 (resolved future 3)
[17:03:56.543] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:03:56.544] resolve() on list environment ...
[17:03:56.544]  recursive: 0
[17:03:56.544]  length: 2
[17:03:56.544]  elements: ‘a’, ‘b’
[17:03:56.544]  length: 1 (resolved future 1)
[17:03:56.545]  length: 0 (resolved future 2)
[17:03:56.545] resolve() on list environment ... DONE
[17:03:56.545] getGlobalsAndPackages() ...
[17:03:56.545] Searching for globals...
[17:03:56.545] 
[17:03:56.545] Searching for globals ... DONE
[17:03:56.545] - globals: [0] <none>
[17:03:56.545] getGlobalsAndPackages() ... DONE
[17:03:56.546] run() for ‘Future’ ...
[17:03:56.546] - state: ‘created’
[17:03:56.546] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.560] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.560]   - Field: ‘node’
[17:03:56.560]   - Field: ‘label’
[17:03:56.560]   - Field: ‘local’
[17:03:56.560]   - Field: ‘owner’
[17:03:56.560]   - Field: ‘envir’
[17:03:56.561]   - Field: ‘workers’
[17:03:56.561]   - Field: ‘packages’
[17:03:56.561]   - Field: ‘gc’
[17:03:56.561]   - Field: ‘conditions’
[17:03:56.561]   - Field: ‘persistent’
[17:03:56.561]   - Field: ‘expr’
[17:03:56.561]   - Field: ‘uuid’
[17:03:56.561]   - Field: ‘seed’
[17:03:56.561]   - Field: ‘version’
[17:03:56.561]   - Field: ‘result’
[17:03:56.561]   - Field: ‘asynchronous’
[17:03:56.562]   - Field: ‘calls’
[17:03:56.562]   - Field: ‘globals’
[17:03:56.562]   - Field: ‘stdout’
[17:03:56.562]   - Field: ‘earlySignal’
[17:03:56.562]   - Field: ‘lazy’
[17:03:56.562]   - Field: ‘state’
[17:03:56.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.562] - Launch lazy future ...
[17:03:56.562] Packages needed by the future expression (n = 0): <none>
[17:03:56.563] Packages needed by future strategies (n = 0): <none>
[17:03:56.563] {
[17:03:56.563]     {
[17:03:56.563]         {
[17:03:56.563]             ...future.startTime <- base::Sys.time()
[17:03:56.563]             {
[17:03:56.563]                 {
[17:03:56.563]                   {
[17:03:56.563]                     {
[17:03:56.563]                       base::local({
[17:03:56.563]                         has_future <- base::requireNamespace("future", 
[17:03:56.563]                           quietly = TRUE)
[17:03:56.563]                         if (has_future) {
[17:03:56.563]                           ns <- base::getNamespace("future")
[17:03:56.563]                           version <- ns[[".package"]][["version"]]
[17:03:56.563]                           if (is.null(version)) 
[17:03:56.563]                             version <- utils::packageVersion("future")
[17:03:56.563]                         }
[17:03:56.563]                         else {
[17:03:56.563]                           version <- NULL
[17:03:56.563]                         }
[17:03:56.563]                         if (!has_future || version < "1.8.0") {
[17:03:56.563]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.563]                             "", base::R.version$version.string), 
[17:03:56.563]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.563]                               "release", "version")], collapse = " "), 
[17:03:56.563]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.563]                             info)
[17:03:56.563]                           info <- base::paste(info, collapse = "; ")
[17:03:56.563]                           if (!has_future) {
[17:03:56.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.563]                               info)
[17:03:56.563]                           }
[17:03:56.563]                           else {
[17:03:56.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.563]                               info, version)
[17:03:56.563]                           }
[17:03:56.563]                           base::stop(msg)
[17:03:56.563]                         }
[17:03:56.563]                       })
[17:03:56.563]                     }
[17:03:56.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.563]                     base::options(mc.cores = 1L)
[17:03:56.563]                   }
[17:03:56.563]                   ...future.strategy.old <- future::plan("list")
[17:03:56.563]                   options(future.plan = NULL)
[17:03:56.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.563]                 }
[17:03:56.563]                 ...future.workdir <- getwd()
[17:03:56.563]             }
[17:03:56.563]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.563]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.563]         }
[17:03:56.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.563]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.563]             base::names(...future.oldOptions))
[17:03:56.563]     }
[17:03:56.563]     if (FALSE) {
[17:03:56.563]     }
[17:03:56.563]     else {
[17:03:56.563]         if (TRUE) {
[17:03:56.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.563]                 open = "w")
[17:03:56.563]         }
[17:03:56.563]         else {
[17:03:56.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.563]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.563]         }
[17:03:56.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.563]             base::sink(type = "output", split = FALSE)
[17:03:56.563]             base::close(...future.stdout)
[17:03:56.563]         }, add = TRUE)
[17:03:56.563]     }
[17:03:56.563]     ...future.frame <- base::sys.nframe()
[17:03:56.563]     ...future.conditions <- base::list()
[17:03:56.563]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.563]     if (FALSE) {
[17:03:56.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.563]     }
[17:03:56.563]     ...future.result <- base::tryCatch({
[17:03:56.563]         base::withCallingHandlers({
[17:03:56.563]             ...future.value <- base::withVisible(base::local({
[17:03:56.563]                 ...future.makeSendCondition <- base::local({
[17:03:56.563]                   sendCondition <- NULL
[17:03:56.563]                   function(frame = 1L) {
[17:03:56.563]                     if (is.function(sendCondition)) 
[17:03:56.563]                       return(sendCondition)
[17:03:56.563]                     ns <- getNamespace("parallel")
[17:03:56.563]                     if (exists("sendData", mode = "function", 
[17:03:56.563]                       envir = ns)) {
[17:03:56.563]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.563]                         envir = ns)
[17:03:56.563]                       envir <- sys.frame(frame)
[17:03:56.563]                       master <- NULL
[17:03:56.563]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.563]                         !identical(envir, emptyenv())) {
[17:03:56.563]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.563]                           inherits = FALSE)) {
[17:03:56.563]                           master <- get("master", mode = "list", 
[17:03:56.563]                             envir = envir, inherits = FALSE)
[17:03:56.563]                           if (inherits(master, c("SOCKnode", 
[17:03:56.563]                             "SOCK0node"))) {
[17:03:56.563]                             sendCondition <<- function(cond) {
[17:03:56.563]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.563]                                 success = TRUE)
[17:03:56.563]                               parallel_sendData(master, data)
[17:03:56.563]                             }
[17:03:56.563]                             return(sendCondition)
[17:03:56.563]                           }
[17:03:56.563]                         }
[17:03:56.563]                         frame <- frame + 1L
[17:03:56.563]                         envir <- sys.frame(frame)
[17:03:56.563]                       }
[17:03:56.563]                     }
[17:03:56.563]                     sendCondition <<- function(cond) NULL
[17:03:56.563]                   }
[17:03:56.563]                 })
[17:03:56.563]                 withCallingHandlers({
[17:03:56.563]                   1
[17:03:56.563]                 }, immediateCondition = function(cond) {
[17:03:56.563]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.563]                   sendCondition(cond)
[17:03:56.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.563]                   {
[17:03:56.563]                     inherits <- base::inherits
[17:03:56.563]                     invokeRestart <- base::invokeRestart
[17:03:56.563]                     is.null <- base::is.null
[17:03:56.563]                     muffled <- FALSE
[17:03:56.563]                     if (inherits(cond, "message")) {
[17:03:56.563]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.563]                       if (muffled) 
[17:03:56.563]                         invokeRestart("muffleMessage")
[17:03:56.563]                     }
[17:03:56.563]                     else if (inherits(cond, "warning")) {
[17:03:56.563]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.563]                       if (muffled) 
[17:03:56.563]                         invokeRestart("muffleWarning")
[17:03:56.563]                     }
[17:03:56.563]                     else if (inherits(cond, "condition")) {
[17:03:56.563]                       if (!is.null(pattern)) {
[17:03:56.563]                         computeRestarts <- base::computeRestarts
[17:03:56.563]                         grepl <- base::grepl
[17:03:56.563]                         restarts <- computeRestarts(cond)
[17:03:56.563]                         for (restart in restarts) {
[17:03:56.563]                           name <- restart$name
[17:03:56.563]                           if (is.null(name)) 
[17:03:56.563]                             next
[17:03:56.563]                           if (!grepl(pattern, name)) 
[17:03:56.563]                             next
[17:03:56.563]                           invokeRestart(restart)
[17:03:56.563]                           muffled <- TRUE
[17:03:56.563]                           break
[17:03:56.563]                         }
[17:03:56.563]                       }
[17:03:56.563]                     }
[17:03:56.563]                     invisible(muffled)
[17:03:56.563]                   }
[17:03:56.563]                   muffleCondition(cond)
[17:03:56.563]                 })
[17:03:56.563]             }))
[17:03:56.563]             future::FutureResult(value = ...future.value$value, 
[17:03:56.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.563]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.563]                     ...future.globalenv.names))
[17:03:56.563]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.563]         }, condition = base::local({
[17:03:56.563]             c <- base::c
[17:03:56.563]             inherits <- base::inherits
[17:03:56.563]             invokeRestart <- base::invokeRestart
[17:03:56.563]             length <- base::length
[17:03:56.563]             list <- base::list
[17:03:56.563]             seq.int <- base::seq.int
[17:03:56.563]             signalCondition <- base::signalCondition
[17:03:56.563]             sys.calls <- base::sys.calls
[17:03:56.563]             `[[` <- base::`[[`
[17:03:56.563]             `+` <- base::`+`
[17:03:56.563]             `<<-` <- base::`<<-`
[17:03:56.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.563]                   3L)]
[17:03:56.563]             }
[17:03:56.563]             function(cond) {
[17:03:56.563]                 is_error <- inherits(cond, "error")
[17:03:56.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.563]                   NULL)
[17:03:56.563]                 if (is_error) {
[17:03:56.563]                   sessionInformation <- function() {
[17:03:56.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.563]                       search = base::search(), system = base::Sys.info())
[17:03:56.563]                   }
[17:03:56.563]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.563]                     cond$call), session = sessionInformation(), 
[17:03:56.563]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.563]                   signalCondition(cond)
[17:03:56.563]                 }
[17:03:56.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.563]                 "immediateCondition"))) {
[17:03:56.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.563]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.563]                   if (TRUE && !signal) {
[17:03:56.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.563]                     {
[17:03:56.563]                       inherits <- base::inherits
[17:03:56.563]                       invokeRestart <- base::invokeRestart
[17:03:56.563]                       is.null <- base::is.null
[17:03:56.563]                       muffled <- FALSE
[17:03:56.563]                       if (inherits(cond, "message")) {
[17:03:56.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.563]                         if (muffled) 
[17:03:56.563]                           invokeRestart("muffleMessage")
[17:03:56.563]                       }
[17:03:56.563]                       else if (inherits(cond, "warning")) {
[17:03:56.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.563]                         if (muffled) 
[17:03:56.563]                           invokeRestart("muffleWarning")
[17:03:56.563]                       }
[17:03:56.563]                       else if (inherits(cond, "condition")) {
[17:03:56.563]                         if (!is.null(pattern)) {
[17:03:56.563]                           computeRestarts <- base::computeRestarts
[17:03:56.563]                           grepl <- base::grepl
[17:03:56.563]                           restarts <- computeRestarts(cond)
[17:03:56.563]                           for (restart in restarts) {
[17:03:56.563]                             name <- restart$name
[17:03:56.563]                             if (is.null(name)) 
[17:03:56.563]                               next
[17:03:56.563]                             if (!grepl(pattern, name)) 
[17:03:56.563]                               next
[17:03:56.563]                             invokeRestart(restart)
[17:03:56.563]                             muffled <- TRUE
[17:03:56.563]                             break
[17:03:56.563]                           }
[17:03:56.563]                         }
[17:03:56.563]                       }
[17:03:56.563]                       invisible(muffled)
[17:03:56.563]                     }
[17:03:56.563]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.563]                   }
[17:03:56.563]                 }
[17:03:56.563]                 else {
[17:03:56.563]                   if (TRUE) {
[17:03:56.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.563]                     {
[17:03:56.563]                       inherits <- base::inherits
[17:03:56.563]                       invokeRestart <- base::invokeRestart
[17:03:56.563]                       is.null <- base::is.null
[17:03:56.563]                       muffled <- FALSE
[17:03:56.563]                       if (inherits(cond, "message")) {
[17:03:56.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.563]                         if (muffled) 
[17:03:56.563]                           invokeRestart("muffleMessage")
[17:03:56.563]                       }
[17:03:56.563]                       else if (inherits(cond, "warning")) {
[17:03:56.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.563]                         if (muffled) 
[17:03:56.563]                           invokeRestart("muffleWarning")
[17:03:56.563]                       }
[17:03:56.563]                       else if (inherits(cond, "condition")) {
[17:03:56.563]                         if (!is.null(pattern)) {
[17:03:56.563]                           computeRestarts <- base::computeRestarts
[17:03:56.563]                           grepl <- base::grepl
[17:03:56.563]                           restarts <- computeRestarts(cond)
[17:03:56.563]                           for (restart in restarts) {
[17:03:56.563]                             name <- restart$name
[17:03:56.563]                             if (is.null(name)) 
[17:03:56.563]                               next
[17:03:56.563]                             if (!grepl(pattern, name)) 
[17:03:56.563]                               next
[17:03:56.563]                             invokeRestart(restart)
[17:03:56.563]                             muffled <- TRUE
[17:03:56.563]                             break
[17:03:56.563]                           }
[17:03:56.563]                         }
[17:03:56.563]                       }
[17:03:56.563]                       invisible(muffled)
[17:03:56.563]                     }
[17:03:56.563]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.563]                   }
[17:03:56.563]                 }
[17:03:56.563]             }
[17:03:56.563]         }))
[17:03:56.563]     }, error = function(ex) {
[17:03:56.563]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.563]                 ...future.rng), started = ...future.startTime, 
[17:03:56.563]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.563]             version = "1.8"), class = "FutureResult")
[17:03:56.563]     }, finally = {
[17:03:56.563]         if (!identical(...future.workdir, getwd())) 
[17:03:56.563]             setwd(...future.workdir)
[17:03:56.563]         {
[17:03:56.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.563]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.563]             }
[17:03:56.563]             base::options(...future.oldOptions)
[17:03:56.563]             if (.Platform$OS.type == "windows") {
[17:03:56.563]                 old_names <- names(...future.oldEnvVars)
[17:03:56.563]                 envs <- base::Sys.getenv()
[17:03:56.563]                 names <- names(envs)
[17:03:56.563]                 common <- intersect(names, old_names)
[17:03:56.563]                 added <- setdiff(names, old_names)
[17:03:56.563]                 removed <- setdiff(old_names, names)
[17:03:56.563]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.563]                   envs[common]]
[17:03:56.563]                 NAMES <- toupper(changed)
[17:03:56.563]                 args <- list()
[17:03:56.563]                 for (kk in seq_along(NAMES)) {
[17:03:56.563]                   name <- changed[[kk]]
[17:03:56.563]                   NAME <- NAMES[[kk]]
[17:03:56.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.563]                     next
[17:03:56.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.563]                 }
[17:03:56.563]                 NAMES <- toupper(added)
[17:03:56.563]                 for (kk in seq_along(NAMES)) {
[17:03:56.563]                   name <- added[[kk]]
[17:03:56.563]                   NAME <- NAMES[[kk]]
[17:03:56.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.563]                     next
[17:03:56.563]                   args[[name]] <- ""
[17:03:56.563]                 }
[17:03:56.563]                 NAMES <- toupper(removed)
[17:03:56.563]                 for (kk in seq_along(NAMES)) {
[17:03:56.563]                   name <- removed[[kk]]
[17:03:56.563]                   NAME <- NAMES[[kk]]
[17:03:56.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.563]                     next
[17:03:56.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.563]                 }
[17:03:56.563]                 if (length(args) > 0) 
[17:03:56.563]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.563]             }
[17:03:56.563]             else {
[17:03:56.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.563]             }
[17:03:56.563]             {
[17:03:56.563]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.563]                   0L) {
[17:03:56.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.563]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.563]                   base::options(opts)
[17:03:56.563]                 }
[17:03:56.563]                 {
[17:03:56.563]                   {
[17:03:56.563]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.563]                     NULL
[17:03:56.563]                   }
[17:03:56.563]                   options(future.plan = NULL)
[17:03:56.563]                   if (is.na(NA_character_)) 
[17:03:56.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.563]                     .init = FALSE)
[17:03:56.563]                 }
[17:03:56.563]             }
[17:03:56.563]         }
[17:03:56.563]     })
[17:03:56.563]     if (TRUE) {
[17:03:56.563]         base::sink(type = "output", split = FALSE)
[17:03:56.563]         if (TRUE) {
[17:03:56.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.563]         }
[17:03:56.563]         else {
[17:03:56.563]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.563]         }
[17:03:56.563]         base::close(...future.stdout)
[17:03:56.563]         ...future.stdout <- NULL
[17:03:56.563]     }
[17:03:56.563]     ...future.result$conditions <- ...future.conditions
[17:03:56.563]     ...future.result$finished <- base::Sys.time()
[17:03:56.563]     ...future.result
[17:03:56.563] }
[17:03:56.566] MultisessionFuture started
[17:03:56.566] - Launch lazy future ... done
[17:03:56.566] run() for ‘MultisessionFuture’ ... done
[17:03:56.566] getGlobalsAndPackages() ...
[17:03:56.566] Searching for globals...
[17:03:56.567] 
[17:03:56.567] Searching for globals ... DONE
[17:03:56.567] - globals: [0] <none>
[17:03:56.567] getGlobalsAndPackages() ... DONE
[17:03:56.567] run() for ‘Future’ ...
[17:03:56.567] - state: ‘created’
[17:03:56.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.581] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.581]   - Field: ‘node’
[17:03:56.581]   - Field: ‘label’
[17:03:56.581]   - Field: ‘local’
[17:03:56.581]   - Field: ‘owner’
[17:03:56.582]   - Field: ‘envir’
[17:03:56.582]   - Field: ‘workers’
[17:03:56.582]   - Field: ‘packages’
[17:03:56.582]   - Field: ‘gc’
[17:03:56.582]   - Field: ‘conditions’
[17:03:56.582]   - Field: ‘persistent’
[17:03:56.582]   - Field: ‘expr’
[17:03:56.582]   - Field: ‘uuid’
[17:03:56.582]   - Field: ‘seed’
[17:03:56.582]   - Field: ‘version’
[17:03:56.582]   - Field: ‘result’
[17:03:56.583]   - Field: ‘asynchronous’
[17:03:56.583]   - Field: ‘calls’
[17:03:56.583]   - Field: ‘globals’
[17:03:56.583]   - Field: ‘stdout’
[17:03:56.583]   - Field: ‘earlySignal’
[17:03:56.583]   - Field: ‘lazy’
[17:03:56.583]   - Field: ‘state’
[17:03:56.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.583] - Launch lazy future ...
[17:03:56.584] Packages needed by the future expression (n = 0): <none>
[17:03:56.584] Packages needed by future strategies (n = 0): <none>
[17:03:56.584] {
[17:03:56.584]     {
[17:03:56.584]         {
[17:03:56.584]             ...future.startTime <- base::Sys.time()
[17:03:56.584]             {
[17:03:56.584]                 {
[17:03:56.584]                   {
[17:03:56.584]                     {
[17:03:56.584]                       base::local({
[17:03:56.584]                         has_future <- base::requireNamespace("future", 
[17:03:56.584]                           quietly = TRUE)
[17:03:56.584]                         if (has_future) {
[17:03:56.584]                           ns <- base::getNamespace("future")
[17:03:56.584]                           version <- ns[[".package"]][["version"]]
[17:03:56.584]                           if (is.null(version)) 
[17:03:56.584]                             version <- utils::packageVersion("future")
[17:03:56.584]                         }
[17:03:56.584]                         else {
[17:03:56.584]                           version <- NULL
[17:03:56.584]                         }
[17:03:56.584]                         if (!has_future || version < "1.8.0") {
[17:03:56.584]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.584]                             "", base::R.version$version.string), 
[17:03:56.584]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.584]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.584]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.584]                               "release", "version")], collapse = " "), 
[17:03:56.584]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.584]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.584]                             info)
[17:03:56.584]                           info <- base::paste(info, collapse = "; ")
[17:03:56.584]                           if (!has_future) {
[17:03:56.584]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.584]                               info)
[17:03:56.584]                           }
[17:03:56.584]                           else {
[17:03:56.584]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.584]                               info, version)
[17:03:56.584]                           }
[17:03:56.584]                           base::stop(msg)
[17:03:56.584]                         }
[17:03:56.584]                       })
[17:03:56.584]                     }
[17:03:56.584]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.584]                     base::options(mc.cores = 1L)
[17:03:56.584]                   }
[17:03:56.584]                   ...future.strategy.old <- future::plan("list")
[17:03:56.584]                   options(future.plan = NULL)
[17:03:56.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.584]                 }
[17:03:56.584]                 ...future.workdir <- getwd()
[17:03:56.584]             }
[17:03:56.584]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.584]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.584]         }
[17:03:56.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.584]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.584]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.584]             base::names(...future.oldOptions))
[17:03:56.584]     }
[17:03:56.584]     if (FALSE) {
[17:03:56.584]     }
[17:03:56.584]     else {
[17:03:56.584]         if (TRUE) {
[17:03:56.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.584]                 open = "w")
[17:03:56.584]         }
[17:03:56.584]         else {
[17:03:56.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.584]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.584]         }
[17:03:56.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.584]             base::sink(type = "output", split = FALSE)
[17:03:56.584]             base::close(...future.stdout)
[17:03:56.584]         }, add = TRUE)
[17:03:56.584]     }
[17:03:56.584]     ...future.frame <- base::sys.nframe()
[17:03:56.584]     ...future.conditions <- base::list()
[17:03:56.584]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.584]     if (FALSE) {
[17:03:56.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.584]     }
[17:03:56.584]     ...future.result <- base::tryCatch({
[17:03:56.584]         base::withCallingHandlers({
[17:03:56.584]             ...future.value <- base::withVisible(base::local({
[17:03:56.584]                 ...future.makeSendCondition <- base::local({
[17:03:56.584]                   sendCondition <- NULL
[17:03:56.584]                   function(frame = 1L) {
[17:03:56.584]                     if (is.function(sendCondition)) 
[17:03:56.584]                       return(sendCondition)
[17:03:56.584]                     ns <- getNamespace("parallel")
[17:03:56.584]                     if (exists("sendData", mode = "function", 
[17:03:56.584]                       envir = ns)) {
[17:03:56.584]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.584]                         envir = ns)
[17:03:56.584]                       envir <- sys.frame(frame)
[17:03:56.584]                       master <- NULL
[17:03:56.584]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.584]                         !identical(envir, emptyenv())) {
[17:03:56.584]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.584]                           inherits = FALSE)) {
[17:03:56.584]                           master <- get("master", mode = "list", 
[17:03:56.584]                             envir = envir, inherits = FALSE)
[17:03:56.584]                           if (inherits(master, c("SOCKnode", 
[17:03:56.584]                             "SOCK0node"))) {
[17:03:56.584]                             sendCondition <<- function(cond) {
[17:03:56.584]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.584]                                 success = TRUE)
[17:03:56.584]                               parallel_sendData(master, data)
[17:03:56.584]                             }
[17:03:56.584]                             return(sendCondition)
[17:03:56.584]                           }
[17:03:56.584]                         }
[17:03:56.584]                         frame <- frame + 1L
[17:03:56.584]                         envir <- sys.frame(frame)
[17:03:56.584]                       }
[17:03:56.584]                     }
[17:03:56.584]                     sendCondition <<- function(cond) NULL
[17:03:56.584]                   }
[17:03:56.584]                 })
[17:03:56.584]                 withCallingHandlers({
[17:03:56.584]                   2
[17:03:56.584]                 }, immediateCondition = function(cond) {
[17:03:56.584]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.584]                   sendCondition(cond)
[17:03:56.584]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.584]                   {
[17:03:56.584]                     inherits <- base::inherits
[17:03:56.584]                     invokeRestart <- base::invokeRestart
[17:03:56.584]                     is.null <- base::is.null
[17:03:56.584]                     muffled <- FALSE
[17:03:56.584]                     if (inherits(cond, "message")) {
[17:03:56.584]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.584]                       if (muffled) 
[17:03:56.584]                         invokeRestart("muffleMessage")
[17:03:56.584]                     }
[17:03:56.584]                     else if (inherits(cond, "warning")) {
[17:03:56.584]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.584]                       if (muffled) 
[17:03:56.584]                         invokeRestart("muffleWarning")
[17:03:56.584]                     }
[17:03:56.584]                     else if (inherits(cond, "condition")) {
[17:03:56.584]                       if (!is.null(pattern)) {
[17:03:56.584]                         computeRestarts <- base::computeRestarts
[17:03:56.584]                         grepl <- base::grepl
[17:03:56.584]                         restarts <- computeRestarts(cond)
[17:03:56.584]                         for (restart in restarts) {
[17:03:56.584]                           name <- restart$name
[17:03:56.584]                           if (is.null(name)) 
[17:03:56.584]                             next
[17:03:56.584]                           if (!grepl(pattern, name)) 
[17:03:56.584]                             next
[17:03:56.584]                           invokeRestart(restart)
[17:03:56.584]                           muffled <- TRUE
[17:03:56.584]                           break
[17:03:56.584]                         }
[17:03:56.584]                       }
[17:03:56.584]                     }
[17:03:56.584]                     invisible(muffled)
[17:03:56.584]                   }
[17:03:56.584]                   muffleCondition(cond)
[17:03:56.584]                 })
[17:03:56.584]             }))
[17:03:56.584]             future::FutureResult(value = ...future.value$value, 
[17:03:56.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.584]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.584]                     ...future.globalenv.names))
[17:03:56.584]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.584]         }, condition = base::local({
[17:03:56.584]             c <- base::c
[17:03:56.584]             inherits <- base::inherits
[17:03:56.584]             invokeRestart <- base::invokeRestart
[17:03:56.584]             length <- base::length
[17:03:56.584]             list <- base::list
[17:03:56.584]             seq.int <- base::seq.int
[17:03:56.584]             signalCondition <- base::signalCondition
[17:03:56.584]             sys.calls <- base::sys.calls
[17:03:56.584]             `[[` <- base::`[[`
[17:03:56.584]             `+` <- base::`+`
[17:03:56.584]             `<<-` <- base::`<<-`
[17:03:56.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.584]                   3L)]
[17:03:56.584]             }
[17:03:56.584]             function(cond) {
[17:03:56.584]                 is_error <- inherits(cond, "error")
[17:03:56.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.584]                   NULL)
[17:03:56.584]                 if (is_error) {
[17:03:56.584]                   sessionInformation <- function() {
[17:03:56.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.584]                       search = base::search(), system = base::Sys.info())
[17:03:56.584]                   }
[17:03:56.584]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.584]                     cond$call), session = sessionInformation(), 
[17:03:56.584]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.584]                   signalCondition(cond)
[17:03:56.584]                 }
[17:03:56.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.584]                 "immediateCondition"))) {
[17:03:56.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.584]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.584]                   if (TRUE && !signal) {
[17:03:56.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.584]                     {
[17:03:56.584]                       inherits <- base::inherits
[17:03:56.584]                       invokeRestart <- base::invokeRestart
[17:03:56.584]                       is.null <- base::is.null
[17:03:56.584]                       muffled <- FALSE
[17:03:56.584]                       if (inherits(cond, "message")) {
[17:03:56.584]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.584]                         if (muffled) 
[17:03:56.584]                           invokeRestart("muffleMessage")
[17:03:56.584]                       }
[17:03:56.584]                       else if (inherits(cond, "warning")) {
[17:03:56.584]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.584]                         if (muffled) 
[17:03:56.584]                           invokeRestart("muffleWarning")
[17:03:56.584]                       }
[17:03:56.584]                       else if (inherits(cond, "condition")) {
[17:03:56.584]                         if (!is.null(pattern)) {
[17:03:56.584]                           computeRestarts <- base::computeRestarts
[17:03:56.584]                           grepl <- base::grepl
[17:03:56.584]                           restarts <- computeRestarts(cond)
[17:03:56.584]                           for (restart in restarts) {
[17:03:56.584]                             name <- restart$name
[17:03:56.584]                             if (is.null(name)) 
[17:03:56.584]                               next
[17:03:56.584]                             if (!grepl(pattern, name)) 
[17:03:56.584]                               next
[17:03:56.584]                             invokeRestart(restart)
[17:03:56.584]                             muffled <- TRUE
[17:03:56.584]                             break
[17:03:56.584]                           }
[17:03:56.584]                         }
[17:03:56.584]                       }
[17:03:56.584]                       invisible(muffled)
[17:03:56.584]                     }
[17:03:56.584]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.584]                   }
[17:03:56.584]                 }
[17:03:56.584]                 else {
[17:03:56.584]                   if (TRUE) {
[17:03:56.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.584]                     {
[17:03:56.584]                       inherits <- base::inherits
[17:03:56.584]                       invokeRestart <- base::invokeRestart
[17:03:56.584]                       is.null <- base::is.null
[17:03:56.584]                       muffled <- FALSE
[17:03:56.584]                       if (inherits(cond, "message")) {
[17:03:56.584]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.584]                         if (muffled) 
[17:03:56.584]                           invokeRestart("muffleMessage")
[17:03:56.584]                       }
[17:03:56.584]                       else if (inherits(cond, "warning")) {
[17:03:56.584]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.584]                         if (muffled) 
[17:03:56.584]                           invokeRestart("muffleWarning")
[17:03:56.584]                       }
[17:03:56.584]                       else if (inherits(cond, "condition")) {
[17:03:56.584]                         if (!is.null(pattern)) {
[17:03:56.584]                           computeRestarts <- base::computeRestarts
[17:03:56.584]                           grepl <- base::grepl
[17:03:56.584]                           restarts <- computeRestarts(cond)
[17:03:56.584]                           for (restart in restarts) {
[17:03:56.584]                             name <- restart$name
[17:03:56.584]                             if (is.null(name)) 
[17:03:56.584]                               next
[17:03:56.584]                             if (!grepl(pattern, name)) 
[17:03:56.584]                               next
[17:03:56.584]                             invokeRestart(restart)
[17:03:56.584]                             muffled <- TRUE
[17:03:56.584]                             break
[17:03:56.584]                           }
[17:03:56.584]                         }
[17:03:56.584]                       }
[17:03:56.584]                       invisible(muffled)
[17:03:56.584]                     }
[17:03:56.584]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.584]                   }
[17:03:56.584]                 }
[17:03:56.584]             }
[17:03:56.584]         }))
[17:03:56.584]     }, error = function(ex) {
[17:03:56.584]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.584]                 ...future.rng), started = ...future.startTime, 
[17:03:56.584]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.584]             version = "1.8"), class = "FutureResult")
[17:03:56.584]     }, finally = {
[17:03:56.584]         if (!identical(...future.workdir, getwd())) 
[17:03:56.584]             setwd(...future.workdir)
[17:03:56.584]         {
[17:03:56.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.584]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.584]             }
[17:03:56.584]             base::options(...future.oldOptions)
[17:03:56.584]             if (.Platform$OS.type == "windows") {
[17:03:56.584]                 old_names <- names(...future.oldEnvVars)
[17:03:56.584]                 envs <- base::Sys.getenv()
[17:03:56.584]                 names <- names(envs)
[17:03:56.584]                 common <- intersect(names, old_names)
[17:03:56.584]                 added <- setdiff(names, old_names)
[17:03:56.584]                 removed <- setdiff(old_names, names)
[17:03:56.584]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.584]                   envs[common]]
[17:03:56.584]                 NAMES <- toupper(changed)
[17:03:56.584]                 args <- list()
[17:03:56.584]                 for (kk in seq_along(NAMES)) {
[17:03:56.584]                   name <- changed[[kk]]
[17:03:56.584]                   NAME <- NAMES[[kk]]
[17:03:56.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.584]                     next
[17:03:56.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.584]                 }
[17:03:56.584]                 NAMES <- toupper(added)
[17:03:56.584]                 for (kk in seq_along(NAMES)) {
[17:03:56.584]                   name <- added[[kk]]
[17:03:56.584]                   NAME <- NAMES[[kk]]
[17:03:56.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.584]                     next
[17:03:56.584]                   args[[name]] <- ""
[17:03:56.584]                 }
[17:03:56.584]                 NAMES <- toupper(removed)
[17:03:56.584]                 for (kk in seq_along(NAMES)) {
[17:03:56.584]                   name <- removed[[kk]]
[17:03:56.584]                   NAME <- NAMES[[kk]]
[17:03:56.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.584]                     next
[17:03:56.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.584]                 }
[17:03:56.584]                 if (length(args) > 0) 
[17:03:56.584]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.584]             }
[17:03:56.584]             else {
[17:03:56.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.584]             }
[17:03:56.584]             {
[17:03:56.584]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.584]                   0L) {
[17:03:56.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.584]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.584]                   base::options(opts)
[17:03:56.584]                 }
[17:03:56.584]                 {
[17:03:56.584]                   {
[17:03:56.584]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.584]                     NULL
[17:03:56.584]                   }
[17:03:56.584]                   options(future.plan = NULL)
[17:03:56.584]                   if (is.na(NA_character_)) 
[17:03:56.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.584]                     .init = FALSE)
[17:03:56.584]                 }
[17:03:56.584]             }
[17:03:56.584]         }
[17:03:56.584]     })
[17:03:56.584]     if (TRUE) {
[17:03:56.584]         base::sink(type = "output", split = FALSE)
[17:03:56.584]         if (TRUE) {
[17:03:56.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.584]         }
[17:03:56.584]         else {
[17:03:56.584]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.584]         }
[17:03:56.584]         base::close(...future.stdout)
[17:03:56.584]         ...future.stdout <- NULL
[17:03:56.584]     }
[17:03:56.584]     ...future.result$conditions <- ...future.conditions
[17:03:56.584]     ...future.result$finished <- base::Sys.time()
[17:03:56.584]     ...future.result
[17:03:56.584] }
[17:03:56.587] MultisessionFuture started
[17:03:56.587] - Launch lazy future ... done
[17:03:56.587] run() for ‘MultisessionFuture’ ... done
[17:03:56.588] resolve() on list environment ...
[17:03:56.588]  recursive: 0
[17:03:56.589]  length: 3
[17:03:56.589]  elements: ‘a’, ‘b’, ‘c’
[17:03:56.589] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.589] - Validating connection of MultisessionFuture
[17:03:56.589] - received message: FutureResult
[17:03:56.590] - Received FutureResult
[17:03:56.590] - Erased future from FutureRegistry
[17:03:56.590] result() for ClusterFuture ...
[17:03:56.590] - result already collected: FutureResult
[17:03:56.590] result() for ClusterFuture ... done
[17:03:56.590] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.590] Future #1
[17:03:56.590]  length: 2 (resolved future 1)
[17:03:56.591] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.591] - Validating connection of MultisessionFuture
[17:03:56.591] - received message: FutureResult
[17:03:56.591] - Received FutureResult
[17:03:56.591] - Erased future from FutureRegistry
[17:03:56.591] result() for ClusterFuture ...
[17:03:56.591] - result already collected: FutureResult
[17:03:56.591] result() for ClusterFuture ... done
[17:03:56.591] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.592] Future #2
[17:03:56.592]  length: 1 (resolved future 2)
[17:03:56.592]  length: 0 (resolved future 3)
[17:03:56.592] resolve() on list environment ... DONE
[17:03:56.592] getGlobalsAndPackages() ...
[17:03:56.593] Searching for globals...
[17:03:56.593] - globals found: [1] ‘{’
[17:03:56.593] Searching for globals ... DONE
[17:03:56.593] Resolving globals: FALSE
[17:03:56.594] 
[17:03:56.594] 
[17:03:56.594] getGlobalsAndPackages() ... DONE
[17:03:56.594] run() for ‘Future’ ...
[17:03:56.594] - state: ‘created’
[17:03:56.594] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.608] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.608]   - Field: ‘node’
[17:03:56.608]   - Field: ‘label’
[17:03:56.609]   - Field: ‘local’
[17:03:56.609]   - Field: ‘owner’
[17:03:56.609]   - Field: ‘envir’
[17:03:56.609]   - Field: ‘workers’
[17:03:56.609]   - Field: ‘packages’
[17:03:56.609]   - Field: ‘gc’
[17:03:56.609]   - Field: ‘conditions’
[17:03:56.609]   - Field: ‘persistent’
[17:03:56.609]   - Field: ‘expr’
[17:03:56.609]   - Field: ‘uuid’
[17:03:56.609]   - Field: ‘seed’
[17:03:56.610]   - Field: ‘version’
[17:03:56.610]   - Field: ‘result’
[17:03:56.610]   - Field: ‘asynchronous’
[17:03:56.610]   - Field: ‘calls’
[17:03:56.610]   - Field: ‘globals’
[17:03:56.610]   - Field: ‘stdout’
[17:03:56.610]   - Field: ‘earlySignal’
[17:03:56.610]   - Field: ‘lazy’
[17:03:56.610]   - Field: ‘state’
[17:03:56.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.610] - Launch lazy future ...
[17:03:56.611] Packages needed by the future expression (n = 0): <none>
[17:03:56.611] Packages needed by future strategies (n = 0): <none>
[17:03:56.611] {
[17:03:56.611]     {
[17:03:56.611]         {
[17:03:56.611]             ...future.startTime <- base::Sys.time()
[17:03:56.611]             {
[17:03:56.611]                 {
[17:03:56.611]                   {
[17:03:56.611]                     {
[17:03:56.611]                       base::local({
[17:03:56.611]                         has_future <- base::requireNamespace("future", 
[17:03:56.611]                           quietly = TRUE)
[17:03:56.611]                         if (has_future) {
[17:03:56.611]                           ns <- base::getNamespace("future")
[17:03:56.611]                           version <- ns[[".package"]][["version"]]
[17:03:56.611]                           if (is.null(version)) 
[17:03:56.611]                             version <- utils::packageVersion("future")
[17:03:56.611]                         }
[17:03:56.611]                         else {
[17:03:56.611]                           version <- NULL
[17:03:56.611]                         }
[17:03:56.611]                         if (!has_future || version < "1.8.0") {
[17:03:56.611]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.611]                             "", base::R.version$version.string), 
[17:03:56.611]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.611]                               "release", "version")], collapse = " "), 
[17:03:56.611]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.611]                             info)
[17:03:56.611]                           info <- base::paste(info, collapse = "; ")
[17:03:56.611]                           if (!has_future) {
[17:03:56.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.611]                               info)
[17:03:56.611]                           }
[17:03:56.611]                           else {
[17:03:56.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.611]                               info, version)
[17:03:56.611]                           }
[17:03:56.611]                           base::stop(msg)
[17:03:56.611]                         }
[17:03:56.611]                       })
[17:03:56.611]                     }
[17:03:56.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.611]                     base::options(mc.cores = 1L)
[17:03:56.611]                   }
[17:03:56.611]                   ...future.strategy.old <- future::plan("list")
[17:03:56.611]                   options(future.plan = NULL)
[17:03:56.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.611]                 }
[17:03:56.611]                 ...future.workdir <- getwd()
[17:03:56.611]             }
[17:03:56.611]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.611]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.611]         }
[17:03:56.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.611]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.611]             base::names(...future.oldOptions))
[17:03:56.611]     }
[17:03:56.611]     if (FALSE) {
[17:03:56.611]     }
[17:03:56.611]     else {
[17:03:56.611]         if (TRUE) {
[17:03:56.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.611]                 open = "w")
[17:03:56.611]         }
[17:03:56.611]         else {
[17:03:56.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.611]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.611]         }
[17:03:56.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.611]             base::sink(type = "output", split = FALSE)
[17:03:56.611]             base::close(...future.stdout)
[17:03:56.611]         }, add = TRUE)
[17:03:56.611]     }
[17:03:56.611]     ...future.frame <- base::sys.nframe()
[17:03:56.611]     ...future.conditions <- base::list()
[17:03:56.611]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.611]     if (FALSE) {
[17:03:56.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.611]     }
[17:03:56.611]     ...future.result <- base::tryCatch({
[17:03:56.611]         base::withCallingHandlers({
[17:03:56.611]             ...future.value <- base::withVisible(base::local({
[17:03:56.611]                 ...future.makeSendCondition <- base::local({
[17:03:56.611]                   sendCondition <- NULL
[17:03:56.611]                   function(frame = 1L) {
[17:03:56.611]                     if (is.function(sendCondition)) 
[17:03:56.611]                       return(sendCondition)
[17:03:56.611]                     ns <- getNamespace("parallel")
[17:03:56.611]                     if (exists("sendData", mode = "function", 
[17:03:56.611]                       envir = ns)) {
[17:03:56.611]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.611]                         envir = ns)
[17:03:56.611]                       envir <- sys.frame(frame)
[17:03:56.611]                       master <- NULL
[17:03:56.611]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.611]                         !identical(envir, emptyenv())) {
[17:03:56.611]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.611]                           inherits = FALSE)) {
[17:03:56.611]                           master <- get("master", mode = "list", 
[17:03:56.611]                             envir = envir, inherits = FALSE)
[17:03:56.611]                           if (inherits(master, c("SOCKnode", 
[17:03:56.611]                             "SOCK0node"))) {
[17:03:56.611]                             sendCondition <<- function(cond) {
[17:03:56.611]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.611]                                 success = TRUE)
[17:03:56.611]                               parallel_sendData(master, data)
[17:03:56.611]                             }
[17:03:56.611]                             return(sendCondition)
[17:03:56.611]                           }
[17:03:56.611]                         }
[17:03:56.611]                         frame <- frame + 1L
[17:03:56.611]                         envir <- sys.frame(frame)
[17:03:56.611]                       }
[17:03:56.611]                     }
[17:03:56.611]                     sendCondition <<- function(cond) NULL
[17:03:56.611]                   }
[17:03:56.611]                 })
[17:03:56.611]                 withCallingHandlers({
[17:03:56.611]                   {
[17:03:56.611]                     1
[17:03:56.611]                   }
[17:03:56.611]                 }, immediateCondition = function(cond) {
[17:03:56.611]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.611]                   sendCondition(cond)
[17:03:56.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.611]                   {
[17:03:56.611]                     inherits <- base::inherits
[17:03:56.611]                     invokeRestart <- base::invokeRestart
[17:03:56.611]                     is.null <- base::is.null
[17:03:56.611]                     muffled <- FALSE
[17:03:56.611]                     if (inherits(cond, "message")) {
[17:03:56.611]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.611]                       if (muffled) 
[17:03:56.611]                         invokeRestart("muffleMessage")
[17:03:56.611]                     }
[17:03:56.611]                     else if (inherits(cond, "warning")) {
[17:03:56.611]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.611]                       if (muffled) 
[17:03:56.611]                         invokeRestart("muffleWarning")
[17:03:56.611]                     }
[17:03:56.611]                     else if (inherits(cond, "condition")) {
[17:03:56.611]                       if (!is.null(pattern)) {
[17:03:56.611]                         computeRestarts <- base::computeRestarts
[17:03:56.611]                         grepl <- base::grepl
[17:03:56.611]                         restarts <- computeRestarts(cond)
[17:03:56.611]                         for (restart in restarts) {
[17:03:56.611]                           name <- restart$name
[17:03:56.611]                           if (is.null(name)) 
[17:03:56.611]                             next
[17:03:56.611]                           if (!grepl(pattern, name)) 
[17:03:56.611]                             next
[17:03:56.611]                           invokeRestart(restart)
[17:03:56.611]                           muffled <- TRUE
[17:03:56.611]                           break
[17:03:56.611]                         }
[17:03:56.611]                       }
[17:03:56.611]                     }
[17:03:56.611]                     invisible(muffled)
[17:03:56.611]                   }
[17:03:56.611]                   muffleCondition(cond)
[17:03:56.611]                 })
[17:03:56.611]             }))
[17:03:56.611]             future::FutureResult(value = ...future.value$value, 
[17:03:56.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.611]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.611]                     ...future.globalenv.names))
[17:03:56.611]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.611]         }, condition = base::local({
[17:03:56.611]             c <- base::c
[17:03:56.611]             inherits <- base::inherits
[17:03:56.611]             invokeRestart <- base::invokeRestart
[17:03:56.611]             length <- base::length
[17:03:56.611]             list <- base::list
[17:03:56.611]             seq.int <- base::seq.int
[17:03:56.611]             signalCondition <- base::signalCondition
[17:03:56.611]             sys.calls <- base::sys.calls
[17:03:56.611]             `[[` <- base::`[[`
[17:03:56.611]             `+` <- base::`+`
[17:03:56.611]             `<<-` <- base::`<<-`
[17:03:56.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.611]                   3L)]
[17:03:56.611]             }
[17:03:56.611]             function(cond) {
[17:03:56.611]                 is_error <- inherits(cond, "error")
[17:03:56.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.611]                   NULL)
[17:03:56.611]                 if (is_error) {
[17:03:56.611]                   sessionInformation <- function() {
[17:03:56.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.611]                       search = base::search(), system = base::Sys.info())
[17:03:56.611]                   }
[17:03:56.611]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.611]                     cond$call), session = sessionInformation(), 
[17:03:56.611]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.611]                   signalCondition(cond)
[17:03:56.611]                 }
[17:03:56.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.611]                 "immediateCondition"))) {
[17:03:56.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.611]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.611]                   if (TRUE && !signal) {
[17:03:56.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.611]                     {
[17:03:56.611]                       inherits <- base::inherits
[17:03:56.611]                       invokeRestart <- base::invokeRestart
[17:03:56.611]                       is.null <- base::is.null
[17:03:56.611]                       muffled <- FALSE
[17:03:56.611]                       if (inherits(cond, "message")) {
[17:03:56.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.611]                         if (muffled) 
[17:03:56.611]                           invokeRestart("muffleMessage")
[17:03:56.611]                       }
[17:03:56.611]                       else if (inherits(cond, "warning")) {
[17:03:56.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.611]                         if (muffled) 
[17:03:56.611]                           invokeRestart("muffleWarning")
[17:03:56.611]                       }
[17:03:56.611]                       else if (inherits(cond, "condition")) {
[17:03:56.611]                         if (!is.null(pattern)) {
[17:03:56.611]                           computeRestarts <- base::computeRestarts
[17:03:56.611]                           grepl <- base::grepl
[17:03:56.611]                           restarts <- computeRestarts(cond)
[17:03:56.611]                           for (restart in restarts) {
[17:03:56.611]                             name <- restart$name
[17:03:56.611]                             if (is.null(name)) 
[17:03:56.611]                               next
[17:03:56.611]                             if (!grepl(pattern, name)) 
[17:03:56.611]                               next
[17:03:56.611]                             invokeRestart(restart)
[17:03:56.611]                             muffled <- TRUE
[17:03:56.611]                             break
[17:03:56.611]                           }
[17:03:56.611]                         }
[17:03:56.611]                       }
[17:03:56.611]                       invisible(muffled)
[17:03:56.611]                     }
[17:03:56.611]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.611]                   }
[17:03:56.611]                 }
[17:03:56.611]                 else {
[17:03:56.611]                   if (TRUE) {
[17:03:56.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.611]                     {
[17:03:56.611]                       inherits <- base::inherits
[17:03:56.611]                       invokeRestart <- base::invokeRestart
[17:03:56.611]                       is.null <- base::is.null
[17:03:56.611]                       muffled <- FALSE
[17:03:56.611]                       if (inherits(cond, "message")) {
[17:03:56.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.611]                         if (muffled) 
[17:03:56.611]                           invokeRestart("muffleMessage")
[17:03:56.611]                       }
[17:03:56.611]                       else if (inherits(cond, "warning")) {
[17:03:56.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.611]                         if (muffled) 
[17:03:56.611]                           invokeRestart("muffleWarning")
[17:03:56.611]                       }
[17:03:56.611]                       else if (inherits(cond, "condition")) {
[17:03:56.611]                         if (!is.null(pattern)) {
[17:03:56.611]                           computeRestarts <- base::computeRestarts
[17:03:56.611]                           grepl <- base::grepl
[17:03:56.611]                           restarts <- computeRestarts(cond)
[17:03:56.611]                           for (restart in restarts) {
[17:03:56.611]                             name <- restart$name
[17:03:56.611]                             if (is.null(name)) 
[17:03:56.611]                               next
[17:03:56.611]                             if (!grepl(pattern, name)) 
[17:03:56.611]                               next
[17:03:56.611]                             invokeRestart(restart)
[17:03:56.611]                             muffled <- TRUE
[17:03:56.611]                             break
[17:03:56.611]                           }
[17:03:56.611]                         }
[17:03:56.611]                       }
[17:03:56.611]                       invisible(muffled)
[17:03:56.611]                     }
[17:03:56.611]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.611]                   }
[17:03:56.611]                 }
[17:03:56.611]             }
[17:03:56.611]         }))
[17:03:56.611]     }, error = function(ex) {
[17:03:56.611]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.611]                 ...future.rng), started = ...future.startTime, 
[17:03:56.611]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.611]             version = "1.8"), class = "FutureResult")
[17:03:56.611]     }, finally = {
[17:03:56.611]         if (!identical(...future.workdir, getwd())) 
[17:03:56.611]             setwd(...future.workdir)
[17:03:56.611]         {
[17:03:56.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.611]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.611]             }
[17:03:56.611]             base::options(...future.oldOptions)
[17:03:56.611]             if (.Platform$OS.type == "windows") {
[17:03:56.611]                 old_names <- names(...future.oldEnvVars)
[17:03:56.611]                 envs <- base::Sys.getenv()
[17:03:56.611]                 names <- names(envs)
[17:03:56.611]                 common <- intersect(names, old_names)
[17:03:56.611]                 added <- setdiff(names, old_names)
[17:03:56.611]                 removed <- setdiff(old_names, names)
[17:03:56.611]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.611]                   envs[common]]
[17:03:56.611]                 NAMES <- toupper(changed)
[17:03:56.611]                 args <- list()
[17:03:56.611]                 for (kk in seq_along(NAMES)) {
[17:03:56.611]                   name <- changed[[kk]]
[17:03:56.611]                   NAME <- NAMES[[kk]]
[17:03:56.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.611]                     next
[17:03:56.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.611]                 }
[17:03:56.611]                 NAMES <- toupper(added)
[17:03:56.611]                 for (kk in seq_along(NAMES)) {
[17:03:56.611]                   name <- added[[kk]]
[17:03:56.611]                   NAME <- NAMES[[kk]]
[17:03:56.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.611]                     next
[17:03:56.611]                   args[[name]] <- ""
[17:03:56.611]                 }
[17:03:56.611]                 NAMES <- toupper(removed)
[17:03:56.611]                 for (kk in seq_along(NAMES)) {
[17:03:56.611]                   name <- removed[[kk]]
[17:03:56.611]                   NAME <- NAMES[[kk]]
[17:03:56.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.611]                     next
[17:03:56.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.611]                 }
[17:03:56.611]                 if (length(args) > 0) 
[17:03:56.611]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.611]             }
[17:03:56.611]             else {
[17:03:56.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.611]             }
[17:03:56.611]             {
[17:03:56.611]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.611]                   0L) {
[17:03:56.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.611]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.611]                   base::options(opts)
[17:03:56.611]                 }
[17:03:56.611]                 {
[17:03:56.611]                   {
[17:03:56.611]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.611]                     NULL
[17:03:56.611]                   }
[17:03:56.611]                   options(future.plan = NULL)
[17:03:56.611]                   if (is.na(NA_character_)) 
[17:03:56.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.611]                     .init = FALSE)
[17:03:56.611]                 }
[17:03:56.611]             }
[17:03:56.611]         }
[17:03:56.611]     })
[17:03:56.611]     if (TRUE) {
[17:03:56.611]         base::sink(type = "output", split = FALSE)
[17:03:56.611]         if (TRUE) {
[17:03:56.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.611]         }
[17:03:56.611]         else {
[17:03:56.611]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.611]         }
[17:03:56.611]         base::close(...future.stdout)
[17:03:56.611]         ...future.stdout <- NULL
[17:03:56.611]     }
[17:03:56.611]     ...future.result$conditions <- ...future.conditions
[17:03:56.611]     ...future.result$finished <- base::Sys.time()
[17:03:56.611]     ...future.result
[17:03:56.611] }
[17:03:56.617] MultisessionFuture started
[17:03:56.617] - Launch lazy future ... done
[17:03:56.617] run() for ‘MultisessionFuture’ ... done
[17:03:56.618] getGlobalsAndPackages() ...
[17:03:56.618] Searching for globals...
[17:03:56.619] - globals found: [1] ‘{’
[17:03:56.619] Searching for globals ... DONE
[17:03:56.619] Resolving globals: FALSE
[17:03:56.619] 
[17:03:56.619] 
[17:03:56.619] getGlobalsAndPackages() ... DONE
[17:03:56.620] run() for ‘Future’ ...
[17:03:56.620] - state: ‘created’
[17:03:56.620] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.634] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.635]   - Field: ‘node’
[17:03:56.635]   - Field: ‘label’
[17:03:56.635]   - Field: ‘local’
[17:03:56.635]   - Field: ‘owner’
[17:03:56.635]   - Field: ‘envir’
[17:03:56.635]   - Field: ‘workers’
[17:03:56.635]   - Field: ‘packages’
[17:03:56.635]   - Field: ‘gc’
[17:03:56.635]   - Field: ‘conditions’
[17:03:56.635]   - Field: ‘persistent’
[17:03:56.635]   - Field: ‘expr’
[17:03:56.636]   - Field: ‘uuid’
[17:03:56.636]   - Field: ‘seed’
[17:03:56.636]   - Field: ‘version’
[17:03:56.636]   - Field: ‘result’
[17:03:56.636]   - Field: ‘asynchronous’
[17:03:56.636]   - Field: ‘calls’
[17:03:56.636]   - Field: ‘globals’
[17:03:56.636]   - Field: ‘stdout’
[17:03:56.636]   - Field: ‘earlySignal’
[17:03:56.636]   - Field: ‘lazy’
[17:03:56.636]   - Field: ‘state’
[17:03:56.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.637] - Launch lazy future ...
[17:03:56.637] Packages needed by the future expression (n = 0): <none>
[17:03:56.637] Packages needed by future strategies (n = 0): <none>
[17:03:56.637] {
[17:03:56.637]     {
[17:03:56.637]         {
[17:03:56.637]             ...future.startTime <- base::Sys.time()
[17:03:56.637]             {
[17:03:56.637]                 {
[17:03:56.637]                   {
[17:03:56.637]                     {
[17:03:56.637]                       base::local({
[17:03:56.637]                         has_future <- base::requireNamespace("future", 
[17:03:56.637]                           quietly = TRUE)
[17:03:56.637]                         if (has_future) {
[17:03:56.637]                           ns <- base::getNamespace("future")
[17:03:56.637]                           version <- ns[[".package"]][["version"]]
[17:03:56.637]                           if (is.null(version)) 
[17:03:56.637]                             version <- utils::packageVersion("future")
[17:03:56.637]                         }
[17:03:56.637]                         else {
[17:03:56.637]                           version <- NULL
[17:03:56.637]                         }
[17:03:56.637]                         if (!has_future || version < "1.8.0") {
[17:03:56.637]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.637]                             "", base::R.version$version.string), 
[17:03:56.637]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.637]                               "release", "version")], collapse = " "), 
[17:03:56.637]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.637]                             info)
[17:03:56.637]                           info <- base::paste(info, collapse = "; ")
[17:03:56.637]                           if (!has_future) {
[17:03:56.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.637]                               info)
[17:03:56.637]                           }
[17:03:56.637]                           else {
[17:03:56.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.637]                               info, version)
[17:03:56.637]                           }
[17:03:56.637]                           base::stop(msg)
[17:03:56.637]                         }
[17:03:56.637]                       })
[17:03:56.637]                     }
[17:03:56.637]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.637]                     base::options(mc.cores = 1L)
[17:03:56.637]                   }
[17:03:56.637]                   ...future.strategy.old <- future::plan("list")
[17:03:56.637]                   options(future.plan = NULL)
[17:03:56.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.637]                 }
[17:03:56.637]                 ...future.workdir <- getwd()
[17:03:56.637]             }
[17:03:56.637]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.637]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.637]         }
[17:03:56.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.637]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.637]             base::names(...future.oldOptions))
[17:03:56.637]     }
[17:03:56.637]     if (FALSE) {
[17:03:56.637]     }
[17:03:56.637]     else {
[17:03:56.637]         if (TRUE) {
[17:03:56.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.637]                 open = "w")
[17:03:56.637]         }
[17:03:56.637]         else {
[17:03:56.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.637]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.637]         }
[17:03:56.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.637]             base::sink(type = "output", split = FALSE)
[17:03:56.637]             base::close(...future.stdout)
[17:03:56.637]         }, add = TRUE)
[17:03:56.637]     }
[17:03:56.637]     ...future.frame <- base::sys.nframe()
[17:03:56.637]     ...future.conditions <- base::list()
[17:03:56.637]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.637]     if (FALSE) {
[17:03:56.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.637]     }
[17:03:56.637]     ...future.result <- base::tryCatch({
[17:03:56.637]         base::withCallingHandlers({
[17:03:56.637]             ...future.value <- base::withVisible(base::local({
[17:03:56.637]                 ...future.makeSendCondition <- base::local({
[17:03:56.637]                   sendCondition <- NULL
[17:03:56.637]                   function(frame = 1L) {
[17:03:56.637]                     if (is.function(sendCondition)) 
[17:03:56.637]                       return(sendCondition)
[17:03:56.637]                     ns <- getNamespace("parallel")
[17:03:56.637]                     if (exists("sendData", mode = "function", 
[17:03:56.637]                       envir = ns)) {
[17:03:56.637]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.637]                         envir = ns)
[17:03:56.637]                       envir <- sys.frame(frame)
[17:03:56.637]                       master <- NULL
[17:03:56.637]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.637]                         !identical(envir, emptyenv())) {
[17:03:56.637]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.637]                           inherits = FALSE)) {
[17:03:56.637]                           master <- get("master", mode = "list", 
[17:03:56.637]                             envir = envir, inherits = FALSE)
[17:03:56.637]                           if (inherits(master, c("SOCKnode", 
[17:03:56.637]                             "SOCK0node"))) {
[17:03:56.637]                             sendCondition <<- function(cond) {
[17:03:56.637]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.637]                                 success = TRUE)
[17:03:56.637]                               parallel_sendData(master, data)
[17:03:56.637]                             }
[17:03:56.637]                             return(sendCondition)
[17:03:56.637]                           }
[17:03:56.637]                         }
[17:03:56.637]                         frame <- frame + 1L
[17:03:56.637]                         envir <- sys.frame(frame)
[17:03:56.637]                       }
[17:03:56.637]                     }
[17:03:56.637]                     sendCondition <<- function(cond) NULL
[17:03:56.637]                   }
[17:03:56.637]                 })
[17:03:56.637]                 withCallingHandlers({
[17:03:56.637]                   {
[17:03:56.637]                     2
[17:03:56.637]                   }
[17:03:56.637]                 }, immediateCondition = function(cond) {
[17:03:56.637]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.637]                   sendCondition(cond)
[17:03:56.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.637]                   {
[17:03:56.637]                     inherits <- base::inherits
[17:03:56.637]                     invokeRestart <- base::invokeRestart
[17:03:56.637]                     is.null <- base::is.null
[17:03:56.637]                     muffled <- FALSE
[17:03:56.637]                     if (inherits(cond, "message")) {
[17:03:56.637]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.637]                       if (muffled) 
[17:03:56.637]                         invokeRestart("muffleMessage")
[17:03:56.637]                     }
[17:03:56.637]                     else if (inherits(cond, "warning")) {
[17:03:56.637]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.637]                       if (muffled) 
[17:03:56.637]                         invokeRestart("muffleWarning")
[17:03:56.637]                     }
[17:03:56.637]                     else if (inherits(cond, "condition")) {
[17:03:56.637]                       if (!is.null(pattern)) {
[17:03:56.637]                         computeRestarts <- base::computeRestarts
[17:03:56.637]                         grepl <- base::grepl
[17:03:56.637]                         restarts <- computeRestarts(cond)
[17:03:56.637]                         for (restart in restarts) {
[17:03:56.637]                           name <- restart$name
[17:03:56.637]                           if (is.null(name)) 
[17:03:56.637]                             next
[17:03:56.637]                           if (!grepl(pattern, name)) 
[17:03:56.637]                             next
[17:03:56.637]                           invokeRestart(restart)
[17:03:56.637]                           muffled <- TRUE
[17:03:56.637]                           break
[17:03:56.637]                         }
[17:03:56.637]                       }
[17:03:56.637]                     }
[17:03:56.637]                     invisible(muffled)
[17:03:56.637]                   }
[17:03:56.637]                   muffleCondition(cond)
[17:03:56.637]                 })
[17:03:56.637]             }))
[17:03:56.637]             future::FutureResult(value = ...future.value$value, 
[17:03:56.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.637]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.637]                     ...future.globalenv.names))
[17:03:56.637]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.637]         }, condition = base::local({
[17:03:56.637]             c <- base::c
[17:03:56.637]             inherits <- base::inherits
[17:03:56.637]             invokeRestart <- base::invokeRestart
[17:03:56.637]             length <- base::length
[17:03:56.637]             list <- base::list
[17:03:56.637]             seq.int <- base::seq.int
[17:03:56.637]             signalCondition <- base::signalCondition
[17:03:56.637]             sys.calls <- base::sys.calls
[17:03:56.637]             `[[` <- base::`[[`
[17:03:56.637]             `+` <- base::`+`
[17:03:56.637]             `<<-` <- base::`<<-`
[17:03:56.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.637]                   3L)]
[17:03:56.637]             }
[17:03:56.637]             function(cond) {
[17:03:56.637]                 is_error <- inherits(cond, "error")
[17:03:56.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.637]                   NULL)
[17:03:56.637]                 if (is_error) {
[17:03:56.637]                   sessionInformation <- function() {
[17:03:56.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.637]                       search = base::search(), system = base::Sys.info())
[17:03:56.637]                   }
[17:03:56.637]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.637]                     cond$call), session = sessionInformation(), 
[17:03:56.637]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.637]                   signalCondition(cond)
[17:03:56.637]                 }
[17:03:56.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.637]                 "immediateCondition"))) {
[17:03:56.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.637]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.637]                   if (TRUE && !signal) {
[17:03:56.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.637]                     {
[17:03:56.637]                       inherits <- base::inherits
[17:03:56.637]                       invokeRestart <- base::invokeRestart
[17:03:56.637]                       is.null <- base::is.null
[17:03:56.637]                       muffled <- FALSE
[17:03:56.637]                       if (inherits(cond, "message")) {
[17:03:56.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.637]                         if (muffled) 
[17:03:56.637]                           invokeRestart("muffleMessage")
[17:03:56.637]                       }
[17:03:56.637]                       else if (inherits(cond, "warning")) {
[17:03:56.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.637]                         if (muffled) 
[17:03:56.637]                           invokeRestart("muffleWarning")
[17:03:56.637]                       }
[17:03:56.637]                       else if (inherits(cond, "condition")) {
[17:03:56.637]                         if (!is.null(pattern)) {
[17:03:56.637]                           computeRestarts <- base::computeRestarts
[17:03:56.637]                           grepl <- base::grepl
[17:03:56.637]                           restarts <- computeRestarts(cond)
[17:03:56.637]                           for (restart in restarts) {
[17:03:56.637]                             name <- restart$name
[17:03:56.637]                             if (is.null(name)) 
[17:03:56.637]                               next
[17:03:56.637]                             if (!grepl(pattern, name)) 
[17:03:56.637]                               next
[17:03:56.637]                             invokeRestart(restart)
[17:03:56.637]                             muffled <- TRUE
[17:03:56.637]                             break
[17:03:56.637]                           }
[17:03:56.637]                         }
[17:03:56.637]                       }
[17:03:56.637]                       invisible(muffled)
[17:03:56.637]                     }
[17:03:56.637]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.637]                   }
[17:03:56.637]                 }
[17:03:56.637]                 else {
[17:03:56.637]                   if (TRUE) {
[17:03:56.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.637]                     {
[17:03:56.637]                       inherits <- base::inherits
[17:03:56.637]                       invokeRestart <- base::invokeRestart
[17:03:56.637]                       is.null <- base::is.null
[17:03:56.637]                       muffled <- FALSE
[17:03:56.637]                       if (inherits(cond, "message")) {
[17:03:56.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.637]                         if (muffled) 
[17:03:56.637]                           invokeRestart("muffleMessage")
[17:03:56.637]                       }
[17:03:56.637]                       else if (inherits(cond, "warning")) {
[17:03:56.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.637]                         if (muffled) 
[17:03:56.637]                           invokeRestart("muffleWarning")
[17:03:56.637]                       }
[17:03:56.637]                       else if (inherits(cond, "condition")) {
[17:03:56.637]                         if (!is.null(pattern)) {
[17:03:56.637]                           computeRestarts <- base::computeRestarts
[17:03:56.637]                           grepl <- base::grepl
[17:03:56.637]                           restarts <- computeRestarts(cond)
[17:03:56.637]                           for (restart in restarts) {
[17:03:56.637]                             name <- restart$name
[17:03:56.637]                             if (is.null(name)) 
[17:03:56.637]                               next
[17:03:56.637]                             if (!grepl(pattern, name)) 
[17:03:56.637]                               next
[17:03:56.637]                             invokeRestart(restart)
[17:03:56.637]                             muffled <- TRUE
[17:03:56.637]                             break
[17:03:56.637]                           }
[17:03:56.637]                         }
[17:03:56.637]                       }
[17:03:56.637]                       invisible(muffled)
[17:03:56.637]                     }
[17:03:56.637]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.637]                   }
[17:03:56.637]                 }
[17:03:56.637]             }
[17:03:56.637]         }))
[17:03:56.637]     }, error = function(ex) {
[17:03:56.637]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.637]                 ...future.rng), started = ...future.startTime, 
[17:03:56.637]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.637]             version = "1.8"), class = "FutureResult")
[17:03:56.637]     }, finally = {
[17:03:56.637]         if (!identical(...future.workdir, getwd())) 
[17:03:56.637]             setwd(...future.workdir)
[17:03:56.637]         {
[17:03:56.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.637]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.637]             }
[17:03:56.637]             base::options(...future.oldOptions)
[17:03:56.637]             if (.Platform$OS.type == "windows") {
[17:03:56.637]                 old_names <- names(...future.oldEnvVars)
[17:03:56.637]                 envs <- base::Sys.getenv()
[17:03:56.637]                 names <- names(envs)
[17:03:56.637]                 common <- intersect(names, old_names)
[17:03:56.637]                 added <- setdiff(names, old_names)
[17:03:56.637]                 removed <- setdiff(old_names, names)
[17:03:56.637]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.637]                   envs[common]]
[17:03:56.637]                 NAMES <- toupper(changed)
[17:03:56.637]                 args <- list()
[17:03:56.637]                 for (kk in seq_along(NAMES)) {
[17:03:56.637]                   name <- changed[[kk]]
[17:03:56.637]                   NAME <- NAMES[[kk]]
[17:03:56.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.637]                     next
[17:03:56.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.637]                 }
[17:03:56.637]                 NAMES <- toupper(added)
[17:03:56.637]                 for (kk in seq_along(NAMES)) {
[17:03:56.637]                   name <- added[[kk]]
[17:03:56.637]                   NAME <- NAMES[[kk]]
[17:03:56.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.637]                     next
[17:03:56.637]                   args[[name]] <- ""
[17:03:56.637]                 }
[17:03:56.637]                 NAMES <- toupper(removed)
[17:03:56.637]                 for (kk in seq_along(NAMES)) {
[17:03:56.637]                   name <- removed[[kk]]
[17:03:56.637]                   NAME <- NAMES[[kk]]
[17:03:56.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.637]                     next
[17:03:56.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.637]                 }
[17:03:56.637]                 if (length(args) > 0) 
[17:03:56.637]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.637]             }
[17:03:56.637]             else {
[17:03:56.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.637]             }
[17:03:56.637]             {
[17:03:56.637]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.637]                   0L) {
[17:03:56.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.637]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.637]                   base::options(opts)
[17:03:56.637]                 }
[17:03:56.637]                 {
[17:03:56.637]                   {
[17:03:56.637]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.637]                     NULL
[17:03:56.637]                   }
[17:03:56.637]                   options(future.plan = NULL)
[17:03:56.637]                   if (is.na(NA_character_)) 
[17:03:56.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.637]                     .init = FALSE)
[17:03:56.637]                 }
[17:03:56.637]             }
[17:03:56.637]         }
[17:03:56.637]     })
[17:03:56.637]     if (TRUE) {
[17:03:56.637]         base::sink(type = "output", split = FALSE)
[17:03:56.637]         if (TRUE) {
[17:03:56.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.637]         }
[17:03:56.637]         else {
[17:03:56.637]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.637]         }
[17:03:56.637]         base::close(...future.stdout)
[17:03:56.637]         ...future.stdout <- NULL
[17:03:56.637]     }
[17:03:56.637]     ...future.result$conditions <- ...future.conditions
[17:03:56.637]     ...future.result$finished <- base::Sys.time()
[17:03:56.637]     ...future.result
[17:03:56.637] }
[17:03:56.640] MultisessionFuture started
[17:03:56.641] - Launch lazy future ... done
[17:03:56.641] run() for ‘MultisessionFuture’ ... done
[17:03:56.641] resolve() on list environment ...
[17:03:56.641]  recursive: 0
[17:03:56.642]  length: 3
[17:03:56.642]  elements: ‘a’, ‘b’, ‘c’
[17:03:56.642] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.642] - Validating connection of MultisessionFuture
[17:03:56.643] - received message: FutureResult
[17:03:56.643] - Received FutureResult
[17:03:56.643] - Erased future from FutureRegistry
[17:03:56.643] result() for ClusterFuture ...
[17:03:56.643] - result already collected: FutureResult
[17:03:56.643] result() for ClusterFuture ... done
[17:03:56.643] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.643] Future #1
[17:03:56.643]  length: 2 (resolved future 1)
[17:03:56.644] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.644] - Validating connection of MultisessionFuture
[17:03:56.644] - received message: FutureResult
[17:03:56.644] - Received FutureResult
[17:03:56.644] - Erased future from FutureRegistry
[17:03:56.644] result() for ClusterFuture ...
[17:03:56.644] - result already collected: FutureResult
[17:03:56.644] result() for ClusterFuture ... done
[17:03:56.645] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.645] Future #2
[17:03:56.645]  length: 1 (resolved future 2)
[17:03:56.645]  length: 0 (resolved future 3)
[17:03:56.645] resolve() on list environment ... DONE
[17:03:56.645] getGlobalsAndPackages() ...
[17:03:56.645] Searching for globals...
[17:03:56.646] - globals found: [1] ‘{’
[17:03:56.646] Searching for globals ... DONE
[17:03:56.646] Resolving globals: FALSE
[17:03:56.646] 
[17:03:56.647] 
[17:03:56.647] getGlobalsAndPackages() ... DONE
[17:03:56.647] run() for ‘Future’ ...
[17:03:56.647] - state: ‘created’
[17:03:56.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.661]   - Field: ‘node’
[17:03:56.661]   - Field: ‘label’
[17:03:56.661]   - Field: ‘local’
[17:03:56.661]   - Field: ‘owner’
[17:03:56.661]   - Field: ‘envir’
[17:03:56.661]   - Field: ‘workers’
[17:03:56.661]   - Field: ‘packages’
[17:03:56.662]   - Field: ‘gc’
[17:03:56.662]   - Field: ‘conditions’
[17:03:56.662]   - Field: ‘persistent’
[17:03:56.662]   - Field: ‘expr’
[17:03:56.662]   - Field: ‘uuid’
[17:03:56.662]   - Field: ‘seed’
[17:03:56.662]   - Field: ‘version’
[17:03:56.662]   - Field: ‘result’
[17:03:56.662]   - Field: ‘asynchronous’
[17:03:56.662]   - Field: ‘calls’
[17:03:56.662]   - Field: ‘globals’
[17:03:56.663]   - Field: ‘stdout’
[17:03:56.663]   - Field: ‘earlySignal’
[17:03:56.663]   - Field: ‘lazy’
[17:03:56.663]   - Field: ‘state’
[17:03:56.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.663] - Launch lazy future ...
[17:03:56.663] Packages needed by the future expression (n = 0): <none>
[17:03:56.663] Packages needed by future strategies (n = 0): <none>
[17:03:56.664] {
[17:03:56.664]     {
[17:03:56.664]         {
[17:03:56.664]             ...future.startTime <- base::Sys.time()
[17:03:56.664]             {
[17:03:56.664]                 {
[17:03:56.664]                   {
[17:03:56.664]                     {
[17:03:56.664]                       base::local({
[17:03:56.664]                         has_future <- base::requireNamespace("future", 
[17:03:56.664]                           quietly = TRUE)
[17:03:56.664]                         if (has_future) {
[17:03:56.664]                           ns <- base::getNamespace("future")
[17:03:56.664]                           version <- ns[[".package"]][["version"]]
[17:03:56.664]                           if (is.null(version)) 
[17:03:56.664]                             version <- utils::packageVersion("future")
[17:03:56.664]                         }
[17:03:56.664]                         else {
[17:03:56.664]                           version <- NULL
[17:03:56.664]                         }
[17:03:56.664]                         if (!has_future || version < "1.8.0") {
[17:03:56.664]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.664]                             "", base::R.version$version.string), 
[17:03:56.664]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.664]                               "release", "version")], collapse = " "), 
[17:03:56.664]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.664]                             info)
[17:03:56.664]                           info <- base::paste(info, collapse = "; ")
[17:03:56.664]                           if (!has_future) {
[17:03:56.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.664]                               info)
[17:03:56.664]                           }
[17:03:56.664]                           else {
[17:03:56.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.664]                               info, version)
[17:03:56.664]                           }
[17:03:56.664]                           base::stop(msg)
[17:03:56.664]                         }
[17:03:56.664]                       })
[17:03:56.664]                     }
[17:03:56.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.664]                     base::options(mc.cores = 1L)
[17:03:56.664]                   }
[17:03:56.664]                   ...future.strategy.old <- future::plan("list")
[17:03:56.664]                   options(future.plan = NULL)
[17:03:56.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.664]                 }
[17:03:56.664]                 ...future.workdir <- getwd()
[17:03:56.664]             }
[17:03:56.664]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.664]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.664]         }
[17:03:56.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.664]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.664]             base::names(...future.oldOptions))
[17:03:56.664]     }
[17:03:56.664]     if (FALSE) {
[17:03:56.664]     }
[17:03:56.664]     else {
[17:03:56.664]         if (TRUE) {
[17:03:56.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.664]                 open = "w")
[17:03:56.664]         }
[17:03:56.664]         else {
[17:03:56.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.664]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.664]         }
[17:03:56.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.664]             base::sink(type = "output", split = FALSE)
[17:03:56.664]             base::close(...future.stdout)
[17:03:56.664]         }, add = TRUE)
[17:03:56.664]     }
[17:03:56.664]     ...future.frame <- base::sys.nframe()
[17:03:56.664]     ...future.conditions <- base::list()
[17:03:56.664]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.664]     if (FALSE) {
[17:03:56.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.664]     }
[17:03:56.664]     ...future.result <- base::tryCatch({
[17:03:56.664]         base::withCallingHandlers({
[17:03:56.664]             ...future.value <- base::withVisible(base::local({
[17:03:56.664]                 ...future.makeSendCondition <- base::local({
[17:03:56.664]                   sendCondition <- NULL
[17:03:56.664]                   function(frame = 1L) {
[17:03:56.664]                     if (is.function(sendCondition)) 
[17:03:56.664]                       return(sendCondition)
[17:03:56.664]                     ns <- getNamespace("parallel")
[17:03:56.664]                     if (exists("sendData", mode = "function", 
[17:03:56.664]                       envir = ns)) {
[17:03:56.664]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.664]                         envir = ns)
[17:03:56.664]                       envir <- sys.frame(frame)
[17:03:56.664]                       master <- NULL
[17:03:56.664]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.664]                         !identical(envir, emptyenv())) {
[17:03:56.664]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.664]                           inherits = FALSE)) {
[17:03:56.664]                           master <- get("master", mode = "list", 
[17:03:56.664]                             envir = envir, inherits = FALSE)
[17:03:56.664]                           if (inherits(master, c("SOCKnode", 
[17:03:56.664]                             "SOCK0node"))) {
[17:03:56.664]                             sendCondition <<- function(cond) {
[17:03:56.664]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.664]                                 success = TRUE)
[17:03:56.664]                               parallel_sendData(master, data)
[17:03:56.664]                             }
[17:03:56.664]                             return(sendCondition)
[17:03:56.664]                           }
[17:03:56.664]                         }
[17:03:56.664]                         frame <- frame + 1L
[17:03:56.664]                         envir <- sys.frame(frame)
[17:03:56.664]                       }
[17:03:56.664]                     }
[17:03:56.664]                     sendCondition <<- function(cond) NULL
[17:03:56.664]                   }
[17:03:56.664]                 })
[17:03:56.664]                 withCallingHandlers({
[17:03:56.664]                   {
[17:03:56.664]                     1
[17:03:56.664]                   }
[17:03:56.664]                 }, immediateCondition = function(cond) {
[17:03:56.664]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.664]                   sendCondition(cond)
[17:03:56.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.664]                   {
[17:03:56.664]                     inherits <- base::inherits
[17:03:56.664]                     invokeRestart <- base::invokeRestart
[17:03:56.664]                     is.null <- base::is.null
[17:03:56.664]                     muffled <- FALSE
[17:03:56.664]                     if (inherits(cond, "message")) {
[17:03:56.664]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.664]                       if (muffled) 
[17:03:56.664]                         invokeRestart("muffleMessage")
[17:03:56.664]                     }
[17:03:56.664]                     else if (inherits(cond, "warning")) {
[17:03:56.664]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.664]                       if (muffled) 
[17:03:56.664]                         invokeRestart("muffleWarning")
[17:03:56.664]                     }
[17:03:56.664]                     else if (inherits(cond, "condition")) {
[17:03:56.664]                       if (!is.null(pattern)) {
[17:03:56.664]                         computeRestarts <- base::computeRestarts
[17:03:56.664]                         grepl <- base::grepl
[17:03:56.664]                         restarts <- computeRestarts(cond)
[17:03:56.664]                         for (restart in restarts) {
[17:03:56.664]                           name <- restart$name
[17:03:56.664]                           if (is.null(name)) 
[17:03:56.664]                             next
[17:03:56.664]                           if (!grepl(pattern, name)) 
[17:03:56.664]                             next
[17:03:56.664]                           invokeRestart(restart)
[17:03:56.664]                           muffled <- TRUE
[17:03:56.664]                           break
[17:03:56.664]                         }
[17:03:56.664]                       }
[17:03:56.664]                     }
[17:03:56.664]                     invisible(muffled)
[17:03:56.664]                   }
[17:03:56.664]                   muffleCondition(cond)
[17:03:56.664]                 })
[17:03:56.664]             }))
[17:03:56.664]             future::FutureResult(value = ...future.value$value, 
[17:03:56.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.664]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.664]                     ...future.globalenv.names))
[17:03:56.664]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.664]         }, condition = base::local({
[17:03:56.664]             c <- base::c
[17:03:56.664]             inherits <- base::inherits
[17:03:56.664]             invokeRestart <- base::invokeRestart
[17:03:56.664]             length <- base::length
[17:03:56.664]             list <- base::list
[17:03:56.664]             seq.int <- base::seq.int
[17:03:56.664]             signalCondition <- base::signalCondition
[17:03:56.664]             sys.calls <- base::sys.calls
[17:03:56.664]             `[[` <- base::`[[`
[17:03:56.664]             `+` <- base::`+`
[17:03:56.664]             `<<-` <- base::`<<-`
[17:03:56.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.664]                   3L)]
[17:03:56.664]             }
[17:03:56.664]             function(cond) {
[17:03:56.664]                 is_error <- inherits(cond, "error")
[17:03:56.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.664]                   NULL)
[17:03:56.664]                 if (is_error) {
[17:03:56.664]                   sessionInformation <- function() {
[17:03:56.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.664]                       search = base::search(), system = base::Sys.info())
[17:03:56.664]                   }
[17:03:56.664]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.664]                     cond$call), session = sessionInformation(), 
[17:03:56.664]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.664]                   signalCondition(cond)
[17:03:56.664]                 }
[17:03:56.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.664]                 "immediateCondition"))) {
[17:03:56.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.664]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.664]                   if (TRUE && !signal) {
[17:03:56.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.664]                     {
[17:03:56.664]                       inherits <- base::inherits
[17:03:56.664]                       invokeRestart <- base::invokeRestart
[17:03:56.664]                       is.null <- base::is.null
[17:03:56.664]                       muffled <- FALSE
[17:03:56.664]                       if (inherits(cond, "message")) {
[17:03:56.664]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.664]                         if (muffled) 
[17:03:56.664]                           invokeRestart("muffleMessage")
[17:03:56.664]                       }
[17:03:56.664]                       else if (inherits(cond, "warning")) {
[17:03:56.664]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.664]                         if (muffled) 
[17:03:56.664]                           invokeRestart("muffleWarning")
[17:03:56.664]                       }
[17:03:56.664]                       else if (inherits(cond, "condition")) {
[17:03:56.664]                         if (!is.null(pattern)) {
[17:03:56.664]                           computeRestarts <- base::computeRestarts
[17:03:56.664]                           grepl <- base::grepl
[17:03:56.664]                           restarts <- computeRestarts(cond)
[17:03:56.664]                           for (restart in restarts) {
[17:03:56.664]                             name <- restart$name
[17:03:56.664]                             if (is.null(name)) 
[17:03:56.664]                               next
[17:03:56.664]                             if (!grepl(pattern, name)) 
[17:03:56.664]                               next
[17:03:56.664]                             invokeRestart(restart)
[17:03:56.664]                             muffled <- TRUE
[17:03:56.664]                             break
[17:03:56.664]                           }
[17:03:56.664]                         }
[17:03:56.664]                       }
[17:03:56.664]                       invisible(muffled)
[17:03:56.664]                     }
[17:03:56.664]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.664]                   }
[17:03:56.664]                 }
[17:03:56.664]                 else {
[17:03:56.664]                   if (TRUE) {
[17:03:56.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.664]                     {
[17:03:56.664]                       inherits <- base::inherits
[17:03:56.664]                       invokeRestart <- base::invokeRestart
[17:03:56.664]                       is.null <- base::is.null
[17:03:56.664]                       muffled <- FALSE
[17:03:56.664]                       if (inherits(cond, "message")) {
[17:03:56.664]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.664]                         if (muffled) 
[17:03:56.664]                           invokeRestart("muffleMessage")
[17:03:56.664]                       }
[17:03:56.664]                       else if (inherits(cond, "warning")) {
[17:03:56.664]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.664]                         if (muffled) 
[17:03:56.664]                           invokeRestart("muffleWarning")
[17:03:56.664]                       }
[17:03:56.664]                       else if (inherits(cond, "condition")) {
[17:03:56.664]                         if (!is.null(pattern)) {
[17:03:56.664]                           computeRestarts <- base::computeRestarts
[17:03:56.664]                           grepl <- base::grepl
[17:03:56.664]                           restarts <- computeRestarts(cond)
[17:03:56.664]                           for (restart in restarts) {
[17:03:56.664]                             name <- restart$name
[17:03:56.664]                             if (is.null(name)) 
[17:03:56.664]                               next
[17:03:56.664]                             if (!grepl(pattern, name)) 
[17:03:56.664]                               next
[17:03:56.664]                             invokeRestart(restart)
[17:03:56.664]                             muffled <- TRUE
[17:03:56.664]                             break
[17:03:56.664]                           }
[17:03:56.664]                         }
[17:03:56.664]                       }
[17:03:56.664]                       invisible(muffled)
[17:03:56.664]                     }
[17:03:56.664]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.664]                   }
[17:03:56.664]                 }
[17:03:56.664]             }
[17:03:56.664]         }))
[17:03:56.664]     }, error = function(ex) {
[17:03:56.664]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.664]                 ...future.rng), started = ...future.startTime, 
[17:03:56.664]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.664]             version = "1.8"), class = "FutureResult")
[17:03:56.664]     }, finally = {
[17:03:56.664]         if (!identical(...future.workdir, getwd())) 
[17:03:56.664]             setwd(...future.workdir)
[17:03:56.664]         {
[17:03:56.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.664]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.664]             }
[17:03:56.664]             base::options(...future.oldOptions)
[17:03:56.664]             if (.Platform$OS.type == "windows") {
[17:03:56.664]                 old_names <- names(...future.oldEnvVars)
[17:03:56.664]                 envs <- base::Sys.getenv()
[17:03:56.664]                 names <- names(envs)
[17:03:56.664]                 common <- intersect(names, old_names)
[17:03:56.664]                 added <- setdiff(names, old_names)
[17:03:56.664]                 removed <- setdiff(old_names, names)
[17:03:56.664]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.664]                   envs[common]]
[17:03:56.664]                 NAMES <- toupper(changed)
[17:03:56.664]                 args <- list()
[17:03:56.664]                 for (kk in seq_along(NAMES)) {
[17:03:56.664]                   name <- changed[[kk]]
[17:03:56.664]                   NAME <- NAMES[[kk]]
[17:03:56.664]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.664]                     next
[17:03:56.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.664]                 }
[17:03:56.664]                 NAMES <- toupper(added)
[17:03:56.664]                 for (kk in seq_along(NAMES)) {
[17:03:56.664]                   name <- added[[kk]]
[17:03:56.664]                   NAME <- NAMES[[kk]]
[17:03:56.664]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.664]                     next
[17:03:56.664]                   args[[name]] <- ""
[17:03:56.664]                 }
[17:03:56.664]                 NAMES <- toupper(removed)
[17:03:56.664]                 for (kk in seq_along(NAMES)) {
[17:03:56.664]                   name <- removed[[kk]]
[17:03:56.664]                   NAME <- NAMES[[kk]]
[17:03:56.664]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.664]                     next
[17:03:56.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.664]                 }
[17:03:56.664]                 if (length(args) > 0) 
[17:03:56.664]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.664]             }
[17:03:56.664]             else {
[17:03:56.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.664]             }
[17:03:56.664]             {
[17:03:56.664]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.664]                   0L) {
[17:03:56.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.664]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.664]                   base::options(opts)
[17:03:56.664]                 }
[17:03:56.664]                 {
[17:03:56.664]                   {
[17:03:56.664]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.664]                     NULL
[17:03:56.664]                   }
[17:03:56.664]                   options(future.plan = NULL)
[17:03:56.664]                   if (is.na(NA_character_)) 
[17:03:56.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.664]                     .init = FALSE)
[17:03:56.664]                 }
[17:03:56.664]             }
[17:03:56.664]         }
[17:03:56.664]     })
[17:03:56.664]     if (TRUE) {
[17:03:56.664]         base::sink(type = "output", split = FALSE)
[17:03:56.664]         if (TRUE) {
[17:03:56.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.664]         }
[17:03:56.664]         else {
[17:03:56.664]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.664]         }
[17:03:56.664]         base::close(...future.stdout)
[17:03:56.664]         ...future.stdout <- NULL
[17:03:56.664]     }
[17:03:56.664]     ...future.result$conditions <- ...future.conditions
[17:03:56.664]     ...future.result$finished <- base::Sys.time()
[17:03:56.664]     ...future.result
[17:03:56.664] }
[17:03:56.667] MultisessionFuture started
[17:03:56.667] - Launch lazy future ... done
[17:03:56.667] run() for ‘MultisessionFuture’ ... done
[17:03:56.668] getGlobalsAndPackages() ...
[17:03:56.668] Searching for globals...
[17:03:56.669] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:03:56.669] Searching for globals ... DONE
[17:03:56.669] Resolving globals: FALSE
[17:03:56.669] 
[17:03:56.669] 
[17:03:56.669] getGlobalsAndPackages() ... DONE
[17:03:56.670] run() for ‘Future’ ...
[17:03:56.670] - state: ‘created’
[17:03:56.670] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.684]   - Field: ‘node’
[17:03:56.684]   - Field: ‘label’
[17:03:56.684]   - Field: ‘local’
[17:03:56.684]   - Field: ‘owner’
[17:03:56.684]   - Field: ‘envir’
[17:03:56.684]   - Field: ‘workers’
[17:03:56.684]   - Field: ‘packages’
[17:03:56.684]   - Field: ‘gc’
[17:03:56.684]   - Field: ‘conditions’
[17:03:56.685]   - Field: ‘persistent’
[17:03:56.685]   - Field: ‘expr’
[17:03:56.685]   - Field: ‘uuid’
[17:03:56.685]   - Field: ‘seed’
[17:03:56.685]   - Field: ‘version’
[17:03:56.685]   - Field: ‘result’
[17:03:56.685]   - Field: ‘asynchronous’
[17:03:56.685]   - Field: ‘calls’
[17:03:56.685]   - Field: ‘globals’
[17:03:56.685]   - Field: ‘stdout’
[17:03:56.685]   - Field: ‘earlySignal’
[17:03:56.685]   - Field: ‘lazy’
[17:03:56.686]   - Field: ‘state’
[17:03:56.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.686] - Launch lazy future ...
[17:03:56.686] Packages needed by the future expression (n = 0): <none>
[17:03:56.686] Packages needed by future strategies (n = 0): <none>
[17:03:56.687] {
[17:03:56.687]     {
[17:03:56.687]         {
[17:03:56.687]             ...future.startTime <- base::Sys.time()
[17:03:56.687]             {
[17:03:56.687]                 {
[17:03:56.687]                   {
[17:03:56.687]                     {
[17:03:56.687]                       base::local({
[17:03:56.687]                         has_future <- base::requireNamespace("future", 
[17:03:56.687]                           quietly = TRUE)
[17:03:56.687]                         if (has_future) {
[17:03:56.687]                           ns <- base::getNamespace("future")
[17:03:56.687]                           version <- ns[[".package"]][["version"]]
[17:03:56.687]                           if (is.null(version)) 
[17:03:56.687]                             version <- utils::packageVersion("future")
[17:03:56.687]                         }
[17:03:56.687]                         else {
[17:03:56.687]                           version <- NULL
[17:03:56.687]                         }
[17:03:56.687]                         if (!has_future || version < "1.8.0") {
[17:03:56.687]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.687]                             "", base::R.version$version.string), 
[17:03:56.687]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.687]                               "release", "version")], collapse = " "), 
[17:03:56.687]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.687]                             info)
[17:03:56.687]                           info <- base::paste(info, collapse = "; ")
[17:03:56.687]                           if (!has_future) {
[17:03:56.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.687]                               info)
[17:03:56.687]                           }
[17:03:56.687]                           else {
[17:03:56.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.687]                               info, version)
[17:03:56.687]                           }
[17:03:56.687]                           base::stop(msg)
[17:03:56.687]                         }
[17:03:56.687]                       })
[17:03:56.687]                     }
[17:03:56.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.687]                     base::options(mc.cores = 1L)
[17:03:56.687]                   }
[17:03:56.687]                   ...future.strategy.old <- future::plan("list")
[17:03:56.687]                   options(future.plan = NULL)
[17:03:56.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.687]                 }
[17:03:56.687]                 ...future.workdir <- getwd()
[17:03:56.687]             }
[17:03:56.687]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.687]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.687]         }
[17:03:56.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.687]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.687]             base::names(...future.oldOptions))
[17:03:56.687]     }
[17:03:56.687]     if (FALSE) {
[17:03:56.687]     }
[17:03:56.687]     else {
[17:03:56.687]         if (TRUE) {
[17:03:56.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.687]                 open = "w")
[17:03:56.687]         }
[17:03:56.687]         else {
[17:03:56.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.687]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.687]         }
[17:03:56.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.687]             base::sink(type = "output", split = FALSE)
[17:03:56.687]             base::close(...future.stdout)
[17:03:56.687]         }, add = TRUE)
[17:03:56.687]     }
[17:03:56.687]     ...future.frame <- base::sys.nframe()
[17:03:56.687]     ...future.conditions <- base::list()
[17:03:56.687]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.687]     if (FALSE) {
[17:03:56.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.687]     }
[17:03:56.687]     ...future.result <- base::tryCatch({
[17:03:56.687]         base::withCallingHandlers({
[17:03:56.687]             ...future.value <- base::withVisible(base::local({
[17:03:56.687]                 ...future.makeSendCondition <- base::local({
[17:03:56.687]                   sendCondition <- NULL
[17:03:56.687]                   function(frame = 1L) {
[17:03:56.687]                     if (is.function(sendCondition)) 
[17:03:56.687]                       return(sendCondition)
[17:03:56.687]                     ns <- getNamespace("parallel")
[17:03:56.687]                     if (exists("sendData", mode = "function", 
[17:03:56.687]                       envir = ns)) {
[17:03:56.687]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.687]                         envir = ns)
[17:03:56.687]                       envir <- sys.frame(frame)
[17:03:56.687]                       master <- NULL
[17:03:56.687]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.687]                         !identical(envir, emptyenv())) {
[17:03:56.687]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.687]                           inherits = FALSE)) {
[17:03:56.687]                           master <- get("master", mode = "list", 
[17:03:56.687]                             envir = envir, inherits = FALSE)
[17:03:56.687]                           if (inherits(master, c("SOCKnode", 
[17:03:56.687]                             "SOCK0node"))) {
[17:03:56.687]                             sendCondition <<- function(cond) {
[17:03:56.687]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.687]                                 success = TRUE)
[17:03:56.687]                               parallel_sendData(master, data)
[17:03:56.687]                             }
[17:03:56.687]                             return(sendCondition)
[17:03:56.687]                           }
[17:03:56.687]                         }
[17:03:56.687]                         frame <- frame + 1L
[17:03:56.687]                         envir <- sys.frame(frame)
[17:03:56.687]                       }
[17:03:56.687]                     }
[17:03:56.687]                     sendCondition <<- function(cond) NULL
[17:03:56.687]                   }
[17:03:56.687]                 })
[17:03:56.687]                 withCallingHandlers({
[17:03:56.687]                   {
[17:03:56.687]                     Sys.sleep(0.5)
[17:03:56.687]                     2
[17:03:56.687]                   }
[17:03:56.687]                 }, immediateCondition = function(cond) {
[17:03:56.687]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.687]                   sendCondition(cond)
[17:03:56.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.687]                   {
[17:03:56.687]                     inherits <- base::inherits
[17:03:56.687]                     invokeRestart <- base::invokeRestart
[17:03:56.687]                     is.null <- base::is.null
[17:03:56.687]                     muffled <- FALSE
[17:03:56.687]                     if (inherits(cond, "message")) {
[17:03:56.687]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.687]                       if (muffled) 
[17:03:56.687]                         invokeRestart("muffleMessage")
[17:03:56.687]                     }
[17:03:56.687]                     else if (inherits(cond, "warning")) {
[17:03:56.687]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.687]                       if (muffled) 
[17:03:56.687]                         invokeRestart("muffleWarning")
[17:03:56.687]                     }
[17:03:56.687]                     else if (inherits(cond, "condition")) {
[17:03:56.687]                       if (!is.null(pattern)) {
[17:03:56.687]                         computeRestarts <- base::computeRestarts
[17:03:56.687]                         grepl <- base::grepl
[17:03:56.687]                         restarts <- computeRestarts(cond)
[17:03:56.687]                         for (restart in restarts) {
[17:03:56.687]                           name <- restart$name
[17:03:56.687]                           if (is.null(name)) 
[17:03:56.687]                             next
[17:03:56.687]                           if (!grepl(pattern, name)) 
[17:03:56.687]                             next
[17:03:56.687]                           invokeRestart(restart)
[17:03:56.687]                           muffled <- TRUE
[17:03:56.687]                           break
[17:03:56.687]                         }
[17:03:56.687]                       }
[17:03:56.687]                     }
[17:03:56.687]                     invisible(muffled)
[17:03:56.687]                   }
[17:03:56.687]                   muffleCondition(cond)
[17:03:56.687]                 })
[17:03:56.687]             }))
[17:03:56.687]             future::FutureResult(value = ...future.value$value, 
[17:03:56.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.687]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.687]                     ...future.globalenv.names))
[17:03:56.687]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.687]         }, condition = base::local({
[17:03:56.687]             c <- base::c
[17:03:56.687]             inherits <- base::inherits
[17:03:56.687]             invokeRestart <- base::invokeRestart
[17:03:56.687]             length <- base::length
[17:03:56.687]             list <- base::list
[17:03:56.687]             seq.int <- base::seq.int
[17:03:56.687]             signalCondition <- base::signalCondition
[17:03:56.687]             sys.calls <- base::sys.calls
[17:03:56.687]             `[[` <- base::`[[`
[17:03:56.687]             `+` <- base::`+`
[17:03:56.687]             `<<-` <- base::`<<-`
[17:03:56.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.687]                   3L)]
[17:03:56.687]             }
[17:03:56.687]             function(cond) {
[17:03:56.687]                 is_error <- inherits(cond, "error")
[17:03:56.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.687]                   NULL)
[17:03:56.687]                 if (is_error) {
[17:03:56.687]                   sessionInformation <- function() {
[17:03:56.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.687]                       search = base::search(), system = base::Sys.info())
[17:03:56.687]                   }
[17:03:56.687]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.687]                     cond$call), session = sessionInformation(), 
[17:03:56.687]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.687]                   signalCondition(cond)
[17:03:56.687]                 }
[17:03:56.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.687]                 "immediateCondition"))) {
[17:03:56.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.687]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.687]                   if (TRUE && !signal) {
[17:03:56.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.687]                     {
[17:03:56.687]                       inherits <- base::inherits
[17:03:56.687]                       invokeRestart <- base::invokeRestart
[17:03:56.687]                       is.null <- base::is.null
[17:03:56.687]                       muffled <- FALSE
[17:03:56.687]                       if (inherits(cond, "message")) {
[17:03:56.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.687]                         if (muffled) 
[17:03:56.687]                           invokeRestart("muffleMessage")
[17:03:56.687]                       }
[17:03:56.687]                       else if (inherits(cond, "warning")) {
[17:03:56.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.687]                         if (muffled) 
[17:03:56.687]                           invokeRestart("muffleWarning")
[17:03:56.687]                       }
[17:03:56.687]                       else if (inherits(cond, "condition")) {
[17:03:56.687]                         if (!is.null(pattern)) {
[17:03:56.687]                           computeRestarts <- base::computeRestarts
[17:03:56.687]                           grepl <- base::grepl
[17:03:56.687]                           restarts <- computeRestarts(cond)
[17:03:56.687]                           for (restart in restarts) {
[17:03:56.687]                             name <- restart$name
[17:03:56.687]                             if (is.null(name)) 
[17:03:56.687]                               next
[17:03:56.687]                             if (!grepl(pattern, name)) 
[17:03:56.687]                               next
[17:03:56.687]                             invokeRestart(restart)
[17:03:56.687]                             muffled <- TRUE
[17:03:56.687]                             break
[17:03:56.687]                           }
[17:03:56.687]                         }
[17:03:56.687]                       }
[17:03:56.687]                       invisible(muffled)
[17:03:56.687]                     }
[17:03:56.687]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.687]                   }
[17:03:56.687]                 }
[17:03:56.687]                 else {
[17:03:56.687]                   if (TRUE) {
[17:03:56.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.687]                     {
[17:03:56.687]                       inherits <- base::inherits
[17:03:56.687]                       invokeRestart <- base::invokeRestart
[17:03:56.687]                       is.null <- base::is.null
[17:03:56.687]                       muffled <- FALSE
[17:03:56.687]                       if (inherits(cond, "message")) {
[17:03:56.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.687]                         if (muffled) 
[17:03:56.687]                           invokeRestart("muffleMessage")
[17:03:56.687]                       }
[17:03:56.687]                       else if (inherits(cond, "warning")) {
[17:03:56.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.687]                         if (muffled) 
[17:03:56.687]                           invokeRestart("muffleWarning")
[17:03:56.687]                       }
[17:03:56.687]                       else if (inherits(cond, "condition")) {
[17:03:56.687]                         if (!is.null(pattern)) {
[17:03:56.687]                           computeRestarts <- base::computeRestarts
[17:03:56.687]                           grepl <- base::grepl
[17:03:56.687]                           restarts <- computeRestarts(cond)
[17:03:56.687]                           for (restart in restarts) {
[17:03:56.687]                             name <- restart$name
[17:03:56.687]                             if (is.null(name)) 
[17:03:56.687]                               next
[17:03:56.687]                             if (!grepl(pattern, name)) 
[17:03:56.687]                               next
[17:03:56.687]                             invokeRestart(restart)
[17:03:56.687]                             muffled <- TRUE
[17:03:56.687]                             break
[17:03:56.687]                           }
[17:03:56.687]                         }
[17:03:56.687]                       }
[17:03:56.687]                       invisible(muffled)
[17:03:56.687]                     }
[17:03:56.687]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.687]                   }
[17:03:56.687]                 }
[17:03:56.687]             }
[17:03:56.687]         }))
[17:03:56.687]     }, error = function(ex) {
[17:03:56.687]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.687]                 ...future.rng), started = ...future.startTime, 
[17:03:56.687]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.687]             version = "1.8"), class = "FutureResult")
[17:03:56.687]     }, finally = {
[17:03:56.687]         if (!identical(...future.workdir, getwd())) 
[17:03:56.687]             setwd(...future.workdir)
[17:03:56.687]         {
[17:03:56.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.687]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.687]             }
[17:03:56.687]             base::options(...future.oldOptions)
[17:03:56.687]             if (.Platform$OS.type == "windows") {
[17:03:56.687]                 old_names <- names(...future.oldEnvVars)
[17:03:56.687]                 envs <- base::Sys.getenv()
[17:03:56.687]                 names <- names(envs)
[17:03:56.687]                 common <- intersect(names, old_names)
[17:03:56.687]                 added <- setdiff(names, old_names)
[17:03:56.687]                 removed <- setdiff(old_names, names)
[17:03:56.687]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.687]                   envs[common]]
[17:03:56.687]                 NAMES <- toupper(changed)
[17:03:56.687]                 args <- list()
[17:03:56.687]                 for (kk in seq_along(NAMES)) {
[17:03:56.687]                   name <- changed[[kk]]
[17:03:56.687]                   NAME <- NAMES[[kk]]
[17:03:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.687]                     next
[17:03:56.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.687]                 }
[17:03:56.687]                 NAMES <- toupper(added)
[17:03:56.687]                 for (kk in seq_along(NAMES)) {
[17:03:56.687]                   name <- added[[kk]]
[17:03:56.687]                   NAME <- NAMES[[kk]]
[17:03:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.687]                     next
[17:03:56.687]                   args[[name]] <- ""
[17:03:56.687]                 }
[17:03:56.687]                 NAMES <- toupper(removed)
[17:03:56.687]                 for (kk in seq_along(NAMES)) {
[17:03:56.687]                   name <- removed[[kk]]
[17:03:56.687]                   NAME <- NAMES[[kk]]
[17:03:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.687]                     next
[17:03:56.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.687]                 }
[17:03:56.687]                 if (length(args) > 0) 
[17:03:56.687]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.687]             }
[17:03:56.687]             else {
[17:03:56.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.687]             }
[17:03:56.687]             {
[17:03:56.687]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.687]                   0L) {
[17:03:56.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.687]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.687]                   base::options(opts)
[17:03:56.687]                 }
[17:03:56.687]                 {
[17:03:56.687]                   {
[17:03:56.687]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.687]                     NULL
[17:03:56.687]                   }
[17:03:56.687]                   options(future.plan = NULL)
[17:03:56.687]                   if (is.na(NA_character_)) 
[17:03:56.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.687]                     .init = FALSE)
[17:03:56.687]                 }
[17:03:56.687]             }
[17:03:56.687]         }
[17:03:56.687]     })
[17:03:56.687]     if (TRUE) {
[17:03:56.687]         base::sink(type = "output", split = FALSE)
[17:03:56.687]         if (TRUE) {
[17:03:56.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.687]         }
[17:03:56.687]         else {
[17:03:56.687]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.687]         }
[17:03:56.687]         base::close(...future.stdout)
[17:03:56.687]         ...future.stdout <- NULL
[17:03:56.687]     }
[17:03:56.687]     ...future.result$conditions <- ...future.conditions
[17:03:56.687]     ...future.result$finished <- base::Sys.time()
[17:03:56.687]     ...future.result
[17:03:56.687] }
[17:03:56.690] MultisessionFuture started
[17:03:56.690] - Launch lazy future ... done
[17:03:56.690] run() for ‘MultisessionFuture’ ... done
[17:03:56.690] getGlobalsAndPackages() ...
[17:03:56.690] Searching for globals...
[17:03:56.691] - globals found: [1] ‘{’
[17:03:56.691] Searching for globals ... DONE
[17:03:56.691] Resolving globals: FALSE
[17:03:56.691] 
[17:03:56.691] 
[17:03:56.692] getGlobalsAndPackages() ... DONE
[17:03:56.692] run() for ‘Future’ ...
[17:03:56.692] - state: ‘created’
[17:03:56.692] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:03:56.706] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:03:56.706] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:03:56.706]   - Field: ‘node’
[17:03:56.706]   - Field: ‘label’
[17:03:56.706]   - Field: ‘local’
[17:03:56.706]   - Field: ‘owner’
[17:03:56.706]   - Field: ‘envir’
[17:03:56.706]   - Field: ‘workers’
[17:03:56.707]   - Field: ‘packages’
[17:03:56.707]   - Field: ‘gc’
[17:03:56.707]   - Field: ‘conditions’
[17:03:56.707]   - Field: ‘persistent’
[17:03:56.707]   - Field: ‘expr’
[17:03:56.707]   - Field: ‘uuid’
[17:03:56.707]   - Field: ‘seed’
[17:03:56.707]   - Field: ‘version’
[17:03:56.707]   - Field: ‘result’
[17:03:56.707]   - Field: ‘asynchronous’
[17:03:56.707]   - Field: ‘calls’
[17:03:56.708]   - Field: ‘globals’
[17:03:56.708]   - Field: ‘stdout’
[17:03:56.708]   - Field: ‘earlySignal’
[17:03:56.708]   - Field: ‘lazy’
[17:03:56.708]   - Field: ‘state’
[17:03:56.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:03:56.708] - Launch lazy future ...
[17:03:56.708] Packages needed by the future expression (n = 0): <none>
[17:03:56.708] Packages needed by future strategies (n = 0): <none>
[17:03:56.709] {
[17:03:56.709]     {
[17:03:56.709]         {
[17:03:56.709]             ...future.startTime <- base::Sys.time()
[17:03:56.709]             {
[17:03:56.709]                 {
[17:03:56.709]                   {
[17:03:56.709]                     {
[17:03:56.709]                       base::local({
[17:03:56.709]                         has_future <- base::requireNamespace("future", 
[17:03:56.709]                           quietly = TRUE)
[17:03:56.709]                         if (has_future) {
[17:03:56.709]                           ns <- base::getNamespace("future")
[17:03:56.709]                           version <- ns[[".package"]][["version"]]
[17:03:56.709]                           if (is.null(version)) 
[17:03:56.709]                             version <- utils::packageVersion("future")
[17:03:56.709]                         }
[17:03:56.709]                         else {
[17:03:56.709]                           version <- NULL
[17:03:56.709]                         }
[17:03:56.709]                         if (!has_future || version < "1.8.0") {
[17:03:56.709]                           info <- base::c(r_version = base::gsub("R version ", 
[17:03:56.709]                             "", base::R.version$version.string), 
[17:03:56.709]                             platform = base::sprintf("%s (%s-bit)", 
[17:03:56.709]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:03:56.709]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:03:56.709]                               "release", "version")], collapse = " "), 
[17:03:56.709]                             hostname = base::Sys.info()[["nodename"]])
[17:03:56.709]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:03:56.709]                             info)
[17:03:56.709]                           info <- base::paste(info, collapse = "; ")
[17:03:56.709]                           if (!has_future) {
[17:03:56.709]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:03:56.709]                               info)
[17:03:56.709]                           }
[17:03:56.709]                           else {
[17:03:56.709]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:03:56.709]                               info, version)
[17:03:56.709]                           }
[17:03:56.709]                           base::stop(msg)
[17:03:56.709]                         }
[17:03:56.709]                       })
[17:03:56.709]                     }
[17:03:56.709]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:03:56.709]                     base::options(mc.cores = 1L)
[17:03:56.709]                   }
[17:03:56.709]                   ...future.strategy.old <- future::plan("list")
[17:03:56.709]                   options(future.plan = NULL)
[17:03:56.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:03:56.709]                 }
[17:03:56.709]                 ...future.workdir <- getwd()
[17:03:56.709]             }
[17:03:56.709]             ...future.oldOptions <- base::as.list(base::.Options)
[17:03:56.709]             ...future.oldEnvVars <- base::Sys.getenv()
[17:03:56.709]         }
[17:03:56.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:03:56.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:03:56.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:03:56.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:03:56.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:03:56.709]             future.stdout.windows.reencode = NULL, width = 80L)
[17:03:56.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:03:56.709]             base::names(...future.oldOptions))
[17:03:56.709]     }
[17:03:56.709]     if (FALSE) {
[17:03:56.709]     }
[17:03:56.709]     else {
[17:03:56.709]         if (TRUE) {
[17:03:56.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:03:56.709]                 open = "w")
[17:03:56.709]         }
[17:03:56.709]         else {
[17:03:56.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:03:56.709]                 windows = "NUL", "/dev/null"), open = "w")
[17:03:56.709]         }
[17:03:56.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:03:56.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:03:56.709]             base::sink(type = "output", split = FALSE)
[17:03:56.709]             base::close(...future.stdout)
[17:03:56.709]         }, add = TRUE)
[17:03:56.709]     }
[17:03:56.709]     ...future.frame <- base::sys.nframe()
[17:03:56.709]     ...future.conditions <- base::list()
[17:03:56.709]     ...future.rng <- base::globalenv()$.Random.seed
[17:03:56.709]     if (FALSE) {
[17:03:56.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:03:56.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:03:56.709]     }
[17:03:56.709]     ...future.result <- base::tryCatch({
[17:03:56.709]         base::withCallingHandlers({
[17:03:56.709]             ...future.value <- base::withVisible(base::local({
[17:03:56.709]                 ...future.makeSendCondition <- base::local({
[17:03:56.709]                   sendCondition <- NULL
[17:03:56.709]                   function(frame = 1L) {
[17:03:56.709]                     if (is.function(sendCondition)) 
[17:03:56.709]                       return(sendCondition)
[17:03:56.709]                     ns <- getNamespace("parallel")
[17:03:56.709]                     if (exists("sendData", mode = "function", 
[17:03:56.709]                       envir = ns)) {
[17:03:56.709]                       parallel_sendData <- get("sendData", mode = "function", 
[17:03:56.709]                         envir = ns)
[17:03:56.709]                       envir <- sys.frame(frame)
[17:03:56.709]                       master <- NULL
[17:03:56.709]                       while (!identical(envir, .GlobalEnv) && 
[17:03:56.709]                         !identical(envir, emptyenv())) {
[17:03:56.709]                         if (exists("master", mode = "list", envir = envir, 
[17:03:56.709]                           inherits = FALSE)) {
[17:03:56.709]                           master <- get("master", mode = "list", 
[17:03:56.709]                             envir = envir, inherits = FALSE)
[17:03:56.709]                           if (inherits(master, c("SOCKnode", 
[17:03:56.709]                             "SOCK0node"))) {
[17:03:56.709]                             sendCondition <<- function(cond) {
[17:03:56.709]                               data <- list(type = "VALUE", value = cond, 
[17:03:56.709]                                 success = TRUE)
[17:03:56.709]                               parallel_sendData(master, data)
[17:03:56.709]                             }
[17:03:56.709]                             return(sendCondition)
[17:03:56.709]                           }
[17:03:56.709]                         }
[17:03:56.709]                         frame <- frame + 1L
[17:03:56.709]                         envir <- sys.frame(frame)
[17:03:56.709]                       }
[17:03:56.709]                     }
[17:03:56.709]                     sendCondition <<- function(cond) NULL
[17:03:56.709]                   }
[17:03:56.709]                 })
[17:03:56.709]                 withCallingHandlers({
[17:03:56.709]                   {
[17:03:56.709]                     3
[17:03:56.709]                   }
[17:03:56.709]                 }, immediateCondition = function(cond) {
[17:03:56.709]                   sendCondition <- ...future.makeSendCondition()
[17:03:56.709]                   sendCondition(cond)
[17:03:56.709]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.709]                   {
[17:03:56.709]                     inherits <- base::inherits
[17:03:56.709]                     invokeRestart <- base::invokeRestart
[17:03:56.709]                     is.null <- base::is.null
[17:03:56.709]                     muffled <- FALSE
[17:03:56.709]                     if (inherits(cond, "message")) {
[17:03:56.709]                       muffled <- grepl(pattern, "muffleMessage")
[17:03:56.709]                       if (muffled) 
[17:03:56.709]                         invokeRestart("muffleMessage")
[17:03:56.709]                     }
[17:03:56.709]                     else if (inherits(cond, "warning")) {
[17:03:56.709]                       muffled <- grepl(pattern, "muffleWarning")
[17:03:56.709]                       if (muffled) 
[17:03:56.709]                         invokeRestart("muffleWarning")
[17:03:56.709]                     }
[17:03:56.709]                     else if (inherits(cond, "condition")) {
[17:03:56.709]                       if (!is.null(pattern)) {
[17:03:56.709]                         computeRestarts <- base::computeRestarts
[17:03:56.709]                         grepl <- base::grepl
[17:03:56.709]                         restarts <- computeRestarts(cond)
[17:03:56.709]                         for (restart in restarts) {
[17:03:56.709]                           name <- restart$name
[17:03:56.709]                           if (is.null(name)) 
[17:03:56.709]                             next
[17:03:56.709]                           if (!grepl(pattern, name)) 
[17:03:56.709]                             next
[17:03:56.709]                           invokeRestart(restart)
[17:03:56.709]                           muffled <- TRUE
[17:03:56.709]                           break
[17:03:56.709]                         }
[17:03:56.709]                       }
[17:03:56.709]                     }
[17:03:56.709]                     invisible(muffled)
[17:03:56.709]                   }
[17:03:56.709]                   muffleCondition(cond)
[17:03:56.709]                 })
[17:03:56.709]             }))
[17:03:56.709]             future::FutureResult(value = ...future.value$value, 
[17:03:56.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.709]                   ...future.rng), globalenv = if (FALSE) 
[17:03:56.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:03:56.709]                     ...future.globalenv.names))
[17:03:56.709]                 else NULL, started = ...future.startTime, version = "1.8")
[17:03:56.709]         }, condition = base::local({
[17:03:56.709]             c <- base::c
[17:03:56.709]             inherits <- base::inherits
[17:03:56.709]             invokeRestart <- base::invokeRestart
[17:03:56.709]             length <- base::length
[17:03:56.709]             list <- base::list
[17:03:56.709]             seq.int <- base::seq.int
[17:03:56.709]             signalCondition <- base::signalCondition
[17:03:56.709]             sys.calls <- base::sys.calls
[17:03:56.709]             `[[` <- base::`[[`
[17:03:56.709]             `+` <- base::`+`
[17:03:56.709]             `<<-` <- base::`<<-`
[17:03:56.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:03:56.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:03:56.709]                   3L)]
[17:03:56.709]             }
[17:03:56.709]             function(cond) {
[17:03:56.709]                 is_error <- inherits(cond, "error")
[17:03:56.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:03:56.709]                   NULL)
[17:03:56.709]                 if (is_error) {
[17:03:56.709]                   sessionInformation <- function() {
[17:03:56.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:03:56.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:03:56.709]                       search = base::search(), system = base::Sys.info())
[17:03:56.709]                   }
[17:03:56.709]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:03:56.709]                     cond$call), session = sessionInformation(), 
[17:03:56.709]                     timestamp = base::Sys.time(), signaled = 0L)
[17:03:56.709]                   signalCondition(cond)
[17:03:56.709]                 }
[17:03:56.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:03:56.709]                 "immediateCondition"))) {
[17:03:56.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:03:56.709]                   ...future.conditions[[length(...future.conditions) + 
[17:03:56.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:03:56.709]                   if (TRUE && !signal) {
[17:03:56.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.709]                     {
[17:03:56.709]                       inherits <- base::inherits
[17:03:56.709]                       invokeRestart <- base::invokeRestart
[17:03:56.709]                       is.null <- base::is.null
[17:03:56.709]                       muffled <- FALSE
[17:03:56.709]                       if (inherits(cond, "message")) {
[17:03:56.709]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.709]                         if (muffled) 
[17:03:56.709]                           invokeRestart("muffleMessage")
[17:03:56.709]                       }
[17:03:56.709]                       else if (inherits(cond, "warning")) {
[17:03:56.709]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.709]                         if (muffled) 
[17:03:56.709]                           invokeRestart("muffleWarning")
[17:03:56.709]                       }
[17:03:56.709]                       else if (inherits(cond, "condition")) {
[17:03:56.709]                         if (!is.null(pattern)) {
[17:03:56.709]                           computeRestarts <- base::computeRestarts
[17:03:56.709]                           grepl <- base::grepl
[17:03:56.709]                           restarts <- computeRestarts(cond)
[17:03:56.709]                           for (restart in restarts) {
[17:03:56.709]                             name <- restart$name
[17:03:56.709]                             if (is.null(name)) 
[17:03:56.709]                               next
[17:03:56.709]                             if (!grepl(pattern, name)) 
[17:03:56.709]                               next
[17:03:56.709]                             invokeRestart(restart)
[17:03:56.709]                             muffled <- TRUE
[17:03:56.709]                             break
[17:03:56.709]                           }
[17:03:56.709]                         }
[17:03:56.709]                       }
[17:03:56.709]                       invisible(muffled)
[17:03:56.709]                     }
[17:03:56.709]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.709]                   }
[17:03:56.709]                 }
[17:03:56.709]                 else {
[17:03:56.709]                   if (TRUE) {
[17:03:56.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:03:56.709]                     {
[17:03:56.709]                       inherits <- base::inherits
[17:03:56.709]                       invokeRestart <- base::invokeRestart
[17:03:56.709]                       is.null <- base::is.null
[17:03:56.709]                       muffled <- FALSE
[17:03:56.709]                       if (inherits(cond, "message")) {
[17:03:56.709]                         muffled <- grepl(pattern, "muffleMessage")
[17:03:56.709]                         if (muffled) 
[17:03:56.709]                           invokeRestart("muffleMessage")
[17:03:56.709]                       }
[17:03:56.709]                       else if (inherits(cond, "warning")) {
[17:03:56.709]                         muffled <- grepl(pattern, "muffleWarning")
[17:03:56.709]                         if (muffled) 
[17:03:56.709]                           invokeRestart("muffleWarning")
[17:03:56.709]                       }
[17:03:56.709]                       else if (inherits(cond, "condition")) {
[17:03:56.709]                         if (!is.null(pattern)) {
[17:03:56.709]                           computeRestarts <- base::computeRestarts
[17:03:56.709]                           grepl <- base::grepl
[17:03:56.709]                           restarts <- computeRestarts(cond)
[17:03:56.709]                           for (restart in restarts) {
[17:03:56.709]                             name <- restart$name
[17:03:56.709]                             if (is.null(name)) 
[17:03:56.709]                               next
[17:03:56.709]                             if (!grepl(pattern, name)) 
[17:03:56.709]                               next
[17:03:56.709]                             invokeRestart(restart)
[17:03:56.709]                             muffled <- TRUE
[17:03:56.709]                             break
[17:03:56.709]                           }
[17:03:56.709]                         }
[17:03:56.709]                       }
[17:03:56.709]                       invisible(muffled)
[17:03:56.709]                     }
[17:03:56.709]                     muffleCondition(cond, pattern = "^muffle")
[17:03:56.709]                   }
[17:03:56.709]                 }
[17:03:56.709]             }
[17:03:56.709]         }))
[17:03:56.709]     }, error = function(ex) {
[17:03:56.709]         base::structure(base::list(value = NULL, visible = NULL, 
[17:03:56.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:03:56.709]                 ...future.rng), started = ...future.startTime, 
[17:03:56.709]             finished = Sys.time(), session_uuid = NA_character_, 
[17:03:56.709]             version = "1.8"), class = "FutureResult")
[17:03:56.709]     }, finally = {
[17:03:56.709]         if (!identical(...future.workdir, getwd())) 
[17:03:56.709]             setwd(...future.workdir)
[17:03:56.709]         {
[17:03:56.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:03:56.709]                 ...future.oldOptions$nwarnings <- NULL
[17:03:56.709]             }
[17:03:56.709]             base::options(...future.oldOptions)
[17:03:56.709]             if (.Platform$OS.type == "windows") {
[17:03:56.709]                 old_names <- names(...future.oldEnvVars)
[17:03:56.709]                 envs <- base::Sys.getenv()
[17:03:56.709]                 names <- names(envs)
[17:03:56.709]                 common <- intersect(names, old_names)
[17:03:56.709]                 added <- setdiff(names, old_names)
[17:03:56.709]                 removed <- setdiff(old_names, names)
[17:03:56.709]                 changed <- common[...future.oldEnvVars[common] != 
[17:03:56.709]                   envs[common]]
[17:03:56.709]                 NAMES <- toupper(changed)
[17:03:56.709]                 args <- list()
[17:03:56.709]                 for (kk in seq_along(NAMES)) {
[17:03:56.709]                   name <- changed[[kk]]
[17:03:56.709]                   NAME <- NAMES[[kk]]
[17:03:56.709]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.709]                     next
[17:03:56.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.709]                 }
[17:03:56.709]                 NAMES <- toupper(added)
[17:03:56.709]                 for (kk in seq_along(NAMES)) {
[17:03:56.709]                   name <- added[[kk]]
[17:03:56.709]                   NAME <- NAMES[[kk]]
[17:03:56.709]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.709]                     next
[17:03:56.709]                   args[[name]] <- ""
[17:03:56.709]                 }
[17:03:56.709]                 NAMES <- toupper(removed)
[17:03:56.709]                 for (kk in seq_along(NAMES)) {
[17:03:56.709]                   name <- removed[[kk]]
[17:03:56.709]                   NAME <- NAMES[[kk]]
[17:03:56.709]                   if (name != NAME && is.element(NAME, old_names)) 
[17:03:56.709]                     next
[17:03:56.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:03:56.709]                 }
[17:03:56.709]                 if (length(args) > 0) 
[17:03:56.709]                   base::do.call(base::Sys.setenv, args = args)
[17:03:56.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:03:56.709]             }
[17:03:56.709]             else {
[17:03:56.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:03:56.709]             }
[17:03:56.709]             {
[17:03:56.709]                 if (base::length(...future.futureOptionsAdded) > 
[17:03:56.709]                   0L) {
[17:03:56.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:03:56.709]                   base::names(opts) <- ...future.futureOptionsAdded
[17:03:56.709]                   base::options(opts)
[17:03:56.709]                 }
[17:03:56.709]                 {
[17:03:56.709]                   {
[17:03:56.709]                     base::options(mc.cores = ...future.mc.cores.old)
[17:03:56.709]                     NULL
[17:03:56.709]                   }
[17:03:56.709]                   options(future.plan = NULL)
[17:03:56.709]                   if (is.na(NA_character_)) 
[17:03:56.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:03:56.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:03:56.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:03:56.709]                     .init = FALSE)
[17:03:56.709]                 }
[17:03:56.709]             }
[17:03:56.709]         }
[17:03:56.709]     })
[17:03:56.709]     if (TRUE) {
[17:03:56.709]         base::sink(type = "output", split = FALSE)
[17:03:56.709]         if (TRUE) {
[17:03:56.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:03:56.709]         }
[17:03:56.709]         else {
[17:03:56.709]             ...future.result["stdout"] <- base::list(NULL)
[17:03:56.709]         }
[17:03:56.709]         base::close(...future.stdout)
[17:03:56.709]         ...future.stdout <- NULL
[17:03:56.709]     }
[17:03:56.709]     ...future.result$conditions <- ...future.conditions
[17:03:56.709]     ...future.result$finished <- base::Sys.time()
[17:03:56.709]     ...future.result
[17:03:56.709] }
[17:03:56.711] Poll #1 (0): usedNodes() = 2, workers = 2
[17:03:56.722] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.722] - Validating connection of MultisessionFuture
[17:03:56.722] - received message: FutureResult
[17:03:56.722] - Received FutureResult
[17:03:56.723] - Erased future from FutureRegistry
[17:03:56.723] result() for ClusterFuture ...
[17:03:56.723] - result already collected: FutureResult
[17:03:56.723] result() for ClusterFuture ... done
[17:03:56.723] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.723] result() for ClusterFuture ...
[17:03:56.723] - result already collected: FutureResult
[17:03:56.723] result() for ClusterFuture ... done
[17:03:56.723] result() for ClusterFuture ...
[17:03:56.723] - result already collected: FutureResult
[17:03:56.723] result() for ClusterFuture ... done
[17:03:56.725] MultisessionFuture started
[17:03:56.725] - Launch lazy future ... done
[17:03:56.725] run() for ‘MultisessionFuture’ ... done
[17:03:56.725] resolve() on list environment ...
[17:03:56.725]  recursive: 0
[17:03:56.726]  length: 4
[17:03:56.726]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:56.726] Future #1
[17:03:56.726]  length: 3 (resolved future 1)
[17:03:56.737] receiveMessageFromWorker() for ClusterFuture ...
[17:03:56.738] - Validating connection of MultisessionFuture
[17:03:56.738] - received message: FutureResult
[17:03:56.738] - Received FutureResult
[17:03:56.738] - Erased future from FutureRegistry
[17:03:56.738] result() for ClusterFuture ...
[17:03:56.738] - result already collected: FutureResult
[17:03:56.738] result() for ClusterFuture ... done
[17:03:56.738] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:56.738] Future #3
[17:03:56.739]  length: 2 (resolved future 3)
[17:03:56.739]  length: 1 (resolved future 4)
[17:03:57.192] receiveMessageFromWorker() for ClusterFuture ...
[17:03:57.192] - Validating connection of MultisessionFuture
[17:03:57.193] - received message: FutureResult
[17:03:57.193] - Received FutureResult
[17:03:57.193] - Erased future from FutureRegistry
[17:03:57.193] result() for ClusterFuture ...
[17:03:57.193] - result already collected: FutureResult
[17:03:57.193] result() for ClusterFuture ... done
[17:03:57.193] receiveMessageFromWorker() for ClusterFuture ... done
[17:03:57.193] Future #2
[17:03:57.194]  length: 0 (resolved future 2)
[17:03:57.194] resolve() on list environment ... DONE
[17:03:57.194] resolve() on list environment ...
[17:03:57.194]  recursive: 0
[17:03:57.195]  length: 4
[17:03:57.195]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:57.195] Future #1
[17:03:57.195]  length: 3 (resolved future 1)
[17:03:57.195] Future #2
[17:03:57.195]  length: 2 (resolved future 2)
[17:03:57.195] Future #3
[17:03:57.196]  length: 1 (resolved future 3)
[17:03:57.196]  length: 0 (resolved future 4)
[17:03:57.196] resolve() on list environment ... DONE
[17:03:57.196] resolve() on list environment ...
[17:03:57.196]  recursive: 0
[17:03:57.197]  length: 4
[17:03:57.197]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:57.197] Future #1
[17:03:57.197]  length: 3 (resolved future 1)
[17:03:57.197] Future #2
[17:03:57.197]  length: 2 (resolved future 2)
[17:03:57.198] Future #3
[17:03:57.198]  length: 1 (resolved future 3)
[17:03:57.198]  length: 0 (resolved future 4)
[17:03:57.198] resolve() on list environment ... DONE
[17:03:57.198] resolve() on list environment ...
[17:03:57.198]  recursive: 0
[17:03:57.199]  length: 4
[17:03:57.199]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:57.199] Future #1
[17:03:57.199]  length: 3 (resolved future 1)
[17:03:57.199] Future #2
[17:03:57.200]  length: 2 (resolved future 2)
[17:03:57.200] Future #3
[17:03:57.200]  length: 1 (resolved future 3)
[17:03:57.200]  length: 0 (resolved future 4)
[17:03:57.200] resolve() on list environment ... DONE
[17:03:57.200] resolve() on list environment ...
[17:03:57.201]  recursive: 0
[17:03:57.201]  length: 4
[17:03:57.201]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:57.201] Future #1
[17:03:57.201] result() for ClusterFuture ...
[17:03:57.202] - result already collected: FutureResult
[17:03:57.202] result() for ClusterFuture ... done
[17:03:57.202] result() for ClusterFuture ...
[17:03:57.202] - result already collected: FutureResult
[17:03:57.202] result() for ClusterFuture ... done
[17:03:57.202]  length: 3 (resolved future 1)
[17:03:57.202] Future #2
[17:03:57.202] result() for ClusterFuture ...
[17:03:57.202] - result already collected: FutureResult
[17:03:57.202] result() for ClusterFuture ... done
[17:03:57.202] result() for ClusterFuture ...
[17:03:57.203] - result already collected: FutureResult
[17:03:57.203] result() for ClusterFuture ... done
[17:03:57.203]  length: 2 (resolved future 2)
[17:03:57.203] Future #3
[17:03:57.203] result() for ClusterFuture ...
[17:03:57.203] - result already collected: FutureResult
[17:03:57.203] result() for ClusterFuture ... done
[17:03:57.203] result() for ClusterFuture ...
[17:03:57.203] - result already collected: FutureResult
[17:03:57.203] result() for ClusterFuture ... done
[17:03:57.203]  length: 1 (resolved future 3)
[17:03:57.204]  length: 0 (resolved future 4)
[17:03:57.204] resolve() on list environment ... DONE
[17:03:57.207] resolve() on list environment ...
[17:03:57.207]  recursive: 99
[17:03:57.208]  length: 4
[17:03:57.208]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:03:57.208] Future #1
[17:03:57.208] result() for ClusterFuture ...
[17:03:57.208] - result already collected: FutureResult
[17:03:57.208] result() for ClusterFuture ... done
[17:03:57.208] result() for ClusterFuture ...
[17:03:57.209] - result already collected: FutureResult
[17:03:57.209] result() for ClusterFuture ... done
[17:03:57.209] A MultisessionFuture was resolved
[17:03:57.209]  length: 3 (resolved future 1)
[17:03:57.209] Future #2
[17:03:57.209] result() for ClusterFuture ...
[17:03:57.209] - result already collected: FutureResult
[17:03:57.209] result() for ClusterFuture ... done
[17:03:57.209] result() for ClusterFuture ...
[17:03:57.209] - result already collected: FutureResult
[17:03:57.209] result() for ClusterFuture ... done
[17:03:57.210] A MultisessionFuture was resolved
[17:03:57.210]  length: 2 (resolved future 2)
[17:03:57.210] Future #3
[17:03:57.210] result() for ClusterFuture ...
[17:03:57.210] - result already collected: FutureResult
[17:03:57.210] result() for ClusterFuture ... done
[17:03:57.210] result() for ClusterFuture ...
[17:03:57.210] - result already collected: FutureResult
[17:03:57.210] result() for ClusterFuture ... done
[17:03:57.210] A MultisessionFuture was resolved
[17:03:57.211]  length: 1 (resolved future 3)
[17:03:57.211]  length: 0 (resolved future 4)
[17:03:57.211] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[17:03:57.214] resolve() on list ...
[17:03:57.214]  recursive: 0
[17:03:57.214]  length: 3
[17:03:57.214] 
[17:03:57.214]  length: 2 (resolved future 1)
[17:03:57.214]  length: 1 (resolved future 2)
[17:03:57.214]  length: 0 (resolved future 3)
[17:03:57.214] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[17:03:57.215] plan(): Setting new future strategy stack:
[17:03:57.215] List of future strategies:
[17:03:57.215] 1. FutureStrategy:
[17:03:57.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:03:57.215]    - tweaked: FALSE
[17:03:57.215]    - call: future::plan(oplan)
[17:03:57.216] plan(): nbrOfWorkers() = 1
> 
