
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:03:58.840] plan(): Setting new future strategy stack:
[18:03:58.841] List of future strategies:
[18:03:58.841] 1. sequential:
[18:03:58.841]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:58.841]    - tweaked: FALSE
[18:03:58.841]    - call: future::plan("sequential")
[18:03:58.864] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[18:03:58.981] plan(): Setting new future strategy stack:
[18:03:58.982] List of future strategies:
[18:03:58.982] 1. sequential:
[18:03:58.982]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:58.982]    - tweaked: FALSE
[18:03:58.982]    - call: plan(strategy)
[18:03:59.014] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[18:03:59.019] getGlobalsAndPackages() ...
[18:03:59.020] Searching for globals...
[18:03:59.028] - globals found: [2] ‘{’, ‘<-’
[18:03:59.029] Searching for globals ... DONE
[18:03:59.029] Resolving globals: FALSE
[18:03:59.030] 
[18:03:59.030] 
[18:03:59.031] getGlobalsAndPackages() ... DONE
[18:03:59.032] run() for ‘Future’ ...
[18:03:59.032] - state: ‘created’
[18:03:59.033] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.034] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.034]   - Field: ‘label’
[18:03:59.034]   - Field: ‘local’
[18:03:59.035]   - Field: ‘owner’
[18:03:59.035]   - Field: ‘envir’
[18:03:59.035]   - Field: ‘packages’
[18:03:59.035]   - Field: ‘gc’
[18:03:59.036]   - Field: ‘conditions’
[18:03:59.036]   - Field: ‘expr’
[18:03:59.036]   - Field: ‘uuid’
[18:03:59.036]   - Field: ‘seed’
[18:03:59.036]   - Field: ‘version’
[18:03:59.037]   - Field: ‘result’
[18:03:59.037]   - Field: ‘asynchronous’
[18:03:59.037]   - Field: ‘calls’
[18:03:59.037]   - Field: ‘globals’
[18:03:59.037]   - Field: ‘stdout’
[18:03:59.038]   - Field: ‘earlySignal’
[18:03:59.038]   - Field: ‘lazy’
[18:03:59.038]   - Field: ‘state’
[18:03:59.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.038] - Launch lazy future ...
[18:03:59.040] Packages needed by the future expression (n = 0): <none>
[18:03:59.040] Packages needed by future strategies (n = 0): <none>
[18:03:59.042] {
[18:03:59.042]     {
[18:03:59.042]         {
[18:03:59.042]             ...future.startTime <- base::Sys.time()
[18:03:59.042]             {
[18:03:59.042]                 {
[18:03:59.042]                   {
[18:03:59.042]                     base::local({
[18:03:59.042]                       has_future <- base::requireNamespace("future", 
[18:03:59.042]                         quietly = TRUE)
[18:03:59.042]                       if (has_future) {
[18:03:59.042]                         ns <- base::getNamespace("future")
[18:03:59.042]                         version <- ns[[".package"]][["version"]]
[18:03:59.042]                         if (is.null(version)) 
[18:03:59.042]                           version <- utils::packageVersion("future")
[18:03:59.042]                       }
[18:03:59.042]                       else {
[18:03:59.042]                         version <- NULL
[18:03:59.042]                       }
[18:03:59.042]                       if (!has_future || version < "1.8.0") {
[18:03:59.042]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.042]                           "", base::R.version$version.string), 
[18:03:59.042]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.042]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.042]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.042]                             "release", "version")], collapse = " "), 
[18:03:59.042]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.042]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.042]                           info)
[18:03:59.042]                         info <- base::paste(info, collapse = "; ")
[18:03:59.042]                         if (!has_future) {
[18:03:59.042]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.042]                             info)
[18:03:59.042]                         }
[18:03:59.042]                         else {
[18:03:59.042]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.042]                             info, version)
[18:03:59.042]                         }
[18:03:59.042]                         base::stop(msg)
[18:03:59.042]                       }
[18:03:59.042]                     })
[18:03:59.042]                   }
[18:03:59.042]                   ...future.strategy.old <- future::plan("list")
[18:03:59.042]                   options(future.plan = NULL)
[18:03:59.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.042]                 }
[18:03:59.042]                 ...future.workdir <- getwd()
[18:03:59.042]             }
[18:03:59.042]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.042]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.042]         }
[18:03:59.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.042]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.042]             base::names(...future.oldOptions))
[18:03:59.042]     }
[18:03:59.042]     if (FALSE) {
[18:03:59.042]     }
[18:03:59.042]     else {
[18:03:59.042]         if (TRUE) {
[18:03:59.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.042]                 open = "w")
[18:03:59.042]         }
[18:03:59.042]         else {
[18:03:59.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.042]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.042]         }
[18:03:59.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.042]             base::sink(type = "output", split = FALSE)
[18:03:59.042]             base::close(...future.stdout)
[18:03:59.042]         }, add = TRUE)
[18:03:59.042]     }
[18:03:59.042]     ...future.frame <- base::sys.nframe()
[18:03:59.042]     ...future.conditions <- base::list()
[18:03:59.042]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.042]     if (FALSE) {
[18:03:59.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.042]     }
[18:03:59.042]     ...future.result <- base::tryCatch({
[18:03:59.042]         base::withCallingHandlers({
[18:03:59.042]             ...future.value <- base::withVisible(base::local({
[18:03:59.042]                 x <- 1
[18:03:59.042]             }))
[18:03:59.042]             future::FutureResult(value = ...future.value$value, 
[18:03:59.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.042]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.042]                     ...future.globalenv.names))
[18:03:59.042]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.042]         }, condition = base::local({
[18:03:59.042]             c <- base::c
[18:03:59.042]             inherits <- base::inherits
[18:03:59.042]             invokeRestart <- base::invokeRestart
[18:03:59.042]             length <- base::length
[18:03:59.042]             list <- base::list
[18:03:59.042]             seq.int <- base::seq.int
[18:03:59.042]             signalCondition <- base::signalCondition
[18:03:59.042]             sys.calls <- base::sys.calls
[18:03:59.042]             `[[` <- base::`[[`
[18:03:59.042]             `+` <- base::`+`
[18:03:59.042]             `<<-` <- base::`<<-`
[18:03:59.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.042]                   3L)]
[18:03:59.042]             }
[18:03:59.042]             function(cond) {
[18:03:59.042]                 is_error <- inherits(cond, "error")
[18:03:59.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.042]                   NULL)
[18:03:59.042]                 if (is_error) {
[18:03:59.042]                   sessionInformation <- function() {
[18:03:59.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.042]                       search = base::search(), system = base::Sys.info())
[18:03:59.042]                   }
[18:03:59.042]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.042]                     cond$call), session = sessionInformation(), 
[18:03:59.042]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.042]                   signalCondition(cond)
[18:03:59.042]                 }
[18:03:59.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.042]                 "immediateCondition"))) {
[18:03:59.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.042]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.042]                   if (TRUE && !signal) {
[18:03:59.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.042]                     {
[18:03:59.042]                       inherits <- base::inherits
[18:03:59.042]                       invokeRestart <- base::invokeRestart
[18:03:59.042]                       is.null <- base::is.null
[18:03:59.042]                       muffled <- FALSE
[18:03:59.042]                       if (inherits(cond, "message")) {
[18:03:59.042]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.042]                         if (muffled) 
[18:03:59.042]                           invokeRestart("muffleMessage")
[18:03:59.042]                       }
[18:03:59.042]                       else if (inherits(cond, "warning")) {
[18:03:59.042]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.042]                         if (muffled) 
[18:03:59.042]                           invokeRestart("muffleWarning")
[18:03:59.042]                       }
[18:03:59.042]                       else if (inherits(cond, "condition")) {
[18:03:59.042]                         if (!is.null(pattern)) {
[18:03:59.042]                           computeRestarts <- base::computeRestarts
[18:03:59.042]                           grepl <- base::grepl
[18:03:59.042]                           restarts <- computeRestarts(cond)
[18:03:59.042]                           for (restart in restarts) {
[18:03:59.042]                             name <- restart$name
[18:03:59.042]                             if (is.null(name)) 
[18:03:59.042]                               next
[18:03:59.042]                             if (!grepl(pattern, name)) 
[18:03:59.042]                               next
[18:03:59.042]                             invokeRestart(restart)
[18:03:59.042]                             muffled <- TRUE
[18:03:59.042]                             break
[18:03:59.042]                           }
[18:03:59.042]                         }
[18:03:59.042]                       }
[18:03:59.042]                       invisible(muffled)
[18:03:59.042]                     }
[18:03:59.042]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.042]                   }
[18:03:59.042]                 }
[18:03:59.042]                 else {
[18:03:59.042]                   if (TRUE) {
[18:03:59.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.042]                     {
[18:03:59.042]                       inherits <- base::inherits
[18:03:59.042]                       invokeRestart <- base::invokeRestart
[18:03:59.042]                       is.null <- base::is.null
[18:03:59.042]                       muffled <- FALSE
[18:03:59.042]                       if (inherits(cond, "message")) {
[18:03:59.042]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.042]                         if (muffled) 
[18:03:59.042]                           invokeRestart("muffleMessage")
[18:03:59.042]                       }
[18:03:59.042]                       else if (inherits(cond, "warning")) {
[18:03:59.042]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.042]                         if (muffled) 
[18:03:59.042]                           invokeRestart("muffleWarning")
[18:03:59.042]                       }
[18:03:59.042]                       else if (inherits(cond, "condition")) {
[18:03:59.042]                         if (!is.null(pattern)) {
[18:03:59.042]                           computeRestarts <- base::computeRestarts
[18:03:59.042]                           grepl <- base::grepl
[18:03:59.042]                           restarts <- computeRestarts(cond)
[18:03:59.042]                           for (restart in restarts) {
[18:03:59.042]                             name <- restart$name
[18:03:59.042]                             if (is.null(name)) 
[18:03:59.042]                               next
[18:03:59.042]                             if (!grepl(pattern, name)) 
[18:03:59.042]                               next
[18:03:59.042]                             invokeRestart(restart)
[18:03:59.042]                             muffled <- TRUE
[18:03:59.042]                             break
[18:03:59.042]                           }
[18:03:59.042]                         }
[18:03:59.042]                       }
[18:03:59.042]                       invisible(muffled)
[18:03:59.042]                     }
[18:03:59.042]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.042]                   }
[18:03:59.042]                 }
[18:03:59.042]             }
[18:03:59.042]         }))
[18:03:59.042]     }, error = function(ex) {
[18:03:59.042]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.042]                 ...future.rng), started = ...future.startTime, 
[18:03:59.042]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.042]             version = "1.8"), class = "FutureResult")
[18:03:59.042]     }, finally = {
[18:03:59.042]         if (!identical(...future.workdir, getwd())) 
[18:03:59.042]             setwd(...future.workdir)
[18:03:59.042]         {
[18:03:59.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.042]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.042]             }
[18:03:59.042]             base::options(...future.oldOptions)
[18:03:59.042]             if (.Platform$OS.type == "windows") {
[18:03:59.042]                 old_names <- names(...future.oldEnvVars)
[18:03:59.042]                 envs <- base::Sys.getenv()
[18:03:59.042]                 names <- names(envs)
[18:03:59.042]                 common <- intersect(names, old_names)
[18:03:59.042]                 added <- setdiff(names, old_names)
[18:03:59.042]                 removed <- setdiff(old_names, names)
[18:03:59.042]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.042]                   envs[common]]
[18:03:59.042]                 NAMES <- toupper(changed)
[18:03:59.042]                 args <- list()
[18:03:59.042]                 for (kk in seq_along(NAMES)) {
[18:03:59.042]                   name <- changed[[kk]]
[18:03:59.042]                   NAME <- NAMES[[kk]]
[18:03:59.042]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.042]                     next
[18:03:59.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.042]                 }
[18:03:59.042]                 NAMES <- toupper(added)
[18:03:59.042]                 for (kk in seq_along(NAMES)) {
[18:03:59.042]                   name <- added[[kk]]
[18:03:59.042]                   NAME <- NAMES[[kk]]
[18:03:59.042]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.042]                     next
[18:03:59.042]                   args[[name]] <- ""
[18:03:59.042]                 }
[18:03:59.042]                 NAMES <- toupper(removed)
[18:03:59.042]                 for (kk in seq_along(NAMES)) {
[18:03:59.042]                   name <- removed[[kk]]
[18:03:59.042]                   NAME <- NAMES[[kk]]
[18:03:59.042]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.042]                     next
[18:03:59.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.042]                 }
[18:03:59.042]                 if (length(args) > 0) 
[18:03:59.042]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.042]             }
[18:03:59.042]             else {
[18:03:59.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.042]             }
[18:03:59.042]             {
[18:03:59.042]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.042]                   0L) {
[18:03:59.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.042]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.042]                   base::options(opts)
[18:03:59.042]                 }
[18:03:59.042]                 {
[18:03:59.042]                   {
[18:03:59.042]                     NULL
[18:03:59.042]                     RNGkind("Mersenne-Twister")
[18:03:59.042]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.042]                       inherits = FALSE)
[18:03:59.042]                   }
[18:03:59.042]                   options(future.plan = NULL)
[18:03:59.042]                   if (is.na(NA_character_)) 
[18:03:59.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.042]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.042]                     .init = FALSE)
[18:03:59.042]                 }
[18:03:59.042]             }
[18:03:59.042]         }
[18:03:59.042]     })
[18:03:59.042]     if (TRUE) {
[18:03:59.042]         base::sink(type = "output", split = FALSE)
[18:03:59.042]         if (TRUE) {
[18:03:59.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.042]         }
[18:03:59.042]         else {
[18:03:59.042]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.042]         }
[18:03:59.042]         base::close(...future.stdout)
[18:03:59.042]         ...future.stdout <- NULL
[18:03:59.042]     }
[18:03:59.042]     ...future.result$conditions <- ...future.conditions
[18:03:59.042]     ...future.result$finished <- base::Sys.time()
[18:03:59.042]     ...future.result
[18:03:59.042] }
[18:03:59.047] plan(): Setting new future strategy stack:
[18:03:59.048] List of future strategies:
[18:03:59.048] 1. sequential:
[18:03:59.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.048]    - tweaked: FALSE
[18:03:59.048]    - call: NULL
[18:03:59.049] plan(): nbrOfWorkers() = 1
[18:03:59.051] plan(): Setting new future strategy stack:
[18:03:59.052] List of future strategies:
[18:03:59.052] 1. sequential:
[18:03:59.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.052]    - tweaked: FALSE
[18:03:59.052]    - call: plan(strategy)
[18:03:59.053] plan(): nbrOfWorkers() = 1
[18:03:59.054] SequentialFuture started (and completed)
[18:03:59.055] - Launch lazy future ... done
[18:03:59.055] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[18:03:59.057] getGlobalsAndPackages() ...
[18:03:59.057] Searching for globals...
[18:03:59.060] - globals found: [3] ‘{’, ‘<-’, ‘a’
[18:03:59.060] Searching for globals ... DONE
[18:03:59.060] Resolving globals: FALSE
[18:03:59.063] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.064] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:03:59.064] - globals: [1] ‘a’
[18:03:59.064] 
[18:03:59.064] getGlobalsAndPackages() ... DONE
[18:03:59.065] run() for ‘Future’ ...
[18:03:59.065] - state: ‘created’
[18:03:59.066] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.066] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.067]   - Field: ‘label’
[18:03:59.067]   - Field: ‘local’
[18:03:59.067]   - Field: ‘owner’
[18:03:59.068]   - Field: ‘envir’
[18:03:59.068]   - Field: ‘packages’
[18:03:59.068]   - Field: ‘gc’
[18:03:59.068]   - Field: ‘conditions’
[18:03:59.069]   - Field: ‘expr’
[18:03:59.069]   - Field: ‘uuid’
[18:03:59.069]   - Field: ‘seed’
[18:03:59.069]   - Field: ‘version’
[18:03:59.070]   - Field: ‘result’
[18:03:59.070]   - Field: ‘asynchronous’
[18:03:59.070]   - Field: ‘calls’
[18:03:59.070]   - Field: ‘globals’
[18:03:59.070]   - Field: ‘stdout’
[18:03:59.071]   - Field: ‘earlySignal’
[18:03:59.071]   - Field: ‘lazy’
[18:03:59.071]   - Field: ‘state’
[18:03:59.071] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.071] - Launch lazy future ...
[18:03:59.072] Packages needed by the future expression (n = 0): <none>
[18:03:59.072] Packages needed by future strategies (n = 0): <none>
[18:03:59.073] {
[18:03:59.073]     {
[18:03:59.073]         {
[18:03:59.073]             ...future.startTime <- base::Sys.time()
[18:03:59.073]             {
[18:03:59.073]                 {
[18:03:59.073]                   {
[18:03:59.073]                     base::local({
[18:03:59.073]                       has_future <- base::requireNamespace("future", 
[18:03:59.073]                         quietly = TRUE)
[18:03:59.073]                       if (has_future) {
[18:03:59.073]                         ns <- base::getNamespace("future")
[18:03:59.073]                         version <- ns[[".package"]][["version"]]
[18:03:59.073]                         if (is.null(version)) 
[18:03:59.073]                           version <- utils::packageVersion("future")
[18:03:59.073]                       }
[18:03:59.073]                       else {
[18:03:59.073]                         version <- NULL
[18:03:59.073]                       }
[18:03:59.073]                       if (!has_future || version < "1.8.0") {
[18:03:59.073]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.073]                           "", base::R.version$version.string), 
[18:03:59.073]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.073]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.073]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.073]                             "release", "version")], collapse = " "), 
[18:03:59.073]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.073]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.073]                           info)
[18:03:59.073]                         info <- base::paste(info, collapse = "; ")
[18:03:59.073]                         if (!has_future) {
[18:03:59.073]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.073]                             info)
[18:03:59.073]                         }
[18:03:59.073]                         else {
[18:03:59.073]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.073]                             info, version)
[18:03:59.073]                         }
[18:03:59.073]                         base::stop(msg)
[18:03:59.073]                       }
[18:03:59.073]                     })
[18:03:59.073]                   }
[18:03:59.073]                   ...future.strategy.old <- future::plan("list")
[18:03:59.073]                   options(future.plan = NULL)
[18:03:59.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.073]                 }
[18:03:59.073]                 ...future.workdir <- getwd()
[18:03:59.073]             }
[18:03:59.073]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.073]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.073]         }
[18:03:59.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.073]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.073]             base::names(...future.oldOptions))
[18:03:59.073]     }
[18:03:59.073]     if (FALSE) {
[18:03:59.073]     }
[18:03:59.073]     else {
[18:03:59.073]         if (TRUE) {
[18:03:59.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.073]                 open = "w")
[18:03:59.073]         }
[18:03:59.073]         else {
[18:03:59.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.073]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.073]         }
[18:03:59.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.073]             base::sink(type = "output", split = FALSE)
[18:03:59.073]             base::close(...future.stdout)
[18:03:59.073]         }, add = TRUE)
[18:03:59.073]     }
[18:03:59.073]     ...future.frame <- base::sys.nframe()
[18:03:59.073]     ...future.conditions <- base::list()
[18:03:59.073]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.073]     if (FALSE) {
[18:03:59.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.073]     }
[18:03:59.073]     ...future.result <- base::tryCatch({
[18:03:59.073]         base::withCallingHandlers({
[18:03:59.073]             ...future.value <- base::withVisible(base::local({
[18:03:59.073]                 x <- a
[18:03:59.073]             }))
[18:03:59.073]             future::FutureResult(value = ...future.value$value, 
[18:03:59.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.073]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.073]                     ...future.globalenv.names))
[18:03:59.073]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.073]         }, condition = base::local({
[18:03:59.073]             c <- base::c
[18:03:59.073]             inherits <- base::inherits
[18:03:59.073]             invokeRestart <- base::invokeRestart
[18:03:59.073]             length <- base::length
[18:03:59.073]             list <- base::list
[18:03:59.073]             seq.int <- base::seq.int
[18:03:59.073]             signalCondition <- base::signalCondition
[18:03:59.073]             sys.calls <- base::sys.calls
[18:03:59.073]             `[[` <- base::`[[`
[18:03:59.073]             `+` <- base::`+`
[18:03:59.073]             `<<-` <- base::`<<-`
[18:03:59.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.073]                   3L)]
[18:03:59.073]             }
[18:03:59.073]             function(cond) {
[18:03:59.073]                 is_error <- inherits(cond, "error")
[18:03:59.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.073]                   NULL)
[18:03:59.073]                 if (is_error) {
[18:03:59.073]                   sessionInformation <- function() {
[18:03:59.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.073]                       search = base::search(), system = base::Sys.info())
[18:03:59.073]                   }
[18:03:59.073]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.073]                     cond$call), session = sessionInformation(), 
[18:03:59.073]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.073]                   signalCondition(cond)
[18:03:59.073]                 }
[18:03:59.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.073]                 "immediateCondition"))) {
[18:03:59.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.073]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.073]                   if (TRUE && !signal) {
[18:03:59.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.073]                     {
[18:03:59.073]                       inherits <- base::inherits
[18:03:59.073]                       invokeRestart <- base::invokeRestart
[18:03:59.073]                       is.null <- base::is.null
[18:03:59.073]                       muffled <- FALSE
[18:03:59.073]                       if (inherits(cond, "message")) {
[18:03:59.073]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.073]                         if (muffled) 
[18:03:59.073]                           invokeRestart("muffleMessage")
[18:03:59.073]                       }
[18:03:59.073]                       else if (inherits(cond, "warning")) {
[18:03:59.073]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.073]                         if (muffled) 
[18:03:59.073]                           invokeRestart("muffleWarning")
[18:03:59.073]                       }
[18:03:59.073]                       else if (inherits(cond, "condition")) {
[18:03:59.073]                         if (!is.null(pattern)) {
[18:03:59.073]                           computeRestarts <- base::computeRestarts
[18:03:59.073]                           grepl <- base::grepl
[18:03:59.073]                           restarts <- computeRestarts(cond)
[18:03:59.073]                           for (restart in restarts) {
[18:03:59.073]                             name <- restart$name
[18:03:59.073]                             if (is.null(name)) 
[18:03:59.073]                               next
[18:03:59.073]                             if (!grepl(pattern, name)) 
[18:03:59.073]                               next
[18:03:59.073]                             invokeRestart(restart)
[18:03:59.073]                             muffled <- TRUE
[18:03:59.073]                             break
[18:03:59.073]                           }
[18:03:59.073]                         }
[18:03:59.073]                       }
[18:03:59.073]                       invisible(muffled)
[18:03:59.073]                     }
[18:03:59.073]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.073]                   }
[18:03:59.073]                 }
[18:03:59.073]                 else {
[18:03:59.073]                   if (TRUE) {
[18:03:59.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.073]                     {
[18:03:59.073]                       inherits <- base::inherits
[18:03:59.073]                       invokeRestart <- base::invokeRestart
[18:03:59.073]                       is.null <- base::is.null
[18:03:59.073]                       muffled <- FALSE
[18:03:59.073]                       if (inherits(cond, "message")) {
[18:03:59.073]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.073]                         if (muffled) 
[18:03:59.073]                           invokeRestart("muffleMessage")
[18:03:59.073]                       }
[18:03:59.073]                       else if (inherits(cond, "warning")) {
[18:03:59.073]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.073]                         if (muffled) 
[18:03:59.073]                           invokeRestart("muffleWarning")
[18:03:59.073]                       }
[18:03:59.073]                       else if (inherits(cond, "condition")) {
[18:03:59.073]                         if (!is.null(pattern)) {
[18:03:59.073]                           computeRestarts <- base::computeRestarts
[18:03:59.073]                           grepl <- base::grepl
[18:03:59.073]                           restarts <- computeRestarts(cond)
[18:03:59.073]                           for (restart in restarts) {
[18:03:59.073]                             name <- restart$name
[18:03:59.073]                             if (is.null(name)) 
[18:03:59.073]                               next
[18:03:59.073]                             if (!grepl(pattern, name)) 
[18:03:59.073]                               next
[18:03:59.073]                             invokeRestart(restart)
[18:03:59.073]                             muffled <- TRUE
[18:03:59.073]                             break
[18:03:59.073]                           }
[18:03:59.073]                         }
[18:03:59.073]                       }
[18:03:59.073]                       invisible(muffled)
[18:03:59.073]                     }
[18:03:59.073]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.073]                   }
[18:03:59.073]                 }
[18:03:59.073]             }
[18:03:59.073]         }))
[18:03:59.073]     }, error = function(ex) {
[18:03:59.073]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.073]                 ...future.rng), started = ...future.startTime, 
[18:03:59.073]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.073]             version = "1.8"), class = "FutureResult")
[18:03:59.073]     }, finally = {
[18:03:59.073]         if (!identical(...future.workdir, getwd())) 
[18:03:59.073]             setwd(...future.workdir)
[18:03:59.073]         {
[18:03:59.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.073]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.073]             }
[18:03:59.073]             base::options(...future.oldOptions)
[18:03:59.073]             if (.Platform$OS.type == "windows") {
[18:03:59.073]                 old_names <- names(...future.oldEnvVars)
[18:03:59.073]                 envs <- base::Sys.getenv()
[18:03:59.073]                 names <- names(envs)
[18:03:59.073]                 common <- intersect(names, old_names)
[18:03:59.073]                 added <- setdiff(names, old_names)
[18:03:59.073]                 removed <- setdiff(old_names, names)
[18:03:59.073]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.073]                   envs[common]]
[18:03:59.073]                 NAMES <- toupper(changed)
[18:03:59.073]                 args <- list()
[18:03:59.073]                 for (kk in seq_along(NAMES)) {
[18:03:59.073]                   name <- changed[[kk]]
[18:03:59.073]                   NAME <- NAMES[[kk]]
[18:03:59.073]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.073]                     next
[18:03:59.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.073]                 }
[18:03:59.073]                 NAMES <- toupper(added)
[18:03:59.073]                 for (kk in seq_along(NAMES)) {
[18:03:59.073]                   name <- added[[kk]]
[18:03:59.073]                   NAME <- NAMES[[kk]]
[18:03:59.073]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.073]                     next
[18:03:59.073]                   args[[name]] <- ""
[18:03:59.073]                 }
[18:03:59.073]                 NAMES <- toupper(removed)
[18:03:59.073]                 for (kk in seq_along(NAMES)) {
[18:03:59.073]                   name <- removed[[kk]]
[18:03:59.073]                   NAME <- NAMES[[kk]]
[18:03:59.073]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.073]                     next
[18:03:59.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.073]                 }
[18:03:59.073]                 if (length(args) > 0) 
[18:03:59.073]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.073]             }
[18:03:59.073]             else {
[18:03:59.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.073]             }
[18:03:59.073]             {
[18:03:59.073]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.073]                   0L) {
[18:03:59.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.073]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.073]                   base::options(opts)
[18:03:59.073]                 }
[18:03:59.073]                 {
[18:03:59.073]                   {
[18:03:59.073]                     NULL
[18:03:59.073]                     RNGkind("Mersenne-Twister")
[18:03:59.073]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.073]                       inherits = FALSE)
[18:03:59.073]                   }
[18:03:59.073]                   options(future.plan = NULL)
[18:03:59.073]                   if (is.na(NA_character_)) 
[18:03:59.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.073]                     .init = FALSE)
[18:03:59.073]                 }
[18:03:59.073]             }
[18:03:59.073]         }
[18:03:59.073]     })
[18:03:59.073]     if (TRUE) {
[18:03:59.073]         base::sink(type = "output", split = FALSE)
[18:03:59.073]         if (TRUE) {
[18:03:59.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.073]         }
[18:03:59.073]         else {
[18:03:59.073]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.073]         }
[18:03:59.073]         base::close(...future.stdout)
[18:03:59.073]         ...future.stdout <- NULL
[18:03:59.073]     }
[18:03:59.073]     ...future.result$conditions <- ...future.conditions
[18:03:59.073]     ...future.result$finished <- base::Sys.time()
[18:03:59.073]     ...future.result
[18:03:59.073] }
[18:03:59.077] assign_globals() ...
[18:03:59.077] List of 1
[18:03:59.077]  $ a: num 2
[18:03:59.077]  - attr(*, "where")=List of 1
[18:03:59.077]   ..$ a:<environment: R_EmptyEnv> 
[18:03:59.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.077]  - attr(*, "resolved")= logi FALSE
[18:03:59.077]  - attr(*, "total_size")= num 56
[18:03:59.077]  - attr(*, "already-done")= logi TRUE
[18:03:59.087] - copied ‘a’ to environment
[18:03:59.087] assign_globals() ... done
[18:03:59.087] plan(): Setting new future strategy stack:
[18:03:59.088] List of future strategies:
[18:03:59.088] 1. sequential:
[18:03:59.088]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.088]    - tweaked: FALSE
[18:03:59.088]    - call: NULL
[18:03:59.089] plan(): nbrOfWorkers() = 1
[18:03:59.090] plan(): Setting new future strategy stack:
[18:03:59.090] List of future strategies:
[18:03:59.090] 1. sequential:
[18:03:59.090]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.090]    - tweaked: FALSE
[18:03:59.090]    - call: plan(strategy)
[18:03:59.092] plan(): nbrOfWorkers() = 1
[18:03:59.092] SequentialFuture started (and completed)
[18:03:59.092] - Launch lazy future ... done
[18:03:59.092] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[18:03:59.093] getGlobalsAndPackages() ...
[18:03:59.094] Searching for globals...
[18:03:59.106] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[18:03:59.107] Searching for globals ... DONE
[18:03:59.107] Resolving globals: FALSE
[18:03:59.108] 
[18:03:59.109] 
[18:03:59.110] getGlobalsAndPackages() ... DONE
[18:03:59.110] run() for ‘Future’ ...
[18:03:59.110] - state: ‘created’
[18:03:59.111] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.112] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.112]   - Field: ‘label’
[18:03:59.112]   - Field: ‘local’
[18:03:59.113]   - Field: ‘owner’
[18:03:59.113]   - Field: ‘envir’
[18:03:59.113]   - Field: ‘packages’
[18:03:59.113]   - Field: ‘gc’
[18:03:59.114]   - Field: ‘conditions’
[18:03:59.114]   - Field: ‘expr’
[18:03:59.114]   - Field: ‘uuid’
[18:03:59.114]   - Field: ‘seed’
[18:03:59.114]   - Field: ‘version’
[18:03:59.115]   - Field: ‘result’
[18:03:59.115]   - Field: ‘asynchronous’
[18:03:59.116]   - Field: ‘calls’
[18:03:59.116]   - Field: ‘globals’
[18:03:59.116]   - Field: ‘stdout’
[18:03:59.116]   - Field: ‘earlySignal’
[18:03:59.117]   - Field: ‘lazy’
[18:03:59.117]   - Field: ‘state’
[18:03:59.117] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.117] - Launch lazy future ...
[18:03:59.118] Packages needed by the future expression (n = 0): <none>
[18:03:59.118] Packages needed by future strategies (n = 0): <none>
[18:03:59.119] {
[18:03:59.119]     {
[18:03:59.119]         {
[18:03:59.119]             ...future.startTime <- base::Sys.time()
[18:03:59.119]             {
[18:03:59.119]                 {
[18:03:59.119]                   {
[18:03:59.119]                     base::local({
[18:03:59.119]                       has_future <- base::requireNamespace("future", 
[18:03:59.119]                         quietly = TRUE)
[18:03:59.119]                       if (has_future) {
[18:03:59.119]                         ns <- base::getNamespace("future")
[18:03:59.119]                         version <- ns[[".package"]][["version"]]
[18:03:59.119]                         if (is.null(version)) 
[18:03:59.119]                           version <- utils::packageVersion("future")
[18:03:59.119]                       }
[18:03:59.119]                       else {
[18:03:59.119]                         version <- NULL
[18:03:59.119]                       }
[18:03:59.119]                       if (!has_future || version < "1.8.0") {
[18:03:59.119]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.119]                           "", base::R.version$version.string), 
[18:03:59.119]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.119]                             "release", "version")], collapse = " "), 
[18:03:59.119]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.119]                           info)
[18:03:59.119]                         info <- base::paste(info, collapse = "; ")
[18:03:59.119]                         if (!has_future) {
[18:03:59.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.119]                             info)
[18:03:59.119]                         }
[18:03:59.119]                         else {
[18:03:59.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.119]                             info, version)
[18:03:59.119]                         }
[18:03:59.119]                         base::stop(msg)
[18:03:59.119]                       }
[18:03:59.119]                     })
[18:03:59.119]                   }
[18:03:59.119]                   ...future.strategy.old <- future::plan("list")
[18:03:59.119]                   options(future.plan = NULL)
[18:03:59.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.119]                 }
[18:03:59.119]                 ...future.workdir <- getwd()
[18:03:59.119]             }
[18:03:59.119]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.119]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.119]         }
[18:03:59.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.119]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.119]             base::names(...future.oldOptions))
[18:03:59.119]     }
[18:03:59.119]     if (FALSE) {
[18:03:59.119]     }
[18:03:59.119]     else {
[18:03:59.119]         if (TRUE) {
[18:03:59.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.119]                 open = "w")
[18:03:59.119]         }
[18:03:59.119]         else {
[18:03:59.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.119]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.119]         }
[18:03:59.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.119]             base::sink(type = "output", split = FALSE)
[18:03:59.119]             base::close(...future.stdout)
[18:03:59.119]         }, add = TRUE)
[18:03:59.119]     }
[18:03:59.119]     ...future.frame <- base::sys.nframe()
[18:03:59.119]     ...future.conditions <- base::list()
[18:03:59.119]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.119]     if (FALSE) {
[18:03:59.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.119]     }
[18:03:59.119]     ...future.result <- base::tryCatch({
[18:03:59.119]         base::withCallingHandlers({
[18:03:59.119]             ...future.value <- base::withVisible(base::local({
[18:03:59.119]                 x <- 3
[18:03:59.119]                 stop("Woops!")
[18:03:59.119]                 x
[18:03:59.119]             }))
[18:03:59.119]             future::FutureResult(value = ...future.value$value, 
[18:03:59.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.119]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.119]                     ...future.globalenv.names))
[18:03:59.119]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.119]         }, condition = base::local({
[18:03:59.119]             c <- base::c
[18:03:59.119]             inherits <- base::inherits
[18:03:59.119]             invokeRestart <- base::invokeRestart
[18:03:59.119]             length <- base::length
[18:03:59.119]             list <- base::list
[18:03:59.119]             seq.int <- base::seq.int
[18:03:59.119]             signalCondition <- base::signalCondition
[18:03:59.119]             sys.calls <- base::sys.calls
[18:03:59.119]             `[[` <- base::`[[`
[18:03:59.119]             `+` <- base::`+`
[18:03:59.119]             `<<-` <- base::`<<-`
[18:03:59.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.119]                   3L)]
[18:03:59.119]             }
[18:03:59.119]             function(cond) {
[18:03:59.119]                 is_error <- inherits(cond, "error")
[18:03:59.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.119]                   NULL)
[18:03:59.119]                 if (is_error) {
[18:03:59.119]                   sessionInformation <- function() {
[18:03:59.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.119]                       search = base::search(), system = base::Sys.info())
[18:03:59.119]                   }
[18:03:59.119]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.119]                     cond$call), session = sessionInformation(), 
[18:03:59.119]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.119]                   signalCondition(cond)
[18:03:59.119]                 }
[18:03:59.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.119]                 "immediateCondition"))) {
[18:03:59.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.119]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.119]                   if (TRUE && !signal) {
[18:03:59.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.119]                     {
[18:03:59.119]                       inherits <- base::inherits
[18:03:59.119]                       invokeRestart <- base::invokeRestart
[18:03:59.119]                       is.null <- base::is.null
[18:03:59.119]                       muffled <- FALSE
[18:03:59.119]                       if (inherits(cond, "message")) {
[18:03:59.119]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.119]                         if (muffled) 
[18:03:59.119]                           invokeRestart("muffleMessage")
[18:03:59.119]                       }
[18:03:59.119]                       else if (inherits(cond, "warning")) {
[18:03:59.119]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.119]                         if (muffled) 
[18:03:59.119]                           invokeRestart("muffleWarning")
[18:03:59.119]                       }
[18:03:59.119]                       else if (inherits(cond, "condition")) {
[18:03:59.119]                         if (!is.null(pattern)) {
[18:03:59.119]                           computeRestarts <- base::computeRestarts
[18:03:59.119]                           grepl <- base::grepl
[18:03:59.119]                           restarts <- computeRestarts(cond)
[18:03:59.119]                           for (restart in restarts) {
[18:03:59.119]                             name <- restart$name
[18:03:59.119]                             if (is.null(name)) 
[18:03:59.119]                               next
[18:03:59.119]                             if (!grepl(pattern, name)) 
[18:03:59.119]                               next
[18:03:59.119]                             invokeRestart(restart)
[18:03:59.119]                             muffled <- TRUE
[18:03:59.119]                             break
[18:03:59.119]                           }
[18:03:59.119]                         }
[18:03:59.119]                       }
[18:03:59.119]                       invisible(muffled)
[18:03:59.119]                     }
[18:03:59.119]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.119]                   }
[18:03:59.119]                 }
[18:03:59.119]                 else {
[18:03:59.119]                   if (TRUE) {
[18:03:59.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.119]                     {
[18:03:59.119]                       inherits <- base::inherits
[18:03:59.119]                       invokeRestart <- base::invokeRestart
[18:03:59.119]                       is.null <- base::is.null
[18:03:59.119]                       muffled <- FALSE
[18:03:59.119]                       if (inherits(cond, "message")) {
[18:03:59.119]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.119]                         if (muffled) 
[18:03:59.119]                           invokeRestart("muffleMessage")
[18:03:59.119]                       }
[18:03:59.119]                       else if (inherits(cond, "warning")) {
[18:03:59.119]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.119]                         if (muffled) 
[18:03:59.119]                           invokeRestart("muffleWarning")
[18:03:59.119]                       }
[18:03:59.119]                       else if (inherits(cond, "condition")) {
[18:03:59.119]                         if (!is.null(pattern)) {
[18:03:59.119]                           computeRestarts <- base::computeRestarts
[18:03:59.119]                           grepl <- base::grepl
[18:03:59.119]                           restarts <- computeRestarts(cond)
[18:03:59.119]                           for (restart in restarts) {
[18:03:59.119]                             name <- restart$name
[18:03:59.119]                             if (is.null(name)) 
[18:03:59.119]                               next
[18:03:59.119]                             if (!grepl(pattern, name)) 
[18:03:59.119]                               next
[18:03:59.119]                             invokeRestart(restart)
[18:03:59.119]                             muffled <- TRUE
[18:03:59.119]                             break
[18:03:59.119]                           }
[18:03:59.119]                         }
[18:03:59.119]                       }
[18:03:59.119]                       invisible(muffled)
[18:03:59.119]                     }
[18:03:59.119]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.119]                   }
[18:03:59.119]                 }
[18:03:59.119]             }
[18:03:59.119]         }))
[18:03:59.119]     }, error = function(ex) {
[18:03:59.119]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.119]                 ...future.rng), started = ...future.startTime, 
[18:03:59.119]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.119]             version = "1.8"), class = "FutureResult")
[18:03:59.119]     }, finally = {
[18:03:59.119]         if (!identical(...future.workdir, getwd())) 
[18:03:59.119]             setwd(...future.workdir)
[18:03:59.119]         {
[18:03:59.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.119]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.119]             }
[18:03:59.119]             base::options(...future.oldOptions)
[18:03:59.119]             if (.Platform$OS.type == "windows") {
[18:03:59.119]                 old_names <- names(...future.oldEnvVars)
[18:03:59.119]                 envs <- base::Sys.getenv()
[18:03:59.119]                 names <- names(envs)
[18:03:59.119]                 common <- intersect(names, old_names)
[18:03:59.119]                 added <- setdiff(names, old_names)
[18:03:59.119]                 removed <- setdiff(old_names, names)
[18:03:59.119]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.119]                   envs[common]]
[18:03:59.119]                 NAMES <- toupper(changed)
[18:03:59.119]                 args <- list()
[18:03:59.119]                 for (kk in seq_along(NAMES)) {
[18:03:59.119]                   name <- changed[[kk]]
[18:03:59.119]                   NAME <- NAMES[[kk]]
[18:03:59.119]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.119]                     next
[18:03:59.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.119]                 }
[18:03:59.119]                 NAMES <- toupper(added)
[18:03:59.119]                 for (kk in seq_along(NAMES)) {
[18:03:59.119]                   name <- added[[kk]]
[18:03:59.119]                   NAME <- NAMES[[kk]]
[18:03:59.119]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.119]                     next
[18:03:59.119]                   args[[name]] <- ""
[18:03:59.119]                 }
[18:03:59.119]                 NAMES <- toupper(removed)
[18:03:59.119]                 for (kk in seq_along(NAMES)) {
[18:03:59.119]                   name <- removed[[kk]]
[18:03:59.119]                   NAME <- NAMES[[kk]]
[18:03:59.119]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.119]                     next
[18:03:59.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.119]                 }
[18:03:59.119]                 if (length(args) > 0) 
[18:03:59.119]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.119]             }
[18:03:59.119]             else {
[18:03:59.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.119]             }
[18:03:59.119]             {
[18:03:59.119]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.119]                   0L) {
[18:03:59.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.119]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.119]                   base::options(opts)
[18:03:59.119]                 }
[18:03:59.119]                 {
[18:03:59.119]                   {
[18:03:59.119]                     NULL
[18:03:59.119]                     RNGkind("Mersenne-Twister")
[18:03:59.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.119]                       inherits = FALSE)
[18:03:59.119]                   }
[18:03:59.119]                   options(future.plan = NULL)
[18:03:59.119]                   if (is.na(NA_character_)) 
[18:03:59.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.119]                     .init = FALSE)
[18:03:59.119]                 }
[18:03:59.119]             }
[18:03:59.119]         }
[18:03:59.119]     })
[18:03:59.119]     if (TRUE) {
[18:03:59.119]         base::sink(type = "output", split = FALSE)
[18:03:59.119]         if (TRUE) {
[18:03:59.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.119]         }
[18:03:59.119]         else {
[18:03:59.119]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.119]         }
[18:03:59.119]         base::close(...future.stdout)
[18:03:59.119]         ...future.stdout <- NULL
[18:03:59.119]     }
[18:03:59.119]     ...future.result$conditions <- ...future.conditions
[18:03:59.119]     ...future.result$finished <- base::Sys.time()
[18:03:59.119]     ...future.result
[18:03:59.119] }
[18:03:59.123] plan(): Setting new future strategy stack:
[18:03:59.124] List of future strategies:
[18:03:59.124] 1. sequential:
[18:03:59.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.124]    - tweaked: FALSE
[18:03:59.124]    - call: NULL
[18:03:59.125] plan(): nbrOfWorkers() = 1
[18:03:59.127] plan(): Setting new future strategy stack:
[18:03:59.127] List of future strategies:
[18:03:59.127] 1. sequential:
[18:03:59.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.127]    - tweaked: FALSE
[18:03:59.127]    - call: plan(strategy)
[18:03:59.128] plan(): nbrOfWorkers() = 1
[18:03:59.129] SequentialFuture started (and completed)
[18:03:59.129] signalConditions() ...
[18:03:59.129]  - include = ‘immediateCondition’
[18:03:59.130]  - exclude = 
[18:03:59.130]  - resignal = FALSE
[18:03:59.130]  - Number of conditions: 1
[18:03:59.130] signalConditions() ... done
[18:03:59.130] - Launch lazy future ... done
[18:03:59.131] run() for ‘SequentialFuture’ ... done
[18:03:59.131] signalConditions() ...
[18:03:59.131]  - include = ‘immediateCondition’
[18:03:59.131]  - exclude = 
[18:03:59.132]  - resignal = FALSE
[18:03:59.132]  - Number of conditions: 1
[18:03:59.132] signalConditions() ... done
[18:03:59.132] Future state: ‘finished’
[18:03:59.133] signalConditions() ...
[18:03:59.133]  - include = ‘condition’
[18:03:59.133]  - exclude = ‘immediateCondition’
[18:03:59.133]  - resignal = TRUE
[18:03:59.133]  - Number of conditions: 1
[18:03:59.134]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:03:59.134] signalConditions() ... done
[18:03:59.135] getGlobalsAndPackages() ...
[18:03:59.137] Searching for globals...
[18:03:59.145] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:03:59.145] Searching for globals ... DONE
[18:03:59.146] Resolving globals: FALSE
[18:03:59.149] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.150] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:03:59.150] - globals: [1] ‘ii’
[18:03:59.151] 
[18:03:59.151] getGlobalsAndPackages() ... DONE
[18:03:59.152] run() for ‘Future’ ...
[18:03:59.152] - state: ‘created’
[18:03:59.152] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.153] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.154]   - Field: ‘label’
[18:03:59.154]   - Field: ‘local’
[18:03:59.154]   - Field: ‘owner’
[18:03:59.154]   - Field: ‘envir’
[18:03:59.154]   - Field: ‘packages’
[18:03:59.155]   - Field: ‘gc’
[18:03:59.155]   - Field: ‘conditions’
[18:03:59.155]   - Field: ‘expr’
[18:03:59.155]   - Field: ‘uuid’
[18:03:59.155]   - Field: ‘seed’
[18:03:59.156]   - Field: ‘version’
[18:03:59.156]   - Field: ‘result’
[18:03:59.156]   - Field: ‘asynchronous’
[18:03:59.156]   - Field: ‘calls’
[18:03:59.156]   - Field: ‘globals’
[18:03:59.157]   - Field: ‘stdout’
[18:03:59.157]   - Field: ‘earlySignal’
[18:03:59.157]   - Field: ‘lazy’
[18:03:59.157]   - Field: ‘state’
[18:03:59.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.158] - Launch lazy future ...
[18:03:59.158] Packages needed by the future expression (n = 0): <none>
[18:03:59.158] Packages needed by future strategies (n = 0): <none>
[18:03:59.159] {
[18:03:59.159]     {
[18:03:59.159]         {
[18:03:59.159]             ...future.startTime <- base::Sys.time()
[18:03:59.159]             {
[18:03:59.159]                 {
[18:03:59.159]                   {
[18:03:59.159]                     base::local({
[18:03:59.159]                       has_future <- base::requireNamespace("future", 
[18:03:59.159]                         quietly = TRUE)
[18:03:59.159]                       if (has_future) {
[18:03:59.159]                         ns <- base::getNamespace("future")
[18:03:59.159]                         version <- ns[[".package"]][["version"]]
[18:03:59.159]                         if (is.null(version)) 
[18:03:59.159]                           version <- utils::packageVersion("future")
[18:03:59.159]                       }
[18:03:59.159]                       else {
[18:03:59.159]                         version <- NULL
[18:03:59.159]                       }
[18:03:59.159]                       if (!has_future || version < "1.8.0") {
[18:03:59.159]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.159]                           "", base::R.version$version.string), 
[18:03:59.159]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.159]                             "release", "version")], collapse = " "), 
[18:03:59.159]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.159]                           info)
[18:03:59.159]                         info <- base::paste(info, collapse = "; ")
[18:03:59.159]                         if (!has_future) {
[18:03:59.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.159]                             info)
[18:03:59.159]                         }
[18:03:59.159]                         else {
[18:03:59.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.159]                             info, version)
[18:03:59.159]                         }
[18:03:59.159]                         base::stop(msg)
[18:03:59.159]                       }
[18:03:59.159]                     })
[18:03:59.159]                   }
[18:03:59.159]                   ...future.strategy.old <- future::plan("list")
[18:03:59.159]                   options(future.plan = NULL)
[18:03:59.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.159]                 }
[18:03:59.159]                 ...future.workdir <- getwd()
[18:03:59.159]             }
[18:03:59.159]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.159]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.159]         }
[18:03:59.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.159]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.159]             base::names(...future.oldOptions))
[18:03:59.159]     }
[18:03:59.159]     if (FALSE) {
[18:03:59.159]     }
[18:03:59.159]     else {
[18:03:59.159]         if (TRUE) {
[18:03:59.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.159]                 open = "w")
[18:03:59.159]         }
[18:03:59.159]         else {
[18:03:59.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.159]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.159]         }
[18:03:59.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.159]             base::sink(type = "output", split = FALSE)
[18:03:59.159]             base::close(...future.stdout)
[18:03:59.159]         }, add = TRUE)
[18:03:59.159]     }
[18:03:59.159]     ...future.frame <- base::sys.nframe()
[18:03:59.159]     ...future.conditions <- base::list()
[18:03:59.159]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.159]     if (FALSE) {
[18:03:59.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.159]     }
[18:03:59.159]     ...future.result <- base::tryCatch({
[18:03:59.159]         base::withCallingHandlers({
[18:03:59.159]             ...future.value <- base::withVisible(base::local({
[18:03:59.159]                 if (ii%%2 == 0) 
[18:03:59.159]                   stop("Woops!")
[18:03:59.159]                 ii
[18:03:59.159]             }))
[18:03:59.159]             future::FutureResult(value = ...future.value$value, 
[18:03:59.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.159]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.159]                     ...future.globalenv.names))
[18:03:59.159]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.159]         }, condition = base::local({
[18:03:59.159]             c <- base::c
[18:03:59.159]             inherits <- base::inherits
[18:03:59.159]             invokeRestart <- base::invokeRestart
[18:03:59.159]             length <- base::length
[18:03:59.159]             list <- base::list
[18:03:59.159]             seq.int <- base::seq.int
[18:03:59.159]             signalCondition <- base::signalCondition
[18:03:59.159]             sys.calls <- base::sys.calls
[18:03:59.159]             `[[` <- base::`[[`
[18:03:59.159]             `+` <- base::`+`
[18:03:59.159]             `<<-` <- base::`<<-`
[18:03:59.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.159]                   3L)]
[18:03:59.159]             }
[18:03:59.159]             function(cond) {
[18:03:59.159]                 is_error <- inherits(cond, "error")
[18:03:59.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.159]                   NULL)
[18:03:59.159]                 if (is_error) {
[18:03:59.159]                   sessionInformation <- function() {
[18:03:59.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.159]                       search = base::search(), system = base::Sys.info())
[18:03:59.159]                   }
[18:03:59.159]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.159]                     cond$call), session = sessionInformation(), 
[18:03:59.159]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.159]                   signalCondition(cond)
[18:03:59.159]                 }
[18:03:59.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.159]                 "immediateCondition"))) {
[18:03:59.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.159]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.159]                   if (TRUE && !signal) {
[18:03:59.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.159]                     {
[18:03:59.159]                       inherits <- base::inherits
[18:03:59.159]                       invokeRestart <- base::invokeRestart
[18:03:59.159]                       is.null <- base::is.null
[18:03:59.159]                       muffled <- FALSE
[18:03:59.159]                       if (inherits(cond, "message")) {
[18:03:59.159]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.159]                         if (muffled) 
[18:03:59.159]                           invokeRestart("muffleMessage")
[18:03:59.159]                       }
[18:03:59.159]                       else if (inherits(cond, "warning")) {
[18:03:59.159]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.159]                         if (muffled) 
[18:03:59.159]                           invokeRestart("muffleWarning")
[18:03:59.159]                       }
[18:03:59.159]                       else if (inherits(cond, "condition")) {
[18:03:59.159]                         if (!is.null(pattern)) {
[18:03:59.159]                           computeRestarts <- base::computeRestarts
[18:03:59.159]                           grepl <- base::grepl
[18:03:59.159]                           restarts <- computeRestarts(cond)
[18:03:59.159]                           for (restart in restarts) {
[18:03:59.159]                             name <- restart$name
[18:03:59.159]                             if (is.null(name)) 
[18:03:59.159]                               next
[18:03:59.159]                             if (!grepl(pattern, name)) 
[18:03:59.159]                               next
[18:03:59.159]                             invokeRestart(restart)
[18:03:59.159]                             muffled <- TRUE
[18:03:59.159]                             break
[18:03:59.159]                           }
[18:03:59.159]                         }
[18:03:59.159]                       }
[18:03:59.159]                       invisible(muffled)
[18:03:59.159]                     }
[18:03:59.159]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.159]                   }
[18:03:59.159]                 }
[18:03:59.159]                 else {
[18:03:59.159]                   if (TRUE) {
[18:03:59.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.159]                     {
[18:03:59.159]                       inherits <- base::inherits
[18:03:59.159]                       invokeRestart <- base::invokeRestart
[18:03:59.159]                       is.null <- base::is.null
[18:03:59.159]                       muffled <- FALSE
[18:03:59.159]                       if (inherits(cond, "message")) {
[18:03:59.159]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.159]                         if (muffled) 
[18:03:59.159]                           invokeRestart("muffleMessage")
[18:03:59.159]                       }
[18:03:59.159]                       else if (inherits(cond, "warning")) {
[18:03:59.159]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.159]                         if (muffled) 
[18:03:59.159]                           invokeRestart("muffleWarning")
[18:03:59.159]                       }
[18:03:59.159]                       else if (inherits(cond, "condition")) {
[18:03:59.159]                         if (!is.null(pattern)) {
[18:03:59.159]                           computeRestarts <- base::computeRestarts
[18:03:59.159]                           grepl <- base::grepl
[18:03:59.159]                           restarts <- computeRestarts(cond)
[18:03:59.159]                           for (restart in restarts) {
[18:03:59.159]                             name <- restart$name
[18:03:59.159]                             if (is.null(name)) 
[18:03:59.159]                               next
[18:03:59.159]                             if (!grepl(pattern, name)) 
[18:03:59.159]                               next
[18:03:59.159]                             invokeRestart(restart)
[18:03:59.159]                             muffled <- TRUE
[18:03:59.159]                             break
[18:03:59.159]                           }
[18:03:59.159]                         }
[18:03:59.159]                       }
[18:03:59.159]                       invisible(muffled)
[18:03:59.159]                     }
[18:03:59.159]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.159]                   }
[18:03:59.159]                 }
[18:03:59.159]             }
[18:03:59.159]         }))
[18:03:59.159]     }, error = function(ex) {
[18:03:59.159]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.159]                 ...future.rng), started = ...future.startTime, 
[18:03:59.159]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.159]             version = "1.8"), class = "FutureResult")
[18:03:59.159]     }, finally = {
[18:03:59.159]         if (!identical(...future.workdir, getwd())) 
[18:03:59.159]             setwd(...future.workdir)
[18:03:59.159]         {
[18:03:59.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.159]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.159]             }
[18:03:59.159]             base::options(...future.oldOptions)
[18:03:59.159]             if (.Platform$OS.type == "windows") {
[18:03:59.159]                 old_names <- names(...future.oldEnvVars)
[18:03:59.159]                 envs <- base::Sys.getenv()
[18:03:59.159]                 names <- names(envs)
[18:03:59.159]                 common <- intersect(names, old_names)
[18:03:59.159]                 added <- setdiff(names, old_names)
[18:03:59.159]                 removed <- setdiff(old_names, names)
[18:03:59.159]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.159]                   envs[common]]
[18:03:59.159]                 NAMES <- toupper(changed)
[18:03:59.159]                 args <- list()
[18:03:59.159]                 for (kk in seq_along(NAMES)) {
[18:03:59.159]                   name <- changed[[kk]]
[18:03:59.159]                   NAME <- NAMES[[kk]]
[18:03:59.159]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.159]                     next
[18:03:59.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.159]                 }
[18:03:59.159]                 NAMES <- toupper(added)
[18:03:59.159]                 for (kk in seq_along(NAMES)) {
[18:03:59.159]                   name <- added[[kk]]
[18:03:59.159]                   NAME <- NAMES[[kk]]
[18:03:59.159]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.159]                     next
[18:03:59.159]                   args[[name]] <- ""
[18:03:59.159]                 }
[18:03:59.159]                 NAMES <- toupper(removed)
[18:03:59.159]                 for (kk in seq_along(NAMES)) {
[18:03:59.159]                   name <- removed[[kk]]
[18:03:59.159]                   NAME <- NAMES[[kk]]
[18:03:59.159]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.159]                     next
[18:03:59.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.159]                 }
[18:03:59.159]                 if (length(args) > 0) 
[18:03:59.159]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.159]             }
[18:03:59.159]             else {
[18:03:59.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.159]             }
[18:03:59.159]             {
[18:03:59.159]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.159]                   0L) {
[18:03:59.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.159]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.159]                   base::options(opts)
[18:03:59.159]                 }
[18:03:59.159]                 {
[18:03:59.159]                   {
[18:03:59.159]                     NULL
[18:03:59.159]                     RNGkind("Mersenne-Twister")
[18:03:59.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.159]                       inherits = FALSE)
[18:03:59.159]                   }
[18:03:59.159]                   options(future.plan = NULL)
[18:03:59.159]                   if (is.na(NA_character_)) 
[18:03:59.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.159]                     .init = FALSE)
[18:03:59.159]                 }
[18:03:59.159]             }
[18:03:59.159]         }
[18:03:59.159]     })
[18:03:59.159]     if (TRUE) {
[18:03:59.159]         base::sink(type = "output", split = FALSE)
[18:03:59.159]         if (TRUE) {
[18:03:59.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.159]         }
[18:03:59.159]         else {
[18:03:59.159]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.159]         }
[18:03:59.159]         base::close(...future.stdout)
[18:03:59.159]         ...future.stdout <- NULL
[18:03:59.159]     }
[18:03:59.159]     ...future.result$conditions <- ...future.conditions
[18:03:59.159]     ...future.result$finished <- base::Sys.time()
[18:03:59.159]     ...future.result
[18:03:59.159] }
[18:03:59.163] assign_globals() ...
[18:03:59.163] List of 1
[18:03:59.163]  $ ii: int 1
[18:03:59.163]  - attr(*, "where")=List of 1
[18:03:59.163]   ..$ ii:<environment: R_EmptyEnv> 
[18:03:59.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.163]  - attr(*, "resolved")= logi FALSE
[18:03:59.163]  - attr(*, "total_size")= num 56
[18:03:59.163]  - attr(*, "already-done")= logi TRUE
[18:03:59.170] - copied ‘ii’ to environment
[18:03:59.170] assign_globals() ... done
[18:03:59.171] plan(): Setting new future strategy stack:
[18:03:59.171] List of future strategies:
[18:03:59.171] 1. sequential:
[18:03:59.171]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.171]    - tweaked: FALSE
[18:03:59.171]    - call: NULL
[18:03:59.172] plan(): nbrOfWorkers() = 1
[18:03:59.173] plan(): Setting new future strategy stack:
[18:03:59.174] List of future strategies:
[18:03:59.174] 1. sequential:
[18:03:59.174]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.174]    - tweaked: FALSE
[18:03:59.174]    - call: plan(strategy)
[18:03:59.174] plan(): nbrOfWorkers() = 1
[18:03:59.175] SequentialFuture started (and completed)
[18:03:59.175] - Launch lazy future ... done
[18:03:59.175] run() for ‘SequentialFuture’ ... done
[18:03:59.176] getGlobalsAndPackages() ...
[18:03:59.176] Searching for globals...
[18:03:59.180] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:03:59.180] Searching for globals ... DONE
[18:03:59.180] Resolving globals: FALSE
[18:03:59.181] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.182] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:03:59.182] - globals: [1] ‘ii’
[18:03:59.183] 
[18:03:59.185] getGlobalsAndPackages() ... DONE
[18:03:59.186] run() for ‘Future’ ...
[18:03:59.186] - state: ‘created’
[18:03:59.187] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.187] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.188]   - Field: ‘label’
[18:03:59.188]   - Field: ‘local’
[18:03:59.188]   - Field: ‘owner’
[18:03:59.188]   - Field: ‘envir’
[18:03:59.189]   - Field: ‘packages’
[18:03:59.189]   - Field: ‘gc’
[18:03:59.189]   - Field: ‘conditions’
[18:03:59.189]   - Field: ‘expr’
[18:03:59.189]   - Field: ‘uuid’
[18:03:59.190]   - Field: ‘seed’
[18:03:59.190]   - Field: ‘version’
[18:03:59.190]   - Field: ‘result’
[18:03:59.190]   - Field: ‘asynchronous’
[18:03:59.190]   - Field: ‘calls’
[18:03:59.191]   - Field: ‘globals’
[18:03:59.191]   - Field: ‘stdout’
[18:03:59.191]   - Field: ‘earlySignal’
[18:03:59.191]   - Field: ‘lazy’
[18:03:59.191]   - Field: ‘state’
[18:03:59.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.192] - Launch lazy future ...
[18:03:59.192] Packages needed by the future expression (n = 0): <none>
[18:03:59.192] Packages needed by future strategies (n = 0): <none>
[18:03:59.193] {
[18:03:59.193]     {
[18:03:59.193]         {
[18:03:59.193]             ...future.startTime <- base::Sys.time()
[18:03:59.193]             {
[18:03:59.193]                 {
[18:03:59.193]                   {
[18:03:59.193]                     base::local({
[18:03:59.193]                       has_future <- base::requireNamespace("future", 
[18:03:59.193]                         quietly = TRUE)
[18:03:59.193]                       if (has_future) {
[18:03:59.193]                         ns <- base::getNamespace("future")
[18:03:59.193]                         version <- ns[[".package"]][["version"]]
[18:03:59.193]                         if (is.null(version)) 
[18:03:59.193]                           version <- utils::packageVersion("future")
[18:03:59.193]                       }
[18:03:59.193]                       else {
[18:03:59.193]                         version <- NULL
[18:03:59.193]                       }
[18:03:59.193]                       if (!has_future || version < "1.8.0") {
[18:03:59.193]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.193]                           "", base::R.version$version.string), 
[18:03:59.193]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.193]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.193]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.193]                             "release", "version")], collapse = " "), 
[18:03:59.193]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.193]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.193]                           info)
[18:03:59.193]                         info <- base::paste(info, collapse = "; ")
[18:03:59.193]                         if (!has_future) {
[18:03:59.193]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.193]                             info)
[18:03:59.193]                         }
[18:03:59.193]                         else {
[18:03:59.193]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.193]                             info, version)
[18:03:59.193]                         }
[18:03:59.193]                         base::stop(msg)
[18:03:59.193]                       }
[18:03:59.193]                     })
[18:03:59.193]                   }
[18:03:59.193]                   ...future.strategy.old <- future::plan("list")
[18:03:59.193]                   options(future.plan = NULL)
[18:03:59.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.193]                 }
[18:03:59.193]                 ...future.workdir <- getwd()
[18:03:59.193]             }
[18:03:59.193]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.193]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.193]         }
[18:03:59.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.193]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.193]             base::names(...future.oldOptions))
[18:03:59.193]     }
[18:03:59.193]     if (FALSE) {
[18:03:59.193]     }
[18:03:59.193]     else {
[18:03:59.193]         if (TRUE) {
[18:03:59.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.193]                 open = "w")
[18:03:59.193]         }
[18:03:59.193]         else {
[18:03:59.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.193]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.193]         }
[18:03:59.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.193]             base::sink(type = "output", split = FALSE)
[18:03:59.193]             base::close(...future.stdout)
[18:03:59.193]         }, add = TRUE)
[18:03:59.193]     }
[18:03:59.193]     ...future.frame <- base::sys.nframe()
[18:03:59.193]     ...future.conditions <- base::list()
[18:03:59.193]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.193]     if (FALSE) {
[18:03:59.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.193]     }
[18:03:59.193]     ...future.result <- base::tryCatch({
[18:03:59.193]         base::withCallingHandlers({
[18:03:59.193]             ...future.value <- base::withVisible(base::local({
[18:03:59.193]                 if (ii%%2 == 0) 
[18:03:59.193]                   stop("Woops!")
[18:03:59.193]                 ii
[18:03:59.193]             }))
[18:03:59.193]             future::FutureResult(value = ...future.value$value, 
[18:03:59.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.193]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.193]                     ...future.globalenv.names))
[18:03:59.193]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.193]         }, condition = base::local({
[18:03:59.193]             c <- base::c
[18:03:59.193]             inherits <- base::inherits
[18:03:59.193]             invokeRestart <- base::invokeRestart
[18:03:59.193]             length <- base::length
[18:03:59.193]             list <- base::list
[18:03:59.193]             seq.int <- base::seq.int
[18:03:59.193]             signalCondition <- base::signalCondition
[18:03:59.193]             sys.calls <- base::sys.calls
[18:03:59.193]             `[[` <- base::`[[`
[18:03:59.193]             `+` <- base::`+`
[18:03:59.193]             `<<-` <- base::`<<-`
[18:03:59.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.193]                   3L)]
[18:03:59.193]             }
[18:03:59.193]             function(cond) {
[18:03:59.193]                 is_error <- inherits(cond, "error")
[18:03:59.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.193]                   NULL)
[18:03:59.193]                 if (is_error) {
[18:03:59.193]                   sessionInformation <- function() {
[18:03:59.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.193]                       search = base::search(), system = base::Sys.info())
[18:03:59.193]                   }
[18:03:59.193]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.193]                     cond$call), session = sessionInformation(), 
[18:03:59.193]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.193]                   signalCondition(cond)
[18:03:59.193]                 }
[18:03:59.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.193]                 "immediateCondition"))) {
[18:03:59.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.193]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.193]                   if (TRUE && !signal) {
[18:03:59.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.193]                     {
[18:03:59.193]                       inherits <- base::inherits
[18:03:59.193]                       invokeRestart <- base::invokeRestart
[18:03:59.193]                       is.null <- base::is.null
[18:03:59.193]                       muffled <- FALSE
[18:03:59.193]                       if (inherits(cond, "message")) {
[18:03:59.193]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.193]                         if (muffled) 
[18:03:59.193]                           invokeRestart("muffleMessage")
[18:03:59.193]                       }
[18:03:59.193]                       else if (inherits(cond, "warning")) {
[18:03:59.193]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.193]                         if (muffled) 
[18:03:59.193]                           invokeRestart("muffleWarning")
[18:03:59.193]                       }
[18:03:59.193]                       else if (inherits(cond, "condition")) {
[18:03:59.193]                         if (!is.null(pattern)) {
[18:03:59.193]                           computeRestarts <- base::computeRestarts
[18:03:59.193]                           grepl <- base::grepl
[18:03:59.193]                           restarts <- computeRestarts(cond)
[18:03:59.193]                           for (restart in restarts) {
[18:03:59.193]                             name <- restart$name
[18:03:59.193]                             if (is.null(name)) 
[18:03:59.193]                               next
[18:03:59.193]                             if (!grepl(pattern, name)) 
[18:03:59.193]                               next
[18:03:59.193]                             invokeRestart(restart)
[18:03:59.193]                             muffled <- TRUE
[18:03:59.193]                             break
[18:03:59.193]                           }
[18:03:59.193]                         }
[18:03:59.193]                       }
[18:03:59.193]                       invisible(muffled)
[18:03:59.193]                     }
[18:03:59.193]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.193]                   }
[18:03:59.193]                 }
[18:03:59.193]                 else {
[18:03:59.193]                   if (TRUE) {
[18:03:59.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.193]                     {
[18:03:59.193]                       inherits <- base::inherits
[18:03:59.193]                       invokeRestart <- base::invokeRestart
[18:03:59.193]                       is.null <- base::is.null
[18:03:59.193]                       muffled <- FALSE
[18:03:59.193]                       if (inherits(cond, "message")) {
[18:03:59.193]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.193]                         if (muffled) 
[18:03:59.193]                           invokeRestart("muffleMessage")
[18:03:59.193]                       }
[18:03:59.193]                       else if (inherits(cond, "warning")) {
[18:03:59.193]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.193]                         if (muffled) 
[18:03:59.193]                           invokeRestart("muffleWarning")
[18:03:59.193]                       }
[18:03:59.193]                       else if (inherits(cond, "condition")) {
[18:03:59.193]                         if (!is.null(pattern)) {
[18:03:59.193]                           computeRestarts <- base::computeRestarts
[18:03:59.193]                           grepl <- base::grepl
[18:03:59.193]                           restarts <- computeRestarts(cond)
[18:03:59.193]                           for (restart in restarts) {
[18:03:59.193]                             name <- restart$name
[18:03:59.193]                             if (is.null(name)) 
[18:03:59.193]                               next
[18:03:59.193]                             if (!grepl(pattern, name)) 
[18:03:59.193]                               next
[18:03:59.193]                             invokeRestart(restart)
[18:03:59.193]                             muffled <- TRUE
[18:03:59.193]                             break
[18:03:59.193]                           }
[18:03:59.193]                         }
[18:03:59.193]                       }
[18:03:59.193]                       invisible(muffled)
[18:03:59.193]                     }
[18:03:59.193]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.193]                   }
[18:03:59.193]                 }
[18:03:59.193]             }
[18:03:59.193]         }))
[18:03:59.193]     }, error = function(ex) {
[18:03:59.193]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.193]                 ...future.rng), started = ...future.startTime, 
[18:03:59.193]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.193]             version = "1.8"), class = "FutureResult")
[18:03:59.193]     }, finally = {
[18:03:59.193]         if (!identical(...future.workdir, getwd())) 
[18:03:59.193]             setwd(...future.workdir)
[18:03:59.193]         {
[18:03:59.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.193]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.193]             }
[18:03:59.193]             base::options(...future.oldOptions)
[18:03:59.193]             if (.Platform$OS.type == "windows") {
[18:03:59.193]                 old_names <- names(...future.oldEnvVars)
[18:03:59.193]                 envs <- base::Sys.getenv()
[18:03:59.193]                 names <- names(envs)
[18:03:59.193]                 common <- intersect(names, old_names)
[18:03:59.193]                 added <- setdiff(names, old_names)
[18:03:59.193]                 removed <- setdiff(old_names, names)
[18:03:59.193]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.193]                   envs[common]]
[18:03:59.193]                 NAMES <- toupper(changed)
[18:03:59.193]                 args <- list()
[18:03:59.193]                 for (kk in seq_along(NAMES)) {
[18:03:59.193]                   name <- changed[[kk]]
[18:03:59.193]                   NAME <- NAMES[[kk]]
[18:03:59.193]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.193]                     next
[18:03:59.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.193]                 }
[18:03:59.193]                 NAMES <- toupper(added)
[18:03:59.193]                 for (kk in seq_along(NAMES)) {
[18:03:59.193]                   name <- added[[kk]]
[18:03:59.193]                   NAME <- NAMES[[kk]]
[18:03:59.193]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.193]                     next
[18:03:59.193]                   args[[name]] <- ""
[18:03:59.193]                 }
[18:03:59.193]                 NAMES <- toupper(removed)
[18:03:59.193]                 for (kk in seq_along(NAMES)) {
[18:03:59.193]                   name <- removed[[kk]]
[18:03:59.193]                   NAME <- NAMES[[kk]]
[18:03:59.193]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.193]                     next
[18:03:59.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.193]                 }
[18:03:59.193]                 if (length(args) > 0) 
[18:03:59.193]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.193]             }
[18:03:59.193]             else {
[18:03:59.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.193]             }
[18:03:59.193]             {
[18:03:59.193]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.193]                   0L) {
[18:03:59.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.193]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.193]                   base::options(opts)
[18:03:59.193]                 }
[18:03:59.193]                 {
[18:03:59.193]                   {
[18:03:59.193]                     NULL
[18:03:59.193]                     RNGkind("Mersenne-Twister")
[18:03:59.193]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.193]                       inherits = FALSE)
[18:03:59.193]                   }
[18:03:59.193]                   options(future.plan = NULL)
[18:03:59.193]                   if (is.na(NA_character_)) 
[18:03:59.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.193]                     .init = FALSE)
[18:03:59.193]                 }
[18:03:59.193]             }
[18:03:59.193]         }
[18:03:59.193]     })
[18:03:59.193]     if (TRUE) {
[18:03:59.193]         base::sink(type = "output", split = FALSE)
[18:03:59.193]         if (TRUE) {
[18:03:59.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.193]         }
[18:03:59.193]         else {
[18:03:59.193]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.193]         }
[18:03:59.193]         base::close(...future.stdout)
[18:03:59.193]         ...future.stdout <- NULL
[18:03:59.193]     }
[18:03:59.193]     ...future.result$conditions <- ...future.conditions
[18:03:59.193]     ...future.result$finished <- base::Sys.time()
[18:03:59.193]     ...future.result
[18:03:59.193] }
[18:03:59.197] assign_globals() ...
[18:03:59.197] List of 1
[18:03:59.197]  $ ii: int 2
[18:03:59.197]  - attr(*, "where")=List of 1
[18:03:59.197]   ..$ ii:<environment: R_EmptyEnv> 
[18:03:59.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.197]  - attr(*, "resolved")= logi FALSE
[18:03:59.197]  - attr(*, "total_size")= num 56
[18:03:59.197]  - attr(*, "already-done")= logi TRUE
[18:03:59.202] - copied ‘ii’ to environment
[18:03:59.203] assign_globals() ... done
[18:03:59.203] plan(): Setting new future strategy stack:
[18:03:59.203] List of future strategies:
[18:03:59.203] 1. sequential:
[18:03:59.203]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.203]    - tweaked: FALSE
[18:03:59.203]    - call: NULL
[18:03:59.204] plan(): nbrOfWorkers() = 1
[18:03:59.206] plan(): Setting new future strategy stack:
[18:03:59.207] List of future strategies:
[18:03:59.207] 1. sequential:
[18:03:59.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.207]    - tweaked: FALSE
[18:03:59.207]    - call: plan(strategy)
[18:03:59.208] plan(): nbrOfWorkers() = 1
[18:03:59.208] SequentialFuture started (and completed)
[18:03:59.208] signalConditions() ...
[18:03:59.208]  - include = ‘immediateCondition’
[18:03:59.209]  - exclude = 
[18:03:59.209]  - resignal = FALSE
[18:03:59.209]  - Number of conditions: 1
[18:03:59.209] signalConditions() ... done
[18:03:59.210] - Launch lazy future ... done
[18:03:59.210] run() for ‘SequentialFuture’ ... done
[18:03:59.211] getGlobalsAndPackages() ...
[18:03:59.211] Searching for globals...
[18:03:59.214] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:03:59.214] Searching for globals ... DONE
[18:03:59.215] Resolving globals: FALSE
[18:03:59.216] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.216] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:03:59.217] - globals: [1] ‘ii’
[18:03:59.217] 
[18:03:59.217] getGlobalsAndPackages() ... DONE
[18:03:59.218] run() for ‘Future’ ...
[18:03:59.218] - state: ‘created’
[18:03:59.218] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.219] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.219]   - Field: ‘label’
[18:03:59.219]   - Field: ‘local’
[18:03:59.220]   - Field: ‘owner’
[18:03:59.220]   - Field: ‘envir’
[18:03:59.220]   - Field: ‘packages’
[18:03:59.220]   - Field: ‘gc’
[18:03:59.220]   - Field: ‘conditions’
[18:03:59.221]   - Field: ‘expr’
[18:03:59.221]   - Field: ‘uuid’
[18:03:59.221]   - Field: ‘seed’
[18:03:59.221]   - Field: ‘version’
[18:03:59.221]   - Field: ‘result’
[18:03:59.222]   - Field: ‘asynchronous’
[18:03:59.222]   - Field: ‘calls’
[18:03:59.222]   - Field: ‘globals’
[18:03:59.222]   - Field: ‘stdout’
[18:03:59.222]   - Field: ‘earlySignal’
[18:03:59.223]   - Field: ‘lazy’
[18:03:59.223]   - Field: ‘state’
[18:03:59.223] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.223] - Launch lazy future ...
[18:03:59.224] Packages needed by the future expression (n = 0): <none>
[18:03:59.224] Packages needed by future strategies (n = 0): <none>
[18:03:59.225] {
[18:03:59.225]     {
[18:03:59.225]         {
[18:03:59.225]             ...future.startTime <- base::Sys.time()
[18:03:59.225]             {
[18:03:59.225]                 {
[18:03:59.225]                   {
[18:03:59.225]                     base::local({
[18:03:59.225]                       has_future <- base::requireNamespace("future", 
[18:03:59.225]                         quietly = TRUE)
[18:03:59.225]                       if (has_future) {
[18:03:59.225]                         ns <- base::getNamespace("future")
[18:03:59.225]                         version <- ns[[".package"]][["version"]]
[18:03:59.225]                         if (is.null(version)) 
[18:03:59.225]                           version <- utils::packageVersion("future")
[18:03:59.225]                       }
[18:03:59.225]                       else {
[18:03:59.225]                         version <- NULL
[18:03:59.225]                       }
[18:03:59.225]                       if (!has_future || version < "1.8.0") {
[18:03:59.225]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.225]                           "", base::R.version$version.string), 
[18:03:59.225]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.225]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.225]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.225]                             "release", "version")], collapse = " "), 
[18:03:59.225]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.225]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.225]                           info)
[18:03:59.225]                         info <- base::paste(info, collapse = "; ")
[18:03:59.225]                         if (!has_future) {
[18:03:59.225]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.225]                             info)
[18:03:59.225]                         }
[18:03:59.225]                         else {
[18:03:59.225]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.225]                             info, version)
[18:03:59.225]                         }
[18:03:59.225]                         base::stop(msg)
[18:03:59.225]                       }
[18:03:59.225]                     })
[18:03:59.225]                   }
[18:03:59.225]                   ...future.strategy.old <- future::plan("list")
[18:03:59.225]                   options(future.plan = NULL)
[18:03:59.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.225]                 }
[18:03:59.225]                 ...future.workdir <- getwd()
[18:03:59.225]             }
[18:03:59.225]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.225]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.225]         }
[18:03:59.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.225]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.225]             base::names(...future.oldOptions))
[18:03:59.225]     }
[18:03:59.225]     if (FALSE) {
[18:03:59.225]     }
[18:03:59.225]     else {
[18:03:59.225]         if (TRUE) {
[18:03:59.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.225]                 open = "w")
[18:03:59.225]         }
[18:03:59.225]         else {
[18:03:59.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.225]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.225]         }
[18:03:59.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.225]             base::sink(type = "output", split = FALSE)
[18:03:59.225]             base::close(...future.stdout)
[18:03:59.225]         }, add = TRUE)
[18:03:59.225]     }
[18:03:59.225]     ...future.frame <- base::sys.nframe()
[18:03:59.225]     ...future.conditions <- base::list()
[18:03:59.225]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.225]     if (FALSE) {
[18:03:59.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.225]     }
[18:03:59.225]     ...future.result <- base::tryCatch({
[18:03:59.225]         base::withCallingHandlers({
[18:03:59.225]             ...future.value <- base::withVisible(base::local({
[18:03:59.225]                 if (ii%%2 == 0) 
[18:03:59.225]                   stop("Woops!")
[18:03:59.225]                 ii
[18:03:59.225]             }))
[18:03:59.225]             future::FutureResult(value = ...future.value$value, 
[18:03:59.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.225]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.225]                     ...future.globalenv.names))
[18:03:59.225]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.225]         }, condition = base::local({
[18:03:59.225]             c <- base::c
[18:03:59.225]             inherits <- base::inherits
[18:03:59.225]             invokeRestart <- base::invokeRestart
[18:03:59.225]             length <- base::length
[18:03:59.225]             list <- base::list
[18:03:59.225]             seq.int <- base::seq.int
[18:03:59.225]             signalCondition <- base::signalCondition
[18:03:59.225]             sys.calls <- base::sys.calls
[18:03:59.225]             `[[` <- base::`[[`
[18:03:59.225]             `+` <- base::`+`
[18:03:59.225]             `<<-` <- base::`<<-`
[18:03:59.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.225]                   3L)]
[18:03:59.225]             }
[18:03:59.225]             function(cond) {
[18:03:59.225]                 is_error <- inherits(cond, "error")
[18:03:59.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.225]                   NULL)
[18:03:59.225]                 if (is_error) {
[18:03:59.225]                   sessionInformation <- function() {
[18:03:59.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.225]                       search = base::search(), system = base::Sys.info())
[18:03:59.225]                   }
[18:03:59.225]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.225]                     cond$call), session = sessionInformation(), 
[18:03:59.225]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.225]                   signalCondition(cond)
[18:03:59.225]                 }
[18:03:59.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.225]                 "immediateCondition"))) {
[18:03:59.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.225]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.225]                   if (TRUE && !signal) {
[18:03:59.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.225]                     {
[18:03:59.225]                       inherits <- base::inherits
[18:03:59.225]                       invokeRestart <- base::invokeRestart
[18:03:59.225]                       is.null <- base::is.null
[18:03:59.225]                       muffled <- FALSE
[18:03:59.225]                       if (inherits(cond, "message")) {
[18:03:59.225]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.225]                         if (muffled) 
[18:03:59.225]                           invokeRestart("muffleMessage")
[18:03:59.225]                       }
[18:03:59.225]                       else if (inherits(cond, "warning")) {
[18:03:59.225]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.225]                         if (muffled) 
[18:03:59.225]                           invokeRestart("muffleWarning")
[18:03:59.225]                       }
[18:03:59.225]                       else if (inherits(cond, "condition")) {
[18:03:59.225]                         if (!is.null(pattern)) {
[18:03:59.225]                           computeRestarts <- base::computeRestarts
[18:03:59.225]                           grepl <- base::grepl
[18:03:59.225]                           restarts <- computeRestarts(cond)
[18:03:59.225]                           for (restart in restarts) {
[18:03:59.225]                             name <- restart$name
[18:03:59.225]                             if (is.null(name)) 
[18:03:59.225]                               next
[18:03:59.225]                             if (!grepl(pattern, name)) 
[18:03:59.225]                               next
[18:03:59.225]                             invokeRestart(restart)
[18:03:59.225]                             muffled <- TRUE
[18:03:59.225]                             break
[18:03:59.225]                           }
[18:03:59.225]                         }
[18:03:59.225]                       }
[18:03:59.225]                       invisible(muffled)
[18:03:59.225]                     }
[18:03:59.225]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.225]                   }
[18:03:59.225]                 }
[18:03:59.225]                 else {
[18:03:59.225]                   if (TRUE) {
[18:03:59.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.225]                     {
[18:03:59.225]                       inherits <- base::inherits
[18:03:59.225]                       invokeRestart <- base::invokeRestart
[18:03:59.225]                       is.null <- base::is.null
[18:03:59.225]                       muffled <- FALSE
[18:03:59.225]                       if (inherits(cond, "message")) {
[18:03:59.225]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.225]                         if (muffled) 
[18:03:59.225]                           invokeRestart("muffleMessage")
[18:03:59.225]                       }
[18:03:59.225]                       else if (inherits(cond, "warning")) {
[18:03:59.225]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.225]                         if (muffled) 
[18:03:59.225]                           invokeRestart("muffleWarning")
[18:03:59.225]                       }
[18:03:59.225]                       else if (inherits(cond, "condition")) {
[18:03:59.225]                         if (!is.null(pattern)) {
[18:03:59.225]                           computeRestarts <- base::computeRestarts
[18:03:59.225]                           grepl <- base::grepl
[18:03:59.225]                           restarts <- computeRestarts(cond)
[18:03:59.225]                           for (restart in restarts) {
[18:03:59.225]                             name <- restart$name
[18:03:59.225]                             if (is.null(name)) 
[18:03:59.225]                               next
[18:03:59.225]                             if (!grepl(pattern, name)) 
[18:03:59.225]                               next
[18:03:59.225]                             invokeRestart(restart)
[18:03:59.225]                             muffled <- TRUE
[18:03:59.225]                             break
[18:03:59.225]                           }
[18:03:59.225]                         }
[18:03:59.225]                       }
[18:03:59.225]                       invisible(muffled)
[18:03:59.225]                     }
[18:03:59.225]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.225]                   }
[18:03:59.225]                 }
[18:03:59.225]             }
[18:03:59.225]         }))
[18:03:59.225]     }, error = function(ex) {
[18:03:59.225]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.225]                 ...future.rng), started = ...future.startTime, 
[18:03:59.225]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.225]             version = "1.8"), class = "FutureResult")
[18:03:59.225]     }, finally = {
[18:03:59.225]         if (!identical(...future.workdir, getwd())) 
[18:03:59.225]             setwd(...future.workdir)
[18:03:59.225]         {
[18:03:59.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.225]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.225]             }
[18:03:59.225]             base::options(...future.oldOptions)
[18:03:59.225]             if (.Platform$OS.type == "windows") {
[18:03:59.225]                 old_names <- names(...future.oldEnvVars)
[18:03:59.225]                 envs <- base::Sys.getenv()
[18:03:59.225]                 names <- names(envs)
[18:03:59.225]                 common <- intersect(names, old_names)
[18:03:59.225]                 added <- setdiff(names, old_names)
[18:03:59.225]                 removed <- setdiff(old_names, names)
[18:03:59.225]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.225]                   envs[common]]
[18:03:59.225]                 NAMES <- toupper(changed)
[18:03:59.225]                 args <- list()
[18:03:59.225]                 for (kk in seq_along(NAMES)) {
[18:03:59.225]                   name <- changed[[kk]]
[18:03:59.225]                   NAME <- NAMES[[kk]]
[18:03:59.225]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.225]                     next
[18:03:59.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.225]                 }
[18:03:59.225]                 NAMES <- toupper(added)
[18:03:59.225]                 for (kk in seq_along(NAMES)) {
[18:03:59.225]                   name <- added[[kk]]
[18:03:59.225]                   NAME <- NAMES[[kk]]
[18:03:59.225]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.225]                     next
[18:03:59.225]                   args[[name]] <- ""
[18:03:59.225]                 }
[18:03:59.225]                 NAMES <- toupper(removed)
[18:03:59.225]                 for (kk in seq_along(NAMES)) {
[18:03:59.225]                   name <- removed[[kk]]
[18:03:59.225]                   NAME <- NAMES[[kk]]
[18:03:59.225]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.225]                     next
[18:03:59.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.225]                 }
[18:03:59.225]                 if (length(args) > 0) 
[18:03:59.225]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.225]             }
[18:03:59.225]             else {
[18:03:59.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.225]             }
[18:03:59.225]             {
[18:03:59.225]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.225]                   0L) {
[18:03:59.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.225]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.225]                   base::options(opts)
[18:03:59.225]                 }
[18:03:59.225]                 {
[18:03:59.225]                   {
[18:03:59.225]                     NULL
[18:03:59.225]                     RNGkind("Mersenne-Twister")
[18:03:59.225]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.225]                       inherits = FALSE)
[18:03:59.225]                   }
[18:03:59.225]                   options(future.plan = NULL)
[18:03:59.225]                   if (is.na(NA_character_)) 
[18:03:59.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.225]                     .init = FALSE)
[18:03:59.225]                 }
[18:03:59.225]             }
[18:03:59.225]         }
[18:03:59.225]     })
[18:03:59.225]     if (TRUE) {
[18:03:59.225]         base::sink(type = "output", split = FALSE)
[18:03:59.225]         if (TRUE) {
[18:03:59.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.225]         }
[18:03:59.225]         else {
[18:03:59.225]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.225]         }
[18:03:59.225]         base::close(...future.stdout)
[18:03:59.225]         ...future.stdout <- NULL
[18:03:59.225]     }
[18:03:59.225]     ...future.result$conditions <- ...future.conditions
[18:03:59.225]     ...future.result$finished <- base::Sys.time()
[18:03:59.225]     ...future.result
[18:03:59.225] }
[18:03:59.231] assign_globals() ...
[18:03:59.231] List of 1
[18:03:59.231]  $ ii: int 3
[18:03:59.231]  - attr(*, "where")=List of 1
[18:03:59.231]   ..$ ii:<environment: R_EmptyEnv> 
[18:03:59.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.231]  - attr(*, "resolved")= logi FALSE
[18:03:59.231]  - attr(*, "total_size")= num 56
[18:03:59.231]  - attr(*, "already-done")= logi TRUE
[18:03:59.243] - copied ‘ii’ to environment
[18:03:59.243] assign_globals() ... done
[18:03:59.244] plan(): Setting new future strategy stack:
[18:03:59.245] List of future strategies:
[18:03:59.245] 1. sequential:
[18:03:59.245]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.245]    - tweaked: FALSE
[18:03:59.245]    - call: NULL
[18:03:59.247] plan(): nbrOfWorkers() = 1
[18:03:59.248] plan(): Setting new future strategy stack:
[18:03:59.248] List of future strategies:
[18:03:59.248] 1. sequential:
[18:03:59.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.248]    - tweaked: FALSE
[18:03:59.248]    - call: plan(strategy)
[18:03:59.250] plan(): nbrOfWorkers() = 1
[18:03:59.250] SequentialFuture started (and completed)
[18:03:59.250] - Launch lazy future ... done
[18:03:59.250] run() for ‘SequentialFuture’ ... done
[18:03:59.251] signalConditions() ...
[18:03:59.251]  - include = ‘immediateCondition’
[18:03:59.252]  - exclude = 
[18:03:59.252]  - resignal = FALSE
[18:03:59.252]  - Number of conditions: 1
[18:03:59.252] signalConditions() ... done
[18:03:59.253] Future state: ‘finished’
[18:03:59.253] signalConditions() ...
[18:03:59.253]  - include = ‘condition’
[18:03:59.253]  - exclude = ‘immediateCondition’
[18:03:59.253]  - resignal = TRUE
[18:03:59.254]  - Number of conditions: 1
[18:03:59.254]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:03:59.254] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[18:03:59.256] signalConditions() ...
[18:03:59.257]  - include = ‘immediateCondition’
[18:03:59.257]  - exclude = 
[18:03:59.257]  - resignal = FALSE
[18:03:59.257]  - Number of conditions: 1
[18:03:59.257] signalConditions() ... done
[18:03:59.258] Future state: ‘finished’
[18:03:59.258] signalConditions() ...
[18:03:59.258]  - include = ‘condition’
[18:03:59.258]  - exclude = ‘immediateCondition’
[18:03:59.259]  - resignal = TRUE
[18:03:59.259]  - Number of conditions: 1
[18:03:59.259]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:03:59.259] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[18:03:59.260] signalConditions() ...
[18:03:59.263]  - include = ‘immediateCondition’
[18:03:59.263]  - exclude = 
[18:03:59.263]  - resignal = FALSE
[18:03:59.264]  - Number of conditions: 1
[18:03:59.264] signalConditions() ... done
[18:03:59.264] Future state: ‘finished’
[18:03:59.264] signalConditions() ...
[18:03:59.264]  - include = ‘condition’
[18:03:59.265]  - exclude = ‘immediateCondition’
[18:03:59.265]  - resignal = TRUE
[18:03:59.265]  - Number of conditions: 1
[18:03:59.265]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:03:59.266] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[18:03:59.266] getGlobalsAndPackages() ...
[18:03:59.267] Searching for globals...
[18:03:59.271] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[18:03:59.271] Searching for globals ... DONE
[18:03:59.271] Resolving globals: FALSE
[18:03:59.272] 
[18:03:59.272] 
[18:03:59.273] getGlobalsAndPackages() ... DONE
[18:03:59.273] run() for ‘Future’ ...
[18:03:59.273] - state: ‘created’
[18:03:59.274] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.275]   - Field: ‘label’
[18:03:59.275]   - Field: ‘local’
[18:03:59.275]   - Field: ‘owner’
[18:03:59.275]   - Field: ‘envir’
[18:03:59.276]   - Field: ‘packages’
[18:03:59.276]   - Field: ‘gc’
[18:03:59.276]   - Field: ‘conditions’
[18:03:59.276]   - Field: ‘expr’
[18:03:59.276]   - Field: ‘uuid’
[18:03:59.277]   - Field: ‘seed’
[18:03:59.277]   - Field: ‘version’
[18:03:59.277]   - Field: ‘result’
[18:03:59.278]   - Field: ‘asynchronous’
[18:03:59.278]   - Field: ‘calls’
[18:03:59.278]   - Field: ‘globals’
[18:03:59.278]   - Field: ‘stdout’
[18:03:59.278]   - Field: ‘earlySignal’
[18:03:59.278]   - Field: ‘lazy’
[18:03:59.279]   - Field: ‘state’
[18:03:59.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.279] - Launch lazy future ...
[18:03:59.280] Packages needed by the future expression (n = 0): <none>
[18:03:59.280] Packages needed by future strategies (n = 0): <none>
[18:03:59.281] {
[18:03:59.281]     {
[18:03:59.281]         {
[18:03:59.281]             ...future.startTime <- base::Sys.time()
[18:03:59.281]             {
[18:03:59.281]                 {
[18:03:59.281]                   {
[18:03:59.281]                     base::local({
[18:03:59.281]                       has_future <- base::requireNamespace("future", 
[18:03:59.281]                         quietly = TRUE)
[18:03:59.281]                       if (has_future) {
[18:03:59.281]                         ns <- base::getNamespace("future")
[18:03:59.281]                         version <- ns[[".package"]][["version"]]
[18:03:59.281]                         if (is.null(version)) 
[18:03:59.281]                           version <- utils::packageVersion("future")
[18:03:59.281]                       }
[18:03:59.281]                       else {
[18:03:59.281]                         version <- NULL
[18:03:59.281]                       }
[18:03:59.281]                       if (!has_future || version < "1.8.0") {
[18:03:59.281]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.281]                           "", base::R.version$version.string), 
[18:03:59.281]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.281]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.281]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.281]                             "release", "version")], collapse = " "), 
[18:03:59.281]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.281]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.281]                           info)
[18:03:59.281]                         info <- base::paste(info, collapse = "; ")
[18:03:59.281]                         if (!has_future) {
[18:03:59.281]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.281]                             info)
[18:03:59.281]                         }
[18:03:59.281]                         else {
[18:03:59.281]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.281]                             info, version)
[18:03:59.281]                         }
[18:03:59.281]                         base::stop(msg)
[18:03:59.281]                       }
[18:03:59.281]                     })
[18:03:59.281]                   }
[18:03:59.281]                   ...future.strategy.old <- future::plan("list")
[18:03:59.281]                   options(future.plan = NULL)
[18:03:59.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.281]                 }
[18:03:59.281]                 ...future.workdir <- getwd()
[18:03:59.281]             }
[18:03:59.281]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.281]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.281]         }
[18:03:59.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.281]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.281]             base::names(...future.oldOptions))
[18:03:59.281]     }
[18:03:59.281]     if (FALSE) {
[18:03:59.281]     }
[18:03:59.281]     else {
[18:03:59.281]         if (TRUE) {
[18:03:59.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.281]                 open = "w")
[18:03:59.281]         }
[18:03:59.281]         else {
[18:03:59.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.281]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.281]         }
[18:03:59.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.281]             base::sink(type = "output", split = FALSE)
[18:03:59.281]             base::close(...future.stdout)
[18:03:59.281]         }, add = TRUE)
[18:03:59.281]     }
[18:03:59.281]     ...future.frame <- base::sys.nframe()
[18:03:59.281]     ...future.conditions <- base::list()
[18:03:59.281]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.281]     if (FALSE) {
[18:03:59.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.281]     }
[18:03:59.281]     ...future.result <- base::tryCatch({
[18:03:59.281]         base::withCallingHandlers({
[18:03:59.281]             ...future.value <- base::withVisible(base::local({
[18:03:59.281]                 cat("Processing: ")
[18:03:59.281]                 for (ii in 1:10) {
[18:03:59.281]                   cat(".")
[18:03:59.281]                 }
[18:03:59.281]                 cat(" [100%]\n")
[18:03:59.281]                 4
[18:03:59.281]             }))
[18:03:59.281]             future::FutureResult(value = ...future.value$value, 
[18:03:59.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.281]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.281]                     ...future.globalenv.names))
[18:03:59.281]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.281]         }, condition = base::local({
[18:03:59.281]             c <- base::c
[18:03:59.281]             inherits <- base::inherits
[18:03:59.281]             invokeRestart <- base::invokeRestart
[18:03:59.281]             length <- base::length
[18:03:59.281]             list <- base::list
[18:03:59.281]             seq.int <- base::seq.int
[18:03:59.281]             signalCondition <- base::signalCondition
[18:03:59.281]             sys.calls <- base::sys.calls
[18:03:59.281]             `[[` <- base::`[[`
[18:03:59.281]             `+` <- base::`+`
[18:03:59.281]             `<<-` <- base::`<<-`
[18:03:59.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.281]                   3L)]
[18:03:59.281]             }
[18:03:59.281]             function(cond) {
[18:03:59.281]                 is_error <- inherits(cond, "error")
[18:03:59.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.281]                   NULL)
[18:03:59.281]                 if (is_error) {
[18:03:59.281]                   sessionInformation <- function() {
[18:03:59.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.281]                       search = base::search(), system = base::Sys.info())
[18:03:59.281]                   }
[18:03:59.281]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.281]                     cond$call), session = sessionInformation(), 
[18:03:59.281]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.281]                   signalCondition(cond)
[18:03:59.281]                 }
[18:03:59.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.281]                 "immediateCondition"))) {
[18:03:59.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.281]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.281]                   if (TRUE && !signal) {
[18:03:59.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.281]                     {
[18:03:59.281]                       inherits <- base::inherits
[18:03:59.281]                       invokeRestart <- base::invokeRestart
[18:03:59.281]                       is.null <- base::is.null
[18:03:59.281]                       muffled <- FALSE
[18:03:59.281]                       if (inherits(cond, "message")) {
[18:03:59.281]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.281]                         if (muffled) 
[18:03:59.281]                           invokeRestart("muffleMessage")
[18:03:59.281]                       }
[18:03:59.281]                       else if (inherits(cond, "warning")) {
[18:03:59.281]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.281]                         if (muffled) 
[18:03:59.281]                           invokeRestart("muffleWarning")
[18:03:59.281]                       }
[18:03:59.281]                       else if (inherits(cond, "condition")) {
[18:03:59.281]                         if (!is.null(pattern)) {
[18:03:59.281]                           computeRestarts <- base::computeRestarts
[18:03:59.281]                           grepl <- base::grepl
[18:03:59.281]                           restarts <- computeRestarts(cond)
[18:03:59.281]                           for (restart in restarts) {
[18:03:59.281]                             name <- restart$name
[18:03:59.281]                             if (is.null(name)) 
[18:03:59.281]                               next
[18:03:59.281]                             if (!grepl(pattern, name)) 
[18:03:59.281]                               next
[18:03:59.281]                             invokeRestart(restart)
[18:03:59.281]                             muffled <- TRUE
[18:03:59.281]                             break
[18:03:59.281]                           }
[18:03:59.281]                         }
[18:03:59.281]                       }
[18:03:59.281]                       invisible(muffled)
[18:03:59.281]                     }
[18:03:59.281]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.281]                   }
[18:03:59.281]                 }
[18:03:59.281]                 else {
[18:03:59.281]                   if (TRUE) {
[18:03:59.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.281]                     {
[18:03:59.281]                       inherits <- base::inherits
[18:03:59.281]                       invokeRestart <- base::invokeRestart
[18:03:59.281]                       is.null <- base::is.null
[18:03:59.281]                       muffled <- FALSE
[18:03:59.281]                       if (inherits(cond, "message")) {
[18:03:59.281]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.281]                         if (muffled) 
[18:03:59.281]                           invokeRestart("muffleMessage")
[18:03:59.281]                       }
[18:03:59.281]                       else if (inherits(cond, "warning")) {
[18:03:59.281]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.281]                         if (muffled) 
[18:03:59.281]                           invokeRestart("muffleWarning")
[18:03:59.281]                       }
[18:03:59.281]                       else if (inherits(cond, "condition")) {
[18:03:59.281]                         if (!is.null(pattern)) {
[18:03:59.281]                           computeRestarts <- base::computeRestarts
[18:03:59.281]                           grepl <- base::grepl
[18:03:59.281]                           restarts <- computeRestarts(cond)
[18:03:59.281]                           for (restart in restarts) {
[18:03:59.281]                             name <- restart$name
[18:03:59.281]                             if (is.null(name)) 
[18:03:59.281]                               next
[18:03:59.281]                             if (!grepl(pattern, name)) 
[18:03:59.281]                               next
[18:03:59.281]                             invokeRestart(restart)
[18:03:59.281]                             muffled <- TRUE
[18:03:59.281]                             break
[18:03:59.281]                           }
[18:03:59.281]                         }
[18:03:59.281]                       }
[18:03:59.281]                       invisible(muffled)
[18:03:59.281]                     }
[18:03:59.281]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.281]                   }
[18:03:59.281]                 }
[18:03:59.281]             }
[18:03:59.281]         }))
[18:03:59.281]     }, error = function(ex) {
[18:03:59.281]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.281]                 ...future.rng), started = ...future.startTime, 
[18:03:59.281]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.281]             version = "1.8"), class = "FutureResult")
[18:03:59.281]     }, finally = {
[18:03:59.281]         if (!identical(...future.workdir, getwd())) 
[18:03:59.281]             setwd(...future.workdir)
[18:03:59.281]         {
[18:03:59.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.281]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.281]             }
[18:03:59.281]             base::options(...future.oldOptions)
[18:03:59.281]             if (.Platform$OS.type == "windows") {
[18:03:59.281]                 old_names <- names(...future.oldEnvVars)
[18:03:59.281]                 envs <- base::Sys.getenv()
[18:03:59.281]                 names <- names(envs)
[18:03:59.281]                 common <- intersect(names, old_names)
[18:03:59.281]                 added <- setdiff(names, old_names)
[18:03:59.281]                 removed <- setdiff(old_names, names)
[18:03:59.281]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.281]                   envs[common]]
[18:03:59.281]                 NAMES <- toupper(changed)
[18:03:59.281]                 args <- list()
[18:03:59.281]                 for (kk in seq_along(NAMES)) {
[18:03:59.281]                   name <- changed[[kk]]
[18:03:59.281]                   NAME <- NAMES[[kk]]
[18:03:59.281]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.281]                     next
[18:03:59.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.281]                 }
[18:03:59.281]                 NAMES <- toupper(added)
[18:03:59.281]                 for (kk in seq_along(NAMES)) {
[18:03:59.281]                   name <- added[[kk]]
[18:03:59.281]                   NAME <- NAMES[[kk]]
[18:03:59.281]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.281]                     next
[18:03:59.281]                   args[[name]] <- ""
[18:03:59.281]                 }
[18:03:59.281]                 NAMES <- toupper(removed)
[18:03:59.281]                 for (kk in seq_along(NAMES)) {
[18:03:59.281]                   name <- removed[[kk]]
[18:03:59.281]                   NAME <- NAMES[[kk]]
[18:03:59.281]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.281]                     next
[18:03:59.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.281]                 }
[18:03:59.281]                 if (length(args) > 0) 
[18:03:59.281]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.281]             }
[18:03:59.281]             else {
[18:03:59.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.281]             }
[18:03:59.281]             {
[18:03:59.281]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.281]                   0L) {
[18:03:59.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.281]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.281]                   base::options(opts)
[18:03:59.281]                 }
[18:03:59.281]                 {
[18:03:59.281]                   {
[18:03:59.281]                     NULL
[18:03:59.281]                     RNGkind("Mersenne-Twister")
[18:03:59.281]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.281]                       inherits = FALSE)
[18:03:59.281]                   }
[18:03:59.281]                   options(future.plan = NULL)
[18:03:59.281]                   if (is.na(NA_character_)) 
[18:03:59.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.281]                     .init = FALSE)
[18:03:59.281]                 }
[18:03:59.281]             }
[18:03:59.281]         }
[18:03:59.281]     })
[18:03:59.281]     if (TRUE) {
[18:03:59.281]         base::sink(type = "output", split = FALSE)
[18:03:59.281]         if (TRUE) {
[18:03:59.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.281]         }
[18:03:59.281]         else {
[18:03:59.281]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.281]         }
[18:03:59.281]         base::close(...future.stdout)
[18:03:59.281]         ...future.stdout <- NULL
[18:03:59.281]     }
[18:03:59.281]     ...future.result$conditions <- ...future.conditions
[18:03:59.281]     ...future.result$finished <- base::Sys.time()
[18:03:59.281]     ...future.result
[18:03:59.281] }
[18:03:59.285] plan(): Setting new future strategy stack:
[18:03:59.285] List of future strategies:
[18:03:59.285] 1. sequential:
[18:03:59.285]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.285]    - tweaked: FALSE
[18:03:59.285]    - call: NULL
[18:03:59.286] plan(): nbrOfWorkers() = 1
[18:03:59.288] plan(): Setting new future strategy stack:
[18:03:59.288] List of future strategies:
[18:03:59.288] 1. sequential:
[18:03:59.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.288]    - tweaked: FALSE
[18:03:59.288]    - call: plan(strategy)
[18:03:59.289] plan(): nbrOfWorkers() = 1
[18:03:59.290] SequentialFuture started (and completed)
[18:03:59.290] - Launch lazy future ... done
[18:03:59.290] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[18:03:59.294] signalConditions() ...
[18:03:59.295]  - include = ‘immediateCondition’
[18:03:59.295]  - exclude = 
[18:03:59.295]  - resignal = FALSE
[18:03:59.295]  - Number of conditions: 1
[18:03:59.296] signalConditions() ... done
[18:03:59.296] Future state: ‘finished’
[18:03:59.296] signalConditions() ...
[18:03:59.296]  - include = ‘condition’
[18:03:59.297]  - exclude = ‘immediateCondition’
[18:03:59.297]  - resignal = TRUE
[18:03:59.297]  - Number of conditions: 1
[18:03:59.297]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:03:59.297] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[18:03:59.299] getGlobalsAndPackages() ...
[18:03:59.299] Searching for globals...
[18:03:59.300] 
[18:03:59.300] Searching for globals ... DONE
[18:03:59.300] - globals: [0] <none>
[18:03:59.300] getGlobalsAndPackages() ... DONE
[18:03:59.301] run() for ‘Future’ ...
[18:03:59.301] - state: ‘created’
[18:03:59.301] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.302] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.302]   - Field: ‘label’
[18:03:59.303]   - Field: ‘local’
[18:03:59.303]   - Field: ‘owner’
[18:03:59.303]   - Field: ‘envir’
[18:03:59.303]   - Field: ‘packages’
[18:03:59.304]   - Field: ‘gc’
[18:03:59.304]   - Field: ‘conditions’
[18:03:59.304]   - Field: ‘expr’
[18:03:59.304]   - Field: ‘uuid’
[18:03:59.304]   - Field: ‘seed’
[18:03:59.305]   - Field: ‘version’
[18:03:59.305]   - Field: ‘result’
[18:03:59.305]   - Field: ‘asynchronous’
[18:03:59.305]   - Field: ‘calls’
[18:03:59.305]   - Field: ‘globals’
[18:03:59.306]   - Field: ‘stdout’
[18:03:59.306]   - Field: ‘earlySignal’
[18:03:59.306]   - Field: ‘lazy’
[18:03:59.306]   - Field: ‘state’
[18:03:59.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.307] - Launch lazy future ...
[18:03:59.307] Packages needed by the future expression (n = 0): <none>
[18:03:59.307] Packages needed by future strategies (n = 0): <none>
[18:03:59.308] {
[18:03:59.308]     {
[18:03:59.308]         {
[18:03:59.308]             ...future.startTime <- base::Sys.time()
[18:03:59.308]             {
[18:03:59.308]                 {
[18:03:59.308]                   {
[18:03:59.308]                     base::local({
[18:03:59.308]                       has_future <- base::requireNamespace("future", 
[18:03:59.308]                         quietly = TRUE)
[18:03:59.308]                       if (has_future) {
[18:03:59.308]                         ns <- base::getNamespace("future")
[18:03:59.308]                         version <- ns[[".package"]][["version"]]
[18:03:59.308]                         if (is.null(version)) 
[18:03:59.308]                           version <- utils::packageVersion("future")
[18:03:59.308]                       }
[18:03:59.308]                       else {
[18:03:59.308]                         version <- NULL
[18:03:59.308]                       }
[18:03:59.308]                       if (!has_future || version < "1.8.0") {
[18:03:59.308]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.308]                           "", base::R.version$version.string), 
[18:03:59.308]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.308]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.308]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.308]                             "release", "version")], collapse = " "), 
[18:03:59.308]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.308]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.308]                           info)
[18:03:59.308]                         info <- base::paste(info, collapse = "; ")
[18:03:59.308]                         if (!has_future) {
[18:03:59.308]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.308]                             info)
[18:03:59.308]                         }
[18:03:59.308]                         else {
[18:03:59.308]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.308]                             info, version)
[18:03:59.308]                         }
[18:03:59.308]                         base::stop(msg)
[18:03:59.308]                       }
[18:03:59.308]                     })
[18:03:59.308]                   }
[18:03:59.308]                   ...future.strategy.old <- future::plan("list")
[18:03:59.308]                   options(future.plan = NULL)
[18:03:59.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.308]                 }
[18:03:59.308]                 ...future.workdir <- getwd()
[18:03:59.308]             }
[18:03:59.308]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.308]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.308]         }
[18:03:59.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.308]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.308]             base::names(...future.oldOptions))
[18:03:59.308]     }
[18:03:59.308]     if (FALSE) {
[18:03:59.308]     }
[18:03:59.308]     else {
[18:03:59.308]         if (TRUE) {
[18:03:59.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.308]                 open = "w")
[18:03:59.308]         }
[18:03:59.308]         else {
[18:03:59.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.308]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.308]         }
[18:03:59.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.308]             base::sink(type = "output", split = FALSE)
[18:03:59.308]             base::close(...future.stdout)
[18:03:59.308]         }, add = TRUE)
[18:03:59.308]     }
[18:03:59.308]     ...future.frame <- base::sys.nframe()
[18:03:59.308]     ...future.conditions <- base::list()
[18:03:59.308]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.308]     if (FALSE) {
[18:03:59.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.308]     }
[18:03:59.308]     ...future.result <- base::tryCatch({
[18:03:59.308]         base::withCallingHandlers({
[18:03:59.308]             ...future.value <- base::withVisible(base::local(1))
[18:03:59.308]             future::FutureResult(value = ...future.value$value, 
[18:03:59.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.308]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.308]                     ...future.globalenv.names))
[18:03:59.308]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.308]         }, condition = base::local({
[18:03:59.308]             c <- base::c
[18:03:59.308]             inherits <- base::inherits
[18:03:59.308]             invokeRestart <- base::invokeRestart
[18:03:59.308]             length <- base::length
[18:03:59.308]             list <- base::list
[18:03:59.308]             seq.int <- base::seq.int
[18:03:59.308]             signalCondition <- base::signalCondition
[18:03:59.308]             sys.calls <- base::sys.calls
[18:03:59.308]             `[[` <- base::`[[`
[18:03:59.308]             `+` <- base::`+`
[18:03:59.308]             `<<-` <- base::`<<-`
[18:03:59.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.308]                   3L)]
[18:03:59.308]             }
[18:03:59.308]             function(cond) {
[18:03:59.308]                 is_error <- inherits(cond, "error")
[18:03:59.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.308]                   NULL)
[18:03:59.308]                 if (is_error) {
[18:03:59.308]                   sessionInformation <- function() {
[18:03:59.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.308]                       search = base::search(), system = base::Sys.info())
[18:03:59.308]                   }
[18:03:59.308]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.308]                     cond$call), session = sessionInformation(), 
[18:03:59.308]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.308]                   signalCondition(cond)
[18:03:59.308]                 }
[18:03:59.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.308]                 "immediateCondition"))) {
[18:03:59.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.308]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.308]                   if (TRUE && !signal) {
[18:03:59.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.308]                     {
[18:03:59.308]                       inherits <- base::inherits
[18:03:59.308]                       invokeRestart <- base::invokeRestart
[18:03:59.308]                       is.null <- base::is.null
[18:03:59.308]                       muffled <- FALSE
[18:03:59.308]                       if (inherits(cond, "message")) {
[18:03:59.308]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.308]                         if (muffled) 
[18:03:59.308]                           invokeRestart("muffleMessage")
[18:03:59.308]                       }
[18:03:59.308]                       else if (inherits(cond, "warning")) {
[18:03:59.308]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.308]                         if (muffled) 
[18:03:59.308]                           invokeRestart("muffleWarning")
[18:03:59.308]                       }
[18:03:59.308]                       else if (inherits(cond, "condition")) {
[18:03:59.308]                         if (!is.null(pattern)) {
[18:03:59.308]                           computeRestarts <- base::computeRestarts
[18:03:59.308]                           grepl <- base::grepl
[18:03:59.308]                           restarts <- computeRestarts(cond)
[18:03:59.308]                           for (restart in restarts) {
[18:03:59.308]                             name <- restart$name
[18:03:59.308]                             if (is.null(name)) 
[18:03:59.308]                               next
[18:03:59.308]                             if (!grepl(pattern, name)) 
[18:03:59.308]                               next
[18:03:59.308]                             invokeRestart(restart)
[18:03:59.308]                             muffled <- TRUE
[18:03:59.308]                             break
[18:03:59.308]                           }
[18:03:59.308]                         }
[18:03:59.308]                       }
[18:03:59.308]                       invisible(muffled)
[18:03:59.308]                     }
[18:03:59.308]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.308]                   }
[18:03:59.308]                 }
[18:03:59.308]                 else {
[18:03:59.308]                   if (TRUE) {
[18:03:59.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.308]                     {
[18:03:59.308]                       inherits <- base::inherits
[18:03:59.308]                       invokeRestart <- base::invokeRestart
[18:03:59.308]                       is.null <- base::is.null
[18:03:59.308]                       muffled <- FALSE
[18:03:59.308]                       if (inherits(cond, "message")) {
[18:03:59.308]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.308]                         if (muffled) 
[18:03:59.308]                           invokeRestart("muffleMessage")
[18:03:59.308]                       }
[18:03:59.308]                       else if (inherits(cond, "warning")) {
[18:03:59.308]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.308]                         if (muffled) 
[18:03:59.308]                           invokeRestart("muffleWarning")
[18:03:59.308]                       }
[18:03:59.308]                       else if (inherits(cond, "condition")) {
[18:03:59.308]                         if (!is.null(pattern)) {
[18:03:59.308]                           computeRestarts <- base::computeRestarts
[18:03:59.308]                           grepl <- base::grepl
[18:03:59.308]                           restarts <- computeRestarts(cond)
[18:03:59.308]                           for (restart in restarts) {
[18:03:59.308]                             name <- restart$name
[18:03:59.308]                             if (is.null(name)) 
[18:03:59.308]                               next
[18:03:59.308]                             if (!grepl(pattern, name)) 
[18:03:59.308]                               next
[18:03:59.308]                             invokeRestart(restart)
[18:03:59.308]                             muffled <- TRUE
[18:03:59.308]                             break
[18:03:59.308]                           }
[18:03:59.308]                         }
[18:03:59.308]                       }
[18:03:59.308]                       invisible(muffled)
[18:03:59.308]                     }
[18:03:59.308]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.308]                   }
[18:03:59.308]                 }
[18:03:59.308]             }
[18:03:59.308]         }))
[18:03:59.308]     }, error = function(ex) {
[18:03:59.308]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.308]                 ...future.rng), started = ...future.startTime, 
[18:03:59.308]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.308]             version = "1.8"), class = "FutureResult")
[18:03:59.308]     }, finally = {
[18:03:59.308]         if (!identical(...future.workdir, getwd())) 
[18:03:59.308]             setwd(...future.workdir)
[18:03:59.308]         {
[18:03:59.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.308]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.308]             }
[18:03:59.308]             base::options(...future.oldOptions)
[18:03:59.308]             if (.Platform$OS.type == "windows") {
[18:03:59.308]                 old_names <- names(...future.oldEnvVars)
[18:03:59.308]                 envs <- base::Sys.getenv()
[18:03:59.308]                 names <- names(envs)
[18:03:59.308]                 common <- intersect(names, old_names)
[18:03:59.308]                 added <- setdiff(names, old_names)
[18:03:59.308]                 removed <- setdiff(old_names, names)
[18:03:59.308]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.308]                   envs[common]]
[18:03:59.308]                 NAMES <- toupper(changed)
[18:03:59.308]                 args <- list()
[18:03:59.308]                 for (kk in seq_along(NAMES)) {
[18:03:59.308]                   name <- changed[[kk]]
[18:03:59.308]                   NAME <- NAMES[[kk]]
[18:03:59.308]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.308]                     next
[18:03:59.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.308]                 }
[18:03:59.308]                 NAMES <- toupper(added)
[18:03:59.308]                 for (kk in seq_along(NAMES)) {
[18:03:59.308]                   name <- added[[kk]]
[18:03:59.308]                   NAME <- NAMES[[kk]]
[18:03:59.308]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.308]                     next
[18:03:59.308]                   args[[name]] <- ""
[18:03:59.308]                 }
[18:03:59.308]                 NAMES <- toupper(removed)
[18:03:59.308]                 for (kk in seq_along(NAMES)) {
[18:03:59.308]                   name <- removed[[kk]]
[18:03:59.308]                   NAME <- NAMES[[kk]]
[18:03:59.308]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.308]                     next
[18:03:59.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.308]                 }
[18:03:59.308]                 if (length(args) > 0) 
[18:03:59.308]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.308]             }
[18:03:59.308]             else {
[18:03:59.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.308]             }
[18:03:59.308]             {
[18:03:59.308]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.308]                   0L) {
[18:03:59.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.308]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.308]                   base::options(opts)
[18:03:59.308]                 }
[18:03:59.308]                 {
[18:03:59.308]                   {
[18:03:59.308]                     NULL
[18:03:59.308]                     RNGkind("Mersenne-Twister")
[18:03:59.308]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.308]                       inherits = FALSE)
[18:03:59.308]                   }
[18:03:59.308]                   options(future.plan = NULL)
[18:03:59.308]                   if (is.na(NA_character_)) 
[18:03:59.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.308]                     .init = FALSE)
[18:03:59.308]                 }
[18:03:59.308]             }
[18:03:59.308]         }
[18:03:59.308]     })
[18:03:59.308]     if (TRUE) {
[18:03:59.308]         base::sink(type = "output", split = FALSE)
[18:03:59.308]         if (TRUE) {
[18:03:59.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.308]         }
[18:03:59.308]         else {
[18:03:59.308]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.308]         }
[18:03:59.308]         base::close(...future.stdout)
[18:03:59.308]         ...future.stdout <- NULL
[18:03:59.308]     }
[18:03:59.308]     ...future.result$conditions <- ...future.conditions
[18:03:59.308]     ...future.result$finished <- base::Sys.time()
[18:03:59.308]     ...future.result
[18:03:59.308] }
[18:03:59.312] plan(): Setting new future strategy stack:
[18:03:59.312] List of future strategies:
[18:03:59.312] 1. sequential:
[18:03:59.312]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.312]    - tweaked: FALSE
[18:03:59.312]    - call: NULL
[18:03:59.313] plan(): nbrOfWorkers() = 1
[18:03:59.315] plan(): Setting new future strategy stack:
[18:03:59.315] List of future strategies:
[18:03:59.315] 1. sequential:
[18:03:59.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.315]    - tweaked: FALSE
[18:03:59.315]    - call: plan(strategy)
[18:03:59.316] plan(): nbrOfWorkers() = 1
[18:03:59.317] SequentialFuture started (and completed)
[18:03:59.317] - Launch lazy future ... done
[18:03:59.317] run() for ‘SequentialFuture’ ... done
c = 1
[18:03:59.318] getGlobalsAndPackages() ...
[18:03:59.318] Searching for globals...
[18:03:59.319] 
[18:03:59.319] Searching for globals ... DONE
[18:03:59.319] - globals: [0] <none>
[18:03:59.320] getGlobalsAndPackages() ... DONE
[18:03:59.320] run() for ‘Future’ ...
[18:03:59.320] - state: ‘created’
[18:03:59.321] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.321] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.322]   - Field: ‘label’
[18:03:59.322]   - Field: ‘local’
[18:03:59.322]   - Field: ‘owner’
[18:03:59.322]   - Field: ‘envir’
[18:03:59.323]   - Field: ‘packages’
[18:03:59.323]   - Field: ‘gc’
[18:03:59.323]   - Field: ‘conditions’
[18:03:59.323]   - Field: ‘expr’
[18:03:59.323]   - Field: ‘uuid’
[18:03:59.324]   - Field: ‘seed’
[18:03:59.324]   - Field: ‘version’
[18:03:59.324]   - Field: ‘result’
[18:03:59.324]   - Field: ‘asynchronous’
[18:03:59.324]   - Field: ‘calls’
[18:03:59.325]   - Field: ‘globals’
[18:03:59.325]   - Field: ‘stdout’
[18:03:59.325]   - Field: ‘earlySignal’
[18:03:59.325]   - Field: ‘lazy’
[18:03:59.325]   - Field: ‘state’
[18:03:59.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.326] - Launch lazy future ...
[18:03:59.326] Packages needed by the future expression (n = 0): <none>
[18:03:59.327] Packages needed by future strategies (n = 0): <none>
[18:03:59.327] {
[18:03:59.327]     {
[18:03:59.327]         {
[18:03:59.327]             ...future.startTime <- base::Sys.time()
[18:03:59.327]             {
[18:03:59.327]                 {
[18:03:59.327]                   {
[18:03:59.327]                     base::local({
[18:03:59.327]                       has_future <- base::requireNamespace("future", 
[18:03:59.327]                         quietly = TRUE)
[18:03:59.327]                       if (has_future) {
[18:03:59.327]                         ns <- base::getNamespace("future")
[18:03:59.327]                         version <- ns[[".package"]][["version"]]
[18:03:59.327]                         if (is.null(version)) 
[18:03:59.327]                           version <- utils::packageVersion("future")
[18:03:59.327]                       }
[18:03:59.327]                       else {
[18:03:59.327]                         version <- NULL
[18:03:59.327]                       }
[18:03:59.327]                       if (!has_future || version < "1.8.0") {
[18:03:59.327]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.327]                           "", base::R.version$version.string), 
[18:03:59.327]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.327]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.327]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.327]                             "release", "version")], collapse = " "), 
[18:03:59.327]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.327]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.327]                           info)
[18:03:59.327]                         info <- base::paste(info, collapse = "; ")
[18:03:59.327]                         if (!has_future) {
[18:03:59.327]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.327]                             info)
[18:03:59.327]                         }
[18:03:59.327]                         else {
[18:03:59.327]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.327]                             info, version)
[18:03:59.327]                         }
[18:03:59.327]                         base::stop(msg)
[18:03:59.327]                       }
[18:03:59.327]                     })
[18:03:59.327]                   }
[18:03:59.327]                   ...future.strategy.old <- future::plan("list")
[18:03:59.327]                   options(future.plan = NULL)
[18:03:59.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.327]                 }
[18:03:59.327]                 ...future.workdir <- getwd()
[18:03:59.327]             }
[18:03:59.327]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.327]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.327]         }
[18:03:59.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.327]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.327]             base::names(...future.oldOptions))
[18:03:59.327]     }
[18:03:59.327]     if (FALSE) {
[18:03:59.327]     }
[18:03:59.327]     else {
[18:03:59.327]         if (TRUE) {
[18:03:59.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.327]                 open = "w")
[18:03:59.327]         }
[18:03:59.327]         else {
[18:03:59.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.327]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.327]         }
[18:03:59.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.327]             base::sink(type = "output", split = FALSE)
[18:03:59.327]             base::close(...future.stdout)
[18:03:59.327]         }, add = TRUE)
[18:03:59.327]     }
[18:03:59.327]     ...future.frame <- base::sys.nframe()
[18:03:59.327]     ...future.conditions <- base::list()
[18:03:59.327]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.327]     if (FALSE) {
[18:03:59.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.327]     }
[18:03:59.327]     ...future.result <- base::tryCatch({
[18:03:59.327]         base::withCallingHandlers({
[18:03:59.327]             ...future.value <- base::withVisible(base::local(1))
[18:03:59.327]             future::FutureResult(value = ...future.value$value, 
[18:03:59.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.327]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.327]                     ...future.globalenv.names))
[18:03:59.327]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.327]         }, condition = base::local({
[18:03:59.327]             c <- base::c
[18:03:59.327]             inherits <- base::inherits
[18:03:59.327]             invokeRestart <- base::invokeRestart
[18:03:59.327]             length <- base::length
[18:03:59.327]             list <- base::list
[18:03:59.327]             seq.int <- base::seq.int
[18:03:59.327]             signalCondition <- base::signalCondition
[18:03:59.327]             sys.calls <- base::sys.calls
[18:03:59.327]             `[[` <- base::`[[`
[18:03:59.327]             `+` <- base::`+`
[18:03:59.327]             `<<-` <- base::`<<-`
[18:03:59.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.327]                   3L)]
[18:03:59.327]             }
[18:03:59.327]             function(cond) {
[18:03:59.327]                 is_error <- inherits(cond, "error")
[18:03:59.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.327]                   NULL)
[18:03:59.327]                 if (is_error) {
[18:03:59.327]                   sessionInformation <- function() {
[18:03:59.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.327]                       search = base::search(), system = base::Sys.info())
[18:03:59.327]                   }
[18:03:59.327]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.327]                     cond$call), session = sessionInformation(), 
[18:03:59.327]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.327]                   signalCondition(cond)
[18:03:59.327]                 }
[18:03:59.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.327]                 "immediateCondition"))) {
[18:03:59.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.327]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.327]                   if (TRUE && !signal) {
[18:03:59.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.327]                     {
[18:03:59.327]                       inherits <- base::inherits
[18:03:59.327]                       invokeRestart <- base::invokeRestart
[18:03:59.327]                       is.null <- base::is.null
[18:03:59.327]                       muffled <- FALSE
[18:03:59.327]                       if (inherits(cond, "message")) {
[18:03:59.327]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.327]                         if (muffled) 
[18:03:59.327]                           invokeRestart("muffleMessage")
[18:03:59.327]                       }
[18:03:59.327]                       else if (inherits(cond, "warning")) {
[18:03:59.327]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.327]                         if (muffled) 
[18:03:59.327]                           invokeRestart("muffleWarning")
[18:03:59.327]                       }
[18:03:59.327]                       else if (inherits(cond, "condition")) {
[18:03:59.327]                         if (!is.null(pattern)) {
[18:03:59.327]                           computeRestarts <- base::computeRestarts
[18:03:59.327]                           grepl <- base::grepl
[18:03:59.327]                           restarts <- computeRestarts(cond)
[18:03:59.327]                           for (restart in restarts) {
[18:03:59.327]                             name <- restart$name
[18:03:59.327]                             if (is.null(name)) 
[18:03:59.327]                               next
[18:03:59.327]                             if (!grepl(pattern, name)) 
[18:03:59.327]                               next
[18:03:59.327]                             invokeRestart(restart)
[18:03:59.327]                             muffled <- TRUE
[18:03:59.327]                             break
[18:03:59.327]                           }
[18:03:59.327]                         }
[18:03:59.327]                       }
[18:03:59.327]                       invisible(muffled)
[18:03:59.327]                     }
[18:03:59.327]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.327]                   }
[18:03:59.327]                 }
[18:03:59.327]                 else {
[18:03:59.327]                   if (TRUE) {
[18:03:59.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.327]                     {
[18:03:59.327]                       inherits <- base::inherits
[18:03:59.327]                       invokeRestart <- base::invokeRestart
[18:03:59.327]                       is.null <- base::is.null
[18:03:59.327]                       muffled <- FALSE
[18:03:59.327]                       if (inherits(cond, "message")) {
[18:03:59.327]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.327]                         if (muffled) 
[18:03:59.327]                           invokeRestart("muffleMessage")
[18:03:59.327]                       }
[18:03:59.327]                       else if (inherits(cond, "warning")) {
[18:03:59.327]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.327]                         if (muffled) 
[18:03:59.327]                           invokeRestart("muffleWarning")
[18:03:59.327]                       }
[18:03:59.327]                       else if (inherits(cond, "condition")) {
[18:03:59.327]                         if (!is.null(pattern)) {
[18:03:59.327]                           computeRestarts <- base::computeRestarts
[18:03:59.327]                           grepl <- base::grepl
[18:03:59.327]                           restarts <- computeRestarts(cond)
[18:03:59.327]                           for (restart in restarts) {
[18:03:59.327]                             name <- restart$name
[18:03:59.327]                             if (is.null(name)) 
[18:03:59.327]                               next
[18:03:59.327]                             if (!grepl(pattern, name)) 
[18:03:59.327]                               next
[18:03:59.327]                             invokeRestart(restart)
[18:03:59.327]                             muffled <- TRUE
[18:03:59.327]                             break
[18:03:59.327]                           }
[18:03:59.327]                         }
[18:03:59.327]                       }
[18:03:59.327]                       invisible(muffled)
[18:03:59.327]                     }
[18:03:59.327]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.327]                   }
[18:03:59.327]                 }
[18:03:59.327]             }
[18:03:59.327]         }))
[18:03:59.327]     }, error = function(ex) {
[18:03:59.327]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.327]                 ...future.rng), started = ...future.startTime, 
[18:03:59.327]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.327]             version = "1.8"), class = "FutureResult")
[18:03:59.327]     }, finally = {
[18:03:59.327]         if (!identical(...future.workdir, getwd())) 
[18:03:59.327]             setwd(...future.workdir)
[18:03:59.327]         {
[18:03:59.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.327]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.327]             }
[18:03:59.327]             base::options(...future.oldOptions)
[18:03:59.327]             if (.Platform$OS.type == "windows") {
[18:03:59.327]                 old_names <- names(...future.oldEnvVars)
[18:03:59.327]                 envs <- base::Sys.getenv()
[18:03:59.327]                 names <- names(envs)
[18:03:59.327]                 common <- intersect(names, old_names)
[18:03:59.327]                 added <- setdiff(names, old_names)
[18:03:59.327]                 removed <- setdiff(old_names, names)
[18:03:59.327]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.327]                   envs[common]]
[18:03:59.327]                 NAMES <- toupper(changed)
[18:03:59.327]                 args <- list()
[18:03:59.327]                 for (kk in seq_along(NAMES)) {
[18:03:59.327]                   name <- changed[[kk]]
[18:03:59.327]                   NAME <- NAMES[[kk]]
[18:03:59.327]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.327]                     next
[18:03:59.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.327]                 }
[18:03:59.327]                 NAMES <- toupper(added)
[18:03:59.327]                 for (kk in seq_along(NAMES)) {
[18:03:59.327]                   name <- added[[kk]]
[18:03:59.327]                   NAME <- NAMES[[kk]]
[18:03:59.327]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.327]                     next
[18:03:59.327]                   args[[name]] <- ""
[18:03:59.327]                 }
[18:03:59.327]                 NAMES <- toupper(removed)
[18:03:59.327]                 for (kk in seq_along(NAMES)) {
[18:03:59.327]                   name <- removed[[kk]]
[18:03:59.327]                   NAME <- NAMES[[kk]]
[18:03:59.327]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.327]                     next
[18:03:59.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.327]                 }
[18:03:59.327]                 if (length(args) > 0) 
[18:03:59.327]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.327]             }
[18:03:59.327]             else {
[18:03:59.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.327]             }
[18:03:59.327]             {
[18:03:59.327]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.327]                   0L) {
[18:03:59.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.327]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.327]                   base::options(opts)
[18:03:59.327]                 }
[18:03:59.327]                 {
[18:03:59.327]                   {
[18:03:59.327]                     NULL
[18:03:59.327]                     RNGkind("Mersenne-Twister")
[18:03:59.327]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.327]                       inherits = FALSE)
[18:03:59.327]                   }
[18:03:59.327]                   options(future.plan = NULL)
[18:03:59.327]                   if (is.na(NA_character_)) 
[18:03:59.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.327]                     .init = FALSE)
[18:03:59.327]                 }
[18:03:59.327]             }
[18:03:59.327]         }
[18:03:59.327]     })
[18:03:59.327]     if (TRUE) {
[18:03:59.327]         base::sink(type = "output", split = FALSE)
[18:03:59.327]         if (TRUE) {
[18:03:59.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.327]         }
[18:03:59.327]         else {
[18:03:59.327]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.327]         }
[18:03:59.327]         base::close(...future.stdout)
[18:03:59.327]         ...future.stdout <- NULL
[18:03:59.327]     }
[18:03:59.327]     ...future.result$conditions <- ...future.conditions
[18:03:59.327]     ...future.result$finished <- base::Sys.time()
[18:03:59.327]     ...future.result
[18:03:59.327] }
[18:03:59.336] plan(): Setting new future strategy stack:
[18:03:59.337] List of future strategies:
[18:03:59.337] 1. sequential:
[18:03:59.337]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.337]    - tweaked: FALSE
[18:03:59.337]    - call: NULL
[18:03:59.338] plan(): nbrOfWorkers() = 1
[18:03:59.339] plan(): Setting new future strategy stack:
[18:03:59.340] List of future strategies:
[18:03:59.340] 1. sequential:
[18:03:59.340]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.340]    - tweaked: FALSE
[18:03:59.340]    - call: plan(strategy)
[18:03:59.343] plan(): nbrOfWorkers() = 1
[18:03:59.347] SequentialFuture started (and completed)
[18:03:59.347] - Launch lazy future ... done
[18:03:59.347] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[18:03:59.348] getGlobalsAndPackages() ...
[18:03:59.349] Searching for globals...
[18:03:59.357] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[18:03:59.357] Searching for globals ... DONE
[18:03:59.357] Resolving globals: FALSE
[18:03:59.358] 
[18:03:59.358] - packages: [1] ‘future’
[18:03:59.359] getGlobalsAndPackages() ... DONE
[18:03:59.359] run() for ‘Future’ ...
[18:03:59.360] - state: ‘created’
[18:03:59.360] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.360] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.361]   - Field: ‘label’
[18:03:59.361]   - Field: ‘local’
[18:03:59.361]   - Field: ‘owner’
[18:03:59.362]   - Field: ‘envir’
[18:03:59.362]   - Field: ‘packages’
[18:03:59.362]   - Field: ‘gc’
[18:03:59.362]   - Field: ‘conditions’
[18:03:59.362]   - Field: ‘expr’
[18:03:59.363]   - Field: ‘uuid’
[18:03:59.363]   - Field: ‘seed’
[18:03:59.363]   - Field: ‘version’
[18:03:59.363]   - Field: ‘result’
[18:03:59.363]   - Field: ‘asynchronous’
[18:03:59.364]   - Field: ‘calls’
[18:03:59.364]   - Field: ‘globals’
[18:03:59.364]   - Field: ‘stdout’
[18:03:59.364]   - Field: ‘earlySignal’
[18:03:59.364]   - Field: ‘lazy’
[18:03:59.365]   - Field: ‘state’
[18:03:59.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.365] - Launch lazy future ...
[18:03:59.366] Packages needed by the future expression (n = 1): ‘future’
[18:03:59.366] Packages needed by future strategies (n = 0): <none>
[18:03:59.369] {
[18:03:59.369]     {
[18:03:59.369]         {
[18:03:59.369]             ...future.startTime <- base::Sys.time()
[18:03:59.369]             {
[18:03:59.369]                 {
[18:03:59.369]                   {
[18:03:59.369]                     {
[18:03:59.369]                       base::local({
[18:03:59.369]                         has_future <- base::requireNamespace("future", 
[18:03:59.369]                           quietly = TRUE)
[18:03:59.369]                         if (has_future) {
[18:03:59.369]                           ns <- base::getNamespace("future")
[18:03:59.369]                           version <- ns[[".package"]][["version"]]
[18:03:59.369]                           if (is.null(version)) 
[18:03:59.369]                             version <- utils::packageVersion("future")
[18:03:59.369]                         }
[18:03:59.369]                         else {
[18:03:59.369]                           version <- NULL
[18:03:59.369]                         }
[18:03:59.369]                         if (!has_future || version < "1.8.0") {
[18:03:59.369]                           info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.369]                             "", base::R.version$version.string), 
[18:03:59.369]                             platform = base::sprintf("%s (%s-bit)", 
[18:03:59.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.369]                               "release", "version")], collapse = " "), 
[18:03:59.369]                             hostname = base::Sys.info()[["nodename"]])
[18:03:59.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.369]                             info)
[18:03:59.369]                           info <- base::paste(info, collapse = "; ")
[18:03:59.369]                           if (!has_future) {
[18:03:59.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.369]                               info)
[18:03:59.369]                           }
[18:03:59.369]                           else {
[18:03:59.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.369]                               info, version)
[18:03:59.369]                           }
[18:03:59.369]                           base::stop(msg)
[18:03:59.369]                         }
[18:03:59.369]                       })
[18:03:59.369]                     }
[18:03:59.369]                     base::local({
[18:03:59.369]                       for (pkg in "future") {
[18:03:59.369]                         base::loadNamespace(pkg)
[18:03:59.369]                         base::library(pkg, character.only = TRUE)
[18:03:59.369]                       }
[18:03:59.369]                     })
[18:03:59.369]                   }
[18:03:59.369]                   ...future.strategy.old <- future::plan("list")
[18:03:59.369]                   options(future.plan = NULL)
[18:03:59.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.369]                 }
[18:03:59.369]                 ...future.workdir <- getwd()
[18:03:59.369]             }
[18:03:59.369]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.369]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.369]         }
[18:03:59.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.369]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.369]             base::names(...future.oldOptions))
[18:03:59.369]     }
[18:03:59.369]     if (FALSE) {
[18:03:59.369]     }
[18:03:59.369]     else {
[18:03:59.369]         if (TRUE) {
[18:03:59.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.369]                 open = "w")
[18:03:59.369]         }
[18:03:59.369]         else {
[18:03:59.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.369]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.369]         }
[18:03:59.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.369]             base::sink(type = "output", split = FALSE)
[18:03:59.369]             base::close(...future.stdout)
[18:03:59.369]         }, add = TRUE)
[18:03:59.369]     }
[18:03:59.369]     ...future.frame <- base::sys.nframe()
[18:03:59.369]     ...future.conditions <- base::list()
[18:03:59.369]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.369]     if (FALSE) {
[18:03:59.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.369]     }
[18:03:59.369]     ...future.result <- base::tryCatch({
[18:03:59.369]         base::withCallingHandlers({
[18:03:59.369]             ...future.value <- base::withVisible(base::local({
[18:03:59.369]                 b <- 1
[18:03:59.369]                 c %<-% 2
[18:03:59.369]                 d <- 3
[18:03:59.369]                 4 %->% e
[18:03:59.369]                 b + c + d + e
[18:03:59.369]             }))
[18:03:59.369]             future::FutureResult(value = ...future.value$value, 
[18:03:59.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.369]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.369]                     ...future.globalenv.names))
[18:03:59.369]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.369]         }, condition = base::local({
[18:03:59.369]             c <- base::c
[18:03:59.369]             inherits <- base::inherits
[18:03:59.369]             invokeRestart <- base::invokeRestart
[18:03:59.369]             length <- base::length
[18:03:59.369]             list <- base::list
[18:03:59.369]             seq.int <- base::seq.int
[18:03:59.369]             signalCondition <- base::signalCondition
[18:03:59.369]             sys.calls <- base::sys.calls
[18:03:59.369]             `[[` <- base::`[[`
[18:03:59.369]             `+` <- base::`+`
[18:03:59.369]             `<<-` <- base::`<<-`
[18:03:59.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.369]                   3L)]
[18:03:59.369]             }
[18:03:59.369]             function(cond) {
[18:03:59.369]                 is_error <- inherits(cond, "error")
[18:03:59.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.369]                   NULL)
[18:03:59.369]                 if (is_error) {
[18:03:59.369]                   sessionInformation <- function() {
[18:03:59.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.369]                       search = base::search(), system = base::Sys.info())
[18:03:59.369]                   }
[18:03:59.369]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.369]                     cond$call), session = sessionInformation(), 
[18:03:59.369]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.369]                   signalCondition(cond)
[18:03:59.369]                 }
[18:03:59.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.369]                 "immediateCondition"))) {
[18:03:59.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.369]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.369]                   if (TRUE && !signal) {
[18:03:59.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.369]                     {
[18:03:59.369]                       inherits <- base::inherits
[18:03:59.369]                       invokeRestart <- base::invokeRestart
[18:03:59.369]                       is.null <- base::is.null
[18:03:59.369]                       muffled <- FALSE
[18:03:59.369]                       if (inherits(cond, "message")) {
[18:03:59.369]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.369]                         if (muffled) 
[18:03:59.369]                           invokeRestart("muffleMessage")
[18:03:59.369]                       }
[18:03:59.369]                       else if (inherits(cond, "warning")) {
[18:03:59.369]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.369]                         if (muffled) 
[18:03:59.369]                           invokeRestart("muffleWarning")
[18:03:59.369]                       }
[18:03:59.369]                       else if (inherits(cond, "condition")) {
[18:03:59.369]                         if (!is.null(pattern)) {
[18:03:59.369]                           computeRestarts <- base::computeRestarts
[18:03:59.369]                           grepl <- base::grepl
[18:03:59.369]                           restarts <- computeRestarts(cond)
[18:03:59.369]                           for (restart in restarts) {
[18:03:59.369]                             name <- restart$name
[18:03:59.369]                             if (is.null(name)) 
[18:03:59.369]                               next
[18:03:59.369]                             if (!grepl(pattern, name)) 
[18:03:59.369]                               next
[18:03:59.369]                             invokeRestart(restart)
[18:03:59.369]                             muffled <- TRUE
[18:03:59.369]                             break
[18:03:59.369]                           }
[18:03:59.369]                         }
[18:03:59.369]                       }
[18:03:59.369]                       invisible(muffled)
[18:03:59.369]                     }
[18:03:59.369]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.369]                   }
[18:03:59.369]                 }
[18:03:59.369]                 else {
[18:03:59.369]                   if (TRUE) {
[18:03:59.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.369]                     {
[18:03:59.369]                       inherits <- base::inherits
[18:03:59.369]                       invokeRestart <- base::invokeRestart
[18:03:59.369]                       is.null <- base::is.null
[18:03:59.369]                       muffled <- FALSE
[18:03:59.369]                       if (inherits(cond, "message")) {
[18:03:59.369]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.369]                         if (muffled) 
[18:03:59.369]                           invokeRestart("muffleMessage")
[18:03:59.369]                       }
[18:03:59.369]                       else if (inherits(cond, "warning")) {
[18:03:59.369]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.369]                         if (muffled) 
[18:03:59.369]                           invokeRestart("muffleWarning")
[18:03:59.369]                       }
[18:03:59.369]                       else if (inherits(cond, "condition")) {
[18:03:59.369]                         if (!is.null(pattern)) {
[18:03:59.369]                           computeRestarts <- base::computeRestarts
[18:03:59.369]                           grepl <- base::grepl
[18:03:59.369]                           restarts <- computeRestarts(cond)
[18:03:59.369]                           for (restart in restarts) {
[18:03:59.369]                             name <- restart$name
[18:03:59.369]                             if (is.null(name)) 
[18:03:59.369]                               next
[18:03:59.369]                             if (!grepl(pattern, name)) 
[18:03:59.369]                               next
[18:03:59.369]                             invokeRestart(restart)
[18:03:59.369]                             muffled <- TRUE
[18:03:59.369]                             break
[18:03:59.369]                           }
[18:03:59.369]                         }
[18:03:59.369]                       }
[18:03:59.369]                       invisible(muffled)
[18:03:59.369]                     }
[18:03:59.369]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.369]                   }
[18:03:59.369]                 }
[18:03:59.369]             }
[18:03:59.369]         }))
[18:03:59.369]     }, error = function(ex) {
[18:03:59.369]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.369]                 ...future.rng), started = ...future.startTime, 
[18:03:59.369]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.369]             version = "1.8"), class = "FutureResult")
[18:03:59.369]     }, finally = {
[18:03:59.369]         if (!identical(...future.workdir, getwd())) 
[18:03:59.369]             setwd(...future.workdir)
[18:03:59.369]         {
[18:03:59.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.369]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.369]             }
[18:03:59.369]             base::options(...future.oldOptions)
[18:03:59.369]             if (.Platform$OS.type == "windows") {
[18:03:59.369]                 old_names <- names(...future.oldEnvVars)
[18:03:59.369]                 envs <- base::Sys.getenv()
[18:03:59.369]                 names <- names(envs)
[18:03:59.369]                 common <- intersect(names, old_names)
[18:03:59.369]                 added <- setdiff(names, old_names)
[18:03:59.369]                 removed <- setdiff(old_names, names)
[18:03:59.369]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.369]                   envs[common]]
[18:03:59.369]                 NAMES <- toupper(changed)
[18:03:59.369]                 args <- list()
[18:03:59.369]                 for (kk in seq_along(NAMES)) {
[18:03:59.369]                   name <- changed[[kk]]
[18:03:59.369]                   NAME <- NAMES[[kk]]
[18:03:59.369]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.369]                     next
[18:03:59.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.369]                 }
[18:03:59.369]                 NAMES <- toupper(added)
[18:03:59.369]                 for (kk in seq_along(NAMES)) {
[18:03:59.369]                   name <- added[[kk]]
[18:03:59.369]                   NAME <- NAMES[[kk]]
[18:03:59.369]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.369]                     next
[18:03:59.369]                   args[[name]] <- ""
[18:03:59.369]                 }
[18:03:59.369]                 NAMES <- toupper(removed)
[18:03:59.369]                 for (kk in seq_along(NAMES)) {
[18:03:59.369]                   name <- removed[[kk]]
[18:03:59.369]                   NAME <- NAMES[[kk]]
[18:03:59.369]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.369]                     next
[18:03:59.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.369]                 }
[18:03:59.369]                 if (length(args) > 0) 
[18:03:59.369]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.369]             }
[18:03:59.369]             else {
[18:03:59.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.369]             }
[18:03:59.369]             {
[18:03:59.369]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.369]                   0L) {
[18:03:59.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.369]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.369]                   base::options(opts)
[18:03:59.369]                 }
[18:03:59.369]                 {
[18:03:59.369]                   {
[18:03:59.369]                     NULL
[18:03:59.369]                     RNGkind("Mersenne-Twister")
[18:03:59.369]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.369]                       inherits = FALSE)
[18:03:59.369]                   }
[18:03:59.369]                   options(future.plan = NULL)
[18:03:59.369]                   if (is.na(NA_character_)) 
[18:03:59.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.369]                     .init = FALSE)
[18:03:59.369]                 }
[18:03:59.369]             }
[18:03:59.369]         }
[18:03:59.369]     })
[18:03:59.369]     if (TRUE) {
[18:03:59.369]         base::sink(type = "output", split = FALSE)
[18:03:59.369]         if (TRUE) {
[18:03:59.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.369]         }
[18:03:59.369]         else {
[18:03:59.369]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.369]         }
[18:03:59.369]         base::close(...future.stdout)
[18:03:59.369]         ...future.stdout <- NULL
[18:03:59.369]     }
[18:03:59.369]     ...future.result$conditions <- ...future.conditions
[18:03:59.369]     ...future.result$finished <- base::Sys.time()
[18:03:59.369]     ...future.result
[18:03:59.369] }
[18:03:59.381] plan(): Setting new future strategy stack:
[18:03:59.382] List of future strategies:
[18:03:59.382] 1. sequential:
[18:03:59.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.382]    - tweaked: FALSE
[18:03:59.382]    - call: NULL
[18:03:59.383] plan(): nbrOfWorkers() = 1
[18:03:59.469] plan(): Setting new future strategy stack:
[18:03:59.469] List of future strategies:
[18:03:59.469] 1. sequential:
[18:03:59.469]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.469]    - tweaked: FALSE
[18:03:59.469]    - call: plan(strategy)
[18:03:59.470] plan(): nbrOfWorkers() = 1
[18:03:59.470] SequentialFuture started (and completed)
[18:03:59.471] signalConditions() ...
[18:03:59.471]  - include = ‘immediateCondition’
[18:03:59.471]  - exclude = 
[18:03:59.471]  - resignal = FALSE
[18:03:59.471]  - Number of conditions: 88
[18:03:59.472] signalConditions() ... done
[18:03:59.472] - Launch lazy future ... done
[18:03:59.472] run() for ‘SequentialFuture’ ... done
[18:03:59.473] signalConditions() ...
[18:03:59.473]  - include = ‘immediateCondition’
[18:03:59.473]  - exclude = 
[18:03:59.473]  - resignal = FALSE
[18:03:59.473]  - Number of conditions: 88
[18:03:59.474] signalConditions() ... done
[18:03:59.474] Future state: ‘finished’
[18:03:59.477] signalConditions() ...
[18:03:59.478]  - include = ‘condition’
[18:03:59.478]  - exclude = ‘immediateCondition’
[18:03:59.478]  - resignal = TRUE
[18:03:59.478]  - Number of conditions: 88
[18:03:59.478]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.385] getGlobalsAndPackages() ...
[18:03:59.479]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.385] Searching for globals...
[18:03:59.479]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.425] 
[18:03:59.479]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.426] Searching for globals ... DONE
[18:03:59.480]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.426] - globals: [0] <none>
[18:03:59.480]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.426] getGlobalsAndPackages() ... DONE
[18:03:59.480]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.427] run() for ‘Future’ ...
[18:03:59.480]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.427] - state: ‘created’
[18:03:59.481]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.427] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.481]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.428] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.481]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.428] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.482]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.429]   - Field: ‘label’
[18:03:59.482]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.429]   - Field: ‘local’
[18:03:59.482]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.429]   - Field: ‘owner’
[18:03:59.482]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.429]   - Field: ‘envir’
[18:03:59.483]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.430]   - Field: ‘packages’
[18:03:59.483]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.430]   - Field: ‘gc’
[18:03:59.483]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.430]   - Field: ‘conditions’
[18:03:59.484]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.430]   - Field: ‘expr’
[18:03:59.484]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.431]   - Field: ‘uuid’
[18:03:59.484]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.431]   - Field: ‘seed’
[18:03:59.484]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.431]   - Field: ‘version’
[18:03:59.485]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.431]   - Field: ‘result’
[18:03:59.485]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.432]   - Field: ‘asynchronous’
[18:03:59.485]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.432]   - Field: ‘calls’
[18:03:59.486]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.432]   - Field: ‘globals’
[18:03:59.486]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.432]   - Field: ‘stdout’
[18:03:59.486]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.433]   - Field: ‘earlySignal’
[18:03:59.486]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.433]   - Field: ‘lazy’
[18:03:59.487]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.433]   - Field: ‘state’
[18:03:59.487]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.488]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.434] - Launch lazy future ...
[18:03:59.488]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.434] Packages needed by the future expression (n = 0): <none>
[18:03:59.488]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.434] Packages needed by future strategies (n = 0): <none>
[18:03:59.489]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.435] {
[18:03:59.435]     {
[18:03:59.435]         {
[18:03:59.435]             ...future.startTime <- base::Sys.time()
[18:03:59.435]             {
[18:03:59.435]                 {
[18:03:59.435]                   {
[18:03:59.435]                     base::local({
[18:03:59.435]                       has_future <- base::requireNamespace("future", 
[18:03:59.435]                         quietly = TRUE)
[18:03:59.435]                       if (has_future) {
[18:03:59.435]                         ns <- base::getNamespace("future")
[18:03:59.435]                         version <- ns[[".package"]][["version"]]
[18:03:59.435]                         if (is.null(version)) 
[18:03:59.435]                           version <- utils::packageVersion("future")
[18:03:59.435]                       }
[18:03:59.435]                       else {
[18:03:59.435]                         version <- NULL
[18:03:59.435]                       }
[18:03:59.435]                       if (!has_future || version < "1.8.0") {
[18:03:59.435]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.435]                           "", base::R.version$version.string), 
[18:03:59.435]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.435]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.435]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.435]                             "release", "version")], collapse = " "), 
[18:03:59.435]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.435]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.435]                           info)
[18:03:59.435]                         info <- base::paste(info, collapse = "; ")
[18:03:59.435]                         if (!has_future) {
[18:03:59.435]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.435]                             info)
[18:03:59.435]                         }
[18:03:59.435]                         else {
[18:03:59.435]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.435]                             info, version)
[18:03:59.435]                         }
[18:03:59.435]                         base::stop(msg)
[18:03:59.435]                       }
[18:03:59.435]                     })
[18:03:59.435]                   }
[18:03:59.435]                   ...future.strategy.old <- future::plan("list")
[18:03:59.435]                   options(future.plan = NULL)
[18:03:59.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.435]                 }
[18:03:59.435]                 ...future.workdir <- getwd()
[18:03:59.435]             }
[18:03:59.435]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.435]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.435]         }
[18:03:59.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.435]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.435]             base::names(...future.oldOptions))
[18:03:59.435]     }
[18:03:59.435]     if (FALSE) {
[18:03:59.435]     }
[18:03:59.435]     else {
[18:03:59.435]         if (TRUE) {
[18:03:59.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.435]                 open = "w")
[18:03:59.435]         }
[18:03:59.435]         else {
[18:03:59.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.435]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.435]         }
[18:03:59.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.435]             base::sink(type = "output", split = FALSE)
[18:03:59.435]             base::close(...future.stdout)
[18:03:59.435]         }, add = TRUE)
[18:03:59.435]     }
[18:03:59.435]     ...future.frame <- base::sys.nframe()
[18:03:59.435]     ...future.conditions <- base::list()
[18:03:59.435]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.435]     if (FALSE) {
[18:03:59.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.435]     }
[18:03:59.435]     ...future.result <- base::tryCatch({
[18:03:59.435]         base::withCallingHandlers({
[18:03:59.435]             ...future.value <- base::withVisible(base::local(2))
[18:03:59.435]             future::FutureResult(value = ...future.value$value, 
[18:03:59.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.435]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.435]                     ...future.globalenv.names))
[18:03:59.435]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.435]         }, condition = base::local({
[18:03:59.435]             c <- base::c
[18:03:59.435]             inherits <- base::inherits
[18:03:59.435]             invokeRestart <- base::invokeRestart
[18:03:59.435]             length <- base::length
[18:03:59.435]             list <- base::list
[18:03:59.435]             seq.int <- base::seq.int
[18:03:59.435]             signalCondition <- base::signalCondition
[18:03:59.435]             sys.calls <- base::sys.calls
[18:03:59.435]             `[[` <- base::`[[`
[18:03:59.435]             `+` <- base::`+`
[18:03:59.435]             `<<-` <- base::`<<-`
[18:03:59.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.435]                   3L)]
[18:03:59.435]             }
[18:03:59.435]             function(cond) {
[18:03:59.435]                 is_error <- inherits(cond, "error")
[18:03:59.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.435]                   NULL)
[18:03:59.435]                 if (is_error) {
[18:03:59.435]                   sessionInformation <- function() {
[18:03:59.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.435]                       search = base::search(), system = base::Sys.info())
[18:03:59.435]                   }
[18:03:59.435]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.435]                     cond$call), session = sessionInformation(), 
[18:03:59.435]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.435]                   signalCondition(cond)
[18:03:59.435]                 }
[18:03:59.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.435]                 "immediateCondition"))) {
[18:03:59.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.435]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.435]                   if (TRUE && !signal) {
[18:03:59.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.435]                     {
[18:03:59.435]                       inherits <- base::inherits
[18:03:59.435]                       invokeRestart <- base::invokeRestart
[18:03:59.435]                       is.null <- base::is.null
[18:03:59.435]                       muffled <- FALSE
[18:03:59.435]                       if (inherits(cond, "message")) {
[18:03:59.435]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.435]                         if (muffled) 
[18:03:59.435]                           invokeRestart("muffleMessage")
[18:03:59.435]                       }
[18:03:59.435]                       else if (inherits(cond, "warning")) {
[18:03:59.435]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.435]                         if (muffled) 
[18:03:59.435]                           invokeRestart("muffleWarning")
[18:03:59.435]                       }
[18:03:59.435]                       else if (inherits(cond, "condition")) {
[18:03:59.435]                         if (!is.null(pattern)) {
[18:03:59.435]                           computeRestarts <- base::computeRestarts
[18:03:59.435]                           grepl <- base::grepl
[18:03:59.435]                           restarts <- computeRestarts(cond)
[18:03:59.435]                           for (restart in restarts) {
[18:03:59.435]                             name <- restart$name
[18:03:59.435]                             if (is.null(name)) 
[18:03:59.435]                               next
[18:03:59.435]                             if (!grepl(pattern, name)) 
[18:03:59.435]                               next
[18:03:59.435]                             invokeRestart(restart)
[18:03:59.435]                             muffled <- TRUE
[18:03:59.435]                             break
[18:03:59.435]                           }
[18:03:59.435]                         }
[18:03:59.435]                       }
[18:03:59.435]                       invisible(muffled)
[18:03:59.435]                     }
[18:03:59.435]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.435]                   }
[18:03:59.435]                 }
[18:03:59.435]                 else {
[18:03:59.435]                   if (TRUE) {
[18:03:59.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.435]                     {
[18:03:59.435]                       inherits <- base::inherits
[18:03:59.435]                       invokeRestart <- base::invokeRestart
[18:03:59.435]                       is.null <- base::is.null
[18:03:59.435]                       muffled <- FALSE
[18:03:59.435]                       if (inherits(cond, "message")) {
[18:03:59.435]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.435]                         if (muffled) 
[18:03:59.435]                           invokeRestart("muffleMessage")
[18:03:59.435]                       }
[18:03:59.435]                       else if (inherits(cond, "warning")) {
[18:03:59.435]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.435]                         if (muffled) 
[18:03:59.435]                           invokeRestart("muffleWarning")
[18:03:59.435]                       }
[18:03:59.435]                       else if (inherits(cond, "condition")) {
[18:03:59.435]                         if (!is.null(pattern)) {
[18:03:59.435]                           computeRestarts <- base::computeRestarts
[18:03:59.435]                           grepl <- base::grepl
[18:03:59.435]                           restarts <- computeRestarts(cond)
[18:03:59.435]                           for (restart in restarts) {
[18:03:59.435]                             name <- restart$name
[18:03:59.435]                             if (is.null(name)) 
[18:03:59.435]                               next
[18:03:59.435]                             if (!grepl(pattern, name)) 
[18:03:59.435]                               next
[18:03:59.435]                             invokeRestart(restart)
[18:03:59.435]                             muffled <- TRUE
[18:03:59.435]                             break
[18:03:59.435]                           }
[18:03:59.435]                         }
[18:03:59.435]                       }
[18:03:59.435]                       invisible(muffled)
[18:03:59.435]                     }
[18:03:59.435]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.435]                   }
[18:03:59.435]                 }
[18:03:59.435]             }
[18:03:59.435]         }))
[18:03:59.435]     }, error = function(ex) {
[18:03:59.435]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.435]                 ...future.rng), started = ...future.startTime, 
[18:03:59.435]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.435]             version = "1.8"), class = "FutureResult")
[18:03:59.435]     }, finally = {
[18:03:59.435]         if (!identical(...future.workdir, getwd())) 
[18:03:59.435]             setwd(...future.workdir)
[18:03:59.435]         {
[18:03:59.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.435]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.435]             }
[18:03:59.435]             base::options(...future.oldOptions)
[18:03:59.435]             if (.Platform$OS.type == "windows") {
[18:03:59.435]                 old_names <- names(...future.oldEnvVars)
[18:03:59.435]                 envs <- base::Sys.getenv()
[18:03:59.435]                 names <- names(envs)
[18:03:59.435]                 common <- intersect(names, old_names)
[18:03:59.435]                 added <- setdiff(names, old_names)
[18:03:59.435]                 removed <- setdiff(old_names, names)
[18:03:59.435]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.435]                   envs[common]]
[18:03:59.435]                 NAMES <- toupper(changed)
[18:03:59.435]                 args <- list()
[18:03:59.435]                 for (kk in seq_along(NAMES)) {
[18:03:59.435]                   name <- changed[[kk]]
[18:03:59.435]                   NAME <- NAMES[[kk]]
[18:03:59.435]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.435]                     next
[18:03:59.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.435]                 }
[18:03:59.435]                 NAMES <- toupper(added)
[18:03:59.435]                 for (kk in seq_along(NAMES)) {
[18:03:59.435]                   name <- added[[kk]]
[18:03:59.435]                   NAME <- NAMES[[kk]]
[18:03:59.435]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.435]                     next
[18:03:59.435]                   args[[name]] <- ""
[18:03:59.435]                 }
[18:03:59.435]                 NAMES <- toupper(removed)
[18:03:59.435]                 for (kk in seq_along(NAMES)) {
[18:03:59.435]                   name <- removed[[kk]]
[18:03:59.435]                   NAME <- NAMES[[kk]]
[18:03:59.435]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.435]                     next
[18:03:59.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.435]                 }
[18:03:59.435]                 if (length(args) > 0) 
[18:03:59.435]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.435]             }
[18:03:59.435]             else {
[18:03:59.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.435]             }
[18:03:59.435]             {
[18:03:59.435]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.435]                   0L) {
[18:03:59.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.435]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.435]                   base::options(opts)
[18:03:59.435]                 }
[18:03:59.435]                 {
[18:03:59.435]                   {
[18:03:59.435]                     NULL
[18:03:59.435]                     RNGkind("Mersenne-Twister")
[18:03:59.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.435]                       inherits = FALSE)
[18:03:59.435]                   }
[18:03:59.435]                   options(future.plan = NULL)
[18:03:59.435]                   if (is.na(NA_character_)) 
[18:03:59.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.435]                     .init = FALSE)
[18:03:59.435]                 }
[18:03:59.435]             }
[18:03:59.435]         }
[18:03:59.435]     })
[18:03:59.435]     if (TRUE) {
[18:03:59.435]         base::sink(type = "output", split = FALSE)
[18:03:59.435]         if (TRUE) {
[18:03:59.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.435]         }
[18:03:59.435]         else {
[18:03:59.435]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.435]         }
[18:03:59.435]         base::close(...future.stdout)
[18:03:59.435]         ...future.stdout <- NULL
[18:03:59.435]     }
[18:03:59.435]     ...future.result$conditions <- ...future.conditions
[18:03:59.435]     ...future.result$finished <- base::Sys.time()
[18:03:59.435]     ...future.result
[18:03:59.435] }
[18:03:59.489]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.439] plan(): Setting new future strategy stack:
[18:03:59.489]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.439] List of future strategies:
[18:03:59.439] 1. sequential:
[18:03:59.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.439]    - tweaked: FALSE
[18:03:59.439]    - call: NULL
[18:03:59.489]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.441] plan(): nbrOfWorkers() = 1
[18:03:59.490]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.443] plan(): Setting new future strategy stack:
[18:03:59.490]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.443] List of future strategies:
[18:03:59.443] 1. sequential:
[18:03:59.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.443]    - tweaked: FALSE
[18:03:59.443]    - call: NULL
[18:03:59.490]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.444] plan(): nbrOfWorkers() = 1
[18:03:59.491]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.444] SequentialFuture started (and completed)
[18:03:59.491]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.445] - Launch lazy future ... done
[18:03:59.491]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.445] run() for ‘SequentialFuture’ ... done
[18:03:59.491]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.446] getGlobalsAndPackages() ...
[18:03:59.492]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.446] Searching for globals...
[18:03:59.492]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.447] 
[18:03:59.492]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.447] Searching for globals ... DONE
[18:03:59.493]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.447] - globals: [0] <none>
[18:03:59.493]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.447] getGlobalsAndPackages() ... DONE
[18:03:59.493]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.448] run() for ‘Future’ ...
[18:03:59.493]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.448] - state: ‘created’
[18:03:59.494]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.449] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.494]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.449] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.494]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.495]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.450]   - Field: ‘label’
[18:03:59.495]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.450]   - Field: ‘local’
[18:03:59.495]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.450]   - Field: ‘owner’
[18:03:59.495]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.451]   - Field: ‘envir’
[18:03:59.496]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.451]   - Field: ‘packages’
[18:03:59.496]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.451]   - Field: ‘gc’
[18:03:59.496]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.451]   - Field: ‘conditions’
[18:03:59.496]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.452]   - Field: ‘expr’
[18:03:59.497]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.452]   - Field: ‘uuid’
[18:03:59.497]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.452]   - Field: ‘seed’
[18:03:59.497]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.452]   - Field: ‘version’
[18:03:59.498]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.453]   - Field: ‘result’
[18:03:59.498]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.453]   - Field: ‘asynchronous’
[18:03:59.498]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.453]   - Field: ‘calls’
[18:03:59.498]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.453]   - Field: ‘globals’
[18:03:59.499]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.454]   - Field: ‘stdout’
[18:03:59.499]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.454]   - Field: ‘earlySignal’
[18:03:59.499]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.454]   - Field: ‘lazy’
[18:03:59.500]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.454]   - Field: ‘state’
[18:03:59.500]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.500]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.455] - Launch lazy future ...
[18:03:59.500]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.455] Packages needed by the future expression (n = 0): <none>
[18:03:59.501]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.455] Packages needed by future strategies (n = 0): <none>
[18:03:59.501]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.456] {
[18:03:59.456]     {
[18:03:59.456]         {
[18:03:59.456]             ...future.startTime <- base::Sys.time()
[18:03:59.456]             {
[18:03:59.456]                 {
[18:03:59.456]                   {
[18:03:59.456]                     base::local({
[18:03:59.456]                       has_future <- base::requireNamespace("future", 
[18:03:59.456]                         quietly = TRUE)
[18:03:59.456]                       if (has_future) {
[18:03:59.456]                         ns <- base::getNamespace("future")
[18:03:59.456]                         version <- ns[[".package"]][["version"]]
[18:03:59.456]                         if (is.null(version)) 
[18:03:59.456]                           version <- utils::packageVersion("future")
[18:03:59.456]                       }
[18:03:59.456]                       else {
[18:03:59.456]                         version <- NULL
[18:03:59.456]                       }
[18:03:59.456]                       if (!has_future || version < "1.8.0") {
[18:03:59.456]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.456]                           "", base::R.version$version.string), 
[18:03:59.456]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.456]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.456]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.456]                             "release", "version")], collapse = " "), 
[18:03:59.456]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.456]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.456]                           info)
[18:03:59.456]                         info <- base::paste(info, collapse = "; ")
[18:03:59.456]                         if (!has_future) {
[18:03:59.456]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.456]                             info)
[18:03:59.456]                         }
[18:03:59.456]                         else {
[18:03:59.456]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.456]                             info, version)
[18:03:59.456]                         }
[18:03:59.456]                         base::stop(msg)
[18:03:59.456]                       }
[18:03:59.456]                     })
[18:03:59.456]                   }
[18:03:59.456]                   ...future.strategy.old <- future::plan("list")
[18:03:59.456]                   options(future.plan = NULL)
[18:03:59.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.456]                 }
[18:03:59.456]                 ...future.workdir <- getwd()
[18:03:59.456]             }
[18:03:59.456]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.456]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.456]         }
[18:03:59.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.456]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.456]             base::names(...future.oldOptions))
[18:03:59.456]     }
[18:03:59.456]     if (FALSE) {
[18:03:59.456]     }
[18:03:59.456]     else {
[18:03:59.456]         if (TRUE) {
[18:03:59.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.456]                 open = "w")
[18:03:59.456]         }
[18:03:59.456]         else {
[18:03:59.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.456]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.456]         }
[18:03:59.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.456]             base::sink(type = "output", split = FALSE)
[18:03:59.456]             base::close(...future.stdout)
[18:03:59.456]         }, add = TRUE)
[18:03:59.456]     }
[18:03:59.456]     ...future.frame <- base::sys.nframe()
[18:03:59.456]     ...future.conditions <- base::list()
[18:03:59.456]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.456]     if (FALSE) {
[18:03:59.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.456]     }
[18:03:59.456]     ...future.result <- base::tryCatch({
[18:03:59.456]         base::withCallingHandlers({
[18:03:59.456]             ...future.value <- base::withVisible(base::local(4))
[18:03:59.456]             future::FutureResult(value = ...future.value$value, 
[18:03:59.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.456]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.456]                     ...future.globalenv.names))
[18:03:59.456]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.456]         }, condition = base::local({
[18:03:59.456]             c <- base::c
[18:03:59.456]             inherits <- base::inherits
[18:03:59.456]             invokeRestart <- base::invokeRestart
[18:03:59.456]             length <- base::length
[18:03:59.456]             list <- base::list
[18:03:59.456]             seq.int <- base::seq.int
[18:03:59.456]             signalCondition <- base::signalCondition
[18:03:59.456]             sys.calls <- base::sys.calls
[18:03:59.456]             `[[` <- base::`[[`
[18:03:59.456]             `+` <- base::`+`
[18:03:59.456]             `<<-` <- base::`<<-`
[18:03:59.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.456]                   3L)]
[18:03:59.456]             }
[18:03:59.456]             function(cond) {
[18:03:59.456]                 is_error <- inherits(cond, "error")
[18:03:59.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.456]                   NULL)
[18:03:59.456]                 if (is_error) {
[18:03:59.456]                   sessionInformation <- function() {
[18:03:59.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.456]                       search = base::search(), system = base::Sys.info())
[18:03:59.456]                   }
[18:03:59.456]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.456]                     cond$call), session = sessionInformation(), 
[18:03:59.456]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.456]                   signalCondition(cond)
[18:03:59.456]                 }
[18:03:59.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.456]                 "immediateCondition"))) {
[18:03:59.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.456]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.456]                   if (TRUE && !signal) {
[18:03:59.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.456]                     {
[18:03:59.456]                       inherits <- base::inherits
[18:03:59.456]                       invokeRestart <- base::invokeRestart
[18:03:59.456]                       is.null <- base::is.null
[18:03:59.456]                       muffled <- FALSE
[18:03:59.456]                       if (inherits(cond, "message")) {
[18:03:59.456]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.456]                         if (muffled) 
[18:03:59.456]                           invokeRestart("muffleMessage")
[18:03:59.456]                       }
[18:03:59.456]                       else if (inherits(cond, "warning")) {
[18:03:59.456]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.456]                         if (muffled) 
[18:03:59.456]                           invokeRestart("muffleWarning")
[18:03:59.456]                       }
[18:03:59.456]                       else if (inherits(cond, "condition")) {
[18:03:59.456]                         if (!is.null(pattern)) {
[18:03:59.456]                           computeRestarts <- base::computeRestarts
[18:03:59.456]                           grepl <- base::grepl
[18:03:59.456]                           restarts <- computeRestarts(cond)
[18:03:59.456]                           for (restart in restarts) {
[18:03:59.456]                             name <- restart$name
[18:03:59.456]                             if (is.null(name)) 
[18:03:59.456]                               next
[18:03:59.456]                             if (!grepl(pattern, name)) 
[18:03:59.456]                               next
[18:03:59.456]                             invokeRestart(restart)
[18:03:59.456]                             muffled <- TRUE
[18:03:59.456]                             break
[18:03:59.456]                           }
[18:03:59.456]                         }
[18:03:59.456]                       }
[18:03:59.456]                       invisible(muffled)
[18:03:59.456]                     }
[18:03:59.456]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.456]                   }
[18:03:59.456]                 }
[18:03:59.456]                 else {
[18:03:59.456]                   if (TRUE) {
[18:03:59.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.456]                     {
[18:03:59.456]                       inherits <- base::inherits
[18:03:59.456]                       invokeRestart <- base::invokeRestart
[18:03:59.456]                       is.null <- base::is.null
[18:03:59.456]                       muffled <- FALSE
[18:03:59.456]                       if (inherits(cond, "message")) {
[18:03:59.456]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.456]                         if (muffled) 
[18:03:59.456]                           invokeRestart("muffleMessage")
[18:03:59.456]                       }
[18:03:59.456]                       else if (inherits(cond, "warning")) {
[18:03:59.456]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.456]                         if (muffled) 
[18:03:59.456]                           invokeRestart("muffleWarning")
[18:03:59.456]                       }
[18:03:59.456]                       else if (inherits(cond, "condition")) {
[18:03:59.456]                         if (!is.null(pattern)) {
[18:03:59.456]                           computeRestarts <- base::computeRestarts
[18:03:59.456]                           grepl <- base::grepl
[18:03:59.456]                           restarts <- computeRestarts(cond)
[18:03:59.456]                           for (restart in restarts) {
[18:03:59.456]                             name <- restart$name
[18:03:59.456]                             if (is.null(name)) 
[18:03:59.456]                               next
[18:03:59.456]                             if (!grepl(pattern, name)) 
[18:03:59.456]                               next
[18:03:59.456]                             invokeRestart(restart)
[18:03:59.456]                             muffled <- TRUE
[18:03:59.456]                             break
[18:03:59.456]                           }
[18:03:59.456]                         }
[18:03:59.456]                       }
[18:03:59.456]                       invisible(muffled)
[18:03:59.456]                     }
[18:03:59.456]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.456]                   }
[18:03:59.456]                 }
[18:03:59.456]             }
[18:03:59.456]         }))
[18:03:59.456]     }, error = function(ex) {
[18:03:59.456]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.456]                 ...future.rng), started = ...future.startTime, 
[18:03:59.456]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.456]             version = "1.8"), class = "FutureResult")
[18:03:59.456]     }, finally = {
[18:03:59.456]         if (!identical(...future.workdir, getwd())) 
[18:03:59.456]             setwd(...future.workdir)
[18:03:59.456]         {
[18:03:59.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.456]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.456]             }
[18:03:59.456]             base::options(...future.oldOptions)
[18:03:59.456]             if (.Platform$OS.type == "windows") {
[18:03:59.456]                 old_names <- names(...future.oldEnvVars)
[18:03:59.456]                 envs <- base::Sys.getenv()
[18:03:59.456]                 names <- names(envs)
[18:03:59.456]                 common <- intersect(names, old_names)
[18:03:59.456]                 added <- setdiff(names, old_names)
[18:03:59.456]                 removed <- setdiff(old_names, names)
[18:03:59.456]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.456]                   envs[common]]
[18:03:59.456]                 NAMES <- toupper(changed)
[18:03:59.456]                 args <- list()
[18:03:59.456]                 for (kk in seq_along(NAMES)) {
[18:03:59.456]                   name <- changed[[kk]]
[18:03:59.456]                   NAME <- NAMES[[kk]]
[18:03:59.456]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.456]                     next
[18:03:59.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.456]                 }
[18:03:59.456]                 NAMES <- toupper(added)
[18:03:59.456]                 for (kk in seq_along(NAMES)) {
[18:03:59.456]                   name <- added[[kk]]
[18:03:59.456]                   NAME <- NAMES[[kk]]
[18:03:59.456]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.456]                     next
[18:03:59.456]                   args[[name]] <- ""
[18:03:59.456]                 }
[18:03:59.456]                 NAMES <- toupper(removed)
[18:03:59.456]                 for (kk in seq_along(NAMES)) {
[18:03:59.456]                   name <- removed[[kk]]
[18:03:59.456]                   NAME <- NAMES[[kk]]
[18:03:59.456]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.456]                     next
[18:03:59.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.456]                 }
[18:03:59.456]                 if (length(args) > 0) 
[18:03:59.456]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.456]             }
[18:03:59.456]             else {
[18:03:59.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.456]             }
[18:03:59.456]             {
[18:03:59.456]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.456]                   0L) {
[18:03:59.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.456]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.456]                   base::options(opts)
[18:03:59.456]                 }
[18:03:59.456]                 {
[18:03:59.456]                   {
[18:03:59.456]                     NULL
[18:03:59.456]                     RNGkind("Mersenne-Twister")
[18:03:59.456]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.456]                       inherits = FALSE)
[18:03:59.456]                   }
[18:03:59.456]                   options(future.plan = NULL)
[18:03:59.456]                   if (is.na(NA_character_)) 
[18:03:59.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.456]                     .init = FALSE)
[18:03:59.456]                 }
[18:03:59.456]             }
[18:03:59.456]         }
[18:03:59.456]     })
[18:03:59.456]     if (TRUE) {
[18:03:59.456]         base::sink(type = "output", split = FALSE)
[18:03:59.456]         if (TRUE) {
[18:03:59.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.456]         }
[18:03:59.456]         else {
[18:03:59.456]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.456]         }
[18:03:59.456]         base::close(...future.stdout)
[18:03:59.456]         ...future.stdout <- NULL
[18:03:59.456]     }
[18:03:59.456]     ...future.result$conditions <- ...future.conditions
[18:03:59.456]     ...future.result$finished <- base::Sys.time()
[18:03:59.456]     ...future.result
[18:03:59.456] }
[18:03:59.502]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.460] plan(): Setting new future strategy stack:
[18:03:59.502]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.460] List of future strategies:
[18:03:59.460] 1. sequential:
[18:03:59.460]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.460]    - tweaked: FALSE
[18:03:59.460]    - call: NULL
[18:03:59.502]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.461] plan(): nbrOfWorkers() = 1
[18:03:59.502]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.465] plan(): Setting new future strategy stack:
[18:03:59.503]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.465] List of future strategies:
[18:03:59.465] 1. sequential:
[18:03:59.465]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.465]    - tweaked: FALSE
[18:03:59.465]    - call: NULL
[18:03:59.503]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.466] plan(): nbrOfWorkers() = 1
[18:03:59.503]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.467] SequentialFuture started (and completed)
[18:03:59.504]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.467] - Launch lazy future ... done
[18:03:59.504]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[18:03:59.467] run() for ‘SequentialFuture’ ... done
[18:03:59.504] signalConditions() ... done
a = 10
[18:03:59.505] getGlobalsAndPackages() ...
[18:03:59.505] Searching for globals...
[18:03:59.507] - globals found: [3] ‘{’, ‘+’, ‘a’
[18:03:59.507] Searching for globals ... DONE
[18:03:59.507] Resolving globals: FALSE
[18:03:59.508] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.508] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:03:59.509] - globals: [1] ‘a’
[18:03:59.509] 
[18:03:59.509] getGlobalsAndPackages() ... DONE
[18:03:59.510] run() for ‘Future’ ...
[18:03:59.510] - state: ‘created’
[18:03:59.510] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:03:59.511] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:03:59.511] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:03:59.511]   - Field: ‘label’
[18:03:59.511]   - Field: ‘local’
[18:03:59.511]   - Field: ‘owner’
[18:03:59.512]   - Field: ‘envir’
[18:03:59.512]   - Field: ‘packages’
[18:03:59.512]   - Field: ‘gc’
[18:03:59.512]   - Field: ‘conditions’
[18:03:59.512]   - Field: ‘expr’
[18:03:59.513]   - Field: ‘uuid’
[18:03:59.513]   - Field: ‘seed’
[18:03:59.513]   - Field: ‘version’
[18:03:59.513]   - Field: ‘result’
[18:03:59.513]   - Field: ‘asynchronous’
[18:03:59.514]   - Field: ‘calls’
[18:03:59.514]   - Field: ‘globals’
[18:03:59.514]   - Field: ‘stdout’
[18:03:59.514]   - Field: ‘earlySignal’
[18:03:59.514]   - Field: ‘lazy’
[18:03:59.515]   - Field: ‘state’
[18:03:59.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:03:59.515] - Launch lazy future ...
[18:03:59.515] Packages needed by the future expression (n = 0): <none>
[18:03:59.515] Packages needed by future strategies (n = 0): <none>
[18:03:59.516] {
[18:03:59.516]     {
[18:03:59.516]         {
[18:03:59.516]             ...future.startTime <- base::Sys.time()
[18:03:59.516]             {
[18:03:59.516]                 {
[18:03:59.516]                   {
[18:03:59.516]                     base::local({
[18:03:59.516]                       has_future <- base::requireNamespace("future", 
[18:03:59.516]                         quietly = TRUE)
[18:03:59.516]                       if (has_future) {
[18:03:59.516]                         ns <- base::getNamespace("future")
[18:03:59.516]                         version <- ns[[".package"]][["version"]]
[18:03:59.516]                         if (is.null(version)) 
[18:03:59.516]                           version <- utils::packageVersion("future")
[18:03:59.516]                       }
[18:03:59.516]                       else {
[18:03:59.516]                         version <- NULL
[18:03:59.516]                       }
[18:03:59.516]                       if (!has_future || version < "1.8.0") {
[18:03:59.516]                         info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.516]                           "", base::R.version$version.string), 
[18:03:59.516]                           platform = base::sprintf("%s (%s-bit)", 
[18:03:59.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.516]                             "release", "version")], collapse = " "), 
[18:03:59.516]                           hostname = base::Sys.info()[["nodename"]])
[18:03:59.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.516]                           info)
[18:03:59.516]                         info <- base::paste(info, collapse = "; ")
[18:03:59.516]                         if (!has_future) {
[18:03:59.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.516]                             info)
[18:03:59.516]                         }
[18:03:59.516]                         else {
[18:03:59.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.516]                             info, version)
[18:03:59.516]                         }
[18:03:59.516]                         base::stop(msg)
[18:03:59.516]                       }
[18:03:59.516]                     })
[18:03:59.516]                   }
[18:03:59.516]                   ...future.strategy.old <- future::plan("list")
[18:03:59.516]                   options(future.plan = NULL)
[18:03:59.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.516]                 }
[18:03:59.516]                 ...future.workdir <- getwd()
[18:03:59.516]             }
[18:03:59.516]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.516]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.516]         }
[18:03:59.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.516]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.516]             base::names(...future.oldOptions))
[18:03:59.516]     }
[18:03:59.516]     if (FALSE) {
[18:03:59.516]     }
[18:03:59.516]     else {
[18:03:59.516]         if (TRUE) {
[18:03:59.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.516]                 open = "w")
[18:03:59.516]         }
[18:03:59.516]         else {
[18:03:59.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.516]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.516]         }
[18:03:59.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.516]             base::sink(type = "output", split = FALSE)
[18:03:59.516]             base::close(...future.stdout)
[18:03:59.516]         }, add = TRUE)
[18:03:59.516]     }
[18:03:59.516]     ...future.frame <- base::sys.nframe()
[18:03:59.516]     ...future.conditions <- base::list()
[18:03:59.516]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.516]     if (FALSE) {
[18:03:59.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.516]     }
[18:03:59.516]     ...future.result <- base::tryCatch({
[18:03:59.516]         base::withCallingHandlers({
[18:03:59.516]             ...future.value <- base::withVisible(base::local({
[18:03:59.516]                 a + 1
[18:03:59.516]             }))
[18:03:59.516]             future::FutureResult(value = ...future.value$value, 
[18:03:59.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.516]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.516]                     ...future.globalenv.names))
[18:03:59.516]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.516]         }, condition = base::local({
[18:03:59.516]             c <- base::c
[18:03:59.516]             inherits <- base::inherits
[18:03:59.516]             invokeRestart <- base::invokeRestart
[18:03:59.516]             length <- base::length
[18:03:59.516]             list <- base::list
[18:03:59.516]             seq.int <- base::seq.int
[18:03:59.516]             signalCondition <- base::signalCondition
[18:03:59.516]             sys.calls <- base::sys.calls
[18:03:59.516]             `[[` <- base::`[[`
[18:03:59.516]             `+` <- base::`+`
[18:03:59.516]             `<<-` <- base::`<<-`
[18:03:59.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.516]                   3L)]
[18:03:59.516]             }
[18:03:59.516]             function(cond) {
[18:03:59.516]                 is_error <- inherits(cond, "error")
[18:03:59.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.516]                   NULL)
[18:03:59.516]                 if (is_error) {
[18:03:59.516]                   sessionInformation <- function() {
[18:03:59.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.516]                       search = base::search(), system = base::Sys.info())
[18:03:59.516]                   }
[18:03:59.516]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.516]                     cond$call), session = sessionInformation(), 
[18:03:59.516]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.516]                   signalCondition(cond)
[18:03:59.516]                 }
[18:03:59.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.516]                 "immediateCondition"))) {
[18:03:59.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.516]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.516]                   if (TRUE && !signal) {
[18:03:59.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.516]                     {
[18:03:59.516]                       inherits <- base::inherits
[18:03:59.516]                       invokeRestart <- base::invokeRestart
[18:03:59.516]                       is.null <- base::is.null
[18:03:59.516]                       muffled <- FALSE
[18:03:59.516]                       if (inherits(cond, "message")) {
[18:03:59.516]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.516]                         if (muffled) 
[18:03:59.516]                           invokeRestart("muffleMessage")
[18:03:59.516]                       }
[18:03:59.516]                       else if (inherits(cond, "warning")) {
[18:03:59.516]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.516]                         if (muffled) 
[18:03:59.516]                           invokeRestart("muffleWarning")
[18:03:59.516]                       }
[18:03:59.516]                       else if (inherits(cond, "condition")) {
[18:03:59.516]                         if (!is.null(pattern)) {
[18:03:59.516]                           computeRestarts <- base::computeRestarts
[18:03:59.516]                           grepl <- base::grepl
[18:03:59.516]                           restarts <- computeRestarts(cond)
[18:03:59.516]                           for (restart in restarts) {
[18:03:59.516]                             name <- restart$name
[18:03:59.516]                             if (is.null(name)) 
[18:03:59.516]                               next
[18:03:59.516]                             if (!grepl(pattern, name)) 
[18:03:59.516]                               next
[18:03:59.516]                             invokeRestart(restart)
[18:03:59.516]                             muffled <- TRUE
[18:03:59.516]                             break
[18:03:59.516]                           }
[18:03:59.516]                         }
[18:03:59.516]                       }
[18:03:59.516]                       invisible(muffled)
[18:03:59.516]                     }
[18:03:59.516]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.516]                   }
[18:03:59.516]                 }
[18:03:59.516]                 else {
[18:03:59.516]                   if (TRUE) {
[18:03:59.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.516]                     {
[18:03:59.516]                       inherits <- base::inherits
[18:03:59.516]                       invokeRestart <- base::invokeRestart
[18:03:59.516]                       is.null <- base::is.null
[18:03:59.516]                       muffled <- FALSE
[18:03:59.516]                       if (inherits(cond, "message")) {
[18:03:59.516]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.516]                         if (muffled) 
[18:03:59.516]                           invokeRestart("muffleMessage")
[18:03:59.516]                       }
[18:03:59.516]                       else if (inherits(cond, "warning")) {
[18:03:59.516]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.516]                         if (muffled) 
[18:03:59.516]                           invokeRestart("muffleWarning")
[18:03:59.516]                       }
[18:03:59.516]                       else if (inherits(cond, "condition")) {
[18:03:59.516]                         if (!is.null(pattern)) {
[18:03:59.516]                           computeRestarts <- base::computeRestarts
[18:03:59.516]                           grepl <- base::grepl
[18:03:59.516]                           restarts <- computeRestarts(cond)
[18:03:59.516]                           for (restart in restarts) {
[18:03:59.516]                             name <- restart$name
[18:03:59.516]                             if (is.null(name)) 
[18:03:59.516]                               next
[18:03:59.516]                             if (!grepl(pattern, name)) 
[18:03:59.516]                               next
[18:03:59.516]                             invokeRestart(restart)
[18:03:59.516]                             muffled <- TRUE
[18:03:59.516]                             break
[18:03:59.516]                           }
[18:03:59.516]                         }
[18:03:59.516]                       }
[18:03:59.516]                       invisible(muffled)
[18:03:59.516]                     }
[18:03:59.516]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.516]                   }
[18:03:59.516]                 }
[18:03:59.516]             }
[18:03:59.516]         }))
[18:03:59.516]     }, error = function(ex) {
[18:03:59.516]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.516]                 ...future.rng), started = ...future.startTime, 
[18:03:59.516]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.516]             version = "1.8"), class = "FutureResult")
[18:03:59.516]     }, finally = {
[18:03:59.516]         if (!identical(...future.workdir, getwd())) 
[18:03:59.516]             setwd(...future.workdir)
[18:03:59.516]         {
[18:03:59.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.516]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.516]             }
[18:03:59.516]             base::options(...future.oldOptions)
[18:03:59.516]             if (.Platform$OS.type == "windows") {
[18:03:59.516]                 old_names <- names(...future.oldEnvVars)
[18:03:59.516]                 envs <- base::Sys.getenv()
[18:03:59.516]                 names <- names(envs)
[18:03:59.516]                 common <- intersect(names, old_names)
[18:03:59.516]                 added <- setdiff(names, old_names)
[18:03:59.516]                 removed <- setdiff(old_names, names)
[18:03:59.516]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.516]                   envs[common]]
[18:03:59.516]                 NAMES <- toupper(changed)
[18:03:59.516]                 args <- list()
[18:03:59.516]                 for (kk in seq_along(NAMES)) {
[18:03:59.516]                   name <- changed[[kk]]
[18:03:59.516]                   NAME <- NAMES[[kk]]
[18:03:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.516]                     next
[18:03:59.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.516]                 }
[18:03:59.516]                 NAMES <- toupper(added)
[18:03:59.516]                 for (kk in seq_along(NAMES)) {
[18:03:59.516]                   name <- added[[kk]]
[18:03:59.516]                   NAME <- NAMES[[kk]]
[18:03:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.516]                     next
[18:03:59.516]                   args[[name]] <- ""
[18:03:59.516]                 }
[18:03:59.516]                 NAMES <- toupper(removed)
[18:03:59.516]                 for (kk in seq_along(NAMES)) {
[18:03:59.516]                   name <- removed[[kk]]
[18:03:59.516]                   NAME <- NAMES[[kk]]
[18:03:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.516]                     next
[18:03:59.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.516]                 }
[18:03:59.516]                 if (length(args) > 0) 
[18:03:59.516]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.516]             }
[18:03:59.516]             else {
[18:03:59.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.516]             }
[18:03:59.516]             {
[18:03:59.516]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.516]                   0L) {
[18:03:59.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.516]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.516]                   base::options(opts)
[18:03:59.516]                 }
[18:03:59.516]                 {
[18:03:59.516]                   {
[18:03:59.516]                     NULL
[18:03:59.516]                     RNGkind("Mersenne-Twister")
[18:03:59.516]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:03:59.516]                       inherits = FALSE)
[18:03:59.516]                   }
[18:03:59.516]                   options(future.plan = NULL)
[18:03:59.516]                   if (is.na(NA_character_)) 
[18:03:59.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.516]                     .init = FALSE)
[18:03:59.516]                 }
[18:03:59.516]             }
[18:03:59.516]         }
[18:03:59.516]     })
[18:03:59.516]     if (TRUE) {
[18:03:59.516]         base::sink(type = "output", split = FALSE)
[18:03:59.516]         if (TRUE) {
[18:03:59.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.516]         }
[18:03:59.516]         else {
[18:03:59.516]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.516]         }
[18:03:59.516]         base::close(...future.stdout)
[18:03:59.516]         ...future.stdout <- NULL
[18:03:59.516]     }
[18:03:59.516]     ...future.result$conditions <- ...future.conditions
[18:03:59.516]     ...future.result$finished <- base::Sys.time()
[18:03:59.516]     ...future.result
[18:03:59.516] }
[18:03:59.519] assign_globals() ...
[18:03:59.520] List of 1
[18:03:59.520]  $ a: num 10
[18:03:59.520]  - attr(*, "where")=List of 1
[18:03:59.520]   ..$ a:<environment: R_EmptyEnv> 
[18:03:59.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.520]  - attr(*, "resolved")= logi FALSE
[18:03:59.520]  - attr(*, "total_size")= num 56
[18:03:59.520]  - attr(*, "already-done")= logi TRUE
[18:03:59.524] - copied ‘a’ to environment
[18:03:59.525] assign_globals() ... done
[18:03:59.525] plan(): Setting new future strategy stack:
[18:03:59.525] List of future strategies:
[18:03:59.525] 1. sequential:
[18:03:59.525]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.525]    - tweaked: FALSE
[18:03:59.525]    - call: NULL
[18:03:59.526] plan(): nbrOfWorkers() = 1
[18:03:59.528] plan(): Setting new future strategy stack:
[18:03:59.528] List of future strategies:
[18:03:59.528] 1. sequential:
[18:03:59.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.528]    - tweaked: FALSE
[18:03:59.528]    - call: plan(strategy)
[18:03:59.529] plan(): nbrOfWorkers() = 1
[18:03:59.529] SequentialFuture started (and completed)
[18:03:59.532] - Launch lazy future ... done
[18:03:59.532] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[18:03:59.543] plan(): Setting new future strategy stack:
[18:03:59.543] List of future strategies:
[18:03:59.543] 1. multicore:
[18:03:59.543]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:03:59.543]    - tweaked: FALSE
[18:03:59.543]    - call: plan(strategy)
[18:03:59.550] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[18:03:59.550] getGlobalsAndPackages() ...
[18:03:59.551] Searching for globals...
[18:03:59.552] - globals found: [2] ‘{’, ‘<-’
[18:03:59.553] Searching for globals ... DONE
[18:03:59.553] Resolving globals: FALSE
[18:03:59.553] 
[18:03:59.554] 
[18:03:59.554] getGlobalsAndPackages() ... DONE
[18:03:59.554] run() for ‘Future’ ...
[18:03:59.555] - state: ‘created’
[18:03:59.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:03:59.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:03:59.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:03:59.562]   - Field: ‘label’
[18:03:59.562]   - Field: ‘local’
[18:03:59.562]   - Field: ‘owner’
[18:03:59.562]   - Field: ‘envir’
[18:03:59.562]   - Field: ‘workers’
[18:03:59.563]   - Field: ‘packages’
[18:03:59.563]   - Field: ‘gc’
[18:03:59.563]   - Field: ‘job’
[18:03:59.563]   - Field: ‘conditions’
[18:03:59.563]   - Field: ‘expr’
[18:03:59.564]   - Field: ‘uuid’
[18:03:59.564]   - Field: ‘seed’
[18:03:59.564]   - Field: ‘version’
[18:03:59.564]   - Field: ‘result’
[18:03:59.564]   - Field: ‘asynchronous’
[18:03:59.565]   - Field: ‘calls’
[18:03:59.565]   - Field: ‘globals’
[18:03:59.565]   - Field: ‘stdout’
[18:03:59.565]   - Field: ‘earlySignal’
[18:03:59.565]   - Field: ‘lazy’
[18:03:59.566]   - Field: ‘state’
[18:03:59.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:03:59.566] - Launch lazy future ...
[18:03:59.568] Packages needed by the future expression (n = 0): <none>
[18:03:59.568] Packages needed by future strategies (n = 0): <none>
[18:03:59.569] {
[18:03:59.569]     {
[18:03:59.569]         {
[18:03:59.569]             ...future.startTime <- base::Sys.time()
[18:03:59.569]             {
[18:03:59.569]                 {
[18:03:59.569]                   {
[18:03:59.569]                     {
[18:03:59.569]                       base::local({
[18:03:59.569]                         has_future <- base::requireNamespace("future", 
[18:03:59.569]                           quietly = TRUE)
[18:03:59.569]                         if (has_future) {
[18:03:59.569]                           ns <- base::getNamespace("future")
[18:03:59.569]                           version <- ns[[".package"]][["version"]]
[18:03:59.569]                           if (is.null(version)) 
[18:03:59.569]                             version <- utils::packageVersion("future")
[18:03:59.569]                         }
[18:03:59.569]                         else {
[18:03:59.569]                           version <- NULL
[18:03:59.569]                         }
[18:03:59.569]                         if (!has_future || version < "1.8.0") {
[18:03:59.569]                           info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.569]                             "", base::R.version$version.string), 
[18:03:59.569]                             platform = base::sprintf("%s (%s-bit)", 
[18:03:59.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.569]                               "release", "version")], collapse = " "), 
[18:03:59.569]                             hostname = base::Sys.info()[["nodename"]])
[18:03:59.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.569]                             info)
[18:03:59.569]                           info <- base::paste(info, collapse = "; ")
[18:03:59.569]                           if (!has_future) {
[18:03:59.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.569]                               info)
[18:03:59.569]                           }
[18:03:59.569]                           else {
[18:03:59.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.569]                               info, version)
[18:03:59.569]                           }
[18:03:59.569]                           base::stop(msg)
[18:03:59.569]                         }
[18:03:59.569]                       })
[18:03:59.569]                     }
[18:03:59.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:03:59.569]                     base::options(mc.cores = 1L)
[18:03:59.569]                   }
[18:03:59.569]                   ...future.strategy.old <- future::plan("list")
[18:03:59.569]                   options(future.plan = NULL)
[18:03:59.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.569]                 }
[18:03:59.569]                 ...future.workdir <- getwd()
[18:03:59.569]             }
[18:03:59.569]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.569]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.569]         }
[18:03:59.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.569]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.569]             base::names(...future.oldOptions))
[18:03:59.569]     }
[18:03:59.569]     if (FALSE) {
[18:03:59.569]     }
[18:03:59.569]     else {
[18:03:59.569]         if (TRUE) {
[18:03:59.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.569]                 open = "w")
[18:03:59.569]         }
[18:03:59.569]         else {
[18:03:59.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.569]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.569]         }
[18:03:59.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.569]             base::sink(type = "output", split = FALSE)
[18:03:59.569]             base::close(...future.stdout)
[18:03:59.569]         }, add = TRUE)
[18:03:59.569]     }
[18:03:59.569]     ...future.frame <- base::sys.nframe()
[18:03:59.569]     ...future.conditions <- base::list()
[18:03:59.569]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.569]     if (FALSE) {
[18:03:59.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.569]     }
[18:03:59.569]     ...future.result <- base::tryCatch({
[18:03:59.569]         base::withCallingHandlers({
[18:03:59.569]             ...future.value <- base::withVisible(base::local({
[18:03:59.569]                 withCallingHandlers({
[18:03:59.569]                   {
[18:03:59.569]                     x <- 1
[18:03:59.569]                   }
[18:03:59.569]                 }, immediateCondition = function(cond) {
[18:03:59.569]                   save_rds <- function (object, pathname, ...) 
[18:03:59.569]                   {
[18:03:59.569]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:03:59.569]                     if (file_test("-f", pathname_tmp)) {
[18:03:59.569]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.569]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:03:59.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.569]                         fi_tmp[["mtime"]])
[18:03:59.569]                     }
[18:03:59.569]                     tryCatch({
[18:03:59.569]                       saveRDS(object, file = pathname_tmp, ...)
[18:03:59.569]                     }, error = function(ex) {
[18:03:59.569]                       msg <- conditionMessage(ex)
[18:03:59.569]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.569]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:03:59.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.569]                         fi_tmp[["mtime"]], msg)
[18:03:59.569]                       ex$message <- msg
[18:03:59.569]                       stop(ex)
[18:03:59.569]                     })
[18:03:59.569]                     stopifnot(file_test("-f", pathname_tmp))
[18:03:59.569]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:03:59.569]                     if (!res || file_test("-f", pathname_tmp)) {
[18:03:59.569]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.569]                       fi <- file.info(pathname)
[18:03:59.569]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:03:59.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.569]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:03:59.569]                         fi[["size"]], fi[["mtime"]])
[18:03:59.569]                       stop(msg)
[18:03:59.569]                     }
[18:03:59.569]                     invisible(pathname)
[18:03:59.569]                   }
[18:03:59.569]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:03:59.569]                     rootPath = tempdir()) 
[18:03:59.569]                   {
[18:03:59.569]                     obj <- list(time = Sys.time(), condition = cond)
[18:03:59.569]                     file <- tempfile(pattern = class(cond)[1], 
[18:03:59.569]                       tmpdir = path, fileext = ".rds")
[18:03:59.569]                     save_rds(obj, file)
[18:03:59.569]                   }
[18:03:59.569]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:03:59.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.569]                   {
[18:03:59.569]                     inherits <- base::inherits
[18:03:59.569]                     invokeRestart <- base::invokeRestart
[18:03:59.569]                     is.null <- base::is.null
[18:03:59.569]                     muffled <- FALSE
[18:03:59.569]                     if (inherits(cond, "message")) {
[18:03:59.569]                       muffled <- grepl(pattern, "muffleMessage")
[18:03:59.569]                       if (muffled) 
[18:03:59.569]                         invokeRestart("muffleMessage")
[18:03:59.569]                     }
[18:03:59.569]                     else if (inherits(cond, "warning")) {
[18:03:59.569]                       muffled <- grepl(pattern, "muffleWarning")
[18:03:59.569]                       if (muffled) 
[18:03:59.569]                         invokeRestart("muffleWarning")
[18:03:59.569]                     }
[18:03:59.569]                     else if (inherits(cond, "condition")) {
[18:03:59.569]                       if (!is.null(pattern)) {
[18:03:59.569]                         computeRestarts <- base::computeRestarts
[18:03:59.569]                         grepl <- base::grepl
[18:03:59.569]                         restarts <- computeRestarts(cond)
[18:03:59.569]                         for (restart in restarts) {
[18:03:59.569]                           name <- restart$name
[18:03:59.569]                           if (is.null(name)) 
[18:03:59.569]                             next
[18:03:59.569]                           if (!grepl(pattern, name)) 
[18:03:59.569]                             next
[18:03:59.569]                           invokeRestart(restart)
[18:03:59.569]                           muffled <- TRUE
[18:03:59.569]                           break
[18:03:59.569]                         }
[18:03:59.569]                       }
[18:03:59.569]                     }
[18:03:59.569]                     invisible(muffled)
[18:03:59.569]                   }
[18:03:59.569]                   muffleCondition(cond)
[18:03:59.569]                 })
[18:03:59.569]             }))
[18:03:59.569]             future::FutureResult(value = ...future.value$value, 
[18:03:59.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.569]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.569]                     ...future.globalenv.names))
[18:03:59.569]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.569]         }, condition = base::local({
[18:03:59.569]             c <- base::c
[18:03:59.569]             inherits <- base::inherits
[18:03:59.569]             invokeRestart <- base::invokeRestart
[18:03:59.569]             length <- base::length
[18:03:59.569]             list <- base::list
[18:03:59.569]             seq.int <- base::seq.int
[18:03:59.569]             signalCondition <- base::signalCondition
[18:03:59.569]             sys.calls <- base::sys.calls
[18:03:59.569]             `[[` <- base::`[[`
[18:03:59.569]             `+` <- base::`+`
[18:03:59.569]             `<<-` <- base::`<<-`
[18:03:59.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.569]                   3L)]
[18:03:59.569]             }
[18:03:59.569]             function(cond) {
[18:03:59.569]                 is_error <- inherits(cond, "error")
[18:03:59.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.569]                   NULL)
[18:03:59.569]                 if (is_error) {
[18:03:59.569]                   sessionInformation <- function() {
[18:03:59.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.569]                       search = base::search(), system = base::Sys.info())
[18:03:59.569]                   }
[18:03:59.569]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.569]                     cond$call), session = sessionInformation(), 
[18:03:59.569]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.569]                   signalCondition(cond)
[18:03:59.569]                 }
[18:03:59.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.569]                 "immediateCondition"))) {
[18:03:59.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.569]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.569]                   if (TRUE && !signal) {
[18:03:59.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.569]                     {
[18:03:59.569]                       inherits <- base::inherits
[18:03:59.569]                       invokeRestart <- base::invokeRestart
[18:03:59.569]                       is.null <- base::is.null
[18:03:59.569]                       muffled <- FALSE
[18:03:59.569]                       if (inherits(cond, "message")) {
[18:03:59.569]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.569]                         if (muffled) 
[18:03:59.569]                           invokeRestart("muffleMessage")
[18:03:59.569]                       }
[18:03:59.569]                       else if (inherits(cond, "warning")) {
[18:03:59.569]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.569]                         if (muffled) 
[18:03:59.569]                           invokeRestart("muffleWarning")
[18:03:59.569]                       }
[18:03:59.569]                       else if (inherits(cond, "condition")) {
[18:03:59.569]                         if (!is.null(pattern)) {
[18:03:59.569]                           computeRestarts <- base::computeRestarts
[18:03:59.569]                           grepl <- base::grepl
[18:03:59.569]                           restarts <- computeRestarts(cond)
[18:03:59.569]                           for (restart in restarts) {
[18:03:59.569]                             name <- restart$name
[18:03:59.569]                             if (is.null(name)) 
[18:03:59.569]                               next
[18:03:59.569]                             if (!grepl(pattern, name)) 
[18:03:59.569]                               next
[18:03:59.569]                             invokeRestart(restart)
[18:03:59.569]                             muffled <- TRUE
[18:03:59.569]                             break
[18:03:59.569]                           }
[18:03:59.569]                         }
[18:03:59.569]                       }
[18:03:59.569]                       invisible(muffled)
[18:03:59.569]                     }
[18:03:59.569]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.569]                   }
[18:03:59.569]                 }
[18:03:59.569]                 else {
[18:03:59.569]                   if (TRUE) {
[18:03:59.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.569]                     {
[18:03:59.569]                       inherits <- base::inherits
[18:03:59.569]                       invokeRestart <- base::invokeRestart
[18:03:59.569]                       is.null <- base::is.null
[18:03:59.569]                       muffled <- FALSE
[18:03:59.569]                       if (inherits(cond, "message")) {
[18:03:59.569]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.569]                         if (muffled) 
[18:03:59.569]                           invokeRestart("muffleMessage")
[18:03:59.569]                       }
[18:03:59.569]                       else if (inherits(cond, "warning")) {
[18:03:59.569]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.569]                         if (muffled) 
[18:03:59.569]                           invokeRestart("muffleWarning")
[18:03:59.569]                       }
[18:03:59.569]                       else if (inherits(cond, "condition")) {
[18:03:59.569]                         if (!is.null(pattern)) {
[18:03:59.569]                           computeRestarts <- base::computeRestarts
[18:03:59.569]                           grepl <- base::grepl
[18:03:59.569]                           restarts <- computeRestarts(cond)
[18:03:59.569]                           for (restart in restarts) {
[18:03:59.569]                             name <- restart$name
[18:03:59.569]                             if (is.null(name)) 
[18:03:59.569]                               next
[18:03:59.569]                             if (!grepl(pattern, name)) 
[18:03:59.569]                               next
[18:03:59.569]                             invokeRestart(restart)
[18:03:59.569]                             muffled <- TRUE
[18:03:59.569]                             break
[18:03:59.569]                           }
[18:03:59.569]                         }
[18:03:59.569]                       }
[18:03:59.569]                       invisible(muffled)
[18:03:59.569]                     }
[18:03:59.569]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.569]                   }
[18:03:59.569]                 }
[18:03:59.569]             }
[18:03:59.569]         }))
[18:03:59.569]     }, error = function(ex) {
[18:03:59.569]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.569]                 ...future.rng), started = ...future.startTime, 
[18:03:59.569]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.569]             version = "1.8"), class = "FutureResult")
[18:03:59.569]     }, finally = {
[18:03:59.569]         if (!identical(...future.workdir, getwd())) 
[18:03:59.569]             setwd(...future.workdir)
[18:03:59.569]         {
[18:03:59.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.569]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.569]             }
[18:03:59.569]             base::options(...future.oldOptions)
[18:03:59.569]             if (.Platform$OS.type == "windows") {
[18:03:59.569]                 old_names <- names(...future.oldEnvVars)
[18:03:59.569]                 envs <- base::Sys.getenv()
[18:03:59.569]                 names <- names(envs)
[18:03:59.569]                 common <- intersect(names, old_names)
[18:03:59.569]                 added <- setdiff(names, old_names)
[18:03:59.569]                 removed <- setdiff(old_names, names)
[18:03:59.569]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.569]                   envs[common]]
[18:03:59.569]                 NAMES <- toupper(changed)
[18:03:59.569]                 args <- list()
[18:03:59.569]                 for (kk in seq_along(NAMES)) {
[18:03:59.569]                   name <- changed[[kk]]
[18:03:59.569]                   NAME <- NAMES[[kk]]
[18:03:59.569]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.569]                     next
[18:03:59.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.569]                 }
[18:03:59.569]                 NAMES <- toupper(added)
[18:03:59.569]                 for (kk in seq_along(NAMES)) {
[18:03:59.569]                   name <- added[[kk]]
[18:03:59.569]                   NAME <- NAMES[[kk]]
[18:03:59.569]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.569]                     next
[18:03:59.569]                   args[[name]] <- ""
[18:03:59.569]                 }
[18:03:59.569]                 NAMES <- toupper(removed)
[18:03:59.569]                 for (kk in seq_along(NAMES)) {
[18:03:59.569]                   name <- removed[[kk]]
[18:03:59.569]                   NAME <- NAMES[[kk]]
[18:03:59.569]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.569]                     next
[18:03:59.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.569]                 }
[18:03:59.569]                 if (length(args) > 0) 
[18:03:59.569]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.569]             }
[18:03:59.569]             else {
[18:03:59.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.569]             }
[18:03:59.569]             {
[18:03:59.569]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.569]                   0L) {
[18:03:59.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.569]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.569]                   base::options(opts)
[18:03:59.569]                 }
[18:03:59.569]                 {
[18:03:59.569]                   {
[18:03:59.569]                     base::options(mc.cores = ...future.mc.cores.old)
[18:03:59.569]                     NULL
[18:03:59.569]                   }
[18:03:59.569]                   options(future.plan = NULL)
[18:03:59.569]                   if (is.na(NA_character_)) 
[18:03:59.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.569]                     .init = FALSE)
[18:03:59.569]                 }
[18:03:59.569]             }
[18:03:59.569]         }
[18:03:59.569]     })
[18:03:59.569]     if (TRUE) {
[18:03:59.569]         base::sink(type = "output", split = FALSE)
[18:03:59.569]         if (TRUE) {
[18:03:59.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.569]         }
[18:03:59.569]         else {
[18:03:59.569]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.569]         }
[18:03:59.569]         base::close(...future.stdout)
[18:03:59.569]         ...future.stdout <- NULL
[18:03:59.569]     }
[18:03:59.569]     ...future.result$conditions <- ...future.conditions
[18:03:59.569]     ...future.result$finished <- base::Sys.time()
[18:03:59.569]     ...future.result
[18:03:59.569] }
[18:03:59.573] requestCore(): workers = 2
[18:03:59.577] MulticoreFuture started
[18:03:59.578] - Launch lazy future ... done
[18:03:59.579] run() for ‘MulticoreFuture’ ... done
[18:03:59.579] plan(): Setting new future strategy stack:
[18:03:59.581] result() for MulticoreFuture ...
[18:03:59.580] List of future strategies:
[18:03:59.580] 1. sequential:
[18:03:59.580]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.580]    - tweaked: FALSE
[18:03:59.580]    - call: NULL
[18:03:59.582] plan(): nbrOfWorkers() = 1
[18:03:59.586] plan(): Setting new future strategy stack:
[18:03:59.586] List of future strategies:
[18:03:59.586] 1. multicore:
[18:03:59.586]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:03:59.586]    - tweaked: FALSE
[18:03:59.586]    - call: plan(strategy)
[18:03:59.595] plan(): nbrOfWorkers() = 2
[18:03:59.603] result() for MulticoreFuture ...
[18:03:59.604] result() for MulticoreFuture ... done
[18:03:59.604] result() for MulticoreFuture ... done
[18:03:59.604] result() for MulticoreFuture ...
[18:03:59.604] result() for MulticoreFuture ... done
** Future evaluation with globals
[18:03:59.605] getGlobalsAndPackages() ...
[18:03:59.606] Searching for globals...
[18:03:59.608] - globals found: [3] ‘{’, ‘<-’, ‘a’
[18:03:59.608] Searching for globals ... DONE
[18:03:59.609] Resolving globals: FALSE
[18:03:59.609] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.610] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:03:59.611] - globals: [1] ‘a’
[18:03:59.611] 
[18:03:59.611] getGlobalsAndPackages() ... DONE
[18:03:59.612] run() for ‘Future’ ...
[18:03:59.612] - state: ‘created’
[18:03:59.612] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:03:59.625] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:03:59.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:03:59.626]   - Field: ‘label’
[18:03:59.626]   - Field: ‘local’
[18:03:59.627]   - Field: ‘owner’
[18:03:59.627]   - Field: ‘envir’
[18:03:59.627]   - Field: ‘workers’
[18:03:59.628]   - Field: ‘packages’
[18:03:59.628]   - Field: ‘gc’
[18:03:59.628]   - Field: ‘job’
[18:03:59.628]   - Field: ‘conditions’
[18:03:59.629]   - Field: ‘expr’
[18:03:59.629]   - Field: ‘uuid’
[18:03:59.629]   - Field: ‘seed’
[18:03:59.629]   - Field: ‘version’
[18:03:59.630]   - Field: ‘result’
[18:03:59.630]   - Field: ‘asynchronous’
[18:03:59.630]   - Field: ‘calls’
[18:03:59.630]   - Field: ‘globals’
[18:03:59.631]   - Field: ‘stdout’
[18:03:59.631]   - Field: ‘earlySignal’
[18:03:59.631]   - Field: ‘lazy’
[18:03:59.631]   - Field: ‘state’
[18:03:59.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:03:59.632] - Launch lazy future ...
[18:03:59.633] Packages needed by the future expression (n = 0): <none>
[18:03:59.633] Packages needed by future strategies (n = 0): <none>
[18:03:59.634] {
[18:03:59.634]     {
[18:03:59.634]         {
[18:03:59.634]             ...future.startTime <- base::Sys.time()
[18:03:59.634]             {
[18:03:59.634]                 {
[18:03:59.634]                   {
[18:03:59.634]                     {
[18:03:59.634]                       base::local({
[18:03:59.634]                         has_future <- base::requireNamespace("future", 
[18:03:59.634]                           quietly = TRUE)
[18:03:59.634]                         if (has_future) {
[18:03:59.634]                           ns <- base::getNamespace("future")
[18:03:59.634]                           version <- ns[[".package"]][["version"]]
[18:03:59.634]                           if (is.null(version)) 
[18:03:59.634]                             version <- utils::packageVersion("future")
[18:03:59.634]                         }
[18:03:59.634]                         else {
[18:03:59.634]                           version <- NULL
[18:03:59.634]                         }
[18:03:59.634]                         if (!has_future || version < "1.8.0") {
[18:03:59.634]                           info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.634]                             "", base::R.version$version.string), 
[18:03:59.634]                             platform = base::sprintf("%s (%s-bit)", 
[18:03:59.634]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.634]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.634]                               "release", "version")], collapse = " "), 
[18:03:59.634]                             hostname = base::Sys.info()[["nodename"]])
[18:03:59.634]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.634]                             info)
[18:03:59.634]                           info <- base::paste(info, collapse = "; ")
[18:03:59.634]                           if (!has_future) {
[18:03:59.634]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.634]                               info)
[18:03:59.634]                           }
[18:03:59.634]                           else {
[18:03:59.634]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.634]                               info, version)
[18:03:59.634]                           }
[18:03:59.634]                           base::stop(msg)
[18:03:59.634]                         }
[18:03:59.634]                       })
[18:03:59.634]                     }
[18:03:59.634]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:03:59.634]                     base::options(mc.cores = 1L)
[18:03:59.634]                   }
[18:03:59.634]                   ...future.strategy.old <- future::plan("list")
[18:03:59.634]                   options(future.plan = NULL)
[18:03:59.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.634]                 }
[18:03:59.634]                 ...future.workdir <- getwd()
[18:03:59.634]             }
[18:03:59.634]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.634]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.634]         }
[18:03:59.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.634]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.634]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.634]             base::names(...future.oldOptions))
[18:03:59.634]     }
[18:03:59.634]     if (FALSE) {
[18:03:59.634]     }
[18:03:59.634]     else {
[18:03:59.634]         if (TRUE) {
[18:03:59.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.634]                 open = "w")
[18:03:59.634]         }
[18:03:59.634]         else {
[18:03:59.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.634]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.634]         }
[18:03:59.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.634]             base::sink(type = "output", split = FALSE)
[18:03:59.634]             base::close(...future.stdout)
[18:03:59.634]         }, add = TRUE)
[18:03:59.634]     }
[18:03:59.634]     ...future.frame <- base::sys.nframe()
[18:03:59.634]     ...future.conditions <- base::list()
[18:03:59.634]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.634]     if (FALSE) {
[18:03:59.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.634]     }
[18:03:59.634]     ...future.result <- base::tryCatch({
[18:03:59.634]         base::withCallingHandlers({
[18:03:59.634]             ...future.value <- base::withVisible(base::local({
[18:03:59.634]                 withCallingHandlers({
[18:03:59.634]                   {
[18:03:59.634]                     x <- a
[18:03:59.634]                   }
[18:03:59.634]                 }, immediateCondition = function(cond) {
[18:03:59.634]                   save_rds <- function (object, pathname, ...) 
[18:03:59.634]                   {
[18:03:59.634]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:03:59.634]                     if (file_test("-f", pathname_tmp)) {
[18:03:59.634]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.634]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:03:59.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.634]                         fi_tmp[["mtime"]])
[18:03:59.634]                     }
[18:03:59.634]                     tryCatch({
[18:03:59.634]                       saveRDS(object, file = pathname_tmp, ...)
[18:03:59.634]                     }, error = function(ex) {
[18:03:59.634]                       msg <- conditionMessage(ex)
[18:03:59.634]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.634]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:03:59.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.634]                         fi_tmp[["mtime"]], msg)
[18:03:59.634]                       ex$message <- msg
[18:03:59.634]                       stop(ex)
[18:03:59.634]                     })
[18:03:59.634]                     stopifnot(file_test("-f", pathname_tmp))
[18:03:59.634]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:03:59.634]                     if (!res || file_test("-f", pathname_tmp)) {
[18:03:59.634]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.634]                       fi <- file.info(pathname)
[18:03:59.634]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:03:59.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.634]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:03:59.634]                         fi[["size"]], fi[["mtime"]])
[18:03:59.634]                       stop(msg)
[18:03:59.634]                     }
[18:03:59.634]                     invisible(pathname)
[18:03:59.634]                   }
[18:03:59.634]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:03:59.634]                     rootPath = tempdir()) 
[18:03:59.634]                   {
[18:03:59.634]                     obj <- list(time = Sys.time(), condition = cond)
[18:03:59.634]                     file <- tempfile(pattern = class(cond)[1], 
[18:03:59.634]                       tmpdir = path, fileext = ".rds")
[18:03:59.634]                     save_rds(obj, file)
[18:03:59.634]                   }
[18:03:59.634]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:03:59.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.634]                   {
[18:03:59.634]                     inherits <- base::inherits
[18:03:59.634]                     invokeRestart <- base::invokeRestart
[18:03:59.634]                     is.null <- base::is.null
[18:03:59.634]                     muffled <- FALSE
[18:03:59.634]                     if (inherits(cond, "message")) {
[18:03:59.634]                       muffled <- grepl(pattern, "muffleMessage")
[18:03:59.634]                       if (muffled) 
[18:03:59.634]                         invokeRestart("muffleMessage")
[18:03:59.634]                     }
[18:03:59.634]                     else if (inherits(cond, "warning")) {
[18:03:59.634]                       muffled <- grepl(pattern, "muffleWarning")
[18:03:59.634]                       if (muffled) 
[18:03:59.634]                         invokeRestart("muffleWarning")
[18:03:59.634]                     }
[18:03:59.634]                     else if (inherits(cond, "condition")) {
[18:03:59.634]                       if (!is.null(pattern)) {
[18:03:59.634]                         computeRestarts <- base::computeRestarts
[18:03:59.634]                         grepl <- base::grepl
[18:03:59.634]                         restarts <- computeRestarts(cond)
[18:03:59.634]                         for (restart in restarts) {
[18:03:59.634]                           name <- restart$name
[18:03:59.634]                           if (is.null(name)) 
[18:03:59.634]                             next
[18:03:59.634]                           if (!grepl(pattern, name)) 
[18:03:59.634]                             next
[18:03:59.634]                           invokeRestart(restart)
[18:03:59.634]                           muffled <- TRUE
[18:03:59.634]                           break
[18:03:59.634]                         }
[18:03:59.634]                       }
[18:03:59.634]                     }
[18:03:59.634]                     invisible(muffled)
[18:03:59.634]                   }
[18:03:59.634]                   muffleCondition(cond)
[18:03:59.634]                 })
[18:03:59.634]             }))
[18:03:59.634]             future::FutureResult(value = ...future.value$value, 
[18:03:59.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.634]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.634]                     ...future.globalenv.names))
[18:03:59.634]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.634]         }, condition = base::local({
[18:03:59.634]             c <- base::c
[18:03:59.634]             inherits <- base::inherits
[18:03:59.634]             invokeRestart <- base::invokeRestart
[18:03:59.634]             length <- base::length
[18:03:59.634]             list <- base::list
[18:03:59.634]             seq.int <- base::seq.int
[18:03:59.634]             signalCondition <- base::signalCondition
[18:03:59.634]             sys.calls <- base::sys.calls
[18:03:59.634]             `[[` <- base::`[[`
[18:03:59.634]             `+` <- base::`+`
[18:03:59.634]             `<<-` <- base::`<<-`
[18:03:59.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.634]                   3L)]
[18:03:59.634]             }
[18:03:59.634]             function(cond) {
[18:03:59.634]                 is_error <- inherits(cond, "error")
[18:03:59.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.634]                   NULL)
[18:03:59.634]                 if (is_error) {
[18:03:59.634]                   sessionInformation <- function() {
[18:03:59.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.634]                       search = base::search(), system = base::Sys.info())
[18:03:59.634]                   }
[18:03:59.634]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.634]                     cond$call), session = sessionInformation(), 
[18:03:59.634]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.634]                   signalCondition(cond)
[18:03:59.634]                 }
[18:03:59.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.634]                 "immediateCondition"))) {
[18:03:59.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.634]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.634]                   if (TRUE && !signal) {
[18:03:59.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.634]                     {
[18:03:59.634]                       inherits <- base::inherits
[18:03:59.634]                       invokeRestart <- base::invokeRestart
[18:03:59.634]                       is.null <- base::is.null
[18:03:59.634]                       muffled <- FALSE
[18:03:59.634]                       if (inherits(cond, "message")) {
[18:03:59.634]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.634]                         if (muffled) 
[18:03:59.634]                           invokeRestart("muffleMessage")
[18:03:59.634]                       }
[18:03:59.634]                       else if (inherits(cond, "warning")) {
[18:03:59.634]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.634]                         if (muffled) 
[18:03:59.634]                           invokeRestart("muffleWarning")
[18:03:59.634]                       }
[18:03:59.634]                       else if (inherits(cond, "condition")) {
[18:03:59.634]                         if (!is.null(pattern)) {
[18:03:59.634]                           computeRestarts <- base::computeRestarts
[18:03:59.634]                           grepl <- base::grepl
[18:03:59.634]                           restarts <- computeRestarts(cond)
[18:03:59.634]                           for (restart in restarts) {
[18:03:59.634]                             name <- restart$name
[18:03:59.634]                             if (is.null(name)) 
[18:03:59.634]                               next
[18:03:59.634]                             if (!grepl(pattern, name)) 
[18:03:59.634]                               next
[18:03:59.634]                             invokeRestart(restart)
[18:03:59.634]                             muffled <- TRUE
[18:03:59.634]                             break
[18:03:59.634]                           }
[18:03:59.634]                         }
[18:03:59.634]                       }
[18:03:59.634]                       invisible(muffled)
[18:03:59.634]                     }
[18:03:59.634]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.634]                   }
[18:03:59.634]                 }
[18:03:59.634]                 else {
[18:03:59.634]                   if (TRUE) {
[18:03:59.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.634]                     {
[18:03:59.634]                       inherits <- base::inherits
[18:03:59.634]                       invokeRestart <- base::invokeRestart
[18:03:59.634]                       is.null <- base::is.null
[18:03:59.634]                       muffled <- FALSE
[18:03:59.634]                       if (inherits(cond, "message")) {
[18:03:59.634]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.634]                         if (muffled) 
[18:03:59.634]                           invokeRestart("muffleMessage")
[18:03:59.634]                       }
[18:03:59.634]                       else if (inherits(cond, "warning")) {
[18:03:59.634]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.634]                         if (muffled) 
[18:03:59.634]                           invokeRestart("muffleWarning")
[18:03:59.634]                       }
[18:03:59.634]                       else if (inherits(cond, "condition")) {
[18:03:59.634]                         if (!is.null(pattern)) {
[18:03:59.634]                           computeRestarts <- base::computeRestarts
[18:03:59.634]                           grepl <- base::grepl
[18:03:59.634]                           restarts <- computeRestarts(cond)
[18:03:59.634]                           for (restart in restarts) {
[18:03:59.634]                             name <- restart$name
[18:03:59.634]                             if (is.null(name)) 
[18:03:59.634]                               next
[18:03:59.634]                             if (!grepl(pattern, name)) 
[18:03:59.634]                               next
[18:03:59.634]                             invokeRestart(restart)
[18:03:59.634]                             muffled <- TRUE
[18:03:59.634]                             break
[18:03:59.634]                           }
[18:03:59.634]                         }
[18:03:59.634]                       }
[18:03:59.634]                       invisible(muffled)
[18:03:59.634]                     }
[18:03:59.634]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.634]                   }
[18:03:59.634]                 }
[18:03:59.634]             }
[18:03:59.634]         }))
[18:03:59.634]     }, error = function(ex) {
[18:03:59.634]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.634]                 ...future.rng), started = ...future.startTime, 
[18:03:59.634]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.634]             version = "1.8"), class = "FutureResult")
[18:03:59.634]     }, finally = {
[18:03:59.634]         if (!identical(...future.workdir, getwd())) 
[18:03:59.634]             setwd(...future.workdir)
[18:03:59.634]         {
[18:03:59.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.634]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.634]             }
[18:03:59.634]             base::options(...future.oldOptions)
[18:03:59.634]             if (.Platform$OS.type == "windows") {
[18:03:59.634]                 old_names <- names(...future.oldEnvVars)
[18:03:59.634]                 envs <- base::Sys.getenv()
[18:03:59.634]                 names <- names(envs)
[18:03:59.634]                 common <- intersect(names, old_names)
[18:03:59.634]                 added <- setdiff(names, old_names)
[18:03:59.634]                 removed <- setdiff(old_names, names)
[18:03:59.634]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.634]                   envs[common]]
[18:03:59.634]                 NAMES <- toupper(changed)
[18:03:59.634]                 args <- list()
[18:03:59.634]                 for (kk in seq_along(NAMES)) {
[18:03:59.634]                   name <- changed[[kk]]
[18:03:59.634]                   NAME <- NAMES[[kk]]
[18:03:59.634]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.634]                     next
[18:03:59.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.634]                 }
[18:03:59.634]                 NAMES <- toupper(added)
[18:03:59.634]                 for (kk in seq_along(NAMES)) {
[18:03:59.634]                   name <- added[[kk]]
[18:03:59.634]                   NAME <- NAMES[[kk]]
[18:03:59.634]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.634]                     next
[18:03:59.634]                   args[[name]] <- ""
[18:03:59.634]                 }
[18:03:59.634]                 NAMES <- toupper(removed)
[18:03:59.634]                 for (kk in seq_along(NAMES)) {
[18:03:59.634]                   name <- removed[[kk]]
[18:03:59.634]                   NAME <- NAMES[[kk]]
[18:03:59.634]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.634]                     next
[18:03:59.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.634]                 }
[18:03:59.634]                 if (length(args) > 0) 
[18:03:59.634]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.634]             }
[18:03:59.634]             else {
[18:03:59.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.634]             }
[18:03:59.634]             {
[18:03:59.634]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.634]                   0L) {
[18:03:59.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.634]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.634]                   base::options(opts)
[18:03:59.634]                 }
[18:03:59.634]                 {
[18:03:59.634]                   {
[18:03:59.634]                     base::options(mc.cores = ...future.mc.cores.old)
[18:03:59.634]                     NULL
[18:03:59.634]                   }
[18:03:59.634]                   options(future.plan = NULL)
[18:03:59.634]                   if (is.na(NA_character_)) 
[18:03:59.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.634]                     .init = FALSE)
[18:03:59.634]                 }
[18:03:59.634]             }
[18:03:59.634]         }
[18:03:59.634]     })
[18:03:59.634]     if (TRUE) {
[18:03:59.634]         base::sink(type = "output", split = FALSE)
[18:03:59.634]         if (TRUE) {
[18:03:59.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.634]         }
[18:03:59.634]         else {
[18:03:59.634]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.634]         }
[18:03:59.634]         base::close(...future.stdout)
[18:03:59.634]         ...future.stdout <- NULL
[18:03:59.634]     }
[18:03:59.634]     ...future.result$conditions <- ...future.conditions
[18:03:59.634]     ...future.result$finished <- base::Sys.time()
[18:03:59.634]     ...future.result
[18:03:59.634] }
[18:03:59.639] assign_globals() ...
[18:03:59.639] List of 1
[18:03:59.639]  $ a: num 2
[18:03:59.639]  - attr(*, "where")=List of 1
[18:03:59.639]   ..$ a:<environment: R_EmptyEnv> 
[18:03:59.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.639]  - attr(*, "resolved")= logi FALSE
[18:03:59.639]  - attr(*, "total_size")= num 56
[18:03:59.639]  - attr(*, "already-done")= logi TRUE
[18:03:59.645] - copied ‘a’ to environment
[18:03:59.645] assign_globals() ... done
[18:03:59.645] requestCore(): workers = 2
[18:03:59.649] MulticoreFuture started
[18:03:59.649] - Launch lazy future ... done
[18:03:59.650] run() for ‘MulticoreFuture’ ... done
[18:03:59.651] plan(): Setting new future strategy stack:
[18:03:59.653] result() for MulticoreFuture ...
[18:03:59.651] List of future strategies:
[18:03:59.651] 1. sequential:
[18:03:59.651]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.651]    - tweaked: FALSE
[18:03:59.651]    - call: NULL
[18:03:59.654] plan(): nbrOfWorkers() = 1
[18:03:59.658] plan(): Setting new future strategy stack:
[18:03:59.658] List of future strategies:
[18:03:59.658] 1. multicore:
[18:03:59.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:03:59.658]    - tweaked: FALSE
[18:03:59.658]    - call: plan(strategy)
[18:03:59.668] plan(): nbrOfWorkers() = 2
[18:03:59.670] result() for MulticoreFuture ...
[18:03:59.670] result() for MulticoreFuture ... done
[18:03:59.673] result() for MulticoreFuture ... done
[18:03:59.674] result() for MulticoreFuture ...
[18:03:59.674] result() for MulticoreFuture ... done
** Future evaluation with errors
[18:03:59.677] getGlobalsAndPackages() ...
[18:03:59.677] Searching for globals...
[18:03:59.683] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[18:03:59.684] Searching for globals ... DONE
[18:03:59.684] Resolving globals: FALSE
[18:03:59.685] 
[18:03:59.685] 
[18:03:59.686] getGlobalsAndPackages() ... DONE
[18:03:59.686] run() for ‘Future’ ...
[18:03:59.687] - state: ‘created’
[18:03:59.687] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:03:59.694] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:03:59.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:03:59.695]   - Field: ‘label’
[18:03:59.695]   - Field: ‘local’
[18:03:59.696]   - Field: ‘owner’
[18:03:59.696]   - Field: ‘envir’
[18:03:59.696]   - Field: ‘workers’
[18:03:59.697]   - Field: ‘packages’
[18:03:59.697]   - Field: ‘gc’
[18:03:59.697]   - Field: ‘job’
[18:03:59.697]   - Field: ‘conditions’
[18:03:59.698]   - Field: ‘expr’
[18:03:59.698]   - Field: ‘uuid’
[18:03:59.698]   - Field: ‘seed’
[18:03:59.698]   - Field: ‘version’
[18:03:59.699]   - Field: ‘result’
[18:03:59.699]   - Field: ‘asynchronous’
[18:03:59.699]   - Field: ‘calls’
[18:03:59.699]   - Field: ‘globals’
[18:03:59.700]   - Field: ‘stdout’
[18:03:59.700]   - Field: ‘earlySignal’
[18:03:59.700]   - Field: ‘lazy’
[18:03:59.700]   - Field: ‘state’
[18:03:59.701] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:03:59.701] - Launch lazy future ...
[18:03:59.701] Packages needed by the future expression (n = 0): <none>
[18:03:59.702] Packages needed by future strategies (n = 0): <none>
[18:03:59.703] {
[18:03:59.703]     {
[18:03:59.703]         {
[18:03:59.703]             ...future.startTime <- base::Sys.time()
[18:03:59.703]             {
[18:03:59.703]                 {
[18:03:59.703]                   {
[18:03:59.703]                     {
[18:03:59.703]                       base::local({
[18:03:59.703]                         has_future <- base::requireNamespace("future", 
[18:03:59.703]                           quietly = TRUE)
[18:03:59.703]                         if (has_future) {
[18:03:59.703]                           ns <- base::getNamespace("future")
[18:03:59.703]                           version <- ns[[".package"]][["version"]]
[18:03:59.703]                           if (is.null(version)) 
[18:03:59.703]                             version <- utils::packageVersion("future")
[18:03:59.703]                         }
[18:03:59.703]                         else {
[18:03:59.703]                           version <- NULL
[18:03:59.703]                         }
[18:03:59.703]                         if (!has_future || version < "1.8.0") {
[18:03:59.703]                           info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.703]                             "", base::R.version$version.string), 
[18:03:59.703]                             platform = base::sprintf("%s (%s-bit)", 
[18:03:59.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.703]                               "release", "version")], collapse = " "), 
[18:03:59.703]                             hostname = base::Sys.info()[["nodename"]])
[18:03:59.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.703]                             info)
[18:03:59.703]                           info <- base::paste(info, collapse = "; ")
[18:03:59.703]                           if (!has_future) {
[18:03:59.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.703]                               info)
[18:03:59.703]                           }
[18:03:59.703]                           else {
[18:03:59.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.703]                               info, version)
[18:03:59.703]                           }
[18:03:59.703]                           base::stop(msg)
[18:03:59.703]                         }
[18:03:59.703]                       })
[18:03:59.703]                     }
[18:03:59.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:03:59.703]                     base::options(mc.cores = 1L)
[18:03:59.703]                   }
[18:03:59.703]                   ...future.strategy.old <- future::plan("list")
[18:03:59.703]                   options(future.plan = NULL)
[18:03:59.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.703]                 }
[18:03:59.703]                 ...future.workdir <- getwd()
[18:03:59.703]             }
[18:03:59.703]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.703]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.703]         }
[18:03:59.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.703]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.703]             base::names(...future.oldOptions))
[18:03:59.703]     }
[18:03:59.703]     if (FALSE) {
[18:03:59.703]     }
[18:03:59.703]     else {
[18:03:59.703]         if (TRUE) {
[18:03:59.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.703]                 open = "w")
[18:03:59.703]         }
[18:03:59.703]         else {
[18:03:59.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.703]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.703]         }
[18:03:59.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.703]             base::sink(type = "output", split = FALSE)
[18:03:59.703]             base::close(...future.stdout)
[18:03:59.703]         }, add = TRUE)
[18:03:59.703]     }
[18:03:59.703]     ...future.frame <- base::sys.nframe()
[18:03:59.703]     ...future.conditions <- base::list()
[18:03:59.703]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.703]     if (FALSE) {
[18:03:59.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.703]     }
[18:03:59.703]     ...future.result <- base::tryCatch({
[18:03:59.703]         base::withCallingHandlers({
[18:03:59.703]             ...future.value <- base::withVisible(base::local({
[18:03:59.703]                 withCallingHandlers({
[18:03:59.703]                   {
[18:03:59.703]                     x <- 3
[18:03:59.703]                     stop("Woops!")
[18:03:59.703]                     x
[18:03:59.703]                   }
[18:03:59.703]                 }, immediateCondition = function(cond) {
[18:03:59.703]                   save_rds <- function (object, pathname, ...) 
[18:03:59.703]                   {
[18:03:59.703]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:03:59.703]                     if (file_test("-f", pathname_tmp)) {
[18:03:59.703]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.703]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:03:59.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.703]                         fi_tmp[["mtime"]])
[18:03:59.703]                     }
[18:03:59.703]                     tryCatch({
[18:03:59.703]                       saveRDS(object, file = pathname_tmp, ...)
[18:03:59.703]                     }, error = function(ex) {
[18:03:59.703]                       msg <- conditionMessage(ex)
[18:03:59.703]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.703]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:03:59.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.703]                         fi_tmp[["mtime"]], msg)
[18:03:59.703]                       ex$message <- msg
[18:03:59.703]                       stop(ex)
[18:03:59.703]                     })
[18:03:59.703]                     stopifnot(file_test("-f", pathname_tmp))
[18:03:59.703]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:03:59.703]                     if (!res || file_test("-f", pathname_tmp)) {
[18:03:59.703]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.703]                       fi <- file.info(pathname)
[18:03:59.703]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:03:59.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.703]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:03:59.703]                         fi[["size"]], fi[["mtime"]])
[18:03:59.703]                       stop(msg)
[18:03:59.703]                     }
[18:03:59.703]                     invisible(pathname)
[18:03:59.703]                   }
[18:03:59.703]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:03:59.703]                     rootPath = tempdir()) 
[18:03:59.703]                   {
[18:03:59.703]                     obj <- list(time = Sys.time(), condition = cond)
[18:03:59.703]                     file <- tempfile(pattern = class(cond)[1], 
[18:03:59.703]                       tmpdir = path, fileext = ".rds")
[18:03:59.703]                     save_rds(obj, file)
[18:03:59.703]                   }
[18:03:59.703]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:03:59.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.703]                   {
[18:03:59.703]                     inherits <- base::inherits
[18:03:59.703]                     invokeRestart <- base::invokeRestart
[18:03:59.703]                     is.null <- base::is.null
[18:03:59.703]                     muffled <- FALSE
[18:03:59.703]                     if (inherits(cond, "message")) {
[18:03:59.703]                       muffled <- grepl(pattern, "muffleMessage")
[18:03:59.703]                       if (muffled) 
[18:03:59.703]                         invokeRestart("muffleMessage")
[18:03:59.703]                     }
[18:03:59.703]                     else if (inherits(cond, "warning")) {
[18:03:59.703]                       muffled <- grepl(pattern, "muffleWarning")
[18:03:59.703]                       if (muffled) 
[18:03:59.703]                         invokeRestart("muffleWarning")
[18:03:59.703]                     }
[18:03:59.703]                     else if (inherits(cond, "condition")) {
[18:03:59.703]                       if (!is.null(pattern)) {
[18:03:59.703]                         computeRestarts <- base::computeRestarts
[18:03:59.703]                         grepl <- base::grepl
[18:03:59.703]                         restarts <- computeRestarts(cond)
[18:03:59.703]                         for (restart in restarts) {
[18:03:59.703]                           name <- restart$name
[18:03:59.703]                           if (is.null(name)) 
[18:03:59.703]                             next
[18:03:59.703]                           if (!grepl(pattern, name)) 
[18:03:59.703]                             next
[18:03:59.703]                           invokeRestart(restart)
[18:03:59.703]                           muffled <- TRUE
[18:03:59.703]                           break
[18:03:59.703]                         }
[18:03:59.703]                       }
[18:03:59.703]                     }
[18:03:59.703]                     invisible(muffled)
[18:03:59.703]                   }
[18:03:59.703]                   muffleCondition(cond)
[18:03:59.703]                 })
[18:03:59.703]             }))
[18:03:59.703]             future::FutureResult(value = ...future.value$value, 
[18:03:59.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.703]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.703]                     ...future.globalenv.names))
[18:03:59.703]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.703]         }, condition = base::local({
[18:03:59.703]             c <- base::c
[18:03:59.703]             inherits <- base::inherits
[18:03:59.703]             invokeRestart <- base::invokeRestart
[18:03:59.703]             length <- base::length
[18:03:59.703]             list <- base::list
[18:03:59.703]             seq.int <- base::seq.int
[18:03:59.703]             signalCondition <- base::signalCondition
[18:03:59.703]             sys.calls <- base::sys.calls
[18:03:59.703]             `[[` <- base::`[[`
[18:03:59.703]             `+` <- base::`+`
[18:03:59.703]             `<<-` <- base::`<<-`
[18:03:59.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.703]                   3L)]
[18:03:59.703]             }
[18:03:59.703]             function(cond) {
[18:03:59.703]                 is_error <- inherits(cond, "error")
[18:03:59.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.703]                   NULL)
[18:03:59.703]                 if (is_error) {
[18:03:59.703]                   sessionInformation <- function() {
[18:03:59.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.703]                       search = base::search(), system = base::Sys.info())
[18:03:59.703]                   }
[18:03:59.703]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.703]                     cond$call), session = sessionInformation(), 
[18:03:59.703]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.703]                   signalCondition(cond)
[18:03:59.703]                 }
[18:03:59.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.703]                 "immediateCondition"))) {
[18:03:59.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.703]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.703]                   if (TRUE && !signal) {
[18:03:59.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.703]                     {
[18:03:59.703]                       inherits <- base::inherits
[18:03:59.703]                       invokeRestart <- base::invokeRestart
[18:03:59.703]                       is.null <- base::is.null
[18:03:59.703]                       muffled <- FALSE
[18:03:59.703]                       if (inherits(cond, "message")) {
[18:03:59.703]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.703]                         if (muffled) 
[18:03:59.703]                           invokeRestart("muffleMessage")
[18:03:59.703]                       }
[18:03:59.703]                       else if (inherits(cond, "warning")) {
[18:03:59.703]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.703]                         if (muffled) 
[18:03:59.703]                           invokeRestart("muffleWarning")
[18:03:59.703]                       }
[18:03:59.703]                       else if (inherits(cond, "condition")) {
[18:03:59.703]                         if (!is.null(pattern)) {
[18:03:59.703]                           computeRestarts <- base::computeRestarts
[18:03:59.703]                           grepl <- base::grepl
[18:03:59.703]                           restarts <- computeRestarts(cond)
[18:03:59.703]                           for (restart in restarts) {
[18:03:59.703]                             name <- restart$name
[18:03:59.703]                             if (is.null(name)) 
[18:03:59.703]                               next
[18:03:59.703]                             if (!grepl(pattern, name)) 
[18:03:59.703]                               next
[18:03:59.703]                             invokeRestart(restart)
[18:03:59.703]                             muffled <- TRUE
[18:03:59.703]                             break
[18:03:59.703]                           }
[18:03:59.703]                         }
[18:03:59.703]                       }
[18:03:59.703]                       invisible(muffled)
[18:03:59.703]                     }
[18:03:59.703]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.703]                   }
[18:03:59.703]                 }
[18:03:59.703]                 else {
[18:03:59.703]                   if (TRUE) {
[18:03:59.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.703]                     {
[18:03:59.703]                       inherits <- base::inherits
[18:03:59.703]                       invokeRestart <- base::invokeRestart
[18:03:59.703]                       is.null <- base::is.null
[18:03:59.703]                       muffled <- FALSE
[18:03:59.703]                       if (inherits(cond, "message")) {
[18:03:59.703]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.703]                         if (muffled) 
[18:03:59.703]                           invokeRestart("muffleMessage")
[18:03:59.703]                       }
[18:03:59.703]                       else if (inherits(cond, "warning")) {
[18:03:59.703]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.703]                         if (muffled) 
[18:03:59.703]                           invokeRestart("muffleWarning")
[18:03:59.703]                       }
[18:03:59.703]                       else if (inherits(cond, "condition")) {
[18:03:59.703]                         if (!is.null(pattern)) {
[18:03:59.703]                           computeRestarts <- base::computeRestarts
[18:03:59.703]                           grepl <- base::grepl
[18:03:59.703]                           restarts <- computeRestarts(cond)
[18:03:59.703]                           for (restart in restarts) {
[18:03:59.703]                             name <- restart$name
[18:03:59.703]                             if (is.null(name)) 
[18:03:59.703]                               next
[18:03:59.703]                             if (!grepl(pattern, name)) 
[18:03:59.703]                               next
[18:03:59.703]                             invokeRestart(restart)
[18:03:59.703]                             muffled <- TRUE
[18:03:59.703]                             break
[18:03:59.703]                           }
[18:03:59.703]                         }
[18:03:59.703]                       }
[18:03:59.703]                       invisible(muffled)
[18:03:59.703]                     }
[18:03:59.703]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.703]                   }
[18:03:59.703]                 }
[18:03:59.703]             }
[18:03:59.703]         }))
[18:03:59.703]     }, error = function(ex) {
[18:03:59.703]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.703]                 ...future.rng), started = ...future.startTime, 
[18:03:59.703]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.703]             version = "1.8"), class = "FutureResult")
[18:03:59.703]     }, finally = {
[18:03:59.703]         if (!identical(...future.workdir, getwd())) 
[18:03:59.703]             setwd(...future.workdir)
[18:03:59.703]         {
[18:03:59.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.703]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.703]             }
[18:03:59.703]             base::options(...future.oldOptions)
[18:03:59.703]             if (.Platform$OS.type == "windows") {
[18:03:59.703]                 old_names <- names(...future.oldEnvVars)
[18:03:59.703]                 envs <- base::Sys.getenv()
[18:03:59.703]                 names <- names(envs)
[18:03:59.703]                 common <- intersect(names, old_names)
[18:03:59.703]                 added <- setdiff(names, old_names)
[18:03:59.703]                 removed <- setdiff(old_names, names)
[18:03:59.703]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.703]                   envs[common]]
[18:03:59.703]                 NAMES <- toupper(changed)
[18:03:59.703]                 args <- list()
[18:03:59.703]                 for (kk in seq_along(NAMES)) {
[18:03:59.703]                   name <- changed[[kk]]
[18:03:59.703]                   NAME <- NAMES[[kk]]
[18:03:59.703]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.703]                     next
[18:03:59.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.703]                 }
[18:03:59.703]                 NAMES <- toupper(added)
[18:03:59.703]                 for (kk in seq_along(NAMES)) {
[18:03:59.703]                   name <- added[[kk]]
[18:03:59.703]                   NAME <- NAMES[[kk]]
[18:03:59.703]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.703]                     next
[18:03:59.703]                   args[[name]] <- ""
[18:03:59.703]                 }
[18:03:59.703]                 NAMES <- toupper(removed)
[18:03:59.703]                 for (kk in seq_along(NAMES)) {
[18:03:59.703]                   name <- removed[[kk]]
[18:03:59.703]                   NAME <- NAMES[[kk]]
[18:03:59.703]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.703]                     next
[18:03:59.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.703]                 }
[18:03:59.703]                 if (length(args) > 0) 
[18:03:59.703]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.703]             }
[18:03:59.703]             else {
[18:03:59.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.703]             }
[18:03:59.703]             {
[18:03:59.703]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.703]                   0L) {
[18:03:59.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.703]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.703]                   base::options(opts)
[18:03:59.703]                 }
[18:03:59.703]                 {
[18:03:59.703]                   {
[18:03:59.703]                     base::options(mc.cores = ...future.mc.cores.old)
[18:03:59.703]                     NULL
[18:03:59.703]                   }
[18:03:59.703]                   options(future.plan = NULL)
[18:03:59.703]                   if (is.na(NA_character_)) 
[18:03:59.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.703]                     .init = FALSE)
[18:03:59.703]                 }
[18:03:59.703]             }
[18:03:59.703]         }
[18:03:59.703]     })
[18:03:59.703]     if (TRUE) {
[18:03:59.703]         base::sink(type = "output", split = FALSE)
[18:03:59.703]         if (TRUE) {
[18:03:59.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.703]         }
[18:03:59.703]         else {
[18:03:59.703]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.703]         }
[18:03:59.703]         base::close(...future.stdout)
[18:03:59.703]         ...future.stdout <- NULL
[18:03:59.703]     }
[18:03:59.703]     ...future.result$conditions <- ...future.conditions
[18:03:59.703]     ...future.result$finished <- base::Sys.time()
[18:03:59.703]     ...future.result
[18:03:59.703] }
[18:03:59.708] requestCore(): workers = 2
[18:03:59.712] MulticoreFuture started
[18:03:59.713] - Launch lazy future ... done
[18:03:59.714] run() for ‘MulticoreFuture’ ... done
[18:03:59.715] result() for MulticoreFuture ...
[18:03:59.717] plan(): Setting new future strategy stack:
[18:03:59.718] List of future strategies:
[18:03:59.718] 1. sequential:
[18:03:59.718]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.718]    - tweaked: FALSE
[18:03:59.718]    - call: NULL
[18:03:59.720] plan(): nbrOfWorkers() = 1
[18:03:59.725] plan(): Setting new future strategy stack:
[18:03:59.725] List of future strategies:
[18:03:59.725] 1. multicore:
[18:03:59.725]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:03:59.725]    - tweaked: FALSE
[18:03:59.725]    - call: plan(strategy)
[18:03:59.736] plan(): nbrOfWorkers() = 2
[18:03:59.746] result() for MulticoreFuture ...
[18:03:59.746] result() for MulticoreFuture ... done
[18:03:59.747] signalConditions() ...
[18:03:59.747]  - include = ‘immediateCondition’
[18:03:59.747]  - exclude = 
[18:03:59.747]  - resignal = FALSE
[18:03:59.748]  - Number of conditions: 1
[18:03:59.749] signalConditions() ... done
[18:03:59.749] result() for MulticoreFuture ... done
[18:03:59.749] result() for MulticoreFuture ...
[18:03:59.750] result() for MulticoreFuture ... done
[18:03:59.750] signalConditions() ...
[18:03:59.750]  - include = ‘immediateCondition’
[18:03:59.750]  - exclude = 
[18:03:59.751]  - resignal = FALSE
[18:03:59.751]  - Number of conditions: 1
[18:03:59.751] signalConditions() ... done
[18:03:59.751] Future state: ‘finished’
[18:03:59.752] result() for MulticoreFuture ...
[18:03:59.752] result() for MulticoreFuture ... done
[18:03:59.752] signalConditions() ...
[18:03:59.752]  - include = ‘condition’
[18:03:59.753]  - exclude = ‘immediateCondition’
[18:03:59.753]  - resignal = TRUE
[18:03:59.753]  - Number of conditions: 1
[18:03:59.754]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:03:59.754] signalConditions() ... done
[18:03:59.755] getGlobalsAndPackages() ...
[18:03:59.755] Searching for globals...
[18:03:59.764] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:03:59.764] Searching for globals ... DONE
[18:03:59.764] Resolving globals: FALSE
[18:03:59.766] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.767] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:03:59.767] - globals: [1] ‘ii’
[18:03:59.768] 
[18:03:59.768] getGlobalsAndPackages() ... DONE
[18:03:59.769] run() for ‘Future’ ...
[18:03:59.769] - state: ‘created’
[18:03:59.769] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:03:59.776] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:03:59.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:03:59.777]   - Field: ‘label’
[18:03:59.778]   - Field: ‘local’
[18:03:59.778]   - Field: ‘owner’
[18:03:59.778]   - Field: ‘envir’
[18:03:59.778]   - Field: ‘workers’
[18:03:59.779]   - Field: ‘packages’
[18:03:59.779]   - Field: ‘gc’
[18:03:59.779]   - Field: ‘job’
[18:03:59.779]   - Field: ‘conditions’
[18:03:59.780]   - Field: ‘expr’
[18:03:59.780]   - Field: ‘uuid’
[18:03:59.780]   - Field: ‘seed’
[18:03:59.780]   - Field: ‘version’
[18:03:59.781]   - Field: ‘result’
[18:03:59.781]   - Field: ‘asynchronous’
[18:03:59.781]   - Field: ‘calls’
[18:03:59.781]   - Field: ‘globals’
[18:03:59.782]   - Field: ‘stdout’
[18:03:59.782]   - Field: ‘earlySignal’
[18:03:59.782]   - Field: ‘lazy’
[18:03:59.782]   - Field: ‘state’
[18:03:59.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:03:59.783] - Launch lazy future ...
[18:03:59.784] Packages needed by the future expression (n = 0): <none>
[18:03:59.784] Packages needed by future strategies (n = 0): <none>
[18:03:59.785] {
[18:03:59.785]     {
[18:03:59.785]         {
[18:03:59.785]             ...future.startTime <- base::Sys.time()
[18:03:59.785]             {
[18:03:59.785]                 {
[18:03:59.785]                   {
[18:03:59.785]                     {
[18:03:59.785]                       base::local({
[18:03:59.785]                         has_future <- base::requireNamespace("future", 
[18:03:59.785]                           quietly = TRUE)
[18:03:59.785]                         if (has_future) {
[18:03:59.785]                           ns <- base::getNamespace("future")
[18:03:59.785]                           version <- ns[[".package"]][["version"]]
[18:03:59.785]                           if (is.null(version)) 
[18:03:59.785]                             version <- utils::packageVersion("future")
[18:03:59.785]                         }
[18:03:59.785]                         else {
[18:03:59.785]                           version <- NULL
[18:03:59.785]                         }
[18:03:59.785]                         if (!has_future || version < "1.8.0") {
[18:03:59.785]                           info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.785]                             "", base::R.version$version.string), 
[18:03:59.785]                             platform = base::sprintf("%s (%s-bit)", 
[18:03:59.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.785]                               "release", "version")], collapse = " "), 
[18:03:59.785]                             hostname = base::Sys.info()[["nodename"]])
[18:03:59.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.785]                             info)
[18:03:59.785]                           info <- base::paste(info, collapse = "; ")
[18:03:59.785]                           if (!has_future) {
[18:03:59.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.785]                               info)
[18:03:59.785]                           }
[18:03:59.785]                           else {
[18:03:59.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.785]                               info, version)
[18:03:59.785]                           }
[18:03:59.785]                           base::stop(msg)
[18:03:59.785]                         }
[18:03:59.785]                       })
[18:03:59.785]                     }
[18:03:59.785]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:03:59.785]                     base::options(mc.cores = 1L)
[18:03:59.785]                   }
[18:03:59.785]                   ...future.strategy.old <- future::plan("list")
[18:03:59.785]                   options(future.plan = NULL)
[18:03:59.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.785]                 }
[18:03:59.785]                 ...future.workdir <- getwd()
[18:03:59.785]             }
[18:03:59.785]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.785]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.785]         }
[18:03:59.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.785]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.785]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.785]             base::names(...future.oldOptions))
[18:03:59.785]     }
[18:03:59.785]     if (FALSE) {
[18:03:59.785]     }
[18:03:59.785]     else {
[18:03:59.785]         if (TRUE) {
[18:03:59.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.785]                 open = "w")
[18:03:59.785]         }
[18:03:59.785]         else {
[18:03:59.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.785]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.785]         }
[18:03:59.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.785]             base::sink(type = "output", split = FALSE)
[18:03:59.785]             base::close(...future.stdout)
[18:03:59.785]         }, add = TRUE)
[18:03:59.785]     }
[18:03:59.785]     ...future.frame <- base::sys.nframe()
[18:03:59.785]     ...future.conditions <- base::list()
[18:03:59.785]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.785]     if (FALSE) {
[18:03:59.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.785]     }
[18:03:59.785]     ...future.result <- base::tryCatch({
[18:03:59.785]         base::withCallingHandlers({
[18:03:59.785]             ...future.value <- base::withVisible(base::local({
[18:03:59.785]                 withCallingHandlers({
[18:03:59.785]                   {
[18:03:59.785]                     if (ii%%2 == 0) 
[18:03:59.785]                       stop("Woops!")
[18:03:59.785]                     ii
[18:03:59.785]                   }
[18:03:59.785]                 }, immediateCondition = function(cond) {
[18:03:59.785]                   save_rds <- function (object, pathname, ...) 
[18:03:59.785]                   {
[18:03:59.785]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:03:59.785]                     if (file_test("-f", pathname_tmp)) {
[18:03:59.785]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.785]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:03:59.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.785]                         fi_tmp[["mtime"]])
[18:03:59.785]                     }
[18:03:59.785]                     tryCatch({
[18:03:59.785]                       saveRDS(object, file = pathname_tmp, ...)
[18:03:59.785]                     }, error = function(ex) {
[18:03:59.785]                       msg <- conditionMessage(ex)
[18:03:59.785]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.785]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:03:59.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.785]                         fi_tmp[["mtime"]], msg)
[18:03:59.785]                       ex$message <- msg
[18:03:59.785]                       stop(ex)
[18:03:59.785]                     })
[18:03:59.785]                     stopifnot(file_test("-f", pathname_tmp))
[18:03:59.785]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:03:59.785]                     if (!res || file_test("-f", pathname_tmp)) {
[18:03:59.785]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.785]                       fi <- file.info(pathname)
[18:03:59.785]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:03:59.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.785]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:03:59.785]                         fi[["size"]], fi[["mtime"]])
[18:03:59.785]                       stop(msg)
[18:03:59.785]                     }
[18:03:59.785]                     invisible(pathname)
[18:03:59.785]                   }
[18:03:59.785]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:03:59.785]                     rootPath = tempdir()) 
[18:03:59.785]                   {
[18:03:59.785]                     obj <- list(time = Sys.time(), condition = cond)
[18:03:59.785]                     file <- tempfile(pattern = class(cond)[1], 
[18:03:59.785]                       tmpdir = path, fileext = ".rds")
[18:03:59.785]                     save_rds(obj, file)
[18:03:59.785]                   }
[18:03:59.785]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:03:59.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.785]                   {
[18:03:59.785]                     inherits <- base::inherits
[18:03:59.785]                     invokeRestart <- base::invokeRestart
[18:03:59.785]                     is.null <- base::is.null
[18:03:59.785]                     muffled <- FALSE
[18:03:59.785]                     if (inherits(cond, "message")) {
[18:03:59.785]                       muffled <- grepl(pattern, "muffleMessage")
[18:03:59.785]                       if (muffled) 
[18:03:59.785]                         invokeRestart("muffleMessage")
[18:03:59.785]                     }
[18:03:59.785]                     else if (inherits(cond, "warning")) {
[18:03:59.785]                       muffled <- grepl(pattern, "muffleWarning")
[18:03:59.785]                       if (muffled) 
[18:03:59.785]                         invokeRestart("muffleWarning")
[18:03:59.785]                     }
[18:03:59.785]                     else if (inherits(cond, "condition")) {
[18:03:59.785]                       if (!is.null(pattern)) {
[18:03:59.785]                         computeRestarts <- base::computeRestarts
[18:03:59.785]                         grepl <- base::grepl
[18:03:59.785]                         restarts <- computeRestarts(cond)
[18:03:59.785]                         for (restart in restarts) {
[18:03:59.785]                           name <- restart$name
[18:03:59.785]                           if (is.null(name)) 
[18:03:59.785]                             next
[18:03:59.785]                           if (!grepl(pattern, name)) 
[18:03:59.785]                             next
[18:03:59.785]                           invokeRestart(restart)
[18:03:59.785]                           muffled <- TRUE
[18:03:59.785]                           break
[18:03:59.785]                         }
[18:03:59.785]                       }
[18:03:59.785]                     }
[18:03:59.785]                     invisible(muffled)
[18:03:59.785]                   }
[18:03:59.785]                   muffleCondition(cond)
[18:03:59.785]                 })
[18:03:59.785]             }))
[18:03:59.785]             future::FutureResult(value = ...future.value$value, 
[18:03:59.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.785]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.785]                     ...future.globalenv.names))
[18:03:59.785]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.785]         }, condition = base::local({
[18:03:59.785]             c <- base::c
[18:03:59.785]             inherits <- base::inherits
[18:03:59.785]             invokeRestart <- base::invokeRestart
[18:03:59.785]             length <- base::length
[18:03:59.785]             list <- base::list
[18:03:59.785]             seq.int <- base::seq.int
[18:03:59.785]             signalCondition <- base::signalCondition
[18:03:59.785]             sys.calls <- base::sys.calls
[18:03:59.785]             `[[` <- base::`[[`
[18:03:59.785]             `+` <- base::`+`
[18:03:59.785]             `<<-` <- base::`<<-`
[18:03:59.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.785]                   3L)]
[18:03:59.785]             }
[18:03:59.785]             function(cond) {
[18:03:59.785]                 is_error <- inherits(cond, "error")
[18:03:59.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.785]                   NULL)
[18:03:59.785]                 if (is_error) {
[18:03:59.785]                   sessionInformation <- function() {
[18:03:59.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.785]                       search = base::search(), system = base::Sys.info())
[18:03:59.785]                   }
[18:03:59.785]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.785]                     cond$call), session = sessionInformation(), 
[18:03:59.785]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.785]                   signalCondition(cond)
[18:03:59.785]                 }
[18:03:59.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.785]                 "immediateCondition"))) {
[18:03:59.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.785]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.785]                   if (TRUE && !signal) {
[18:03:59.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.785]                     {
[18:03:59.785]                       inherits <- base::inherits
[18:03:59.785]                       invokeRestart <- base::invokeRestart
[18:03:59.785]                       is.null <- base::is.null
[18:03:59.785]                       muffled <- FALSE
[18:03:59.785]                       if (inherits(cond, "message")) {
[18:03:59.785]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.785]                         if (muffled) 
[18:03:59.785]                           invokeRestart("muffleMessage")
[18:03:59.785]                       }
[18:03:59.785]                       else if (inherits(cond, "warning")) {
[18:03:59.785]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.785]                         if (muffled) 
[18:03:59.785]                           invokeRestart("muffleWarning")
[18:03:59.785]                       }
[18:03:59.785]                       else if (inherits(cond, "condition")) {
[18:03:59.785]                         if (!is.null(pattern)) {
[18:03:59.785]                           computeRestarts <- base::computeRestarts
[18:03:59.785]                           grepl <- base::grepl
[18:03:59.785]                           restarts <- computeRestarts(cond)
[18:03:59.785]                           for (restart in restarts) {
[18:03:59.785]                             name <- restart$name
[18:03:59.785]                             if (is.null(name)) 
[18:03:59.785]                               next
[18:03:59.785]                             if (!grepl(pattern, name)) 
[18:03:59.785]                               next
[18:03:59.785]                             invokeRestart(restart)
[18:03:59.785]                             muffled <- TRUE
[18:03:59.785]                             break
[18:03:59.785]                           }
[18:03:59.785]                         }
[18:03:59.785]                       }
[18:03:59.785]                       invisible(muffled)
[18:03:59.785]                     }
[18:03:59.785]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.785]                   }
[18:03:59.785]                 }
[18:03:59.785]                 else {
[18:03:59.785]                   if (TRUE) {
[18:03:59.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.785]                     {
[18:03:59.785]                       inherits <- base::inherits
[18:03:59.785]                       invokeRestart <- base::invokeRestart
[18:03:59.785]                       is.null <- base::is.null
[18:03:59.785]                       muffled <- FALSE
[18:03:59.785]                       if (inherits(cond, "message")) {
[18:03:59.785]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.785]                         if (muffled) 
[18:03:59.785]                           invokeRestart("muffleMessage")
[18:03:59.785]                       }
[18:03:59.785]                       else if (inherits(cond, "warning")) {
[18:03:59.785]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.785]                         if (muffled) 
[18:03:59.785]                           invokeRestart("muffleWarning")
[18:03:59.785]                       }
[18:03:59.785]                       else if (inherits(cond, "condition")) {
[18:03:59.785]                         if (!is.null(pattern)) {
[18:03:59.785]                           computeRestarts <- base::computeRestarts
[18:03:59.785]                           grepl <- base::grepl
[18:03:59.785]                           restarts <- computeRestarts(cond)
[18:03:59.785]                           for (restart in restarts) {
[18:03:59.785]                             name <- restart$name
[18:03:59.785]                             if (is.null(name)) 
[18:03:59.785]                               next
[18:03:59.785]                             if (!grepl(pattern, name)) 
[18:03:59.785]                               next
[18:03:59.785]                             invokeRestart(restart)
[18:03:59.785]                             muffled <- TRUE
[18:03:59.785]                             break
[18:03:59.785]                           }
[18:03:59.785]                         }
[18:03:59.785]                       }
[18:03:59.785]                       invisible(muffled)
[18:03:59.785]                     }
[18:03:59.785]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.785]                   }
[18:03:59.785]                 }
[18:03:59.785]             }
[18:03:59.785]         }))
[18:03:59.785]     }, error = function(ex) {
[18:03:59.785]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.785]                 ...future.rng), started = ...future.startTime, 
[18:03:59.785]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.785]             version = "1.8"), class = "FutureResult")
[18:03:59.785]     }, finally = {
[18:03:59.785]         if (!identical(...future.workdir, getwd())) 
[18:03:59.785]             setwd(...future.workdir)
[18:03:59.785]         {
[18:03:59.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.785]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.785]             }
[18:03:59.785]             base::options(...future.oldOptions)
[18:03:59.785]             if (.Platform$OS.type == "windows") {
[18:03:59.785]                 old_names <- names(...future.oldEnvVars)
[18:03:59.785]                 envs <- base::Sys.getenv()
[18:03:59.785]                 names <- names(envs)
[18:03:59.785]                 common <- intersect(names, old_names)
[18:03:59.785]                 added <- setdiff(names, old_names)
[18:03:59.785]                 removed <- setdiff(old_names, names)
[18:03:59.785]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.785]                   envs[common]]
[18:03:59.785]                 NAMES <- toupper(changed)
[18:03:59.785]                 args <- list()
[18:03:59.785]                 for (kk in seq_along(NAMES)) {
[18:03:59.785]                   name <- changed[[kk]]
[18:03:59.785]                   NAME <- NAMES[[kk]]
[18:03:59.785]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.785]                     next
[18:03:59.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.785]                 }
[18:03:59.785]                 NAMES <- toupper(added)
[18:03:59.785]                 for (kk in seq_along(NAMES)) {
[18:03:59.785]                   name <- added[[kk]]
[18:03:59.785]                   NAME <- NAMES[[kk]]
[18:03:59.785]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.785]                     next
[18:03:59.785]                   args[[name]] <- ""
[18:03:59.785]                 }
[18:03:59.785]                 NAMES <- toupper(removed)
[18:03:59.785]                 for (kk in seq_along(NAMES)) {
[18:03:59.785]                   name <- removed[[kk]]
[18:03:59.785]                   NAME <- NAMES[[kk]]
[18:03:59.785]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.785]                     next
[18:03:59.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.785]                 }
[18:03:59.785]                 if (length(args) > 0) 
[18:03:59.785]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.785]             }
[18:03:59.785]             else {
[18:03:59.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.785]             }
[18:03:59.785]             {
[18:03:59.785]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.785]                   0L) {
[18:03:59.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.785]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.785]                   base::options(opts)
[18:03:59.785]                 }
[18:03:59.785]                 {
[18:03:59.785]                   {
[18:03:59.785]                     base::options(mc.cores = ...future.mc.cores.old)
[18:03:59.785]                     NULL
[18:03:59.785]                   }
[18:03:59.785]                   options(future.plan = NULL)
[18:03:59.785]                   if (is.na(NA_character_)) 
[18:03:59.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.785]                     .init = FALSE)
[18:03:59.785]                 }
[18:03:59.785]             }
[18:03:59.785]         }
[18:03:59.785]     })
[18:03:59.785]     if (TRUE) {
[18:03:59.785]         base::sink(type = "output", split = FALSE)
[18:03:59.785]         if (TRUE) {
[18:03:59.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.785]         }
[18:03:59.785]         else {
[18:03:59.785]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.785]         }
[18:03:59.785]         base::close(...future.stdout)
[18:03:59.785]         ...future.stdout <- NULL
[18:03:59.785]     }
[18:03:59.785]     ...future.result$conditions <- ...future.conditions
[18:03:59.785]     ...future.result$finished <- base::Sys.time()
[18:03:59.785]     ...future.result
[18:03:59.785] }
[18:03:59.790] assign_globals() ...
[18:03:59.790] List of 1
[18:03:59.790]  $ ii: int 1
[18:03:59.790]  - attr(*, "where")=List of 1
[18:03:59.790]   ..$ ii:<environment: R_EmptyEnv> 
[18:03:59.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.790]  - attr(*, "resolved")= logi FALSE
[18:03:59.790]  - attr(*, "total_size")= num 56
[18:03:59.790]  - attr(*, "already-done")= logi TRUE
[18:03:59.796] - copied ‘ii’ to environment
[18:03:59.797] assign_globals() ... done
[18:03:59.797] requestCore(): workers = 2
[18:03:59.801] MulticoreFuture started
[18:03:59.801] - Launch lazy future ... done
[18:03:59.804] run() for ‘MulticoreFuture’ ... done
[18:03:59.806] plan(): Setting new future strategy stack:
[18:03:59.808] getGlobalsAndPackages() ...
[18:03:59.808] Searching for globals...
[18:03:59.807] List of future strategies:
[18:03:59.807] 1. sequential:
[18:03:59.807]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.807]    - tweaked: FALSE
[18:03:59.807]    - call: NULL
[18:03:59.811] plan(): nbrOfWorkers() = 1
[18:03:59.817] plan(): Setting new future strategy stack:
[18:03:59.818] List of future strategies:
[18:03:59.818] 1. multicore:
[18:03:59.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:03:59.818]    - tweaked: FALSE
[18:03:59.818]    - call: plan(strategy)
[18:03:59.823] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:03:59.825] Searching for globals ... DONE
[18:03:59.826] Resolving globals: FALSE
[18:03:59.829] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.832] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:03:59.833] - globals: [1] ‘ii’
[18:03:59.834] 
[18:03:59.835] getGlobalsAndPackages() ... DONE
[18:03:59.836] plan(): nbrOfWorkers() = 2
[18:03:59.836] run() for ‘Future’ ...
[18:03:59.837] - state: ‘created’
[18:03:59.838] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:03:59.846] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:03:59.847] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:03:59.847]   - Field: ‘label’
[18:03:59.848]   - Field: ‘local’
[18:03:59.848]   - Field: ‘owner’
[18:03:59.849]   - Field: ‘envir’
[18:03:59.849]   - Field: ‘workers’
[18:03:59.849]   - Field: ‘packages’
[18:03:59.850]   - Field: ‘gc’
[18:03:59.850]   - Field: ‘job’
[18:03:59.850]   - Field: ‘conditions’
[18:03:59.851]   - Field: ‘expr’
[18:03:59.851]   - Field: ‘uuid’
[18:03:59.851]   - Field: ‘seed’
[18:03:59.852]   - Field: ‘version’
[18:03:59.852]   - Field: ‘result’
[18:03:59.852]   - Field: ‘asynchronous’
[18:03:59.853]   - Field: ‘calls’
[18:03:59.853]   - Field: ‘globals’
[18:03:59.853]   - Field: ‘stdout’
[18:03:59.854]   - Field: ‘earlySignal’
[18:03:59.854]   - Field: ‘lazy’
[18:03:59.854]   - Field: ‘state’
[18:03:59.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:03:59.855] - Launch lazy future ...
[18:03:59.856] Packages needed by the future expression (n = 0): <none>
[18:03:59.856] Packages needed by future strategies (n = 0): <none>
[18:03:59.858] {
[18:03:59.858]     {
[18:03:59.858]         {
[18:03:59.858]             ...future.startTime <- base::Sys.time()
[18:03:59.858]             {
[18:03:59.858]                 {
[18:03:59.858]                   {
[18:03:59.858]                     {
[18:03:59.858]                       base::local({
[18:03:59.858]                         has_future <- base::requireNamespace("future", 
[18:03:59.858]                           quietly = TRUE)
[18:03:59.858]                         if (has_future) {
[18:03:59.858]                           ns <- base::getNamespace("future")
[18:03:59.858]                           version <- ns[[".package"]][["version"]]
[18:03:59.858]                           if (is.null(version)) 
[18:03:59.858]                             version <- utils::packageVersion("future")
[18:03:59.858]                         }
[18:03:59.858]                         else {
[18:03:59.858]                           version <- NULL
[18:03:59.858]                         }
[18:03:59.858]                         if (!has_future || version < "1.8.0") {
[18:03:59.858]                           info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.858]                             "", base::R.version$version.string), 
[18:03:59.858]                             platform = base::sprintf("%s (%s-bit)", 
[18:03:59.858]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.858]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.858]                               "release", "version")], collapse = " "), 
[18:03:59.858]                             hostname = base::Sys.info()[["nodename"]])
[18:03:59.858]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.858]                             info)
[18:03:59.858]                           info <- base::paste(info, collapse = "; ")
[18:03:59.858]                           if (!has_future) {
[18:03:59.858]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.858]                               info)
[18:03:59.858]                           }
[18:03:59.858]                           else {
[18:03:59.858]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.858]                               info, version)
[18:03:59.858]                           }
[18:03:59.858]                           base::stop(msg)
[18:03:59.858]                         }
[18:03:59.858]                       })
[18:03:59.858]                     }
[18:03:59.858]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:03:59.858]                     base::options(mc.cores = 1L)
[18:03:59.858]                   }
[18:03:59.858]                   ...future.strategy.old <- future::plan("list")
[18:03:59.858]                   options(future.plan = NULL)
[18:03:59.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.858]                 }
[18:03:59.858]                 ...future.workdir <- getwd()
[18:03:59.858]             }
[18:03:59.858]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.858]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.858]         }
[18:03:59.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.858]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.858]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.858]             base::names(...future.oldOptions))
[18:03:59.858]     }
[18:03:59.858]     if (FALSE) {
[18:03:59.858]     }
[18:03:59.858]     else {
[18:03:59.858]         if (TRUE) {
[18:03:59.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.858]                 open = "w")
[18:03:59.858]         }
[18:03:59.858]         else {
[18:03:59.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.858]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.858]         }
[18:03:59.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.858]             base::sink(type = "output", split = FALSE)
[18:03:59.858]             base::close(...future.stdout)
[18:03:59.858]         }, add = TRUE)
[18:03:59.858]     }
[18:03:59.858]     ...future.frame <- base::sys.nframe()
[18:03:59.858]     ...future.conditions <- base::list()
[18:03:59.858]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.858]     if (FALSE) {
[18:03:59.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.858]     }
[18:03:59.858]     ...future.result <- base::tryCatch({
[18:03:59.858]         base::withCallingHandlers({
[18:03:59.858]             ...future.value <- base::withVisible(base::local({
[18:03:59.858]                 withCallingHandlers({
[18:03:59.858]                   {
[18:03:59.858]                     if (ii%%2 == 0) 
[18:03:59.858]                       stop("Woops!")
[18:03:59.858]                     ii
[18:03:59.858]                   }
[18:03:59.858]                 }, immediateCondition = function(cond) {
[18:03:59.858]                   save_rds <- function (object, pathname, ...) 
[18:03:59.858]                   {
[18:03:59.858]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:03:59.858]                     if (file_test("-f", pathname_tmp)) {
[18:03:59.858]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.858]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:03:59.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.858]                         fi_tmp[["mtime"]])
[18:03:59.858]                     }
[18:03:59.858]                     tryCatch({
[18:03:59.858]                       saveRDS(object, file = pathname_tmp, ...)
[18:03:59.858]                     }, error = function(ex) {
[18:03:59.858]                       msg <- conditionMessage(ex)
[18:03:59.858]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.858]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:03:59.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.858]                         fi_tmp[["mtime"]], msg)
[18:03:59.858]                       ex$message <- msg
[18:03:59.858]                       stop(ex)
[18:03:59.858]                     })
[18:03:59.858]                     stopifnot(file_test("-f", pathname_tmp))
[18:03:59.858]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:03:59.858]                     if (!res || file_test("-f", pathname_tmp)) {
[18:03:59.858]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.858]                       fi <- file.info(pathname)
[18:03:59.858]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:03:59.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.858]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:03:59.858]                         fi[["size"]], fi[["mtime"]])
[18:03:59.858]                       stop(msg)
[18:03:59.858]                     }
[18:03:59.858]                     invisible(pathname)
[18:03:59.858]                   }
[18:03:59.858]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:03:59.858]                     rootPath = tempdir()) 
[18:03:59.858]                   {
[18:03:59.858]                     obj <- list(time = Sys.time(), condition = cond)
[18:03:59.858]                     file <- tempfile(pattern = class(cond)[1], 
[18:03:59.858]                       tmpdir = path, fileext = ".rds")
[18:03:59.858]                     save_rds(obj, file)
[18:03:59.858]                   }
[18:03:59.858]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:03:59.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.858]                   {
[18:03:59.858]                     inherits <- base::inherits
[18:03:59.858]                     invokeRestart <- base::invokeRestart
[18:03:59.858]                     is.null <- base::is.null
[18:03:59.858]                     muffled <- FALSE
[18:03:59.858]                     if (inherits(cond, "message")) {
[18:03:59.858]                       muffled <- grepl(pattern, "muffleMessage")
[18:03:59.858]                       if (muffled) 
[18:03:59.858]                         invokeRestart("muffleMessage")
[18:03:59.858]                     }
[18:03:59.858]                     else if (inherits(cond, "warning")) {
[18:03:59.858]                       muffled <- grepl(pattern, "muffleWarning")
[18:03:59.858]                       if (muffled) 
[18:03:59.858]                         invokeRestart("muffleWarning")
[18:03:59.858]                     }
[18:03:59.858]                     else if (inherits(cond, "condition")) {
[18:03:59.858]                       if (!is.null(pattern)) {
[18:03:59.858]                         computeRestarts <- base::computeRestarts
[18:03:59.858]                         grepl <- base::grepl
[18:03:59.858]                         restarts <- computeRestarts(cond)
[18:03:59.858]                         for (restart in restarts) {
[18:03:59.858]                           name <- restart$name
[18:03:59.858]                           if (is.null(name)) 
[18:03:59.858]                             next
[18:03:59.858]                           if (!grepl(pattern, name)) 
[18:03:59.858]                             next
[18:03:59.858]                           invokeRestart(restart)
[18:03:59.858]                           muffled <- TRUE
[18:03:59.858]                           break
[18:03:59.858]                         }
[18:03:59.858]                       }
[18:03:59.858]                     }
[18:03:59.858]                     invisible(muffled)
[18:03:59.858]                   }
[18:03:59.858]                   muffleCondition(cond)
[18:03:59.858]                 })
[18:03:59.858]             }))
[18:03:59.858]             future::FutureResult(value = ...future.value$value, 
[18:03:59.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.858]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.858]                     ...future.globalenv.names))
[18:03:59.858]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.858]         }, condition = base::local({
[18:03:59.858]             c <- base::c
[18:03:59.858]             inherits <- base::inherits
[18:03:59.858]             invokeRestart <- base::invokeRestart
[18:03:59.858]             length <- base::length
[18:03:59.858]             list <- base::list
[18:03:59.858]             seq.int <- base::seq.int
[18:03:59.858]             signalCondition <- base::signalCondition
[18:03:59.858]             sys.calls <- base::sys.calls
[18:03:59.858]             `[[` <- base::`[[`
[18:03:59.858]             `+` <- base::`+`
[18:03:59.858]             `<<-` <- base::`<<-`
[18:03:59.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.858]                   3L)]
[18:03:59.858]             }
[18:03:59.858]             function(cond) {
[18:03:59.858]                 is_error <- inherits(cond, "error")
[18:03:59.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.858]                   NULL)
[18:03:59.858]                 if (is_error) {
[18:03:59.858]                   sessionInformation <- function() {
[18:03:59.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.858]                       search = base::search(), system = base::Sys.info())
[18:03:59.858]                   }
[18:03:59.858]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.858]                     cond$call), session = sessionInformation(), 
[18:03:59.858]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.858]                   signalCondition(cond)
[18:03:59.858]                 }
[18:03:59.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.858]                 "immediateCondition"))) {
[18:03:59.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.858]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.858]                   if (TRUE && !signal) {
[18:03:59.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.858]                     {
[18:03:59.858]                       inherits <- base::inherits
[18:03:59.858]                       invokeRestart <- base::invokeRestart
[18:03:59.858]                       is.null <- base::is.null
[18:03:59.858]                       muffled <- FALSE
[18:03:59.858]                       if (inherits(cond, "message")) {
[18:03:59.858]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.858]                         if (muffled) 
[18:03:59.858]                           invokeRestart("muffleMessage")
[18:03:59.858]                       }
[18:03:59.858]                       else if (inherits(cond, "warning")) {
[18:03:59.858]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.858]                         if (muffled) 
[18:03:59.858]                           invokeRestart("muffleWarning")
[18:03:59.858]                       }
[18:03:59.858]                       else if (inherits(cond, "condition")) {
[18:03:59.858]                         if (!is.null(pattern)) {
[18:03:59.858]                           computeRestarts <- base::computeRestarts
[18:03:59.858]                           grepl <- base::grepl
[18:03:59.858]                           restarts <- computeRestarts(cond)
[18:03:59.858]                           for (restart in restarts) {
[18:03:59.858]                             name <- restart$name
[18:03:59.858]                             if (is.null(name)) 
[18:03:59.858]                               next
[18:03:59.858]                             if (!grepl(pattern, name)) 
[18:03:59.858]                               next
[18:03:59.858]                             invokeRestart(restart)
[18:03:59.858]                             muffled <- TRUE
[18:03:59.858]                             break
[18:03:59.858]                           }
[18:03:59.858]                         }
[18:03:59.858]                       }
[18:03:59.858]                       invisible(muffled)
[18:03:59.858]                     }
[18:03:59.858]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.858]                   }
[18:03:59.858]                 }
[18:03:59.858]                 else {
[18:03:59.858]                   if (TRUE) {
[18:03:59.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.858]                     {
[18:03:59.858]                       inherits <- base::inherits
[18:03:59.858]                       invokeRestart <- base::invokeRestart
[18:03:59.858]                       is.null <- base::is.null
[18:03:59.858]                       muffled <- FALSE
[18:03:59.858]                       if (inherits(cond, "message")) {
[18:03:59.858]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.858]                         if (muffled) 
[18:03:59.858]                           invokeRestart("muffleMessage")
[18:03:59.858]                       }
[18:03:59.858]                       else if (inherits(cond, "warning")) {
[18:03:59.858]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.858]                         if (muffled) 
[18:03:59.858]                           invokeRestart("muffleWarning")
[18:03:59.858]                       }
[18:03:59.858]                       else if (inherits(cond, "condition")) {
[18:03:59.858]                         if (!is.null(pattern)) {
[18:03:59.858]                           computeRestarts <- base::computeRestarts
[18:03:59.858]                           grepl <- base::grepl
[18:03:59.858]                           restarts <- computeRestarts(cond)
[18:03:59.858]                           for (restart in restarts) {
[18:03:59.858]                             name <- restart$name
[18:03:59.858]                             if (is.null(name)) 
[18:03:59.858]                               next
[18:03:59.858]                             if (!grepl(pattern, name)) 
[18:03:59.858]                               next
[18:03:59.858]                             invokeRestart(restart)
[18:03:59.858]                             muffled <- TRUE
[18:03:59.858]                             break
[18:03:59.858]                           }
[18:03:59.858]                         }
[18:03:59.858]                       }
[18:03:59.858]                       invisible(muffled)
[18:03:59.858]                     }
[18:03:59.858]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.858]                   }
[18:03:59.858]                 }
[18:03:59.858]             }
[18:03:59.858]         }))
[18:03:59.858]     }, error = function(ex) {
[18:03:59.858]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.858]                 ...future.rng), started = ...future.startTime, 
[18:03:59.858]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.858]             version = "1.8"), class = "FutureResult")
[18:03:59.858]     }, finally = {
[18:03:59.858]         if (!identical(...future.workdir, getwd())) 
[18:03:59.858]             setwd(...future.workdir)
[18:03:59.858]         {
[18:03:59.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.858]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.858]             }
[18:03:59.858]             base::options(...future.oldOptions)
[18:03:59.858]             if (.Platform$OS.type == "windows") {
[18:03:59.858]                 old_names <- names(...future.oldEnvVars)
[18:03:59.858]                 envs <- base::Sys.getenv()
[18:03:59.858]                 names <- names(envs)
[18:03:59.858]                 common <- intersect(names, old_names)
[18:03:59.858]                 added <- setdiff(names, old_names)
[18:03:59.858]                 removed <- setdiff(old_names, names)
[18:03:59.858]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.858]                   envs[common]]
[18:03:59.858]                 NAMES <- toupper(changed)
[18:03:59.858]                 args <- list()
[18:03:59.858]                 for (kk in seq_along(NAMES)) {
[18:03:59.858]                   name <- changed[[kk]]
[18:03:59.858]                   NAME <- NAMES[[kk]]
[18:03:59.858]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.858]                     next
[18:03:59.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.858]                 }
[18:03:59.858]                 NAMES <- toupper(added)
[18:03:59.858]                 for (kk in seq_along(NAMES)) {
[18:03:59.858]                   name <- added[[kk]]
[18:03:59.858]                   NAME <- NAMES[[kk]]
[18:03:59.858]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.858]                     next
[18:03:59.858]                   args[[name]] <- ""
[18:03:59.858]                 }
[18:03:59.858]                 NAMES <- toupper(removed)
[18:03:59.858]                 for (kk in seq_along(NAMES)) {
[18:03:59.858]                   name <- removed[[kk]]
[18:03:59.858]                   NAME <- NAMES[[kk]]
[18:03:59.858]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.858]                     next
[18:03:59.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.858]                 }
[18:03:59.858]                 if (length(args) > 0) 
[18:03:59.858]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.858]             }
[18:03:59.858]             else {
[18:03:59.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.858]             }
[18:03:59.858]             {
[18:03:59.858]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.858]                   0L) {
[18:03:59.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.858]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.858]                   base::options(opts)
[18:03:59.858]                 }
[18:03:59.858]                 {
[18:03:59.858]                   {
[18:03:59.858]                     base::options(mc.cores = ...future.mc.cores.old)
[18:03:59.858]                     NULL
[18:03:59.858]                   }
[18:03:59.858]                   options(future.plan = NULL)
[18:03:59.858]                   if (is.na(NA_character_)) 
[18:03:59.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.858]                     .init = FALSE)
[18:03:59.858]                 }
[18:03:59.858]             }
[18:03:59.858]         }
[18:03:59.858]     })
[18:03:59.858]     if (TRUE) {
[18:03:59.858]         base::sink(type = "output", split = FALSE)
[18:03:59.858]         if (TRUE) {
[18:03:59.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.858]         }
[18:03:59.858]         else {
[18:03:59.858]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.858]         }
[18:03:59.858]         base::close(...future.stdout)
[18:03:59.858]         ...future.stdout <- NULL
[18:03:59.858]     }
[18:03:59.858]     ...future.result$conditions <- ...future.conditions
[18:03:59.858]     ...future.result$finished <- base::Sys.time()
[18:03:59.858]     ...future.result
[18:03:59.858] }
[18:03:59.864] assign_globals() ...
[18:03:59.865] List of 1
[18:03:59.865]  $ ii: int 2
[18:03:59.865]  - attr(*, "where")=List of 1
[18:03:59.865]   ..$ ii:<environment: R_EmptyEnv> 
[18:03:59.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.865]  - attr(*, "resolved")= logi FALSE
[18:03:59.865]  - attr(*, "total_size")= num 56
[18:03:59.865]  - attr(*, "already-done")= logi TRUE
[18:03:59.873] - copied ‘ii’ to environment
[18:03:59.874] assign_globals() ... done
[18:03:59.874] requestCore(): workers = 2
[18:03:59.878] MulticoreFuture started
[18:03:59.879] - Launch lazy future ... done
[18:03:59.883] plan(): Setting new future strategy stack:
[18:03:59.879] run() for ‘MulticoreFuture’ ... done
[18:03:59.888] getGlobalsAndPackages() ...
[18:03:59.889] Searching for globals...
[18:03:59.897] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:03:59.897] Searching for globals ... DONE
[18:03:59.898] Resolving globals: FALSE
[18:03:59.883] List of future strategies:
[18:03:59.883] 1. sequential:
[18:03:59.883]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.883]    - tweaked: FALSE
[18:03:59.883]    - call: NULL
[18:03:59.900] The total size of the 1 globals is 56 bytes (56 bytes)
[18:03:59.901] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:03:59.901] - globals: [1] ‘ii’
[18:03:59.902] 
[18:03:59.902] plan(): nbrOfWorkers() = 1
[18:03:59.902] getGlobalsAndPackages() ... DONE
[18:03:59.903] run() for ‘Future’ ...
[18:03:59.904] - state: ‘created’
[18:03:59.904] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:03:59.910] plan(): Setting new future strategy stack:
[18:03:59.912] List of future strategies:
[18:03:59.912] 1. multicore:
[18:03:59.912]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:03:59.912]    - tweaked: FALSE
[18:03:59.912]    - call: plan(strategy)
[18:03:59.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:03:59.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:03:59.914]   - Field: ‘label’
[18:03:59.914]   - Field: ‘local’
[18:03:59.915]   - Field: ‘owner’
[18:03:59.915]   - Field: ‘envir’
[18:03:59.915]   - Field: ‘workers’
[18:03:59.916]   - Field: ‘packages’
[18:03:59.916]   - Field: ‘gc’
[18:03:59.916]   - Field: ‘job’
[18:03:59.917]   - Field: ‘conditions’
[18:03:59.917]   - Field: ‘expr’
[18:03:59.917]   - Field: ‘uuid’
[18:03:59.917]   - Field: ‘seed’
[18:03:59.919]   - Field: ‘version’
[18:03:59.919]   - Field: ‘result’
[18:03:59.920]   - Field: ‘asynchronous’
[18:03:59.921]   - Field: ‘calls’
[18:03:59.922]   - Field: ‘globals’
[18:03:59.922]   - Field: ‘stdout’
[18:03:59.923]   - Field: ‘earlySignal’
[18:03:59.923]   - Field: ‘lazy’
[18:03:59.923]   - Field: ‘state’
[18:03:59.924] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:03:59.924] - Launch lazy future ...
[18:03:59.925] Packages needed by the future expression (n = 0): <none>
[18:03:59.925] Packages needed by future strategies (n = 0): <none>
[18:03:59.927] plan(): nbrOfWorkers() = 2
[18:03:59.927] {
[18:03:59.927]     {
[18:03:59.927]         {
[18:03:59.927]             ...future.startTime <- base::Sys.time()
[18:03:59.927]             {
[18:03:59.927]                 {
[18:03:59.927]                   {
[18:03:59.927]                     {
[18:03:59.927]                       base::local({
[18:03:59.927]                         has_future <- base::requireNamespace("future", 
[18:03:59.927]                           quietly = TRUE)
[18:03:59.927]                         if (has_future) {
[18:03:59.927]                           ns <- base::getNamespace("future")
[18:03:59.927]                           version <- ns[[".package"]][["version"]]
[18:03:59.927]                           if (is.null(version)) 
[18:03:59.927]                             version <- utils::packageVersion("future")
[18:03:59.927]                         }
[18:03:59.927]                         else {
[18:03:59.927]                           version <- NULL
[18:03:59.927]                         }
[18:03:59.927]                         if (!has_future || version < "1.8.0") {
[18:03:59.927]                           info <- base::c(r_version = base::gsub("R version ", 
[18:03:59.927]                             "", base::R.version$version.string), 
[18:03:59.927]                             platform = base::sprintf("%s (%s-bit)", 
[18:03:59.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:03:59.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:03:59.927]                               "release", "version")], collapse = " "), 
[18:03:59.927]                             hostname = base::Sys.info()[["nodename"]])
[18:03:59.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:03:59.927]                             info)
[18:03:59.927]                           info <- base::paste(info, collapse = "; ")
[18:03:59.927]                           if (!has_future) {
[18:03:59.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:03:59.927]                               info)
[18:03:59.927]                           }
[18:03:59.927]                           else {
[18:03:59.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:03:59.927]                               info, version)
[18:03:59.927]                           }
[18:03:59.927]                           base::stop(msg)
[18:03:59.927]                         }
[18:03:59.927]                       })
[18:03:59.927]                     }
[18:03:59.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:03:59.927]                     base::options(mc.cores = 1L)
[18:03:59.927]                   }
[18:03:59.927]                   ...future.strategy.old <- future::plan("list")
[18:03:59.927]                   options(future.plan = NULL)
[18:03:59.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:03:59.927]                 }
[18:03:59.927]                 ...future.workdir <- getwd()
[18:03:59.927]             }
[18:03:59.927]             ...future.oldOptions <- base::as.list(base::.Options)
[18:03:59.927]             ...future.oldEnvVars <- base::Sys.getenv()
[18:03:59.927]         }
[18:03:59.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:03:59.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:03:59.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:03:59.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:03:59.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:03:59.927]             future.stdout.windows.reencode = NULL, width = 80L)
[18:03:59.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:03:59.927]             base::names(...future.oldOptions))
[18:03:59.927]     }
[18:03:59.927]     if (FALSE) {
[18:03:59.927]     }
[18:03:59.927]     else {
[18:03:59.927]         if (TRUE) {
[18:03:59.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:03:59.927]                 open = "w")
[18:03:59.927]         }
[18:03:59.927]         else {
[18:03:59.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:03:59.927]                 windows = "NUL", "/dev/null"), open = "w")
[18:03:59.927]         }
[18:03:59.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:03:59.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:03:59.927]             base::sink(type = "output", split = FALSE)
[18:03:59.927]             base::close(...future.stdout)
[18:03:59.927]         }, add = TRUE)
[18:03:59.927]     }
[18:03:59.927]     ...future.frame <- base::sys.nframe()
[18:03:59.927]     ...future.conditions <- base::list()
[18:03:59.927]     ...future.rng <- base::globalenv()$.Random.seed
[18:03:59.927]     if (FALSE) {
[18:03:59.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:03:59.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:03:59.927]     }
[18:03:59.927]     ...future.result <- base::tryCatch({
[18:03:59.927]         base::withCallingHandlers({
[18:03:59.927]             ...future.value <- base::withVisible(base::local({
[18:03:59.927]                 withCallingHandlers({
[18:03:59.927]                   {
[18:03:59.927]                     if (ii%%2 == 0) 
[18:03:59.927]                       stop("Woops!")
[18:03:59.927]                     ii
[18:03:59.927]                   }
[18:03:59.927]                 }, immediateCondition = function(cond) {
[18:03:59.927]                   save_rds <- function (object, pathname, ...) 
[18:03:59.927]                   {
[18:03:59.927]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:03:59.927]                     if (file_test("-f", pathname_tmp)) {
[18:03:59.927]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.927]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:03:59.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.927]                         fi_tmp[["mtime"]])
[18:03:59.927]                     }
[18:03:59.927]                     tryCatch({
[18:03:59.927]                       saveRDS(object, file = pathname_tmp, ...)
[18:03:59.927]                     }, error = function(ex) {
[18:03:59.927]                       msg <- conditionMessage(ex)
[18:03:59.927]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.927]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:03:59.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.927]                         fi_tmp[["mtime"]], msg)
[18:03:59.927]                       ex$message <- msg
[18:03:59.927]                       stop(ex)
[18:03:59.927]                     })
[18:03:59.927]                     stopifnot(file_test("-f", pathname_tmp))
[18:03:59.927]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:03:59.927]                     if (!res || file_test("-f", pathname_tmp)) {
[18:03:59.927]                       fi_tmp <- file.info(pathname_tmp)
[18:03:59.927]                       fi <- file.info(pathname)
[18:03:59.927]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:03:59.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:03:59.927]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:03:59.927]                         fi[["size"]], fi[["mtime"]])
[18:03:59.927]                       stop(msg)
[18:03:59.927]                     }
[18:03:59.927]                     invisible(pathname)
[18:03:59.927]                   }
[18:03:59.927]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:03:59.927]                     rootPath = tempdir()) 
[18:03:59.927]                   {
[18:03:59.927]                     obj <- list(time = Sys.time(), condition = cond)
[18:03:59.927]                     file <- tempfile(pattern = class(cond)[1], 
[18:03:59.927]                       tmpdir = path, fileext = ".rds")
[18:03:59.927]                     save_rds(obj, file)
[18:03:59.927]                   }
[18:03:59.927]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:03:59.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.927]                   {
[18:03:59.927]                     inherits <- base::inherits
[18:03:59.927]                     invokeRestart <- base::invokeRestart
[18:03:59.927]                     is.null <- base::is.null
[18:03:59.927]                     muffled <- FALSE
[18:03:59.927]                     if (inherits(cond, "message")) {
[18:03:59.927]                       muffled <- grepl(pattern, "muffleMessage")
[18:03:59.927]                       if (muffled) 
[18:03:59.927]                         invokeRestart("muffleMessage")
[18:03:59.927]                     }
[18:03:59.927]                     else if (inherits(cond, "warning")) {
[18:03:59.927]                       muffled <- grepl(pattern, "muffleWarning")
[18:03:59.927]                       if (muffled) 
[18:03:59.927]                         invokeRestart("muffleWarning")
[18:03:59.927]                     }
[18:03:59.927]                     else if (inherits(cond, "condition")) {
[18:03:59.927]                       if (!is.null(pattern)) {
[18:03:59.927]                         computeRestarts <- base::computeRestarts
[18:03:59.927]                         grepl <- base::grepl
[18:03:59.927]                         restarts <- computeRestarts(cond)
[18:03:59.927]                         for (restart in restarts) {
[18:03:59.927]                           name <- restart$name
[18:03:59.927]                           if (is.null(name)) 
[18:03:59.927]                             next
[18:03:59.927]                           if (!grepl(pattern, name)) 
[18:03:59.927]                             next
[18:03:59.927]                           invokeRestart(restart)
[18:03:59.927]                           muffled <- TRUE
[18:03:59.927]                           break
[18:03:59.927]                         }
[18:03:59.927]                       }
[18:03:59.927]                     }
[18:03:59.927]                     invisible(muffled)
[18:03:59.927]                   }
[18:03:59.927]                   muffleCondition(cond)
[18:03:59.927]                 })
[18:03:59.927]             }))
[18:03:59.927]             future::FutureResult(value = ...future.value$value, 
[18:03:59.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.927]                   ...future.rng), globalenv = if (FALSE) 
[18:03:59.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:03:59.927]                     ...future.globalenv.names))
[18:03:59.927]                 else NULL, started = ...future.startTime, version = "1.8")
[18:03:59.927]         }, condition = base::local({
[18:03:59.927]             c <- base::c
[18:03:59.927]             inherits <- base::inherits
[18:03:59.927]             invokeRestart <- base::invokeRestart
[18:03:59.927]             length <- base::length
[18:03:59.927]             list <- base::list
[18:03:59.927]             seq.int <- base::seq.int
[18:03:59.927]             signalCondition <- base::signalCondition
[18:03:59.927]             sys.calls <- base::sys.calls
[18:03:59.927]             `[[` <- base::`[[`
[18:03:59.927]             `+` <- base::`+`
[18:03:59.927]             `<<-` <- base::`<<-`
[18:03:59.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:03:59.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:03:59.927]                   3L)]
[18:03:59.927]             }
[18:03:59.927]             function(cond) {
[18:03:59.927]                 is_error <- inherits(cond, "error")
[18:03:59.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:03:59.927]                   NULL)
[18:03:59.927]                 if (is_error) {
[18:03:59.927]                   sessionInformation <- function() {
[18:03:59.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:03:59.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:03:59.927]                       search = base::search(), system = base::Sys.info())
[18:03:59.927]                   }
[18:03:59.927]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:03:59.927]                     cond$call), session = sessionInformation(), 
[18:03:59.927]                     timestamp = base::Sys.time(), signaled = 0L)
[18:03:59.927]                   signalCondition(cond)
[18:03:59.927]                 }
[18:03:59.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:03:59.927]                 "immediateCondition"))) {
[18:03:59.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:03:59.927]                   ...future.conditions[[length(...future.conditions) + 
[18:03:59.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:03:59.927]                   if (TRUE && !signal) {
[18:03:59.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.927]                     {
[18:03:59.927]                       inherits <- base::inherits
[18:03:59.927]                       invokeRestart <- base::invokeRestart
[18:03:59.927]                       is.null <- base::is.null
[18:03:59.927]                       muffled <- FALSE
[18:03:59.927]                       if (inherits(cond, "message")) {
[18:03:59.927]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.927]                         if (muffled) 
[18:03:59.927]                           invokeRestart("muffleMessage")
[18:03:59.927]                       }
[18:03:59.927]                       else if (inherits(cond, "warning")) {
[18:03:59.927]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.927]                         if (muffled) 
[18:03:59.927]                           invokeRestart("muffleWarning")
[18:03:59.927]                       }
[18:03:59.927]                       else if (inherits(cond, "condition")) {
[18:03:59.927]                         if (!is.null(pattern)) {
[18:03:59.927]                           computeRestarts <- base::computeRestarts
[18:03:59.927]                           grepl <- base::grepl
[18:03:59.927]                           restarts <- computeRestarts(cond)
[18:03:59.927]                           for (restart in restarts) {
[18:03:59.927]                             name <- restart$name
[18:03:59.927]                             if (is.null(name)) 
[18:03:59.927]                               next
[18:03:59.927]                             if (!grepl(pattern, name)) 
[18:03:59.927]                               next
[18:03:59.927]                             invokeRestart(restart)
[18:03:59.927]                             muffled <- TRUE
[18:03:59.927]                             break
[18:03:59.927]                           }
[18:03:59.927]                         }
[18:03:59.927]                       }
[18:03:59.927]                       invisible(muffled)
[18:03:59.927]                     }
[18:03:59.927]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.927]                   }
[18:03:59.927]                 }
[18:03:59.927]                 else {
[18:03:59.927]                   if (TRUE) {
[18:03:59.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:03:59.927]                     {
[18:03:59.927]                       inherits <- base::inherits
[18:03:59.927]                       invokeRestart <- base::invokeRestart
[18:03:59.927]                       is.null <- base::is.null
[18:03:59.927]                       muffled <- FALSE
[18:03:59.927]                       if (inherits(cond, "message")) {
[18:03:59.927]                         muffled <- grepl(pattern, "muffleMessage")
[18:03:59.927]                         if (muffled) 
[18:03:59.927]                           invokeRestart("muffleMessage")
[18:03:59.927]                       }
[18:03:59.927]                       else if (inherits(cond, "warning")) {
[18:03:59.927]                         muffled <- grepl(pattern, "muffleWarning")
[18:03:59.927]                         if (muffled) 
[18:03:59.927]                           invokeRestart("muffleWarning")
[18:03:59.927]                       }
[18:03:59.927]                       else if (inherits(cond, "condition")) {
[18:03:59.927]                         if (!is.null(pattern)) {
[18:03:59.927]                           computeRestarts <- base::computeRestarts
[18:03:59.927]                           grepl <- base::grepl
[18:03:59.927]                           restarts <- computeRestarts(cond)
[18:03:59.927]                           for (restart in restarts) {
[18:03:59.927]                             name <- restart$name
[18:03:59.927]                             if (is.null(name)) 
[18:03:59.927]                               next
[18:03:59.927]                             if (!grepl(pattern, name)) 
[18:03:59.927]                               next
[18:03:59.927]                             invokeRestart(restart)
[18:03:59.927]                             muffled <- TRUE
[18:03:59.927]                             break
[18:03:59.927]                           }
[18:03:59.927]                         }
[18:03:59.927]                       }
[18:03:59.927]                       invisible(muffled)
[18:03:59.927]                     }
[18:03:59.927]                     muffleCondition(cond, pattern = "^muffle")
[18:03:59.927]                   }
[18:03:59.927]                 }
[18:03:59.927]             }
[18:03:59.927]         }))
[18:03:59.927]     }, error = function(ex) {
[18:03:59.927]         base::structure(base::list(value = NULL, visible = NULL, 
[18:03:59.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:03:59.927]                 ...future.rng), started = ...future.startTime, 
[18:03:59.927]             finished = Sys.time(), session_uuid = NA_character_, 
[18:03:59.927]             version = "1.8"), class = "FutureResult")
[18:03:59.927]     }, finally = {
[18:03:59.927]         if (!identical(...future.workdir, getwd())) 
[18:03:59.927]             setwd(...future.workdir)
[18:03:59.927]         {
[18:03:59.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:03:59.927]                 ...future.oldOptions$nwarnings <- NULL
[18:03:59.927]             }
[18:03:59.927]             base::options(...future.oldOptions)
[18:03:59.927]             if (.Platform$OS.type == "windows") {
[18:03:59.927]                 old_names <- names(...future.oldEnvVars)
[18:03:59.927]                 envs <- base::Sys.getenv()
[18:03:59.927]                 names <- names(envs)
[18:03:59.927]                 common <- intersect(names, old_names)
[18:03:59.927]                 added <- setdiff(names, old_names)
[18:03:59.927]                 removed <- setdiff(old_names, names)
[18:03:59.927]                 changed <- common[...future.oldEnvVars[common] != 
[18:03:59.927]                   envs[common]]
[18:03:59.927]                 NAMES <- toupper(changed)
[18:03:59.927]                 args <- list()
[18:03:59.927]                 for (kk in seq_along(NAMES)) {
[18:03:59.927]                   name <- changed[[kk]]
[18:03:59.927]                   NAME <- NAMES[[kk]]
[18:03:59.927]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.927]                     next
[18:03:59.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.927]                 }
[18:03:59.927]                 NAMES <- toupper(added)
[18:03:59.927]                 for (kk in seq_along(NAMES)) {
[18:03:59.927]                   name <- added[[kk]]
[18:03:59.927]                   NAME <- NAMES[[kk]]
[18:03:59.927]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.927]                     next
[18:03:59.927]                   args[[name]] <- ""
[18:03:59.927]                 }
[18:03:59.927]                 NAMES <- toupper(removed)
[18:03:59.927]                 for (kk in seq_along(NAMES)) {
[18:03:59.927]                   name <- removed[[kk]]
[18:03:59.927]                   NAME <- NAMES[[kk]]
[18:03:59.927]                   if (name != NAME && is.element(NAME, old_names)) 
[18:03:59.927]                     next
[18:03:59.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:03:59.927]                 }
[18:03:59.927]                 if (length(args) > 0) 
[18:03:59.927]                   base::do.call(base::Sys.setenv, args = args)
[18:03:59.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:03:59.927]             }
[18:03:59.927]             else {
[18:03:59.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:03:59.927]             }
[18:03:59.927]             {
[18:03:59.927]                 if (base::length(...future.futureOptionsAdded) > 
[18:03:59.927]                   0L) {
[18:03:59.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:03:59.927]                   base::names(opts) <- ...future.futureOptionsAdded
[18:03:59.927]                   base::options(opts)
[18:03:59.927]                 }
[18:03:59.927]                 {
[18:03:59.927]                   {
[18:03:59.927]                     base::options(mc.cores = ...future.mc.cores.old)
[18:03:59.927]                     NULL
[18:03:59.927]                   }
[18:03:59.927]                   options(future.plan = NULL)
[18:03:59.927]                   if (is.na(NA_character_)) 
[18:03:59.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:03:59.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:03:59.927]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:03:59.927]                     .init = FALSE)
[18:03:59.927]                 }
[18:03:59.927]             }
[18:03:59.927]         }
[18:03:59.927]     })
[18:03:59.927]     if (TRUE) {
[18:03:59.927]         base::sink(type = "output", split = FALSE)
[18:03:59.927]         if (TRUE) {
[18:03:59.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:03:59.927]         }
[18:03:59.927]         else {
[18:03:59.927]             ...future.result["stdout"] <- base::list(NULL)
[18:03:59.927]         }
[18:03:59.927]         base::close(...future.stdout)
[18:03:59.927]         ...future.stdout <- NULL
[18:03:59.927]     }
[18:03:59.927]     ...future.result$conditions <- ...future.conditions
[18:03:59.927]     ...future.result$finished <- base::Sys.time()
[18:03:59.927]     ...future.result
[18:03:59.927] }
[18:03:59.932] assign_globals() ...
[18:03:59.933] List of 1
[18:03:59.933]  $ ii: int 3
[18:03:59.933]  - attr(*, "where")=List of 1
[18:03:59.933]   ..$ ii:<environment: R_EmptyEnv> 
[18:03:59.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:03:59.933]  - attr(*, "resolved")= logi FALSE
[18:03:59.933]  - attr(*, "total_size")= num 56
[18:03:59.933]  - attr(*, "already-done")= logi TRUE
[18:03:59.941] - copied ‘ii’ to environment
[18:03:59.942] assign_globals() ... done
[18:03:59.942] requestCore(): workers = 2
[18:03:59.943] Poll #1 (0): usedCores() = 2, workers = 2
[18:03:59.955] result() for MulticoreFuture ...
[18:03:59.957] result() for MulticoreFuture ...
[18:03:59.959] result() for MulticoreFuture ... done
[18:03:59.960] result() for MulticoreFuture ... done
[18:03:59.960] result() for MulticoreFuture ...
[18:03:59.960] result() for MulticoreFuture ... done
[18:03:59.969] MulticoreFuture started
[18:03:59.970] - Launch lazy future ... done
[18:03:59.970] run() for ‘MulticoreFuture’ ... done
[18:03:59.973] plan(): Setting new future strategy stack:
[18:03:59.972] result() for MulticoreFuture ...
[18:03:59.974] result() for MulticoreFuture ... done
[18:03:59.975] result() for MulticoreFuture ...
[18:03:59.975] result() for MulticoreFuture ... done
[18:03:59.973] List of future strategies:
[18:03:59.973] 1. sequential:
[18:03:59.973]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:03:59.973]    - tweaked: FALSE
[18:03:59.973]    - call: NULL
[18:03:59.976] result() for MulticoreFuture ...
[18:03:59.978] plan(): nbrOfWorkers() = 1
[18:03:59.985] plan(): Setting new future strategy stack:
[18:03:59.986] List of future strategies:
[18:03:59.986] 1. multicore:
[18:03:59.986]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:03:59.986]    - tweaked: FALSE
[18:03:59.986]    - call: plan(strategy)
[18:03:59.993] result() for MulticoreFuture ...
[18:03:59.993] result() for MulticoreFuture ... done
[18:03:59.993] signalConditions() ...
[18:03:59.994]  - include = ‘immediateCondition’
[18:03:59.997]  - exclude = 
[18:03:59.997]  - resignal = FALSE
[18:03:59.998]  - Number of conditions: 1
[18:03:59.998] signalConditions() ... done
[18:03:59.998] result() for MulticoreFuture ... done
[18:03:59.999] result() for MulticoreFuture ...
[18:03:59.999] result() for MulticoreFuture ... done
[18:03:59.999] signalConditions() ...
[18:03:59.999]  - include = ‘immediateCondition’
[18:04:00.000]  - exclude = 
[18:04:00.000]  - resignal = FALSE
[18:04:00.000]  - Number of conditions: 1
[18:04:00.001] signalConditions() ... done
[18:04:00.001] Future state: ‘finished’
[18:04:00.002] result() for MulticoreFuture ...
[18:04:00.002] result() for MulticoreFuture ... done
[18:04:00.002] signalConditions() ...
[18:04:00.003]  - include = ‘condition’
[18:04:00.003]  - exclude = ‘immediateCondition’
[18:04:00.003]  - resignal = TRUE
[18:04:00.004]  - Number of conditions: 1
[18:04:00.004]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:00.004] signalConditions() ... done
[18:04:00.006] result() for MulticoreFuture ...
[18:04:00.010] plan(): nbrOfWorkers() = 2
[18:04:00.011] result() for MulticoreFuture ...
[18:04:00.012] result() for MulticoreFuture ... done
[18:04:00.012] result() for MulticoreFuture ... done
[18:04:00.012] result() for MulticoreFuture ...
[18:04:00.013] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[18:04:00.014] result() for MulticoreFuture ...
[18:04:00.014] result() for MulticoreFuture ... done
[18:04:00.014] result() for MulticoreFuture ...
[18:04:00.015] result() for MulticoreFuture ... done
[18:04:00.015] signalConditions() ...
[18:04:00.015]  - include = ‘immediateCondition’
[18:04:00.015]  - exclude = 
[18:04:00.016]  - resignal = FALSE
[18:04:00.016]  - Number of conditions: 1
[18:04:00.016] signalConditions() ... done
[18:04:00.016] Future state: ‘finished’
[18:04:00.017] result() for MulticoreFuture ...
[18:04:00.017] result() for MulticoreFuture ... done
[18:04:00.017] signalConditions() ...
[18:04:00.017]  - include = ‘condition’
[18:04:00.017]  - exclude = ‘immediateCondition’
[18:04:00.018]  - resignal = TRUE
[18:04:00.018]  - Number of conditions: 1
[18:04:00.018]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:00.018] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[18:04:00.023] result() for MulticoreFuture ...
[18:04:00.023] result() for MulticoreFuture ... done
[18:04:00.023] result() for MulticoreFuture ...
[18:04:00.024] result() for MulticoreFuture ... done
[18:04:00.024] signalConditions() ...
[18:04:00.024]  - include = ‘immediateCondition’
[18:04:00.024]  - exclude = 
[18:04:00.025]  - resignal = FALSE
[18:04:00.025]  - Number of conditions: 1
[18:04:00.025] signalConditions() ... done
[18:04:00.025] Future state: ‘finished’
[18:04:00.026] result() for MulticoreFuture ...
[18:04:00.026] result() for MulticoreFuture ... done
[18:04:00.026] signalConditions() ...
[18:04:00.026]  - include = ‘condition’
[18:04:00.027]  - exclude = ‘immediateCondition’
[18:04:00.027]  - resignal = TRUE
[18:04:00.027]  - Number of conditions: 1
[18:04:00.027]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:00.028] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[18:04:00.029] getGlobalsAndPackages() ...
[18:04:00.029] Searching for globals...
[18:04:00.034] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[18:04:00.034] Searching for globals ... DONE
[18:04:00.034] Resolving globals: FALSE
[18:04:00.035] 
[18:04:00.036] 
[18:04:00.036] getGlobalsAndPackages() ... DONE
[18:04:00.036] run() for ‘Future’ ...
[18:04:00.037] - state: ‘created’
[18:04:00.037] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:00.044] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:00.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:00.044]   - Field: ‘label’
[18:04:00.044]   - Field: ‘local’
[18:04:00.045]   - Field: ‘owner’
[18:04:00.045]   - Field: ‘envir’
[18:04:00.045]   - Field: ‘workers’
[18:04:00.045]   - Field: ‘packages’
[18:04:00.046]   - Field: ‘gc’
[18:04:00.046]   - Field: ‘job’
[18:04:00.046]   - Field: ‘conditions’
[18:04:00.046]   - Field: ‘expr’
[18:04:00.047]   - Field: ‘uuid’
[18:04:00.047]   - Field: ‘seed’
[18:04:00.047]   - Field: ‘version’
[18:04:00.047]   - Field: ‘result’
[18:04:00.048]   - Field: ‘asynchronous’
[18:04:00.048]   - Field: ‘calls’
[18:04:00.048]   - Field: ‘globals’
[18:04:00.048]   - Field: ‘stdout’
[18:04:00.048]   - Field: ‘earlySignal’
[18:04:00.049]   - Field: ‘lazy’
[18:04:00.049]   - Field: ‘state’
[18:04:00.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:00.049] - Launch lazy future ...
[18:04:00.050] Packages needed by the future expression (n = 0): <none>
[18:04:00.050] Packages needed by future strategies (n = 0): <none>
[18:04:00.051] {
[18:04:00.051]     {
[18:04:00.051]         {
[18:04:00.051]             ...future.startTime <- base::Sys.time()
[18:04:00.051]             {
[18:04:00.051]                 {
[18:04:00.051]                   {
[18:04:00.051]                     {
[18:04:00.051]                       base::local({
[18:04:00.051]                         has_future <- base::requireNamespace("future", 
[18:04:00.051]                           quietly = TRUE)
[18:04:00.051]                         if (has_future) {
[18:04:00.051]                           ns <- base::getNamespace("future")
[18:04:00.051]                           version <- ns[[".package"]][["version"]]
[18:04:00.051]                           if (is.null(version)) 
[18:04:00.051]                             version <- utils::packageVersion("future")
[18:04:00.051]                         }
[18:04:00.051]                         else {
[18:04:00.051]                           version <- NULL
[18:04:00.051]                         }
[18:04:00.051]                         if (!has_future || version < "1.8.0") {
[18:04:00.051]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:00.051]                             "", base::R.version$version.string), 
[18:04:00.051]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:00.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:00.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:00.051]                               "release", "version")], collapse = " "), 
[18:04:00.051]                             hostname = base::Sys.info()[["nodename"]])
[18:04:00.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:00.051]                             info)
[18:04:00.051]                           info <- base::paste(info, collapse = "; ")
[18:04:00.051]                           if (!has_future) {
[18:04:00.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:00.051]                               info)
[18:04:00.051]                           }
[18:04:00.051]                           else {
[18:04:00.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:00.051]                               info, version)
[18:04:00.051]                           }
[18:04:00.051]                           base::stop(msg)
[18:04:00.051]                         }
[18:04:00.051]                       })
[18:04:00.051]                     }
[18:04:00.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:00.051]                     base::options(mc.cores = 1L)
[18:04:00.051]                   }
[18:04:00.051]                   ...future.strategy.old <- future::plan("list")
[18:04:00.051]                   options(future.plan = NULL)
[18:04:00.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:00.051]                 }
[18:04:00.051]                 ...future.workdir <- getwd()
[18:04:00.051]             }
[18:04:00.051]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:00.051]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:00.051]         }
[18:04:00.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:00.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:00.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:00.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:00.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:00.051]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:00.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:00.051]             base::names(...future.oldOptions))
[18:04:00.051]     }
[18:04:00.051]     if (FALSE) {
[18:04:00.051]     }
[18:04:00.051]     else {
[18:04:00.051]         if (TRUE) {
[18:04:00.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:00.051]                 open = "w")
[18:04:00.051]         }
[18:04:00.051]         else {
[18:04:00.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:00.051]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:00.051]         }
[18:04:00.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:00.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:00.051]             base::sink(type = "output", split = FALSE)
[18:04:00.051]             base::close(...future.stdout)
[18:04:00.051]         }, add = TRUE)
[18:04:00.051]     }
[18:04:00.051]     ...future.frame <- base::sys.nframe()
[18:04:00.051]     ...future.conditions <- base::list()
[18:04:00.051]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:00.051]     if (FALSE) {
[18:04:00.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:00.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:00.051]     }
[18:04:00.051]     ...future.result <- base::tryCatch({
[18:04:00.051]         base::withCallingHandlers({
[18:04:00.051]             ...future.value <- base::withVisible(base::local({
[18:04:00.051]                 withCallingHandlers({
[18:04:00.051]                   {
[18:04:00.051]                     cat("Processing: ")
[18:04:00.051]                     for (ii in 1:10) {
[18:04:00.051]                       cat(".")
[18:04:00.051]                     }
[18:04:00.051]                     cat(" [100%]\n")
[18:04:00.051]                     4
[18:04:00.051]                   }
[18:04:00.051]                 }, immediateCondition = function(cond) {
[18:04:00.051]                   save_rds <- function (object, pathname, ...) 
[18:04:00.051]                   {
[18:04:00.051]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:00.051]                     if (file_test("-f", pathname_tmp)) {
[18:04:00.051]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.051]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:00.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.051]                         fi_tmp[["mtime"]])
[18:04:00.051]                     }
[18:04:00.051]                     tryCatch({
[18:04:00.051]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:00.051]                     }, error = function(ex) {
[18:04:00.051]                       msg <- conditionMessage(ex)
[18:04:00.051]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.051]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:00.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.051]                         fi_tmp[["mtime"]], msg)
[18:04:00.051]                       ex$message <- msg
[18:04:00.051]                       stop(ex)
[18:04:00.051]                     })
[18:04:00.051]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:00.051]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:00.051]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:00.051]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.051]                       fi <- file.info(pathname)
[18:04:00.051]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:00.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.051]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:00.051]                         fi[["size"]], fi[["mtime"]])
[18:04:00.051]                       stop(msg)
[18:04:00.051]                     }
[18:04:00.051]                     invisible(pathname)
[18:04:00.051]                   }
[18:04:00.051]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:00.051]                     rootPath = tempdir()) 
[18:04:00.051]                   {
[18:04:00.051]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:00.051]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:00.051]                       tmpdir = path, fileext = ".rds")
[18:04:00.051]                     save_rds(obj, file)
[18:04:00.051]                   }
[18:04:00.051]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:04:00.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.051]                   {
[18:04:00.051]                     inherits <- base::inherits
[18:04:00.051]                     invokeRestart <- base::invokeRestart
[18:04:00.051]                     is.null <- base::is.null
[18:04:00.051]                     muffled <- FALSE
[18:04:00.051]                     if (inherits(cond, "message")) {
[18:04:00.051]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:00.051]                       if (muffled) 
[18:04:00.051]                         invokeRestart("muffleMessage")
[18:04:00.051]                     }
[18:04:00.051]                     else if (inherits(cond, "warning")) {
[18:04:00.051]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:00.051]                       if (muffled) 
[18:04:00.051]                         invokeRestart("muffleWarning")
[18:04:00.051]                     }
[18:04:00.051]                     else if (inherits(cond, "condition")) {
[18:04:00.051]                       if (!is.null(pattern)) {
[18:04:00.051]                         computeRestarts <- base::computeRestarts
[18:04:00.051]                         grepl <- base::grepl
[18:04:00.051]                         restarts <- computeRestarts(cond)
[18:04:00.051]                         for (restart in restarts) {
[18:04:00.051]                           name <- restart$name
[18:04:00.051]                           if (is.null(name)) 
[18:04:00.051]                             next
[18:04:00.051]                           if (!grepl(pattern, name)) 
[18:04:00.051]                             next
[18:04:00.051]                           invokeRestart(restart)
[18:04:00.051]                           muffled <- TRUE
[18:04:00.051]                           break
[18:04:00.051]                         }
[18:04:00.051]                       }
[18:04:00.051]                     }
[18:04:00.051]                     invisible(muffled)
[18:04:00.051]                   }
[18:04:00.051]                   muffleCondition(cond)
[18:04:00.051]                 })
[18:04:00.051]             }))
[18:04:00.051]             future::FutureResult(value = ...future.value$value, 
[18:04:00.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.051]                   ...future.rng), globalenv = if (FALSE) 
[18:04:00.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:00.051]                     ...future.globalenv.names))
[18:04:00.051]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:00.051]         }, condition = base::local({
[18:04:00.051]             c <- base::c
[18:04:00.051]             inherits <- base::inherits
[18:04:00.051]             invokeRestart <- base::invokeRestart
[18:04:00.051]             length <- base::length
[18:04:00.051]             list <- base::list
[18:04:00.051]             seq.int <- base::seq.int
[18:04:00.051]             signalCondition <- base::signalCondition
[18:04:00.051]             sys.calls <- base::sys.calls
[18:04:00.051]             `[[` <- base::`[[`
[18:04:00.051]             `+` <- base::`+`
[18:04:00.051]             `<<-` <- base::`<<-`
[18:04:00.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:00.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:00.051]                   3L)]
[18:04:00.051]             }
[18:04:00.051]             function(cond) {
[18:04:00.051]                 is_error <- inherits(cond, "error")
[18:04:00.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:00.051]                   NULL)
[18:04:00.051]                 if (is_error) {
[18:04:00.051]                   sessionInformation <- function() {
[18:04:00.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:00.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:00.051]                       search = base::search(), system = base::Sys.info())
[18:04:00.051]                   }
[18:04:00.051]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:00.051]                     cond$call), session = sessionInformation(), 
[18:04:00.051]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:00.051]                   signalCondition(cond)
[18:04:00.051]                 }
[18:04:00.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:00.051]                 "immediateCondition"))) {
[18:04:00.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:00.051]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:00.051]                   if (TRUE && !signal) {
[18:04:00.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.051]                     {
[18:04:00.051]                       inherits <- base::inherits
[18:04:00.051]                       invokeRestart <- base::invokeRestart
[18:04:00.051]                       is.null <- base::is.null
[18:04:00.051]                       muffled <- FALSE
[18:04:00.051]                       if (inherits(cond, "message")) {
[18:04:00.051]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.051]                         if (muffled) 
[18:04:00.051]                           invokeRestart("muffleMessage")
[18:04:00.051]                       }
[18:04:00.051]                       else if (inherits(cond, "warning")) {
[18:04:00.051]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.051]                         if (muffled) 
[18:04:00.051]                           invokeRestart("muffleWarning")
[18:04:00.051]                       }
[18:04:00.051]                       else if (inherits(cond, "condition")) {
[18:04:00.051]                         if (!is.null(pattern)) {
[18:04:00.051]                           computeRestarts <- base::computeRestarts
[18:04:00.051]                           grepl <- base::grepl
[18:04:00.051]                           restarts <- computeRestarts(cond)
[18:04:00.051]                           for (restart in restarts) {
[18:04:00.051]                             name <- restart$name
[18:04:00.051]                             if (is.null(name)) 
[18:04:00.051]                               next
[18:04:00.051]                             if (!grepl(pattern, name)) 
[18:04:00.051]                               next
[18:04:00.051]                             invokeRestart(restart)
[18:04:00.051]                             muffled <- TRUE
[18:04:00.051]                             break
[18:04:00.051]                           }
[18:04:00.051]                         }
[18:04:00.051]                       }
[18:04:00.051]                       invisible(muffled)
[18:04:00.051]                     }
[18:04:00.051]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.051]                   }
[18:04:00.051]                 }
[18:04:00.051]                 else {
[18:04:00.051]                   if (TRUE) {
[18:04:00.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.051]                     {
[18:04:00.051]                       inherits <- base::inherits
[18:04:00.051]                       invokeRestart <- base::invokeRestart
[18:04:00.051]                       is.null <- base::is.null
[18:04:00.051]                       muffled <- FALSE
[18:04:00.051]                       if (inherits(cond, "message")) {
[18:04:00.051]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.051]                         if (muffled) 
[18:04:00.051]                           invokeRestart("muffleMessage")
[18:04:00.051]                       }
[18:04:00.051]                       else if (inherits(cond, "warning")) {
[18:04:00.051]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.051]                         if (muffled) 
[18:04:00.051]                           invokeRestart("muffleWarning")
[18:04:00.051]                       }
[18:04:00.051]                       else if (inherits(cond, "condition")) {
[18:04:00.051]                         if (!is.null(pattern)) {
[18:04:00.051]                           computeRestarts <- base::computeRestarts
[18:04:00.051]                           grepl <- base::grepl
[18:04:00.051]                           restarts <- computeRestarts(cond)
[18:04:00.051]                           for (restart in restarts) {
[18:04:00.051]                             name <- restart$name
[18:04:00.051]                             if (is.null(name)) 
[18:04:00.051]                               next
[18:04:00.051]                             if (!grepl(pattern, name)) 
[18:04:00.051]                               next
[18:04:00.051]                             invokeRestart(restart)
[18:04:00.051]                             muffled <- TRUE
[18:04:00.051]                             break
[18:04:00.051]                           }
[18:04:00.051]                         }
[18:04:00.051]                       }
[18:04:00.051]                       invisible(muffled)
[18:04:00.051]                     }
[18:04:00.051]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.051]                   }
[18:04:00.051]                 }
[18:04:00.051]             }
[18:04:00.051]         }))
[18:04:00.051]     }, error = function(ex) {
[18:04:00.051]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:00.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.051]                 ...future.rng), started = ...future.startTime, 
[18:04:00.051]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:00.051]             version = "1.8"), class = "FutureResult")
[18:04:00.051]     }, finally = {
[18:04:00.051]         if (!identical(...future.workdir, getwd())) 
[18:04:00.051]             setwd(...future.workdir)
[18:04:00.051]         {
[18:04:00.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:00.051]                 ...future.oldOptions$nwarnings <- NULL
[18:04:00.051]             }
[18:04:00.051]             base::options(...future.oldOptions)
[18:04:00.051]             if (.Platform$OS.type == "windows") {
[18:04:00.051]                 old_names <- names(...future.oldEnvVars)
[18:04:00.051]                 envs <- base::Sys.getenv()
[18:04:00.051]                 names <- names(envs)
[18:04:00.051]                 common <- intersect(names, old_names)
[18:04:00.051]                 added <- setdiff(names, old_names)
[18:04:00.051]                 removed <- setdiff(old_names, names)
[18:04:00.051]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:00.051]                   envs[common]]
[18:04:00.051]                 NAMES <- toupper(changed)
[18:04:00.051]                 args <- list()
[18:04:00.051]                 for (kk in seq_along(NAMES)) {
[18:04:00.051]                   name <- changed[[kk]]
[18:04:00.051]                   NAME <- NAMES[[kk]]
[18:04:00.051]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.051]                     next
[18:04:00.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.051]                 }
[18:04:00.051]                 NAMES <- toupper(added)
[18:04:00.051]                 for (kk in seq_along(NAMES)) {
[18:04:00.051]                   name <- added[[kk]]
[18:04:00.051]                   NAME <- NAMES[[kk]]
[18:04:00.051]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.051]                     next
[18:04:00.051]                   args[[name]] <- ""
[18:04:00.051]                 }
[18:04:00.051]                 NAMES <- toupper(removed)
[18:04:00.051]                 for (kk in seq_along(NAMES)) {
[18:04:00.051]                   name <- removed[[kk]]
[18:04:00.051]                   NAME <- NAMES[[kk]]
[18:04:00.051]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.051]                     next
[18:04:00.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.051]                 }
[18:04:00.051]                 if (length(args) > 0) 
[18:04:00.051]                   base::do.call(base::Sys.setenv, args = args)
[18:04:00.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:00.051]             }
[18:04:00.051]             else {
[18:04:00.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:00.051]             }
[18:04:00.051]             {
[18:04:00.051]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:00.051]                   0L) {
[18:04:00.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:00.051]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:00.051]                   base::options(opts)
[18:04:00.051]                 }
[18:04:00.051]                 {
[18:04:00.051]                   {
[18:04:00.051]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:00.051]                     NULL
[18:04:00.051]                   }
[18:04:00.051]                   options(future.plan = NULL)
[18:04:00.051]                   if (is.na(NA_character_)) 
[18:04:00.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:00.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:00.051]                     .init = FALSE)
[18:04:00.051]                 }
[18:04:00.051]             }
[18:04:00.051]         }
[18:04:00.051]     })
[18:04:00.051]     if (TRUE) {
[18:04:00.051]         base::sink(type = "output", split = FALSE)
[18:04:00.051]         if (TRUE) {
[18:04:00.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:00.051]         }
[18:04:00.051]         else {
[18:04:00.051]             ...future.result["stdout"] <- base::list(NULL)
[18:04:00.051]         }
[18:04:00.051]         base::close(...future.stdout)
[18:04:00.051]         ...future.stdout <- NULL
[18:04:00.051]     }
[18:04:00.051]     ...future.result$conditions <- ...future.conditions
[18:04:00.051]     ...future.result$finished <- base::Sys.time()
[18:04:00.051]     ...future.result
[18:04:00.051] }
[18:04:00.056] requestCore(): workers = 2
[18:04:00.059] MulticoreFuture started
[18:04:00.060] - Launch lazy future ... done
[18:04:00.060] run() for ‘MulticoreFuture’ ... done
** Collecting results
v1 = 1
[18:04:00.061] plan(): Setting new future strategy stack:
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[18:04:00.062] result() for MulticoreFuture ...
[18:04:00.062] List of future strategies:
[18:04:00.062] 1. sequential:
[18:04:00.062]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.062]    - tweaked: FALSE
[18:04:00.062]    - call: NULL
[18:04:00.064] plan(): nbrOfWorkers() = 1
[18:04:00.062] result() for MulticoreFuture ... done
[18:04:00.064] result() for MulticoreFuture ...
[18:04:00.064] result() for MulticoreFuture ... done
[18:04:00.065] signalConditions() ...
[18:04:00.065]  - include = ‘immediateCondition’
[18:04:00.065]  - exclude = 
[18:04:00.067]  - resignal = FALSE
[18:04:00.067]  - Number of conditions: 1
[18:04:00.067] signalConditions() ... done
[18:04:00.068] Future state: ‘finished’
[18:04:00.068] result() for MulticoreFuture ...
[18:04:00.068] result() for MulticoreFuture ... done
[18:04:00.069] signalConditions() ...
[18:04:00.069]  - include = ‘condition’
[18:04:00.069]  - exclude = ‘immediateCondition’
[18:04:00.070]  - resignal = TRUE
[18:04:00.070]  - Number of conditions: 1
[18:04:00.070]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:00.071] signalConditions() ... done
v3: <simpleError> (as expect)
[18:04:00.072] result() for MulticoreFuture ...
[18:04:00.072] plan(): Setting new future strategy stack:
[18:04:00.073] List of future strategies:
[18:04:00.073] 1. multicore:
[18:04:00.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:00.073]    - tweaked: FALSE
[18:04:00.073]    - call: plan(strategy)
[18:04:00.083] plan(): nbrOfWorkers() = 2
[18:04:00.085] result() for MulticoreFuture ...
[18:04:00.086] result() for MulticoreFuture ... done
[18:04:00.086] result() for MulticoreFuture ... done
[18:04:00.086] result() for MulticoreFuture ...
[18:04:00.087] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[18:04:00.088] getGlobalsAndPackages() ...
[18:04:00.088] Searching for globals...
[18:04:00.089] 
[18:04:00.089] Searching for globals ... DONE
[18:04:00.089] - globals: [0] <none>
[18:04:00.090] getGlobalsAndPackages() ... DONE
[18:04:00.090] run() for ‘Future’ ...
[18:04:00.090] - state: ‘created’
[18:04:00.091] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:00.098] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:00.098] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:00.098]   - Field: ‘label’
[18:04:00.099]   - Field: ‘local’
[18:04:00.099]   - Field: ‘owner’
[18:04:00.099]   - Field: ‘envir’
[18:04:00.099]   - Field: ‘workers’
[18:04:00.100]   - Field: ‘packages’
[18:04:00.100]   - Field: ‘gc’
[18:04:00.100]   - Field: ‘job’
[18:04:00.100]   - Field: ‘conditions’
[18:04:00.101]   - Field: ‘expr’
[18:04:00.101]   - Field: ‘uuid’
[18:04:00.101]   - Field: ‘seed’
[18:04:00.101]   - Field: ‘version’
[18:04:00.101]   - Field: ‘result’
[18:04:00.102]   - Field: ‘asynchronous’
[18:04:00.102]   - Field: ‘calls’
[18:04:00.102]   - Field: ‘globals’
[18:04:00.102]   - Field: ‘stdout’
[18:04:00.103]   - Field: ‘earlySignal’
[18:04:00.103]   - Field: ‘lazy’
[18:04:00.103]   - Field: ‘state’
[18:04:00.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:00.103] - Launch lazy future ...
[18:04:00.104] Packages needed by the future expression (n = 0): <none>
[18:04:00.104] Packages needed by future strategies (n = 0): <none>
[18:04:00.105] {
[18:04:00.105]     {
[18:04:00.105]         {
[18:04:00.105]             ...future.startTime <- base::Sys.time()
[18:04:00.105]             {
[18:04:00.105]                 {
[18:04:00.105]                   {
[18:04:00.105]                     {
[18:04:00.105]                       base::local({
[18:04:00.105]                         has_future <- base::requireNamespace("future", 
[18:04:00.105]                           quietly = TRUE)
[18:04:00.105]                         if (has_future) {
[18:04:00.105]                           ns <- base::getNamespace("future")
[18:04:00.105]                           version <- ns[[".package"]][["version"]]
[18:04:00.105]                           if (is.null(version)) 
[18:04:00.105]                             version <- utils::packageVersion("future")
[18:04:00.105]                         }
[18:04:00.105]                         else {
[18:04:00.105]                           version <- NULL
[18:04:00.105]                         }
[18:04:00.105]                         if (!has_future || version < "1.8.0") {
[18:04:00.105]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:00.105]                             "", base::R.version$version.string), 
[18:04:00.105]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:00.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:00.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:00.105]                               "release", "version")], collapse = " "), 
[18:04:00.105]                             hostname = base::Sys.info()[["nodename"]])
[18:04:00.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:00.105]                             info)
[18:04:00.105]                           info <- base::paste(info, collapse = "; ")
[18:04:00.105]                           if (!has_future) {
[18:04:00.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:00.105]                               info)
[18:04:00.105]                           }
[18:04:00.105]                           else {
[18:04:00.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:00.105]                               info, version)
[18:04:00.105]                           }
[18:04:00.105]                           base::stop(msg)
[18:04:00.105]                         }
[18:04:00.105]                       })
[18:04:00.105]                     }
[18:04:00.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:00.105]                     base::options(mc.cores = 1L)
[18:04:00.105]                   }
[18:04:00.105]                   ...future.strategy.old <- future::plan("list")
[18:04:00.105]                   options(future.plan = NULL)
[18:04:00.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:00.105]                 }
[18:04:00.105]                 ...future.workdir <- getwd()
[18:04:00.105]             }
[18:04:00.105]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:00.105]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:00.105]         }
[18:04:00.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:00.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:00.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:00.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:00.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:00.105]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:00.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:00.105]             base::names(...future.oldOptions))
[18:04:00.105]     }
[18:04:00.105]     if (FALSE) {
[18:04:00.105]     }
[18:04:00.105]     else {
[18:04:00.105]         if (TRUE) {
[18:04:00.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:00.105]                 open = "w")
[18:04:00.105]         }
[18:04:00.105]         else {
[18:04:00.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:00.105]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:00.105]         }
[18:04:00.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:00.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:00.105]             base::sink(type = "output", split = FALSE)
[18:04:00.105]             base::close(...future.stdout)
[18:04:00.105]         }, add = TRUE)
[18:04:00.105]     }
[18:04:00.105]     ...future.frame <- base::sys.nframe()
[18:04:00.105]     ...future.conditions <- base::list()
[18:04:00.105]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:00.105]     if (FALSE) {
[18:04:00.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:00.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:00.105]     }
[18:04:00.105]     ...future.result <- base::tryCatch({
[18:04:00.105]         base::withCallingHandlers({
[18:04:00.105]             ...future.value <- base::withVisible(base::local({
[18:04:00.105]                 withCallingHandlers({
[18:04:00.105]                   1
[18:04:00.105]                 }, immediateCondition = function(cond) {
[18:04:00.105]                   save_rds <- function (object, pathname, ...) 
[18:04:00.105]                   {
[18:04:00.105]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:00.105]                     if (file_test("-f", pathname_tmp)) {
[18:04:00.105]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.105]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:00.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.105]                         fi_tmp[["mtime"]])
[18:04:00.105]                     }
[18:04:00.105]                     tryCatch({
[18:04:00.105]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:00.105]                     }, error = function(ex) {
[18:04:00.105]                       msg <- conditionMessage(ex)
[18:04:00.105]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.105]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:00.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.105]                         fi_tmp[["mtime"]], msg)
[18:04:00.105]                       ex$message <- msg
[18:04:00.105]                       stop(ex)
[18:04:00.105]                     })
[18:04:00.105]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:00.105]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:00.105]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:00.105]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.105]                       fi <- file.info(pathname)
[18:04:00.105]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:00.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.105]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:00.105]                         fi[["size"]], fi[["mtime"]])
[18:04:00.105]                       stop(msg)
[18:04:00.105]                     }
[18:04:00.105]                     invisible(pathname)
[18:04:00.105]                   }
[18:04:00.105]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:00.105]                     rootPath = tempdir()) 
[18:04:00.105]                   {
[18:04:00.105]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:00.105]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:00.105]                       tmpdir = path, fileext = ".rds")
[18:04:00.105]                     save_rds(obj, file)
[18:04:00.105]                   }
[18:04:00.105]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:04:00.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.105]                   {
[18:04:00.105]                     inherits <- base::inherits
[18:04:00.105]                     invokeRestart <- base::invokeRestart
[18:04:00.105]                     is.null <- base::is.null
[18:04:00.105]                     muffled <- FALSE
[18:04:00.105]                     if (inherits(cond, "message")) {
[18:04:00.105]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:00.105]                       if (muffled) 
[18:04:00.105]                         invokeRestart("muffleMessage")
[18:04:00.105]                     }
[18:04:00.105]                     else if (inherits(cond, "warning")) {
[18:04:00.105]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:00.105]                       if (muffled) 
[18:04:00.105]                         invokeRestart("muffleWarning")
[18:04:00.105]                     }
[18:04:00.105]                     else if (inherits(cond, "condition")) {
[18:04:00.105]                       if (!is.null(pattern)) {
[18:04:00.105]                         computeRestarts <- base::computeRestarts
[18:04:00.105]                         grepl <- base::grepl
[18:04:00.105]                         restarts <- computeRestarts(cond)
[18:04:00.105]                         for (restart in restarts) {
[18:04:00.105]                           name <- restart$name
[18:04:00.105]                           if (is.null(name)) 
[18:04:00.105]                             next
[18:04:00.105]                           if (!grepl(pattern, name)) 
[18:04:00.105]                             next
[18:04:00.105]                           invokeRestart(restart)
[18:04:00.105]                           muffled <- TRUE
[18:04:00.105]                           break
[18:04:00.105]                         }
[18:04:00.105]                       }
[18:04:00.105]                     }
[18:04:00.105]                     invisible(muffled)
[18:04:00.105]                   }
[18:04:00.105]                   muffleCondition(cond)
[18:04:00.105]                 })
[18:04:00.105]             }))
[18:04:00.105]             future::FutureResult(value = ...future.value$value, 
[18:04:00.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.105]                   ...future.rng), globalenv = if (FALSE) 
[18:04:00.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:00.105]                     ...future.globalenv.names))
[18:04:00.105]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:00.105]         }, condition = base::local({
[18:04:00.105]             c <- base::c
[18:04:00.105]             inherits <- base::inherits
[18:04:00.105]             invokeRestart <- base::invokeRestart
[18:04:00.105]             length <- base::length
[18:04:00.105]             list <- base::list
[18:04:00.105]             seq.int <- base::seq.int
[18:04:00.105]             signalCondition <- base::signalCondition
[18:04:00.105]             sys.calls <- base::sys.calls
[18:04:00.105]             `[[` <- base::`[[`
[18:04:00.105]             `+` <- base::`+`
[18:04:00.105]             `<<-` <- base::`<<-`
[18:04:00.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:00.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:00.105]                   3L)]
[18:04:00.105]             }
[18:04:00.105]             function(cond) {
[18:04:00.105]                 is_error <- inherits(cond, "error")
[18:04:00.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:00.105]                   NULL)
[18:04:00.105]                 if (is_error) {
[18:04:00.105]                   sessionInformation <- function() {
[18:04:00.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:00.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:00.105]                       search = base::search(), system = base::Sys.info())
[18:04:00.105]                   }
[18:04:00.105]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:00.105]                     cond$call), session = sessionInformation(), 
[18:04:00.105]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:00.105]                   signalCondition(cond)
[18:04:00.105]                 }
[18:04:00.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:00.105]                 "immediateCondition"))) {
[18:04:00.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:00.105]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:00.105]                   if (TRUE && !signal) {
[18:04:00.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.105]                     {
[18:04:00.105]                       inherits <- base::inherits
[18:04:00.105]                       invokeRestart <- base::invokeRestart
[18:04:00.105]                       is.null <- base::is.null
[18:04:00.105]                       muffled <- FALSE
[18:04:00.105]                       if (inherits(cond, "message")) {
[18:04:00.105]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.105]                         if (muffled) 
[18:04:00.105]                           invokeRestart("muffleMessage")
[18:04:00.105]                       }
[18:04:00.105]                       else if (inherits(cond, "warning")) {
[18:04:00.105]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.105]                         if (muffled) 
[18:04:00.105]                           invokeRestart("muffleWarning")
[18:04:00.105]                       }
[18:04:00.105]                       else if (inherits(cond, "condition")) {
[18:04:00.105]                         if (!is.null(pattern)) {
[18:04:00.105]                           computeRestarts <- base::computeRestarts
[18:04:00.105]                           grepl <- base::grepl
[18:04:00.105]                           restarts <- computeRestarts(cond)
[18:04:00.105]                           for (restart in restarts) {
[18:04:00.105]                             name <- restart$name
[18:04:00.105]                             if (is.null(name)) 
[18:04:00.105]                               next
[18:04:00.105]                             if (!grepl(pattern, name)) 
[18:04:00.105]                               next
[18:04:00.105]                             invokeRestart(restart)
[18:04:00.105]                             muffled <- TRUE
[18:04:00.105]                             break
[18:04:00.105]                           }
[18:04:00.105]                         }
[18:04:00.105]                       }
[18:04:00.105]                       invisible(muffled)
[18:04:00.105]                     }
[18:04:00.105]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.105]                   }
[18:04:00.105]                 }
[18:04:00.105]                 else {
[18:04:00.105]                   if (TRUE) {
[18:04:00.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.105]                     {
[18:04:00.105]                       inherits <- base::inherits
[18:04:00.105]                       invokeRestart <- base::invokeRestart
[18:04:00.105]                       is.null <- base::is.null
[18:04:00.105]                       muffled <- FALSE
[18:04:00.105]                       if (inherits(cond, "message")) {
[18:04:00.105]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.105]                         if (muffled) 
[18:04:00.105]                           invokeRestart("muffleMessage")
[18:04:00.105]                       }
[18:04:00.105]                       else if (inherits(cond, "warning")) {
[18:04:00.105]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.105]                         if (muffled) 
[18:04:00.105]                           invokeRestart("muffleWarning")
[18:04:00.105]                       }
[18:04:00.105]                       else if (inherits(cond, "condition")) {
[18:04:00.105]                         if (!is.null(pattern)) {
[18:04:00.105]                           computeRestarts <- base::computeRestarts
[18:04:00.105]                           grepl <- base::grepl
[18:04:00.105]                           restarts <- computeRestarts(cond)
[18:04:00.105]                           for (restart in restarts) {
[18:04:00.105]                             name <- restart$name
[18:04:00.105]                             if (is.null(name)) 
[18:04:00.105]                               next
[18:04:00.105]                             if (!grepl(pattern, name)) 
[18:04:00.105]                               next
[18:04:00.105]                             invokeRestart(restart)
[18:04:00.105]                             muffled <- TRUE
[18:04:00.105]                             break
[18:04:00.105]                           }
[18:04:00.105]                         }
[18:04:00.105]                       }
[18:04:00.105]                       invisible(muffled)
[18:04:00.105]                     }
[18:04:00.105]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.105]                   }
[18:04:00.105]                 }
[18:04:00.105]             }
[18:04:00.105]         }))
[18:04:00.105]     }, error = function(ex) {
[18:04:00.105]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:00.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.105]                 ...future.rng), started = ...future.startTime, 
[18:04:00.105]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:00.105]             version = "1.8"), class = "FutureResult")
[18:04:00.105]     }, finally = {
[18:04:00.105]         if (!identical(...future.workdir, getwd())) 
[18:04:00.105]             setwd(...future.workdir)
[18:04:00.105]         {
[18:04:00.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:00.105]                 ...future.oldOptions$nwarnings <- NULL
[18:04:00.105]             }
[18:04:00.105]             base::options(...future.oldOptions)
[18:04:00.105]             if (.Platform$OS.type == "windows") {
[18:04:00.105]                 old_names <- names(...future.oldEnvVars)
[18:04:00.105]                 envs <- base::Sys.getenv()
[18:04:00.105]                 names <- names(envs)
[18:04:00.105]                 common <- intersect(names, old_names)
[18:04:00.105]                 added <- setdiff(names, old_names)
[18:04:00.105]                 removed <- setdiff(old_names, names)
[18:04:00.105]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:00.105]                   envs[common]]
[18:04:00.105]                 NAMES <- toupper(changed)
[18:04:00.105]                 args <- list()
[18:04:00.105]                 for (kk in seq_along(NAMES)) {
[18:04:00.105]                   name <- changed[[kk]]
[18:04:00.105]                   NAME <- NAMES[[kk]]
[18:04:00.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.105]                     next
[18:04:00.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.105]                 }
[18:04:00.105]                 NAMES <- toupper(added)
[18:04:00.105]                 for (kk in seq_along(NAMES)) {
[18:04:00.105]                   name <- added[[kk]]
[18:04:00.105]                   NAME <- NAMES[[kk]]
[18:04:00.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.105]                     next
[18:04:00.105]                   args[[name]] <- ""
[18:04:00.105]                 }
[18:04:00.105]                 NAMES <- toupper(removed)
[18:04:00.105]                 for (kk in seq_along(NAMES)) {
[18:04:00.105]                   name <- removed[[kk]]
[18:04:00.105]                   NAME <- NAMES[[kk]]
[18:04:00.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.105]                     next
[18:04:00.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.105]                 }
[18:04:00.105]                 if (length(args) > 0) 
[18:04:00.105]                   base::do.call(base::Sys.setenv, args = args)
[18:04:00.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:00.105]             }
[18:04:00.105]             else {
[18:04:00.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:00.105]             }
[18:04:00.105]             {
[18:04:00.105]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:00.105]                   0L) {
[18:04:00.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:00.105]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:00.105]                   base::options(opts)
[18:04:00.105]                 }
[18:04:00.105]                 {
[18:04:00.105]                   {
[18:04:00.105]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:00.105]                     NULL
[18:04:00.105]                   }
[18:04:00.105]                   options(future.plan = NULL)
[18:04:00.105]                   if (is.na(NA_character_)) 
[18:04:00.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:00.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:00.105]                     .init = FALSE)
[18:04:00.105]                 }
[18:04:00.105]             }
[18:04:00.105]         }
[18:04:00.105]     })
[18:04:00.105]     if (TRUE) {
[18:04:00.105]         base::sink(type = "output", split = FALSE)
[18:04:00.105]         if (TRUE) {
[18:04:00.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:00.105]         }
[18:04:00.105]         else {
[18:04:00.105]             ...future.result["stdout"] <- base::list(NULL)
[18:04:00.105]         }
[18:04:00.105]         base::close(...future.stdout)
[18:04:00.105]         ...future.stdout <- NULL
[18:04:00.105]     }
[18:04:00.105]     ...future.result$conditions <- ...future.conditions
[18:04:00.105]     ...future.result$finished <- base::Sys.time()
[18:04:00.105]     ...future.result
[18:04:00.105] }
[18:04:00.113] requestCore(): workers = 2
[18:04:00.117] MulticoreFuture started
[18:04:00.117] - Launch lazy future ... done
[18:04:00.118] run() for ‘MulticoreFuture’ ... done
[18:04:00.119] plan(): Setting new future strategy stack:
[18:04:00.119] result() for MulticoreFuture ...
[18:04:00.119] List of future strategies:
[18:04:00.119] 1. sequential:
[18:04:00.119]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.119]    - tweaked: FALSE
[18:04:00.119]    - call: NULL
[18:04:00.122] plan(): nbrOfWorkers() = 1
[18:04:00.126] plan(): Setting new future strategy stack:
[18:04:00.127] List of future strategies:
[18:04:00.127] 1. multicore:
[18:04:00.127]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:00.127]    - tweaked: FALSE
[18:04:00.127]    - call: plan(strategy)
[18:04:00.136] plan(): nbrOfWorkers() = 2
[18:04:00.138] result() for MulticoreFuture ...
[18:04:00.138] result() for MulticoreFuture ... done
[18:04:00.139] result() for MulticoreFuture ... done
[18:04:00.139] result() for MulticoreFuture ...
[18:04:00.139] result() for MulticoreFuture ... done
c = 1
[18:04:00.140] getGlobalsAndPackages() ...
[18:04:00.141] Searching for globals...
[18:04:00.142] 
[18:04:00.142] Searching for globals ... DONE
[18:04:00.142] - globals: [0] <none>
[18:04:00.142] getGlobalsAndPackages() ... DONE
[18:04:00.143] run() for ‘Future’ ...
[18:04:00.143] - state: ‘created’
[18:04:00.144] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:00.151] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:00.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:00.151]   - Field: ‘label’
[18:04:00.152]   - Field: ‘local’
[18:04:00.152]   - Field: ‘owner’
[18:04:00.152]   - Field: ‘envir’
[18:04:00.152]   - Field: ‘workers’
[18:04:00.153]   - Field: ‘packages’
[18:04:00.153]   - Field: ‘gc’
[18:04:00.153]   - Field: ‘job’
[18:04:00.153]   - Field: ‘conditions’
[18:04:00.154]   - Field: ‘expr’
[18:04:00.154]   - Field: ‘uuid’
[18:04:00.154]   - Field: ‘seed’
[18:04:00.154]   - Field: ‘version’
[18:04:00.155]   - Field: ‘result’
[18:04:00.155]   - Field: ‘asynchronous’
[18:04:00.155]   - Field: ‘calls’
[18:04:00.155]   - Field: ‘globals’
[18:04:00.156]   - Field: ‘stdout’
[18:04:00.156]   - Field: ‘earlySignal’
[18:04:00.156]   - Field: ‘lazy’
[18:04:00.156]   - Field: ‘state’
[18:04:00.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:00.157] - Launch lazy future ...
[18:04:00.158] Packages needed by the future expression (n = 0): <none>
[18:04:00.158] Packages needed by future strategies (n = 0): <none>
[18:04:00.159] {
[18:04:00.159]     {
[18:04:00.159]         {
[18:04:00.159]             ...future.startTime <- base::Sys.time()
[18:04:00.159]             {
[18:04:00.159]                 {
[18:04:00.159]                   {
[18:04:00.159]                     {
[18:04:00.159]                       base::local({
[18:04:00.159]                         has_future <- base::requireNamespace("future", 
[18:04:00.159]                           quietly = TRUE)
[18:04:00.159]                         if (has_future) {
[18:04:00.159]                           ns <- base::getNamespace("future")
[18:04:00.159]                           version <- ns[[".package"]][["version"]]
[18:04:00.159]                           if (is.null(version)) 
[18:04:00.159]                             version <- utils::packageVersion("future")
[18:04:00.159]                         }
[18:04:00.159]                         else {
[18:04:00.159]                           version <- NULL
[18:04:00.159]                         }
[18:04:00.159]                         if (!has_future || version < "1.8.0") {
[18:04:00.159]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:00.159]                             "", base::R.version$version.string), 
[18:04:00.159]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:00.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:00.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:00.159]                               "release", "version")], collapse = " "), 
[18:04:00.159]                             hostname = base::Sys.info()[["nodename"]])
[18:04:00.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:00.159]                             info)
[18:04:00.159]                           info <- base::paste(info, collapse = "; ")
[18:04:00.159]                           if (!has_future) {
[18:04:00.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:00.159]                               info)
[18:04:00.159]                           }
[18:04:00.159]                           else {
[18:04:00.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:00.159]                               info, version)
[18:04:00.159]                           }
[18:04:00.159]                           base::stop(msg)
[18:04:00.159]                         }
[18:04:00.159]                       })
[18:04:00.159]                     }
[18:04:00.159]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:00.159]                     base::options(mc.cores = 1L)
[18:04:00.159]                   }
[18:04:00.159]                   ...future.strategy.old <- future::plan("list")
[18:04:00.159]                   options(future.plan = NULL)
[18:04:00.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:00.159]                 }
[18:04:00.159]                 ...future.workdir <- getwd()
[18:04:00.159]             }
[18:04:00.159]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:00.159]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:00.159]         }
[18:04:00.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:00.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:00.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:00.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:00.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:00.159]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:00.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:00.159]             base::names(...future.oldOptions))
[18:04:00.159]     }
[18:04:00.159]     if (FALSE) {
[18:04:00.159]     }
[18:04:00.159]     else {
[18:04:00.159]         if (TRUE) {
[18:04:00.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:00.159]                 open = "w")
[18:04:00.159]         }
[18:04:00.159]         else {
[18:04:00.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:00.159]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:00.159]         }
[18:04:00.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:00.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:00.159]             base::sink(type = "output", split = FALSE)
[18:04:00.159]             base::close(...future.stdout)
[18:04:00.159]         }, add = TRUE)
[18:04:00.159]     }
[18:04:00.159]     ...future.frame <- base::sys.nframe()
[18:04:00.159]     ...future.conditions <- base::list()
[18:04:00.159]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:00.159]     if (FALSE) {
[18:04:00.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:00.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:00.159]     }
[18:04:00.159]     ...future.result <- base::tryCatch({
[18:04:00.159]         base::withCallingHandlers({
[18:04:00.159]             ...future.value <- base::withVisible(base::local({
[18:04:00.159]                 withCallingHandlers({
[18:04:00.159]                   1
[18:04:00.159]                 }, immediateCondition = function(cond) {
[18:04:00.159]                   save_rds <- function (object, pathname, ...) 
[18:04:00.159]                   {
[18:04:00.159]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:00.159]                     if (file_test("-f", pathname_tmp)) {
[18:04:00.159]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.159]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:00.159]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.159]                         fi_tmp[["mtime"]])
[18:04:00.159]                     }
[18:04:00.159]                     tryCatch({
[18:04:00.159]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:00.159]                     }, error = function(ex) {
[18:04:00.159]                       msg <- conditionMessage(ex)
[18:04:00.159]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.159]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:00.159]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.159]                         fi_tmp[["mtime"]], msg)
[18:04:00.159]                       ex$message <- msg
[18:04:00.159]                       stop(ex)
[18:04:00.159]                     })
[18:04:00.159]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:00.159]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:00.159]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:00.159]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.159]                       fi <- file.info(pathname)
[18:04:00.159]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:00.159]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.159]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:00.159]                         fi[["size"]], fi[["mtime"]])
[18:04:00.159]                       stop(msg)
[18:04:00.159]                     }
[18:04:00.159]                     invisible(pathname)
[18:04:00.159]                   }
[18:04:00.159]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:00.159]                     rootPath = tempdir()) 
[18:04:00.159]                   {
[18:04:00.159]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:00.159]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:00.159]                       tmpdir = path, fileext = ".rds")
[18:04:00.159]                     save_rds(obj, file)
[18:04:00.159]                   }
[18:04:00.159]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:04:00.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.159]                   {
[18:04:00.159]                     inherits <- base::inherits
[18:04:00.159]                     invokeRestart <- base::invokeRestart
[18:04:00.159]                     is.null <- base::is.null
[18:04:00.159]                     muffled <- FALSE
[18:04:00.159]                     if (inherits(cond, "message")) {
[18:04:00.159]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:00.159]                       if (muffled) 
[18:04:00.159]                         invokeRestart("muffleMessage")
[18:04:00.159]                     }
[18:04:00.159]                     else if (inherits(cond, "warning")) {
[18:04:00.159]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:00.159]                       if (muffled) 
[18:04:00.159]                         invokeRestart("muffleWarning")
[18:04:00.159]                     }
[18:04:00.159]                     else if (inherits(cond, "condition")) {
[18:04:00.159]                       if (!is.null(pattern)) {
[18:04:00.159]                         computeRestarts <- base::computeRestarts
[18:04:00.159]                         grepl <- base::grepl
[18:04:00.159]                         restarts <- computeRestarts(cond)
[18:04:00.159]                         for (restart in restarts) {
[18:04:00.159]                           name <- restart$name
[18:04:00.159]                           if (is.null(name)) 
[18:04:00.159]                             next
[18:04:00.159]                           if (!grepl(pattern, name)) 
[18:04:00.159]                             next
[18:04:00.159]                           invokeRestart(restart)
[18:04:00.159]                           muffled <- TRUE
[18:04:00.159]                           break
[18:04:00.159]                         }
[18:04:00.159]                       }
[18:04:00.159]                     }
[18:04:00.159]                     invisible(muffled)
[18:04:00.159]                   }
[18:04:00.159]                   muffleCondition(cond)
[18:04:00.159]                 })
[18:04:00.159]             }))
[18:04:00.159]             future::FutureResult(value = ...future.value$value, 
[18:04:00.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.159]                   ...future.rng), globalenv = if (FALSE) 
[18:04:00.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:00.159]                     ...future.globalenv.names))
[18:04:00.159]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:00.159]         }, condition = base::local({
[18:04:00.159]             c <- base::c
[18:04:00.159]             inherits <- base::inherits
[18:04:00.159]             invokeRestart <- base::invokeRestart
[18:04:00.159]             length <- base::length
[18:04:00.159]             list <- base::list
[18:04:00.159]             seq.int <- base::seq.int
[18:04:00.159]             signalCondition <- base::signalCondition
[18:04:00.159]             sys.calls <- base::sys.calls
[18:04:00.159]             `[[` <- base::`[[`
[18:04:00.159]             `+` <- base::`+`
[18:04:00.159]             `<<-` <- base::`<<-`
[18:04:00.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:00.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:00.159]                   3L)]
[18:04:00.159]             }
[18:04:00.159]             function(cond) {
[18:04:00.159]                 is_error <- inherits(cond, "error")
[18:04:00.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:00.159]                   NULL)
[18:04:00.159]                 if (is_error) {
[18:04:00.159]                   sessionInformation <- function() {
[18:04:00.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:00.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:00.159]                       search = base::search(), system = base::Sys.info())
[18:04:00.159]                   }
[18:04:00.159]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:00.159]                     cond$call), session = sessionInformation(), 
[18:04:00.159]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:00.159]                   signalCondition(cond)
[18:04:00.159]                 }
[18:04:00.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:00.159]                 "immediateCondition"))) {
[18:04:00.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:00.159]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:00.159]                   if (TRUE && !signal) {
[18:04:00.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.159]                     {
[18:04:00.159]                       inherits <- base::inherits
[18:04:00.159]                       invokeRestart <- base::invokeRestart
[18:04:00.159]                       is.null <- base::is.null
[18:04:00.159]                       muffled <- FALSE
[18:04:00.159]                       if (inherits(cond, "message")) {
[18:04:00.159]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.159]                         if (muffled) 
[18:04:00.159]                           invokeRestart("muffleMessage")
[18:04:00.159]                       }
[18:04:00.159]                       else if (inherits(cond, "warning")) {
[18:04:00.159]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.159]                         if (muffled) 
[18:04:00.159]                           invokeRestart("muffleWarning")
[18:04:00.159]                       }
[18:04:00.159]                       else if (inherits(cond, "condition")) {
[18:04:00.159]                         if (!is.null(pattern)) {
[18:04:00.159]                           computeRestarts <- base::computeRestarts
[18:04:00.159]                           grepl <- base::grepl
[18:04:00.159]                           restarts <- computeRestarts(cond)
[18:04:00.159]                           for (restart in restarts) {
[18:04:00.159]                             name <- restart$name
[18:04:00.159]                             if (is.null(name)) 
[18:04:00.159]                               next
[18:04:00.159]                             if (!grepl(pattern, name)) 
[18:04:00.159]                               next
[18:04:00.159]                             invokeRestart(restart)
[18:04:00.159]                             muffled <- TRUE
[18:04:00.159]                             break
[18:04:00.159]                           }
[18:04:00.159]                         }
[18:04:00.159]                       }
[18:04:00.159]                       invisible(muffled)
[18:04:00.159]                     }
[18:04:00.159]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.159]                   }
[18:04:00.159]                 }
[18:04:00.159]                 else {
[18:04:00.159]                   if (TRUE) {
[18:04:00.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.159]                     {
[18:04:00.159]                       inherits <- base::inherits
[18:04:00.159]                       invokeRestart <- base::invokeRestart
[18:04:00.159]                       is.null <- base::is.null
[18:04:00.159]                       muffled <- FALSE
[18:04:00.159]                       if (inherits(cond, "message")) {
[18:04:00.159]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.159]                         if (muffled) 
[18:04:00.159]                           invokeRestart("muffleMessage")
[18:04:00.159]                       }
[18:04:00.159]                       else if (inherits(cond, "warning")) {
[18:04:00.159]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.159]                         if (muffled) 
[18:04:00.159]                           invokeRestart("muffleWarning")
[18:04:00.159]                       }
[18:04:00.159]                       else if (inherits(cond, "condition")) {
[18:04:00.159]                         if (!is.null(pattern)) {
[18:04:00.159]                           computeRestarts <- base::computeRestarts
[18:04:00.159]                           grepl <- base::grepl
[18:04:00.159]                           restarts <- computeRestarts(cond)
[18:04:00.159]                           for (restart in restarts) {
[18:04:00.159]                             name <- restart$name
[18:04:00.159]                             if (is.null(name)) 
[18:04:00.159]                               next
[18:04:00.159]                             if (!grepl(pattern, name)) 
[18:04:00.159]                               next
[18:04:00.159]                             invokeRestart(restart)
[18:04:00.159]                             muffled <- TRUE
[18:04:00.159]                             break
[18:04:00.159]                           }
[18:04:00.159]                         }
[18:04:00.159]                       }
[18:04:00.159]                       invisible(muffled)
[18:04:00.159]                     }
[18:04:00.159]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.159]                   }
[18:04:00.159]                 }
[18:04:00.159]             }
[18:04:00.159]         }))
[18:04:00.159]     }, error = function(ex) {
[18:04:00.159]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:00.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.159]                 ...future.rng), started = ...future.startTime, 
[18:04:00.159]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:00.159]             version = "1.8"), class = "FutureResult")
[18:04:00.159]     }, finally = {
[18:04:00.159]         if (!identical(...future.workdir, getwd())) 
[18:04:00.159]             setwd(...future.workdir)
[18:04:00.159]         {
[18:04:00.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:00.159]                 ...future.oldOptions$nwarnings <- NULL
[18:04:00.159]             }
[18:04:00.159]             base::options(...future.oldOptions)
[18:04:00.159]             if (.Platform$OS.type == "windows") {
[18:04:00.159]                 old_names <- names(...future.oldEnvVars)
[18:04:00.159]                 envs <- base::Sys.getenv()
[18:04:00.159]                 names <- names(envs)
[18:04:00.159]                 common <- intersect(names, old_names)
[18:04:00.159]                 added <- setdiff(names, old_names)
[18:04:00.159]                 removed <- setdiff(old_names, names)
[18:04:00.159]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:00.159]                   envs[common]]
[18:04:00.159]                 NAMES <- toupper(changed)
[18:04:00.159]                 args <- list()
[18:04:00.159]                 for (kk in seq_along(NAMES)) {
[18:04:00.159]                   name <- changed[[kk]]
[18:04:00.159]                   NAME <- NAMES[[kk]]
[18:04:00.159]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.159]                     next
[18:04:00.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.159]                 }
[18:04:00.159]                 NAMES <- toupper(added)
[18:04:00.159]                 for (kk in seq_along(NAMES)) {
[18:04:00.159]                   name <- added[[kk]]
[18:04:00.159]                   NAME <- NAMES[[kk]]
[18:04:00.159]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.159]                     next
[18:04:00.159]                   args[[name]] <- ""
[18:04:00.159]                 }
[18:04:00.159]                 NAMES <- toupper(removed)
[18:04:00.159]                 for (kk in seq_along(NAMES)) {
[18:04:00.159]                   name <- removed[[kk]]
[18:04:00.159]                   NAME <- NAMES[[kk]]
[18:04:00.159]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.159]                     next
[18:04:00.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.159]                 }
[18:04:00.159]                 if (length(args) > 0) 
[18:04:00.159]                   base::do.call(base::Sys.setenv, args = args)
[18:04:00.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:00.159]             }
[18:04:00.159]             else {
[18:04:00.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:00.159]             }
[18:04:00.159]             {
[18:04:00.159]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:00.159]                   0L) {
[18:04:00.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:00.159]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:00.159]                   base::options(opts)
[18:04:00.159]                 }
[18:04:00.159]                 {
[18:04:00.159]                   {
[18:04:00.159]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:00.159]                     NULL
[18:04:00.159]                   }
[18:04:00.159]                   options(future.plan = NULL)
[18:04:00.159]                   if (is.na(NA_character_)) 
[18:04:00.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:00.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:00.159]                     .init = FALSE)
[18:04:00.159]                 }
[18:04:00.159]             }
[18:04:00.159]         }
[18:04:00.159]     })
[18:04:00.159]     if (TRUE) {
[18:04:00.159]         base::sink(type = "output", split = FALSE)
[18:04:00.159]         if (TRUE) {
[18:04:00.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:00.159]         }
[18:04:00.159]         else {
[18:04:00.159]             ...future.result["stdout"] <- base::list(NULL)
[18:04:00.159]         }
[18:04:00.159]         base::close(...future.stdout)
[18:04:00.159]         ...future.stdout <- NULL
[18:04:00.159]     }
[18:04:00.159]     ...future.result$conditions <- ...future.conditions
[18:04:00.159]     ...future.result$finished <- base::Sys.time()
[18:04:00.159]     ...future.result
[18:04:00.159] }
[18:04:00.164] requestCore(): workers = 2
[18:04:00.167] MulticoreFuture started
[18:04:00.168] - Launch lazy future ... done
[18:04:00.168] run() for ‘MulticoreFuture’ ... done
[18:04:00.169] result() for MulticoreFuture ...
[18:04:00.169] plan(): Setting new future strategy stack:
[18:04:00.170] List of future strategies:
[18:04:00.170] 1. sequential:
[18:04:00.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.170]    - tweaked: FALSE
[18:04:00.170]    - call: NULL
[18:04:00.172] plan(): nbrOfWorkers() = 1
[18:04:00.176] plan(): Setting new future strategy stack:
[18:04:00.177] List of future strategies:
[18:04:00.177] 1. multicore:
[18:04:00.177]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:00.177]    - tweaked: FALSE
[18:04:00.177]    - call: plan(strategy)
[18:04:00.186] plan(): nbrOfWorkers() = 2
[18:04:00.188] result() for MulticoreFuture ...
[18:04:00.188] result() for MulticoreFuture ... done
[18:04:00.189] result() for MulticoreFuture ... done
[18:04:00.189] result() for MulticoreFuture ...
[18:04:00.189] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[18:04:00.190] getGlobalsAndPackages() ...
[18:04:00.191] Searching for globals...
[18:04:00.200] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[18:04:00.201] Searching for globals ... DONE
[18:04:00.201] Resolving globals: FALSE
[18:04:00.202] 
[18:04:00.202] - packages: [1] ‘future’
[18:04:00.202] getGlobalsAndPackages() ... DONE
[18:04:00.203] run() for ‘Future’ ...
[18:04:00.203] - state: ‘created’
[18:04:00.204] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:00.211] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:00.212] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:00.212]   - Field: ‘label’
[18:04:00.212]   - Field: ‘local’
[18:04:00.213]   - Field: ‘owner’
[18:04:00.213]   - Field: ‘envir’
[18:04:00.213]   - Field: ‘workers’
[18:04:00.213]   - Field: ‘packages’
[18:04:00.214]   - Field: ‘gc’
[18:04:00.214]   - Field: ‘job’
[18:04:00.214]   - Field: ‘conditions’
[18:04:00.214]   - Field: ‘expr’
[18:04:00.215]   - Field: ‘uuid’
[18:04:00.215]   - Field: ‘seed’
[18:04:00.215]   - Field: ‘version’
[18:04:00.215]   - Field: ‘result’
[18:04:00.216]   - Field: ‘asynchronous’
[18:04:00.216]   - Field: ‘calls’
[18:04:00.216]   - Field: ‘globals’
[18:04:00.216]   - Field: ‘stdout’
[18:04:00.217]   - Field: ‘earlySignal’
[18:04:00.217]   - Field: ‘lazy’
[18:04:00.217]   - Field: ‘state’
[18:04:00.217] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:00.218] - Launch lazy future ...
[18:04:00.218] Packages needed by the future expression (n = 1): ‘future’
[18:04:00.219] Packages needed by future strategies (n = 0): <none>
[18:04:00.223] {
[18:04:00.223]     {
[18:04:00.223]         {
[18:04:00.223]             ...future.startTime <- base::Sys.time()
[18:04:00.223]             {
[18:04:00.223]                 {
[18:04:00.223]                   {
[18:04:00.223]                     {
[18:04:00.223]                       {
[18:04:00.223]                         base::local({
[18:04:00.223]                           has_future <- base::requireNamespace("future", 
[18:04:00.223]                             quietly = TRUE)
[18:04:00.223]                           if (has_future) {
[18:04:00.223]                             ns <- base::getNamespace("future")
[18:04:00.223]                             version <- ns[[".package"]][["version"]]
[18:04:00.223]                             if (is.null(version)) 
[18:04:00.223]                               version <- utils::packageVersion("future")
[18:04:00.223]                           }
[18:04:00.223]                           else {
[18:04:00.223]                             version <- NULL
[18:04:00.223]                           }
[18:04:00.223]                           if (!has_future || version < "1.8.0") {
[18:04:00.223]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:00.223]                               "", base::R.version$version.string), 
[18:04:00.223]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:00.223]                                 base::R.version$platform, 8 * 
[18:04:00.223]                                   base::.Machine$sizeof.pointer), 
[18:04:00.223]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:00.223]                                 "release", "version")], collapse = " "), 
[18:04:00.223]                               hostname = base::Sys.info()[["nodename"]])
[18:04:00.223]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:00.223]                               info)
[18:04:00.223]                             info <- base::paste(info, collapse = "; ")
[18:04:00.223]                             if (!has_future) {
[18:04:00.223]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:00.223]                                 info)
[18:04:00.223]                             }
[18:04:00.223]                             else {
[18:04:00.223]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:00.223]                                 info, version)
[18:04:00.223]                             }
[18:04:00.223]                             base::stop(msg)
[18:04:00.223]                           }
[18:04:00.223]                         })
[18:04:00.223]                       }
[18:04:00.223]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:00.223]                       base::options(mc.cores = 1L)
[18:04:00.223]                     }
[18:04:00.223]                     base::local({
[18:04:00.223]                       for (pkg in "future") {
[18:04:00.223]                         base::loadNamespace(pkg)
[18:04:00.223]                         base::library(pkg, character.only = TRUE)
[18:04:00.223]                       }
[18:04:00.223]                     })
[18:04:00.223]                   }
[18:04:00.223]                   ...future.strategy.old <- future::plan("list")
[18:04:00.223]                   options(future.plan = NULL)
[18:04:00.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:00.223]                 }
[18:04:00.223]                 ...future.workdir <- getwd()
[18:04:00.223]             }
[18:04:00.223]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:00.223]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:00.223]         }
[18:04:00.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:00.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:00.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:00.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:00.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:00.223]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:00.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:00.223]             base::names(...future.oldOptions))
[18:04:00.223]     }
[18:04:00.223]     if (FALSE) {
[18:04:00.223]     }
[18:04:00.223]     else {
[18:04:00.223]         if (TRUE) {
[18:04:00.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:00.223]                 open = "w")
[18:04:00.223]         }
[18:04:00.223]         else {
[18:04:00.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:00.223]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:00.223]         }
[18:04:00.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:00.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:00.223]             base::sink(type = "output", split = FALSE)
[18:04:00.223]             base::close(...future.stdout)
[18:04:00.223]         }, add = TRUE)
[18:04:00.223]     }
[18:04:00.223]     ...future.frame <- base::sys.nframe()
[18:04:00.223]     ...future.conditions <- base::list()
[18:04:00.223]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:00.223]     if (FALSE) {
[18:04:00.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:00.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:00.223]     }
[18:04:00.223]     ...future.result <- base::tryCatch({
[18:04:00.223]         base::withCallingHandlers({
[18:04:00.223]             ...future.value <- base::withVisible(base::local({
[18:04:00.223]                 withCallingHandlers({
[18:04:00.223]                   {
[18:04:00.223]                     b <- 1
[18:04:00.223]                     c %<-% 2
[18:04:00.223]                     d <- 3
[18:04:00.223]                     4 %->% e
[18:04:00.223]                     b + c + d + e
[18:04:00.223]                   }
[18:04:00.223]                 }, immediateCondition = function(cond) {
[18:04:00.223]                   save_rds <- function (object, pathname, ...) 
[18:04:00.223]                   {
[18:04:00.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:00.223]                     if (file_test("-f", pathname_tmp)) {
[18:04:00.223]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:00.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.223]                         fi_tmp[["mtime"]])
[18:04:00.223]                     }
[18:04:00.223]                     tryCatch({
[18:04:00.223]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:00.223]                     }, error = function(ex) {
[18:04:00.223]                       msg <- conditionMessage(ex)
[18:04:00.223]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:00.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.223]                         fi_tmp[["mtime"]], msg)
[18:04:00.223]                       ex$message <- msg
[18:04:00.223]                       stop(ex)
[18:04:00.223]                     })
[18:04:00.223]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:00.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:00.223]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:00.223]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.223]                       fi <- file.info(pathname)
[18:04:00.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:00.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:00.223]                         fi[["size"]], fi[["mtime"]])
[18:04:00.223]                       stop(msg)
[18:04:00.223]                     }
[18:04:00.223]                     invisible(pathname)
[18:04:00.223]                   }
[18:04:00.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:00.223]                     rootPath = tempdir()) 
[18:04:00.223]                   {
[18:04:00.223]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:00.223]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:00.223]                       tmpdir = path, fileext = ".rds")
[18:04:00.223]                     save_rds(obj, file)
[18:04:00.223]                   }
[18:04:00.223]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:04:00.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.223]                   {
[18:04:00.223]                     inherits <- base::inherits
[18:04:00.223]                     invokeRestart <- base::invokeRestart
[18:04:00.223]                     is.null <- base::is.null
[18:04:00.223]                     muffled <- FALSE
[18:04:00.223]                     if (inherits(cond, "message")) {
[18:04:00.223]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:00.223]                       if (muffled) 
[18:04:00.223]                         invokeRestart("muffleMessage")
[18:04:00.223]                     }
[18:04:00.223]                     else if (inherits(cond, "warning")) {
[18:04:00.223]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:00.223]                       if (muffled) 
[18:04:00.223]                         invokeRestart("muffleWarning")
[18:04:00.223]                     }
[18:04:00.223]                     else if (inherits(cond, "condition")) {
[18:04:00.223]                       if (!is.null(pattern)) {
[18:04:00.223]                         computeRestarts <- base::computeRestarts
[18:04:00.223]                         grepl <- base::grepl
[18:04:00.223]                         restarts <- computeRestarts(cond)
[18:04:00.223]                         for (restart in restarts) {
[18:04:00.223]                           name <- restart$name
[18:04:00.223]                           if (is.null(name)) 
[18:04:00.223]                             next
[18:04:00.223]                           if (!grepl(pattern, name)) 
[18:04:00.223]                             next
[18:04:00.223]                           invokeRestart(restart)
[18:04:00.223]                           muffled <- TRUE
[18:04:00.223]                           break
[18:04:00.223]                         }
[18:04:00.223]                       }
[18:04:00.223]                     }
[18:04:00.223]                     invisible(muffled)
[18:04:00.223]                   }
[18:04:00.223]                   muffleCondition(cond)
[18:04:00.223]                 })
[18:04:00.223]             }))
[18:04:00.223]             future::FutureResult(value = ...future.value$value, 
[18:04:00.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.223]                   ...future.rng), globalenv = if (FALSE) 
[18:04:00.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:00.223]                     ...future.globalenv.names))
[18:04:00.223]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:00.223]         }, condition = base::local({
[18:04:00.223]             c <- base::c
[18:04:00.223]             inherits <- base::inherits
[18:04:00.223]             invokeRestart <- base::invokeRestart
[18:04:00.223]             length <- base::length
[18:04:00.223]             list <- base::list
[18:04:00.223]             seq.int <- base::seq.int
[18:04:00.223]             signalCondition <- base::signalCondition
[18:04:00.223]             sys.calls <- base::sys.calls
[18:04:00.223]             `[[` <- base::`[[`
[18:04:00.223]             `+` <- base::`+`
[18:04:00.223]             `<<-` <- base::`<<-`
[18:04:00.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:00.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:00.223]                   3L)]
[18:04:00.223]             }
[18:04:00.223]             function(cond) {
[18:04:00.223]                 is_error <- inherits(cond, "error")
[18:04:00.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:00.223]                   NULL)
[18:04:00.223]                 if (is_error) {
[18:04:00.223]                   sessionInformation <- function() {
[18:04:00.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:00.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:00.223]                       search = base::search(), system = base::Sys.info())
[18:04:00.223]                   }
[18:04:00.223]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:00.223]                     cond$call), session = sessionInformation(), 
[18:04:00.223]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:00.223]                   signalCondition(cond)
[18:04:00.223]                 }
[18:04:00.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:00.223]                 "immediateCondition"))) {
[18:04:00.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:00.223]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:00.223]                   if (TRUE && !signal) {
[18:04:00.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.223]                     {
[18:04:00.223]                       inherits <- base::inherits
[18:04:00.223]                       invokeRestart <- base::invokeRestart
[18:04:00.223]                       is.null <- base::is.null
[18:04:00.223]                       muffled <- FALSE
[18:04:00.223]                       if (inherits(cond, "message")) {
[18:04:00.223]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.223]                         if (muffled) 
[18:04:00.223]                           invokeRestart("muffleMessage")
[18:04:00.223]                       }
[18:04:00.223]                       else if (inherits(cond, "warning")) {
[18:04:00.223]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.223]                         if (muffled) 
[18:04:00.223]                           invokeRestart("muffleWarning")
[18:04:00.223]                       }
[18:04:00.223]                       else if (inherits(cond, "condition")) {
[18:04:00.223]                         if (!is.null(pattern)) {
[18:04:00.223]                           computeRestarts <- base::computeRestarts
[18:04:00.223]                           grepl <- base::grepl
[18:04:00.223]                           restarts <- computeRestarts(cond)
[18:04:00.223]                           for (restart in restarts) {
[18:04:00.223]                             name <- restart$name
[18:04:00.223]                             if (is.null(name)) 
[18:04:00.223]                               next
[18:04:00.223]                             if (!grepl(pattern, name)) 
[18:04:00.223]                               next
[18:04:00.223]                             invokeRestart(restart)
[18:04:00.223]                             muffled <- TRUE
[18:04:00.223]                             break
[18:04:00.223]                           }
[18:04:00.223]                         }
[18:04:00.223]                       }
[18:04:00.223]                       invisible(muffled)
[18:04:00.223]                     }
[18:04:00.223]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.223]                   }
[18:04:00.223]                 }
[18:04:00.223]                 else {
[18:04:00.223]                   if (TRUE) {
[18:04:00.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.223]                     {
[18:04:00.223]                       inherits <- base::inherits
[18:04:00.223]                       invokeRestart <- base::invokeRestart
[18:04:00.223]                       is.null <- base::is.null
[18:04:00.223]                       muffled <- FALSE
[18:04:00.223]                       if (inherits(cond, "message")) {
[18:04:00.223]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.223]                         if (muffled) 
[18:04:00.223]                           invokeRestart("muffleMessage")
[18:04:00.223]                       }
[18:04:00.223]                       else if (inherits(cond, "warning")) {
[18:04:00.223]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.223]                         if (muffled) 
[18:04:00.223]                           invokeRestart("muffleWarning")
[18:04:00.223]                       }
[18:04:00.223]                       else if (inherits(cond, "condition")) {
[18:04:00.223]                         if (!is.null(pattern)) {
[18:04:00.223]                           computeRestarts <- base::computeRestarts
[18:04:00.223]                           grepl <- base::grepl
[18:04:00.223]                           restarts <- computeRestarts(cond)
[18:04:00.223]                           for (restart in restarts) {
[18:04:00.223]                             name <- restart$name
[18:04:00.223]                             if (is.null(name)) 
[18:04:00.223]                               next
[18:04:00.223]                             if (!grepl(pattern, name)) 
[18:04:00.223]                               next
[18:04:00.223]                             invokeRestart(restart)
[18:04:00.223]                             muffled <- TRUE
[18:04:00.223]                             break
[18:04:00.223]                           }
[18:04:00.223]                         }
[18:04:00.223]                       }
[18:04:00.223]                       invisible(muffled)
[18:04:00.223]                     }
[18:04:00.223]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.223]                   }
[18:04:00.223]                 }
[18:04:00.223]             }
[18:04:00.223]         }))
[18:04:00.223]     }, error = function(ex) {
[18:04:00.223]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:00.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.223]                 ...future.rng), started = ...future.startTime, 
[18:04:00.223]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:00.223]             version = "1.8"), class = "FutureResult")
[18:04:00.223]     }, finally = {
[18:04:00.223]         if (!identical(...future.workdir, getwd())) 
[18:04:00.223]             setwd(...future.workdir)
[18:04:00.223]         {
[18:04:00.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:00.223]                 ...future.oldOptions$nwarnings <- NULL
[18:04:00.223]             }
[18:04:00.223]             base::options(...future.oldOptions)
[18:04:00.223]             if (.Platform$OS.type == "windows") {
[18:04:00.223]                 old_names <- names(...future.oldEnvVars)
[18:04:00.223]                 envs <- base::Sys.getenv()
[18:04:00.223]                 names <- names(envs)
[18:04:00.223]                 common <- intersect(names, old_names)
[18:04:00.223]                 added <- setdiff(names, old_names)
[18:04:00.223]                 removed <- setdiff(old_names, names)
[18:04:00.223]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:00.223]                   envs[common]]
[18:04:00.223]                 NAMES <- toupper(changed)
[18:04:00.223]                 args <- list()
[18:04:00.223]                 for (kk in seq_along(NAMES)) {
[18:04:00.223]                   name <- changed[[kk]]
[18:04:00.223]                   NAME <- NAMES[[kk]]
[18:04:00.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.223]                     next
[18:04:00.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.223]                 }
[18:04:00.223]                 NAMES <- toupper(added)
[18:04:00.223]                 for (kk in seq_along(NAMES)) {
[18:04:00.223]                   name <- added[[kk]]
[18:04:00.223]                   NAME <- NAMES[[kk]]
[18:04:00.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.223]                     next
[18:04:00.223]                   args[[name]] <- ""
[18:04:00.223]                 }
[18:04:00.223]                 NAMES <- toupper(removed)
[18:04:00.223]                 for (kk in seq_along(NAMES)) {
[18:04:00.223]                   name <- removed[[kk]]
[18:04:00.223]                   NAME <- NAMES[[kk]]
[18:04:00.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.223]                     next
[18:04:00.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.223]                 }
[18:04:00.223]                 if (length(args) > 0) 
[18:04:00.223]                   base::do.call(base::Sys.setenv, args = args)
[18:04:00.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:00.223]             }
[18:04:00.223]             else {
[18:04:00.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:00.223]             }
[18:04:00.223]             {
[18:04:00.223]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:00.223]                   0L) {
[18:04:00.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:00.223]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:00.223]                   base::options(opts)
[18:04:00.223]                 }
[18:04:00.223]                 {
[18:04:00.223]                   {
[18:04:00.223]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:00.223]                     NULL
[18:04:00.223]                   }
[18:04:00.223]                   options(future.plan = NULL)
[18:04:00.223]                   if (is.na(NA_character_)) 
[18:04:00.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:00.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:00.223]                     .init = FALSE)
[18:04:00.223]                 }
[18:04:00.223]             }
[18:04:00.223]         }
[18:04:00.223]     })
[18:04:00.223]     if (TRUE) {
[18:04:00.223]         base::sink(type = "output", split = FALSE)
[18:04:00.223]         if (TRUE) {
[18:04:00.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:00.223]         }
[18:04:00.223]         else {
[18:04:00.223]             ...future.result["stdout"] <- base::list(NULL)
[18:04:00.223]         }
[18:04:00.223]         base::close(...future.stdout)
[18:04:00.223]         ...future.stdout <- NULL
[18:04:00.223]     }
[18:04:00.223]     ...future.result$conditions <- ...future.conditions
[18:04:00.223]     ...future.result$finished <- base::Sys.time()
[18:04:00.223]     ...future.result
[18:04:00.223] }
[18:04:00.228] requestCore(): workers = 2
[18:04:00.232] MulticoreFuture started
[18:04:00.232] - Launch lazy future ... done
[18:04:00.233] run() for ‘MulticoreFuture’ ... done
[18:04:00.234] result() for MulticoreFuture ...
[18:04:00.234] plan(): Setting new future strategy stack:
[18:04:00.235] List of future strategies:
[18:04:00.235] 1. sequential:
[18:04:00.235]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.235]    - tweaked: FALSE
[18:04:00.235]    - call: NULL
[18:04:00.237] plan(): nbrOfWorkers() = 1
[18:04:00.305] plan(): Setting new future strategy stack:
[18:04:00.305] List of future strategies:
[18:04:00.305] 1. multicore:
[18:04:00.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:00.305]    - tweaked: FALSE
[18:04:00.305]    - call: plan(strategy)
[18:04:00.313] plan(): nbrOfWorkers() = 2
[18:04:00.315] result() for MulticoreFuture ...
[18:04:00.316] result() for MulticoreFuture ... done
[18:04:00.316] signalConditions() ...
[18:04:00.316]  - include = ‘immediateCondition’
[18:04:00.317]  - exclude = 
[18:04:00.317]  - resignal = FALSE
[18:04:00.317]  - Number of conditions: 88
[18:04:00.318] signalConditions() ... done
[18:04:00.318] result() for MulticoreFuture ... done
[18:04:00.319] result() for MulticoreFuture ...
[18:04:00.319] result() for MulticoreFuture ... done
[18:04:00.319] signalConditions() ...
[18:04:00.319]  - include = ‘immediateCondition’
[18:04:00.320]  - exclude = 
[18:04:00.320]  - resignal = FALSE
[18:04:00.320]  - Number of conditions: 88
[18:04:00.321] signalConditions() ... done
[18:04:00.321] Future state: ‘finished’
[18:04:00.321] result() for MulticoreFuture ...
[18:04:00.321] result() for MulticoreFuture ... done
[18:04:00.322] signalConditions() ...
[18:04:00.322]  - include = ‘condition’
[18:04:00.322]  - exclude = ‘immediateCondition’
[18:04:00.322]  - resignal = TRUE
[18:04:00.322]  - Number of conditions: 88
[18:04:00.323]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.240] getGlobalsAndPackages() ...
[18:04:00.323]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.241] Searching for globals...
[18:04:00.323]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.243] 
[18:04:00.324]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.243] Searching for globals ... DONE
[18:04:00.324]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.244] - globals: [0] <none>
[18:04:00.325]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.244] getGlobalsAndPackages() ... DONE
[18:04:00.325]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.246] run() for ‘Future’ ...
[18:04:00.325]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.247] - state: ‘created’
[18:04:00.326]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.247] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:00.326]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.248] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:00.326]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:00.327]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.249]   - Field: ‘label’
[18:04:00.327]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.250]   - Field: ‘local’
[18:04:00.327]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.250]   - Field: ‘owner’
[18:04:00.328]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.251]   - Field: ‘envir’
[18:04:00.328]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.251]   - Field: ‘packages’
[18:04:00.328]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.252]   - Field: ‘gc’
[18:04:00.329]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.252]   - Field: ‘conditions’
[18:04:00.329]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.252]   - Field: ‘expr’
[18:04:00.329]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.253]   - Field: ‘uuid’
[18:04:00.330]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.253]   - Field: ‘seed’
[18:04:00.330]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.254]   - Field: ‘version’
[18:04:00.330]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.254]   - Field: ‘result’
[18:04:00.331]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.255]   - Field: ‘asynchronous’
[18:04:00.331]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.255]   - Field: ‘calls’
[18:04:00.331]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.255]   - Field: ‘globals’
[18:04:00.332]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.256]   - Field: ‘stdout’
[18:04:00.332]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.256]   - Field: ‘earlySignal’
[18:04:00.332]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.256]   - Field: ‘lazy’
[18:04:00.333]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.257]   - Field: ‘state’
[18:04:00.333]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:00.333]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.258] - Launch lazy future ...
[18:04:00.334]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.258] Packages needed by the future expression (n = 0): <none>
[18:04:00.334]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.259] Packages needed by future strategies (n = 0): <none>
[18:04:00.334]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.260] {
[18:04:00.260]     {
[18:04:00.260]         {
[18:04:00.260]             ...future.startTime <- base::Sys.time()
[18:04:00.260]             {
[18:04:00.260]                 {
[18:04:00.260]                   {
[18:04:00.260]                     base::local({
[18:04:00.260]                       has_future <- base::requireNamespace("future", 
[18:04:00.260]                         quietly = TRUE)
[18:04:00.260]                       if (has_future) {
[18:04:00.260]                         ns <- base::getNamespace("future")
[18:04:00.260]                         version <- ns[[".package"]][["version"]]
[18:04:00.260]                         if (is.null(version)) 
[18:04:00.260]                           version <- utils::packageVersion("future")
[18:04:00.260]                       }
[18:04:00.260]                       else {
[18:04:00.260]                         version <- NULL
[18:04:00.260]                       }
[18:04:00.260]                       if (!has_future || version < "1.8.0") {
[18:04:00.260]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:00.260]                           "", base::R.version$version.string), 
[18:04:00.260]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:00.260]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:00.260]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:00.260]                             "release", "version")], collapse = " "), 
[18:04:00.260]                           hostname = base::Sys.info()[["nodename"]])
[18:04:00.260]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:00.260]                           info)
[18:04:00.260]                         info <- base::paste(info, collapse = "; ")
[18:04:00.260]                         if (!has_future) {
[18:04:00.260]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:00.260]                             info)
[18:04:00.260]                         }
[18:04:00.260]                         else {
[18:04:00.260]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:00.260]                             info, version)
[18:04:00.260]                         }
[18:04:00.260]                         base::stop(msg)
[18:04:00.260]                       }
[18:04:00.260]                     })
[18:04:00.260]                   }
[18:04:00.260]                   ...future.strategy.old <- future::plan("list")
[18:04:00.260]                   options(future.plan = NULL)
[18:04:00.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:00.260]                 }
[18:04:00.260]                 ...future.workdir <- getwd()
[18:04:00.260]             }
[18:04:00.260]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:00.260]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:00.260]         }
[18:04:00.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:00.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:00.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:00.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:00.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:00.260]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:00.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:00.260]             base::names(...future.oldOptions))
[18:04:00.260]     }
[18:04:00.260]     if (FALSE) {
[18:04:00.260]     }
[18:04:00.260]     else {
[18:04:00.260]         if (TRUE) {
[18:04:00.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:00.260]                 open = "w")
[18:04:00.260]         }
[18:04:00.260]         else {
[18:04:00.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:00.260]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:00.260]         }
[18:04:00.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:00.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:00.260]             base::sink(type = "output", split = FALSE)
[18:04:00.260]             base::close(...future.stdout)
[18:04:00.260]         }, add = TRUE)
[18:04:00.260]     }
[18:04:00.260]     ...future.frame <- base::sys.nframe()
[18:04:00.260]     ...future.conditions <- base::list()
[18:04:00.260]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:00.260]     if (FALSE) {
[18:04:00.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:00.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:00.260]     }
[18:04:00.260]     ...future.result <- base::tryCatch({
[18:04:00.260]         base::withCallingHandlers({
[18:04:00.260]             ...future.value <- base::withVisible(base::local(2))
[18:04:00.260]             future::FutureResult(value = ...future.value$value, 
[18:04:00.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.260]                   ...future.rng), globalenv = if (FALSE) 
[18:04:00.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:00.260]                     ...future.globalenv.names))
[18:04:00.260]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:00.260]         }, condition = base::local({
[18:04:00.260]             c <- base::c
[18:04:00.260]             inherits <- base::inherits
[18:04:00.260]             invokeRestart <- base::invokeRestart
[18:04:00.260]             length <- base::length
[18:04:00.260]             list <- base::list
[18:04:00.260]             seq.int <- base::seq.int
[18:04:00.260]             signalCondition <- base::signalCondition
[18:04:00.260]             sys.calls <- base::sys.calls
[18:04:00.260]             `[[` <- base::`[[`
[18:04:00.260]             `+` <- base::`+`
[18:04:00.260]             `<<-` <- base::`<<-`
[18:04:00.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:00.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:00.260]                   3L)]
[18:04:00.260]             }
[18:04:00.260]             function(cond) {
[18:04:00.260]                 is_error <- inherits(cond, "error")
[18:04:00.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:00.260]                   NULL)
[18:04:00.260]                 if (is_error) {
[18:04:00.260]                   sessionInformation <- function() {
[18:04:00.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:00.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:00.260]                       search = base::search(), system = base::Sys.info())
[18:04:00.260]                   }
[18:04:00.260]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:00.260]                     cond$call), session = sessionInformation(), 
[18:04:00.260]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:00.260]                   signalCondition(cond)
[18:04:00.260]                 }
[18:04:00.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:00.260]                 "immediateCondition"))) {
[18:04:00.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:00.260]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:00.260]                   if (TRUE && !signal) {
[18:04:00.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.260]                     {
[18:04:00.260]                       inherits <- base::inherits
[18:04:00.260]                       invokeRestart <- base::invokeRestart
[18:04:00.260]                       is.null <- base::is.null
[18:04:00.260]                       muffled <- FALSE
[18:04:00.260]                       if (inherits(cond, "message")) {
[18:04:00.260]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.260]                         if (muffled) 
[18:04:00.260]                           invokeRestart("muffleMessage")
[18:04:00.260]                       }
[18:04:00.260]                       else if (inherits(cond, "warning")) {
[18:04:00.260]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.260]                         if (muffled) 
[18:04:00.260]                           invokeRestart("muffleWarning")
[18:04:00.260]                       }
[18:04:00.260]                       else if (inherits(cond, "condition")) {
[18:04:00.260]                         if (!is.null(pattern)) {
[18:04:00.260]                           computeRestarts <- base::computeRestarts
[18:04:00.260]                           grepl <- base::grepl
[18:04:00.260]                           restarts <- computeRestarts(cond)
[18:04:00.260]                           for (restart in restarts) {
[18:04:00.260]                             name <- restart$name
[18:04:00.260]                             if (is.null(name)) 
[18:04:00.260]                               next
[18:04:00.260]                             if (!grepl(pattern, name)) 
[18:04:00.260]                               next
[18:04:00.260]                             invokeRestart(restart)
[18:04:00.260]                             muffled <- TRUE
[18:04:00.260]                             break
[18:04:00.260]                           }
[18:04:00.260]                         }
[18:04:00.260]                       }
[18:04:00.260]                       invisible(muffled)
[18:04:00.260]                     }
[18:04:00.260]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.260]                   }
[18:04:00.260]                 }
[18:04:00.260]                 else {
[18:04:00.260]                   if (TRUE) {
[18:04:00.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.260]                     {
[18:04:00.260]                       inherits <- base::inherits
[18:04:00.260]                       invokeRestart <- base::invokeRestart
[18:04:00.260]                       is.null <- base::is.null
[18:04:00.260]                       muffled <- FALSE
[18:04:00.260]                       if (inherits(cond, "message")) {
[18:04:00.260]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.260]                         if (muffled) 
[18:04:00.260]                           invokeRestart("muffleMessage")
[18:04:00.260]                       }
[18:04:00.260]                       else if (inherits(cond, "warning")) {
[18:04:00.260]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.260]                         if (muffled) 
[18:04:00.260]                           invokeRestart("muffleWarning")
[18:04:00.260]                       }
[18:04:00.260]                       else if (inherits(cond, "condition")) {
[18:04:00.260]                         if (!is.null(pattern)) {
[18:04:00.260]                           computeRestarts <- base::computeRestarts
[18:04:00.260]                           grepl <- base::grepl
[18:04:00.260]                           restarts <- computeRestarts(cond)
[18:04:00.260]                           for (restart in restarts) {
[18:04:00.260]                             name <- restart$name
[18:04:00.260]                             if (is.null(name)) 
[18:04:00.260]                               next
[18:04:00.260]                             if (!grepl(pattern, name)) 
[18:04:00.260]                               next
[18:04:00.260]                             invokeRestart(restart)
[18:04:00.260]                             muffled <- TRUE
[18:04:00.260]                             break
[18:04:00.260]                           }
[18:04:00.260]                         }
[18:04:00.260]                       }
[18:04:00.260]                       invisible(muffled)
[18:04:00.260]                     }
[18:04:00.260]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.260]                   }
[18:04:00.260]                 }
[18:04:00.260]             }
[18:04:00.260]         }))
[18:04:00.260]     }, error = function(ex) {
[18:04:00.260]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:00.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.260]                 ...future.rng), started = ...future.startTime, 
[18:04:00.260]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:00.260]             version = "1.8"), class = "FutureResult")
[18:04:00.260]     }, finally = {
[18:04:00.260]         if (!identical(...future.workdir, getwd())) 
[18:04:00.260]             setwd(...future.workdir)
[18:04:00.260]         {
[18:04:00.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:00.260]                 ...future.oldOptions$nwarnings <- NULL
[18:04:00.260]             }
[18:04:00.260]             base::options(...future.oldOptions)
[18:04:00.260]             if (.Platform$OS.type == "windows") {
[18:04:00.260]                 old_names <- names(...future.oldEnvVars)
[18:04:00.260]                 envs <- base::Sys.getenv()
[18:04:00.260]                 names <- names(envs)
[18:04:00.260]                 common <- intersect(names, old_names)
[18:04:00.260]                 added <- setdiff(names, old_names)
[18:04:00.260]                 removed <- setdiff(old_names, names)
[18:04:00.260]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:00.260]                   envs[common]]
[18:04:00.260]                 NAMES <- toupper(changed)
[18:04:00.260]                 args <- list()
[18:04:00.260]                 for (kk in seq_along(NAMES)) {
[18:04:00.260]                   name <- changed[[kk]]
[18:04:00.260]                   NAME <- NAMES[[kk]]
[18:04:00.260]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.260]                     next
[18:04:00.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.260]                 }
[18:04:00.260]                 NAMES <- toupper(added)
[18:04:00.260]                 for (kk in seq_along(NAMES)) {
[18:04:00.260]                   name <- added[[kk]]
[18:04:00.260]                   NAME <- NAMES[[kk]]
[18:04:00.260]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.260]                     next
[18:04:00.260]                   args[[name]] <- ""
[18:04:00.260]                 }
[18:04:00.260]                 NAMES <- toupper(removed)
[18:04:00.260]                 for (kk in seq_along(NAMES)) {
[18:04:00.260]                   name <- removed[[kk]]
[18:04:00.260]                   NAME <- NAMES[[kk]]
[18:04:00.260]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.260]                     next
[18:04:00.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.260]                 }
[18:04:00.260]                 if (length(args) > 0) 
[18:04:00.260]                   base::do.call(base::Sys.setenv, args = args)
[18:04:00.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:00.260]             }
[18:04:00.260]             else {
[18:04:00.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:00.260]             }
[18:04:00.260]             {
[18:04:00.260]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:00.260]                   0L) {
[18:04:00.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:00.260]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:00.260]                   base::options(opts)
[18:04:00.260]                 }
[18:04:00.260]                 {
[18:04:00.260]                   {
[18:04:00.260]                     NULL
[18:04:00.260]                     RNGkind("Mersenne-Twister")
[18:04:00.260]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:00.260]                       inherits = FALSE)
[18:04:00.260]                   }
[18:04:00.260]                   options(future.plan = NULL)
[18:04:00.260]                   if (is.na(NA_character_)) 
[18:04:00.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:00.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:00.260]                     .init = FALSE)
[18:04:00.260]                 }
[18:04:00.260]             }
[18:04:00.260]         }
[18:04:00.260]     })
[18:04:00.260]     if (TRUE) {
[18:04:00.260]         base::sink(type = "output", split = FALSE)
[18:04:00.260]         if (TRUE) {
[18:04:00.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:00.260]         }
[18:04:00.260]         else {
[18:04:00.260]             ...future.result["stdout"] <- base::list(NULL)
[18:04:00.260]         }
[18:04:00.260]         base::close(...future.stdout)
[18:04:00.260]         ...future.stdout <- NULL
[18:04:00.260]     }
[18:04:00.260]     ...future.result$conditions <- ...future.conditions
[18:04:00.260]     ...future.result$finished <- base::Sys.time()
[18:04:00.260]     ...future.result
[18:04:00.260] }
[18:04:00.335]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.266] plan(): Setting new future strategy stack:
[18:04:00.335]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.267] List of future strategies:
[18:04:00.267] 1. sequential:
[18:04:00.267]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.267]    - tweaked: FALSE
[18:04:00.267]    - call: NULL
[18:04:00.336]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.268] plan(): nbrOfWorkers() = 1
[18:04:00.336]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.271] plan(): Setting new future strategy stack:
[18:04:00.336]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.271] List of future strategies:
[18:04:00.271] 1. sequential:
[18:04:00.271]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.271]    - tweaked: FALSE
[18:04:00.271]    - call: NULL
[18:04:00.337]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.273] plan(): nbrOfWorkers() = 1
[18:04:00.337]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.273] SequentialFuture started (and completed)
[18:04:00.337]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.274] - Launch lazy future ... done
[18:04:00.338]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.274] run() for ‘SequentialFuture’ ... done
[18:04:00.338]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.275] getGlobalsAndPackages() ...
[18:04:00.338]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.276] Searching for globals...
[18:04:00.339]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.277] 
[18:04:00.339]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.277] Searching for globals ... DONE
[18:04:00.339]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.278] - globals: [0] <none>
[18:04:00.340]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.278] getGlobalsAndPackages() ... DONE
[18:04:00.340]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.279] run() for ‘Future’ ...
[18:04:00.340]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.279] - state: ‘created’
[18:04:00.341]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.280] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:00.341]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:00.341]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:00.342]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.281]   - Field: ‘label’
[18:04:00.342]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.282]   - Field: ‘local’
[18:04:00.342]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.282]   - Field: ‘owner’
[18:04:00.343]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.283]   - Field: ‘envir’
[18:04:00.343]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.283]   - Field: ‘packages’
[18:04:00.343]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.283]   - Field: ‘gc’
[18:04:00.344]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.284]   - Field: ‘conditions’
[18:04:00.344]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.284]   - Field: ‘expr’
[18:04:00.345]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.284]   - Field: ‘uuid’
[18:04:00.345]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.285]   - Field: ‘seed’
[18:04:00.345]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.285]   - Field: ‘version’
[18:04:00.346]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.286]   - Field: ‘result’
[18:04:00.346]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.286]   - Field: ‘asynchronous’
[18:04:00.346]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.286]   - Field: ‘calls’
[18:04:00.347]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.287]   - Field: ‘globals’
[18:04:00.347]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.287]   - Field: ‘stdout’
[18:04:00.347]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.288]   - Field: ‘earlySignal’
[18:04:00.348]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.288]   - Field: ‘lazy’
[18:04:00.348]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.288]   - Field: ‘state’
[18:04:00.348]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:00.349]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.289] - Launch lazy future ...
[18:04:00.349]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.290] Packages needed by the future expression (n = 0): <none>
[18:04:00.349]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.290] Packages needed by future strategies (n = 0): <none>
[18:04:00.350]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.292] {
[18:04:00.292]     {
[18:04:00.292]         {
[18:04:00.292]             ...future.startTime <- base::Sys.time()
[18:04:00.292]             {
[18:04:00.292]                 {
[18:04:00.292]                   {
[18:04:00.292]                     base::local({
[18:04:00.292]                       has_future <- base::requireNamespace("future", 
[18:04:00.292]                         quietly = TRUE)
[18:04:00.292]                       if (has_future) {
[18:04:00.292]                         ns <- base::getNamespace("future")
[18:04:00.292]                         version <- ns[[".package"]][["version"]]
[18:04:00.292]                         if (is.null(version)) 
[18:04:00.292]                           version <- utils::packageVersion("future")
[18:04:00.292]                       }
[18:04:00.292]                       else {
[18:04:00.292]                         version <- NULL
[18:04:00.292]                       }
[18:04:00.292]                       if (!has_future || version < "1.8.0") {
[18:04:00.292]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:00.292]                           "", base::R.version$version.string), 
[18:04:00.292]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:00.292]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:00.292]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:00.292]                             "release", "version")], collapse = " "), 
[18:04:00.292]                           hostname = base::Sys.info()[["nodename"]])
[18:04:00.292]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:00.292]                           info)
[18:04:00.292]                         info <- base::paste(info, collapse = "; ")
[18:04:00.292]                         if (!has_future) {
[18:04:00.292]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:00.292]                             info)
[18:04:00.292]                         }
[18:04:00.292]                         else {
[18:04:00.292]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:00.292]                             info, version)
[18:04:00.292]                         }
[18:04:00.292]                         base::stop(msg)
[18:04:00.292]                       }
[18:04:00.292]                     })
[18:04:00.292]                   }
[18:04:00.292]                   ...future.strategy.old <- future::plan("list")
[18:04:00.292]                   options(future.plan = NULL)
[18:04:00.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:00.292]                 }
[18:04:00.292]                 ...future.workdir <- getwd()
[18:04:00.292]             }
[18:04:00.292]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:00.292]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:00.292]         }
[18:04:00.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:00.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:00.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:00.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:00.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:00.292]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:00.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:00.292]             base::names(...future.oldOptions))
[18:04:00.292]     }
[18:04:00.292]     if (FALSE) {
[18:04:00.292]     }
[18:04:00.292]     else {
[18:04:00.292]         if (TRUE) {
[18:04:00.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:00.292]                 open = "w")
[18:04:00.292]         }
[18:04:00.292]         else {
[18:04:00.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:00.292]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:00.292]         }
[18:04:00.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:00.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:00.292]             base::sink(type = "output", split = FALSE)
[18:04:00.292]             base::close(...future.stdout)
[18:04:00.292]         }, add = TRUE)
[18:04:00.292]     }
[18:04:00.292]     ...future.frame <- base::sys.nframe()
[18:04:00.292]     ...future.conditions <- base::list()
[18:04:00.292]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:00.292]     if (FALSE) {
[18:04:00.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:00.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:00.292]     }
[18:04:00.292]     ...future.result <- base::tryCatch({
[18:04:00.292]         base::withCallingHandlers({
[18:04:00.292]             ...future.value <- base::withVisible(base::local(4))
[18:04:00.292]             future::FutureResult(value = ...future.value$value, 
[18:04:00.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.292]                   ...future.rng), globalenv = if (FALSE) 
[18:04:00.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:00.292]                     ...future.globalenv.names))
[18:04:00.292]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:00.292]         }, condition = base::local({
[18:04:00.292]             c <- base::c
[18:04:00.292]             inherits <- base::inherits
[18:04:00.292]             invokeRestart <- base::invokeRestart
[18:04:00.292]             length <- base::length
[18:04:00.292]             list <- base::list
[18:04:00.292]             seq.int <- base::seq.int
[18:04:00.292]             signalCondition <- base::signalCondition
[18:04:00.292]             sys.calls <- base::sys.calls
[18:04:00.292]             `[[` <- base::`[[`
[18:04:00.292]             `+` <- base::`+`
[18:04:00.292]             `<<-` <- base::`<<-`
[18:04:00.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:00.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:00.292]                   3L)]
[18:04:00.292]             }
[18:04:00.292]             function(cond) {
[18:04:00.292]                 is_error <- inherits(cond, "error")
[18:04:00.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:00.292]                   NULL)
[18:04:00.292]                 if (is_error) {
[18:04:00.292]                   sessionInformation <- function() {
[18:04:00.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:00.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:00.292]                       search = base::search(), system = base::Sys.info())
[18:04:00.292]                   }
[18:04:00.292]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:00.292]                     cond$call), session = sessionInformation(), 
[18:04:00.292]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:00.292]                   signalCondition(cond)
[18:04:00.292]                 }
[18:04:00.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:00.292]                 "immediateCondition"))) {
[18:04:00.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:00.292]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:00.292]                   if (TRUE && !signal) {
[18:04:00.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.292]                     {
[18:04:00.292]                       inherits <- base::inherits
[18:04:00.292]                       invokeRestart <- base::invokeRestart
[18:04:00.292]                       is.null <- base::is.null
[18:04:00.292]                       muffled <- FALSE
[18:04:00.292]                       if (inherits(cond, "message")) {
[18:04:00.292]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.292]                         if (muffled) 
[18:04:00.292]                           invokeRestart("muffleMessage")
[18:04:00.292]                       }
[18:04:00.292]                       else if (inherits(cond, "warning")) {
[18:04:00.292]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.292]                         if (muffled) 
[18:04:00.292]                           invokeRestart("muffleWarning")
[18:04:00.292]                       }
[18:04:00.292]                       else if (inherits(cond, "condition")) {
[18:04:00.292]                         if (!is.null(pattern)) {
[18:04:00.292]                           computeRestarts <- base::computeRestarts
[18:04:00.292]                           grepl <- base::grepl
[18:04:00.292]                           restarts <- computeRestarts(cond)
[18:04:00.292]                           for (restart in restarts) {
[18:04:00.292]                             name <- restart$name
[18:04:00.292]                             if (is.null(name)) 
[18:04:00.292]                               next
[18:04:00.292]                             if (!grepl(pattern, name)) 
[18:04:00.292]                               next
[18:04:00.292]                             invokeRestart(restart)
[18:04:00.292]                             muffled <- TRUE
[18:04:00.292]                             break
[18:04:00.292]                           }
[18:04:00.292]                         }
[18:04:00.292]                       }
[18:04:00.292]                       invisible(muffled)
[18:04:00.292]                     }
[18:04:00.292]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.292]                   }
[18:04:00.292]                 }
[18:04:00.292]                 else {
[18:04:00.292]                   if (TRUE) {
[18:04:00.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.292]                     {
[18:04:00.292]                       inherits <- base::inherits
[18:04:00.292]                       invokeRestart <- base::invokeRestart
[18:04:00.292]                       is.null <- base::is.null
[18:04:00.292]                       muffled <- FALSE
[18:04:00.292]                       if (inherits(cond, "message")) {
[18:04:00.292]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.292]                         if (muffled) 
[18:04:00.292]                           invokeRestart("muffleMessage")
[18:04:00.292]                       }
[18:04:00.292]                       else if (inherits(cond, "warning")) {
[18:04:00.292]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.292]                         if (muffled) 
[18:04:00.292]                           invokeRestart("muffleWarning")
[18:04:00.292]                       }
[18:04:00.292]                       else if (inherits(cond, "condition")) {
[18:04:00.292]                         if (!is.null(pattern)) {
[18:04:00.292]                           computeRestarts <- base::computeRestarts
[18:04:00.292]                           grepl <- base::grepl
[18:04:00.292]                           restarts <- computeRestarts(cond)
[18:04:00.292]                           for (restart in restarts) {
[18:04:00.292]                             name <- restart$name
[18:04:00.292]                             if (is.null(name)) 
[18:04:00.292]                               next
[18:04:00.292]                             if (!grepl(pattern, name)) 
[18:04:00.292]                               next
[18:04:00.292]                             invokeRestart(restart)
[18:04:00.292]                             muffled <- TRUE
[18:04:00.292]                             break
[18:04:00.292]                           }
[18:04:00.292]                         }
[18:04:00.292]                       }
[18:04:00.292]                       invisible(muffled)
[18:04:00.292]                     }
[18:04:00.292]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.292]                   }
[18:04:00.292]                 }
[18:04:00.292]             }
[18:04:00.292]         }))
[18:04:00.292]     }, error = function(ex) {
[18:04:00.292]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:00.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.292]                 ...future.rng), started = ...future.startTime, 
[18:04:00.292]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:00.292]             version = "1.8"), class = "FutureResult")
[18:04:00.292]     }, finally = {
[18:04:00.292]         if (!identical(...future.workdir, getwd())) 
[18:04:00.292]             setwd(...future.workdir)
[18:04:00.292]         {
[18:04:00.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:00.292]                 ...future.oldOptions$nwarnings <- NULL
[18:04:00.292]             }
[18:04:00.292]             base::options(...future.oldOptions)
[18:04:00.292]             if (.Platform$OS.type == "windows") {
[18:04:00.292]                 old_names <- names(...future.oldEnvVars)
[18:04:00.292]                 envs <- base::Sys.getenv()
[18:04:00.292]                 names <- names(envs)
[18:04:00.292]                 common <- intersect(names, old_names)
[18:04:00.292]                 added <- setdiff(names, old_names)
[18:04:00.292]                 removed <- setdiff(old_names, names)
[18:04:00.292]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:00.292]                   envs[common]]
[18:04:00.292]                 NAMES <- toupper(changed)
[18:04:00.292]                 args <- list()
[18:04:00.292]                 for (kk in seq_along(NAMES)) {
[18:04:00.292]                   name <- changed[[kk]]
[18:04:00.292]                   NAME <- NAMES[[kk]]
[18:04:00.292]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.292]                     next
[18:04:00.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.292]                 }
[18:04:00.292]                 NAMES <- toupper(added)
[18:04:00.292]                 for (kk in seq_along(NAMES)) {
[18:04:00.292]                   name <- added[[kk]]
[18:04:00.292]                   NAME <- NAMES[[kk]]
[18:04:00.292]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.292]                     next
[18:04:00.292]                   args[[name]] <- ""
[18:04:00.292]                 }
[18:04:00.292]                 NAMES <- toupper(removed)
[18:04:00.292]                 for (kk in seq_along(NAMES)) {
[18:04:00.292]                   name <- removed[[kk]]
[18:04:00.292]                   NAME <- NAMES[[kk]]
[18:04:00.292]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.292]                     next
[18:04:00.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.292]                 }
[18:04:00.292]                 if (length(args) > 0) 
[18:04:00.292]                   base::do.call(base::Sys.setenv, args = args)
[18:04:00.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:00.292]             }
[18:04:00.292]             else {
[18:04:00.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:00.292]             }
[18:04:00.292]             {
[18:04:00.292]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:00.292]                   0L) {
[18:04:00.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:00.292]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:00.292]                   base::options(opts)
[18:04:00.292]                 }
[18:04:00.292]                 {
[18:04:00.292]                   {
[18:04:00.292]                     NULL
[18:04:00.292]                     RNGkind("Mersenne-Twister")
[18:04:00.292]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:00.292]                       inherits = FALSE)
[18:04:00.292]                   }
[18:04:00.292]                   options(future.plan = NULL)
[18:04:00.292]                   if (is.na(NA_character_)) 
[18:04:00.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:00.292]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:00.292]                     .init = FALSE)
[18:04:00.292]                 }
[18:04:00.292]             }
[18:04:00.292]         }
[18:04:00.292]     })
[18:04:00.292]     if (TRUE) {
[18:04:00.292]         base::sink(type = "output", split = FALSE)
[18:04:00.292]         if (TRUE) {
[18:04:00.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:00.292]         }
[18:04:00.292]         else {
[18:04:00.292]             ...future.result["stdout"] <- base::list(NULL)
[18:04:00.292]         }
[18:04:00.292]         base::close(...future.stdout)
[18:04:00.292]         ...future.stdout <- NULL
[18:04:00.292]     }
[18:04:00.292]     ...future.result$conditions <- ...future.conditions
[18:04:00.292]     ...future.result$finished <- base::Sys.time()
[18:04:00.292]     ...future.result
[18:04:00.292] }
[18:04:00.350]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.297] plan(): Setting new future strategy stack:
[18:04:00.350]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.297] List of future strategies:
[18:04:00.297] 1. sequential:
[18:04:00.297]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.297]    - tweaked: FALSE
[18:04:00.297]    - call: NULL
[18:04:00.351]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.298] plan(): nbrOfWorkers() = 1
[18:04:00.351]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.300] plan(): Setting new future strategy stack:
[18:04:00.351]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.301] List of future strategies:
[18:04:00.301] 1. sequential:
[18:04:00.301]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.301]    - tweaked: FALSE
[18:04:00.301]    - call: NULL
[18:04:00.352]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.302] plan(): nbrOfWorkers() = 1
[18:04:00.352]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.303] SequentialFuture started (and completed)
[18:04:00.352]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.303] - Launch lazy future ... done
[18:04:00.353]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:00.303] run() for ‘SequentialFuture’ ... done
[18:04:00.353] signalConditions() ... done
a = 10
[18:04:00.354] getGlobalsAndPackages() ...
[18:04:00.354] Searching for globals...
[18:04:00.356] - globals found: [3] ‘{’, ‘+’, ‘a’
[18:04:00.356] Searching for globals ... DONE
[18:04:00.357] Resolving globals: FALSE
[18:04:00.357] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:00.358] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:04:00.359] - globals: [1] ‘a’
[18:04:00.359] 
[18:04:00.359] getGlobalsAndPackages() ... DONE
[18:04:00.360] run() for ‘Future’ ...
[18:04:00.360] - state: ‘created’
[18:04:00.360] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:00.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:00.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:00.372]   - Field: ‘label’
[18:04:00.372]   - Field: ‘local’
[18:04:00.372]   - Field: ‘owner’
[18:04:00.372]   - Field: ‘envir’
[18:04:00.373]   - Field: ‘workers’
[18:04:00.373]   - Field: ‘packages’
[18:04:00.373]   - Field: ‘gc’
[18:04:00.373]   - Field: ‘job’
[18:04:00.374]   - Field: ‘conditions’
[18:04:00.374]   - Field: ‘expr’
[18:04:00.374]   - Field: ‘uuid’
[18:04:00.374]   - Field: ‘seed’
[18:04:00.374]   - Field: ‘version’
[18:04:00.375]   - Field: ‘result’
[18:04:00.375]   - Field: ‘asynchronous’
[18:04:00.375]   - Field: ‘calls’
[18:04:00.375]   - Field: ‘globals’
[18:04:00.375]   - Field: ‘stdout’
[18:04:00.376]   - Field: ‘earlySignal’
[18:04:00.376]   - Field: ‘lazy’
[18:04:00.376]   - Field: ‘state’
[18:04:00.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:00.376] - Launch lazy future ...
[18:04:00.377] Packages needed by the future expression (n = 0): <none>
[18:04:00.377] Packages needed by future strategies (n = 0): <none>
[18:04:00.378] {
[18:04:00.378]     {
[18:04:00.378]         {
[18:04:00.378]             ...future.startTime <- base::Sys.time()
[18:04:00.378]             {
[18:04:00.378]                 {
[18:04:00.378]                   {
[18:04:00.378]                     {
[18:04:00.378]                       base::local({
[18:04:00.378]                         has_future <- base::requireNamespace("future", 
[18:04:00.378]                           quietly = TRUE)
[18:04:00.378]                         if (has_future) {
[18:04:00.378]                           ns <- base::getNamespace("future")
[18:04:00.378]                           version <- ns[[".package"]][["version"]]
[18:04:00.378]                           if (is.null(version)) 
[18:04:00.378]                             version <- utils::packageVersion("future")
[18:04:00.378]                         }
[18:04:00.378]                         else {
[18:04:00.378]                           version <- NULL
[18:04:00.378]                         }
[18:04:00.378]                         if (!has_future || version < "1.8.0") {
[18:04:00.378]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:00.378]                             "", base::R.version$version.string), 
[18:04:00.378]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:00.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:00.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:00.378]                               "release", "version")], collapse = " "), 
[18:04:00.378]                             hostname = base::Sys.info()[["nodename"]])
[18:04:00.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:00.378]                             info)
[18:04:00.378]                           info <- base::paste(info, collapse = "; ")
[18:04:00.378]                           if (!has_future) {
[18:04:00.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:00.378]                               info)
[18:04:00.378]                           }
[18:04:00.378]                           else {
[18:04:00.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:00.378]                               info, version)
[18:04:00.378]                           }
[18:04:00.378]                           base::stop(msg)
[18:04:00.378]                         }
[18:04:00.378]                       })
[18:04:00.378]                     }
[18:04:00.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:00.378]                     base::options(mc.cores = 1L)
[18:04:00.378]                   }
[18:04:00.378]                   ...future.strategy.old <- future::plan("list")
[18:04:00.378]                   options(future.plan = NULL)
[18:04:00.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:00.378]                 }
[18:04:00.378]                 ...future.workdir <- getwd()
[18:04:00.378]             }
[18:04:00.378]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:00.378]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:00.378]         }
[18:04:00.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:00.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:00.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:00.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:00.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:00.378]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:00.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:00.378]             base::names(...future.oldOptions))
[18:04:00.378]     }
[18:04:00.378]     if (FALSE) {
[18:04:00.378]     }
[18:04:00.378]     else {
[18:04:00.378]         if (TRUE) {
[18:04:00.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:00.378]                 open = "w")
[18:04:00.378]         }
[18:04:00.378]         else {
[18:04:00.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:00.378]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:00.378]         }
[18:04:00.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:00.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:00.378]             base::sink(type = "output", split = FALSE)
[18:04:00.378]             base::close(...future.stdout)
[18:04:00.378]         }, add = TRUE)
[18:04:00.378]     }
[18:04:00.378]     ...future.frame <- base::sys.nframe()
[18:04:00.378]     ...future.conditions <- base::list()
[18:04:00.378]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:00.378]     if (FALSE) {
[18:04:00.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:00.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:00.378]     }
[18:04:00.378]     ...future.result <- base::tryCatch({
[18:04:00.378]         base::withCallingHandlers({
[18:04:00.378]             ...future.value <- base::withVisible(base::local({
[18:04:00.378]                 withCallingHandlers({
[18:04:00.378]                   {
[18:04:00.378]                     a + 1
[18:04:00.378]                   }
[18:04:00.378]                 }, immediateCondition = function(cond) {
[18:04:00.378]                   save_rds <- function (object, pathname, ...) 
[18:04:00.378]                   {
[18:04:00.378]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:00.378]                     if (file_test("-f", pathname_tmp)) {
[18:04:00.378]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.378]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:00.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.378]                         fi_tmp[["mtime"]])
[18:04:00.378]                     }
[18:04:00.378]                     tryCatch({
[18:04:00.378]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:00.378]                     }, error = function(ex) {
[18:04:00.378]                       msg <- conditionMessage(ex)
[18:04:00.378]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.378]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:00.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.378]                         fi_tmp[["mtime"]], msg)
[18:04:00.378]                       ex$message <- msg
[18:04:00.378]                       stop(ex)
[18:04:00.378]                     })
[18:04:00.378]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:00.378]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:00.378]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:00.378]                       fi_tmp <- file.info(pathname_tmp)
[18:04:00.378]                       fi <- file.info(pathname)
[18:04:00.378]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:00.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:00.378]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:00.378]                         fi[["size"]], fi[["mtime"]])
[18:04:00.378]                       stop(msg)
[18:04:00.378]                     }
[18:04:00.378]                     invisible(pathname)
[18:04:00.378]                   }
[18:04:00.378]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:00.378]                     rootPath = tempdir()) 
[18:04:00.378]                   {
[18:04:00.378]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:00.378]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:00.378]                       tmpdir = path, fileext = ".rds")
[18:04:00.378]                     save_rds(obj, file)
[18:04:00.378]                   }
[18:04:00.378]                   saveImmediateCondition(cond, path = "/tmp/RtmpNSFsmZ/.future/immediateConditions")
[18:04:00.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.378]                   {
[18:04:00.378]                     inherits <- base::inherits
[18:04:00.378]                     invokeRestart <- base::invokeRestart
[18:04:00.378]                     is.null <- base::is.null
[18:04:00.378]                     muffled <- FALSE
[18:04:00.378]                     if (inherits(cond, "message")) {
[18:04:00.378]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:00.378]                       if (muffled) 
[18:04:00.378]                         invokeRestart("muffleMessage")
[18:04:00.378]                     }
[18:04:00.378]                     else if (inherits(cond, "warning")) {
[18:04:00.378]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:00.378]                       if (muffled) 
[18:04:00.378]                         invokeRestart("muffleWarning")
[18:04:00.378]                     }
[18:04:00.378]                     else if (inherits(cond, "condition")) {
[18:04:00.378]                       if (!is.null(pattern)) {
[18:04:00.378]                         computeRestarts <- base::computeRestarts
[18:04:00.378]                         grepl <- base::grepl
[18:04:00.378]                         restarts <- computeRestarts(cond)
[18:04:00.378]                         for (restart in restarts) {
[18:04:00.378]                           name <- restart$name
[18:04:00.378]                           if (is.null(name)) 
[18:04:00.378]                             next
[18:04:00.378]                           if (!grepl(pattern, name)) 
[18:04:00.378]                             next
[18:04:00.378]                           invokeRestart(restart)
[18:04:00.378]                           muffled <- TRUE
[18:04:00.378]                           break
[18:04:00.378]                         }
[18:04:00.378]                       }
[18:04:00.378]                     }
[18:04:00.378]                     invisible(muffled)
[18:04:00.378]                   }
[18:04:00.378]                   muffleCondition(cond)
[18:04:00.378]                 })
[18:04:00.378]             }))
[18:04:00.378]             future::FutureResult(value = ...future.value$value, 
[18:04:00.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.378]                   ...future.rng), globalenv = if (FALSE) 
[18:04:00.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:00.378]                     ...future.globalenv.names))
[18:04:00.378]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:00.378]         }, condition = base::local({
[18:04:00.378]             c <- base::c
[18:04:00.378]             inherits <- base::inherits
[18:04:00.378]             invokeRestart <- base::invokeRestart
[18:04:00.378]             length <- base::length
[18:04:00.378]             list <- base::list
[18:04:00.378]             seq.int <- base::seq.int
[18:04:00.378]             signalCondition <- base::signalCondition
[18:04:00.378]             sys.calls <- base::sys.calls
[18:04:00.378]             `[[` <- base::`[[`
[18:04:00.378]             `+` <- base::`+`
[18:04:00.378]             `<<-` <- base::`<<-`
[18:04:00.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:00.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:00.378]                   3L)]
[18:04:00.378]             }
[18:04:00.378]             function(cond) {
[18:04:00.378]                 is_error <- inherits(cond, "error")
[18:04:00.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:00.378]                   NULL)
[18:04:00.378]                 if (is_error) {
[18:04:00.378]                   sessionInformation <- function() {
[18:04:00.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:00.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:00.378]                       search = base::search(), system = base::Sys.info())
[18:04:00.378]                   }
[18:04:00.378]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:00.378]                     cond$call), session = sessionInformation(), 
[18:04:00.378]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:00.378]                   signalCondition(cond)
[18:04:00.378]                 }
[18:04:00.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:00.378]                 "immediateCondition"))) {
[18:04:00.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:00.378]                   ...future.conditions[[length(...future.conditions) + 
[18:04:00.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:00.378]                   if (TRUE && !signal) {
[18:04:00.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.378]                     {
[18:04:00.378]                       inherits <- base::inherits
[18:04:00.378]                       invokeRestart <- base::invokeRestart
[18:04:00.378]                       is.null <- base::is.null
[18:04:00.378]                       muffled <- FALSE
[18:04:00.378]                       if (inherits(cond, "message")) {
[18:04:00.378]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.378]                         if (muffled) 
[18:04:00.378]                           invokeRestart("muffleMessage")
[18:04:00.378]                       }
[18:04:00.378]                       else if (inherits(cond, "warning")) {
[18:04:00.378]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.378]                         if (muffled) 
[18:04:00.378]                           invokeRestart("muffleWarning")
[18:04:00.378]                       }
[18:04:00.378]                       else if (inherits(cond, "condition")) {
[18:04:00.378]                         if (!is.null(pattern)) {
[18:04:00.378]                           computeRestarts <- base::computeRestarts
[18:04:00.378]                           grepl <- base::grepl
[18:04:00.378]                           restarts <- computeRestarts(cond)
[18:04:00.378]                           for (restart in restarts) {
[18:04:00.378]                             name <- restart$name
[18:04:00.378]                             if (is.null(name)) 
[18:04:00.378]                               next
[18:04:00.378]                             if (!grepl(pattern, name)) 
[18:04:00.378]                               next
[18:04:00.378]                             invokeRestart(restart)
[18:04:00.378]                             muffled <- TRUE
[18:04:00.378]                             break
[18:04:00.378]                           }
[18:04:00.378]                         }
[18:04:00.378]                       }
[18:04:00.378]                       invisible(muffled)
[18:04:00.378]                     }
[18:04:00.378]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.378]                   }
[18:04:00.378]                 }
[18:04:00.378]                 else {
[18:04:00.378]                   if (TRUE) {
[18:04:00.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:00.378]                     {
[18:04:00.378]                       inherits <- base::inherits
[18:04:00.378]                       invokeRestart <- base::invokeRestart
[18:04:00.378]                       is.null <- base::is.null
[18:04:00.378]                       muffled <- FALSE
[18:04:00.378]                       if (inherits(cond, "message")) {
[18:04:00.378]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:00.378]                         if (muffled) 
[18:04:00.378]                           invokeRestart("muffleMessage")
[18:04:00.378]                       }
[18:04:00.378]                       else if (inherits(cond, "warning")) {
[18:04:00.378]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:00.378]                         if (muffled) 
[18:04:00.378]                           invokeRestart("muffleWarning")
[18:04:00.378]                       }
[18:04:00.378]                       else if (inherits(cond, "condition")) {
[18:04:00.378]                         if (!is.null(pattern)) {
[18:04:00.378]                           computeRestarts <- base::computeRestarts
[18:04:00.378]                           grepl <- base::grepl
[18:04:00.378]                           restarts <- computeRestarts(cond)
[18:04:00.378]                           for (restart in restarts) {
[18:04:00.378]                             name <- restart$name
[18:04:00.378]                             if (is.null(name)) 
[18:04:00.378]                               next
[18:04:00.378]                             if (!grepl(pattern, name)) 
[18:04:00.378]                               next
[18:04:00.378]                             invokeRestart(restart)
[18:04:00.378]                             muffled <- TRUE
[18:04:00.378]                             break
[18:04:00.378]                           }
[18:04:00.378]                         }
[18:04:00.378]                       }
[18:04:00.378]                       invisible(muffled)
[18:04:00.378]                     }
[18:04:00.378]                     muffleCondition(cond, pattern = "^muffle")
[18:04:00.378]                   }
[18:04:00.378]                 }
[18:04:00.378]             }
[18:04:00.378]         }))
[18:04:00.378]     }, error = function(ex) {
[18:04:00.378]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:00.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:00.378]                 ...future.rng), started = ...future.startTime, 
[18:04:00.378]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:00.378]             version = "1.8"), class = "FutureResult")
[18:04:00.378]     }, finally = {
[18:04:00.378]         if (!identical(...future.workdir, getwd())) 
[18:04:00.378]             setwd(...future.workdir)
[18:04:00.378]         {
[18:04:00.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:00.378]                 ...future.oldOptions$nwarnings <- NULL
[18:04:00.378]             }
[18:04:00.378]             base::options(...future.oldOptions)
[18:04:00.378]             if (.Platform$OS.type == "windows") {
[18:04:00.378]                 old_names <- names(...future.oldEnvVars)
[18:04:00.378]                 envs <- base::Sys.getenv()
[18:04:00.378]                 names <- names(envs)
[18:04:00.378]                 common <- intersect(names, old_names)
[18:04:00.378]                 added <- setdiff(names, old_names)
[18:04:00.378]                 removed <- setdiff(old_names, names)
[18:04:00.378]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:00.378]                   envs[common]]
[18:04:00.378]                 NAMES <- toupper(changed)
[18:04:00.378]                 args <- list()
[18:04:00.378]                 for (kk in seq_along(NAMES)) {
[18:04:00.378]                   name <- changed[[kk]]
[18:04:00.378]                   NAME <- NAMES[[kk]]
[18:04:00.378]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.378]                     next
[18:04:00.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.378]                 }
[18:04:00.378]                 NAMES <- toupper(added)
[18:04:00.378]                 for (kk in seq_along(NAMES)) {
[18:04:00.378]                   name <- added[[kk]]
[18:04:00.378]                   NAME <- NAMES[[kk]]
[18:04:00.378]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.378]                     next
[18:04:00.378]                   args[[name]] <- ""
[18:04:00.378]                 }
[18:04:00.378]                 NAMES <- toupper(removed)
[18:04:00.378]                 for (kk in seq_along(NAMES)) {
[18:04:00.378]                   name <- removed[[kk]]
[18:04:00.378]                   NAME <- NAMES[[kk]]
[18:04:00.378]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:00.378]                     next
[18:04:00.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:00.378]                 }
[18:04:00.378]                 if (length(args) > 0) 
[18:04:00.378]                   base::do.call(base::Sys.setenv, args = args)
[18:04:00.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:00.378]             }
[18:04:00.378]             else {
[18:04:00.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:00.378]             }
[18:04:00.378]             {
[18:04:00.378]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:00.378]                   0L) {
[18:04:00.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:00.378]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:00.378]                   base::options(opts)
[18:04:00.378]                 }
[18:04:00.378]                 {
[18:04:00.378]                   {
[18:04:00.378]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:00.378]                     NULL
[18:04:00.378]                   }
[18:04:00.378]                   options(future.plan = NULL)
[18:04:00.378]                   if (is.na(NA_character_)) 
[18:04:00.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:00.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:00.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:00.378]                     .init = FALSE)
[18:04:00.378]                 }
[18:04:00.378]             }
[18:04:00.378]         }
[18:04:00.378]     })
[18:04:00.378]     if (TRUE) {
[18:04:00.378]         base::sink(type = "output", split = FALSE)
[18:04:00.378]         if (TRUE) {
[18:04:00.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:00.378]         }
[18:04:00.378]         else {
[18:04:00.378]             ...future.result["stdout"] <- base::list(NULL)
[18:04:00.378]         }
[18:04:00.378]         base::close(...future.stdout)
[18:04:00.378]         ...future.stdout <- NULL
[18:04:00.378]     }
[18:04:00.378]     ...future.result$conditions <- ...future.conditions
[18:04:00.378]     ...future.result$finished <- base::Sys.time()
[18:04:00.378]     ...future.result
[18:04:00.378] }
[18:04:00.382] assign_globals() ...
[18:04:00.382] List of 1
[18:04:00.382]  $ a: num 10
[18:04:00.382]  - attr(*, "where")=List of 1
[18:04:00.382]   ..$ a:<environment: R_EmptyEnv> 
[18:04:00.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:00.382]  - attr(*, "resolved")= logi FALSE
[18:04:00.382]  - attr(*, "total_size")= num 56
[18:04:00.382]  - attr(*, "already-done")= logi TRUE
[18:04:00.388] - copied ‘a’ to environment
[18:04:00.388] assign_globals() ... done
[18:04:00.388] requestCore(): workers = 2
[18:04:00.391] MulticoreFuture started
[18:04:00.392] - Launch lazy future ... done
[18:04:00.393] run() for ‘MulticoreFuture’ ... done
[18:04:00.393] plan(): Setting new future strategy stack:
[18:04:00.394] result() for MulticoreFuture ...
[18:04:00.394] List of future strategies:
[18:04:00.394] 1. sequential:
[18:04:00.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:00.394]    - tweaked: FALSE
[18:04:00.394]    - call: NULL
[18:04:00.396] plan(): nbrOfWorkers() = 1
[18:04:00.400] plan(): Setting new future strategy stack:
[18:04:00.400] List of future strategies:
[18:04:00.400] 1. multicore:
[18:04:00.400]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:00.400]    - tweaked: FALSE
[18:04:00.400]    - call: plan(strategy)
[18:04:00.409] plan(): nbrOfWorkers() = 2
[18:04:00.411] result() for MulticoreFuture ...
[18:04:00.411] result() for MulticoreFuture ... done
[18:04:00.411] result() for MulticoreFuture ... done
[18:04:00.412] result() for MulticoreFuture ...
[18:04:00.412] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[18:04:00.413] plan(): Setting new future strategy stack:
[18:04:00.414] List of future strategies:
[18:04:00.414] 1. multisession:
[18:04:00.414]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:00.414]    - tweaked: FALSE
[18:04:00.414]    - call: plan(strategy)
[18:04:00.415] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:00.415] multisession:
[18:04:00.415] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:00.415] - tweaked: FALSE
[18:04:00.415] - call: plan(strategy)
[18:04:00.426] getGlobalsAndPackages() ...
[18:04:00.426] Not searching for globals
[18:04:00.427] - globals: [0] <none>
[18:04:00.427] getGlobalsAndPackages() ... DONE
[18:04:00.428] [local output] makeClusterPSOCK() ...
[18:04:00.495] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:00.497] [local output] Base port: 11422
[18:04:00.498] [local output] Getting setup options for 2 cluster nodes ...
[18:04:00.498] [local output]  - Node 1 of 2 ...
[18:04:00.499] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:00.500] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNSFsmZ/worker.rank=1.parallelly.parent=321415.4e787459a562b.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpNSFsmZ/worker.rank=1.parallelly.parent=321415.4e787459a562b.pid")'’
[18:04:00.758] - Possible to infer worker's PID: TRUE
[18:04:00.759] [local output] Rscript port: 11422

[18:04:00.759] [local output]  - Node 2 of 2 ...
[18:04:00.760] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:00.761] [local output] Rscript port: 11422

[18:04:00.762] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:00.762] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:00.763] [local output] Setting up PSOCK nodes in parallel
[18:04:00.763] List of 36
[18:04:00.763]  $ worker          : chr "localhost"
[18:04:00.763]   ..- attr(*, "localhost")= logi TRUE
[18:04:00.763]  $ master          : chr "localhost"
[18:04:00.763]  $ port            : int 11422
[18:04:00.763]  $ connectTimeout  : num 120
[18:04:00.763]  $ timeout         : num 2592000
[18:04:00.763]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:00.763]  $ homogeneous     : logi TRUE
[18:04:00.763]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:00.763]  $ rscript_envs    : NULL
[18:04:00.763]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:00.763]  $ rscript_startup : NULL
[18:04:00.763]  $ rscript_sh      : chr "sh"
[18:04:00.763]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:00.763]  $ methods         : logi TRUE
[18:04:00.763]  $ socketOptions   : chr "no-delay"
[18:04:00.763]  $ useXDR          : logi FALSE
[18:04:00.763]  $ outfile         : chr "/dev/null"
[18:04:00.763]  $ renice          : int NA
[18:04:00.763]  $ rshcmd          : NULL
[18:04:00.763]  $ user            : chr(0) 
[18:04:00.763]  $ revtunnel       : logi FALSE
[18:04:00.763]  $ rshlogfile      : NULL
[18:04:00.763]  $ rshopts         : chr(0) 
[18:04:00.763]  $ rank            : int 1
[18:04:00.763]  $ manual          : logi FALSE
[18:04:00.763]  $ dryrun          : logi FALSE
[18:04:00.763]  $ quiet           : logi FALSE
[18:04:00.763]  $ setup_strategy  : chr "parallel"
[18:04:00.763]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:00.763]  $ pidfile         : chr "/tmp/RtmpNSFsmZ/worker.rank=1.parallelly.parent=321415.4e787459a562b.pid"
[18:04:00.763]  $ rshcmd_label    : NULL
[18:04:00.763]  $ rsh_call        : NULL
[18:04:00.763]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:00.763]  $ localMachine    : logi TRUE
[18:04:00.763]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:00.763]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:00.763]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:00.763]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:00.763]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:00.763]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:00.763]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:00.763]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:00.763]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:00.763]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:00.763]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:00.763]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:00.763]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:00.763]  $ arguments       :List of 28
[18:04:00.763]   ..$ worker          : chr "localhost"
[18:04:00.763]   ..$ master          : NULL
[18:04:00.763]   ..$ port            : int 11422
[18:04:00.763]   ..$ connectTimeout  : num 120
[18:04:00.763]   ..$ timeout         : num 2592000
[18:04:00.763]   ..$ rscript         : NULL
[18:04:00.763]   ..$ homogeneous     : NULL
[18:04:00.763]   ..$ rscript_args    : NULL
[18:04:00.763]   ..$ rscript_envs    : NULL
[18:04:00.763]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:00.763]   ..$ rscript_startup : NULL
[18:04:00.763]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:00.763]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:00.763]   ..$ methods         : logi TRUE
[18:04:00.763]   ..$ socketOptions   : chr "no-delay"
[18:04:00.763]   ..$ useXDR          : logi FALSE
[18:04:00.763]   ..$ outfile         : chr "/dev/null"
[18:04:00.763]   ..$ renice          : int NA
[18:04:00.763]   ..$ rshcmd          : NULL
[18:04:00.763]   ..$ user            : NULL
[18:04:00.763]   ..$ revtunnel       : logi NA
[18:04:00.763]   ..$ rshlogfile      : NULL
[18:04:00.763]   ..$ rshopts         : NULL
[18:04:00.763]   ..$ rank            : int 1
[18:04:00.763]   ..$ manual          : logi FALSE
[18:04:00.763]   ..$ dryrun          : logi FALSE
[18:04:00.763]   ..$ quiet           : logi FALSE
[18:04:00.763]   ..$ setup_strategy  : chr "parallel"
[18:04:00.763]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:00.798] [local output] System call to launch all workers:
[18:04:00.798] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNSFsmZ/worker.rank=1.parallelly.parent=321415.4e787459a562b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11422 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:00.798] [local output] Starting PSOCK main server
[18:04:00.806] [local output] Workers launched
[18:04:00.807] [local output] Waiting for workers to connect back
[18:04:00.807]  - [local output] 0 workers out of 2 ready
[18:04:01.162]  - [local output] 0 workers out of 2 ready
[18:04:01.162]  - [local output] 1 workers out of 2 ready
[18:04:01.183]  - [local output] 1 workers out of 2 ready
[18:04:01.184]  - [local output] 2 workers out of 2 ready
[18:04:01.184] [local output] Launching of workers completed
[18:04:01.184] [local output] Collecting session information from workers
[18:04:01.186] [local output]  - Worker #1 of 2
[18:04:01.187] [local output]  - Worker #2 of 2
[18:04:01.188] [local output] makeClusterPSOCK() ... done
[18:04:01.207] Packages needed by the future expression (n = 0): <none>
[18:04:01.208] Packages needed by future strategies (n = 0): <none>
[18:04:01.209] {
[18:04:01.209]     {
[18:04:01.209]         {
[18:04:01.209]             ...future.startTime <- base::Sys.time()
[18:04:01.209]             {
[18:04:01.209]                 {
[18:04:01.209]                   {
[18:04:01.209]                     {
[18:04:01.209]                       base::local({
[18:04:01.209]                         has_future <- base::requireNamespace("future", 
[18:04:01.209]                           quietly = TRUE)
[18:04:01.209]                         if (has_future) {
[18:04:01.209]                           ns <- base::getNamespace("future")
[18:04:01.209]                           version <- ns[[".package"]][["version"]]
[18:04:01.209]                           if (is.null(version)) 
[18:04:01.209]                             version <- utils::packageVersion("future")
[18:04:01.209]                         }
[18:04:01.209]                         else {
[18:04:01.209]                           version <- NULL
[18:04:01.209]                         }
[18:04:01.209]                         if (!has_future || version < "1.8.0") {
[18:04:01.209]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:01.209]                             "", base::R.version$version.string), 
[18:04:01.209]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:01.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:01.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:01.209]                               "release", "version")], collapse = " "), 
[18:04:01.209]                             hostname = base::Sys.info()[["nodename"]])
[18:04:01.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:01.209]                             info)
[18:04:01.209]                           info <- base::paste(info, collapse = "; ")
[18:04:01.209]                           if (!has_future) {
[18:04:01.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:01.209]                               info)
[18:04:01.209]                           }
[18:04:01.209]                           else {
[18:04:01.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:01.209]                               info, version)
[18:04:01.209]                           }
[18:04:01.209]                           base::stop(msg)
[18:04:01.209]                         }
[18:04:01.209]                       })
[18:04:01.209]                     }
[18:04:01.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:01.209]                     base::options(mc.cores = 1L)
[18:04:01.209]                   }
[18:04:01.209]                   ...future.strategy.old <- future::plan("list")
[18:04:01.209]                   options(future.plan = NULL)
[18:04:01.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:01.209]                 }
[18:04:01.209]                 ...future.workdir <- getwd()
[18:04:01.209]             }
[18:04:01.209]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:01.209]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:01.209]         }
[18:04:01.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:01.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:01.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:01.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:01.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:01.209]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:01.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:01.209]             base::names(...future.oldOptions))
[18:04:01.209]     }
[18:04:01.209]     if (FALSE) {
[18:04:01.209]     }
[18:04:01.209]     else {
[18:04:01.209]         if (TRUE) {
[18:04:01.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:01.209]                 open = "w")
[18:04:01.209]         }
[18:04:01.209]         else {
[18:04:01.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:01.209]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:01.209]         }
[18:04:01.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:01.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:01.209]             base::sink(type = "output", split = FALSE)
[18:04:01.209]             base::close(...future.stdout)
[18:04:01.209]         }, add = TRUE)
[18:04:01.209]     }
[18:04:01.209]     ...future.frame <- base::sys.nframe()
[18:04:01.209]     ...future.conditions <- base::list()
[18:04:01.209]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:01.209]     if (FALSE) {
[18:04:01.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:01.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:01.209]     }
[18:04:01.209]     ...future.result <- base::tryCatch({
[18:04:01.209]         base::withCallingHandlers({
[18:04:01.209]             ...future.value <- base::withVisible(base::local({
[18:04:01.209]                 ...future.makeSendCondition <- base::local({
[18:04:01.209]                   sendCondition <- NULL
[18:04:01.209]                   function(frame = 1L) {
[18:04:01.209]                     if (is.function(sendCondition)) 
[18:04:01.209]                       return(sendCondition)
[18:04:01.209]                     ns <- getNamespace("parallel")
[18:04:01.209]                     if (exists("sendData", mode = "function", 
[18:04:01.209]                       envir = ns)) {
[18:04:01.209]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:01.209]                         envir = ns)
[18:04:01.209]                       envir <- sys.frame(frame)
[18:04:01.209]                       master <- NULL
[18:04:01.209]                       while (!identical(envir, .GlobalEnv) && 
[18:04:01.209]                         !identical(envir, emptyenv())) {
[18:04:01.209]                         if (exists("master", mode = "list", envir = envir, 
[18:04:01.209]                           inherits = FALSE)) {
[18:04:01.209]                           master <- get("master", mode = "list", 
[18:04:01.209]                             envir = envir, inherits = FALSE)
[18:04:01.209]                           if (inherits(master, c("SOCKnode", 
[18:04:01.209]                             "SOCK0node"))) {
[18:04:01.209]                             sendCondition <<- function(cond) {
[18:04:01.209]                               data <- list(type = "VALUE", value = cond, 
[18:04:01.209]                                 success = TRUE)
[18:04:01.209]                               parallel_sendData(master, data)
[18:04:01.209]                             }
[18:04:01.209]                             return(sendCondition)
[18:04:01.209]                           }
[18:04:01.209]                         }
[18:04:01.209]                         frame <- frame + 1L
[18:04:01.209]                         envir <- sys.frame(frame)
[18:04:01.209]                       }
[18:04:01.209]                     }
[18:04:01.209]                     sendCondition <<- function(cond) NULL
[18:04:01.209]                   }
[18:04:01.209]                 })
[18:04:01.209]                 withCallingHandlers({
[18:04:01.209]                   NA
[18:04:01.209]                 }, immediateCondition = function(cond) {
[18:04:01.209]                   sendCondition <- ...future.makeSendCondition()
[18:04:01.209]                   sendCondition(cond)
[18:04:01.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.209]                   {
[18:04:01.209]                     inherits <- base::inherits
[18:04:01.209]                     invokeRestart <- base::invokeRestart
[18:04:01.209]                     is.null <- base::is.null
[18:04:01.209]                     muffled <- FALSE
[18:04:01.209]                     if (inherits(cond, "message")) {
[18:04:01.209]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:01.209]                       if (muffled) 
[18:04:01.209]                         invokeRestart("muffleMessage")
[18:04:01.209]                     }
[18:04:01.209]                     else if (inherits(cond, "warning")) {
[18:04:01.209]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:01.209]                       if (muffled) 
[18:04:01.209]                         invokeRestart("muffleWarning")
[18:04:01.209]                     }
[18:04:01.209]                     else if (inherits(cond, "condition")) {
[18:04:01.209]                       if (!is.null(pattern)) {
[18:04:01.209]                         computeRestarts <- base::computeRestarts
[18:04:01.209]                         grepl <- base::grepl
[18:04:01.209]                         restarts <- computeRestarts(cond)
[18:04:01.209]                         for (restart in restarts) {
[18:04:01.209]                           name <- restart$name
[18:04:01.209]                           if (is.null(name)) 
[18:04:01.209]                             next
[18:04:01.209]                           if (!grepl(pattern, name)) 
[18:04:01.209]                             next
[18:04:01.209]                           invokeRestart(restart)
[18:04:01.209]                           muffled <- TRUE
[18:04:01.209]                           break
[18:04:01.209]                         }
[18:04:01.209]                       }
[18:04:01.209]                     }
[18:04:01.209]                     invisible(muffled)
[18:04:01.209]                   }
[18:04:01.209]                   muffleCondition(cond)
[18:04:01.209]                 })
[18:04:01.209]             }))
[18:04:01.209]             future::FutureResult(value = ...future.value$value, 
[18:04:01.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.209]                   ...future.rng), globalenv = if (FALSE) 
[18:04:01.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:01.209]                     ...future.globalenv.names))
[18:04:01.209]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:01.209]         }, condition = base::local({
[18:04:01.209]             c <- base::c
[18:04:01.209]             inherits <- base::inherits
[18:04:01.209]             invokeRestart <- base::invokeRestart
[18:04:01.209]             length <- base::length
[18:04:01.209]             list <- base::list
[18:04:01.209]             seq.int <- base::seq.int
[18:04:01.209]             signalCondition <- base::signalCondition
[18:04:01.209]             sys.calls <- base::sys.calls
[18:04:01.209]             `[[` <- base::`[[`
[18:04:01.209]             `+` <- base::`+`
[18:04:01.209]             `<<-` <- base::`<<-`
[18:04:01.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:01.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:01.209]                   3L)]
[18:04:01.209]             }
[18:04:01.209]             function(cond) {
[18:04:01.209]                 is_error <- inherits(cond, "error")
[18:04:01.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:01.209]                   NULL)
[18:04:01.209]                 if (is_error) {
[18:04:01.209]                   sessionInformation <- function() {
[18:04:01.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:01.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:01.209]                       search = base::search(), system = base::Sys.info())
[18:04:01.209]                   }
[18:04:01.209]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:01.209]                     cond$call), session = sessionInformation(), 
[18:04:01.209]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:01.209]                   signalCondition(cond)
[18:04:01.209]                 }
[18:04:01.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:01.209]                 "immediateCondition"))) {
[18:04:01.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:01.209]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:01.209]                   if (TRUE && !signal) {
[18:04:01.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.209]                     {
[18:04:01.209]                       inherits <- base::inherits
[18:04:01.209]                       invokeRestart <- base::invokeRestart
[18:04:01.209]                       is.null <- base::is.null
[18:04:01.209]                       muffled <- FALSE
[18:04:01.209]                       if (inherits(cond, "message")) {
[18:04:01.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.209]                         if (muffled) 
[18:04:01.209]                           invokeRestart("muffleMessage")
[18:04:01.209]                       }
[18:04:01.209]                       else if (inherits(cond, "warning")) {
[18:04:01.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.209]                         if (muffled) 
[18:04:01.209]                           invokeRestart("muffleWarning")
[18:04:01.209]                       }
[18:04:01.209]                       else if (inherits(cond, "condition")) {
[18:04:01.209]                         if (!is.null(pattern)) {
[18:04:01.209]                           computeRestarts <- base::computeRestarts
[18:04:01.209]                           grepl <- base::grepl
[18:04:01.209]                           restarts <- computeRestarts(cond)
[18:04:01.209]                           for (restart in restarts) {
[18:04:01.209]                             name <- restart$name
[18:04:01.209]                             if (is.null(name)) 
[18:04:01.209]                               next
[18:04:01.209]                             if (!grepl(pattern, name)) 
[18:04:01.209]                               next
[18:04:01.209]                             invokeRestart(restart)
[18:04:01.209]                             muffled <- TRUE
[18:04:01.209]                             break
[18:04:01.209]                           }
[18:04:01.209]                         }
[18:04:01.209]                       }
[18:04:01.209]                       invisible(muffled)
[18:04:01.209]                     }
[18:04:01.209]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.209]                   }
[18:04:01.209]                 }
[18:04:01.209]                 else {
[18:04:01.209]                   if (TRUE) {
[18:04:01.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.209]                     {
[18:04:01.209]                       inherits <- base::inherits
[18:04:01.209]                       invokeRestart <- base::invokeRestart
[18:04:01.209]                       is.null <- base::is.null
[18:04:01.209]                       muffled <- FALSE
[18:04:01.209]                       if (inherits(cond, "message")) {
[18:04:01.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.209]                         if (muffled) 
[18:04:01.209]                           invokeRestart("muffleMessage")
[18:04:01.209]                       }
[18:04:01.209]                       else if (inherits(cond, "warning")) {
[18:04:01.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.209]                         if (muffled) 
[18:04:01.209]                           invokeRestart("muffleWarning")
[18:04:01.209]                       }
[18:04:01.209]                       else if (inherits(cond, "condition")) {
[18:04:01.209]                         if (!is.null(pattern)) {
[18:04:01.209]                           computeRestarts <- base::computeRestarts
[18:04:01.209]                           grepl <- base::grepl
[18:04:01.209]                           restarts <- computeRestarts(cond)
[18:04:01.209]                           for (restart in restarts) {
[18:04:01.209]                             name <- restart$name
[18:04:01.209]                             if (is.null(name)) 
[18:04:01.209]                               next
[18:04:01.209]                             if (!grepl(pattern, name)) 
[18:04:01.209]                               next
[18:04:01.209]                             invokeRestart(restart)
[18:04:01.209]                             muffled <- TRUE
[18:04:01.209]                             break
[18:04:01.209]                           }
[18:04:01.209]                         }
[18:04:01.209]                       }
[18:04:01.209]                       invisible(muffled)
[18:04:01.209]                     }
[18:04:01.209]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.209]                   }
[18:04:01.209]                 }
[18:04:01.209]             }
[18:04:01.209]         }))
[18:04:01.209]     }, error = function(ex) {
[18:04:01.209]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:01.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.209]                 ...future.rng), started = ...future.startTime, 
[18:04:01.209]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:01.209]             version = "1.8"), class = "FutureResult")
[18:04:01.209]     }, finally = {
[18:04:01.209]         if (!identical(...future.workdir, getwd())) 
[18:04:01.209]             setwd(...future.workdir)
[18:04:01.209]         {
[18:04:01.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:01.209]                 ...future.oldOptions$nwarnings <- NULL
[18:04:01.209]             }
[18:04:01.209]             base::options(...future.oldOptions)
[18:04:01.209]             if (.Platform$OS.type == "windows") {
[18:04:01.209]                 old_names <- names(...future.oldEnvVars)
[18:04:01.209]                 envs <- base::Sys.getenv()
[18:04:01.209]                 names <- names(envs)
[18:04:01.209]                 common <- intersect(names, old_names)
[18:04:01.209]                 added <- setdiff(names, old_names)
[18:04:01.209]                 removed <- setdiff(old_names, names)
[18:04:01.209]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:01.209]                   envs[common]]
[18:04:01.209]                 NAMES <- toupper(changed)
[18:04:01.209]                 args <- list()
[18:04:01.209]                 for (kk in seq_along(NAMES)) {
[18:04:01.209]                   name <- changed[[kk]]
[18:04:01.209]                   NAME <- NAMES[[kk]]
[18:04:01.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.209]                     next
[18:04:01.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.209]                 }
[18:04:01.209]                 NAMES <- toupper(added)
[18:04:01.209]                 for (kk in seq_along(NAMES)) {
[18:04:01.209]                   name <- added[[kk]]
[18:04:01.209]                   NAME <- NAMES[[kk]]
[18:04:01.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.209]                     next
[18:04:01.209]                   args[[name]] <- ""
[18:04:01.209]                 }
[18:04:01.209]                 NAMES <- toupper(removed)
[18:04:01.209]                 for (kk in seq_along(NAMES)) {
[18:04:01.209]                   name <- removed[[kk]]
[18:04:01.209]                   NAME <- NAMES[[kk]]
[18:04:01.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.209]                     next
[18:04:01.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.209]                 }
[18:04:01.209]                 if (length(args) > 0) 
[18:04:01.209]                   base::do.call(base::Sys.setenv, args = args)
[18:04:01.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:01.209]             }
[18:04:01.209]             else {
[18:04:01.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:01.209]             }
[18:04:01.209]             {
[18:04:01.209]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:01.209]                   0L) {
[18:04:01.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:01.209]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:01.209]                   base::options(opts)
[18:04:01.209]                 }
[18:04:01.209]                 {
[18:04:01.209]                   {
[18:04:01.209]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:01.209]                     NULL
[18:04:01.209]                   }
[18:04:01.209]                   options(future.plan = NULL)
[18:04:01.209]                   if (is.na(NA_character_)) 
[18:04:01.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:01.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:01.209]                     .init = FALSE)
[18:04:01.209]                 }
[18:04:01.209]             }
[18:04:01.209]         }
[18:04:01.209]     })
[18:04:01.209]     if (TRUE) {
[18:04:01.209]         base::sink(type = "output", split = FALSE)
[18:04:01.209]         if (TRUE) {
[18:04:01.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:01.209]         }
[18:04:01.209]         else {
[18:04:01.209]             ...future.result["stdout"] <- base::list(NULL)
[18:04:01.209]         }
[18:04:01.209]         base::close(...future.stdout)
[18:04:01.209]         ...future.stdout <- NULL
[18:04:01.209]     }
[18:04:01.209]     ...future.result$conditions <- ...future.conditions
[18:04:01.209]     ...future.result$finished <- base::Sys.time()
[18:04:01.209]     ...future.result
[18:04:01.209] }
[18:04:01.311] MultisessionFuture started
[18:04:01.313] result() for ClusterFuture ...
[18:04:01.314] receiveMessageFromWorker() for ClusterFuture ...
[18:04:01.315] - Validating connection of MultisessionFuture
[18:04:01.381] - received message: FutureResult
[18:04:01.381] - Received FutureResult
[18:04:01.381] - Erased future from FutureRegistry
[18:04:01.382] result() for ClusterFuture ...
[18:04:01.382] - result already collected: FutureResult
[18:04:01.382] result() for ClusterFuture ... done
[18:04:01.382] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:01.383] result() for ClusterFuture ... done
[18:04:01.383] result() for ClusterFuture ...
[18:04:01.383] - result already collected: FutureResult
[18:04:01.383] result() for ClusterFuture ... done
[18:04:01.384] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:04:01.390] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[18:04:01.391] getGlobalsAndPackages() ...
[18:04:01.391] Searching for globals...
[18:04:01.393] - globals found: [2] ‘{’, ‘<-’
[18:04:01.393] Searching for globals ... DONE
[18:04:01.394] Resolving globals: FALSE
[18:04:01.394] 
[18:04:01.395] 
[18:04:01.395] getGlobalsAndPackages() ... DONE
[18:04:01.395] run() for ‘Future’ ...
[18:04:01.396] - state: ‘created’
[18:04:01.396] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:01.421] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:01.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:01.421]   - Field: ‘node’
[18:04:01.422]   - Field: ‘label’
[18:04:01.422]   - Field: ‘local’
[18:04:01.422]   - Field: ‘owner’
[18:04:01.422]   - Field: ‘envir’
[18:04:01.422]   - Field: ‘workers’
[18:04:01.423]   - Field: ‘packages’
[18:04:01.423]   - Field: ‘gc’
[18:04:01.423]   - Field: ‘conditions’
[18:04:01.423]   - Field: ‘persistent’
[18:04:01.424]   - Field: ‘expr’
[18:04:01.424]   - Field: ‘uuid’
[18:04:01.424]   - Field: ‘seed’
[18:04:01.424]   - Field: ‘version’
[18:04:01.425]   - Field: ‘result’
[18:04:01.425]   - Field: ‘asynchronous’
[18:04:01.425]   - Field: ‘calls’
[18:04:01.425]   - Field: ‘globals’
[18:04:01.425]   - Field: ‘stdout’
[18:04:01.426]   - Field: ‘earlySignal’
[18:04:01.426]   - Field: ‘lazy’
[18:04:01.426]   - Field: ‘state’
[18:04:01.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:01.427] - Launch lazy future ...
[18:04:01.427] Packages needed by the future expression (n = 0): <none>
[18:04:01.428] Packages needed by future strategies (n = 0): <none>
[18:04:01.429] {
[18:04:01.429]     {
[18:04:01.429]         {
[18:04:01.429]             ...future.startTime <- base::Sys.time()
[18:04:01.429]             {
[18:04:01.429]                 {
[18:04:01.429]                   {
[18:04:01.429]                     {
[18:04:01.429]                       base::local({
[18:04:01.429]                         has_future <- base::requireNamespace("future", 
[18:04:01.429]                           quietly = TRUE)
[18:04:01.429]                         if (has_future) {
[18:04:01.429]                           ns <- base::getNamespace("future")
[18:04:01.429]                           version <- ns[[".package"]][["version"]]
[18:04:01.429]                           if (is.null(version)) 
[18:04:01.429]                             version <- utils::packageVersion("future")
[18:04:01.429]                         }
[18:04:01.429]                         else {
[18:04:01.429]                           version <- NULL
[18:04:01.429]                         }
[18:04:01.429]                         if (!has_future || version < "1.8.0") {
[18:04:01.429]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:01.429]                             "", base::R.version$version.string), 
[18:04:01.429]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:01.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:01.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:01.429]                               "release", "version")], collapse = " "), 
[18:04:01.429]                             hostname = base::Sys.info()[["nodename"]])
[18:04:01.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:01.429]                             info)
[18:04:01.429]                           info <- base::paste(info, collapse = "; ")
[18:04:01.429]                           if (!has_future) {
[18:04:01.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:01.429]                               info)
[18:04:01.429]                           }
[18:04:01.429]                           else {
[18:04:01.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:01.429]                               info, version)
[18:04:01.429]                           }
[18:04:01.429]                           base::stop(msg)
[18:04:01.429]                         }
[18:04:01.429]                       })
[18:04:01.429]                     }
[18:04:01.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:01.429]                     base::options(mc.cores = 1L)
[18:04:01.429]                   }
[18:04:01.429]                   ...future.strategy.old <- future::plan("list")
[18:04:01.429]                   options(future.plan = NULL)
[18:04:01.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:01.429]                 }
[18:04:01.429]                 ...future.workdir <- getwd()
[18:04:01.429]             }
[18:04:01.429]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:01.429]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:01.429]         }
[18:04:01.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:01.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:01.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:01.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:01.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:01.429]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:01.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:01.429]             base::names(...future.oldOptions))
[18:04:01.429]     }
[18:04:01.429]     if (FALSE) {
[18:04:01.429]     }
[18:04:01.429]     else {
[18:04:01.429]         if (TRUE) {
[18:04:01.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:01.429]                 open = "w")
[18:04:01.429]         }
[18:04:01.429]         else {
[18:04:01.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:01.429]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:01.429]         }
[18:04:01.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:01.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:01.429]             base::sink(type = "output", split = FALSE)
[18:04:01.429]             base::close(...future.stdout)
[18:04:01.429]         }, add = TRUE)
[18:04:01.429]     }
[18:04:01.429]     ...future.frame <- base::sys.nframe()
[18:04:01.429]     ...future.conditions <- base::list()
[18:04:01.429]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:01.429]     if (FALSE) {
[18:04:01.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:01.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:01.429]     }
[18:04:01.429]     ...future.result <- base::tryCatch({
[18:04:01.429]         base::withCallingHandlers({
[18:04:01.429]             ...future.value <- base::withVisible(base::local({
[18:04:01.429]                 ...future.makeSendCondition <- base::local({
[18:04:01.429]                   sendCondition <- NULL
[18:04:01.429]                   function(frame = 1L) {
[18:04:01.429]                     if (is.function(sendCondition)) 
[18:04:01.429]                       return(sendCondition)
[18:04:01.429]                     ns <- getNamespace("parallel")
[18:04:01.429]                     if (exists("sendData", mode = "function", 
[18:04:01.429]                       envir = ns)) {
[18:04:01.429]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:01.429]                         envir = ns)
[18:04:01.429]                       envir <- sys.frame(frame)
[18:04:01.429]                       master <- NULL
[18:04:01.429]                       while (!identical(envir, .GlobalEnv) && 
[18:04:01.429]                         !identical(envir, emptyenv())) {
[18:04:01.429]                         if (exists("master", mode = "list", envir = envir, 
[18:04:01.429]                           inherits = FALSE)) {
[18:04:01.429]                           master <- get("master", mode = "list", 
[18:04:01.429]                             envir = envir, inherits = FALSE)
[18:04:01.429]                           if (inherits(master, c("SOCKnode", 
[18:04:01.429]                             "SOCK0node"))) {
[18:04:01.429]                             sendCondition <<- function(cond) {
[18:04:01.429]                               data <- list(type = "VALUE", value = cond, 
[18:04:01.429]                                 success = TRUE)
[18:04:01.429]                               parallel_sendData(master, data)
[18:04:01.429]                             }
[18:04:01.429]                             return(sendCondition)
[18:04:01.429]                           }
[18:04:01.429]                         }
[18:04:01.429]                         frame <- frame + 1L
[18:04:01.429]                         envir <- sys.frame(frame)
[18:04:01.429]                       }
[18:04:01.429]                     }
[18:04:01.429]                     sendCondition <<- function(cond) NULL
[18:04:01.429]                   }
[18:04:01.429]                 })
[18:04:01.429]                 withCallingHandlers({
[18:04:01.429]                   {
[18:04:01.429]                     x <- 1
[18:04:01.429]                   }
[18:04:01.429]                 }, immediateCondition = function(cond) {
[18:04:01.429]                   sendCondition <- ...future.makeSendCondition()
[18:04:01.429]                   sendCondition(cond)
[18:04:01.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.429]                   {
[18:04:01.429]                     inherits <- base::inherits
[18:04:01.429]                     invokeRestart <- base::invokeRestart
[18:04:01.429]                     is.null <- base::is.null
[18:04:01.429]                     muffled <- FALSE
[18:04:01.429]                     if (inherits(cond, "message")) {
[18:04:01.429]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:01.429]                       if (muffled) 
[18:04:01.429]                         invokeRestart("muffleMessage")
[18:04:01.429]                     }
[18:04:01.429]                     else if (inherits(cond, "warning")) {
[18:04:01.429]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:01.429]                       if (muffled) 
[18:04:01.429]                         invokeRestart("muffleWarning")
[18:04:01.429]                     }
[18:04:01.429]                     else if (inherits(cond, "condition")) {
[18:04:01.429]                       if (!is.null(pattern)) {
[18:04:01.429]                         computeRestarts <- base::computeRestarts
[18:04:01.429]                         grepl <- base::grepl
[18:04:01.429]                         restarts <- computeRestarts(cond)
[18:04:01.429]                         for (restart in restarts) {
[18:04:01.429]                           name <- restart$name
[18:04:01.429]                           if (is.null(name)) 
[18:04:01.429]                             next
[18:04:01.429]                           if (!grepl(pattern, name)) 
[18:04:01.429]                             next
[18:04:01.429]                           invokeRestart(restart)
[18:04:01.429]                           muffled <- TRUE
[18:04:01.429]                           break
[18:04:01.429]                         }
[18:04:01.429]                       }
[18:04:01.429]                     }
[18:04:01.429]                     invisible(muffled)
[18:04:01.429]                   }
[18:04:01.429]                   muffleCondition(cond)
[18:04:01.429]                 })
[18:04:01.429]             }))
[18:04:01.429]             future::FutureResult(value = ...future.value$value, 
[18:04:01.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.429]                   ...future.rng), globalenv = if (FALSE) 
[18:04:01.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:01.429]                     ...future.globalenv.names))
[18:04:01.429]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:01.429]         }, condition = base::local({
[18:04:01.429]             c <- base::c
[18:04:01.429]             inherits <- base::inherits
[18:04:01.429]             invokeRestart <- base::invokeRestart
[18:04:01.429]             length <- base::length
[18:04:01.429]             list <- base::list
[18:04:01.429]             seq.int <- base::seq.int
[18:04:01.429]             signalCondition <- base::signalCondition
[18:04:01.429]             sys.calls <- base::sys.calls
[18:04:01.429]             `[[` <- base::`[[`
[18:04:01.429]             `+` <- base::`+`
[18:04:01.429]             `<<-` <- base::`<<-`
[18:04:01.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:01.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:01.429]                   3L)]
[18:04:01.429]             }
[18:04:01.429]             function(cond) {
[18:04:01.429]                 is_error <- inherits(cond, "error")
[18:04:01.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:01.429]                   NULL)
[18:04:01.429]                 if (is_error) {
[18:04:01.429]                   sessionInformation <- function() {
[18:04:01.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:01.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:01.429]                       search = base::search(), system = base::Sys.info())
[18:04:01.429]                   }
[18:04:01.429]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:01.429]                     cond$call), session = sessionInformation(), 
[18:04:01.429]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:01.429]                   signalCondition(cond)
[18:04:01.429]                 }
[18:04:01.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:01.429]                 "immediateCondition"))) {
[18:04:01.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:01.429]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:01.429]                   if (TRUE && !signal) {
[18:04:01.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.429]                     {
[18:04:01.429]                       inherits <- base::inherits
[18:04:01.429]                       invokeRestart <- base::invokeRestart
[18:04:01.429]                       is.null <- base::is.null
[18:04:01.429]                       muffled <- FALSE
[18:04:01.429]                       if (inherits(cond, "message")) {
[18:04:01.429]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.429]                         if (muffled) 
[18:04:01.429]                           invokeRestart("muffleMessage")
[18:04:01.429]                       }
[18:04:01.429]                       else if (inherits(cond, "warning")) {
[18:04:01.429]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.429]                         if (muffled) 
[18:04:01.429]                           invokeRestart("muffleWarning")
[18:04:01.429]                       }
[18:04:01.429]                       else if (inherits(cond, "condition")) {
[18:04:01.429]                         if (!is.null(pattern)) {
[18:04:01.429]                           computeRestarts <- base::computeRestarts
[18:04:01.429]                           grepl <- base::grepl
[18:04:01.429]                           restarts <- computeRestarts(cond)
[18:04:01.429]                           for (restart in restarts) {
[18:04:01.429]                             name <- restart$name
[18:04:01.429]                             if (is.null(name)) 
[18:04:01.429]                               next
[18:04:01.429]                             if (!grepl(pattern, name)) 
[18:04:01.429]                               next
[18:04:01.429]                             invokeRestart(restart)
[18:04:01.429]                             muffled <- TRUE
[18:04:01.429]                             break
[18:04:01.429]                           }
[18:04:01.429]                         }
[18:04:01.429]                       }
[18:04:01.429]                       invisible(muffled)
[18:04:01.429]                     }
[18:04:01.429]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.429]                   }
[18:04:01.429]                 }
[18:04:01.429]                 else {
[18:04:01.429]                   if (TRUE) {
[18:04:01.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.429]                     {
[18:04:01.429]                       inherits <- base::inherits
[18:04:01.429]                       invokeRestart <- base::invokeRestart
[18:04:01.429]                       is.null <- base::is.null
[18:04:01.429]                       muffled <- FALSE
[18:04:01.429]                       if (inherits(cond, "message")) {
[18:04:01.429]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.429]                         if (muffled) 
[18:04:01.429]                           invokeRestart("muffleMessage")
[18:04:01.429]                       }
[18:04:01.429]                       else if (inherits(cond, "warning")) {
[18:04:01.429]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.429]                         if (muffled) 
[18:04:01.429]                           invokeRestart("muffleWarning")
[18:04:01.429]                       }
[18:04:01.429]                       else if (inherits(cond, "condition")) {
[18:04:01.429]                         if (!is.null(pattern)) {
[18:04:01.429]                           computeRestarts <- base::computeRestarts
[18:04:01.429]                           grepl <- base::grepl
[18:04:01.429]                           restarts <- computeRestarts(cond)
[18:04:01.429]                           for (restart in restarts) {
[18:04:01.429]                             name <- restart$name
[18:04:01.429]                             if (is.null(name)) 
[18:04:01.429]                               next
[18:04:01.429]                             if (!grepl(pattern, name)) 
[18:04:01.429]                               next
[18:04:01.429]                             invokeRestart(restart)
[18:04:01.429]                             muffled <- TRUE
[18:04:01.429]                             break
[18:04:01.429]                           }
[18:04:01.429]                         }
[18:04:01.429]                       }
[18:04:01.429]                       invisible(muffled)
[18:04:01.429]                     }
[18:04:01.429]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.429]                   }
[18:04:01.429]                 }
[18:04:01.429]             }
[18:04:01.429]         }))
[18:04:01.429]     }, error = function(ex) {
[18:04:01.429]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:01.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.429]                 ...future.rng), started = ...future.startTime, 
[18:04:01.429]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:01.429]             version = "1.8"), class = "FutureResult")
[18:04:01.429]     }, finally = {
[18:04:01.429]         if (!identical(...future.workdir, getwd())) 
[18:04:01.429]             setwd(...future.workdir)
[18:04:01.429]         {
[18:04:01.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:01.429]                 ...future.oldOptions$nwarnings <- NULL
[18:04:01.429]             }
[18:04:01.429]             base::options(...future.oldOptions)
[18:04:01.429]             if (.Platform$OS.type == "windows") {
[18:04:01.429]                 old_names <- names(...future.oldEnvVars)
[18:04:01.429]                 envs <- base::Sys.getenv()
[18:04:01.429]                 names <- names(envs)
[18:04:01.429]                 common <- intersect(names, old_names)
[18:04:01.429]                 added <- setdiff(names, old_names)
[18:04:01.429]                 removed <- setdiff(old_names, names)
[18:04:01.429]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:01.429]                   envs[common]]
[18:04:01.429]                 NAMES <- toupper(changed)
[18:04:01.429]                 args <- list()
[18:04:01.429]                 for (kk in seq_along(NAMES)) {
[18:04:01.429]                   name <- changed[[kk]]
[18:04:01.429]                   NAME <- NAMES[[kk]]
[18:04:01.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.429]                     next
[18:04:01.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.429]                 }
[18:04:01.429]                 NAMES <- toupper(added)
[18:04:01.429]                 for (kk in seq_along(NAMES)) {
[18:04:01.429]                   name <- added[[kk]]
[18:04:01.429]                   NAME <- NAMES[[kk]]
[18:04:01.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.429]                     next
[18:04:01.429]                   args[[name]] <- ""
[18:04:01.429]                 }
[18:04:01.429]                 NAMES <- toupper(removed)
[18:04:01.429]                 for (kk in seq_along(NAMES)) {
[18:04:01.429]                   name <- removed[[kk]]
[18:04:01.429]                   NAME <- NAMES[[kk]]
[18:04:01.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.429]                     next
[18:04:01.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.429]                 }
[18:04:01.429]                 if (length(args) > 0) 
[18:04:01.429]                   base::do.call(base::Sys.setenv, args = args)
[18:04:01.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:01.429]             }
[18:04:01.429]             else {
[18:04:01.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:01.429]             }
[18:04:01.429]             {
[18:04:01.429]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:01.429]                   0L) {
[18:04:01.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:01.429]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:01.429]                   base::options(opts)
[18:04:01.429]                 }
[18:04:01.429]                 {
[18:04:01.429]                   {
[18:04:01.429]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:01.429]                     NULL
[18:04:01.429]                   }
[18:04:01.429]                   options(future.plan = NULL)
[18:04:01.429]                   if (is.na(NA_character_)) 
[18:04:01.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:01.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:01.429]                     .init = FALSE)
[18:04:01.429]                 }
[18:04:01.429]             }
[18:04:01.429]         }
[18:04:01.429]     })
[18:04:01.429]     if (TRUE) {
[18:04:01.429]         base::sink(type = "output", split = FALSE)
[18:04:01.429]         if (TRUE) {
[18:04:01.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:01.429]         }
[18:04:01.429]         else {
[18:04:01.429]             ...future.result["stdout"] <- base::list(NULL)
[18:04:01.429]         }
[18:04:01.429]         base::close(...future.stdout)
[18:04:01.429]         ...future.stdout <- NULL
[18:04:01.429]     }
[18:04:01.429]     ...future.result$conditions <- ...future.conditions
[18:04:01.429]     ...future.result$finished <- base::Sys.time()
[18:04:01.429]     ...future.result
[18:04:01.429] }
[18:04:01.435] MultisessionFuture started
[18:04:01.435] - Launch lazy future ... done
[18:04:01.435] run() for ‘MultisessionFuture’ ... done
[18:04:01.436] result() for ClusterFuture ...
[18:04:01.436] receiveMessageFromWorker() for ClusterFuture ...
[18:04:01.436] - Validating connection of MultisessionFuture
[18:04:01.478] - received message: FutureResult
[18:04:01.478] - Received FutureResult
[18:04:01.479] - Erased future from FutureRegistry
[18:04:01.479] result() for ClusterFuture ...
[18:04:01.479] - result already collected: FutureResult
[18:04:01.480] result() for ClusterFuture ... done
[18:04:01.480] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:01.480] result() for ClusterFuture ... done
[18:04:01.480] result() for ClusterFuture ...
[18:04:01.481] - result already collected: FutureResult
[18:04:01.481] result() for ClusterFuture ... done
** Future evaluation with globals
[18:04:01.482] getGlobalsAndPackages() ...
[18:04:01.482] Searching for globals...
[18:04:01.485] - globals found: [3] ‘{’, ‘<-’, ‘a’
[18:04:01.485] Searching for globals ... DONE
[18:04:01.486] Resolving globals: FALSE
[18:04:01.487] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:01.488] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:04:01.488] - globals: [1] ‘a’
[18:04:01.488] 
[18:04:01.489] getGlobalsAndPackages() ... DONE
[18:04:01.489] run() for ‘Future’ ...
[18:04:01.490] - state: ‘created’
[18:04:01.490] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:01.520] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:01.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:01.521]   - Field: ‘node’
[18:04:01.521]   - Field: ‘label’
[18:04:01.522]   - Field: ‘local’
[18:04:01.522]   - Field: ‘owner’
[18:04:01.522]   - Field: ‘envir’
[18:04:01.522]   - Field: ‘workers’
[18:04:01.522]   - Field: ‘packages’
[18:04:01.523]   - Field: ‘gc’
[18:04:01.523]   - Field: ‘conditions’
[18:04:01.523]   - Field: ‘persistent’
[18:04:01.524]   - Field: ‘expr’
[18:04:01.524]   - Field: ‘uuid’
[18:04:01.524]   - Field: ‘seed’
[18:04:01.525]   - Field: ‘version’
[18:04:01.525]   - Field: ‘result’
[18:04:01.525]   - Field: ‘asynchronous’
[18:04:01.525]   - Field: ‘calls’
[18:04:01.526]   - Field: ‘globals’
[18:04:01.526]   - Field: ‘stdout’
[18:04:01.526]   - Field: ‘earlySignal’
[18:04:01.527]   - Field: ‘lazy’
[18:04:01.527]   - Field: ‘state’
[18:04:01.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:01.528] - Launch lazy future ...
[18:04:01.528] Packages needed by the future expression (n = 0): <none>
[18:04:01.529] Packages needed by future strategies (n = 0): <none>
[18:04:01.530] {
[18:04:01.530]     {
[18:04:01.530]         {
[18:04:01.530]             ...future.startTime <- base::Sys.time()
[18:04:01.530]             {
[18:04:01.530]                 {
[18:04:01.530]                   {
[18:04:01.530]                     {
[18:04:01.530]                       base::local({
[18:04:01.530]                         has_future <- base::requireNamespace("future", 
[18:04:01.530]                           quietly = TRUE)
[18:04:01.530]                         if (has_future) {
[18:04:01.530]                           ns <- base::getNamespace("future")
[18:04:01.530]                           version <- ns[[".package"]][["version"]]
[18:04:01.530]                           if (is.null(version)) 
[18:04:01.530]                             version <- utils::packageVersion("future")
[18:04:01.530]                         }
[18:04:01.530]                         else {
[18:04:01.530]                           version <- NULL
[18:04:01.530]                         }
[18:04:01.530]                         if (!has_future || version < "1.8.0") {
[18:04:01.530]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:01.530]                             "", base::R.version$version.string), 
[18:04:01.530]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:01.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:01.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:01.530]                               "release", "version")], collapse = " "), 
[18:04:01.530]                             hostname = base::Sys.info()[["nodename"]])
[18:04:01.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:01.530]                             info)
[18:04:01.530]                           info <- base::paste(info, collapse = "; ")
[18:04:01.530]                           if (!has_future) {
[18:04:01.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:01.530]                               info)
[18:04:01.530]                           }
[18:04:01.530]                           else {
[18:04:01.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:01.530]                               info, version)
[18:04:01.530]                           }
[18:04:01.530]                           base::stop(msg)
[18:04:01.530]                         }
[18:04:01.530]                       })
[18:04:01.530]                     }
[18:04:01.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:01.530]                     base::options(mc.cores = 1L)
[18:04:01.530]                   }
[18:04:01.530]                   ...future.strategy.old <- future::plan("list")
[18:04:01.530]                   options(future.plan = NULL)
[18:04:01.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:01.530]                 }
[18:04:01.530]                 ...future.workdir <- getwd()
[18:04:01.530]             }
[18:04:01.530]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:01.530]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:01.530]         }
[18:04:01.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:01.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:01.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:01.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:01.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:01.530]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:01.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:01.530]             base::names(...future.oldOptions))
[18:04:01.530]     }
[18:04:01.530]     if (FALSE) {
[18:04:01.530]     }
[18:04:01.530]     else {
[18:04:01.530]         if (TRUE) {
[18:04:01.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:01.530]                 open = "w")
[18:04:01.530]         }
[18:04:01.530]         else {
[18:04:01.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:01.530]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:01.530]         }
[18:04:01.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:01.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:01.530]             base::sink(type = "output", split = FALSE)
[18:04:01.530]             base::close(...future.stdout)
[18:04:01.530]         }, add = TRUE)
[18:04:01.530]     }
[18:04:01.530]     ...future.frame <- base::sys.nframe()
[18:04:01.530]     ...future.conditions <- base::list()
[18:04:01.530]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:01.530]     if (FALSE) {
[18:04:01.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:01.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:01.530]     }
[18:04:01.530]     ...future.result <- base::tryCatch({
[18:04:01.530]         base::withCallingHandlers({
[18:04:01.530]             ...future.value <- base::withVisible(base::local({
[18:04:01.530]                 ...future.makeSendCondition <- base::local({
[18:04:01.530]                   sendCondition <- NULL
[18:04:01.530]                   function(frame = 1L) {
[18:04:01.530]                     if (is.function(sendCondition)) 
[18:04:01.530]                       return(sendCondition)
[18:04:01.530]                     ns <- getNamespace("parallel")
[18:04:01.530]                     if (exists("sendData", mode = "function", 
[18:04:01.530]                       envir = ns)) {
[18:04:01.530]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:01.530]                         envir = ns)
[18:04:01.530]                       envir <- sys.frame(frame)
[18:04:01.530]                       master <- NULL
[18:04:01.530]                       while (!identical(envir, .GlobalEnv) && 
[18:04:01.530]                         !identical(envir, emptyenv())) {
[18:04:01.530]                         if (exists("master", mode = "list", envir = envir, 
[18:04:01.530]                           inherits = FALSE)) {
[18:04:01.530]                           master <- get("master", mode = "list", 
[18:04:01.530]                             envir = envir, inherits = FALSE)
[18:04:01.530]                           if (inherits(master, c("SOCKnode", 
[18:04:01.530]                             "SOCK0node"))) {
[18:04:01.530]                             sendCondition <<- function(cond) {
[18:04:01.530]                               data <- list(type = "VALUE", value = cond, 
[18:04:01.530]                                 success = TRUE)
[18:04:01.530]                               parallel_sendData(master, data)
[18:04:01.530]                             }
[18:04:01.530]                             return(sendCondition)
[18:04:01.530]                           }
[18:04:01.530]                         }
[18:04:01.530]                         frame <- frame + 1L
[18:04:01.530]                         envir <- sys.frame(frame)
[18:04:01.530]                       }
[18:04:01.530]                     }
[18:04:01.530]                     sendCondition <<- function(cond) NULL
[18:04:01.530]                   }
[18:04:01.530]                 })
[18:04:01.530]                 withCallingHandlers({
[18:04:01.530]                   {
[18:04:01.530]                     x <- a
[18:04:01.530]                   }
[18:04:01.530]                 }, immediateCondition = function(cond) {
[18:04:01.530]                   sendCondition <- ...future.makeSendCondition()
[18:04:01.530]                   sendCondition(cond)
[18:04:01.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.530]                   {
[18:04:01.530]                     inherits <- base::inherits
[18:04:01.530]                     invokeRestart <- base::invokeRestart
[18:04:01.530]                     is.null <- base::is.null
[18:04:01.530]                     muffled <- FALSE
[18:04:01.530]                     if (inherits(cond, "message")) {
[18:04:01.530]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:01.530]                       if (muffled) 
[18:04:01.530]                         invokeRestart("muffleMessage")
[18:04:01.530]                     }
[18:04:01.530]                     else if (inherits(cond, "warning")) {
[18:04:01.530]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:01.530]                       if (muffled) 
[18:04:01.530]                         invokeRestart("muffleWarning")
[18:04:01.530]                     }
[18:04:01.530]                     else if (inherits(cond, "condition")) {
[18:04:01.530]                       if (!is.null(pattern)) {
[18:04:01.530]                         computeRestarts <- base::computeRestarts
[18:04:01.530]                         grepl <- base::grepl
[18:04:01.530]                         restarts <- computeRestarts(cond)
[18:04:01.530]                         for (restart in restarts) {
[18:04:01.530]                           name <- restart$name
[18:04:01.530]                           if (is.null(name)) 
[18:04:01.530]                             next
[18:04:01.530]                           if (!grepl(pattern, name)) 
[18:04:01.530]                             next
[18:04:01.530]                           invokeRestart(restart)
[18:04:01.530]                           muffled <- TRUE
[18:04:01.530]                           break
[18:04:01.530]                         }
[18:04:01.530]                       }
[18:04:01.530]                     }
[18:04:01.530]                     invisible(muffled)
[18:04:01.530]                   }
[18:04:01.530]                   muffleCondition(cond)
[18:04:01.530]                 })
[18:04:01.530]             }))
[18:04:01.530]             future::FutureResult(value = ...future.value$value, 
[18:04:01.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.530]                   ...future.rng), globalenv = if (FALSE) 
[18:04:01.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:01.530]                     ...future.globalenv.names))
[18:04:01.530]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:01.530]         }, condition = base::local({
[18:04:01.530]             c <- base::c
[18:04:01.530]             inherits <- base::inherits
[18:04:01.530]             invokeRestart <- base::invokeRestart
[18:04:01.530]             length <- base::length
[18:04:01.530]             list <- base::list
[18:04:01.530]             seq.int <- base::seq.int
[18:04:01.530]             signalCondition <- base::signalCondition
[18:04:01.530]             sys.calls <- base::sys.calls
[18:04:01.530]             `[[` <- base::`[[`
[18:04:01.530]             `+` <- base::`+`
[18:04:01.530]             `<<-` <- base::`<<-`
[18:04:01.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:01.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:01.530]                   3L)]
[18:04:01.530]             }
[18:04:01.530]             function(cond) {
[18:04:01.530]                 is_error <- inherits(cond, "error")
[18:04:01.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:01.530]                   NULL)
[18:04:01.530]                 if (is_error) {
[18:04:01.530]                   sessionInformation <- function() {
[18:04:01.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:01.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:01.530]                       search = base::search(), system = base::Sys.info())
[18:04:01.530]                   }
[18:04:01.530]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:01.530]                     cond$call), session = sessionInformation(), 
[18:04:01.530]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:01.530]                   signalCondition(cond)
[18:04:01.530]                 }
[18:04:01.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:01.530]                 "immediateCondition"))) {
[18:04:01.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:01.530]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:01.530]                   if (TRUE && !signal) {
[18:04:01.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.530]                     {
[18:04:01.530]                       inherits <- base::inherits
[18:04:01.530]                       invokeRestart <- base::invokeRestart
[18:04:01.530]                       is.null <- base::is.null
[18:04:01.530]                       muffled <- FALSE
[18:04:01.530]                       if (inherits(cond, "message")) {
[18:04:01.530]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.530]                         if (muffled) 
[18:04:01.530]                           invokeRestart("muffleMessage")
[18:04:01.530]                       }
[18:04:01.530]                       else if (inherits(cond, "warning")) {
[18:04:01.530]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.530]                         if (muffled) 
[18:04:01.530]                           invokeRestart("muffleWarning")
[18:04:01.530]                       }
[18:04:01.530]                       else if (inherits(cond, "condition")) {
[18:04:01.530]                         if (!is.null(pattern)) {
[18:04:01.530]                           computeRestarts <- base::computeRestarts
[18:04:01.530]                           grepl <- base::grepl
[18:04:01.530]                           restarts <- computeRestarts(cond)
[18:04:01.530]                           for (restart in restarts) {
[18:04:01.530]                             name <- restart$name
[18:04:01.530]                             if (is.null(name)) 
[18:04:01.530]                               next
[18:04:01.530]                             if (!grepl(pattern, name)) 
[18:04:01.530]                               next
[18:04:01.530]                             invokeRestart(restart)
[18:04:01.530]                             muffled <- TRUE
[18:04:01.530]                             break
[18:04:01.530]                           }
[18:04:01.530]                         }
[18:04:01.530]                       }
[18:04:01.530]                       invisible(muffled)
[18:04:01.530]                     }
[18:04:01.530]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.530]                   }
[18:04:01.530]                 }
[18:04:01.530]                 else {
[18:04:01.530]                   if (TRUE) {
[18:04:01.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.530]                     {
[18:04:01.530]                       inherits <- base::inherits
[18:04:01.530]                       invokeRestart <- base::invokeRestart
[18:04:01.530]                       is.null <- base::is.null
[18:04:01.530]                       muffled <- FALSE
[18:04:01.530]                       if (inherits(cond, "message")) {
[18:04:01.530]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.530]                         if (muffled) 
[18:04:01.530]                           invokeRestart("muffleMessage")
[18:04:01.530]                       }
[18:04:01.530]                       else if (inherits(cond, "warning")) {
[18:04:01.530]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.530]                         if (muffled) 
[18:04:01.530]                           invokeRestart("muffleWarning")
[18:04:01.530]                       }
[18:04:01.530]                       else if (inherits(cond, "condition")) {
[18:04:01.530]                         if (!is.null(pattern)) {
[18:04:01.530]                           computeRestarts <- base::computeRestarts
[18:04:01.530]                           grepl <- base::grepl
[18:04:01.530]                           restarts <- computeRestarts(cond)
[18:04:01.530]                           for (restart in restarts) {
[18:04:01.530]                             name <- restart$name
[18:04:01.530]                             if (is.null(name)) 
[18:04:01.530]                               next
[18:04:01.530]                             if (!grepl(pattern, name)) 
[18:04:01.530]                               next
[18:04:01.530]                             invokeRestart(restart)
[18:04:01.530]                             muffled <- TRUE
[18:04:01.530]                             break
[18:04:01.530]                           }
[18:04:01.530]                         }
[18:04:01.530]                       }
[18:04:01.530]                       invisible(muffled)
[18:04:01.530]                     }
[18:04:01.530]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.530]                   }
[18:04:01.530]                 }
[18:04:01.530]             }
[18:04:01.530]         }))
[18:04:01.530]     }, error = function(ex) {
[18:04:01.530]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:01.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.530]                 ...future.rng), started = ...future.startTime, 
[18:04:01.530]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:01.530]             version = "1.8"), class = "FutureResult")
[18:04:01.530]     }, finally = {
[18:04:01.530]         if (!identical(...future.workdir, getwd())) 
[18:04:01.530]             setwd(...future.workdir)
[18:04:01.530]         {
[18:04:01.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:01.530]                 ...future.oldOptions$nwarnings <- NULL
[18:04:01.530]             }
[18:04:01.530]             base::options(...future.oldOptions)
[18:04:01.530]             if (.Platform$OS.type == "windows") {
[18:04:01.530]                 old_names <- names(...future.oldEnvVars)
[18:04:01.530]                 envs <- base::Sys.getenv()
[18:04:01.530]                 names <- names(envs)
[18:04:01.530]                 common <- intersect(names, old_names)
[18:04:01.530]                 added <- setdiff(names, old_names)
[18:04:01.530]                 removed <- setdiff(old_names, names)
[18:04:01.530]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:01.530]                   envs[common]]
[18:04:01.530]                 NAMES <- toupper(changed)
[18:04:01.530]                 args <- list()
[18:04:01.530]                 for (kk in seq_along(NAMES)) {
[18:04:01.530]                   name <- changed[[kk]]
[18:04:01.530]                   NAME <- NAMES[[kk]]
[18:04:01.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.530]                     next
[18:04:01.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.530]                 }
[18:04:01.530]                 NAMES <- toupper(added)
[18:04:01.530]                 for (kk in seq_along(NAMES)) {
[18:04:01.530]                   name <- added[[kk]]
[18:04:01.530]                   NAME <- NAMES[[kk]]
[18:04:01.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.530]                     next
[18:04:01.530]                   args[[name]] <- ""
[18:04:01.530]                 }
[18:04:01.530]                 NAMES <- toupper(removed)
[18:04:01.530]                 for (kk in seq_along(NAMES)) {
[18:04:01.530]                   name <- removed[[kk]]
[18:04:01.530]                   NAME <- NAMES[[kk]]
[18:04:01.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.530]                     next
[18:04:01.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.530]                 }
[18:04:01.530]                 if (length(args) > 0) 
[18:04:01.530]                   base::do.call(base::Sys.setenv, args = args)
[18:04:01.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:01.530]             }
[18:04:01.530]             else {
[18:04:01.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:01.530]             }
[18:04:01.530]             {
[18:04:01.530]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:01.530]                   0L) {
[18:04:01.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:01.530]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:01.530]                   base::options(opts)
[18:04:01.530]                 }
[18:04:01.530]                 {
[18:04:01.530]                   {
[18:04:01.530]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:01.530]                     NULL
[18:04:01.530]                   }
[18:04:01.530]                   options(future.plan = NULL)
[18:04:01.530]                   if (is.na(NA_character_)) 
[18:04:01.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:01.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:01.530]                     .init = FALSE)
[18:04:01.530]                 }
[18:04:01.530]             }
[18:04:01.530]         }
[18:04:01.530]     })
[18:04:01.530]     if (TRUE) {
[18:04:01.530]         base::sink(type = "output", split = FALSE)
[18:04:01.530]         if (TRUE) {
[18:04:01.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:01.530]         }
[18:04:01.530]         else {
[18:04:01.530]             ...future.result["stdout"] <- base::list(NULL)
[18:04:01.530]         }
[18:04:01.530]         base::close(...future.stdout)
[18:04:01.530]         ...future.stdout <- NULL
[18:04:01.530]     }
[18:04:01.530]     ...future.result$conditions <- ...future.conditions
[18:04:01.530]     ...future.result$finished <- base::Sys.time()
[18:04:01.530]     ...future.result
[18:04:01.530] }
[18:04:01.536] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:04:01.536] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:04:01.537] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:04:01.537] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:04:01.538] MultisessionFuture started
[18:04:01.539] - Launch lazy future ... done
[18:04:01.539] run() for ‘MultisessionFuture’ ... done
[18:04:01.540] result() for ClusterFuture ...
[18:04:01.541] receiveMessageFromWorker() for ClusterFuture ...
[18:04:01.541] - Validating connection of MultisessionFuture
[18:04:01.589] - received message: FutureResult
[18:04:01.590] - Received FutureResult
[18:04:01.591] - Erased future from FutureRegistry
[18:04:01.593] result() for ClusterFuture ...
[18:04:01.593] - result already collected: FutureResult
[18:04:01.594] result() for ClusterFuture ... done
[18:04:01.594] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:01.594] result() for ClusterFuture ... done
[18:04:01.595] result() for ClusterFuture ...
[18:04:01.595] - result already collected: FutureResult
[18:04:01.595] result() for ClusterFuture ... done
** Future evaluation with errors
[18:04:01.596] getGlobalsAndPackages() ...
[18:04:01.596] Searching for globals...
[18:04:01.600] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[18:04:01.601] Searching for globals ... DONE
[18:04:01.601] Resolving globals: FALSE
[18:04:01.602] 
[18:04:01.602] 
[18:04:01.602] getGlobalsAndPackages() ... DONE
[18:04:01.603] run() for ‘Future’ ...
[18:04:01.603] - state: ‘created’
[18:04:01.604] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:01.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:01.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:01.629]   - Field: ‘node’
[18:04:01.629]   - Field: ‘label’
[18:04:01.630]   - Field: ‘local’
[18:04:01.630]   - Field: ‘owner’
[18:04:01.630]   - Field: ‘envir’
[18:04:01.630]   - Field: ‘workers’
[18:04:01.630]   - Field: ‘packages’
[18:04:01.631]   - Field: ‘gc’
[18:04:01.631]   - Field: ‘conditions’
[18:04:01.631]   - Field: ‘persistent’
[18:04:01.631]   - Field: ‘expr’
[18:04:01.632]   - Field: ‘uuid’
[18:04:01.632]   - Field: ‘seed’
[18:04:01.632]   - Field: ‘version’
[18:04:01.632]   - Field: ‘result’
[18:04:01.632]   - Field: ‘asynchronous’
[18:04:01.633]   - Field: ‘calls’
[18:04:01.633]   - Field: ‘globals’
[18:04:01.633]   - Field: ‘stdout’
[18:04:01.633]   - Field: ‘earlySignal’
[18:04:01.634]   - Field: ‘lazy’
[18:04:01.634]   - Field: ‘state’
[18:04:01.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:01.634] - Launch lazy future ...
[18:04:01.635] Packages needed by the future expression (n = 0): <none>
[18:04:01.635] Packages needed by future strategies (n = 0): <none>
[18:04:01.636] {
[18:04:01.636]     {
[18:04:01.636]         {
[18:04:01.636]             ...future.startTime <- base::Sys.time()
[18:04:01.636]             {
[18:04:01.636]                 {
[18:04:01.636]                   {
[18:04:01.636]                     {
[18:04:01.636]                       base::local({
[18:04:01.636]                         has_future <- base::requireNamespace("future", 
[18:04:01.636]                           quietly = TRUE)
[18:04:01.636]                         if (has_future) {
[18:04:01.636]                           ns <- base::getNamespace("future")
[18:04:01.636]                           version <- ns[[".package"]][["version"]]
[18:04:01.636]                           if (is.null(version)) 
[18:04:01.636]                             version <- utils::packageVersion("future")
[18:04:01.636]                         }
[18:04:01.636]                         else {
[18:04:01.636]                           version <- NULL
[18:04:01.636]                         }
[18:04:01.636]                         if (!has_future || version < "1.8.0") {
[18:04:01.636]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:01.636]                             "", base::R.version$version.string), 
[18:04:01.636]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:01.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:01.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:01.636]                               "release", "version")], collapse = " "), 
[18:04:01.636]                             hostname = base::Sys.info()[["nodename"]])
[18:04:01.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:01.636]                             info)
[18:04:01.636]                           info <- base::paste(info, collapse = "; ")
[18:04:01.636]                           if (!has_future) {
[18:04:01.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:01.636]                               info)
[18:04:01.636]                           }
[18:04:01.636]                           else {
[18:04:01.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:01.636]                               info, version)
[18:04:01.636]                           }
[18:04:01.636]                           base::stop(msg)
[18:04:01.636]                         }
[18:04:01.636]                       })
[18:04:01.636]                     }
[18:04:01.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:01.636]                     base::options(mc.cores = 1L)
[18:04:01.636]                   }
[18:04:01.636]                   ...future.strategy.old <- future::plan("list")
[18:04:01.636]                   options(future.plan = NULL)
[18:04:01.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:01.636]                 }
[18:04:01.636]                 ...future.workdir <- getwd()
[18:04:01.636]             }
[18:04:01.636]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:01.636]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:01.636]         }
[18:04:01.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:01.636]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:01.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:01.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:01.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:01.636]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:01.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:01.636]             base::names(...future.oldOptions))
[18:04:01.636]     }
[18:04:01.636]     if (FALSE) {
[18:04:01.636]     }
[18:04:01.636]     else {
[18:04:01.636]         if (TRUE) {
[18:04:01.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:01.636]                 open = "w")
[18:04:01.636]         }
[18:04:01.636]         else {
[18:04:01.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:01.636]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:01.636]         }
[18:04:01.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:01.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:01.636]             base::sink(type = "output", split = FALSE)
[18:04:01.636]             base::close(...future.stdout)
[18:04:01.636]         }, add = TRUE)
[18:04:01.636]     }
[18:04:01.636]     ...future.frame <- base::sys.nframe()
[18:04:01.636]     ...future.conditions <- base::list()
[18:04:01.636]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:01.636]     if (FALSE) {
[18:04:01.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:01.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:01.636]     }
[18:04:01.636]     ...future.result <- base::tryCatch({
[18:04:01.636]         base::withCallingHandlers({
[18:04:01.636]             ...future.value <- base::withVisible(base::local({
[18:04:01.636]                 ...future.makeSendCondition <- base::local({
[18:04:01.636]                   sendCondition <- NULL
[18:04:01.636]                   function(frame = 1L) {
[18:04:01.636]                     if (is.function(sendCondition)) 
[18:04:01.636]                       return(sendCondition)
[18:04:01.636]                     ns <- getNamespace("parallel")
[18:04:01.636]                     if (exists("sendData", mode = "function", 
[18:04:01.636]                       envir = ns)) {
[18:04:01.636]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:01.636]                         envir = ns)
[18:04:01.636]                       envir <- sys.frame(frame)
[18:04:01.636]                       master <- NULL
[18:04:01.636]                       while (!identical(envir, .GlobalEnv) && 
[18:04:01.636]                         !identical(envir, emptyenv())) {
[18:04:01.636]                         if (exists("master", mode = "list", envir = envir, 
[18:04:01.636]                           inherits = FALSE)) {
[18:04:01.636]                           master <- get("master", mode = "list", 
[18:04:01.636]                             envir = envir, inherits = FALSE)
[18:04:01.636]                           if (inherits(master, c("SOCKnode", 
[18:04:01.636]                             "SOCK0node"))) {
[18:04:01.636]                             sendCondition <<- function(cond) {
[18:04:01.636]                               data <- list(type = "VALUE", value = cond, 
[18:04:01.636]                                 success = TRUE)
[18:04:01.636]                               parallel_sendData(master, data)
[18:04:01.636]                             }
[18:04:01.636]                             return(sendCondition)
[18:04:01.636]                           }
[18:04:01.636]                         }
[18:04:01.636]                         frame <- frame + 1L
[18:04:01.636]                         envir <- sys.frame(frame)
[18:04:01.636]                       }
[18:04:01.636]                     }
[18:04:01.636]                     sendCondition <<- function(cond) NULL
[18:04:01.636]                   }
[18:04:01.636]                 })
[18:04:01.636]                 withCallingHandlers({
[18:04:01.636]                   {
[18:04:01.636]                     x <- 3
[18:04:01.636]                     stop("Woops!")
[18:04:01.636]                     x
[18:04:01.636]                   }
[18:04:01.636]                 }, immediateCondition = function(cond) {
[18:04:01.636]                   sendCondition <- ...future.makeSendCondition()
[18:04:01.636]                   sendCondition(cond)
[18:04:01.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.636]                   {
[18:04:01.636]                     inherits <- base::inherits
[18:04:01.636]                     invokeRestart <- base::invokeRestart
[18:04:01.636]                     is.null <- base::is.null
[18:04:01.636]                     muffled <- FALSE
[18:04:01.636]                     if (inherits(cond, "message")) {
[18:04:01.636]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:01.636]                       if (muffled) 
[18:04:01.636]                         invokeRestart("muffleMessage")
[18:04:01.636]                     }
[18:04:01.636]                     else if (inherits(cond, "warning")) {
[18:04:01.636]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:01.636]                       if (muffled) 
[18:04:01.636]                         invokeRestart("muffleWarning")
[18:04:01.636]                     }
[18:04:01.636]                     else if (inherits(cond, "condition")) {
[18:04:01.636]                       if (!is.null(pattern)) {
[18:04:01.636]                         computeRestarts <- base::computeRestarts
[18:04:01.636]                         grepl <- base::grepl
[18:04:01.636]                         restarts <- computeRestarts(cond)
[18:04:01.636]                         for (restart in restarts) {
[18:04:01.636]                           name <- restart$name
[18:04:01.636]                           if (is.null(name)) 
[18:04:01.636]                             next
[18:04:01.636]                           if (!grepl(pattern, name)) 
[18:04:01.636]                             next
[18:04:01.636]                           invokeRestart(restart)
[18:04:01.636]                           muffled <- TRUE
[18:04:01.636]                           break
[18:04:01.636]                         }
[18:04:01.636]                       }
[18:04:01.636]                     }
[18:04:01.636]                     invisible(muffled)
[18:04:01.636]                   }
[18:04:01.636]                   muffleCondition(cond)
[18:04:01.636]                 })
[18:04:01.636]             }))
[18:04:01.636]             future::FutureResult(value = ...future.value$value, 
[18:04:01.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.636]                   ...future.rng), globalenv = if (FALSE) 
[18:04:01.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:01.636]                     ...future.globalenv.names))
[18:04:01.636]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:01.636]         }, condition = base::local({
[18:04:01.636]             c <- base::c
[18:04:01.636]             inherits <- base::inherits
[18:04:01.636]             invokeRestart <- base::invokeRestart
[18:04:01.636]             length <- base::length
[18:04:01.636]             list <- base::list
[18:04:01.636]             seq.int <- base::seq.int
[18:04:01.636]             signalCondition <- base::signalCondition
[18:04:01.636]             sys.calls <- base::sys.calls
[18:04:01.636]             `[[` <- base::`[[`
[18:04:01.636]             `+` <- base::`+`
[18:04:01.636]             `<<-` <- base::`<<-`
[18:04:01.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:01.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:01.636]                   3L)]
[18:04:01.636]             }
[18:04:01.636]             function(cond) {
[18:04:01.636]                 is_error <- inherits(cond, "error")
[18:04:01.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:01.636]                   NULL)
[18:04:01.636]                 if (is_error) {
[18:04:01.636]                   sessionInformation <- function() {
[18:04:01.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:01.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:01.636]                       search = base::search(), system = base::Sys.info())
[18:04:01.636]                   }
[18:04:01.636]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:01.636]                     cond$call), session = sessionInformation(), 
[18:04:01.636]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:01.636]                   signalCondition(cond)
[18:04:01.636]                 }
[18:04:01.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:01.636]                 "immediateCondition"))) {
[18:04:01.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:01.636]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:01.636]                   if (TRUE && !signal) {
[18:04:01.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.636]                     {
[18:04:01.636]                       inherits <- base::inherits
[18:04:01.636]                       invokeRestart <- base::invokeRestart
[18:04:01.636]                       is.null <- base::is.null
[18:04:01.636]                       muffled <- FALSE
[18:04:01.636]                       if (inherits(cond, "message")) {
[18:04:01.636]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.636]                         if (muffled) 
[18:04:01.636]                           invokeRestart("muffleMessage")
[18:04:01.636]                       }
[18:04:01.636]                       else if (inherits(cond, "warning")) {
[18:04:01.636]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.636]                         if (muffled) 
[18:04:01.636]                           invokeRestart("muffleWarning")
[18:04:01.636]                       }
[18:04:01.636]                       else if (inherits(cond, "condition")) {
[18:04:01.636]                         if (!is.null(pattern)) {
[18:04:01.636]                           computeRestarts <- base::computeRestarts
[18:04:01.636]                           grepl <- base::grepl
[18:04:01.636]                           restarts <- computeRestarts(cond)
[18:04:01.636]                           for (restart in restarts) {
[18:04:01.636]                             name <- restart$name
[18:04:01.636]                             if (is.null(name)) 
[18:04:01.636]                               next
[18:04:01.636]                             if (!grepl(pattern, name)) 
[18:04:01.636]                               next
[18:04:01.636]                             invokeRestart(restart)
[18:04:01.636]                             muffled <- TRUE
[18:04:01.636]                             break
[18:04:01.636]                           }
[18:04:01.636]                         }
[18:04:01.636]                       }
[18:04:01.636]                       invisible(muffled)
[18:04:01.636]                     }
[18:04:01.636]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.636]                   }
[18:04:01.636]                 }
[18:04:01.636]                 else {
[18:04:01.636]                   if (TRUE) {
[18:04:01.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.636]                     {
[18:04:01.636]                       inherits <- base::inherits
[18:04:01.636]                       invokeRestart <- base::invokeRestart
[18:04:01.636]                       is.null <- base::is.null
[18:04:01.636]                       muffled <- FALSE
[18:04:01.636]                       if (inherits(cond, "message")) {
[18:04:01.636]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.636]                         if (muffled) 
[18:04:01.636]                           invokeRestart("muffleMessage")
[18:04:01.636]                       }
[18:04:01.636]                       else if (inherits(cond, "warning")) {
[18:04:01.636]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.636]                         if (muffled) 
[18:04:01.636]                           invokeRestart("muffleWarning")
[18:04:01.636]                       }
[18:04:01.636]                       else if (inherits(cond, "condition")) {
[18:04:01.636]                         if (!is.null(pattern)) {
[18:04:01.636]                           computeRestarts <- base::computeRestarts
[18:04:01.636]                           grepl <- base::grepl
[18:04:01.636]                           restarts <- computeRestarts(cond)
[18:04:01.636]                           for (restart in restarts) {
[18:04:01.636]                             name <- restart$name
[18:04:01.636]                             if (is.null(name)) 
[18:04:01.636]                               next
[18:04:01.636]                             if (!grepl(pattern, name)) 
[18:04:01.636]                               next
[18:04:01.636]                             invokeRestart(restart)
[18:04:01.636]                             muffled <- TRUE
[18:04:01.636]                             break
[18:04:01.636]                           }
[18:04:01.636]                         }
[18:04:01.636]                       }
[18:04:01.636]                       invisible(muffled)
[18:04:01.636]                     }
[18:04:01.636]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.636]                   }
[18:04:01.636]                 }
[18:04:01.636]             }
[18:04:01.636]         }))
[18:04:01.636]     }, error = function(ex) {
[18:04:01.636]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:01.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.636]                 ...future.rng), started = ...future.startTime, 
[18:04:01.636]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:01.636]             version = "1.8"), class = "FutureResult")
[18:04:01.636]     }, finally = {
[18:04:01.636]         if (!identical(...future.workdir, getwd())) 
[18:04:01.636]             setwd(...future.workdir)
[18:04:01.636]         {
[18:04:01.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:01.636]                 ...future.oldOptions$nwarnings <- NULL
[18:04:01.636]             }
[18:04:01.636]             base::options(...future.oldOptions)
[18:04:01.636]             if (.Platform$OS.type == "windows") {
[18:04:01.636]                 old_names <- names(...future.oldEnvVars)
[18:04:01.636]                 envs <- base::Sys.getenv()
[18:04:01.636]                 names <- names(envs)
[18:04:01.636]                 common <- intersect(names, old_names)
[18:04:01.636]                 added <- setdiff(names, old_names)
[18:04:01.636]                 removed <- setdiff(old_names, names)
[18:04:01.636]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:01.636]                   envs[common]]
[18:04:01.636]                 NAMES <- toupper(changed)
[18:04:01.636]                 args <- list()
[18:04:01.636]                 for (kk in seq_along(NAMES)) {
[18:04:01.636]                   name <- changed[[kk]]
[18:04:01.636]                   NAME <- NAMES[[kk]]
[18:04:01.636]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.636]                     next
[18:04:01.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.636]                 }
[18:04:01.636]                 NAMES <- toupper(added)
[18:04:01.636]                 for (kk in seq_along(NAMES)) {
[18:04:01.636]                   name <- added[[kk]]
[18:04:01.636]                   NAME <- NAMES[[kk]]
[18:04:01.636]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.636]                     next
[18:04:01.636]                   args[[name]] <- ""
[18:04:01.636]                 }
[18:04:01.636]                 NAMES <- toupper(removed)
[18:04:01.636]                 for (kk in seq_along(NAMES)) {
[18:04:01.636]                   name <- removed[[kk]]
[18:04:01.636]                   NAME <- NAMES[[kk]]
[18:04:01.636]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.636]                     next
[18:04:01.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.636]                 }
[18:04:01.636]                 if (length(args) > 0) 
[18:04:01.636]                   base::do.call(base::Sys.setenv, args = args)
[18:04:01.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:01.636]             }
[18:04:01.636]             else {
[18:04:01.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:01.636]             }
[18:04:01.636]             {
[18:04:01.636]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:01.636]                   0L) {
[18:04:01.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:01.636]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:01.636]                   base::options(opts)
[18:04:01.636]                 }
[18:04:01.636]                 {
[18:04:01.636]                   {
[18:04:01.636]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:01.636]                     NULL
[18:04:01.636]                   }
[18:04:01.636]                   options(future.plan = NULL)
[18:04:01.636]                   if (is.na(NA_character_)) 
[18:04:01.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:01.636]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:01.636]                     .init = FALSE)
[18:04:01.636]                 }
[18:04:01.636]             }
[18:04:01.636]         }
[18:04:01.636]     })
[18:04:01.636]     if (TRUE) {
[18:04:01.636]         base::sink(type = "output", split = FALSE)
[18:04:01.636]         if (TRUE) {
[18:04:01.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:01.636]         }
[18:04:01.636]         else {
[18:04:01.636]             ...future.result["stdout"] <- base::list(NULL)
[18:04:01.636]         }
[18:04:01.636]         base::close(...future.stdout)
[18:04:01.636]         ...future.stdout <- NULL
[18:04:01.636]     }
[18:04:01.636]     ...future.result$conditions <- ...future.conditions
[18:04:01.636]     ...future.result$finished <- base::Sys.time()
[18:04:01.636]     ...future.result
[18:04:01.636] }
[18:04:01.643] MultisessionFuture started
[18:04:01.643] - Launch lazy future ... done
[18:04:01.643] run() for ‘MultisessionFuture’ ... done
[18:04:01.644] result() for ClusterFuture ...
[18:04:01.644] receiveMessageFromWorker() for ClusterFuture ...
[18:04:01.644] - Validating connection of MultisessionFuture
[18:04:01.688] - received message: FutureResult
[18:04:01.688] - Received FutureResult
[18:04:01.689] - Erased future from FutureRegistry
[18:04:01.689] result() for ClusterFuture ...
[18:04:01.689] - result already collected: FutureResult
[18:04:01.690] result() for ClusterFuture ... done
[18:04:01.690] signalConditions() ...
[18:04:01.690]  - include = ‘immediateCondition’
[18:04:01.690]  - exclude = 
[18:04:01.691]  - resignal = FALSE
[18:04:01.691]  - Number of conditions: 1
[18:04:01.691] signalConditions() ... done
[18:04:01.691] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:01.691] result() for ClusterFuture ... done
[18:04:01.692] result() for ClusterFuture ...
[18:04:01.692] - result already collected: FutureResult
[18:04:01.692] result() for ClusterFuture ... done
[18:04:01.692] signalConditions() ...
[18:04:01.693]  - include = ‘immediateCondition’
[18:04:01.693]  - exclude = 
[18:04:01.693]  - resignal = FALSE
[18:04:01.693]  - Number of conditions: 1
[18:04:01.694] signalConditions() ... done
[18:04:01.694] Future state: ‘finished’
[18:04:01.694] result() for ClusterFuture ...
[18:04:01.695] - result already collected: FutureResult
[18:04:01.695] result() for ClusterFuture ... done
[18:04:01.695] signalConditions() ...
[18:04:01.695]  - include = ‘condition’
[18:04:01.695]  - exclude = ‘immediateCondition’
[18:04:01.696]  - resignal = TRUE
[18:04:01.696]  - Number of conditions: 1
[18:04:01.696]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:01.697] signalConditions() ... done
[18:04:01.698] getGlobalsAndPackages() ...
[18:04:01.698] Searching for globals...
[18:04:01.702] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:04:01.702] Searching for globals ... DONE
[18:04:01.703] Resolving globals: FALSE
[18:04:01.704] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:01.705] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:01.705] - globals: [1] ‘ii’
[18:04:01.705] 
[18:04:01.706] getGlobalsAndPackages() ... DONE
[18:04:01.706] run() for ‘Future’ ...
[18:04:01.707] - state: ‘created’
[18:04:01.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:01.735] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:01.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:01.736]   - Field: ‘node’
[18:04:01.736]   - Field: ‘label’
[18:04:01.736]   - Field: ‘local’
[18:04:01.737]   - Field: ‘owner’
[18:04:01.737]   - Field: ‘envir’
[18:04:01.737]   - Field: ‘workers’
[18:04:01.737]   - Field: ‘packages’
[18:04:01.737]   - Field: ‘gc’
[18:04:01.738]   - Field: ‘conditions’
[18:04:01.738]   - Field: ‘persistent’
[18:04:01.738]   - Field: ‘expr’
[18:04:01.738]   - Field: ‘uuid’
[18:04:01.738]   - Field: ‘seed’
[18:04:01.739]   - Field: ‘version’
[18:04:01.739]   - Field: ‘result’
[18:04:01.739]   - Field: ‘asynchronous’
[18:04:01.739]   - Field: ‘calls’
[18:04:01.739]   - Field: ‘globals’
[18:04:01.740]   - Field: ‘stdout’
[18:04:01.740]   - Field: ‘earlySignal’
[18:04:01.740]   - Field: ‘lazy’
[18:04:01.740]   - Field: ‘state’
[18:04:01.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:01.741] - Launch lazy future ...
[18:04:01.741] Packages needed by the future expression (n = 0): <none>
[18:04:01.741] Packages needed by future strategies (n = 0): <none>
[18:04:01.742] {
[18:04:01.742]     {
[18:04:01.742]         {
[18:04:01.742]             ...future.startTime <- base::Sys.time()
[18:04:01.742]             {
[18:04:01.742]                 {
[18:04:01.742]                   {
[18:04:01.742]                     {
[18:04:01.742]                       base::local({
[18:04:01.742]                         has_future <- base::requireNamespace("future", 
[18:04:01.742]                           quietly = TRUE)
[18:04:01.742]                         if (has_future) {
[18:04:01.742]                           ns <- base::getNamespace("future")
[18:04:01.742]                           version <- ns[[".package"]][["version"]]
[18:04:01.742]                           if (is.null(version)) 
[18:04:01.742]                             version <- utils::packageVersion("future")
[18:04:01.742]                         }
[18:04:01.742]                         else {
[18:04:01.742]                           version <- NULL
[18:04:01.742]                         }
[18:04:01.742]                         if (!has_future || version < "1.8.0") {
[18:04:01.742]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:01.742]                             "", base::R.version$version.string), 
[18:04:01.742]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:01.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:01.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:01.742]                               "release", "version")], collapse = " "), 
[18:04:01.742]                             hostname = base::Sys.info()[["nodename"]])
[18:04:01.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:01.742]                             info)
[18:04:01.742]                           info <- base::paste(info, collapse = "; ")
[18:04:01.742]                           if (!has_future) {
[18:04:01.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:01.742]                               info)
[18:04:01.742]                           }
[18:04:01.742]                           else {
[18:04:01.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:01.742]                               info, version)
[18:04:01.742]                           }
[18:04:01.742]                           base::stop(msg)
[18:04:01.742]                         }
[18:04:01.742]                       })
[18:04:01.742]                     }
[18:04:01.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:01.742]                     base::options(mc.cores = 1L)
[18:04:01.742]                   }
[18:04:01.742]                   ...future.strategy.old <- future::plan("list")
[18:04:01.742]                   options(future.plan = NULL)
[18:04:01.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:01.742]                 }
[18:04:01.742]                 ...future.workdir <- getwd()
[18:04:01.742]             }
[18:04:01.742]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:01.742]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:01.742]         }
[18:04:01.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:01.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:01.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:01.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:01.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:01.742]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:01.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:01.742]             base::names(...future.oldOptions))
[18:04:01.742]     }
[18:04:01.742]     if (FALSE) {
[18:04:01.742]     }
[18:04:01.742]     else {
[18:04:01.742]         if (TRUE) {
[18:04:01.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:01.742]                 open = "w")
[18:04:01.742]         }
[18:04:01.742]         else {
[18:04:01.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:01.742]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:01.742]         }
[18:04:01.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:01.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:01.742]             base::sink(type = "output", split = FALSE)
[18:04:01.742]             base::close(...future.stdout)
[18:04:01.742]         }, add = TRUE)
[18:04:01.742]     }
[18:04:01.742]     ...future.frame <- base::sys.nframe()
[18:04:01.742]     ...future.conditions <- base::list()
[18:04:01.742]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:01.742]     if (FALSE) {
[18:04:01.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:01.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:01.742]     }
[18:04:01.742]     ...future.result <- base::tryCatch({
[18:04:01.742]         base::withCallingHandlers({
[18:04:01.742]             ...future.value <- base::withVisible(base::local({
[18:04:01.742]                 ...future.makeSendCondition <- base::local({
[18:04:01.742]                   sendCondition <- NULL
[18:04:01.742]                   function(frame = 1L) {
[18:04:01.742]                     if (is.function(sendCondition)) 
[18:04:01.742]                       return(sendCondition)
[18:04:01.742]                     ns <- getNamespace("parallel")
[18:04:01.742]                     if (exists("sendData", mode = "function", 
[18:04:01.742]                       envir = ns)) {
[18:04:01.742]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:01.742]                         envir = ns)
[18:04:01.742]                       envir <- sys.frame(frame)
[18:04:01.742]                       master <- NULL
[18:04:01.742]                       while (!identical(envir, .GlobalEnv) && 
[18:04:01.742]                         !identical(envir, emptyenv())) {
[18:04:01.742]                         if (exists("master", mode = "list", envir = envir, 
[18:04:01.742]                           inherits = FALSE)) {
[18:04:01.742]                           master <- get("master", mode = "list", 
[18:04:01.742]                             envir = envir, inherits = FALSE)
[18:04:01.742]                           if (inherits(master, c("SOCKnode", 
[18:04:01.742]                             "SOCK0node"))) {
[18:04:01.742]                             sendCondition <<- function(cond) {
[18:04:01.742]                               data <- list(type = "VALUE", value = cond, 
[18:04:01.742]                                 success = TRUE)
[18:04:01.742]                               parallel_sendData(master, data)
[18:04:01.742]                             }
[18:04:01.742]                             return(sendCondition)
[18:04:01.742]                           }
[18:04:01.742]                         }
[18:04:01.742]                         frame <- frame + 1L
[18:04:01.742]                         envir <- sys.frame(frame)
[18:04:01.742]                       }
[18:04:01.742]                     }
[18:04:01.742]                     sendCondition <<- function(cond) NULL
[18:04:01.742]                   }
[18:04:01.742]                 })
[18:04:01.742]                 withCallingHandlers({
[18:04:01.742]                   {
[18:04:01.742]                     if (ii%%2 == 0) 
[18:04:01.742]                       stop("Woops!")
[18:04:01.742]                     ii
[18:04:01.742]                   }
[18:04:01.742]                 }, immediateCondition = function(cond) {
[18:04:01.742]                   sendCondition <- ...future.makeSendCondition()
[18:04:01.742]                   sendCondition(cond)
[18:04:01.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.742]                   {
[18:04:01.742]                     inherits <- base::inherits
[18:04:01.742]                     invokeRestart <- base::invokeRestart
[18:04:01.742]                     is.null <- base::is.null
[18:04:01.742]                     muffled <- FALSE
[18:04:01.742]                     if (inherits(cond, "message")) {
[18:04:01.742]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:01.742]                       if (muffled) 
[18:04:01.742]                         invokeRestart("muffleMessage")
[18:04:01.742]                     }
[18:04:01.742]                     else if (inherits(cond, "warning")) {
[18:04:01.742]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:01.742]                       if (muffled) 
[18:04:01.742]                         invokeRestart("muffleWarning")
[18:04:01.742]                     }
[18:04:01.742]                     else if (inherits(cond, "condition")) {
[18:04:01.742]                       if (!is.null(pattern)) {
[18:04:01.742]                         computeRestarts <- base::computeRestarts
[18:04:01.742]                         grepl <- base::grepl
[18:04:01.742]                         restarts <- computeRestarts(cond)
[18:04:01.742]                         for (restart in restarts) {
[18:04:01.742]                           name <- restart$name
[18:04:01.742]                           if (is.null(name)) 
[18:04:01.742]                             next
[18:04:01.742]                           if (!grepl(pattern, name)) 
[18:04:01.742]                             next
[18:04:01.742]                           invokeRestart(restart)
[18:04:01.742]                           muffled <- TRUE
[18:04:01.742]                           break
[18:04:01.742]                         }
[18:04:01.742]                       }
[18:04:01.742]                     }
[18:04:01.742]                     invisible(muffled)
[18:04:01.742]                   }
[18:04:01.742]                   muffleCondition(cond)
[18:04:01.742]                 })
[18:04:01.742]             }))
[18:04:01.742]             future::FutureResult(value = ...future.value$value, 
[18:04:01.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.742]                   ...future.rng), globalenv = if (FALSE) 
[18:04:01.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:01.742]                     ...future.globalenv.names))
[18:04:01.742]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:01.742]         }, condition = base::local({
[18:04:01.742]             c <- base::c
[18:04:01.742]             inherits <- base::inherits
[18:04:01.742]             invokeRestart <- base::invokeRestart
[18:04:01.742]             length <- base::length
[18:04:01.742]             list <- base::list
[18:04:01.742]             seq.int <- base::seq.int
[18:04:01.742]             signalCondition <- base::signalCondition
[18:04:01.742]             sys.calls <- base::sys.calls
[18:04:01.742]             `[[` <- base::`[[`
[18:04:01.742]             `+` <- base::`+`
[18:04:01.742]             `<<-` <- base::`<<-`
[18:04:01.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:01.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:01.742]                   3L)]
[18:04:01.742]             }
[18:04:01.742]             function(cond) {
[18:04:01.742]                 is_error <- inherits(cond, "error")
[18:04:01.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:01.742]                   NULL)
[18:04:01.742]                 if (is_error) {
[18:04:01.742]                   sessionInformation <- function() {
[18:04:01.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:01.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:01.742]                       search = base::search(), system = base::Sys.info())
[18:04:01.742]                   }
[18:04:01.742]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:01.742]                     cond$call), session = sessionInformation(), 
[18:04:01.742]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:01.742]                   signalCondition(cond)
[18:04:01.742]                 }
[18:04:01.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:01.742]                 "immediateCondition"))) {
[18:04:01.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:01.742]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:01.742]                   if (TRUE && !signal) {
[18:04:01.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.742]                     {
[18:04:01.742]                       inherits <- base::inherits
[18:04:01.742]                       invokeRestart <- base::invokeRestart
[18:04:01.742]                       is.null <- base::is.null
[18:04:01.742]                       muffled <- FALSE
[18:04:01.742]                       if (inherits(cond, "message")) {
[18:04:01.742]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.742]                         if (muffled) 
[18:04:01.742]                           invokeRestart("muffleMessage")
[18:04:01.742]                       }
[18:04:01.742]                       else if (inherits(cond, "warning")) {
[18:04:01.742]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.742]                         if (muffled) 
[18:04:01.742]                           invokeRestart("muffleWarning")
[18:04:01.742]                       }
[18:04:01.742]                       else if (inherits(cond, "condition")) {
[18:04:01.742]                         if (!is.null(pattern)) {
[18:04:01.742]                           computeRestarts <- base::computeRestarts
[18:04:01.742]                           grepl <- base::grepl
[18:04:01.742]                           restarts <- computeRestarts(cond)
[18:04:01.742]                           for (restart in restarts) {
[18:04:01.742]                             name <- restart$name
[18:04:01.742]                             if (is.null(name)) 
[18:04:01.742]                               next
[18:04:01.742]                             if (!grepl(pattern, name)) 
[18:04:01.742]                               next
[18:04:01.742]                             invokeRestart(restart)
[18:04:01.742]                             muffled <- TRUE
[18:04:01.742]                             break
[18:04:01.742]                           }
[18:04:01.742]                         }
[18:04:01.742]                       }
[18:04:01.742]                       invisible(muffled)
[18:04:01.742]                     }
[18:04:01.742]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.742]                   }
[18:04:01.742]                 }
[18:04:01.742]                 else {
[18:04:01.742]                   if (TRUE) {
[18:04:01.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.742]                     {
[18:04:01.742]                       inherits <- base::inherits
[18:04:01.742]                       invokeRestart <- base::invokeRestart
[18:04:01.742]                       is.null <- base::is.null
[18:04:01.742]                       muffled <- FALSE
[18:04:01.742]                       if (inherits(cond, "message")) {
[18:04:01.742]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.742]                         if (muffled) 
[18:04:01.742]                           invokeRestart("muffleMessage")
[18:04:01.742]                       }
[18:04:01.742]                       else if (inherits(cond, "warning")) {
[18:04:01.742]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.742]                         if (muffled) 
[18:04:01.742]                           invokeRestart("muffleWarning")
[18:04:01.742]                       }
[18:04:01.742]                       else if (inherits(cond, "condition")) {
[18:04:01.742]                         if (!is.null(pattern)) {
[18:04:01.742]                           computeRestarts <- base::computeRestarts
[18:04:01.742]                           grepl <- base::grepl
[18:04:01.742]                           restarts <- computeRestarts(cond)
[18:04:01.742]                           for (restart in restarts) {
[18:04:01.742]                             name <- restart$name
[18:04:01.742]                             if (is.null(name)) 
[18:04:01.742]                               next
[18:04:01.742]                             if (!grepl(pattern, name)) 
[18:04:01.742]                               next
[18:04:01.742]                             invokeRestart(restart)
[18:04:01.742]                             muffled <- TRUE
[18:04:01.742]                             break
[18:04:01.742]                           }
[18:04:01.742]                         }
[18:04:01.742]                       }
[18:04:01.742]                       invisible(muffled)
[18:04:01.742]                     }
[18:04:01.742]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.742]                   }
[18:04:01.742]                 }
[18:04:01.742]             }
[18:04:01.742]         }))
[18:04:01.742]     }, error = function(ex) {
[18:04:01.742]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:01.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.742]                 ...future.rng), started = ...future.startTime, 
[18:04:01.742]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:01.742]             version = "1.8"), class = "FutureResult")
[18:04:01.742]     }, finally = {
[18:04:01.742]         if (!identical(...future.workdir, getwd())) 
[18:04:01.742]             setwd(...future.workdir)
[18:04:01.742]         {
[18:04:01.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:01.742]                 ...future.oldOptions$nwarnings <- NULL
[18:04:01.742]             }
[18:04:01.742]             base::options(...future.oldOptions)
[18:04:01.742]             if (.Platform$OS.type == "windows") {
[18:04:01.742]                 old_names <- names(...future.oldEnvVars)
[18:04:01.742]                 envs <- base::Sys.getenv()
[18:04:01.742]                 names <- names(envs)
[18:04:01.742]                 common <- intersect(names, old_names)
[18:04:01.742]                 added <- setdiff(names, old_names)
[18:04:01.742]                 removed <- setdiff(old_names, names)
[18:04:01.742]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:01.742]                   envs[common]]
[18:04:01.742]                 NAMES <- toupper(changed)
[18:04:01.742]                 args <- list()
[18:04:01.742]                 for (kk in seq_along(NAMES)) {
[18:04:01.742]                   name <- changed[[kk]]
[18:04:01.742]                   NAME <- NAMES[[kk]]
[18:04:01.742]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.742]                     next
[18:04:01.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.742]                 }
[18:04:01.742]                 NAMES <- toupper(added)
[18:04:01.742]                 for (kk in seq_along(NAMES)) {
[18:04:01.742]                   name <- added[[kk]]
[18:04:01.742]                   NAME <- NAMES[[kk]]
[18:04:01.742]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.742]                     next
[18:04:01.742]                   args[[name]] <- ""
[18:04:01.742]                 }
[18:04:01.742]                 NAMES <- toupper(removed)
[18:04:01.742]                 for (kk in seq_along(NAMES)) {
[18:04:01.742]                   name <- removed[[kk]]
[18:04:01.742]                   NAME <- NAMES[[kk]]
[18:04:01.742]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.742]                     next
[18:04:01.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.742]                 }
[18:04:01.742]                 if (length(args) > 0) 
[18:04:01.742]                   base::do.call(base::Sys.setenv, args = args)
[18:04:01.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:01.742]             }
[18:04:01.742]             else {
[18:04:01.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:01.742]             }
[18:04:01.742]             {
[18:04:01.742]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:01.742]                   0L) {
[18:04:01.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:01.742]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:01.742]                   base::options(opts)
[18:04:01.742]                 }
[18:04:01.742]                 {
[18:04:01.742]                   {
[18:04:01.742]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:01.742]                     NULL
[18:04:01.742]                   }
[18:04:01.742]                   options(future.plan = NULL)
[18:04:01.742]                   if (is.na(NA_character_)) 
[18:04:01.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:01.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:01.742]                     .init = FALSE)
[18:04:01.742]                 }
[18:04:01.742]             }
[18:04:01.742]         }
[18:04:01.742]     })
[18:04:01.742]     if (TRUE) {
[18:04:01.742]         base::sink(type = "output", split = FALSE)
[18:04:01.742]         if (TRUE) {
[18:04:01.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:01.742]         }
[18:04:01.742]         else {
[18:04:01.742]             ...future.result["stdout"] <- base::list(NULL)
[18:04:01.742]         }
[18:04:01.742]         base::close(...future.stdout)
[18:04:01.742]         ...future.stdout <- NULL
[18:04:01.742]     }
[18:04:01.742]     ...future.result$conditions <- ...future.conditions
[18:04:01.742]     ...future.result$finished <- base::Sys.time()
[18:04:01.742]     ...future.result
[18:04:01.742] }
[18:04:01.747] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:04:01.748] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:04:01.748] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:04:01.749] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:04:01.750] MultisessionFuture started
[18:04:01.750] - Launch lazy future ... done
[18:04:01.750] run() for ‘MultisessionFuture’ ... done
[18:04:01.751] getGlobalsAndPackages() ...
[18:04:01.751] Searching for globals...
[18:04:01.754] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:04:01.755] Searching for globals ... DONE
[18:04:01.755] Resolving globals: FALSE
[18:04:01.756] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:01.757] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:01.757] - globals: [1] ‘ii’
[18:04:01.757] 
[18:04:01.757] getGlobalsAndPackages() ... DONE
[18:04:01.758] run() for ‘Future’ ...
[18:04:01.758] - state: ‘created’
[18:04:01.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:01.780] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:01.781] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:01.781]   - Field: ‘node’
[18:04:01.781]   - Field: ‘label’
[18:04:01.781]   - Field: ‘local’
[18:04:01.782]   - Field: ‘owner’
[18:04:01.782]   - Field: ‘envir’
[18:04:01.782]   - Field: ‘workers’
[18:04:01.782]   - Field: ‘packages’
[18:04:01.782]   - Field: ‘gc’
[18:04:01.783]   - Field: ‘conditions’
[18:04:01.783]   - Field: ‘persistent’
[18:04:01.783]   - Field: ‘expr’
[18:04:01.783]   - Field: ‘uuid’
[18:04:01.783]   - Field: ‘seed’
[18:04:01.784]   - Field: ‘version’
[18:04:01.784]   - Field: ‘result’
[18:04:01.784]   - Field: ‘asynchronous’
[18:04:01.784]   - Field: ‘calls’
[18:04:01.784]   - Field: ‘globals’
[18:04:01.785]   - Field: ‘stdout’
[18:04:01.785]   - Field: ‘earlySignal’
[18:04:01.785]   - Field: ‘lazy’
[18:04:01.785]   - Field: ‘state’
[18:04:01.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:01.786] - Launch lazy future ...
[18:04:01.786] Packages needed by the future expression (n = 0): <none>
[18:04:01.786] Packages needed by future strategies (n = 0): <none>
[18:04:01.787] {
[18:04:01.787]     {
[18:04:01.787]         {
[18:04:01.787]             ...future.startTime <- base::Sys.time()
[18:04:01.787]             {
[18:04:01.787]                 {
[18:04:01.787]                   {
[18:04:01.787]                     {
[18:04:01.787]                       base::local({
[18:04:01.787]                         has_future <- base::requireNamespace("future", 
[18:04:01.787]                           quietly = TRUE)
[18:04:01.787]                         if (has_future) {
[18:04:01.787]                           ns <- base::getNamespace("future")
[18:04:01.787]                           version <- ns[[".package"]][["version"]]
[18:04:01.787]                           if (is.null(version)) 
[18:04:01.787]                             version <- utils::packageVersion("future")
[18:04:01.787]                         }
[18:04:01.787]                         else {
[18:04:01.787]                           version <- NULL
[18:04:01.787]                         }
[18:04:01.787]                         if (!has_future || version < "1.8.0") {
[18:04:01.787]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:01.787]                             "", base::R.version$version.string), 
[18:04:01.787]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:01.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:01.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:01.787]                               "release", "version")], collapse = " "), 
[18:04:01.787]                             hostname = base::Sys.info()[["nodename"]])
[18:04:01.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:01.787]                             info)
[18:04:01.787]                           info <- base::paste(info, collapse = "; ")
[18:04:01.787]                           if (!has_future) {
[18:04:01.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:01.787]                               info)
[18:04:01.787]                           }
[18:04:01.787]                           else {
[18:04:01.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:01.787]                               info, version)
[18:04:01.787]                           }
[18:04:01.787]                           base::stop(msg)
[18:04:01.787]                         }
[18:04:01.787]                       })
[18:04:01.787]                     }
[18:04:01.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:01.787]                     base::options(mc.cores = 1L)
[18:04:01.787]                   }
[18:04:01.787]                   ...future.strategy.old <- future::plan("list")
[18:04:01.787]                   options(future.plan = NULL)
[18:04:01.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:01.787]                 }
[18:04:01.787]                 ...future.workdir <- getwd()
[18:04:01.787]             }
[18:04:01.787]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:01.787]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:01.787]         }
[18:04:01.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:01.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:01.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:01.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:01.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:01.787]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:01.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:01.787]             base::names(...future.oldOptions))
[18:04:01.787]     }
[18:04:01.787]     if (FALSE) {
[18:04:01.787]     }
[18:04:01.787]     else {
[18:04:01.787]         if (TRUE) {
[18:04:01.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:01.787]                 open = "w")
[18:04:01.787]         }
[18:04:01.787]         else {
[18:04:01.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:01.787]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:01.787]         }
[18:04:01.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:01.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:01.787]             base::sink(type = "output", split = FALSE)
[18:04:01.787]             base::close(...future.stdout)
[18:04:01.787]         }, add = TRUE)
[18:04:01.787]     }
[18:04:01.787]     ...future.frame <- base::sys.nframe()
[18:04:01.787]     ...future.conditions <- base::list()
[18:04:01.787]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:01.787]     if (FALSE) {
[18:04:01.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:01.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:01.787]     }
[18:04:01.787]     ...future.result <- base::tryCatch({
[18:04:01.787]         base::withCallingHandlers({
[18:04:01.787]             ...future.value <- base::withVisible(base::local({
[18:04:01.787]                 ...future.makeSendCondition <- base::local({
[18:04:01.787]                   sendCondition <- NULL
[18:04:01.787]                   function(frame = 1L) {
[18:04:01.787]                     if (is.function(sendCondition)) 
[18:04:01.787]                       return(sendCondition)
[18:04:01.787]                     ns <- getNamespace("parallel")
[18:04:01.787]                     if (exists("sendData", mode = "function", 
[18:04:01.787]                       envir = ns)) {
[18:04:01.787]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:01.787]                         envir = ns)
[18:04:01.787]                       envir <- sys.frame(frame)
[18:04:01.787]                       master <- NULL
[18:04:01.787]                       while (!identical(envir, .GlobalEnv) && 
[18:04:01.787]                         !identical(envir, emptyenv())) {
[18:04:01.787]                         if (exists("master", mode = "list", envir = envir, 
[18:04:01.787]                           inherits = FALSE)) {
[18:04:01.787]                           master <- get("master", mode = "list", 
[18:04:01.787]                             envir = envir, inherits = FALSE)
[18:04:01.787]                           if (inherits(master, c("SOCKnode", 
[18:04:01.787]                             "SOCK0node"))) {
[18:04:01.787]                             sendCondition <<- function(cond) {
[18:04:01.787]                               data <- list(type = "VALUE", value = cond, 
[18:04:01.787]                                 success = TRUE)
[18:04:01.787]                               parallel_sendData(master, data)
[18:04:01.787]                             }
[18:04:01.787]                             return(sendCondition)
[18:04:01.787]                           }
[18:04:01.787]                         }
[18:04:01.787]                         frame <- frame + 1L
[18:04:01.787]                         envir <- sys.frame(frame)
[18:04:01.787]                       }
[18:04:01.787]                     }
[18:04:01.787]                     sendCondition <<- function(cond) NULL
[18:04:01.787]                   }
[18:04:01.787]                 })
[18:04:01.787]                 withCallingHandlers({
[18:04:01.787]                   {
[18:04:01.787]                     if (ii%%2 == 0) 
[18:04:01.787]                       stop("Woops!")
[18:04:01.787]                     ii
[18:04:01.787]                   }
[18:04:01.787]                 }, immediateCondition = function(cond) {
[18:04:01.787]                   sendCondition <- ...future.makeSendCondition()
[18:04:01.787]                   sendCondition(cond)
[18:04:01.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.787]                   {
[18:04:01.787]                     inherits <- base::inherits
[18:04:01.787]                     invokeRestart <- base::invokeRestart
[18:04:01.787]                     is.null <- base::is.null
[18:04:01.787]                     muffled <- FALSE
[18:04:01.787]                     if (inherits(cond, "message")) {
[18:04:01.787]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:01.787]                       if (muffled) 
[18:04:01.787]                         invokeRestart("muffleMessage")
[18:04:01.787]                     }
[18:04:01.787]                     else if (inherits(cond, "warning")) {
[18:04:01.787]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:01.787]                       if (muffled) 
[18:04:01.787]                         invokeRestart("muffleWarning")
[18:04:01.787]                     }
[18:04:01.787]                     else if (inherits(cond, "condition")) {
[18:04:01.787]                       if (!is.null(pattern)) {
[18:04:01.787]                         computeRestarts <- base::computeRestarts
[18:04:01.787]                         grepl <- base::grepl
[18:04:01.787]                         restarts <- computeRestarts(cond)
[18:04:01.787]                         for (restart in restarts) {
[18:04:01.787]                           name <- restart$name
[18:04:01.787]                           if (is.null(name)) 
[18:04:01.787]                             next
[18:04:01.787]                           if (!grepl(pattern, name)) 
[18:04:01.787]                             next
[18:04:01.787]                           invokeRestart(restart)
[18:04:01.787]                           muffled <- TRUE
[18:04:01.787]                           break
[18:04:01.787]                         }
[18:04:01.787]                       }
[18:04:01.787]                     }
[18:04:01.787]                     invisible(muffled)
[18:04:01.787]                   }
[18:04:01.787]                   muffleCondition(cond)
[18:04:01.787]                 })
[18:04:01.787]             }))
[18:04:01.787]             future::FutureResult(value = ...future.value$value, 
[18:04:01.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.787]                   ...future.rng), globalenv = if (FALSE) 
[18:04:01.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:01.787]                     ...future.globalenv.names))
[18:04:01.787]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:01.787]         }, condition = base::local({
[18:04:01.787]             c <- base::c
[18:04:01.787]             inherits <- base::inherits
[18:04:01.787]             invokeRestart <- base::invokeRestart
[18:04:01.787]             length <- base::length
[18:04:01.787]             list <- base::list
[18:04:01.787]             seq.int <- base::seq.int
[18:04:01.787]             signalCondition <- base::signalCondition
[18:04:01.787]             sys.calls <- base::sys.calls
[18:04:01.787]             `[[` <- base::`[[`
[18:04:01.787]             `+` <- base::`+`
[18:04:01.787]             `<<-` <- base::`<<-`
[18:04:01.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:01.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:01.787]                   3L)]
[18:04:01.787]             }
[18:04:01.787]             function(cond) {
[18:04:01.787]                 is_error <- inherits(cond, "error")
[18:04:01.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:01.787]                   NULL)
[18:04:01.787]                 if (is_error) {
[18:04:01.787]                   sessionInformation <- function() {
[18:04:01.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:01.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:01.787]                       search = base::search(), system = base::Sys.info())
[18:04:01.787]                   }
[18:04:01.787]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:01.787]                     cond$call), session = sessionInformation(), 
[18:04:01.787]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:01.787]                   signalCondition(cond)
[18:04:01.787]                 }
[18:04:01.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:01.787]                 "immediateCondition"))) {
[18:04:01.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:01.787]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:01.787]                   if (TRUE && !signal) {
[18:04:01.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.787]                     {
[18:04:01.787]                       inherits <- base::inherits
[18:04:01.787]                       invokeRestart <- base::invokeRestart
[18:04:01.787]                       is.null <- base::is.null
[18:04:01.787]                       muffled <- FALSE
[18:04:01.787]                       if (inherits(cond, "message")) {
[18:04:01.787]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.787]                         if (muffled) 
[18:04:01.787]                           invokeRestart("muffleMessage")
[18:04:01.787]                       }
[18:04:01.787]                       else if (inherits(cond, "warning")) {
[18:04:01.787]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.787]                         if (muffled) 
[18:04:01.787]                           invokeRestart("muffleWarning")
[18:04:01.787]                       }
[18:04:01.787]                       else if (inherits(cond, "condition")) {
[18:04:01.787]                         if (!is.null(pattern)) {
[18:04:01.787]                           computeRestarts <- base::computeRestarts
[18:04:01.787]                           grepl <- base::grepl
[18:04:01.787]                           restarts <- computeRestarts(cond)
[18:04:01.787]                           for (restart in restarts) {
[18:04:01.787]                             name <- restart$name
[18:04:01.787]                             if (is.null(name)) 
[18:04:01.787]                               next
[18:04:01.787]                             if (!grepl(pattern, name)) 
[18:04:01.787]                               next
[18:04:01.787]                             invokeRestart(restart)
[18:04:01.787]                             muffled <- TRUE
[18:04:01.787]                             break
[18:04:01.787]                           }
[18:04:01.787]                         }
[18:04:01.787]                       }
[18:04:01.787]                       invisible(muffled)
[18:04:01.787]                     }
[18:04:01.787]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.787]                   }
[18:04:01.787]                 }
[18:04:01.787]                 else {
[18:04:01.787]                   if (TRUE) {
[18:04:01.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.787]                     {
[18:04:01.787]                       inherits <- base::inherits
[18:04:01.787]                       invokeRestart <- base::invokeRestart
[18:04:01.787]                       is.null <- base::is.null
[18:04:01.787]                       muffled <- FALSE
[18:04:01.787]                       if (inherits(cond, "message")) {
[18:04:01.787]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.787]                         if (muffled) 
[18:04:01.787]                           invokeRestart("muffleMessage")
[18:04:01.787]                       }
[18:04:01.787]                       else if (inherits(cond, "warning")) {
[18:04:01.787]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.787]                         if (muffled) 
[18:04:01.787]                           invokeRestart("muffleWarning")
[18:04:01.787]                       }
[18:04:01.787]                       else if (inherits(cond, "condition")) {
[18:04:01.787]                         if (!is.null(pattern)) {
[18:04:01.787]                           computeRestarts <- base::computeRestarts
[18:04:01.787]                           grepl <- base::grepl
[18:04:01.787]                           restarts <- computeRestarts(cond)
[18:04:01.787]                           for (restart in restarts) {
[18:04:01.787]                             name <- restart$name
[18:04:01.787]                             if (is.null(name)) 
[18:04:01.787]                               next
[18:04:01.787]                             if (!grepl(pattern, name)) 
[18:04:01.787]                               next
[18:04:01.787]                             invokeRestart(restart)
[18:04:01.787]                             muffled <- TRUE
[18:04:01.787]                             break
[18:04:01.787]                           }
[18:04:01.787]                         }
[18:04:01.787]                       }
[18:04:01.787]                       invisible(muffled)
[18:04:01.787]                     }
[18:04:01.787]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.787]                   }
[18:04:01.787]                 }
[18:04:01.787]             }
[18:04:01.787]         }))
[18:04:01.787]     }, error = function(ex) {
[18:04:01.787]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:01.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.787]                 ...future.rng), started = ...future.startTime, 
[18:04:01.787]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:01.787]             version = "1.8"), class = "FutureResult")
[18:04:01.787]     }, finally = {
[18:04:01.787]         if (!identical(...future.workdir, getwd())) 
[18:04:01.787]             setwd(...future.workdir)
[18:04:01.787]         {
[18:04:01.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:01.787]                 ...future.oldOptions$nwarnings <- NULL
[18:04:01.787]             }
[18:04:01.787]             base::options(...future.oldOptions)
[18:04:01.787]             if (.Platform$OS.type == "windows") {
[18:04:01.787]                 old_names <- names(...future.oldEnvVars)
[18:04:01.787]                 envs <- base::Sys.getenv()
[18:04:01.787]                 names <- names(envs)
[18:04:01.787]                 common <- intersect(names, old_names)
[18:04:01.787]                 added <- setdiff(names, old_names)
[18:04:01.787]                 removed <- setdiff(old_names, names)
[18:04:01.787]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:01.787]                   envs[common]]
[18:04:01.787]                 NAMES <- toupper(changed)
[18:04:01.787]                 args <- list()
[18:04:01.787]                 for (kk in seq_along(NAMES)) {
[18:04:01.787]                   name <- changed[[kk]]
[18:04:01.787]                   NAME <- NAMES[[kk]]
[18:04:01.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.787]                     next
[18:04:01.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.787]                 }
[18:04:01.787]                 NAMES <- toupper(added)
[18:04:01.787]                 for (kk in seq_along(NAMES)) {
[18:04:01.787]                   name <- added[[kk]]
[18:04:01.787]                   NAME <- NAMES[[kk]]
[18:04:01.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.787]                     next
[18:04:01.787]                   args[[name]] <- ""
[18:04:01.787]                 }
[18:04:01.787]                 NAMES <- toupper(removed)
[18:04:01.787]                 for (kk in seq_along(NAMES)) {
[18:04:01.787]                   name <- removed[[kk]]
[18:04:01.787]                   NAME <- NAMES[[kk]]
[18:04:01.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.787]                     next
[18:04:01.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.787]                 }
[18:04:01.787]                 if (length(args) > 0) 
[18:04:01.787]                   base::do.call(base::Sys.setenv, args = args)
[18:04:01.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:01.787]             }
[18:04:01.787]             else {
[18:04:01.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:01.787]             }
[18:04:01.787]             {
[18:04:01.787]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:01.787]                   0L) {
[18:04:01.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:01.787]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:01.787]                   base::options(opts)
[18:04:01.787]                 }
[18:04:01.787]                 {
[18:04:01.787]                   {
[18:04:01.787]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:01.787]                     NULL
[18:04:01.787]                   }
[18:04:01.787]                   options(future.plan = NULL)
[18:04:01.787]                   if (is.na(NA_character_)) 
[18:04:01.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:01.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:01.787]                     .init = FALSE)
[18:04:01.787]                 }
[18:04:01.787]             }
[18:04:01.787]         }
[18:04:01.787]     })
[18:04:01.787]     if (TRUE) {
[18:04:01.787]         base::sink(type = "output", split = FALSE)
[18:04:01.787]         if (TRUE) {
[18:04:01.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:01.787]         }
[18:04:01.787]         else {
[18:04:01.787]             ...future.result["stdout"] <- base::list(NULL)
[18:04:01.787]         }
[18:04:01.787]         base::close(...future.stdout)
[18:04:01.787]         ...future.stdout <- NULL
[18:04:01.787]     }
[18:04:01.787]     ...future.result$conditions <- ...future.conditions
[18:04:01.787]     ...future.result$finished <- base::Sys.time()
[18:04:01.787]     ...future.result
[18:04:01.787] }
[18:04:01.887] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:04:01.887] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[18:04:01.888] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[18:04:01.888] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:04:01.889] MultisessionFuture started
[18:04:01.889] - Launch lazy future ... done
[18:04:01.890] run() for ‘MultisessionFuture’ ... done
[18:04:01.890] getGlobalsAndPackages() ...
[18:04:01.891] Searching for globals...
[18:04:01.894] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[18:04:01.894] Searching for globals ... DONE
[18:04:01.895] Resolving globals: FALSE
[18:04:01.896] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:01.897] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:01.897] - globals: [1] ‘ii’
[18:04:01.897] 
[18:04:01.897] getGlobalsAndPackages() ... DONE
[18:04:01.898] run() for ‘Future’ ...
[18:04:01.898] - state: ‘created’
[18:04:01.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:01.925] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:01.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:01.925]   - Field: ‘node’
[18:04:01.926]   - Field: ‘label’
[18:04:01.926]   - Field: ‘local’
[18:04:01.926]   - Field: ‘owner’
[18:04:01.926]   - Field: ‘envir’
[18:04:01.927]   - Field: ‘workers’
[18:04:01.927]   - Field: ‘packages’
[18:04:01.927]   - Field: ‘gc’
[18:04:01.927]   - Field: ‘conditions’
[18:04:01.928]   - Field: ‘persistent’
[18:04:01.928]   - Field: ‘expr’
[18:04:01.928]   - Field: ‘uuid’
[18:04:01.928]   - Field: ‘seed’
[18:04:01.929]   - Field: ‘version’
[18:04:01.929]   - Field: ‘result’
[18:04:01.929]   - Field: ‘asynchronous’
[18:04:01.929]   - Field: ‘calls’
[18:04:01.929]   - Field: ‘globals’
[18:04:01.930]   - Field: ‘stdout’
[18:04:01.930]   - Field: ‘earlySignal’
[18:04:01.930]   - Field: ‘lazy’
[18:04:01.930]   - Field: ‘state’
[18:04:01.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:01.931] - Launch lazy future ...
[18:04:01.931] Packages needed by the future expression (n = 0): <none>
[18:04:01.932] Packages needed by future strategies (n = 0): <none>
[18:04:01.933] {
[18:04:01.933]     {
[18:04:01.933]         {
[18:04:01.933]             ...future.startTime <- base::Sys.time()
[18:04:01.933]             {
[18:04:01.933]                 {
[18:04:01.933]                   {
[18:04:01.933]                     {
[18:04:01.933]                       base::local({
[18:04:01.933]                         has_future <- base::requireNamespace("future", 
[18:04:01.933]                           quietly = TRUE)
[18:04:01.933]                         if (has_future) {
[18:04:01.933]                           ns <- base::getNamespace("future")
[18:04:01.933]                           version <- ns[[".package"]][["version"]]
[18:04:01.933]                           if (is.null(version)) 
[18:04:01.933]                             version <- utils::packageVersion("future")
[18:04:01.933]                         }
[18:04:01.933]                         else {
[18:04:01.933]                           version <- NULL
[18:04:01.933]                         }
[18:04:01.933]                         if (!has_future || version < "1.8.0") {
[18:04:01.933]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:01.933]                             "", base::R.version$version.string), 
[18:04:01.933]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:01.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:01.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:01.933]                               "release", "version")], collapse = " "), 
[18:04:01.933]                             hostname = base::Sys.info()[["nodename"]])
[18:04:01.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:01.933]                             info)
[18:04:01.933]                           info <- base::paste(info, collapse = "; ")
[18:04:01.933]                           if (!has_future) {
[18:04:01.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:01.933]                               info)
[18:04:01.933]                           }
[18:04:01.933]                           else {
[18:04:01.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:01.933]                               info, version)
[18:04:01.933]                           }
[18:04:01.933]                           base::stop(msg)
[18:04:01.933]                         }
[18:04:01.933]                       })
[18:04:01.933]                     }
[18:04:01.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:01.933]                     base::options(mc.cores = 1L)
[18:04:01.933]                   }
[18:04:01.933]                   ...future.strategy.old <- future::plan("list")
[18:04:01.933]                   options(future.plan = NULL)
[18:04:01.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:01.933]                 }
[18:04:01.933]                 ...future.workdir <- getwd()
[18:04:01.933]             }
[18:04:01.933]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:01.933]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:01.933]         }
[18:04:01.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:01.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:01.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:01.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:01.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:01.933]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:01.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:01.933]             base::names(...future.oldOptions))
[18:04:01.933]     }
[18:04:01.933]     if (FALSE) {
[18:04:01.933]     }
[18:04:01.933]     else {
[18:04:01.933]         if (TRUE) {
[18:04:01.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:01.933]                 open = "w")
[18:04:01.933]         }
[18:04:01.933]         else {
[18:04:01.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:01.933]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:01.933]         }
[18:04:01.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:01.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:01.933]             base::sink(type = "output", split = FALSE)
[18:04:01.933]             base::close(...future.stdout)
[18:04:01.933]         }, add = TRUE)
[18:04:01.933]     }
[18:04:01.933]     ...future.frame <- base::sys.nframe()
[18:04:01.933]     ...future.conditions <- base::list()
[18:04:01.933]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:01.933]     if (FALSE) {
[18:04:01.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:01.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:01.933]     }
[18:04:01.933]     ...future.result <- base::tryCatch({
[18:04:01.933]         base::withCallingHandlers({
[18:04:01.933]             ...future.value <- base::withVisible(base::local({
[18:04:01.933]                 ...future.makeSendCondition <- base::local({
[18:04:01.933]                   sendCondition <- NULL
[18:04:01.933]                   function(frame = 1L) {
[18:04:01.933]                     if (is.function(sendCondition)) 
[18:04:01.933]                       return(sendCondition)
[18:04:01.933]                     ns <- getNamespace("parallel")
[18:04:01.933]                     if (exists("sendData", mode = "function", 
[18:04:01.933]                       envir = ns)) {
[18:04:01.933]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:01.933]                         envir = ns)
[18:04:01.933]                       envir <- sys.frame(frame)
[18:04:01.933]                       master <- NULL
[18:04:01.933]                       while (!identical(envir, .GlobalEnv) && 
[18:04:01.933]                         !identical(envir, emptyenv())) {
[18:04:01.933]                         if (exists("master", mode = "list", envir = envir, 
[18:04:01.933]                           inherits = FALSE)) {
[18:04:01.933]                           master <- get("master", mode = "list", 
[18:04:01.933]                             envir = envir, inherits = FALSE)
[18:04:01.933]                           if (inherits(master, c("SOCKnode", 
[18:04:01.933]                             "SOCK0node"))) {
[18:04:01.933]                             sendCondition <<- function(cond) {
[18:04:01.933]                               data <- list(type = "VALUE", value = cond, 
[18:04:01.933]                                 success = TRUE)
[18:04:01.933]                               parallel_sendData(master, data)
[18:04:01.933]                             }
[18:04:01.933]                             return(sendCondition)
[18:04:01.933]                           }
[18:04:01.933]                         }
[18:04:01.933]                         frame <- frame + 1L
[18:04:01.933]                         envir <- sys.frame(frame)
[18:04:01.933]                       }
[18:04:01.933]                     }
[18:04:01.933]                     sendCondition <<- function(cond) NULL
[18:04:01.933]                   }
[18:04:01.933]                 })
[18:04:01.933]                 withCallingHandlers({
[18:04:01.933]                   {
[18:04:01.933]                     if (ii%%2 == 0) 
[18:04:01.933]                       stop("Woops!")
[18:04:01.933]                     ii
[18:04:01.933]                   }
[18:04:01.933]                 }, immediateCondition = function(cond) {
[18:04:01.933]                   sendCondition <- ...future.makeSendCondition()
[18:04:01.933]                   sendCondition(cond)
[18:04:01.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.933]                   {
[18:04:01.933]                     inherits <- base::inherits
[18:04:01.933]                     invokeRestart <- base::invokeRestart
[18:04:01.933]                     is.null <- base::is.null
[18:04:01.933]                     muffled <- FALSE
[18:04:01.933]                     if (inherits(cond, "message")) {
[18:04:01.933]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:01.933]                       if (muffled) 
[18:04:01.933]                         invokeRestart("muffleMessage")
[18:04:01.933]                     }
[18:04:01.933]                     else if (inherits(cond, "warning")) {
[18:04:01.933]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:01.933]                       if (muffled) 
[18:04:01.933]                         invokeRestart("muffleWarning")
[18:04:01.933]                     }
[18:04:01.933]                     else if (inherits(cond, "condition")) {
[18:04:01.933]                       if (!is.null(pattern)) {
[18:04:01.933]                         computeRestarts <- base::computeRestarts
[18:04:01.933]                         grepl <- base::grepl
[18:04:01.933]                         restarts <- computeRestarts(cond)
[18:04:01.933]                         for (restart in restarts) {
[18:04:01.933]                           name <- restart$name
[18:04:01.933]                           if (is.null(name)) 
[18:04:01.933]                             next
[18:04:01.933]                           if (!grepl(pattern, name)) 
[18:04:01.933]                             next
[18:04:01.933]                           invokeRestart(restart)
[18:04:01.933]                           muffled <- TRUE
[18:04:01.933]                           break
[18:04:01.933]                         }
[18:04:01.933]                       }
[18:04:01.933]                     }
[18:04:01.933]                     invisible(muffled)
[18:04:01.933]                   }
[18:04:01.933]                   muffleCondition(cond)
[18:04:01.933]                 })
[18:04:01.933]             }))
[18:04:01.933]             future::FutureResult(value = ...future.value$value, 
[18:04:01.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.933]                   ...future.rng), globalenv = if (FALSE) 
[18:04:01.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:01.933]                     ...future.globalenv.names))
[18:04:01.933]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:01.933]         }, condition = base::local({
[18:04:01.933]             c <- base::c
[18:04:01.933]             inherits <- base::inherits
[18:04:01.933]             invokeRestart <- base::invokeRestart
[18:04:01.933]             length <- base::length
[18:04:01.933]             list <- base::list
[18:04:01.933]             seq.int <- base::seq.int
[18:04:01.933]             signalCondition <- base::signalCondition
[18:04:01.933]             sys.calls <- base::sys.calls
[18:04:01.933]             `[[` <- base::`[[`
[18:04:01.933]             `+` <- base::`+`
[18:04:01.933]             `<<-` <- base::`<<-`
[18:04:01.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:01.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:01.933]                   3L)]
[18:04:01.933]             }
[18:04:01.933]             function(cond) {
[18:04:01.933]                 is_error <- inherits(cond, "error")
[18:04:01.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:01.933]                   NULL)
[18:04:01.933]                 if (is_error) {
[18:04:01.933]                   sessionInformation <- function() {
[18:04:01.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:01.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:01.933]                       search = base::search(), system = base::Sys.info())
[18:04:01.933]                   }
[18:04:01.933]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:01.933]                     cond$call), session = sessionInformation(), 
[18:04:01.933]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:01.933]                   signalCondition(cond)
[18:04:01.933]                 }
[18:04:01.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:01.933]                 "immediateCondition"))) {
[18:04:01.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:01.933]                   ...future.conditions[[length(...future.conditions) + 
[18:04:01.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:01.933]                   if (TRUE && !signal) {
[18:04:01.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.933]                     {
[18:04:01.933]                       inherits <- base::inherits
[18:04:01.933]                       invokeRestart <- base::invokeRestart
[18:04:01.933]                       is.null <- base::is.null
[18:04:01.933]                       muffled <- FALSE
[18:04:01.933]                       if (inherits(cond, "message")) {
[18:04:01.933]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.933]                         if (muffled) 
[18:04:01.933]                           invokeRestart("muffleMessage")
[18:04:01.933]                       }
[18:04:01.933]                       else if (inherits(cond, "warning")) {
[18:04:01.933]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.933]                         if (muffled) 
[18:04:01.933]                           invokeRestart("muffleWarning")
[18:04:01.933]                       }
[18:04:01.933]                       else if (inherits(cond, "condition")) {
[18:04:01.933]                         if (!is.null(pattern)) {
[18:04:01.933]                           computeRestarts <- base::computeRestarts
[18:04:01.933]                           grepl <- base::grepl
[18:04:01.933]                           restarts <- computeRestarts(cond)
[18:04:01.933]                           for (restart in restarts) {
[18:04:01.933]                             name <- restart$name
[18:04:01.933]                             if (is.null(name)) 
[18:04:01.933]                               next
[18:04:01.933]                             if (!grepl(pattern, name)) 
[18:04:01.933]                               next
[18:04:01.933]                             invokeRestart(restart)
[18:04:01.933]                             muffled <- TRUE
[18:04:01.933]                             break
[18:04:01.933]                           }
[18:04:01.933]                         }
[18:04:01.933]                       }
[18:04:01.933]                       invisible(muffled)
[18:04:01.933]                     }
[18:04:01.933]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.933]                   }
[18:04:01.933]                 }
[18:04:01.933]                 else {
[18:04:01.933]                   if (TRUE) {
[18:04:01.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:01.933]                     {
[18:04:01.933]                       inherits <- base::inherits
[18:04:01.933]                       invokeRestart <- base::invokeRestart
[18:04:01.933]                       is.null <- base::is.null
[18:04:01.933]                       muffled <- FALSE
[18:04:01.933]                       if (inherits(cond, "message")) {
[18:04:01.933]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:01.933]                         if (muffled) 
[18:04:01.933]                           invokeRestart("muffleMessage")
[18:04:01.933]                       }
[18:04:01.933]                       else if (inherits(cond, "warning")) {
[18:04:01.933]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:01.933]                         if (muffled) 
[18:04:01.933]                           invokeRestart("muffleWarning")
[18:04:01.933]                       }
[18:04:01.933]                       else if (inherits(cond, "condition")) {
[18:04:01.933]                         if (!is.null(pattern)) {
[18:04:01.933]                           computeRestarts <- base::computeRestarts
[18:04:01.933]                           grepl <- base::grepl
[18:04:01.933]                           restarts <- computeRestarts(cond)
[18:04:01.933]                           for (restart in restarts) {
[18:04:01.933]                             name <- restart$name
[18:04:01.933]                             if (is.null(name)) 
[18:04:01.933]                               next
[18:04:01.933]                             if (!grepl(pattern, name)) 
[18:04:01.933]                               next
[18:04:01.933]                             invokeRestart(restart)
[18:04:01.933]                             muffled <- TRUE
[18:04:01.933]                             break
[18:04:01.933]                           }
[18:04:01.933]                         }
[18:04:01.933]                       }
[18:04:01.933]                       invisible(muffled)
[18:04:01.933]                     }
[18:04:01.933]                     muffleCondition(cond, pattern = "^muffle")
[18:04:01.933]                   }
[18:04:01.933]                 }
[18:04:01.933]             }
[18:04:01.933]         }))
[18:04:01.933]     }, error = function(ex) {
[18:04:01.933]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:01.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:01.933]                 ...future.rng), started = ...future.startTime, 
[18:04:01.933]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:01.933]             version = "1.8"), class = "FutureResult")
[18:04:01.933]     }, finally = {
[18:04:01.933]         if (!identical(...future.workdir, getwd())) 
[18:04:01.933]             setwd(...future.workdir)
[18:04:01.933]         {
[18:04:01.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:01.933]                 ...future.oldOptions$nwarnings <- NULL
[18:04:01.933]             }
[18:04:01.933]             base::options(...future.oldOptions)
[18:04:01.933]             if (.Platform$OS.type == "windows") {
[18:04:01.933]                 old_names <- names(...future.oldEnvVars)
[18:04:01.933]                 envs <- base::Sys.getenv()
[18:04:01.933]                 names <- names(envs)
[18:04:01.933]                 common <- intersect(names, old_names)
[18:04:01.933]                 added <- setdiff(names, old_names)
[18:04:01.933]                 removed <- setdiff(old_names, names)
[18:04:01.933]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:01.933]                   envs[common]]
[18:04:01.933]                 NAMES <- toupper(changed)
[18:04:01.933]                 args <- list()
[18:04:01.933]                 for (kk in seq_along(NAMES)) {
[18:04:01.933]                   name <- changed[[kk]]
[18:04:01.933]                   NAME <- NAMES[[kk]]
[18:04:01.933]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.933]                     next
[18:04:01.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.933]                 }
[18:04:01.933]                 NAMES <- toupper(added)
[18:04:01.933]                 for (kk in seq_along(NAMES)) {
[18:04:01.933]                   name <- added[[kk]]
[18:04:01.933]                   NAME <- NAMES[[kk]]
[18:04:01.933]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.933]                     next
[18:04:01.933]                   args[[name]] <- ""
[18:04:01.933]                 }
[18:04:01.933]                 NAMES <- toupper(removed)
[18:04:01.933]                 for (kk in seq_along(NAMES)) {
[18:04:01.933]                   name <- removed[[kk]]
[18:04:01.933]                   NAME <- NAMES[[kk]]
[18:04:01.933]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:01.933]                     next
[18:04:01.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:01.933]                 }
[18:04:01.933]                 if (length(args) > 0) 
[18:04:01.933]                   base::do.call(base::Sys.setenv, args = args)
[18:04:01.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:01.933]             }
[18:04:01.933]             else {
[18:04:01.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:01.933]             }
[18:04:01.933]             {
[18:04:01.933]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:01.933]                   0L) {
[18:04:01.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:01.933]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:01.933]                   base::options(opts)
[18:04:01.933]                 }
[18:04:01.933]                 {
[18:04:01.933]                   {
[18:04:01.933]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:01.933]                     NULL
[18:04:01.933]                   }
[18:04:01.933]                   options(future.plan = NULL)
[18:04:01.933]                   if (is.na(NA_character_)) 
[18:04:01.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:01.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:01.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:01.933]                     .init = FALSE)
[18:04:01.933]                 }
[18:04:01.933]             }
[18:04:01.933]         }
[18:04:01.933]     })
[18:04:01.933]     if (TRUE) {
[18:04:01.933]         base::sink(type = "output", split = FALSE)
[18:04:01.933]         if (TRUE) {
[18:04:01.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:01.933]         }
[18:04:01.933]         else {
[18:04:01.933]             ...future.result["stdout"] <- base::list(NULL)
[18:04:01.933]         }
[18:04:01.933]         base::close(...future.stdout)
[18:04:01.933]         ...future.stdout <- NULL
[18:04:01.933]     }
[18:04:01.933]     ...future.result$conditions <- ...future.conditions
[18:04:01.933]     ...future.result$finished <- base::Sys.time()
[18:04:01.933]     ...future.result
[18:04:01.933] }
[18:04:01.937] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:01.967] receiveMessageFromWorker() for ClusterFuture ...
[18:04:01.967] - Validating connection of MultisessionFuture
[18:04:01.968] - received message: FutureResult
[18:04:01.968] - Received FutureResult
[18:04:01.968] - Erased future from FutureRegistry
[18:04:01.968] result() for ClusterFuture ...
[18:04:01.969] - result already collected: FutureResult
[18:04:01.969] result() for ClusterFuture ... done
[18:04:01.969] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:01.969] result() for ClusterFuture ...
[18:04:01.969] - result already collected: FutureResult
[18:04:01.970] result() for ClusterFuture ... done
[18:04:01.970] result() for ClusterFuture ...
[18:04:01.970] - result already collected: FutureResult
[18:04:01.970] result() for ClusterFuture ... done
[18:04:01.971] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:04:01.972] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:04:01.972] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:04:01.973] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:04:01.974] MultisessionFuture started
[18:04:01.974] - Launch lazy future ... done
[18:04:01.974] run() for ‘MultisessionFuture’ ... done
[18:04:01.974] result() for ClusterFuture ...
[18:04:01.975] - result already collected: FutureResult
[18:04:01.976] result() for ClusterFuture ... done
[18:04:01.976] result() for ClusterFuture ...
[18:04:01.976] - result already collected: FutureResult
[18:04:01.976] result() for ClusterFuture ... done
[18:04:01.976] result() for ClusterFuture ...
[18:04:01.977] receiveMessageFromWorker() for ClusterFuture ...
[18:04:01.977] - Validating connection of MultisessionFuture
[18:04:01.996] - received message: FutureResult
[18:04:01.997] - Received FutureResult
[18:04:01.997] - Erased future from FutureRegistry
[18:04:01.997] result() for ClusterFuture ...
[18:04:01.997] - result already collected: FutureResult
[18:04:01.998] result() for ClusterFuture ... done
[18:04:01.998] signalConditions() ...
[18:04:01.998]  - include = ‘immediateCondition’
[18:04:01.998]  - exclude = 
[18:04:01.999]  - resignal = FALSE
[18:04:01.999]  - Number of conditions: 1
[18:04:01.999] signalConditions() ... done
[18:04:01.999] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:01.999] result() for ClusterFuture ... done
[18:04:02.000] result() for ClusterFuture ...
[18:04:02.000] - result already collected: FutureResult
[18:04:02.000] result() for ClusterFuture ... done
[18:04:02.000] signalConditions() ...
[18:04:02.000]  - include = ‘immediateCondition’
[18:04:02.001]  - exclude = 
[18:04:02.001]  - resignal = FALSE
[18:04:02.001]  - Number of conditions: 1
[18:04:02.001] signalConditions() ... done
[18:04:02.002] Future state: ‘finished’
[18:04:02.002] result() for ClusterFuture ...
[18:04:02.002] - result already collected: FutureResult
[18:04:02.002] result() for ClusterFuture ... done
[18:04:02.003] signalConditions() ...
[18:04:02.003]  - include = ‘condition’
[18:04:02.003]  - exclude = ‘immediateCondition’
[18:04:02.003]  - resignal = TRUE
[18:04:02.003]  - Number of conditions: 1
[18:04:02.004]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:02.004] signalConditions() ... done
[18:04:02.005] result() for ClusterFuture ...
[18:04:02.005] receiveMessageFromWorker() for ClusterFuture ...
[18:04:02.005] - Validating connection of MultisessionFuture
[18:04:02.017] - received message: FutureResult
[18:04:02.017] - Received FutureResult
[18:04:02.017] - Erased future from FutureRegistry
[18:04:02.018] result() for ClusterFuture ...
[18:04:02.018] - result already collected: FutureResult
[18:04:02.018] result() for ClusterFuture ... done
[18:04:02.018] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:02.018] result() for ClusterFuture ... done
[18:04:02.019] result() for ClusterFuture ...
[18:04:02.019] - result already collected: FutureResult
[18:04:02.019] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[18:04:02.020] result() for ClusterFuture ...
[18:04:02.020] - result already collected: FutureResult
[18:04:02.020] result() for ClusterFuture ... done
[18:04:02.020] result() for ClusterFuture ...
[18:04:02.020] - result already collected: FutureResult
[18:04:02.021] result() for ClusterFuture ... done
[18:04:02.021] signalConditions() ...
[18:04:02.021]  - include = ‘immediateCondition’
[18:04:02.021]  - exclude = 
[18:04:02.021]  - resignal = FALSE
[18:04:02.021]  - Number of conditions: 1
[18:04:02.022] signalConditions() ... done
[18:04:02.022] Future state: ‘finished’
[18:04:02.022] result() for ClusterFuture ...
[18:04:02.022] - result already collected: FutureResult
[18:04:02.022] result() for ClusterFuture ... done
[18:04:02.023] signalConditions() ...
[18:04:02.023]  - include = ‘condition’
[18:04:02.023]  - exclude = ‘immediateCondition’
[18:04:02.023]  - resignal = TRUE
[18:04:02.023]  - Number of conditions: 1
[18:04:02.023]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:02.024] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[18:04:02.024] result() for ClusterFuture ...
[18:04:02.025] - result already collected: FutureResult
[18:04:02.025] result() for ClusterFuture ... done
[18:04:02.025] result() for ClusterFuture ...
[18:04:02.025] - result already collected: FutureResult
[18:04:02.025] result() for ClusterFuture ... done
[18:04:02.026] signalConditions() ...
[18:04:02.026]  - include = ‘immediateCondition’
[18:04:02.026]  - exclude = 
[18:04:02.026]  - resignal = FALSE
[18:04:02.026]  - Number of conditions: 1
[18:04:02.026] signalConditions() ... done
[18:04:02.027] Future state: ‘finished’
[18:04:02.027] result() for ClusterFuture ...
[18:04:02.027] - result already collected: FutureResult
[18:04:02.027] result() for ClusterFuture ... done
[18:04:02.027] signalConditions() ...
[18:04:02.028]  - include = ‘condition’
[18:04:02.028]  - exclude = ‘immediateCondition’
[18:04:02.028]  - resignal = TRUE
[18:04:02.028]  - Number of conditions: 1
[18:04:02.028]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:02.029] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[18:04:02.029] getGlobalsAndPackages() ...
[18:04:02.029] Searching for globals...
[18:04:02.033] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[18:04:02.033] Searching for globals ... DONE
[18:04:02.034] Resolving globals: FALSE
[18:04:02.034] 
[18:04:02.034] 
[18:04:02.035] getGlobalsAndPackages() ... DONE
[18:04:02.035] run() for ‘Future’ ...
[18:04:02.035] - state: ‘created’
[18:04:02.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:02.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:02.060] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:02.060]   - Field: ‘node’
[18:04:02.060]   - Field: ‘label’
[18:04:02.060]   - Field: ‘local’
[18:04:02.061]   - Field: ‘owner’
[18:04:02.061]   - Field: ‘envir’
[18:04:02.061]   - Field: ‘workers’
[18:04:02.061]   - Field: ‘packages’
[18:04:02.061]   - Field: ‘gc’
[18:04:02.062]   - Field: ‘conditions’
[18:04:02.062]   - Field: ‘persistent’
[18:04:02.062]   - Field: ‘expr’
[18:04:02.062]   - Field: ‘uuid’
[18:04:02.063]   - Field: ‘seed’
[18:04:02.063]   - Field: ‘version’
[18:04:02.063]   - Field: ‘result’
[18:04:02.063]   - Field: ‘asynchronous’
[18:04:02.064]   - Field: ‘calls’
[18:04:02.064]   - Field: ‘globals’
[18:04:02.064]   - Field: ‘stdout’
[18:04:02.064]   - Field: ‘earlySignal’
[18:04:02.064]   - Field: ‘lazy’
[18:04:02.065]   - Field: ‘state’
[18:04:02.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:02.065] - Launch lazy future ...
[18:04:02.066] Packages needed by the future expression (n = 0): <none>
[18:04:02.066] Packages needed by future strategies (n = 0): <none>
[18:04:02.067] {
[18:04:02.067]     {
[18:04:02.067]         {
[18:04:02.067]             ...future.startTime <- base::Sys.time()
[18:04:02.067]             {
[18:04:02.067]                 {
[18:04:02.067]                   {
[18:04:02.067]                     {
[18:04:02.067]                       base::local({
[18:04:02.067]                         has_future <- base::requireNamespace("future", 
[18:04:02.067]                           quietly = TRUE)
[18:04:02.067]                         if (has_future) {
[18:04:02.067]                           ns <- base::getNamespace("future")
[18:04:02.067]                           version <- ns[[".package"]][["version"]]
[18:04:02.067]                           if (is.null(version)) 
[18:04:02.067]                             version <- utils::packageVersion("future")
[18:04:02.067]                         }
[18:04:02.067]                         else {
[18:04:02.067]                           version <- NULL
[18:04:02.067]                         }
[18:04:02.067]                         if (!has_future || version < "1.8.0") {
[18:04:02.067]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:02.067]                             "", base::R.version$version.string), 
[18:04:02.067]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:02.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:02.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:02.067]                               "release", "version")], collapse = " "), 
[18:04:02.067]                             hostname = base::Sys.info()[["nodename"]])
[18:04:02.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:02.067]                             info)
[18:04:02.067]                           info <- base::paste(info, collapse = "; ")
[18:04:02.067]                           if (!has_future) {
[18:04:02.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:02.067]                               info)
[18:04:02.067]                           }
[18:04:02.067]                           else {
[18:04:02.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:02.067]                               info, version)
[18:04:02.067]                           }
[18:04:02.067]                           base::stop(msg)
[18:04:02.067]                         }
[18:04:02.067]                       })
[18:04:02.067]                     }
[18:04:02.067]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:02.067]                     base::options(mc.cores = 1L)
[18:04:02.067]                   }
[18:04:02.067]                   ...future.strategy.old <- future::plan("list")
[18:04:02.067]                   options(future.plan = NULL)
[18:04:02.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:02.067]                 }
[18:04:02.067]                 ...future.workdir <- getwd()
[18:04:02.067]             }
[18:04:02.067]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:02.067]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:02.067]         }
[18:04:02.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:02.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:02.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:02.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:02.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:02.067]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:02.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:02.067]             base::names(...future.oldOptions))
[18:04:02.067]     }
[18:04:02.067]     if (FALSE) {
[18:04:02.067]     }
[18:04:02.067]     else {
[18:04:02.067]         if (TRUE) {
[18:04:02.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:02.067]                 open = "w")
[18:04:02.067]         }
[18:04:02.067]         else {
[18:04:02.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:02.067]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:02.067]         }
[18:04:02.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:02.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:02.067]             base::sink(type = "output", split = FALSE)
[18:04:02.067]             base::close(...future.stdout)
[18:04:02.067]         }, add = TRUE)
[18:04:02.067]     }
[18:04:02.067]     ...future.frame <- base::sys.nframe()
[18:04:02.067]     ...future.conditions <- base::list()
[18:04:02.067]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:02.067]     if (FALSE) {
[18:04:02.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:02.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:02.067]     }
[18:04:02.067]     ...future.result <- base::tryCatch({
[18:04:02.067]         base::withCallingHandlers({
[18:04:02.067]             ...future.value <- base::withVisible(base::local({
[18:04:02.067]                 ...future.makeSendCondition <- base::local({
[18:04:02.067]                   sendCondition <- NULL
[18:04:02.067]                   function(frame = 1L) {
[18:04:02.067]                     if (is.function(sendCondition)) 
[18:04:02.067]                       return(sendCondition)
[18:04:02.067]                     ns <- getNamespace("parallel")
[18:04:02.067]                     if (exists("sendData", mode = "function", 
[18:04:02.067]                       envir = ns)) {
[18:04:02.067]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:02.067]                         envir = ns)
[18:04:02.067]                       envir <- sys.frame(frame)
[18:04:02.067]                       master <- NULL
[18:04:02.067]                       while (!identical(envir, .GlobalEnv) && 
[18:04:02.067]                         !identical(envir, emptyenv())) {
[18:04:02.067]                         if (exists("master", mode = "list", envir = envir, 
[18:04:02.067]                           inherits = FALSE)) {
[18:04:02.067]                           master <- get("master", mode = "list", 
[18:04:02.067]                             envir = envir, inherits = FALSE)
[18:04:02.067]                           if (inherits(master, c("SOCKnode", 
[18:04:02.067]                             "SOCK0node"))) {
[18:04:02.067]                             sendCondition <<- function(cond) {
[18:04:02.067]                               data <- list(type = "VALUE", value = cond, 
[18:04:02.067]                                 success = TRUE)
[18:04:02.067]                               parallel_sendData(master, data)
[18:04:02.067]                             }
[18:04:02.067]                             return(sendCondition)
[18:04:02.067]                           }
[18:04:02.067]                         }
[18:04:02.067]                         frame <- frame + 1L
[18:04:02.067]                         envir <- sys.frame(frame)
[18:04:02.067]                       }
[18:04:02.067]                     }
[18:04:02.067]                     sendCondition <<- function(cond) NULL
[18:04:02.067]                   }
[18:04:02.067]                 })
[18:04:02.067]                 withCallingHandlers({
[18:04:02.067]                   {
[18:04:02.067]                     cat("Processing: ")
[18:04:02.067]                     for (ii in 1:10) {
[18:04:02.067]                       cat(".")
[18:04:02.067]                     }
[18:04:02.067]                     cat(" [100%]\n")
[18:04:02.067]                     4
[18:04:02.067]                   }
[18:04:02.067]                 }, immediateCondition = function(cond) {
[18:04:02.067]                   sendCondition <- ...future.makeSendCondition()
[18:04:02.067]                   sendCondition(cond)
[18:04:02.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.067]                   {
[18:04:02.067]                     inherits <- base::inherits
[18:04:02.067]                     invokeRestart <- base::invokeRestart
[18:04:02.067]                     is.null <- base::is.null
[18:04:02.067]                     muffled <- FALSE
[18:04:02.067]                     if (inherits(cond, "message")) {
[18:04:02.067]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:02.067]                       if (muffled) 
[18:04:02.067]                         invokeRestart("muffleMessage")
[18:04:02.067]                     }
[18:04:02.067]                     else if (inherits(cond, "warning")) {
[18:04:02.067]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:02.067]                       if (muffled) 
[18:04:02.067]                         invokeRestart("muffleWarning")
[18:04:02.067]                     }
[18:04:02.067]                     else if (inherits(cond, "condition")) {
[18:04:02.067]                       if (!is.null(pattern)) {
[18:04:02.067]                         computeRestarts <- base::computeRestarts
[18:04:02.067]                         grepl <- base::grepl
[18:04:02.067]                         restarts <- computeRestarts(cond)
[18:04:02.067]                         for (restart in restarts) {
[18:04:02.067]                           name <- restart$name
[18:04:02.067]                           if (is.null(name)) 
[18:04:02.067]                             next
[18:04:02.067]                           if (!grepl(pattern, name)) 
[18:04:02.067]                             next
[18:04:02.067]                           invokeRestart(restart)
[18:04:02.067]                           muffled <- TRUE
[18:04:02.067]                           break
[18:04:02.067]                         }
[18:04:02.067]                       }
[18:04:02.067]                     }
[18:04:02.067]                     invisible(muffled)
[18:04:02.067]                   }
[18:04:02.067]                   muffleCondition(cond)
[18:04:02.067]                 })
[18:04:02.067]             }))
[18:04:02.067]             future::FutureResult(value = ...future.value$value, 
[18:04:02.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.067]                   ...future.rng), globalenv = if (FALSE) 
[18:04:02.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:02.067]                     ...future.globalenv.names))
[18:04:02.067]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:02.067]         }, condition = base::local({
[18:04:02.067]             c <- base::c
[18:04:02.067]             inherits <- base::inherits
[18:04:02.067]             invokeRestart <- base::invokeRestart
[18:04:02.067]             length <- base::length
[18:04:02.067]             list <- base::list
[18:04:02.067]             seq.int <- base::seq.int
[18:04:02.067]             signalCondition <- base::signalCondition
[18:04:02.067]             sys.calls <- base::sys.calls
[18:04:02.067]             `[[` <- base::`[[`
[18:04:02.067]             `+` <- base::`+`
[18:04:02.067]             `<<-` <- base::`<<-`
[18:04:02.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:02.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:02.067]                   3L)]
[18:04:02.067]             }
[18:04:02.067]             function(cond) {
[18:04:02.067]                 is_error <- inherits(cond, "error")
[18:04:02.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:02.067]                   NULL)
[18:04:02.067]                 if (is_error) {
[18:04:02.067]                   sessionInformation <- function() {
[18:04:02.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:02.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:02.067]                       search = base::search(), system = base::Sys.info())
[18:04:02.067]                   }
[18:04:02.067]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:02.067]                     cond$call), session = sessionInformation(), 
[18:04:02.067]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:02.067]                   signalCondition(cond)
[18:04:02.067]                 }
[18:04:02.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:02.067]                 "immediateCondition"))) {
[18:04:02.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:02.067]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:02.067]                   if (TRUE && !signal) {
[18:04:02.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.067]                     {
[18:04:02.067]                       inherits <- base::inherits
[18:04:02.067]                       invokeRestart <- base::invokeRestart
[18:04:02.067]                       is.null <- base::is.null
[18:04:02.067]                       muffled <- FALSE
[18:04:02.067]                       if (inherits(cond, "message")) {
[18:04:02.067]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.067]                         if (muffled) 
[18:04:02.067]                           invokeRestart("muffleMessage")
[18:04:02.067]                       }
[18:04:02.067]                       else if (inherits(cond, "warning")) {
[18:04:02.067]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.067]                         if (muffled) 
[18:04:02.067]                           invokeRestart("muffleWarning")
[18:04:02.067]                       }
[18:04:02.067]                       else if (inherits(cond, "condition")) {
[18:04:02.067]                         if (!is.null(pattern)) {
[18:04:02.067]                           computeRestarts <- base::computeRestarts
[18:04:02.067]                           grepl <- base::grepl
[18:04:02.067]                           restarts <- computeRestarts(cond)
[18:04:02.067]                           for (restart in restarts) {
[18:04:02.067]                             name <- restart$name
[18:04:02.067]                             if (is.null(name)) 
[18:04:02.067]                               next
[18:04:02.067]                             if (!grepl(pattern, name)) 
[18:04:02.067]                               next
[18:04:02.067]                             invokeRestart(restart)
[18:04:02.067]                             muffled <- TRUE
[18:04:02.067]                             break
[18:04:02.067]                           }
[18:04:02.067]                         }
[18:04:02.067]                       }
[18:04:02.067]                       invisible(muffled)
[18:04:02.067]                     }
[18:04:02.067]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.067]                   }
[18:04:02.067]                 }
[18:04:02.067]                 else {
[18:04:02.067]                   if (TRUE) {
[18:04:02.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.067]                     {
[18:04:02.067]                       inherits <- base::inherits
[18:04:02.067]                       invokeRestart <- base::invokeRestart
[18:04:02.067]                       is.null <- base::is.null
[18:04:02.067]                       muffled <- FALSE
[18:04:02.067]                       if (inherits(cond, "message")) {
[18:04:02.067]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.067]                         if (muffled) 
[18:04:02.067]                           invokeRestart("muffleMessage")
[18:04:02.067]                       }
[18:04:02.067]                       else if (inherits(cond, "warning")) {
[18:04:02.067]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.067]                         if (muffled) 
[18:04:02.067]                           invokeRestart("muffleWarning")
[18:04:02.067]                       }
[18:04:02.067]                       else if (inherits(cond, "condition")) {
[18:04:02.067]                         if (!is.null(pattern)) {
[18:04:02.067]                           computeRestarts <- base::computeRestarts
[18:04:02.067]                           grepl <- base::grepl
[18:04:02.067]                           restarts <- computeRestarts(cond)
[18:04:02.067]                           for (restart in restarts) {
[18:04:02.067]                             name <- restart$name
[18:04:02.067]                             if (is.null(name)) 
[18:04:02.067]                               next
[18:04:02.067]                             if (!grepl(pattern, name)) 
[18:04:02.067]                               next
[18:04:02.067]                             invokeRestart(restart)
[18:04:02.067]                             muffled <- TRUE
[18:04:02.067]                             break
[18:04:02.067]                           }
[18:04:02.067]                         }
[18:04:02.067]                       }
[18:04:02.067]                       invisible(muffled)
[18:04:02.067]                     }
[18:04:02.067]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.067]                   }
[18:04:02.067]                 }
[18:04:02.067]             }
[18:04:02.067]         }))
[18:04:02.067]     }, error = function(ex) {
[18:04:02.067]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:02.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.067]                 ...future.rng), started = ...future.startTime, 
[18:04:02.067]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:02.067]             version = "1.8"), class = "FutureResult")
[18:04:02.067]     }, finally = {
[18:04:02.067]         if (!identical(...future.workdir, getwd())) 
[18:04:02.067]             setwd(...future.workdir)
[18:04:02.067]         {
[18:04:02.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:02.067]                 ...future.oldOptions$nwarnings <- NULL
[18:04:02.067]             }
[18:04:02.067]             base::options(...future.oldOptions)
[18:04:02.067]             if (.Platform$OS.type == "windows") {
[18:04:02.067]                 old_names <- names(...future.oldEnvVars)
[18:04:02.067]                 envs <- base::Sys.getenv()
[18:04:02.067]                 names <- names(envs)
[18:04:02.067]                 common <- intersect(names, old_names)
[18:04:02.067]                 added <- setdiff(names, old_names)
[18:04:02.067]                 removed <- setdiff(old_names, names)
[18:04:02.067]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:02.067]                   envs[common]]
[18:04:02.067]                 NAMES <- toupper(changed)
[18:04:02.067]                 args <- list()
[18:04:02.067]                 for (kk in seq_along(NAMES)) {
[18:04:02.067]                   name <- changed[[kk]]
[18:04:02.067]                   NAME <- NAMES[[kk]]
[18:04:02.067]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.067]                     next
[18:04:02.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.067]                 }
[18:04:02.067]                 NAMES <- toupper(added)
[18:04:02.067]                 for (kk in seq_along(NAMES)) {
[18:04:02.067]                   name <- added[[kk]]
[18:04:02.067]                   NAME <- NAMES[[kk]]
[18:04:02.067]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.067]                     next
[18:04:02.067]                   args[[name]] <- ""
[18:04:02.067]                 }
[18:04:02.067]                 NAMES <- toupper(removed)
[18:04:02.067]                 for (kk in seq_along(NAMES)) {
[18:04:02.067]                   name <- removed[[kk]]
[18:04:02.067]                   NAME <- NAMES[[kk]]
[18:04:02.067]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.067]                     next
[18:04:02.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.067]                 }
[18:04:02.067]                 if (length(args) > 0) 
[18:04:02.067]                   base::do.call(base::Sys.setenv, args = args)
[18:04:02.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:02.067]             }
[18:04:02.067]             else {
[18:04:02.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:02.067]             }
[18:04:02.067]             {
[18:04:02.067]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:02.067]                   0L) {
[18:04:02.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:02.067]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:02.067]                   base::options(opts)
[18:04:02.067]                 }
[18:04:02.067]                 {
[18:04:02.067]                   {
[18:04:02.067]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:02.067]                     NULL
[18:04:02.067]                   }
[18:04:02.067]                   options(future.plan = NULL)
[18:04:02.067]                   if (is.na(NA_character_)) 
[18:04:02.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:02.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:02.067]                     .init = FALSE)
[18:04:02.067]                 }
[18:04:02.067]             }
[18:04:02.067]         }
[18:04:02.067]     })
[18:04:02.067]     if (TRUE) {
[18:04:02.067]         base::sink(type = "output", split = FALSE)
[18:04:02.067]         if (TRUE) {
[18:04:02.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:02.067]         }
[18:04:02.067]         else {
[18:04:02.067]             ...future.result["stdout"] <- base::list(NULL)
[18:04:02.067]         }
[18:04:02.067]         base::close(...future.stdout)
[18:04:02.067]         ...future.stdout <- NULL
[18:04:02.067]     }
[18:04:02.067]     ...future.result$conditions <- ...future.conditions
[18:04:02.067]     ...future.result$finished <- base::Sys.time()
[18:04:02.067]     ...future.result
[18:04:02.067] }
[18:04:02.073] MultisessionFuture started
[18:04:02.073] - Launch lazy future ... done
[18:04:02.073] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[18:04:02.074] result() for ClusterFuture ...
[18:04:02.075] - result already collected: FutureResult
[18:04:02.075] result() for ClusterFuture ... done
[18:04:02.075] result() for ClusterFuture ...
[18:04:02.075] - result already collected: FutureResult
[18:04:02.076] result() for ClusterFuture ... done
[18:04:02.076] signalConditions() ...
[18:04:02.076]  - include = ‘immediateCondition’
[18:04:02.076]  - exclude = 
[18:04:02.076]  - resignal = FALSE
[18:04:02.077]  - Number of conditions: 1
[18:04:02.077] signalConditions() ... done
[18:04:02.077] Future state: ‘finished’
[18:04:02.077] result() for ClusterFuture ...
[18:04:02.077] - result already collected: FutureResult
[18:04:02.078] result() for ClusterFuture ... done
[18:04:02.078] signalConditions() ...
[18:04:02.078]  - include = ‘condition’
[18:04:02.078]  - exclude = ‘immediateCondition’
[18:04:02.078]  - resignal = TRUE
[18:04:02.079]  - Number of conditions: 1
[18:04:02.079]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:02.079] signalConditions() ... done
v3: <simpleError> (as expect)
[18:04:02.079] result() for ClusterFuture ...
[18:04:02.080] receiveMessageFromWorker() for ClusterFuture ...
[18:04:02.080] - Validating connection of MultisessionFuture
[18:04:02.117] - received message: FutureResult
[18:04:02.118] - Received FutureResult
[18:04:02.118] - Erased future from FutureRegistry
[18:04:02.118] result() for ClusterFuture ...
[18:04:02.118] - result already collected: FutureResult
[18:04:02.118] result() for ClusterFuture ... done
[18:04:02.119] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:02.119] result() for ClusterFuture ... done
[18:04:02.119] result() for ClusterFuture ...
[18:04:02.119] - result already collected: FutureResult
[18:04:02.119] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[18:04:02.120] getGlobalsAndPackages() ...
[18:04:02.121] Searching for globals...
[18:04:02.121] 
[18:04:02.121] Searching for globals ... DONE
[18:04:02.122] - globals: [0] <none>
[18:04:02.122] getGlobalsAndPackages() ... DONE
[18:04:02.122] run() for ‘Future’ ...
[18:04:02.123] - state: ‘created’
[18:04:02.123] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:02.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:02.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:02.148]   - Field: ‘node’
[18:04:02.148]   - Field: ‘label’
[18:04:02.148]   - Field: ‘local’
[18:04:02.148]   - Field: ‘owner’
[18:04:02.149]   - Field: ‘envir’
[18:04:02.149]   - Field: ‘workers’
[18:04:02.149]   - Field: ‘packages’
[18:04:02.149]   - Field: ‘gc’
[18:04:02.149]   - Field: ‘conditions’
[18:04:02.150]   - Field: ‘persistent’
[18:04:02.150]   - Field: ‘expr’
[18:04:02.150]   - Field: ‘uuid’
[18:04:02.150]   - Field: ‘seed’
[18:04:02.150]   - Field: ‘version’
[18:04:02.151]   - Field: ‘result’
[18:04:02.151]   - Field: ‘asynchronous’
[18:04:02.151]   - Field: ‘calls’
[18:04:02.151]   - Field: ‘globals’
[18:04:02.151]   - Field: ‘stdout’
[18:04:02.151]   - Field: ‘earlySignal’
[18:04:02.152]   - Field: ‘lazy’
[18:04:02.152]   - Field: ‘state’
[18:04:02.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:02.152] - Launch lazy future ...
[18:04:02.153] Packages needed by the future expression (n = 0): <none>
[18:04:02.153] Packages needed by future strategies (n = 0): <none>
[18:04:02.154] {
[18:04:02.154]     {
[18:04:02.154]         {
[18:04:02.154]             ...future.startTime <- base::Sys.time()
[18:04:02.154]             {
[18:04:02.154]                 {
[18:04:02.154]                   {
[18:04:02.154]                     {
[18:04:02.154]                       base::local({
[18:04:02.154]                         has_future <- base::requireNamespace("future", 
[18:04:02.154]                           quietly = TRUE)
[18:04:02.154]                         if (has_future) {
[18:04:02.154]                           ns <- base::getNamespace("future")
[18:04:02.154]                           version <- ns[[".package"]][["version"]]
[18:04:02.154]                           if (is.null(version)) 
[18:04:02.154]                             version <- utils::packageVersion("future")
[18:04:02.154]                         }
[18:04:02.154]                         else {
[18:04:02.154]                           version <- NULL
[18:04:02.154]                         }
[18:04:02.154]                         if (!has_future || version < "1.8.0") {
[18:04:02.154]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:02.154]                             "", base::R.version$version.string), 
[18:04:02.154]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:02.154]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:02.154]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:02.154]                               "release", "version")], collapse = " "), 
[18:04:02.154]                             hostname = base::Sys.info()[["nodename"]])
[18:04:02.154]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:02.154]                             info)
[18:04:02.154]                           info <- base::paste(info, collapse = "; ")
[18:04:02.154]                           if (!has_future) {
[18:04:02.154]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:02.154]                               info)
[18:04:02.154]                           }
[18:04:02.154]                           else {
[18:04:02.154]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:02.154]                               info, version)
[18:04:02.154]                           }
[18:04:02.154]                           base::stop(msg)
[18:04:02.154]                         }
[18:04:02.154]                       })
[18:04:02.154]                     }
[18:04:02.154]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:02.154]                     base::options(mc.cores = 1L)
[18:04:02.154]                   }
[18:04:02.154]                   ...future.strategy.old <- future::plan("list")
[18:04:02.154]                   options(future.plan = NULL)
[18:04:02.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:02.154]                 }
[18:04:02.154]                 ...future.workdir <- getwd()
[18:04:02.154]             }
[18:04:02.154]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:02.154]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:02.154]         }
[18:04:02.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:02.154]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:02.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:02.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:02.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:02.154]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:02.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:02.154]             base::names(...future.oldOptions))
[18:04:02.154]     }
[18:04:02.154]     if (FALSE) {
[18:04:02.154]     }
[18:04:02.154]     else {
[18:04:02.154]         if (TRUE) {
[18:04:02.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:02.154]                 open = "w")
[18:04:02.154]         }
[18:04:02.154]         else {
[18:04:02.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:02.154]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:02.154]         }
[18:04:02.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:02.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:02.154]             base::sink(type = "output", split = FALSE)
[18:04:02.154]             base::close(...future.stdout)
[18:04:02.154]         }, add = TRUE)
[18:04:02.154]     }
[18:04:02.154]     ...future.frame <- base::sys.nframe()
[18:04:02.154]     ...future.conditions <- base::list()
[18:04:02.154]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:02.154]     if (FALSE) {
[18:04:02.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:02.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:02.154]     }
[18:04:02.154]     ...future.result <- base::tryCatch({
[18:04:02.154]         base::withCallingHandlers({
[18:04:02.154]             ...future.value <- base::withVisible(base::local({
[18:04:02.154]                 ...future.makeSendCondition <- base::local({
[18:04:02.154]                   sendCondition <- NULL
[18:04:02.154]                   function(frame = 1L) {
[18:04:02.154]                     if (is.function(sendCondition)) 
[18:04:02.154]                       return(sendCondition)
[18:04:02.154]                     ns <- getNamespace("parallel")
[18:04:02.154]                     if (exists("sendData", mode = "function", 
[18:04:02.154]                       envir = ns)) {
[18:04:02.154]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:02.154]                         envir = ns)
[18:04:02.154]                       envir <- sys.frame(frame)
[18:04:02.154]                       master <- NULL
[18:04:02.154]                       while (!identical(envir, .GlobalEnv) && 
[18:04:02.154]                         !identical(envir, emptyenv())) {
[18:04:02.154]                         if (exists("master", mode = "list", envir = envir, 
[18:04:02.154]                           inherits = FALSE)) {
[18:04:02.154]                           master <- get("master", mode = "list", 
[18:04:02.154]                             envir = envir, inherits = FALSE)
[18:04:02.154]                           if (inherits(master, c("SOCKnode", 
[18:04:02.154]                             "SOCK0node"))) {
[18:04:02.154]                             sendCondition <<- function(cond) {
[18:04:02.154]                               data <- list(type = "VALUE", value = cond, 
[18:04:02.154]                                 success = TRUE)
[18:04:02.154]                               parallel_sendData(master, data)
[18:04:02.154]                             }
[18:04:02.154]                             return(sendCondition)
[18:04:02.154]                           }
[18:04:02.154]                         }
[18:04:02.154]                         frame <- frame + 1L
[18:04:02.154]                         envir <- sys.frame(frame)
[18:04:02.154]                       }
[18:04:02.154]                     }
[18:04:02.154]                     sendCondition <<- function(cond) NULL
[18:04:02.154]                   }
[18:04:02.154]                 })
[18:04:02.154]                 withCallingHandlers({
[18:04:02.154]                   1
[18:04:02.154]                 }, immediateCondition = function(cond) {
[18:04:02.154]                   sendCondition <- ...future.makeSendCondition()
[18:04:02.154]                   sendCondition(cond)
[18:04:02.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.154]                   {
[18:04:02.154]                     inherits <- base::inherits
[18:04:02.154]                     invokeRestart <- base::invokeRestart
[18:04:02.154]                     is.null <- base::is.null
[18:04:02.154]                     muffled <- FALSE
[18:04:02.154]                     if (inherits(cond, "message")) {
[18:04:02.154]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:02.154]                       if (muffled) 
[18:04:02.154]                         invokeRestart("muffleMessage")
[18:04:02.154]                     }
[18:04:02.154]                     else if (inherits(cond, "warning")) {
[18:04:02.154]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:02.154]                       if (muffled) 
[18:04:02.154]                         invokeRestart("muffleWarning")
[18:04:02.154]                     }
[18:04:02.154]                     else if (inherits(cond, "condition")) {
[18:04:02.154]                       if (!is.null(pattern)) {
[18:04:02.154]                         computeRestarts <- base::computeRestarts
[18:04:02.154]                         grepl <- base::grepl
[18:04:02.154]                         restarts <- computeRestarts(cond)
[18:04:02.154]                         for (restart in restarts) {
[18:04:02.154]                           name <- restart$name
[18:04:02.154]                           if (is.null(name)) 
[18:04:02.154]                             next
[18:04:02.154]                           if (!grepl(pattern, name)) 
[18:04:02.154]                             next
[18:04:02.154]                           invokeRestart(restart)
[18:04:02.154]                           muffled <- TRUE
[18:04:02.154]                           break
[18:04:02.154]                         }
[18:04:02.154]                       }
[18:04:02.154]                     }
[18:04:02.154]                     invisible(muffled)
[18:04:02.154]                   }
[18:04:02.154]                   muffleCondition(cond)
[18:04:02.154]                 })
[18:04:02.154]             }))
[18:04:02.154]             future::FutureResult(value = ...future.value$value, 
[18:04:02.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.154]                   ...future.rng), globalenv = if (FALSE) 
[18:04:02.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:02.154]                     ...future.globalenv.names))
[18:04:02.154]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:02.154]         }, condition = base::local({
[18:04:02.154]             c <- base::c
[18:04:02.154]             inherits <- base::inherits
[18:04:02.154]             invokeRestart <- base::invokeRestart
[18:04:02.154]             length <- base::length
[18:04:02.154]             list <- base::list
[18:04:02.154]             seq.int <- base::seq.int
[18:04:02.154]             signalCondition <- base::signalCondition
[18:04:02.154]             sys.calls <- base::sys.calls
[18:04:02.154]             `[[` <- base::`[[`
[18:04:02.154]             `+` <- base::`+`
[18:04:02.154]             `<<-` <- base::`<<-`
[18:04:02.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:02.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:02.154]                   3L)]
[18:04:02.154]             }
[18:04:02.154]             function(cond) {
[18:04:02.154]                 is_error <- inherits(cond, "error")
[18:04:02.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:02.154]                   NULL)
[18:04:02.154]                 if (is_error) {
[18:04:02.154]                   sessionInformation <- function() {
[18:04:02.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:02.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:02.154]                       search = base::search(), system = base::Sys.info())
[18:04:02.154]                   }
[18:04:02.154]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:02.154]                     cond$call), session = sessionInformation(), 
[18:04:02.154]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:02.154]                   signalCondition(cond)
[18:04:02.154]                 }
[18:04:02.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:02.154]                 "immediateCondition"))) {
[18:04:02.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:02.154]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:02.154]                   if (TRUE && !signal) {
[18:04:02.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.154]                     {
[18:04:02.154]                       inherits <- base::inherits
[18:04:02.154]                       invokeRestart <- base::invokeRestart
[18:04:02.154]                       is.null <- base::is.null
[18:04:02.154]                       muffled <- FALSE
[18:04:02.154]                       if (inherits(cond, "message")) {
[18:04:02.154]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.154]                         if (muffled) 
[18:04:02.154]                           invokeRestart("muffleMessage")
[18:04:02.154]                       }
[18:04:02.154]                       else if (inherits(cond, "warning")) {
[18:04:02.154]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.154]                         if (muffled) 
[18:04:02.154]                           invokeRestart("muffleWarning")
[18:04:02.154]                       }
[18:04:02.154]                       else if (inherits(cond, "condition")) {
[18:04:02.154]                         if (!is.null(pattern)) {
[18:04:02.154]                           computeRestarts <- base::computeRestarts
[18:04:02.154]                           grepl <- base::grepl
[18:04:02.154]                           restarts <- computeRestarts(cond)
[18:04:02.154]                           for (restart in restarts) {
[18:04:02.154]                             name <- restart$name
[18:04:02.154]                             if (is.null(name)) 
[18:04:02.154]                               next
[18:04:02.154]                             if (!grepl(pattern, name)) 
[18:04:02.154]                               next
[18:04:02.154]                             invokeRestart(restart)
[18:04:02.154]                             muffled <- TRUE
[18:04:02.154]                             break
[18:04:02.154]                           }
[18:04:02.154]                         }
[18:04:02.154]                       }
[18:04:02.154]                       invisible(muffled)
[18:04:02.154]                     }
[18:04:02.154]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.154]                   }
[18:04:02.154]                 }
[18:04:02.154]                 else {
[18:04:02.154]                   if (TRUE) {
[18:04:02.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.154]                     {
[18:04:02.154]                       inherits <- base::inherits
[18:04:02.154]                       invokeRestart <- base::invokeRestart
[18:04:02.154]                       is.null <- base::is.null
[18:04:02.154]                       muffled <- FALSE
[18:04:02.154]                       if (inherits(cond, "message")) {
[18:04:02.154]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.154]                         if (muffled) 
[18:04:02.154]                           invokeRestart("muffleMessage")
[18:04:02.154]                       }
[18:04:02.154]                       else if (inherits(cond, "warning")) {
[18:04:02.154]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.154]                         if (muffled) 
[18:04:02.154]                           invokeRestart("muffleWarning")
[18:04:02.154]                       }
[18:04:02.154]                       else if (inherits(cond, "condition")) {
[18:04:02.154]                         if (!is.null(pattern)) {
[18:04:02.154]                           computeRestarts <- base::computeRestarts
[18:04:02.154]                           grepl <- base::grepl
[18:04:02.154]                           restarts <- computeRestarts(cond)
[18:04:02.154]                           for (restart in restarts) {
[18:04:02.154]                             name <- restart$name
[18:04:02.154]                             if (is.null(name)) 
[18:04:02.154]                               next
[18:04:02.154]                             if (!grepl(pattern, name)) 
[18:04:02.154]                               next
[18:04:02.154]                             invokeRestart(restart)
[18:04:02.154]                             muffled <- TRUE
[18:04:02.154]                             break
[18:04:02.154]                           }
[18:04:02.154]                         }
[18:04:02.154]                       }
[18:04:02.154]                       invisible(muffled)
[18:04:02.154]                     }
[18:04:02.154]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.154]                   }
[18:04:02.154]                 }
[18:04:02.154]             }
[18:04:02.154]         }))
[18:04:02.154]     }, error = function(ex) {
[18:04:02.154]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:02.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.154]                 ...future.rng), started = ...future.startTime, 
[18:04:02.154]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:02.154]             version = "1.8"), class = "FutureResult")
[18:04:02.154]     }, finally = {
[18:04:02.154]         if (!identical(...future.workdir, getwd())) 
[18:04:02.154]             setwd(...future.workdir)
[18:04:02.154]         {
[18:04:02.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:02.154]                 ...future.oldOptions$nwarnings <- NULL
[18:04:02.154]             }
[18:04:02.154]             base::options(...future.oldOptions)
[18:04:02.154]             if (.Platform$OS.type == "windows") {
[18:04:02.154]                 old_names <- names(...future.oldEnvVars)
[18:04:02.154]                 envs <- base::Sys.getenv()
[18:04:02.154]                 names <- names(envs)
[18:04:02.154]                 common <- intersect(names, old_names)
[18:04:02.154]                 added <- setdiff(names, old_names)
[18:04:02.154]                 removed <- setdiff(old_names, names)
[18:04:02.154]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:02.154]                   envs[common]]
[18:04:02.154]                 NAMES <- toupper(changed)
[18:04:02.154]                 args <- list()
[18:04:02.154]                 for (kk in seq_along(NAMES)) {
[18:04:02.154]                   name <- changed[[kk]]
[18:04:02.154]                   NAME <- NAMES[[kk]]
[18:04:02.154]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.154]                     next
[18:04:02.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.154]                 }
[18:04:02.154]                 NAMES <- toupper(added)
[18:04:02.154]                 for (kk in seq_along(NAMES)) {
[18:04:02.154]                   name <- added[[kk]]
[18:04:02.154]                   NAME <- NAMES[[kk]]
[18:04:02.154]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.154]                     next
[18:04:02.154]                   args[[name]] <- ""
[18:04:02.154]                 }
[18:04:02.154]                 NAMES <- toupper(removed)
[18:04:02.154]                 for (kk in seq_along(NAMES)) {
[18:04:02.154]                   name <- removed[[kk]]
[18:04:02.154]                   NAME <- NAMES[[kk]]
[18:04:02.154]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.154]                     next
[18:04:02.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.154]                 }
[18:04:02.154]                 if (length(args) > 0) 
[18:04:02.154]                   base::do.call(base::Sys.setenv, args = args)
[18:04:02.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:02.154]             }
[18:04:02.154]             else {
[18:04:02.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:02.154]             }
[18:04:02.154]             {
[18:04:02.154]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:02.154]                   0L) {
[18:04:02.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:02.154]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:02.154]                   base::options(opts)
[18:04:02.154]                 }
[18:04:02.154]                 {
[18:04:02.154]                   {
[18:04:02.154]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:02.154]                     NULL
[18:04:02.154]                   }
[18:04:02.154]                   options(future.plan = NULL)
[18:04:02.154]                   if (is.na(NA_character_)) 
[18:04:02.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:02.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:02.154]                     .init = FALSE)
[18:04:02.154]                 }
[18:04:02.154]             }
[18:04:02.154]         }
[18:04:02.154]     })
[18:04:02.154]     if (TRUE) {
[18:04:02.154]         base::sink(type = "output", split = FALSE)
[18:04:02.154]         if (TRUE) {
[18:04:02.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:02.154]         }
[18:04:02.154]         else {
[18:04:02.154]             ...future.result["stdout"] <- base::list(NULL)
[18:04:02.154]         }
[18:04:02.154]         base::close(...future.stdout)
[18:04:02.154]         ...future.stdout <- NULL
[18:04:02.154]     }
[18:04:02.154]     ...future.result$conditions <- ...future.conditions
[18:04:02.154]     ...future.result$finished <- base::Sys.time()
[18:04:02.154]     ...future.result
[18:04:02.154] }
[18:04:02.160] MultisessionFuture started
[18:04:02.160] - Launch lazy future ... done
[18:04:02.160] run() for ‘MultisessionFuture’ ... done
[18:04:02.161] result() for ClusterFuture ...
[18:04:02.164] receiveMessageFromWorker() for ClusterFuture ...
[18:04:02.164] - Validating connection of MultisessionFuture
[18:04:02.204] - received message: FutureResult
[18:04:02.205] - Received FutureResult
[18:04:02.205] - Erased future from FutureRegistry
[18:04:02.205] result() for ClusterFuture ...
[18:04:02.206] - result already collected: FutureResult
[18:04:02.206] result() for ClusterFuture ... done
[18:04:02.206] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:02.206] result() for ClusterFuture ... done
[18:04:02.206] result() for ClusterFuture ...
[18:04:02.207] - result already collected: FutureResult
[18:04:02.207] result() for ClusterFuture ... done
c = 1
[18:04:02.207] getGlobalsAndPackages() ...
[18:04:02.208] Searching for globals...
[18:04:02.208] 
[18:04:02.209] Searching for globals ... DONE
[18:04:02.209] - globals: [0] <none>
[18:04:02.209] getGlobalsAndPackages() ... DONE
[18:04:02.209] run() for ‘Future’ ...
[18:04:02.210] - state: ‘created’
[18:04:02.210] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:02.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:02.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:02.236]   - Field: ‘node’
[18:04:02.236]   - Field: ‘label’
[18:04:02.236]   - Field: ‘local’
[18:04:02.236]   - Field: ‘owner’
[18:04:02.237]   - Field: ‘envir’
[18:04:02.237]   - Field: ‘workers’
[18:04:02.237]   - Field: ‘packages’
[18:04:02.237]   - Field: ‘gc’
[18:04:02.237]   - Field: ‘conditions’
[18:04:02.238]   - Field: ‘persistent’
[18:04:02.239]   - Field: ‘expr’
[18:04:02.239]   - Field: ‘uuid’
[18:04:02.239]   - Field: ‘seed’
[18:04:02.240]   - Field: ‘version’
[18:04:02.240]   - Field: ‘result’
[18:04:02.240]   - Field: ‘asynchronous’
[18:04:02.240]   - Field: ‘calls’
[18:04:02.240]   - Field: ‘globals’
[18:04:02.241]   - Field: ‘stdout’
[18:04:02.241]   - Field: ‘earlySignal’
[18:04:02.241]   - Field: ‘lazy’
[18:04:02.241]   - Field: ‘state’
[18:04:02.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:02.242] - Launch lazy future ...
[18:04:02.242] Packages needed by the future expression (n = 0): <none>
[18:04:02.243] Packages needed by future strategies (n = 0): <none>
[18:04:02.244] {
[18:04:02.244]     {
[18:04:02.244]         {
[18:04:02.244]             ...future.startTime <- base::Sys.time()
[18:04:02.244]             {
[18:04:02.244]                 {
[18:04:02.244]                   {
[18:04:02.244]                     {
[18:04:02.244]                       base::local({
[18:04:02.244]                         has_future <- base::requireNamespace("future", 
[18:04:02.244]                           quietly = TRUE)
[18:04:02.244]                         if (has_future) {
[18:04:02.244]                           ns <- base::getNamespace("future")
[18:04:02.244]                           version <- ns[[".package"]][["version"]]
[18:04:02.244]                           if (is.null(version)) 
[18:04:02.244]                             version <- utils::packageVersion("future")
[18:04:02.244]                         }
[18:04:02.244]                         else {
[18:04:02.244]                           version <- NULL
[18:04:02.244]                         }
[18:04:02.244]                         if (!has_future || version < "1.8.0") {
[18:04:02.244]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:02.244]                             "", base::R.version$version.string), 
[18:04:02.244]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:02.244]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:02.244]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:02.244]                               "release", "version")], collapse = " "), 
[18:04:02.244]                             hostname = base::Sys.info()[["nodename"]])
[18:04:02.244]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:02.244]                             info)
[18:04:02.244]                           info <- base::paste(info, collapse = "; ")
[18:04:02.244]                           if (!has_future) {
[18:04:02.244]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:02.244]                               info)
[18:04:02.244]                           }
[18:04:02.244]                           else {
[18:04:02.244]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:02.244]                               info, version)
[18:04:02.244]                           }
[18:04:02.244]                           base::stop(msg)
[18:04:02.244]                         }
[18:04:02.244]                       })
[18:04:02.244]                     }
[18:04:02.244]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:02.244]                     base::options(mc.cores = 1L)
[18:04:02.244]                   }
[18:04:02.244]                   ...future.strategy.old <- future::plan("list")
[18:04:02.244]                   options(future.plan = NULL)
[18:04:02.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:02.244]                 }
[18:04:02.244]                 ...future.workdir <- getwd()
[18:04:02.244]             }
[18:04:02.244]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:02.244]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:02.244]         }
[18:04:02.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:02.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:02.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:02.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:02.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:02.244]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:02.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:02.244]             base::names(...future.oldOptions))
[18:04:02.244]     }
[18:04:02.244]     if (FALSE) {
[18:04:02.244]     }
[18:04:02.244]     else {
[18:04:02.244]         if (TRUE) {
[18:04:02.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:02.244]                 open = "w")
[18:04:02.244]         }
[18:04:02.244]         else {
[18:04:02.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:02.244]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:02.244]         }
[18:04:02.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:02.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:02.244]             base::sink(type = "output", split = FALSE)
[18:04:02.244]             base::close(...future.stdout)
[18:04:02.244]         }, add = TRUE)
[18:04:02.244]     }
[18:04:02.244]     ...future.frame <- base::sys.nframe()
[18:04:02.244]     ...future.conditions <- base::list()
[18:04:02.244]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:02.244]     if (FALSE) {
[18:04:02.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:02.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:02.244]     }
[18:04:02.244]     ...future.result <- base::tryCatch({
[18:04:02.244]         base::withCallingHandlers({
[18:04:02.244]             ...future.value <- base::withVisible(base::local({
[18:04:02.244]                 ...future.makeSendCondition <- base::local({
[18:04:02.244]                   sendCondition <- NULL
[18:04:02.244]                   function(frame = 1L) {
[18:04:02.244]                     if (is.function(sendCondition)) 
[18:04:02.244]                       return(sendCondition)
[18:04:02.244]                     ns <- getNamespace("parallel")
[18:04:02.244]                     if (exists("sendData", mode = "function", 
[18:04:02.244]                       envir = ns)) {
[18:04:02.244]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:02.244]                         envir = ns)
[18:04:02.244]                       envir <- sys.frame(frame)
[18:04:02.244]                       master <- NULL
[18:04:02.244]                       while (!identical(envir, .GlobalEnv) && 
[18:04:02.244]                         !identical(envir, emptyenv())) {
[18:04:02.244]                         if (exists("master", mode = "list", envir = envir, 
[18:04:02.244]                           inherits = FALSE)) {
[18:04:02.244]                           master <- get("master", mode = "list", 
[18:04:02.244]                             envir = envir, inherits = FALSE)
[18:04:02.244]                           if (inherits(master, c("SOCKnode", 
[18:04:02.244]                             "SOCK0node"))) {
[18:04:02.244]                             sendCondition <<- function(cond) {
[18:04:02.244]                               data <- list(type = "VALUE", value = cond, 
[18:04:02.244]                                 success = TRUE)
[18:04:02.244]                               parallel_sendData(master, data)
[18:04:02.244]                             }
[18:04:02.244]                             return(sendCondition)
[18:04:02.244]                           }
[18:04:02.244]                         }
[18:04:02.244]                         frame <- frame + 1L
[18:04:02.244]                         envir <- sys.frame(frame)
[18:04:02.244]                       }
[18:04:02.244]                     }
[18:04:02.244]                     sendCondition <<- function(cond) NULL
[18:04:02.244]                   }
[18:04:02.244]                 })
[18:04:02.244]                 withCallingHandlers({
[18:04:02.244]                   1
[18:04:02.244]                 }, immediateCondition = function(cond) {
[18:04:02.244]                   sendCondition <- ...future.makeSendCondition()
[18:04:02.244]                   sendCondition(cond)
[18:04:02.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.244]                   {
[18:04:02.244]                     inherits <- base::inherits
[18:04:02.244]                     invokeRestart <- base::invokeRestart
[18:04:02.244]                     is.null <- base::is.null
[18:04:02.244]                     muffled <- FALSE
[18:04:02.244]                     if (inherits(cond, "message")) {
[18:04:02.244]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:02.244]                       if (muffled) 
[18:04:02.244]                         invokeRestart("muffleMessage")
[18:04:02.244]                     }
[18:04:02.244]                     else if (inherits(cond, "warning")) {
[18:04:02.244]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:02.244]                       if (muffled) 
[18:04:02.244]                         invokeRestart("muffleWarning")
[18:04:02.244]                     }
[18:04:02.244]                     else if (inherits(cond, "condition")) {
[18:04:02.244]                       if (!is.null(pattern)) {
[18:04:02.244]                         computeRestarts <- base::computeRestarts
[18:04:02.244]                         grepl <- base::grepl
[18:04:02.244]                         restarts <- computeRestarts(cond)
[18:04:02.244]                         for (restart in restarts) {
[18:04:02.244]                           name <- restart$name
[18:04:02.244]                           if (is.null(name)) 
[18:04:02.244]                             next
[18:04:02.244]                           if (!grepl(pattern, name)) 
[18:04:02.244]                             next
[18:04:02.244]                           invokeRestart(restart)
[18:04:02.244]                           muffled <- TRUE
[18:04:02.244]                           break
[18:04:02.244]                         }
[18:04:02.244]                       }
[18:04:02.244]                     }
[18:04:02.244]                     invisible(muffled)
[18:04:02.244]                   }
[18:04:02.244]                   muffleCondition(cond)
[18:04:02.244]                 })
[18:04:02.244]             }))
[18:04:02.244]             future::FutureResult(value = ...future.value$value, 
[18:04:02.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.244]                   ...future.rng), globalenv = if (FALSE) 
[18:04:02.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:02.244]                     ...future.globalenv.names))
[18:04:02.244]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:02.244]         }, condition = base::local({
[18:04:02.244]             c <- base::c
[18:04:02.244]             inherits <- base::inherits
[18:04:02.244]             invokeRestart <- base::invokeRestart
[18:04:02.244]             length <- base::length
[18:04:02.244]             list <- base::list
[18:04:02.244]             seq.int <- base::seq.int
[18:04:02.244]             signalCondition <- base::signalCondition
[18:04:02.244]             sys.calls <- base::sys.calls
[18:04:02.244]             `[[` <- base::`[[`
[18:04:02.244]             `+` <- base::`+`
[18:04:02.244]             `<<-` <- base::`<<-`
[18:04:02.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:02.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:02.244]                   3L)]
[18:04:02.244]             }
[18:04:02.244]             function(cond) {
[18:04:02.244]                 is_error <- inherits(cond, "error")
[18:04:02.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:02.244]                   NULL)
[18:04:02.244]                 if (is_error) {
[18:04:02.244]                   sessionInformation <- function() {
[18:04:02.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:02.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:02.244]                       search = base::search(), system = base::Sys.info())
[18:04:02.244]                   }
[18:04:02.244]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:02.244]                     cond$call), session = sessionInformation(), 
[18:04:02.244]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:02.244]                   signalCondition(cond)
[18:04:02.244]                 }
[18:04:02.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:02.244]                 "immediateCondition"))) {
[18:04:02.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:02.244]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:02.244]                   if (TRUE && !signal) {
[18:04:02.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.244]                     {
[18:04:02.244]                       inherits <- base::inherits
[18:04:02.244]                       invokeRestart <- base::invokeRestart
[18:04:02.244]                       is.null <- base::is.null
[18:04:02.244]                       muffled <- FALSE
[18:04:02.244]                       if (inherits(cond, "message")) {
[18:04:02.244]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.244]                         if (muffled) 
[18:04:02.244]                           invokeRestart("muffleMessage")
[18:04:02.244]                       }
[18:04:02.244]                       else if (inherits(cond, "warning")) {
[18:04:02.244]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.244]                         if (muffled) 
[18:04:02.244]                           invokeRestart("muffleWarning")
[18:04:02.244]                       }
[18:04:02.244]                       else if (inherits(cond, "condition")) {
[18:04:02.244]                         if (!is.null(pattern)) {
[18:04:02.244]                           computeRestarts <- base::computeRestarts
[18:04:02.244]                           grepl <- base::grepl
[18:04:02.244]                           restarts <- computeRestarts(cond)
[18:04:02.244]                           for (restart in restarts) {
[18:04:02.244]                             name <- restart$name
[18:04:02.244]                             if (is.null(name)) 
[18:04:02.244]                               next
[18:04:02.244]                             if (!grepl(pattern, name)) 
[18:04:02.244]                               next
[18:04:02.244]                             invokeRestart(restart)
[18:04:02.244]                             muffled <- TRUE
[18:04:02.244]                             break
[18:04:02.244]                           }
[18:04:02.244]                         }
[18:04:02.244]                       }
[18:04:02.244]                       invisible(muffled)
[18:04:02.244]                     }
[18:04:02.244]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.244]                   }
[18:04:02.244]                 }
[18:04:02.244]                 else {
[18:04:02.244]                   if (TRUE) {
[18:04:02.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.244]                     {
[18:04:02.244]                       inherits <- base::inherits
[18:04:02.244]                       invokeRestart <- base::invokeRestart
[18:04:02.244]                       is.null <- base::is.null
[18:04:02.244]                       muffled <- FALSE
[18:04:02.244]                       if (inherits(cond, "message")) {
[18:04:02.244]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.244]                         if (muffled) 
[18:04:02.244]                           invokeRestart("muffleMessage")
[18:04:02.244]                       }
[18:04:02.244]                       else if (inherits(cond, "warning")) {
[18:04:02.244]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.244]                         if (muffled) 
[18:04:02.244]                           invokeRestart("muffleWarning")
[18:04:02.244]                       }
[18:04:02.244]                       else if (inherits(cond, "condition")) {
[18:04:02.244]                         if (!is.null(pattern)) {
[18:04:02.244]                           computeRestarts <- base::computeRestarts
[18:04:02.244]                           grepl <- base::grepl
[18:04:02.244]                           restarts <- computeRestarts(cond)
[18:04:02.244]                           for (restart in restarts) {
[18:04:02.244]                             name <- restart$name
[18:04:02.244]                             if (is.null(name)) 
[18:04:02.244]                               next
[18:04:02.244]                             if (!grepl(pattern, name)) 
[18:04:02.244]                               next
[18:04:02.244]                             invokeRestart(restart)
[18:04:02.244]                             muffled <- TRUE
[18:04:02.244]                             break
[18:04:02.244]                           }
[18:04:02.244]                         }
[18:04:02.244]                       }
[18:04:02.244]                       invisible(muffled)
[18:04:02.244]                     }
[18:04:02.244]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.244]                   }
[18:04:02.244]                 }
[18:04:02.244]             }
[18:04:02.244]         }))
[18:04:02.244]     }, error = function(ex) {
[18:04:02.244]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:02.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.244]                 ...future.rng), started = ...future.startTime, 
[18:04:02.244]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:02.244]             version = "1.8"), class = "FutureResult")
[18:04:02.244]     }, finally = {
[18:04:02.244]         if (!identical(...future.workdir, getwd())) 
[18:04:02.244]             setwd(...future.workdir)
[18:04:02.244]         {
[18:04:02.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:02.244]                 ...future.oldOptions$nwarnings <- NULL
[18:04:02.244]             }
[18:04:02.244]             base::options(...future.oldOptions)
[18:04:02.244]             if (.Platform$OS.type == "windows") {
[18:04:02.244]                 old_names <- names(...future.oldEnvVars)
[18:04:02.244]                 envs <- base::Sys.getenv()
[18:04:02.244]                 names <- names(envs)
[18:04:02.244]                 common <- intersect(names, old_names)
[18:04:02.244]                 added <- setdiff(names, old_names)
[18:04:02.244]                 removed <- setdiff(old_names, names)
[18:04:02.244]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:02.244]                   envs[common]]
[18:04:02.244]                 NAMES <- toupper(changed)
[18:04:02.244]                 args <- list()
[18:04:02.244]                 for (kk in seq_along(NAMES)) {
[18:04:02.244]                   name <- changed[[kk]]
[18:04:02.244]                   NAME <- NAMES[[kk]]
[18:04:02.244]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.244]                     next
[18:04:02.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.244]                 }
[18:04:02.244]                 NAMES <- toupper(added)
[18:04:02.244]                 for (kk in seq_along(NAMES)) {
[18:04:02.244]                   name <- added[[kk]]
[18:04:02.244]                   NAME <- NAMES[[kk]]
[18:04:02.244]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.244]                     next
[18:04:02.244]                   args[[name]] <- ""
[18:04:02.244]                 }
[18:04:02.244]                 NAMES <- toupper(removed)
[18:04:02.244]                 for (kk in seq_along(NAMES)) {
[18:04:02.244]                   name <- removed[[kk]]
[18:04:02.244]                   NAME <- NAMES[[kk]]
[18:04:02.244]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.244]                     next
[18:04:02.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.244]                 }
[18:04:02.244]                 if (length(args) > 0) 
[18:04:02.244]                   base::do.call(base::Sys.setenv, args = args)
[18:04:02.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:02.244]             }
[18:04:02.244]             else {
[18:04:02.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:02.244]             }
[18:04:02.244]             {
[18:04:02.244]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:02.244]                   0L) {
[18:04:02.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:02.244]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:02.244]                   base::options(opts)
[18:04:02.244]                 }
[18:04:02.244]                 {
[18:04:02.244]                   {
[18:04:02.244]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:02.244]                     NULL
[18:04:02.244]                   }
[18:04:02.244]                   options(future.plan = NULL)
[18:04:02.244]                   if (is.na(NA_character_)) 
[18:04:02.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:02.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:02.244]                     .init = FALSE)
[18:04:02.244]                 }
[18:04:02.244]             }
[18:04:02.244]         }
[18:04:02.244]     })
[18:04:02.244]     if (TRUE) {
[18:04:02.244]         base::sink(type = "output", split = FALSE)
[18:04:02.244]         if (TRUE) {
[18:04:02.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:02.244]         }
[18:04:02.244]         else {
[18:04:02.244]             ...future.result["stdout"] <- base::list(NULL)
[18:04:02.244]         }
[18:04:02.244]         base::close(...future.stdout)
[18:04:02.244]         ...future.stdout <- NULL
[18:04:02.244]     }
[18:04:02.244]     ...future.result$conditions <- ...future.conditions
[18:04:02.244]     ...future.result$finished <- base::Sys.time()
[18:04:02.244]     ...future.result
[18:04:02.244] }
[18:04:02.251] MultisessionFuture started
[18:04:02.251] - Launch lazy future ... done
[18:04:02.251] run() for ‘MultisessionFuture’ ... done
[18:04:02.251] result() for ClusterFuture ...
[18:04:02.252] receiveMessageFromWorker() for ClusterFuture ...
[18:04:02.252] - Validating connection of MultisessionFuture
[18:04:02.294] - received message: FutureResult
[18:04:02.294] - Received FutureResult
[18:04:02.295] - Erased future from FutureRegistry
[18:04:02.295] result() for ClusterFuture ...
[18:04:02.295] - result already collected: FutureResult
[18:04:02.295] result() for ClusterFuture ... done
[18:04:02.296] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:02.296] result() for ClusterFuture ... done
[18:04:02.296] result() for ClusterFuture ...
[18:04:02.296] - result already collected: FutureResult
[18:04:02.296] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[18:04:02.297] getGlobalsAndPackages() ...
[18:04:02.297] Searching for globals...
[18:04:02.306] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[18:04:02.306] Searching for globals ... DONE
[18:04:02.307] Resolving globals: FALSE
[18:04:02.307] 
[18:04:02.308] - packages: [1] ‘future’
[18:04:02.308] getGlobalsAndPackages() ... DONE
[18:04:02.309] run() for ‘Future’ ...
[18:04:02.309] - state: ‘created’
[18:04:02.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:02.332] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:02.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:02.333]   - Field: ‘node’
[18:04:02.333]   - Field: ‘label’
[18:04:02.333]   - Field: ‘local’
[18:04:02.333]   - Field: ‘owner’
[18:04:02.333]   - Field: ‘envir’
[18:04:02.334]   - Field: ‘workers’
[18:04:02.334]   - Field: ‘packages’
[18:04:02.334]   - Field: ‘gc’
[18:04:02.334]   - Field: ‘conditions’
[18:04:02.334]   - Field: ‘persistent’
[18:04:02.335]   - Field: ‘expr’
[18:04:02.335]   - Field: ‘uuid’
[18:04:02.335]   - Field: ‘seed’
[18:04:02.335]   - Field: ‘version’
[18:04:02.335]   - Field: ‘result’
[18:04:02.335]   - Field: ‘asynchronous’
[18:04:02.336]   - Field: ‘calls’
[18:04:02.336]   - Field: ‘globals’
[18:04:02.336]   - Field: ‘stdout’
[18:04:02.336]   - Field: ‘earlySignal’
[18:04:02.336]   - Field: ‘lazy’
[18:04:02.337]   - Field: ‘state’
[18:04:02.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:02.337] - Launch lazy future ...
[18:04:02.338] Packages needed by the future expression (n = 1): ‘future’
[18:04:02.338] Packages needed by future strategies (n = 0): <none>
[18:04:02.339] {
[18:04:02.339]     {
[18:04:02.339]         {
[18:04:02.339]             ...future.startTime <- base::Sys.time()
[18:04:02.339]             {
[18:04:02.339]                 {
[18:04:02.339]                   {
[18:04:02.339]                     {
[18:04:02.339]                       {
[18:04:02.339]                         base::local({
[18:04:02.339]                           has_future <- base::requireNamespace("future", 
[18:04:02.339]                             quietly = TRUE)
[18:04:02.339]                           if (has_future) {
[18:04:02.339]                             ns <- base::getNamespace("future")
[18:04:02.339]                             version <- ns[[".package"]][["version"]]
[18:04:02.339]                             if (is.null(version)) 
[18:04:02.339]                               version <- utils::packageVersion("future")
[18:04:02.339]                           }
[18:04:02.339]                           else {
[18:04:02.339]                             version <- NULL
[18:04:02.339]                           }
[18:04:02.339]                           if (!has_future || version < "1.8.0") {
[18:04:02.339]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:02.339]                               "", base::R.version$version.string), 
[18:04:02.339]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:02.339]                                 base::R.version$platform, 8 * 
[18:04:02.339]                                   base::.Machine$sizeof.pointer), 
[18:04:02.339]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:02.339]                                 "release", "version")], collapse = " "), 
[18:04:02.339]                               hostname = base::Sys.info()[["nodename"]])
[18:04:02.339]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:02.339]                               info)
[18:04:02.339]                             info <- base::paste(info, collapse = "; ")
[18:04:02.339]                             if (!has_future) {
[18:04:02.339]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:02.339]                                 info)
[18:04:02.339]                             }
[18:04:02.339]                             else {
[18:04:02.339]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:02.339]                                 info, version)
[18:04:02.339]                             }
[18:04:02.339]                             base::stop(msg)
[18:04:02.339]                           }
[18:04:02.339]                         })
[18:04:02.339]                       }
[18:04:02.339]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:02.339]                       base::options(mc.cores = 1L)
[18:04:02.339]                     }
[18:04:02.339]                     base::local({
[18:04:02.339]                       for (pkg in "future") {
[18:04:02.339]                         base::loadNamespace(pkg)
[18:04:02.339]                         base::library(pkg, character.only = TRUE)
[18:04:02.339]                       }
[18:04:02.339]                     })
[18:04:02.339]                   }
[18:04:02.339]                   ...future.strategy.old <- future::plan("list")
[18:04:02.339]                   options(future.plan = NULL)
[18:04:02.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:02.339]                 }
[18:04:02.339]                 ...future.workdir <- getwd()
[18:04:02.339]             }
[18:04:02.339]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:02.339]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:02.339]         }
[18:04:02.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:02.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:02.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:02.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:02.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:02.339]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:02.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:02.339]             base::names(...future.oldOptions))
[18:04:02.339]     }
[18:04:02.339]     if (FALSE) {
[18:04:02.339]     }
[18:04:02.339]     else {
[18:04:02.339]         if (TRUE) {
[18:04:02.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:02.339]                 open = "w")
[18:04:02.339]         }
[18:04:02.339]         else {
[18:04:02.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:02.339]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:02.339]         }
[18:04:02.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:02.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:02.339]             base::sink(type = "output", split = FALSE)
[18:04:02.339]             base::close(...future.stdout)
[18:04:02.339]         }, add = TRUE)
[18:04:02.339]     }
[18:04:02.339]     ...future.frame <- base::sys.nframe()
[18:04:02.339]     ...future.conditions <- base::list()
[18:04:02.339]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:02.339]     if (FALSE) {
[18:04:02.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:02.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:02.339]     }
[18:04:02.339]     ...future.result <- base::tryCatch({
[18:04:02.339]         base::withCallingHandlers({
[18:04:02.339]             ...future.value <- base::withVisible(base::local({
[18:04:02.339]                 ...future.makeSendCondition <- base::local({
[18:04:02.339]                   sendCondition <- NULL
[18:04:02.339]                   function(frame = 1L) {
[18:04:02.339]                     if (is.function(sendCondition)) 
[18:04:02.339]                       return(sendCondition)
[18:04:02.339]                     ns <- getNamespace("parallel")
[18:04:02.339]                     if (exists("sendData", mode = "function", 
[18:04:02.339]                       envir = ns)) {
[18:04:02.339]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:02.339]                         envir = ns)
[18:04:02.339]                       envir <- sys.frame(frame)
[18:04:02.339]                       master <- NULL
[18:04:02.339]                       while (!identical(envir, .GlobalEnv) && 
[18:04:02.339]                         !identical(envir, emptyenv())) {
[18:04:02.339]                         if (exists("master", mode = "list", envir = envir, 
[18:04:02.339]                           inherits = FALSE)) {
[18:04:02.339]                           master <- get("master", mode = "list", 
[18:04:02.339]                             envir = envir, inherits = FALSE)
[18:04:02.339]                           if (inherits(master, c("SOCKnode", 
[18:04:02.339]                             "SOCK0node"))) {
[18:04:02.339]                             sendCondition <<- function(cond) {
[18:04:02.339]                               data <- list(type = "VALUE", value = cond, 
[18:04:02.339]                                 success = TRUE)
[18:04:02.339]                               parallel_sendData(master, data)
[18:04:02.339]                             }
[18:04:02.339]                             return(sendCondition)
[18:04:02.339]                           }
[18:04:02.339]                         }
[18:04:02.339]                         frame <- frame + 1L
[18:04:02.339]                         envir <- sys.frame(frame)
[18:04:02.339]                       }
[18:04:02.339]                     }
[18:04:02.339]                     sendCondition <<- function(cond) NULL
[18:04:02.339]                   }
[18:04:02.339]                 })
[18:04:02.339]                 withCallingHandlers({
[18:04:02.339]                   {
[18:04:02.339]                     b <- 1
[18:04:02.339]                     c %<-% 2
[18:04:02.339]                     d <- 3
[18:04:02.339]                     4 %->% e
[18:04:02.339]                     b + c + d + e
[18:04:02.339]                   }
[18:04:02.339]                 }, immediateCondition = function(cond) {
[18:04:02.339]                   sendCondition <- ...future.makeSendCondition()
[18:04:02.339]                   sendCondition(cond)
[18:04:02.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.339]                   {
[18:04:02.339]                     inherits <- base::inherits
[18:04:02.339]                     invokeRestart <- base::invokeRestart
[18:04:02.339]                     is.null <- base::is.null
[18:04:02.339]                     muffled <- FALSE
[18:04:02.339]                     if (inherits(cond, "message")) {
[18:04:02.339]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:02.339]                       if (muffled) 
[18:04:02.339]                         invokeRestart("muffleMessage")
[18:04:02.339]                     }
[18:04:02.339]                     else if (inherits(cond, "warning")) {
[18:04:02.339]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:02.339]                       if (muffled) 
[18:04:02.339]                         invokeRestart("muffleWarning")
[18:04:02.339]                     }
[18:04:02.339]                     else if (inherits(cond, "condition")) {
[18:04:02.339]                       if (!is.null(pattern)) {
[18:04:02.339]                         computeRestarts <- base::computeRestarts
[18:04:02.339]                         grepl <- base::grepl
[18:04:02.339]                         restarts <- computeRestarts(cond)
[18:04:02.339]                         for (restart in restarts) {
[18:04:02.339]                           name <- restart$name
[18:04:02.339]                           if (is.null(name)) 
[18:04:02.339]                             next
[18:04:02.339]                           if (!grepl(pattern, name)) 
[18:04:02.339]                             next
[18:04:02.339]                           invokeRestart(restart)
[18:04:02.339]                           muffled <- TRUE
[18:04:02.339]                           break
[18:04:02.339]                         }
[18:04:02.339]                       }
[18:04:02.339]                     }
[18:04:02.339]                     invisible(muffled)
[18:04:02.339]                   }
[18:04:02.339]                   muffleCondition(cond)
[18:04:02.339]                 })
[18:04:02.339]             }))
[18:04:02.339]             future::FutureResult(value = ...future.value$value, 
[18:04:02.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.339]                   ...future.rng), globalenv = if (FALSE) 
[18:04:02.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:02.339]                     ...future.globalenv.names))
[18:04:02.339]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:02.339]         }, condition = base::local({
[18:04:02.339]             c <- base::c
[18:04:02.339]             inherits <- base::inherits
[18:04:02.339]             invokeRestart <- base::invokeRestart
[18:04:02.339]             length <- base::length
[18:04:02.339]             list <- base::list
[18:04:02.339]             seq.int <- base::seq.int
[18:04:02.339]             signalCondition <- base::signalCondition
[18:04:02.339]             sys.calls <- base::sys.calls
[18:04:02.339]             `[[` <- base::`[[`
[18:04:02.339]             `+` <- base::`+`
[18:04:02.339]             `<<-` <- base::`<<-`
[18:04:02.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:02.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:02.339]                   3L)]
[18:04:02.339]             }
[18:04:02.339]             function(cond) {
[18:04:02.339]                 is_error <- inherits(cond, "error")
[18:04:02.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:02.339]                   NULL)
[18:04:02.339]                 if (is_error) {
[18:04:02.339]                   sessionInformation <- function() {
[18:04:02.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:02.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:02.339]                       search = base::search(), system = base::Sys.info())
[18:04:02.339]                   }
[18:04:02.339]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:02.339]                     cond$call), session = sessionInformation(), 
[18:04:02.339]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:02.339]                   signalCondition(cond)
[18:04:02.339]                 }
[18:04:02.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:02.339]                 "immediateCondition"))) {
[18:04:02.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:02.339]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:02.339]                   if (TRUE && !signal) {
[18:04:02.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.339]                     {
[18:04:02.339]                       inherits <- base::inherits
[18:04:02.339]                       invokeRestart <- base::invokeRestart
[18:04:02.339]                       is.null <- base::is.null
[18:04:02.339]                       muffled <- FALSE
[18:04:02.339]                       if (inherits(cond, "message")) {
[18:04:02.339]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.339]                         if (muffled) 
[18:04:02.339]                           invokeRestart("muffleMessage")
[18:04:02.339]                       }
[18:04:02.339]                       else if (inherits(cond, "warning")) {
[18:04:02.339]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.339]                         if (muffled) 
[18:04:02.339]                           invokeRestart("muffleWarning")
[18:04:02.339]                       }
[18:04:02.339]                       else if (inherits(cond, "condition")) {
[18:04:02.339]                         if (!is.null(pattern)) {
[18:04:02.339]                           computeRestarts <- base::computeRestarts
[18:04:02.339]                           grepl <- base::grepl
[18:04:02.339]                           restarts <- computeRestarts(cond)
[18:04:02.339]                           for (restart in restarts) {
[18:04:02.339]                             name <- restart$name
[18:04:02.339]                             if (is.null(name)) 
[18:04:02.339]                               next
[18:04:02.339]                             if (!grepl(pattern, name)) 
[18:04:02.339]                               next
[18:04:02.339]                             invokeRestart(restart)
[18:04:02.339]                             muffled <- TRUE
[18:04:02.339]                             break
[18:04:02.339]                           }
[18:04:02.339]                         }
[18:04:02.339]                       }
[18:04:02.339]                       invisible(muffled)
[18:04:02.339]                     }
[18:04:02.339]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.339]                   }
[18:04:02.339]                 }
[18:04:02.339]                 else {
[18:04:02.339]                   if (TRUE) {
[18:04:02.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.339]                     {
[18:04:02.339]                       inherits <- base::inherits
[18:04:02.339]                       invokeRestart <- base::invokeRestart
[18:04:02.339]                       is.null <- base::is.null
[18:04:02.339]                       muffled <- FALSE
[18:04:02.339]                       if (inherits(cond, "message")) {
[18:04:02.339]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.339]                         if (muffled) 
[18:04:02.339]                           invokeRestart("muffleMessage")
[18:04:02.339]                       }
[18:04:02.339]                       else if (inherits(cond, "warning")) {
[18:04:02.339]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.339]                         if (muffled) 
[18:04:02.339]                           invokeRestart("muffleWarning")
[18:04:02.339]                       }
[18:04:02.339]                       else if (inherits(cond, "condition")) {
[18:04:02.339]                         if (!is.null(pattern)) {
[18:04:02.339]                           computeRestarts <- base::computeRestarts
[18:04:02.339]                           grepl <- base::grepl
[18:04:02.339]                           restarts <- computeRestarts(cond)
[18:04:02.339]                           for (restart in restarts) {
[18:04:02.339]                             name <- restart$name
[18:04:02.339]                             if (is.null(name)) 
[18:04:02.339]                               next
[18:04:02.339]                             if (!grepl(pattern, name)) 
[18:04:02.339]                               next
[18:04:02.339]                             invokeRestart(restart)
[18:04:02.339]                             muffled <- TRUE
[18:04:02.339]                             break
[18:04:02.339]                           }
[18:04:02.339]                         }
[18:04:02.339]                       }
[18:04:02.339]                       invisible(muffled)
[18:04:02.339]                     }
[18:04:02.339]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.339]                   }
[18:04:02.339]                 }
[18:04:02.339]             }
[18:04:02.339]         }))
[18:04:02.339]     }, error = function(ex) {
[18:04:02.339]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:02.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.339]                 ...future.rng), started = ...future.startTime, 
[18:04:02.339]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:02.339]             version = "1.8"), class = "FutureResult")
[18:04:02.339]     }, finally = {
[18:04:02.339]         if (!identical(...future.workdir, getwd())) 
[18:04:02.339]             setwd(...future.workdir)
[18:04:02.339]         {
[18:04:02.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:02.339]                 ...future.oldOptions$nwarnings <- NULL
[18:04:02.339]             }
[18:04:02.339]             base::options(...future.oldOptions)
[18:04:02.339]             if (.Platform$OS.type == "windows") {
[18:04:02.339]                 old_names <- names(...future.oldEnvVars)
[18:04:02.339]                 envs <- base::Sys.getenv()
[18:04:02.339]                 names <- names(envs)
[18:04:02.339]                 common <- intersect(names, old_names)
[18:04:02.339]                 added <- setdiff(names, old_names)
[18:04:02.339]                 removed <- setdiff(old_names, names)
[18:04:02.339]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:02.339]                   envs[common]]
[18:04:02.339]                 NAMES <- toupper(changed)
[18:04:02.339]                 args <- list()
[18:04:02.339]                 for (kk in seq_along(NAMES)) {
[18:04:02.339]                   name <- changed[[kk]]
[18:04:02.339]                   NAME <- NAMES[[kk]]
[18:04:02.339]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.339]                     next
[18:04:02.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.339]                 }
[18:04:02.339]                 NAMES <- toupper(added)
[18:04:02.339]                 for (kk in seq_along(NAMES)) {
[18:04:02.339]                   name <- added[[kk]]
[18:04:02.339]                   NAME <- NAMES[[kk]]
[18:04:02.339]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.339]                     next
[18:04:02.339]                   args[[name]] <- ""
[18:04:02.339]                 }
[18:04:02.339]                 NAMES <- toupper(removed)
[18:04:02.339]                 for (kk in seq_along(NAMES)) {
[18:04:02.339]                   name <- removed[[kk]]
[18:04:02.339]                   NAME <- NAMES[[kk]]
[18:04:02.339]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.339]                     next
[18:04:02.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.339]                 }
[18:04:02.339]                 if (length(args) > 0) 
[18:04:02.339]                   base::do.call(base::Sys.setenv, args = args)
[18:04:02.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:02.339]             }
[18:04:02.339]             else {
[18:04:02.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:02.339]             }
[18:04:02.339]             {
[18:04:02.339]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:02.339]                   0L) {
[18:04:02.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:02.339]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:02.339]                   base::options(opts)
[18:04:02.339]                 }
[18:04:02.339]                 {
[18:04:02.339]                   {
[18:04:02.339]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:02.339]                     NULL
[18:04:02.339]                   }
[18:04:02.339]                   options(future.plan = NULL)
[18:04:02.339]                   if (is.na(NA_character_)) 
[18:04:02.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:02.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:02.339]                     .init = FALSE)
[18:04:02.339]                 }
[18:04:02.339]             }
[18:04:02.339]         }
[18:04:02.339]     })
[18:04:02.339]     if (TRUE) {
[18:04:02.339]         base::sink(type = "output", split = FALSE)
[18:04:02.339]         if (TRUE) {
[18:04:02.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:02.339]         }
[18:04:02.339]         else {
[18:04:02.339]             ...future.result["stdout"] <- base::list(NULL)
[18:04:02.339]         }
[18:04:02.339]         base::close(...future.stdout)
[18:04:02.339]         ...future.stdout <- NULL
[18:04:02.339]     }
[18:04:02.339]     ...future.result$conditions <- ...future.conditions
[18:04:02.339]     ...future.result$finished <- base::Sys.time()
[18:04:02.339]     ...future.result
[18:04:02.339] }
[18:04:02.345] MultisessionFuture started
[18:04:02.346] - Launch lazy future ... done
[18:04:02.346] run() for ‘MultisessionFuture’ ... done
[18:04:02.346] result() for ClusterFuture ...
[18:04:02.346] receiveMessageFromWorker() for ClusterFuture ...
[18:04:02.347] - Validating connection of MultisessionFuture
[18:04:02.417] - received message: FutureResult
[18:04:02.418] - Received FutureResult
[18:04:02.418] - Erased future from FutureRegistry
[18:04:02.418] result() for ClusterFuture ...
[18:04:02.419] - result already collected: FutureResult
[18:04:02.419] result() for ClusterFuture ... done
[18:04:02.419] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:02.419] result() for ClusterFuture ... done
[18:04:02.419] result() for ClusterFuture ...
[18:04:02.420] - result already collected: FutureResult
[18:04:02.420] result() for ClusterFuture ... done
a = 10
[18:04:02.420] getGlobalsAndPackages() ...
[18:04:02.421] Searching for globals...
[18:04:02.422] - globals found: [3] ‘{’, ‘+’, ‘a’
[18:04:02.423] Searching for globals ... DONE
[18:04:02.423] Resolving globals: FALSE
[18:04:02.424] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:02.424] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:04:02.425] - globals: [1] ‘a’
[18:04:02.425] 
[18:04:02.425] getGlobalsAndPackages() ... DONE
[18:04:02.426] run() for ‘Future’ ...
[18:04:02.426] - state: ‘created’
[18:04:02.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:02.450] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:02.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:02.451]   - Field: ‘node’
[18:04:02.451]   - Field: ‘label’
[18:04:02.451]   - Field: ‘local’
[18:04:02.451]   - Field: ‘owner’
[18:04:02.451]   - Field: ‘envir’
[18:04:02.452]   - Field: ‘workers’
[18:04:02.452]   - Field: ‘packages’
[18:04:02.452]   - Field: ‘gc’
[18:04:02.452]   - Field: ‘conditions’
[18:04:02.452]   - Field: ‘persistent’
[18:04:02.453]   - Field: ‘expr’
[18:04:02.453]   - Field: ‘uuid’
[18:04:02.453]   - Field: ‘seed’
[18:04:02.453]   - Field: ‘version’
[18:04:02.453]   - Field: ‘result’
[18:04:02.454]   - Field: ‘asynchronous’
[18:04:02.454]   - Field: ‘calls’
[18:04:02.454]   - Field: ‘globals’
[18:04:02.454]   - Field: ‘stdout’
[18:04:02.454]   - Field: ‘earlySignal’
[18:04:02.455]   - Field: ‘lazy’
[18:04:02.455]   - Field: ‘state’
[18:04:02.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:02.455] - Launch lazy future ...
[18:04:02.456] Packages needed by the future expression (n = 0): <none>
[18:04:02.456] Packages needed by future strategies (n = 0): <none>
[18:04:02.457] {
[18:04:02.457]     {
[18:04:02.457]         {
[18:04:02.457]             ...future.startTime <- base::Sys.time()
[18:04:02.457]             {
[18:04:02.457]                 {
[18:04:02.457]                   {
[18:04:02.457]                     {
[18:04:02.457]                       base::local({
[18:04:02.457]                         has_future <- base::requireNamespace("future", 
[18:04:02.457]                           quietly = TRUE)
[18:04:02.457]                         if (has_future) {
[18:04:02.457]                           ns <- base::getNamespace("future")
[18:04:02.457]                           version <- ns[[".package"]][["version"]]
[18:04:02.457]                           if (is.null(version)) 
[18:04:02.457]                             version <- utils::packageVersion("future")
[18:04:02.457]                         }
[18:04:02.457]                         else {
[18:04:02.457]                           version <- NULL
[18:04:02.457]                         }
[18:04:02.457]                         if (!has_future || version < "1.8.0") {
[18:04:02.457]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:02.457]                             "", base::R.version$version.string), 
[18:04:02.457]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:02.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:02.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:02.457]                               "release", "version")], collapse = " "), 
[18:04:02.457]                             hostname = base::Sys.info()[["nodename"]])
[18:04:02.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:02.457]                             info)
[18:04:02.457]                           info <- base::paste(info, collapse = "; ")
[18:04:02.457]                           if (!has_future) {
[18:04:02.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:02.457]                               info)
[18:04:02.457]                           }
[18:04:02.457]                           else {
[18:04:02.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:02.457]                               info, version)
[18:04:02.457]                           }
[18:04:02.457]                           base::stop(msg)
[18:04:02.457]                         }
[18:04:02.457]                       })
[18:04:02.457]                     }
[18:04:02.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:02.457]                     base::options(mc.cores = 1L)
[18:04:02.457]                   }
[18:04:02.457]                   ...future.strategy.old <- future::plan("list")
[18:04:02.457]                   options(future.plan = NULL)
[18:04:02.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:02.457]                 }
[18:04:02.457]                 ...future.workdir <- getwd()
[18:04:02.457]             }
[18:04:02.457]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:02.457]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:02.457]         }
[18:04:02.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:02.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:02.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:02.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:02.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:02.457]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:02.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:02.457]             base::names(...future.oldOptions))
[18:04:02.457]     }
[18:04:02.457]     if (FALSE) {
[18:04:02.457]     }
[18:04:02.457]     else {
[18:04:02.457]         if (TRUE) {
[18:04:02.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:02.457]                 open = "w")
[18:04:02.457]         }
[18:04:02.457]         else {
[18:04:02.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:02.457]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:02.457]         }
[18:04:02.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:02.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:02.457]             base::sink(type = "output", split = FALSE)
[18:04:02.457]             base::close(...future.stdout)
[18:04:02.457]         }, add = TRUE)
[18:04:02.457]     }
[18:04:02.457]     ...future.frame <- base::sys.nframe()
[18:04:02.457]     ...future.conditions <- base::list()
[18:04:02.457]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:02.457]     if (FALSE) {
[18:04:02.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:02.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:02.457]     }
[18:04:02.457]     ...future.result <- base::tryCatch({
[18:04:02.457]         base::withCallingHandlers({
[18:04:02.457]             ...future.value <- base::withVisible(base::local({
[18:04:02.457]                 ...future.makeSendCondition <- base::local({
[18:04:02.457]                   sendCondition <- NULL
[18:04:02.457]                   function(frame = 1L) {
[18:04:02.457]                     if (is.function(sendCondition)) 
[18:04:02.457]                       return(sendCondition)
[18:04:02.457]                     ns <- getNamespace("parallel")
[18:04:02.457]                     if (exists("sendData", mode = "function", 
[18:04:02.457]                       envir = ns)) {
[18:04:02.457]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:02.457]                         envir = ns)
[18:04:02.457]                       envir <- sys.frame(frame)
[18:04:02.457]                       master <- NULL
[18:04:02.457]                       while (!identical(envir, .GlobalEnv) && 
[18:04:02.457]                         !identical(envir, emptyenv())) {
[18:04:02.457]                         if (exists("master", mode = "list", envir = envir, 
[18:04:02.457]                           inherits = FALSE)) {
[18:04:02.457]                           master <- get("master", mode = "list", 
[18:04:02.457]                             envir = envir, inherits = FALSE)
[18:04:02.457]                           if (inherits(master, c("SOCKnode", 
[18:04:02.457]                             "SOCK0node"))) {
[18:04:02.457]                             sendCondition <<- function(cond) {
[18:04:02.457]                               data <- list(type = "VALUE", value = cond, 
[18:04:02.457]                                 success = TRUE)
[18:04:02.457]                               parallel_sendData(master, data)
[18:04:02.457]                             }
[18:04:02.457]                             return(sendCondition)
[18:04:02.457]                           }
[18:04:02.457]                         }
[18:04:02.457]                         frame <- frame + 1L
[18:04:02.457]                         envir <- sys.frame(frame)
[18:04:02.457]                       }
[18:04:02.457]                     }
[18:04:02.457]                     sendCondition <<- function(cond) NULL
[18:04:02.457]                   }
[18:04:02.457]                 })
[18:04:02.457]                 withCallingHandlers({
[18:04:02.457]                   {
[18:04:02.457]                     a + 1
[18:04:02.457]                   }
[18:04:02.457]                 }, immediateCondition = function(cond) {
[18:04:02.457]                   sendCondition <- ...future.makeSendCondition()
[18:04:02.457]                   sendCondition(cond)
[18:04:02.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.457]                   {
[18:04:02.457]                     inherits <- base::inherits
[18:04:02.457]                     invokeRestart <- base::invokeRestart
[18:04:02.457]                     is.null <- base::is.null
[18:04:02.457]                     muffled <- FALSE
[18:04:02.457]                     if (inherits(cond, "message")) {
[18:04:02.457]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:02.457]                       if (muffled) 
[18:04:02.457]                         invokeRestart("muffleMessage")
[18:04:02.457]                     }
[18:04:02.457]                     else if (inherits(cond, "warning")) {
[18:04:02.457]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:02.457]                       if (muffled) 
[18:04:02.457]                         invokeRestart("muffleWarning")
[18:04:02.457]                     }
[18:04:02.457]                     else if (inherits(cond, "condition")) {
[18:04:02.457]                       if (!is.null(pattern)) {
[18:04:02.457]                         computeRestarts <- base::computeRestarts
[18:04:02.457]                         grepl <- base::grepl
[18:04:02.457]                         restarts <- computeRestarts(cond)
[18:04:02.457]                         for (restart in restarts) {
[18:04:02.457]                           name <- restart$name
[18:04:02.457]                           if (is.null(name)) 
[18:04:02.457]                             next
[18:04:02.457]                           if (!grepl(pattern, name)) 
[18:04:02.457]                             next
[18:04:02.457]                           invokeRestart(restart)
[18:04:02.457]                           muffled <- TRUE
[18:04:02.457]                           break
[18:04:02.457]                         }
[18:04:02.457]                       }
[18:04:02.457]                     }
[18:04:02.457]                     invisible(muffled)
[18:04:02.457]                   }
[18:04:02.457]                   muffleCondition(cond)
[18:04:02.457]                 })
[18:04:02.457]             }))
[18:04:02.457]             future::FutureResult(value = ...future.value$value, 
[18:04:02.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.457]                   ...future.rng), globalenv = if (FALSE) 
[18:04:02.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:02.457]                     ...future.globalenv.names))
[18:04:02.457]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:02.457]         }, condition = base::local({
[18:04:02.457]             c <- base::c
[18:04:02.457]             inherits <- base::inherits
[18:04:02.457]             invokeRestart <- base::invokeRestart
[18:04:02.457]             length <- base::length
[18:04:02.457]             list <- base::list
[18:04:02.457]             seq.int <- base::seq.int
[18:04:02.457]             signalCondition <- base::signalCondition
[18:04:02.457]             sys.calls <- base::sys.calls
[18:04:02.457]             `[[` <- base::`[[`
[18:04:02.457]             `+` <- base::`+`
[18:04:02.457]             `<<-` <- base::`<<-`
[18:04:02.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:02.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:02.457]                   3L)]
[18:04:02.457]             }
[18:04:02.457]             function(cond) {
[18:04:02.457]                 is_error <- inherits(cond, "error")
[18:04:02.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:02.457]                   NULL)
[18:04:02.457]                 if (is_error) {
[18:04:02.457]                   sessionInformation <- function() {
[18:04:02.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:02.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:02.457]                       search = base::search(), system = base::Sys.info())
[18:04:02.457]                   }
[18:04:02.457]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:02.457]                     cond$call), session = sessionInformation(), 
[18:04:02.457]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:02.457]                   signalCondition(cond)
[18:04:02.457]                 }
[18:04:02.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:02.457]                 "immediateCondition"))) {
[18:04:02.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:02.457]                   ...future.conditions[[length(...future.conditions) + 
[18:04:02.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:02.457]                   if (TRUE && !signal) {
[18:04:02.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.457]                     {
[18:04:02.457]                       inherits <- base::inherits
[18:04:02.457]                       invokeRestart <- base::invokeRestart
[18:04:02.457]                       is.null <- base::is.null
[18:04:02.457]                       muffled <- FALSE
[18:04:02.457]                       if (inherits(cond, "message")) {
[18:04:02.457]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.457]                         if (muffled) 
[18:04:02.457]                           invokeRestart("muffleMessage")
[18:04:02.457]                       }
[18:04:02.457]                       else if (inherits(cond, "warning")) {
[18:04:02.457]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.457]                         if (muffled) 
[18:04:02.457]                           invokeRestart("muffleWarning")
[18:04:02.457]                       }
[18:04:02.457]                       else if (inherits(cond, "condition")) {
[18:04:02.457]                         if (!is.null(pattern)) {
[18:04:02.457]                           computeRestarts <- base::computeRestarts
[18:04:02.457]                           grepl <- base::grepl
[18:04:02.457]                           restarts <- computeRestarts(cond)
[18:04:02.457]                           for (restart in restarts) {
[18:04:02.457]                             name <- restart$name
[18:04:02.457]                             if (is.null(name)) 
[18:04:02.457]                               next
[18:04:02.457]                             if (!grepl(pattern, name)) 
[18:04:02.457]                               next
[18:04:02.457]                             invokeRestart(restart)
[18:04:02.457]                             muffled <- TRUE
[18:04:02.457]                             break
[18:04:02.457]                           }
[18:04:02.457]                         }
[18:04:02.457]                       }
[18:04:02.457]                       invisible(muffled)
[18:04:02.457]                     }
[18:04:02.457]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.457]                   }
[18:04:02.457]                 }
[18:04:02.457]                 else {
[18:04:02.457]                   if (TRUE) {
[18:04:02.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:02.457]                     {
[18:04:02.457]                       inherits <- base::inherits
[18:04:02.457]                       invokeRestart <- base::invokeRestart
[18:04:02.457]                       is.null <- base::is.null
[18:04:02.457]                       muffled <- FALSE
[18:04:02.457]                       if (inherits(cond, "message")) {
[18:04:02.457]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:02.457]                         if (muffled) 
[18:04:02.457]                           invokeRestart("muffleMessage")
[18:04:02.457]                       }
[18:04:02.457]                       else if (inherits(cond, "warning")) {
[18:04:02.457]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:02.457]                         if (muffled) 
[18:04:02.457]                           invokeRestart("muffleWarning")
[18:04:02.457]                       }
[18:04:02.457]                       else if (inherits(cond, "condition")) {
[18:04:02.457]                         if (!is.null(pattern)) {
[18:04:02.457]                           computeRestarts <- base::computeRestarts
[18:04:02.457]                           grepl <- base::grepl
[18:04:02.457]                           restarts <- computeRestarts(cond)
[18:04:02.457]                           for (restart in restarts) {
[18:04:02.457]                             name <- restart$name
[18:04:02.457]                             if (is.null(name)) 
[18:04:02.457]                               next
[18:04:02.457]                             if (!grepl(pattern, name)) 
[18:04:02.457]                               next
[18:04:02.457]                             invokeRestart(restart)
[18:04:02.457]                             muffled <- TRUE
[18:04:02.457]                             break
[18:04:02.457]                           }
[18:04:02.457]                         }
[18:04:02.457]                       }
[18:04:02.457]                       invisible(muffled)
[18:04:02.457]                     }
[18:04:02.457]                     muffleCondition(cond, pattern = "^muffle")
[18:04:02.457]                   }
[18:04:02.457]                 }
[18:04:02.457]             }
[18:04:02.457]         }))
[18:04:02.457]     }, error = function(ex) {
[18:04:02.457]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:02.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:02.457]                 ...future.rng), started = ...future.startTime, 
[18:04:02.457]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:02.457]             version = "1.8"), class = "FutureResult")
[18:04:02.457]     }, finally = {
[18:04:02.457]         if (!identical(...future.workdir, getwd())) 
[18:04:02.457]             setwd(...future.workdir)
[18:04:02.457]         {
[18:04:02.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:02.457]                 ...future.oldOptions$nwarnings <- NULL
[18:04:02.457]             }
[18:04:02.457]             base::options(...future.oldOptions)
[18:04:02.457]             if (.Platform$OS.type == "windows") {
[18:04:02.457]                 old_names <- names(...future.oldEnvVars)
[18:04:02.457]                 envs <- base::Sys.getenv()
[18:04:02.457]                 names <- names(envs)
[18:04:02.457]                 common <- intersect(names, old_names)
[18:04:02.457]                 added <- setdiff(names, old_names)
[18:04:02.457]                 removed <- setdiff(old_names, names)
[18:04:02.457]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:02.457]                   envs[common]]
[18:04:02.457]                 NAMES <- toupper(changed)
[18:04:02.457]                 args <- list()
[18:04:02.457]                 for (kk in seq_along(NAMES)) {
[18:04:02.457]                   name <- changed[[kk]]
[18:04:02.457]                   NAME <- NAMES[[kk]]
[18:04:02.457]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.457]                     next
[18:04:02.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.457]                 }
[18:04:02.457]                 NAMES <- toupper(added)
[18:04:02.457]                 for (kk in seq_along(NAMES)) {
[18:04:02.457]                   name <- added[[kk]]
[18:04:02.457]                   NAME <- NAMES[[kk]]
[18:04:02.457]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.457]                     next
[18:04:02.457]                   args[[name]] <- ""
[18:04:02.457]                 }
[18:04:02.457]                 NAMES <- toupper(removed)
[18:04:02.457]                 for (kk in seq_along(NAMES)) {
[18:04:02.457]                   name <- removed[[kk]]
[18:04:02.457]                   NAME <- NAMES[[kk]]
[18:04:02.457]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:02.457]                     next
[18:04:02.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:02.457]                 }
[18:04:02.457]                 if (length(args) > 0) 
[18:04:02.457]                   base::do.call(base::Sys.setenv, args = args)
[18:04:02.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:02.457]             }
[18:04:02.457]             else {
[18:04:02.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:02.457]             }
[18:04:02.457]             {
[18:04:02.457]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:02.457]                   0L) {
[18:04:02.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:02.457]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:02.457]                   base::options(opts)
[18:04:02.457]                 }
[18:04:02.457]                 {
[18:04:02.457]                   {
[18:04:02.457]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:02.457]                     NULL
[18:04:02.457]                   }
[18:04:02.457]                   options(future.plan = NULL)
[18:04:02.457]                   if (is.na(NA_character_)) 
[18:04:02.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:02.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:02.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:02.457]                     .init = FALSE)
[18:04:02.457]                 }
[18:04:02.457]             }
[18:04:02.457]         }
[18:04:02.457]     })
[18:04:02.457]     if (TRUE) {
[18:04:02.457]         base::sink(type = "output", split = FALSE)
[18:04:02.457]         if (TRUE) {
[18:04:02.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:02.457]         }
[18:04:02.457]         else {
[18:04:02.457]             ...future.result["stdout"] <- base::list(NULL)
[18:04:02.457]         }
[18:04:02.457]         base::close(...future.stdout)
[18:04:02.457]         ...future.stdout <- NULL
[18:04:02.457]     }
[18:04:02.457]     ...future.result$conditions <- ...future.conditions
[18:04:02.457]     ...future.result$finished <- base::Sys.time()
[18:04:02.457]     ...future.result
[18:04:02.457] }
[18:04:02.462] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:04:02.462] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:04:02.463] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:04:02.463] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:04:02.464] MultisessionFuture started
[18:04:02.465] - Launch lazy future ... done
[18:04:02.465] run() for ‘MultisessionFuture’ ... done
[18:04:02.465] result() for ClusterFuture ...
[18:04:02.465] receiveMessageFromWorker() for ClusterFuture ...
[18:04:02.466] - Validating connection of MultisessionFuture
[18:04:02.508] - received message: FutureResult
[18:04:02.509] - Received FutureResult
[18:04:02.509] - Erased future from FutureRegistry
[18:04:02.509] result() for ClusterFuture ...
[18:04:02.510] - result already collected: FutureResult
[18:04:02.510] result() for ClusterFuture ... done
[18:04:02.510] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:02.510] result() for ClusterFuture ... done
[18:04:02.511] result() for ClusterFuture ...
[18:04:02.511] - result already collected: FutureResult
[18:04:02.511] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[18:04:02.513] plan(): Setting new future strategy stack:
[18:04:02.513] List of future strategies:
[18:04:02.513] 1. FutureStrategy:
[18:04:02.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:02.513]    - tweaked: FALSE
[18:04:02.513]    - call: future::plan(oplan)
[18:04:02.515] plan(): nbrOfWorkers() = 1
> 
